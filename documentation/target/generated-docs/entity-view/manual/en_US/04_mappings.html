<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mappings</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#mappings">Mappings</a>
<ul class="sectlevel2">
<li><a href="#mapping-types">Mapping types</a></li>
<li><a href="#mapping-defaults">Mapping defaults</a></li>
<li><a href="#anchor-id-mappings">Id mappings</a></li>
<li><a href="#anchor-flat-view-id-mappings">Flat view id mappings</a></li>
<li><a href="#basic-mappings">Basic mappings</a></li>
<li><a href="#subview-mappings">Subview mappings</a></li>
<li><a href="#subquery-mappings">Subquery mappings</a></li>
<li><a href="#anchor-parameter-mappings">Parameter mappings</a></li>
<li><a href="#entity-mappings">Entity mappings</a></li>
<li><a href="#collection-mappings">Collection mappings</a></li>
<li><a href="#singular-collection-type-mappings">Singular collection type mappings</a></li>
<li><a href="#anchor-correlation-mappings">Correlated mappings</a></li>
<li><a href="#special-method-attributes">Special method attributes</a></li>
<li><a href="#mapping-expression-extensions">Mapping expression extensions</a></li>
<li><a href="#anchor-constructor-mapping">Entity View constructor mapping</a></li>
<li><a href="#inheritance-mapping">Inheritance mapping</a></li>
<li><a href="#inheritance-subview-mapping">Inheritance subview mapping</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="mappings"><a class="anchor" href="#mappings"></a>Mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As already mentioned in the <a href="#Getting started">[Getting started]</a> section, the entity view module builds up on the core module.
Some of the basics like <a href="{core_doc}#implicit-joins">implicit joins</a>
and the basic <a href="{core_doc}#expressions">expression structure</a> should be known to understand all of the following mapping examples.</p>
</div>
<div class="paragraph">
<p>Entity views are to entities in ORM, what table views are to tables in an RDBMS. They represent projections on the entity model.
In a sense you can say that entity views are DTOs 2.0 or DTOs done right.</p>
</div>
<div class="paragraph">
<p>One of the unique features of entity views is that it <strong>only</strong> imposes a structure and the projections, but the base query defines the data source.
{projectname} tried to reduce as much of the boilerplate as possible for defining the structure and the projections by employing a convention over configuration approach.</p>
</div>
<div class="paragraph">
<p>The result of these efforts is that entity views are defined as interfaces or abstract classes mostly containing just getter definitions that serve as attribute definitions.
To declare that an interface or an abstract class as entity view, you have to annotate it and specify the entity class for which this entity view provides projections.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView { ... }</pre>
</div>
</div>
<div class="paragraph">
<p>So an entity view can be seen as a named wrapper for a bunch of attributes, where every attribute has some kind of mapping that is based on the attributes the entity type offers.
An attribute is declared by defining a public abstract method in an entity view i.e. every abstract method is considered to be an attribute.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Since every method of an interface is abstract and public, you can omit the <code>abstract</code> and <code>public</code> keywords.
In this simple example you can see that the <code>CatView</code> has an attribute named <code>name</code>. The implicit mapping for the attribute is the attribute name itself, so <code>name</code>.
This means that the entity view attribute <code>name</code> declared by the abstract method <code>getName()</code> is mapped to the entity attribute <code>name</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since entity views and their mappings are validated during startup against the entity model, you should see any mapping related runtime errors and can be sure it works if it doesn&#8217;t fail to start
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the nice things about using interfaces is that you can have multiple inheritance. If you separate concerns in separate <em>feature interfaces</em>,
you can effectively make use of multiple inheritance.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">interface NameView {
    String getName();
}

interface AgeView {
    Long getAge();
}

@EntityView(Cat.class)
interface CatView extends NameView, AgeView {
}</pre>
</div>
</div>
<div class="paragraph">
<p>In this example <code>CatView</code> has two attributes, <code>name</code> and <code>age</code>. Even though the interfaces are not entity views, they could have custom mappings.</p>
</div>
<div class="sect2">
<h3 id="mapping-types"><a class="anchor" href="#mapping-types"></a>Mapping types</h3>
<div class="paragraph">
<p>So far, you have mostly seen basic attribute mappings in entity views, but there is actually support for far many mapping types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic mappings - maps basic attributes from entities into entity views</p>
</li>
<li>
<p>Subview mappings - maps a *ToOne relation of an entity to an entity view</p>
</li>
<li>
<p>Flat view mappings - maps an embeddable of an entity to a flat entity view</p>
</li>
<li>
<p>Subquery mappings - maps the result of a subquery to a basic attribute into entity views</p>
</li>
<li>
<p>Parameter mappings - maps named query parameters into an entity view</p>
</li>
<li>
<p>Entity mappings - maps *ToOne or *ToMany relations of an entity as is into an entity view</p>
</li>
<li>
<p>Collection mappings - maps *ToMany relations of an entity into an entity view with support for basic, subview and embeddable types</p>
</li>
<li>
<p>Correlated mappings - correlates an entity type by some key and maps it or an attribute of it into an entity view as subview or basic type respectively</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In general we do not recommend to make extensive use of entity mappings as it defeats the purpose of entity views and can lead to lazy loading issues
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Apart from mapping attributes, it is also possible have a constructor and map parameters when using an abstract class.
One of the biggest use cases for this is for doing further transformations on the data that can&#8217;t be pushed to the DBMS like e.g. money formatting.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping-defaults"><a class="anchor" href="#mapping-defaults"></a>Mapping defaults</h3>
<div class="paragraph">
<p>As mentioned before, the entity view module implements a convention over configuration approach and thus has some smart defaults for mappings.
Whenever an attribute(getter method) without a mapping annotation is encountered, a default mapping to the same named entity attribute will be created.
If there is none, it will obviously report an error.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-id-mappings"><a class="anchor" href="#anchor-id-mappings"></a>Id mappings</h3>
<div class="paragraph">
<p>Id mappings declare that an attribute represents the identifier i.e. can be used to uniquely identify an entity view object.
The id mapping is declared by annotating the desired attribute with <code>@IdMapping</code> and optionally specifying the mapping path.
Having an id attribute allows an entity view to map collections, be mapped in collections and gives an entity view object a meaningful identity.
If an entity view has no id mapping, it is considered to be a flat view which probably only makes sense for scalar results or embedded objects.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is generally recommended to always declare an id mapping if possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an id mapping is present, the generated entity view implementation&#8217;s equals-hashCode implementation will be based on it.
Otherwise it will consider <strong>all</strong> attributes in the equals-hashCode implementation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-flat-view-id-mappings"><a class="anchor" href="#anchor-flat-view-id-mappings"></a>Flat view id mappings</h3>
<div class="paragraph">
<p>A flat view id mapping is given when the type of the id attribute is a flat view type. This is the case when the view type has no id declared.
It&#8217;s very similar to subview mappings and is mostly used when working with JPA embeddable types. Imagine the following model for illustration purposes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatIdView {
    String getName();
}

@EntityView(Cat.class)
interface CatView {
    @IdMapping("this")
    CatIdView getId();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This example already makes use of many concepts. It declares the <code>CatIdView</code> as flat view with a basic mapping and the <code>CatView</code> with a flat view id.
The mapping for the flat view id in <code>CatView</code> uses to the <a href="#this"><code>this</code></a> expression extension to allow the flat view to be based on the same entity that is backing the <code>CatView</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since flat view types will consider <strong>all</strong> attributes in the equals-hashCode implementation, the type shouldn&#8217;t contain unnecessary attributes if possible.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="basic-mappings"><a class="anchor" href="#basic-mappings"></a>Basic mappings</h3>
<div class="paragraph">
<p>A basic mapping is declared by annotating the desired attribute with <code>@Mapping</code> and specifying the mapping expression.
An attribute that has no mapping annotations is only considered to have a basic mapping if it is of a basic type like e.g. Integer. Without a mapping annotation, the default mapping rules apply.
In general, every non-collection and non-managed type is considered to be basic. Managed types are JPA managed types and entity view types.</p>
</div>
<div class="paragraph">
<p>Although most example only use path expressions for the mapping, it is actually allowed to use any <a href="{core_doc}#expressions">scalar expression</a> that JPQL or {projectname} allows.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @Mapping("UPPER(name)")
    String getUpperName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>As you might expect, the expression <code>UPPER(name)</code> will upper-case the name, so <code>getUpperName()</code> will return the upper-cased name.
Applying such an entity view on a simple query builder will show what happens behind the scenes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;CatView&gt; result = evm.applySetting(
        EntityViewSetting.create(CatView.class),
        cbf.create(em, Cat.class)
    ).getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, UPPER(cat.name)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The expression in the mapping ends up as select item in the query just as expected.</p>
</div>
</div>
<div class="sect2">
<h3 id="subview-mappings"><a class="anchor" href="#subview-mappings"></a>Subview mappings</h3>
<div class="paragraph">
<p>Subview and embeddable view mappings are similar to basic mappings in the sense that the same rules apply, except for the allowed mappings.
Since these mappings get their data from objects of managed types, only path expressions are allowed for their mappings.
Path expressions can have arbitrary depth i.e. multiple de-references like <code>relation.subRelation.otherRelation</code> and path elements can be of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple path elements that refer to entity type attributes</p>
</li>
<li>
<p><code>TREAT</code> expression like <code>TREAT(..).subRelation</code></p>
</li>
<li>
<p>Qualified expression like <code>KEY(..).subRelation</code></p>
</li>
<li>
<p>Array expression like <code>relation[:param].subRelation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A subview mapping is given when the type of the attribute is a entity view type.
Since a entity view is always declared for a specific entity type, the target type of the subview mapping and the entity view&#8217;s entity type must be compatible.
This means that you could apply a <code>AnimalView</code> to a <code>Cat</code> if it extends <code>Animal</code> but can&#8217;t apply a <code>PersonView</code> since it&#8217;s not compatible i.e. <code>Cat</code> is not a subtype of <code>Person</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
interface PersonView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Animal.class)
interface AnimalView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    AnimalView getFather();
}</pre>
</div>
</div>
<div class="paragraph">
<p>As you might imagine, the <code>CatView</code> will additionally select attributes of the father relation since they are requested by the <code>AnimalView</code>.
In order to understand the following generated query, you should know what an <a href="{core_doc}#implicit-joins">implicit join</a> does and how entity views make use of such implicit joins.</p>
</div>
<div class="paragraph">
<p>Behind the scenes, the entity views runtime will apply a select on the criteria builder for the expressions <code>cat.id</code>, <code>father.id</code> and <code>father.name</code>.
The expression <code>father.name</code> accesses an entity attribute is only accessible when actually joining the relation. This is why an implicit/default join is generated for the father relation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, father_1.id, father_1.name
FROM Cat cat
LEFT JOIN cat.father father_1</pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>father</code> relation is optional or nullable, a (default) left join is created due to the rules of <a href="{core_doc}#model-awareness">model awareness</a> in implicit joins.
This is a perfect fit for entity views as the subview object will be simply <code>null</code> if a cat has no father. If the implicit join worked like JPQL defines it, an inner join would have to be created.
An inner join would mean that cats without a father would get filtered out which is an undesirable effect since we only want a projection on top of a base query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Subviews can in turn have subviews again, so there is no limitation regarding the depth. The only requirement is that there is no cycle.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="flat-view-mappings"><a class="anchor" href="#flat-view-mappings"></a>Flat view mappings</h4>
<div class="paragraph">
<p>A flat view mapping is given when the type of the attribute is a flat view type. This is the case when the entity view has no id declared.
It&#8217;s very similar to subview mappings and is mostly used when working with JPA embeddable types.</p>
</div>
<div class="paragraph">
<p>Note that a flat view can be used like a normal view except when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is used as view root i.e. the flat view is the entity view type used in <code>EntityViewSetting</code>,</p>
</li>
<li>
<p>it is embedded in a flat view which in turn is the view root i.e. the parent is a flat view that is used in <code>EntityViewSetting</code></p>
</li>
<li>
<p>or it is used as subview for a non-indexed collection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then the flat view can&#8217;t have collection attributes with fetch strategy <code>JOIN</code>.
The reason is that the elements of the collection can&#8217;t be matched with the flat view as it has no identity it can use for matching.</p>
</div>
<div class="paragraph">
<p>Imagine the following model for illustration purposes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Embeddable
class Name {
    String firstName;
    String lastName;
}

@Entity
class Person {
    @Id
    @GeneratedValue
    Long id;
    @Embedded
    Name name;
}

@EntityView(Name.class)
interface SimpleNameView {
    String getFirstName();
}

@EntityView(Person.class)
interface PersonView {
    @IdMapping
    Long getId();

    SimpleNameView getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Applying a <code>PersonView</code> would produce a query like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT person.id, person.name.firstName
FROM Person person</pre>
</div>
</div>
<div class="paragraph">
<p>Such a flat view can also be used with the <a href="#this"><code>this</code> expression</a> which is similar to JPAs <code>@Embedded</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A limitation in Hibernate actually requires the use of flat entity views for mapping of element collections i.e. you can map the element collection 1:1 to the entity view.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="subquery-mappings"><a class="anchor" href="#subquery-mappings"></a>Subquery mappings</h3>
<div class="paragraph">
<p>Subquery mappings allow to map scalar subqueries into entity views and are declared by annotating the desired attribute with <code>@MappingSubquery</code> and specifying a <a href="{entity_view_jdoc}/persistence/view/SubqueryProvider.html"><code>SubqueryProvider</code></a>.
The following example should illustrate the usage:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @MappingSubquery(KittenCountSubqueryProvider.class)
    Long getKittenCount();

    class KittenCountSubqueryProvider implements SubqueryProvider {

        @Override
        public &lt;T&gt; T createSubquery(SubqueryInitiator&lt;T&gt; subqueryBuilder) {
            return subqueryBuilder.from(Cat.class, "subCat")
                    .select("COUNT(*)")
                    .whereOr()
                        .where("subCat.father.id").eqExpression("OUTER(id)")
                        .where("subCat.mother.id").eqExpression("OUTER(id)")
                    .endOr()
                .end();
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>This entity view already comes into contact with the <a href="{core_doc}">core</a> API for creating subqueries.
It produces just what it defines, a subquery in the select clause.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.father.id = cat.id
           OR subCat.mother.id = cat.id
    )
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>In the subquery provider before you saw the usage of <code>OUTER</code> which is gone in the final query.
This is because <code>OUTER</code> is a way to refer to attributes of the parent query root without having to refer to the concrete the query alias.
For more information on this check out the documentation of the <a href="{core_doc}#outer-function"><code>OUTER</code> function</a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The subquery was just used for illustration purposes and could be replaced with a basic mapping <code>SIZE(kittens)</code> which would also generate a more efficient query.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="anchor-parameter-mappings"><a class="anchor" href="#anchor-parameter-mappings"></a>Parameter mappings</h3>
<div class="paragraph">
<p>A parameter mapping is a convenient way to <em>inject</em> the values of query parameters or optional parameters into instances of an entity view.
Introducing a parameter mapping with <code>@MappingParameter</code> will introduce a <em>fake</em> select item. If a parameter is not used in a query, <code>NULL</code> will be injected into the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @MappingParameter("myParam")
    String getMyParam();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, NULLIF(1,1)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>Parameter mappings are probably most useful in <a href="#anchor-constructor-mapping">constructor mappings</a> where they can be used for some transformation logic.</p>
</div>
</div>
<div class="sect2">
<h3 id="entity-mappings"><a class="anchor" href="#entity-mappings"></a>Entity mappings</h3>
<div class="paragraph">
<p>Apart from having custom projections for entity or embeddable types through subviews, you can also map the JPA managed types directly.
You can use the <code>@Mapping</code> annotation if desired and map any path expression as singular or plural attribute(i.e. collection) with managed types.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    Cat getFather();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, father_1
FROM Cat cat
LEFT JOIN cat.father father_1</pre>
</div>
</div>
<div class="paragraph">
<p>Beware that when using managed types directly, you might run into <em>lazy loading</em> issues when accessing uninitialized/un-fetched properties of the entity.</p>
</div>
<div class="paragraph">
<p>You can however specify what properties should be fetched for such entity mappings by using the <code>fetches</code> configuration.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @Mapping(fetches = "kittens")
    Cat getFather();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will fetch the kittens of the father.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, father_1
FROM Cat cat
LEFT JOIN cat.father father_1
LEFT JOIN FETCH father_1.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="collection-mappings"><a class="anchor" href="#collection-mappings"></a>Collection mappings</h3>
<div class="paragraph">
<p>One of the most important features of the {projectname} entity view module is the possibility to map collections.
You can map collections defined in the entity model to collections in the entity view model in multiple ways.</p>
</div>
<div class="sect3">
<h4 id="simple-1-1-collection-mapping"><a class="anchor" href="#simple-1-1-collection-mapping"></a>Simple 1:1 collection mapping</h4>
<div class="paragraph">
<p>The simplest possible mapping is a 1:1 mapping of e.g. a *ToMany collection.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    Set&lt;Cat&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will simply join the <code>kittens</code> collection. During entity view construction the elements are collected and the result is flattened as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subset-basic-collection-mapping"><a class="anchor" href="#subset-basic-collection-mapping"></a>Subset basic collection mapping</h4>
<div class="paragraph">
<p>Most of the time, only a subset of the properties of a relation is needed. In case only a single property is required,
the use of <code>@Mapping</code> to refer to the property within a collection can be used.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @Mapping("kittens.name")
    Set&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will join the <code>kittens</code> collection and only select their <code>name</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subview-collection-mapping"><a class="anchor" href="#subview-collection-mapping"></a>Subview collection mapping</h4>
<div class="paragraph">
<p>For the cases when multiple properties of a relation are needed, you can also use subviews.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    Set&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Applying the <code>CatView</code> entity view will again join the <code>kittens</code> collection but this time select some more properties.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>A subview within a collection can have subviews and collections of subviews again i.e. there is no limit to nesting.</p>
</div>
</div>
<div class="sect3">
<h4 id="collection-type-re-mapping"><a class="anchor" href="#collection-type-re-mapping"></a>Collection type re-mapping</h4>
<div class="paragraph">
<p>Another nice feature of {projectname} entity views is the ability to re-map a collection to a different collection type.
In the entity model one might for example choose to always use a <code>java.util.Set</code> for mapping collections,
but to be able to make use of the elements in a UI, you might require e.g. a <code>java.util.List</code>.</p>
</div>
<div class="paragraph">
<p>Although the <code>kittens</code> relation in the <code>Cat</code> entity uses a <code>Set</code>, you can map the <code>kittens</code> as <code>List</code> in the <code>CatView</code>.
As you might expect, the order of the elements will then depend on the order of the query result.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    List&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>By executing the query with a custom <a href="{core_doc}#anchor-order-by-clause"><code>ORDER BY</code> clause</a>, the result order can be made deterministic.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;CatView&gt; result = entityViewManager.applySetting(
        EntityViewSetting.create(CatView.class),
        cb.create(Cat.class)
            .orderByAsc("name")
            .orderByAsc("kittens.name")
    ).getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1
ORDER BY cat.name       ASC NULLS LAST,
         kittens_1.name ASC NULLS LAST</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We do not recommend to rely on this behavior but instead make use of sorted collection mappings.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ordered-collection-mapping"><a class="anchor" href="#ordered-collection-mapping"></a>Ordered collection mapping</h4>
<div class="paragraph">
<p>Apart from changing the collection type to e.g. <code>List</code> it is also possible to get <em>ordered</em> results with sets.
By specifying <code>ordered = true</code> for the collection via the annotation <code>@CollectionMapping</code> you can force a set implementation that retains the insertion order like a <code>LinkedHashSet</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @CollectionMapping(ordered = true)
    Set&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The query doesn&#8217;t change, the only thing that does, is the implementation for the collection.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>This oviously only makes sense when used along with an <em>ORDER BY</em> clause that orders the result set deterministically.</p>
</div>
</div>
<div class="sect3">
<h4 id="sorted-collection-mapping"><a class="anchor" href="#sorted-collection-mapping"></a>Sorted collection mapping</h4>
<div class="paragraph">
<p>In addition to ordering, the following sorted collection types are supported</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SortedSet</code> and <code>NavigableSet</code></p>
</li>
<li>
<p><code>SortedMap</code> and <code>NavigableMap</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can specify the comparator for the collection via the annotation <code>@CollectionMapping</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();

    static class DefaultComparator implements Comparator&lt;SimpleCatView&gt; {

        @Override
        public int compare(SimpleCatView o1, SimpleCatView o2) {
            return String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName());
        }
    }
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @CollectionMapping(comparator = SimpleCatView.DefaultComparator.class)
    SortedSet&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure the correct ordering of the collection elements regardless of the query ordering.
The query stays the same.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="indexed-collection-re-mapping"><a class="anchor" href="#indexed-collection-re-mapping"></a>Indexed collection re-mapping</h4>
<div class="paragraph">
<p>Mapping an indexed collection like a <code>java.util.Map</code> or <code>java.util.List</code> with an <code>@OrderColumn</code> can happen in multiple ways.
Let&#8217;s consider the following model.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
class Cat {
    @Id
    Long id;

    @OneToMany
    @OrderColumn
    List&lt;Cat&gt; indexedKittens;

    @ManyToMany
    Map&lt;Cat, Cat&gt; kittensBestFriends;
}

@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Indexed mapping</dt>
<dd>
<p>One way is to map the collections indexed again, i.e. a <code>Map</code> in the entity is mapped as <code>Map</code> in the entity view.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    List&lt;SimpleCatView&gt; getIndexedKittens();

    Map&lt;SimpleCatView, SimpleCatView&gt; getKittensBestFriends(); <i class="conum" data-value="1"></i><b>(1)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Careful when mapping the key to a subview. This is only supported in the latest JPA provider versions</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,

    INDEX(indexedKittens_1),
    indexedKittens_1.id,
    indexedKittens_1.name

    KEY(kittensBestFriends_1).id,
    KEY(kittensBestFriends_1).name,

    kittensBestFriends_1.id,
    kittensBestFriends_1.name
FROM Cat cat
LEFT JOIN cat.indexedKittens indexedKittens_1
LEFT JOIN cat.kittensBestFriends kittensBestFriends_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Map-Key only mapping</dt>
<dd>
<p>By using the qualified expression <code>KEY()</code> you can map the keys of a map to a collection by using <code>@Mapping</code></p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @Mapping("KEY(kittensBestFriends)")
    List&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, KEY(kittensBestFriends_1).id, KEY(kittensBestFriends_1).name
FROM Cat cat
LEFT JOIN cat.kittensBestFriends kittensBestFriends_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Map-Value only mapping</dt>
<dd>
<p>Simply mapping a path expression for a <code>Map</code> to a normal collection, will result in only fetching the map values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @Mapping("kittensBestFriends")
    List&lt;SimpleCatView&gt; getBestFriends();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittensBestFriends_1.id, kittensBestFriends_1.name
FROM Cat cat
LEFT JOIN cat.kittensBestFriends kittensBestFriends_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">List-Value only mapping</dt>
<dd>
<p>Sometimes it might be required to ignore the index of an indexed <code>List</code> when mapping it to a <code>List</code> again. To do so use <code>ignoreIndex</code> on <code>@CollectionMapping</code></p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @Mapping("indexedKittens")
    @CollectionMapping(ignoreIndex = true)
    List&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, indexedKittens_1.id, indexedKittens_1.name
FROM Cat cat
LEFT JOIN cat.indexedKittens indexedKittens_1</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="singular-collection-type-mappings"><a class="anchor" href="#singular-collection-type-mappings"></a>Singular collection type mappings</h3>
<div class="paragraph">
<p>There are cases when the entity model defines a collection that is actually a singular entity attribute. This can happen when you use custom type implementations or JPA 2.1 attribute converters that produce collections.
A custom type or converter could map a DBMS array, json, xml or any other type to a collection. Since such an entity attribute is not a relation, it can only be a singular attribute.
By default {projectname} entity views assume that an entity view attribute with a collection type is a plural attribute and the mapping refers to a plural entity attribute.
In order to be able to map such special singular attribute collections, you have to specifically use <code>@MappingSingular</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
class Cat {

    @Id
    Long id;

    @Basic
    @Convert(converter = StringSetConverter.class)
    Set&lt;String&gt; tags;
}

class StringSetConverter implements AttributeConverter&lt;String, Set&lt;String&gt;&gt; { ... }

@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    @MappingSingular
    Set&lt;String&gt; getTags();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Beware that you can&#8217;t re-map the collection type in this case although this might soon be possible. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/361">#361</a> for further information.</p>
</div>
<div class="paragraph">
<p>The query will not generate a join but simply select the <code>tags</code> since it&#8217;s a singular attribute.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, cat.tags
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-correlation-mappings"><a class="anchor" href="#anchor-correlation-mappings"></a>Correlated mappings</h3>
<div class="paragraph">
<p>In some entity models, not every relation between entities might be explicitly mapped. There are multiple possible reasons for that like e.g. not wanting to have explicit dependencies, to keep it simple etc.
Apart from unmapped relations, there is sometimes the need to <em>correlate</em> entities based on some criteria with other entities which are more of an ad-hoc nature than explicit relations.</p>
</div>
<div class="paragraph">
<p>For these cases {projectname} entity views introduces the concept of <em>correlated mappings</em>. These mappings can be used to connect entities through a custom criteria instead of through mapped entity relations.
Correlated mappings can be used for any attribute type(basic, entity, subview, collection) although singular basic attributes can also be implemented as <a href="#subquery-mappings">normal subqueries</a>.</p>
</div>
<div class="paragraph">
<p>A correlation mapping is declared by annotating the desired attribute with <code>@MappingCorrelated</code> or <code>@MappingCorrelatedSimple</code>.</p>
</div>
<div class="sect3">
<h4 id="general-correlated-mappings"><a class="anchor" href="#general-correlated-mappings"></a>General correlated mappings</h4>
<div class="paragraph">
<p>In order to map the correlation you need to specify some values</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>correlationBasis</code> - An expression that maps to the so called <em>correlation key</em></p>
</li>
<li>
<p><code>correlator</code> - The <code>CorrelationProvider</code> to use for the correlation that introduces a so called <em>correlated entity</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the correlated entity type is <em>projected into</em> the view. To map a specific property of the entity type, use the <code>correlationResult</code> attribute.
There is also the possibility to specify a <a href="#anchor-fetch-strategies"><em>fetch strategy</em></a> that should be used for the correlation. By default, the <code>SELECT</code> strategy is used.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        fetch = FetchStrategy.JOIN
    )
    Set&lt;Person&gt; getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String alias = builder.getCorrelationAlias();  <i class="conum" data-value="1"></i><b>(1)</b>
            builder.correlate(Person.class)
                .on(alias + ".age").inExpressions(correlationExpression) <i class="conum" data-value="2"></i><b>(2)</b>
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>getCorrelationAlias()</code> defines the alias for the correlated entity</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>correlationExpression</code> represents the <code>correlationBasis</code>. We generally recommend to use the <code>IN</code> predicate through <code>inExpressions()</code> to be able to easily switch the fetch strategy</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on the fetch strategy multiple other queries might be executed. Check out the different <a href="#anchor-fetch-strategies">fetch strategies</a> for further information.
In this case, the <code>JOIN</code> strategy was used, so the following query is generated.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, pers
FROM Cat cat
LEFT JOIN Person correlated_SameAgedPersons <i class="conum" data-value="1"></i><b>(1)</b>
       ON cat.age = correlated_SameAgedPersons.age <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This makes use of the so called <a href="{core_doc}#anchor-entity-joins"><code>entity join</code> feature</a> which is only available in newer JPA provider versions</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Note that the <code>IN</code> predicate which was used in the correlation provider was rewritten to a equality predicate</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since entity joins are required for using the <code>JOIN</code> fetch strategy with correlation mappings you have to make sure your JPA provider supports them.
If your JPA provider does not support entity joins, you have to use a different fetch strategy instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="simple-correlated-mappings"><a class="anchor" href="#simple-correlated-mappings"></a>Simple correlated mappings</h4>
<div class="paragraph">
<p>Since correlation providers are mostly static, {projectname} also offers a way to define simple correlations in a declarative manner.
The <code>@MappingCorrelatedSimple</code> annotation only requires a few values</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>correlationBasis</code> - An expression that maps to the so called <em>correlation key</em></p>
</li>
<li>
<p><code>correlated</code> - The <em>correlated entity</em> type</p>
</li>
<li>
<p><code>correlationExpression</code> - The expression to use for correlating the <em>correlated entity</em> type to the view</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
public interface PersonView {

    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlated = Person.class,
        correlationExpression = "age IN correlationKey" <i class="conum" data-value="1"></i><b>(1)</b>
        fetch = FetchStrategy.JOIN
    )
    Set&lt;PersonView&gt; getSameAgedPersons(); <i class="conum" data-value="2"></i><b>(2)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The expression uses the default name for the correlation key but could use a different name by specifying the attribute <code>correlationKeyAlias</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As you see here, it is obviously also possible to map subviews for correlated entity types</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just like the general correlation, by default, the correlated entity type is <em>projected into</em> the view. To map a specific property of the entity type, use the <code>correlationResult</code> attribute.
There is also the possibility to specify a <a href="#anchor-fetch-strategies"><em>fetch strategy</em></a> that should be used for the correlation. By default, the <code>SELECT</code> strategy is used.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="special-method-attributes"><a class="anchor" href="#special-method-attributes"></a>Special method attributes</h3>
<div class="paragraph">
<p>There are some special methods that can be declared abstract in an entity view type which have special runtime support.</p>
</div>
<div class="sect3">
<h4 id="entity-view-special-method-entity-view-manager-getter"><a class="anchor" href="#entity-view-special-method-entity-view-manager-getter"></a>EntityViewManager getter</h4>
<div class="paragraph">
<p>An abstract method that returns <code>EntityViewManager</code> will not be considered to be an attribute.
Such a method has special runtime support as it will always return the associated <code>EntityViewManager</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
public abstract class PersonView {

    @IdMapping
    public abstract Long getId();

    abstract EntityViewManager getEntityViewManager();

    public void someMethod() {
        // ... use getEntityViewManager()
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>This is especially useful for <a href="#Updatable Entity Views">[Updatable Entity Views]</a> when a method wants to create a new instance of a subview or get a reference to a subview.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping-expression-extensions"><a class="anchor" href="#mapping-expression-extensions"></a>Mapping expression extensions</h3>
<div class="paragraph">
<p>{projectname} entity views generally supports the full set of <a href="{core_doc}#expressions">expressions</a> that JPQL and {projectname} core module supports,
but in addition to that, also offers some expression extensions.</p>
</div>
<div class="sect3">
<h4 id="this"><a class="anchor" href="#this"></a>THIS</h4>
<div class="paragraph">
<p>Similar to the <code>this</code> expression in Java, in a mapping expression within entity views the <code>this</code> expression can be used to refer to the entity type backing the entity view.
The expression can be used to implement embedded objects that are able to refer to the entity type of the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface EmbeddedCatView {

    @IdMapping
    Long getId();

    String getName();
}

@EmbeddableEntityView(Cat.class)
interface ExternalInterfaceView {

    @Mapping("name")
    String getExternalName();
}

@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    @Mapping("this")
    EmbeddedCatView getEmbedded();

    @Mapping("this")
    ExternalInterfaceView getAdapter();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Both <code>EmbeddedCatView</code> and <code>ExternalInterfaceView</code> refer to the same <code>Cat</code> as their parent <code>CatView</code>.
The query looks as if the types were directly embedded into the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    cat.id,
    cat.name,
    cat.name
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="outer"><a class="anchor" href="#outer"></a>OUTER</h4>
<div class="paragraph">
<p>In {projectname} core the <code>OUTER</code> function can be used to refer to the query root of a parent query from within a subquery.
This is still the same with {projectname} entity views but might lead to unintuitive behavior when the subquery provider uses <code>OUTER</code> and is used in a subview.
The following example shows the unintuitive behavior.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    Set&lt;KittenCatView&gt; getKittens();
}

@EntityView(Cat.class)
interface KittenCatView {

    @IdMapping
    Long getId();

    @MappingSubquery(KittenCountSubqueryProvider.class)
    Long getKittenCount();

    class KittenCountSubqueryProvider implements SubqueryProvider {

        @Override
        public &lt;T&gt; T createSubquery(SubqueryInitiator&lt;T&gt; subqueryBuilder) {
            return subqueryBuilder.from(Cat.class, "subCat")
                    .select("COUNT(*)")
                    .whereOr()
                        .where("subCat.father.id").eqExpression("OUTER(id)")
                        .where("subCat.mother.id").eqExpression("OUTER(id)")
                    .endOr()
                .end();
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>When applying the <code>KittenCatView</code> directly, everything works as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.father.id = cat.id
        OR subCat.mother.id = cat.id
    )
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>But when using <code>KittenCatView</code> as subview within <code>CatView</code>, it starts to break.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    kittens_1.id,
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.father.id = cat.id <i class="conum" data-value="1"></i><b>(1)</b>
           OR subCat.mother.id = cat.id
    )
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>OUTER</code> resolved to <code>cat</code> instead of <code>kittens_1</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>OUTER</code> function doesn&#8217;t know about the entity view structure and will remain to refer to the <strong>query root</strong>.</p>
</div>
<div class="paragraph">
<p>In the future, a function <code>EMBEDDING_VIEW</code> will be introduced to be able to refer to the <em>embedding entity view</em>. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/367">#367</a> for more information on this.</p>
</div>
</div>
<div class="sect3">
<h4 id="view_root"><a class="anchor" href="#view_root"></a>VIEW_ROOT</h4>
<div class="paragraph">
<p>The <code>VIEW_ROOT</code> function can be used to refer to the relation for which the main entity view is applied.
Normally this will resolve to the query root, but beware that the entity view root might not always be the query root.
One of the main use cases for this function is when using <a href="#anchor-correlation-mappings">correlated subview mappings</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For further information on applying a different entity view root take a look into the <a href="#anchor-entity-view-apply-root">querying chapter</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>VIEW_ROOT</code> function can be used in a correlation provider to additionally refer to a view root.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = CatAgeCorrelationProvider.class
    )
    Set&lt;Cat&gt; getSameAgedCats();

    static class CatAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String correlatedCat = builder.getCorrelationAlias();
            builder.correlate(Cat.class)
                .on(correlatedCat + ".age").inExpressions(correlationExpression)
                .on(correlatedCat + ".id").notInExpressions("VIEW_ROOT(id)") <i class="conum" data-value="1"></i><b>(1)</b>
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We generally recommend to use the <code>IN</code> predicate through <code>inExpressions()</code> or <code>notInExpressions()</code> to be able to easily switch the fetch strategy</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>VIEW_ROOT</code> function is usable with every fetch strategy. In case of the <code>JOIN</code> fetch strategy the result is just as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, correlatedCat
FROM Cat cat
LEFT JOIN Cat correlatedCat
       ON correlatedCat.age = cat.age
      AND correlatedCat.id &lt;&gt; cat.id <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Again, the <code>IN</code> predicate was rewritten to an equality predicate</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Make sure you understand the &lt;&lt;anchor-select-fetch-strategy-view-root,implication&gt; of the <code>VIEW_ROOT</code> function when using the batched <code>SELECT</code> fetch strategy as this might affect performance.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-constructor-mapping"><a class="anchor" href="#anchor-constructor-mapping"></a>Entity View constructor mapping</h3>
<div class="paragraph">
<p>So far, all mapping examples used interfaces for entity views, but as outlined in the beginning, {projectname} entity views also has support for abstract classes.
There are multiple use cases for using abstract classes for entity views, but in general we recommend to use an interface as often as possible.
The biggest advantage of using abstract classes is that you can have a custom constructor which can further apply transformations on data.</p>
</div>
<div class="sect3">
<h4 id="abstract-class-entity-view-with-custom-equals-hashcode"><a class="anchor" href="#abstract-class-entity-view-with-custom-equals-hashcode"></a>Abstract class Entity View with custom equals-hashCode</h4>
<div class="paragraph">
<p>Abstract classes, contrary to interfaces, can define an implementation for the equals and hashCode methods which is normally generated for the runtime implementations of Entity Views.
If you decide to have a custom implementation you have to fulfill the general requirement, that the equals and hashCode methods use</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only the attribute mapped with <code>@IdMapping</code> if there is one</p>
</li>
<li>
<p>Otherwise use all attributes of the Entity View</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Not following these requirements could lead to unexpected results so it is generally best to rely on the default implementation.
For every custom implementation that is detected during the bootstrap a warning message will be logged.</p>
</div>
</div>
<div class="sect3">
<h4 id="map-external-data-model-with-view-constructor"><a class="anchor" href="#map-external-data-model-with-view-constructor"></a>Map external data model with view constructor</h4>
<div class="paragraph">
<p>One of those use cases for a view constructor is integrating with an existing external data model.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">class CatRestDTO {
    private final Long id;
    private final String name;

    public MyOldCatDTO(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>In general we recommend to use the entity view types directly instead of an external data model, because of the additional boilerplate code needed.
Note that the creators of {projectname} are not generally against external data models since it is reasonable to have them e.g. in API projects that shouldn&#8217;t expose a library dependency.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView extends CatRestDTO {

    public CatView(
        @Mapping("id") Long id,
        @Mapping("name") String name
    ) {
        super(id, name);
    }

}</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the <code>CatView</code> for efficient querying but still have objects that are an instance of <code>CatRestDTO</code> and can thus be used like normal <code>CatRestDTO</code> instances.
To decouple the actual entity view <code>CatView</code> from the data access or service one normally uses method signatures like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">interface CatDAO {
    &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityViewClass); <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;T&gt; List&lt;T&gt; findAll(EntityViewSetting&lt;T, CriteriaBuilder&lt;T&gt;&gt; entityViewSetting); <i class="conum" data-value="2"></i><b>(2)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the <code>EntityViewSetting</code> within the implementation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Supply a custom <code>EntityViewSetting</code> which can also have filters, sorts, optional parameters and pagination information</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By using one of these approaches you can have a projection independent implementation for <code>CatDAO</code> and let the consumer i.e. a REST endpoint decide about the representation.</p>
</div>
</div>
<div class="sect3">
<h4 id="additional-data-transformation-in-view-constructor"><a class="anchor" href="#additional-data-transformation-in-view-constructor"></a>Additional data transformation in view constructor</h4>
<div class="paragraph">
<p>Another use case for view constructors is the transformation of data. Sometimes it is just easier to do the transformation in Java code instead of through a JPQL expression,
but then there are also times when there is no other way than doing it in Java code.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume you want to have an attribute that contains different text based on the age.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    @Mapping("CASE WHEN age = 0 THEN 'newborn' WHEN age &lt; 10 THEN 'child' WHEN age &lt; 18 THEN 'teenager' ELSE 'adult' END")
    String getText();

}</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>CASE WHEN</code> expression can be used to implement that, but if the text is only static, there is no need to use that kind of expression.
You can instead just inject the <code>age</code> as constructor parameter and do the mapping to the text in Java code.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(@Mapping("age") long age) {
        if (age == 0) {
            this.text = "newborn";
        } else if (age &lt; 10) {
            this.text = "child";
        } else if (age &lt; 18) {
            this.text = "teenager";
        } else {
            this.text = "adult";
        }
    }

    @IdMapping
    public abstract Long getId();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Since that kind of mapping logic is normally externalized, {projectname} entity views also offers a way to <em>inject</em> external services.
You can provide services to entity views via <a href="#anchor-optional-parameters"><em>optional parameters</em></a> like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, CriteriaBuilder&lt;CatView&gt;&gt; setting
    = EntityViewSetting.create(CatView.class);

setting.addOptionalParameter("ageMapper", new AgeToTextMapper());
List&lt;CatView&gt; result = entityViewManager.applySetting(setting, cbf.create(em, Cat.class))
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>The services, or optional parameters in general can be consumed either as attributes or as constructor parameters with <code>@MappingParameter</code>.
If the parameter is not supplied, <code>null</code> is injected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(
        @Mapping("age") long age,
        @MappingParameter("ageMapper") AgeToTextMapper mapper
    ) {
        this.text = ageMapper.map(age);
    }

    @IdMapping
    public abstract Long getId();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anchor-named-constructor"><a class="anchor" href="#anchor-named-constructor"></a>Multiple named constructors</h4>
<div class="paragraph">
<p>So far, the example always used no or just a single constructor, but it is actually possible to have multiple constructors.
Every constructor in an entity view must have a name defined via <code>@ViewConstructor</code>. The default name is <code>init</code> and is used for constructors that have no <code>@ViewConstructor</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(
        @Mapping("age") long age,
        @MappingParameter("ageMapper") AgeToTextMapper mapper
    ) {
        this.text = ageMapper.map(age);
    }

    @ViewConstructor("special")
    public CatView(@Mapping("age") long age) {
        this.text = age &gt; 80 ? "oldy" : "normal";
    }

    @IdMapping
    public abstract Long getId();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The constructor name can be chosen when constructing a <code>EntityViewSetting</code> via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#create(java.lang.Class,%20java.lang.String)"><code>create()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting.create(CatView.class, "special");</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-attribute-getters-in-constructor"><a class="anchor" href="#using-attribute-getters-in-constructor"></a>Using attribute getters in constructor</h4>
<div class="paragraph">
<p>Since mapping constructor parameters can become very cumbersome and oftentimes you need a value not only in the constructor but also accessible directly via a getter,
{projectname} came up with a solution that allows you to use the getters of attributes in the constructor.</p>
</div>
<div class="paragraph">
<p>It might not be immediately obvious why this is a special thing. Since entity views are declared as abstract classes you can imagine that the runtime has to actually create concrete classes.
These concrete classes <em>normally</em> initialize fields <strong>after</strong> calling the super constructor, thus making it impossible for the super constructor to actually retrieve values by using the attribute getters.
The JVM enforces that fields can only be accessed after the super constructor has been called, so normally there is no way that the getter implementations that serve the fields can return non-null values in the super constructor.
Fortunately, {projectname} entity views found a way around this limitation of the JVM by making use of the infamous <code>sun.misc.Unsafe</code> to define a class that would normally fail bytecode verification.
The trick is, that the implementations that are generated will set the fields before calling the super constructor thus making the values available to the super constructor.</p>
</div>
<div class="paragraph">
<p>By default, all abstract classes will be defined through <code>sun.misc.Unsafe</code>.
If you don&#8217;t want that behavior and instead want bytecode verifiable implementations to be generated, you can always disable this strategy by using a <a href="#proxy-unsafe-allowed">configuration property</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(@MappingParameter("ageMapper") AgeToTextMapper mapper) {
        this.text = ageMapper.map(getAge()); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @IdMapping
    public abstract Long getId();

    public abstract Long getAge();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the unsafe proxy is used, <code>getAge()</code> will return the actual value, otherwise it will return <code>null</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inheritance-mapping"><a class="anchor" href="#inheritance-mapping"></a>Inheritance mapping</h3>
<div class="paragraph">
<p>Entity views can have an inheritance relationship to subtypes via an inheritance mapping. This relationship allows instances of an entity view subtype to be materialized when a selection predicate
defined by an inheritance mapping is satisfied.</p>
</div>
<div class="paragraph">
<p>The inheritance feature for an entity view is activated by annotating <a href="{entity_view_jdoc}/persistence/view/EntityViewInheritance.html"><code>@EntityViewInheritance</code></a> on an entity view.
By default, all subtypes of the entity view are considered as inheritance subtypes and thus require a so called <em>inheritance mapping</em>.</p>
</div>
<div class="paragraph">
<p>An <em>inheritance mapping</em> is defined by annotating the subtype with <a href="{entity_view_jdoc}/persistence/view/EntityViewInheritanceMapping.html"><code>@EntityViewInheritanceMapping</code></a> and defining
a selection predicate that represents the condition on which decides the instantiation of that subtype. The predicate is a normal <a href="{core_doc}#expressions">JPQL predicate expression</a>
and can refer to all attributes of the mapped entity type.</p>
</div>
<div class="paragraph">
<p>Consider the following example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@EntityViewInheritance
public interface BaseCatView {
    String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &lt; 18")
public interface YoungCatView extends BaseCatView {
    @Mapping("mother.name")
    String getMotherName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &gt; 18")
public interface OldCatView extends BaseCatView {
    @Mapping("kittens.name")
    List&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When querying for entity views of the type <code>BaseCatView</code>, the selection predicates <code>age &lt; 18</code> and <code>age &gt; 18</code> are <em>merged</em> into a <em>type discriminator</em> expression that returns a type index.
The type index refers to the entity view type into which a result should be materialized. The resulting JPQL query for such an entity view looks like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    CASE
        WHEN age &lt; 18 THEN 1
        WHEN age &gt; 18 THEN 2
        ELSE 0
    END,
    cat.name,
    mother_1.name,
    kittens_1.name
FROM Cat cat
LEFT JOIN cat.mother mother_1
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>The type index 0 refers to the base type <code>BaseCatView</code>, hence instances of <code>BaseCatView</code> are materialized when the age of a result equals 18.</p>
</div>
<div class="paragraph">
<p>Since it might not be desirable to use all entity view subtypes for the inheritance relationship, it is possible to explicitly declare the subtypes in the <code>@EntityViewInheritance</code> annotation on the super type.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@EntityViewInheritance({ YoungCatView.class })
public interface BaseCatView {
    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This has the effect, that only <code>BaseCatView</code> or <code>YoungCatView</code> instances are materialized for a result.</p>
</div>
</div>
<div class="sect2">
<h3 id="inheritance-subview-mapping"><a class="anchor" href="#inheritance-subview-mapping"></a>Inheritance subview mapping</h3>
<div class="paragraph">
<p>Similarly to specifying the entity view inheritance subtypes at the declaration site, i.e. <code>BaseCatView</code>, it is also possible to define subtypes at the <em>use site</em>, i.e. at the subview attribute.
By annotating the subview attribute with <code>@MappingInheritance</code>, it is possible to delimit and override the entity view subtype mappings that are considered for materialization from the result.
When using the <code>@MappingInheritance</code> annotation, it is required to list all desired subtypes via <code>@MappingInheritanceSubtype</code> annotations that can optionally override the inheritance mapping.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
interface PersonView {
    String getName();
    @MappingInheritance({
        @MappingInheritanceSubtype(mapping = "age &lt;= 18", value = YoungCatView.class)
    })
    Set&lt;BaseCatView&gt; getCats();
}

@EntityView(Cat.class)
@EntityViewInheritance
public interface BaseCatView {
    String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &lt; 18")
public interface YoungCatView extends BaseCatView {
    @Mapping("mother.name")
    String getMotherName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &gt; 18")
public interface OldCatView extends BaseCatView {
    @Mapping("kittens.name")
    List&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When querying for <code>PersonView</code>, <code>YoungCatView</code> instances will be materialized if the cat&#8217;s age is lower <strong>or equal</strong> to 18 and otherwise instances of <code>BaseCatView</code> will be created.
By setting the annotation property <code>onlySubtypes</code> to true, instances of the base type <code>BaseCatView</code> aren&#8217;t materialized but a null is propagated.
Apart from skipping the base type, it is also possible to define the base type via <code>@MappingInheritanceSubtype</code> which allows to specify the inheritance mapping for the base type.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When no <code>@MappingInheritanceSubtype</code> elements are given, only the base type is materialized which can be used to <em>disable</em> the inheritance feature for an attribute.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is illegal to set <code>onlySubtypes</code> to true and have an empty set of subtype mappings as that would always result in a <code>null</code> object.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="inheritance-mapping-with-constructors"><a class="anchor" href="#inheritance-mapping-with-constructors"></a>Inheritance mapping with constructors</h4>
<div class="paragraph">
<p>Entity view inheritance is not limited to interface types but can also be used with custom constructors.
If a view constructor is used, all entity view inheritance subtypes must have a view constructor with the same name.
In case of just a single constructor the <code>@ViewConstructor</code> does not have to be applied, as the name <code>init</code> is chosen by default as name.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@EntityViewInheritance
public abstract class BaseCatView {

    private final String parentName;

    public BaseCatView(@Mapping("father.name") String parentName) {
        this.parentName = parentName;
    }

    public abstract String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &lt; 18")
public abstract class YoungCatView extends BaseCatView {

    public YoungCatView(@Mapping("mother.name") String parentName) {
        super(parentName);
    }

    @Mapping("mother.name")
    public abstract String getMotherName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &gt; 18")
public abstract class OldCatView extends BaseCatView {

    public OldCatView() {
        super("None");
    }

    @Mapping("kittens.name")
    public abstract List&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="inheritance-mapping-and-jpa-inheritance"><a class="anchor" href="#inheritance-mapping-and-jpa-inheritance"></a>Inheritance mapping and JPA inheritance</h4>
<div class="paragraph">
<p>The most obvious use case for entity view inheritance is mapping JPA entities that use an inheritance relationship.
{projectname} supports this and also makes use of defaults for the inheritance mapping in case a entity view subtype uses an entity subtype in the <code>@EntityView</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Animal.class)
@EntityViewInheritance
public interface AnimalView {

    String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping
public interface CatView extends AnimalView {

    String getKittyName();
}

@EntityView(Dog.class)
@EntityViewInheritanceMapping
public interface DogView extends AnimalView {

    String getDoggyName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DogView</code> uses the entity <code>Dog</code> and <code>CatView</code> the entity <code>Cat</code> which are both subtypes of <code>Animal</code>. In this case no inheritance mapping needs to be provided as {projectname} will
generate a type constraint like <code>TYPE(this) = Dog</code> or <code>TYPE(this) = Cat</code> for the respective entity view subtypes <code>DogView</code> and <code>CatView</code>.
The resulting JPQL query when using <code>AnimalView</code> might look like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    CASE
        WHEN TYPE(animal) = Cat THEN 1
        WHEN TYPE(animal) = Dog THEN 2
        ELSE 0
    END,
    animal.name,
    TREAT(animal AS Cat).kittyName,
    TREAT(animal AS Dog).doggyName
FROM Animal animal</pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, the expressions for the access of the subtype properties rightfully make use of the <code>TREAT</code> operator.</p>
</div>
<div class="paragraph">
<p>An entity view could also be modelled flat i.e. not mirroring the entity inheritance relationship as entity views, but just put the desired properties on a single entity view type.
This can be done by making use of the <code>TREAT</code> operator and the <code>this</code> expression in the entity view mappings just as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Animal.class)
@EntityViewInheritance
public interface MyAnimalView {

    String getName();

    @Mapping("TREAT(this AS Cat).kittyName")
    String getKittyName();

    @Mapping("TREAT(this AS Dog).doggyName")
    String getDoggyName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The generated query looks approximately like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    animal.name,
    TREAT(animal AS Cat).kittyName,
    TREAT(animal AS Dog).doggyName
FROM Animal animal</pre>
</div>
</div>
<div class="paragraph">
<p>and in case an animal is not of the treated type, a <code>null</code> value will be produced.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-04 13:32:35 KST
</div>
</div>
</body>
</html>