<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="Christian Beikov, Blazebit">
<title>Blaze Persistence - Entity View Module</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<h1>Blaze Persistence - Entity View Module</h1>
<div class="details"><div class="author-wrapper">
<span id="author" class="author">Christian Beikov, Blazebit</span><br>
<span id="email" class="email"><a href="mailto:christian@blazebit.com">christian@blazebit.com</a></span></div><br>
<div class="author-wrapper"><span id="author2" class="author">Moritz Becker, Curecomp</span><br>
<span id="email2" class="email"><a href="mailto:moritz.becker@gmx.at">moritz.becker@gmx.at</a></span></div><br>
<span id="revnumber">1.2.0-SNAPSHOT</span>
<br>
<span class="copyright">Copyright (C) 2014 - 2018 Blazebit</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">Preface</a></li>
<li><a href="#system-requirements">System requirements</a></li>
<li><a href="#getting-started">1. Getting started</a>
<ul class="sectlevel2">
<li><a href="#getting-started-setup">1.1. Setup</a></li>
<li><a href="#anchor-environment">1.2. Environments</a></li>
<li><a href="#supported-java-runtimes">1.3. Supported Java runtimes</a></li>
<li><a href="#supported-environments-libraries">1.4. Supported environments/libraries</a></li>
<li><a href="#first-entity-view-query">1.5. First entity view query</a></li>
<li><a href="#getting-started-summary">1.6. Summary</a></li>
</ul>
</li>
<li><a href="#architecture">2. Architecture</a>
<ul class="sectlevel2">
<li><a href="#architecture-interfaces">2.1. Interfaces</a></li>
<li><a href="#architecture-core-integration">2.2. Core module integration</a></li>
<li><a href="#architecture-object-builder-pipeline">2.3. Object builder pipeline</a></li>
<li><a href="#architecture-updatable-entity-views">2.4. Updatable entity views</a></li>
</ul>
</li>
<li><a href="#mappings">3. Mappings</a>
<ul class="sectlevel2">
<li><a href="#mapping-types">3.1. Mapping types</a></li>
<li><a href="#mapping-defaults">3.2. Mapping defaults</a></li>
<li><a href="#anchor-id-mappings">3.3. Id mappings</a></li>
<li><a href="#anchor-flat-view-id-mappings">3.4. Flat view id mappings</a></li>
<li><a href="#basic-mappings">3.5. Basic mappings</a></li>
<li><a href="#subview-mappings">3.6. Subview mappings</a></li>
<li><a href="#subquery-mappings">3.7. Subquery mappings</a></li>
<li><a href="#anchor-parameter-mappings">3.8. Parameter mappings</a></li>
<li><a href="#entity-mappings">3.9. Entity mappings</a></li>
<li><a href="#collection-mappings">3.10. Collection mappings</a></li>
<li><a href="#singular-collection-type-mappings">3.11. Singular collection type mappings</a></li>
<li><a href="#anchor-correlation-mappings">3.12. Correlated mappings</a></li>
<li><a href="#special-method-attributes">3.13. Special method attributes</a></li>
<li><a href="#mapping-expression-extensions">3.14. Mapping expression extensions</a></li>
<li><a href="#anchor-constructor-mapping">3.15. Entity View constructor mapping</a></li>
<li><a href="#inheritance-mapping">3.16. Inheritance mapping</a></li>
<li><a href="#inheritance-subview-mapping">3.17. Inheritance subview mapping</a></li>
</ul>
</li>
<li><a href="#anchor-fetch-strategies">4. Fetch strategies</a>
<ul class="sectlevel2">
<li><a href="#join-fetch-strategy">4.1. Join fetch strategy</a></li>
<li><a href="#select-fetch-strategy">4.2. Select fetch strategy</a></li>
<li><a href="#anchor-subselect-fetch-strategy">4.3. Subselect fetch strategy</a></li>
</ul>
</li>
<li><a href="#filter-and-sorter-api">5. Filter and Sorter API</a>
<ul class="sectlevel2">
<li><a href="#filter-api">5.1. Filter API</a></li>
<li><a href="#sorter-api">5.2. Sorter API</a></li>
</ul>
</li>
<li><a href="#querying-and-pagination-api">6. Querying and Pagination API</a>
<ul class="sectlevel2">
<li><a href="#querying-entity-views">6.1. Querying entity views</a></li>
<li><a href="#anchor-optional-parameters">6.2. Optional parameters and configuration</a></li>
<li><a href="#anchor-entity-view-apply-root">6.3. Applying entity views on specific relations</a></li>
</ul>
</li>
<li><a href="#updatable-entity-views">7. Updatable Entity Views</a>
<ul class="sectlevel2">
<li><a href="#update-mapping">7.1. Update mapping</a></li>
<li><a href="#create-mapping">7.2. Create mapping</a></li>
<li><a href="#api-usage">7.3. API usage</a></li>
<li><a href="#lifecycle-and-listeners">7.4. Lifecycle and listeners</a></li>
<li><a href="#attribute-mappings">7.5. Attribute mappings</a></li>
<li><a href="#locking-support">7.6. Locking support</a></li>
<li><a href="#updatable-entity-view-persist-and-update-cascading">7.7. Persist and Update cascading</a></li>
<li><a href="#updatable-entity-view-delete-cascading-orphan-removal">7.8. Cascading deletes and orphan removal</a></li>
<li><a href="#conversion-support">7.9. Conversion support</a></li>
</ul>
</li>
<li><a href="#entity-view-basic-user-type-spi">8. BasicUserType SPI</a>
<ul class="sectlevel2">
<li><a href="#supported-types">8.1. Supported types</a></li>
<li><a href="#type-support-for-write-models">8.2. Type support for write models</a></li>
<li><a href="#type-support-for-jpa-managed-types">8.3. Type support for JPA managed types</a></li>
<li><a href="#optimistic-locking-version-type-support">8.4. Optimistic locking version type support</a></li>
</ul>
</li>
<li><a href="#entity-view-type-converter-api">9. TypeConverter API</a>
<ul class="sectlevel2">
<li><a href="#builtin-typeconverters">9.1. Builtin TypeConverters</a></li>
</ul>
</li>
<li><a href="#updatable-entity-view-change-model-api">10. Updatable Entity View Change Model</a>
<ul class="sectlevel2">
<li><a href="#updatable-entity-view-change-model-api-overview">10.1. Change Model API overview</a></li>
<li><a href="#updatable-entity-view-change-model-tx-support">10.2. Transaction support</a></li>
<li><a href="#updatable-entity-view-change-model-type-support">10.3. User type support</a></li>
</ul>
</li>
<li><a href="#spring-data-integration">11. Spring Data integration</a>
<ul class="sectlevel2">
<li><a href="#spring-data-setup">11.1. Setup</a></li>
<li><a href="#spring-data-features">11.2. Features</a></li>
<li><a href="#spring-data-rest-integration">11.3. Spring Data Rest integration</a></li>
</ul>
</li>
<li><a href="#deltaspike-data-integration">12. DeltaSpike Data integration</a>
<ul class="sectlevel2">
<li><a href="#deltaspike-data-setup">12.1. Setup</a></li>
<li><a href="#deltaspike-data-features">12.2. Features</a></li>
</ul>
</li>
<li><a href="#metamodel">13. Metamodel</a></li>
<li><a href="#configuration">14. Configuration</a>
<ul class="sectlevel2">
<li><a href="#anchor-configuration-properties">14.1. Configuration properties</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JPA applications that use the entity model in every layer often suffer from the infamous <code>LazyInitializationException</code> or <em>N + 1</em> queries issues.
This is mainly due to the use of a too general model for a use case and is often solved by making use of a specialized DTO and adapting queries to that structure.
The use of DTOs normally requires adapting many parts of an application and a lot of boilerplate code which is why people tend to do <em>the wrong thing</em> like making use of
the <em>open session in view</em> anti-pattern. Apart from lazy loading issues, also the performance suffers due to selecting <em>unnecessary data</em> that a UI is never displaying.</p>
</div>
<div class="paragraph">
<p>Blaze Persistence entity views try to solve these and many more problems a developer faces when having to implement efficient model mapping in a JPA application.
It allows to define DTOs as interfaces and provides the mappings to the JPA model via annotations. It favors convention-over-configuration by providing smart defaults that allow to omit most mappings.
By applying DTOs to a query builder through the <code>ObjectBuilder</code> extension point it is possible to separate query logic from the projections while still enjoying high performance queries.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="system-requirements"><a class="anchor" href="#system-requirements"></a>System requirements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Blaze Persistence entity views require at least Java 1.7 and at least a JPA 2.0 implementation.
The entity view module depends on the core module and requires the use of the same versions for both modules.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>1. Getting started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a step-by-step introduction about how to get started with the entity view module of Blaze Persistence.</p>
</div>
<div class="paragraph">
<p>The entity view module requires the Blaze Persistence core so if you have not read the getting started
guide for the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html">core</a> yet, you might want to start your reading there.</p>
</div>
<div class="sect2">
<h3 id="getting-started-setup"><a class="anchor" href="#getting-started-setup"></a>1.1. Setup</h3>
<div class="paragraph">
<p>As already described in the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#getting-started-setup">core module setup</a>, every module depends on the core module.
So if you haven&#8217;t setup the core module dependencies yet, get back here when you did.</p>
</div>
<div class="paragraph">
<p>To make use of the entity view module, you require all artifacts from the <em>entity-view</em> directory of the distribution.
CDI and Spring users can find integrations in <em>integration/entity-view</em> that give a good foundation for configuring for these environments.</p>
</div>
<div class="paragraph">
<p>Spring Data users can find a special integration in <em>integration/entity-view</em> which is described in more detail in a later <a href="#spring-data-integration">chapter</a>.
This integration depends on all artifacts of the <em>jpa-criteria</em> module.</p>
</div>
<div class="sect3">
<h4 id="maven-setup"><a class="anchor" href="#maven-setup"></a>1.1.1. Maven setup</h4>
<div class="paragraph">
<p>We recommend you introduce a version property for Blaze Persistence which can be used for all artifacts.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;properties&gt;
    &lt;blaze-persistence.version&gt;{version}&lt;/blaze-persistence.version&gt;
&lt;/properties&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The required dependencies for the entity view module are</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-entity-view-api&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-entity-view-impl&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the environment, there are some integrations that help you with configuration</p>
</div>
<div class="sect4">
<h5 id="maven-setup-cdi-integration"><a class="anchor" href="#maven-setup-cdi-integration"></a>CDI integration</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-entity-view-cdi&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-spring-integration"><a class="anchor" href="#maven-setup-spring-integration"></a>Spring integration</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-entity-view-spring&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-spring-data-integration"><a class="anchor" href="#maven-setup-spring-data-integration"></a>Spring Data integration</h5>
<div class="paragraph">
<p>When you work with Spring Data you can additionally have first class integration by using the following dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-spring-data-2.x&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If you still work with Spring Data 1.x you will have to use a different integration as Spring Data 2.x changed quite a bit.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-spring-data-1.x&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Spring Data integration depends on the <em>jpa-criteria</em> module
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-jpa-criteria-api&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-jpa-criteria-impl&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If a JPA provider that does not implement the JPA 2.1 specification like Hibernate 4.2 or OpenJPA is used, the following compatibility dependency is also required.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-jpa-criteria-jpa-2-compatibility&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-environment"><a class="anchor" href="#anchor-environment"></a>1.2. Environments</h3>
<div class="paragraph">
<p>The entity view module of Blaze Persistence is usable in Java EE, Spring as well as in Java SE environments.</p>
</div>
<div class="sect3">
<h4 id="environments-java-se"><a class="anchor" href="#environments-java-se"></a>1.2.1. Java SE</h4>
<div class="paragraph">
<p>In a Java SE environment the <code>EntityViewConfiguration</code> as well as the <code>EntityViewManager</code> must
be created manually as follows:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewConfiguration cfg = EntityViews.createDefaultConfiguration();
cfg.addEntityView(EntityView1.class);
// Add some more
cfg.addEntityView(EntityViewn.class);
EntityViewManager evm = cfg.createEntityViewManager(criteriaBuilderFactory);</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>EntityViewConfiguration</code> is used to register all the entity
view classes that you want to make accessible within the an <code>EntityViewManager</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You may create multiple <code>EntityViewManager</code> instances with potentially different
configurations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="environments-java-ee"><a class="anchor" href="#environments-java-ee"></a>1.2.2. Java EE</h4>
<div class="paragraph">
<p>For usage with CDI the integration module <em>blaze-persistence-integration-entity-view-cdi</em> provides a CDI
extension which takes over the task of creating and providing an <code>EntityViewConfiguration</code>
from which an <code>EntityViewManager</code> can be created like following example shows.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Singleton // from javax.ejb
@Startup   // from javax.ejb
public class EntityViewManagerProducer {

    // inject the configuration provided by the cdi integration
    @Inject
    private EntityViewConfiguration config;

    // inject the criteria builder factory which will be used along with the entity view manager
    @Inject
    private CriteriaBuilderFactory criteriaBuilderFactory;

    private EntityViewManager evm;

    @PostConstruct
    public void init() {
        // do some configuration
        evm = config.createEntityViewManager(criteriaBuilderFactory);
    }

    @Produces
    @ApplicationScoped
    public EntityViewManager createEntityViewManager() {
        return evm;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The CDI extension collects all the entity views classes and provides a producer for the pre-configured <code>EntityViewConfiguration</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="environments-cdi"><a class="anchor" href="#environments-cdi"></a>1.2.3. CDI</h4>
<div class="paragraph">
<p>If EJBs aren&#8217;t available, the <code>EntityViewManager</code> can also be configured in a CDI 1.1 specific way similar to the Java EE way.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@ApplicationScoped
public class EntityViewManagerProducer {

    // inject the configuration provided by the cdi integration
    @Inject
    private EntityViewConfiguration config;

    // inject the criteria builder factory which will be used along with the entity view manager
    @Inject
    private CriteriaBuilderFactory criteriaBuilderFactory;

    private volatile EntityViewManager evm;

    public void init(@Observes @Initialized(ApplicationScoped.class) Object init) {
        // do some configuration
        evm = config.createEntityViewManager(criteriaBuilderFactory);
    }

    @Produces
    @ApplicationScoped
    public EntityViewManager createEntityViewManager() {
        return evm;
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anchor-environment-spring"><a class="anchor" href="#anchor-environment-spring"></a>1.2.4. Spring</h4>
<div class="paragraph">
<p>You have to enable the Spring entity-views integration via annotation based config or XML based config and you can also mix those two types of configuration:</p>
</div>
<div class="paragraph">
<p>Annotation Config</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Configuration
@EnableEntityViews("my.entityviews.base.package")
public class AppConfig {
}</pre>
</div>
</div>
<div class="paragraph">
<p>XML Config</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:ev="http://persistence.blazebit.com/view/spring"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
        http://persistence.blazebit.com/view/spring http://persistence.blazebit.com/view/spring/spring-entity-views-1.2.xsd"&gt;

    &lt;ev:entity-views base-package="my.entityviews.base.package"/&gt;

&lt;/beans&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The Spring integration collects all the entity views classes in the specified base-package and provides the pre-configured <code>EntityViewConfiguration</code> for injection.
This configuration is then used to create a <code>EntityViewManager</code> which should be provided as bean.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Configuration
public class BlazePersistenceConfiguration {

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy(false)
    // inject the criteria builder factory which will be used along with the entity view manager
    public EntityViewManager createEntityViewManager(CriteriaBuilderFactory cbf, EntityViewConfiguration entityViewConfiguration) {
        return entityViewConfiguration.createEntityViewManager(cbf);
    }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="supported-java-runtimes"><a class="anchor" href="#supported-java-runtimes"></a>1.3. Supported Java runtimes</h3>
<div class="paragraph">
<p>The entity view module like all other modules generally follows what has already been stated in the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#supported-java-runtimes">core moduel documentation</a>.</p>
</div>
<div class="paragraph">
<p>Automatic module names for modules.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Module</th>
<th class="tableblock halign-left valign-top">Automatic module name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entity View API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.view</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entity View Impl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.view.impl</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="supported-environments-libraries"><a class="anchor" href="#supported-environments-libraries"></a>1.4. Supported environments/libraries</h3>
<div class="paragraph">
<p>Generally, we support the usage in Java EE 6+ or Spring 4+ applications.</p>
</div>
<div class="paragraph">
<p>The following table outlines the supported library versions for the integrations.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Module</th>
<th class="tableblock halign-left valign-top">Automatic module name</th>
<th class="tableblock halign-left valign-top">Minimum version</th>
<th class="tableblock halign-left valign-top">Supported versions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CDI integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.view.cdi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CDI 1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0, 1.1, 1.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.view.spring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring 4.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.3, 5.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DeltaSpike Data integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.deltaspike.data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DeltaSpike 1.7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.7, 1.8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Data integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.spring.data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Data 1.11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.11, 2.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Data Rest integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.spring.data.rest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Data 1.11, Spring MVC 4.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Data 1.11 + Spring MVC 4.3, Spring Data 2.0 + Spring MVC 5.0</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="first-entity-view-query"><a class="anchor" href="#first-entity-view-query"></a>1.5. First entity view query</h3>
<div class="paragraph">
<p>This section is supposed to give you a first feeling of how to use entity views.
For more detailed information, please see the subsequent chapters.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the following we suppose <code>cbf</code>, <code>em</code> and <code>evm</code> to refer to an instance of <code>CriteriaBuilderFactory</code>,
JPA&#8217;s <code>EntityManager</code> and <code>EntityViewManager</code>, respectively.
Take a look at the <a href="#anchor-environment">environments</a> chapter for how to obtain an <code>EntityViewManager</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An entity view can be thought of as the ORM world&#8217;s dual to a database table view.
It enables the user to query just a subset of an entity&#8217;s fields. This enables
developers to only query what they actually need for their current use case, thereby
reducing network traffic and improving performance.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a very simple example. Assume that in our application we want to
display a list of the names of all the cats in our database. Using entity views
we would first define a new view for this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatNameView {

    @IdMapping
    public Long getId();

    public String getName();

}</pre>
</div>
</div>
<div class="paragraph">
<p>The usage of the <code>CatNameView</code> could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class);
CriteriaBuilder&lt;CatNameView&gt; catNameBuilder = evm.applySetting(EntityViewSetting.create(CatNameView.class), cb);
List&lt;CatNameView&gt; catNameViews = catNameBuilder.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, you can apply further restrictions to your query by <code>CriteriaBuilder</code> means.
E.g. you could avoid duplicate names in the above example by calling <code>groupBy()</code> on the
CriteriaBuilder at any point after its creation.</p>
</div>
<div class="paragraph">
<p>By default the abstract getter methods in the view definition map to same named entity fields.
So the <code>getName()</code> getter in the above example actually triggers querying
of the <code>name</code> field. If we want to use a different name for the getter method we would
have to add an additional <code>@Mapping</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatNameView {

    @IdMapping
    public Long getId();

    @Mapping("name")
    public String getCatName();

}</pre>
</div>
</div>
<div class="paragraph">
<p>Of course, it is also possible to combine various views via inheritance.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatKittens {

    @IdMapping
    public Long getId();

    public List&lt;Kitten&gt; getKittens();

}

@EntityView(Cat.class)
public interface CatNameView {

    @IdMapping
    public Long getId();

    @Mapping("name")
    public String getCatName();

}

@EntityView(Cat.class)
public interface CombinedView extends CatKittens, CatNameView {

    @Mapping("SIZE(kittens)")
    public Integer getKittenSize();

}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An entity view does not have to be an interface, it can be any class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Moreover you can see that it is possible to use whole expressions inside the <code>@Mapping</code> annotations.
The allowed expression will be covered in more detail in subsequent chapters.</p>
</div>
<div class="paragraph">
<p>Another useful feature are subviews which is illustrated in following example.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Landlord.class)
public interface LandlordView {

    @IdMapping
    public Long getId();

    public String getName();

    public Integer getAge();

    @Mapping("ownedProperties")
    public PropertyAddressView getHouses();

}

@EntityView(Property.class)
public interface PropertyAddressView {

    @IdMapping
    public Long getId();

    public String getAddress();

}</pre>
</div>
</div>
<div class="paragraph">
<p>The last feature we are going to cover here are filters and sorters in conjunction with <code>EntityViewSetting</code> which
allows the dynamic configuration of filters and sorters on your entity view and are
also usable together with pagination. This makes them ideal an ideal fit whenever you need to query data for display
in a filterable and/or sortable data table. Following example illustrates how this looks like:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@ViewFilters({
    @ViewFilter(name = "customFilter", value = FilteredDocument.CustomFilter.class)
})
public interface FilteredCatView {

    @AttributeFilter(ContainsFilter.class)
    public String getName();

    public static class CustomFilter extends ViewFilterProvider {
        @Override
        public &lt;T extends WhereBuilder&lt;T&gt;&gt; T apply(T whereBuilder) {
            return whereBuilder.where("doctor.name").like().expression("Julia%").noEscape();
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>In this example we once again define a view on our Cat entity and select the cat&#8217;s name only.
But in addition we applied a filter on the name attribute. In this case we chose the <code>ContainsFilter</code>, one
of the predefined filters. We also defined a custom filter where we check whether the cat&#8217;s doctor&#8217;s name
starts with the string <em>Julia</em>.
The next code snippet shows how we dynamically set the actual filter value by which the
query should filter and how we paginate the resulting query.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Base setting
EntityViewSetting&lt;FilteredCatView, PaginatedCriteriaBuilder&lt;FilteredCatView&gt;&gt; setting =
        EntityViewSetting.create(FilteredCatView.class, 0, 10);

// Query
CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class);
setting.addAttributeFilter("name", "Kitty");

PaginatedCriteriaBuilder&lt;FilteredCatView&gt; paginatedCb = evm.applySetting(setting, cb);
PagedList&lt;FilteredCatView&gt; result = paginatedCb.getResultList();</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-summary"><a class="anchor" href="#getting-started-summary"></a>1.6. Summary</h3>
<div class="paragraph">
<p>If you want to go into more detail, you are now ready to discover the other chapters of the documentation or
the API yourself.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>2. Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is just a high level view for those that are interested about how Blaze Persistence entity view works.</p>
</div>
<div class="sect2">
<h3 id="architecture-interfaces"><a class="anchor" href="#architecture-interfaces"></a>2.1. Interfaces</h3>
<div class="paragraph">
<p>A quick overview that presents the interfaces that are essential for users and how they are related.</p>
</div>
<div class="paragraph">
<p>Since entity views are mostly annotation driven and are about mapping attributes to entity attributes, there are not that many interfaces.
The two most important ones are the <code>EntityViewManager</code> and the <code>EntityViewSetting</code>.</p>
</div>
<div class="paragraph">
<p>A <code>EntityViewManager</code> is built once on startup during which it analyzes and validates the configured entity views.
It is responsible for building implementations for the interfaces and abstract classes from the metamodel and caching object builder instances for entity views.</p>
</div>
<div class="paragraph">
<p>The <code>EntityViewSetting</code> is a configuration that can be applied on a query builder through an <code>EntityViewManager</code> and contains information about</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The entity view</p>
</li>
<li>
<p>Pagination</p>
</li>
<li>
<p>Filters and sorters</p>
</li>
<li>
<p>Parameters and properties</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="architecture-core-integration"><a class="anchor" href="#architecture-core-integration"></a>2.2. Core module integration</h3>
<div class="paragraph">
<p>The entity view module builds on top of the <code>ObjectBuilder</code> integration point offered by query builders of the core module.
Every entity view is translated into a <code>ObjectBuilder</code> which is then applied on a query builder.</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture-object-builder-pipeline"><a class="anchor" href="#architecture-object-builder-pipeline"></a>2.3. Object builder pipeline</h3>
<div class="paragraph">
<p>During startup the metamodel is built which is then used for building an object builder pipeline.
For every entity view interface/class a <code>ObjectBuilder</code> template called <code>ViewTypeObjectBuilderTemplate</code> is created which is cached.
From these templates a normal <code>ObjectBuilder</code> is built that can be applied on any query builder. Depending on the features a entity view uses,
the resulting object builder might actually be a object builder pipeline i.e. it invokes multiple object builders in an ordered manner on tuples.</p>
</div>
<div class="paragraph">
<p>In general, a object builder for an entity view just takes in the tuple and passes it to the constructor of the entity view implementation.
As soon as subviews or collections are involved, it becomes a pipeline. The pipeline has two different forms, the abstract form represented by <code>TupleTransformatorFactory</code> and the concrete form <code>TupleTransformator</code>.
When a object builder is created from a template, the concrete form is created from the abstract one which might involve building object builders for subviews.
Every collection introduces a new transformation level i.e. elements of a collection must be materialized before the collection can be materialized.</p>
</div>
<div class="paragraph">
<p>So the result is processed from the <em>leafs</em>(i.e. the elements) upwards(i.e. a collection) until objects of the target entity view type are materialized.</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture-updatable-entity-views"><a class="anchor" href="#architecture-updatable-entity-views"></a>2.4. Updatable entity views</h3>
<div class="paragraph">
<p>Updatable entity views are still in flux and are not yet fully thought through, but here comes the essential idea.</p>
</div>
<div class="paragraph">
<p>Similar to the object builder pipeline, a <code>EntityViewUpdater</code> is composed of several possibly nested <em>attribute flushers</em>.
A <code>EntityViewUpdater</code> is built once and is responsible for <em>flushing</em> dirty attributes to the persistence context.
After flushing, attributes are considered to be non-dirty but they can become dirty again either through a change or a transaction rollback.</p>
</div>
<div class="paragraph">
<p>Dirty tracking is done either by remembering the initial state and comparing with changed state or not at all.
Collections are tracked by using custom collection implementations that do <em>action recording</em> which is then <em>replayed</em> onto a collection of an entity reference.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mappings"><a class="anchor" href="#mappings"></a>3. Mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As already mentioned in the <a href="#getting-started">Getting started</a> section, the entity view module builds up on the core module.
Some of the basics like <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#implicit-joins">implicit joins</a>
and the basic <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#expressions">expression structure</a> should be known to understand all of the following mapping examples.</p>
</div>
<div class="paragraph">
<p>Entity views are to entities in ORM, what table views are to tables in an RDBMS. They represent projections on the entity model.
In a sense you can say that entity views are DTOs 2.0 or DTOs done right.</p>
</div>
<div class="paragraph">
<p>One of the unique features of entity views is that it <strong>only</strong> imposes a structure and the projections, but the base query defines the data source.
Blaze Persistence tried to reduce as much of the boilerplate as possible for defining the structure and the projections by employing a convention over configuration approach.</p>
</div>
<div class="paragraph">
<p>The result of these efforts is that entity views are defined as interfaces or abstract classes mostly containing just getter definitions that serve as attribute definitions.
To declare that an interface or an abstract class as entity view, you have to annotate it and specify the entity class for which this entity view provides projections.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView { ... }</pre>
</div>
</div>
<div class="paragraph">
<p>So an entity view can be seen as a named wrapper for a bunch of attributes, where every attribute has some kind of mapping that is based on the attributes the entity type offers.
An attribute is declared by defining a public abstract method in an entity view i.e. every abstract method is considered to be an attribute.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Since every method of an interface is abstract and public, you can omit the <code>abstract</code> and <code>public</code> keywords.
In this simple example you can see that the <code>CatView</code> has an attribute named <code>name</code>. The implicit mapping for the attribute is the attribute name itself, so <code>name</code>.
This means that the entity view attribute <code>name</code> declared by the abstract method <code>getName()</code> is mapped to the entity attribute <code>name</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since entity views and their mappings are validated during startup against the entity model, you should see any mapping related runtime errors and can be sure it works if it doesn&#8217;t fail to start
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the nice things about using interfaces is that you can have multiple inheritance. If you separate concerns in separate <em>feature interfaces</em>,
you can effectively make use of multiple inheritance.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">interface NameView {
    String getName();
}

interface AgeView {
    Long getAge();
}

@EntityView(Cat.class)
interface CatView extends NameView, AgeView {
}</pre>
</div>
</div>
<div class="paragraph">
<p>In this example <code>CatView</code> has two attributes, <code>name</code> and <code>age</code>. Even though the interfaces are not entity views, they could have custom mappings.</p>
</div>
<div class="sect2">
<h3 id="mapping-types"><a class="anchor" href="#mapping-types"></a>3.1. Mapping types</h3>
<div class="paragraph">
<p>So far, you have mostly seen basic attribute mappings in entity views, but there is actually support for far many mapping types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic mappings - maps basic attributes from entities into entity views</p>
</li>
<li>
<p>Subview mappings - maps a *ToOne relation of an entity to an entity view</p>
</li>
<li>
<p>Flat view mappings - maps an embeddable of an entity to a flat entity view</p>
</li>
<li>
<p>Subquery mappings - maps the result of a subquery to a basic attribute into entity views</p>
</li>
<li>
<p>Parameter mappings - maps named query parameters into an entity view</p>
</li>
<li>
<p>Entity mappings - maps *ToOne or *ToMany relations of an entity as is into an entity view</p>
</li>
<li>
<p>Collection mappings - maps *ToMany relations of an entity into an entity view with support for basic, subview and embeddable types</p>
</li>
<li>
<p>Correlated mappings - correlates an entity type by some key and maps it or an attribute of it into an entity view as subview or basic type respectively</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In general we do not recommend to make extensive use of entity mappings as it defeats the purpose of entity views and can lead to lazy loading issues
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Apart from mapping attributes, it is also possible have a constructor and map parameters when using an abstract class.
One of the biggest use cases for this is for doing further transformations on the data that can&#8217;t be pushed to the DBMS like e.g. money formatting.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping-defaults"><a class="anchor" href="#mapping-defaults"></a>3.2. Mapping defaults</h3>
<div class="paragraph">
<p>As mentioned before, the entity view module implements a convention over configuration approach and thus has some smart defaults for mappings.
Whenever an attribute(getter method) without a mapping annotation is encountered, a default mapping to the same named entity attribute will be created.
If there is none, it will obviously report an error.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-id-mappings"><a class="anchor" href="#anchor-id-mappings"></a>3.3. Id mappings</h3>
<div class="paragraph">
<p>Id mappings declare that an attribute represents the identifier i.e. can be used to uniquely identify an entity view object.
The id mapping is declared by annotating the desired attribute with <code>@IdMapping</code> and optionally specifying the mapping path.
Having an id attribute allows an entity view to map collections, be mapped in collections and gives an entity view object a meaningful identity.
If an entity view has no id mapping, it is considered to be a flat view which probably only makes sense for scalar results or embedded objects.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is generally recommended to always declare an id mapping if possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an id mapping is present, the generated entity view implementation&#8217;s equals-hashCode implementation will be based on it.
Otherwise it will consider <strong>all</strong> attributes in the equals-hashCode implementation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-flat-view-id-mappings"><a class="anchor" href="#anchor-flat-view-id-mappings"></a>3.4. Flat view id mappings</h3>
<div class="paragraph">
<p>A flat view id mapping is given when the type of the id attribute is a flat view type. This is the case when the view type has no id declared.
It&#8217;s very similar to subview mappings and is mostly used when working with JPA embeddable types. Imagine the following model for illustration purposes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatIdView {
    String getName();
}

@EntityView(Cat.class)
interface CatView {
    @IdMapping("this")
    CatIdView getId();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This example already makes use of many concepts. It declares the <code>CatIdView</code> as flat view with a basic mapping and the <code>CatView</code> with a flat view id.
The mapping for the flat view id in <code>CatView</code> uses to the <a href="#this"><code>this</code></a> expression extension to allow the flat view to be based on the same entity that is backing the <code>CatView</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since flat view types will consider <strong>all</strong> attributes in the equals-hashCode implementation, the type shouldn&#8217;t contain unnecessary attributes if possible.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="basic-mappings"><a class="anchor" href="#basic-mappings"></a>3.5. Basic mappings</h3>
<div class="paragraph">
<p>A basic mapping is declared by annotating the desired attribute with <code>@Mapping</code> and specifying the mapping expression.
An attribute that has no mapping annotations is only considered to have a basic mapping if it is of a basic type like e.g. Integer. Without a mapping annotation, the default mapping rules apply.
In general, every non-collection and non-managed type is considered to be basic. Managed types are JPA managed types and entity view types.</p>
</div>
<div class="paragraph">
<p>Although most example only use path expressions for the mapping, it is actually allowed to use any <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#expressions">scalar expression</a> that JPQL or Blaze Persistence allows.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @Mapping("UPPER(name)")
    String getUpperName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>As you might expect, the expression <code>UPPER(name)</code> will upper-case the name, so <code>getUpperName()</code> will return the upper-cased name.
Applying such an entity view on a simple query builder will show what happens behind the scenes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;CatView&gt; result = evm.applySetting(
        EntityViewSetting.create(CatView.class),
        cbf.create(em, Cat.class)
    ).getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, UPPER(cat.name)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The expression in the mapping ends up as select item in the query just as expected.</p>
</div>
</div>
<div class="sect2">
<h3 id="subview-mappings"><a class="anchor" href="#subview-mappings"></a>3.6. Subview mappings</h3>
<div class="paragraph">
<p>Subview and embeddable view mappings are similar to basic mappings in the sense that the same rules apply, except for the allowed mappings.
Since these mappings get their data from objects of managed types, only path expressions are allowed for their mappings.
Path expressions can have arbitrary depth i.e. multiple de-references like <code>relation.subRelation.otherRelation</code> and path elements can be of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple path elements that refer to entity type attributes</p>
</li>
<li>
<p><code>TREAT</code> expression like <code>TREAT(..).subRelation</code></p>
</li>
<li>
<p>Qualified expression like <code>KEY(..).subRelation</code></p>
</li>
<li>
<p>Array expression like <code>relation[:param].subRelation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A subview mapping is given when the type of the attribute is a entity view type.
Since a entity view is always declared for a specific entity type, the target type of the subview mapping and the entity view&#8217;s entity type must be compatible.
This means that you could apply a <code>AnimalView</code> to a <code>Cat</code> if it extends <code>Animal</code> but can&#8217;t apply a <code>PersonView</code> since it&#8217;s not compatible i.e. <code>Cat</code> is not a subtype of <code>Person</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
interface PersonView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Animal.class)
interface AnimalView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    AnimalView getFather();
}</pre>
</div>
</div>
<div class="paragraph">
<p>As you might imagine, the <code>CatView</code> will additionally select attributes of the father relation since they are requested by the <code>AnimalView</code>.
In order to understand the following generated query, you should know what an <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#implicit-joins">implicit join</a> does and how entity views make use of such implicit joins.</p>
</div>
<div class="paragraph">
<p>Behind the scenes, the entity views runtime will apply a select on the criteria builder for the expressions <code>cat.id</code>, <code>father.id</code> and <code>father.name</code>.
The expression <code>father.name</code> accesses an entity attribute is only accessible when actually joining the relation. This is why an implicit/default join is generated for the father relation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, father_1.id, father_1.name
FROM Cat cat
LEFT JOIN cat.father father_1</pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>father</code> relation is optional or nullable, a (default) left join is created due to the rules of <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#model-awareness">model awareness</a> in implicit joins.
This is a perfect fit for entity views as the subview object will be simply <code>null</code> if a cat has no father. If the implicit join worked like JPQL defines it, an inner join would have to be created.
An inner join would mean that cats without a father would get filtered out which is an undesirable effect since we only want a projection on top of a base query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Subviews can in turn have subviews again, so there is no limitation regarding the depth. The only requirement is that there is no cycle.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="flat-view-mappings"><a class="anchor" href="#flat-view-mappings"></a>3.6.1. Flat view mappings</h4>
<div class="paragraph">
<p>A flat view mapping is given when the type of the attribute is a flat view type. This is the case when the entity view has no id declared.
It&#8217;s very similar to subview mappings and is mostly used when working with JPA embeddable types.</p>
</div>
<div class="paragraph">
<p>Note that a flat view can be used like a normal view except when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is used as view root i.e. the flat view is the entity view type used in <code>EntityViewSetting</code>,</p>
</li>
<li>
<p>it is embedded in a flat view which in turn is the view root i.e. the parent is a flat view that is used in <code>EntityViewSetting</code></p>
</li>
<li>
<p>or it is used as subview for a non-indexed collection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then the flat view can&#8217;t have collection attributes with fetch strategy <code>JOIN</code>.
The reason is that the elements of the collection can&#8217;t be matched with the flat view as it has no identity it can use for matching.</p>
</div>
<div class="paragraph">
<p>Imagine the following model for illustration purposes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Embeddable
class Name {
    String firstName;
    String lastName;
}

@Entity
class Person {
    @Id
    @GeneratedValue
    Long id;
    @Embedded
    Name name;
}

@EntityView(Name.class)
interface SimpleNameView {
    String getFirstName();
}

@EntityView(Person.class)
interface PersonView {
    @IdMapping
    Long getId();

    SimpleNameView getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Applying a <code>PersonView</code> would produce a query like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT person.id, person.name.firstName
FROM Person person</pre>
</div>
</div>
<div class="paragraph">
<p>Such a flat view can also be used with the <a href="#this"><code>this</code> expression</a> which is similar to JPAs <code>@Embedded</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A limitation in Hibernate actually requires the use of flat entity views for mapping of element collections i.e. you can map the element collection 1:1 to the entity view.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="subquery-mappings"><a class="anchor" href="#subquery-mappings"></a>3.7. Subquery mappings</h3>
<div class="paragraph">
<p>Subquery mappings allow to map scalar subqueries into entity views and are declared by annotating the desired attribute with <code>@MappingSubquery</code> and specifying a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/SubqueryProvider.html"><code>SubqueryProvider</code></a>.
The following example should illustrate the usage:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @MappingSubquery(KittenCountSubqueryProvider.class)
    Long getKittenCount();

    class KittenCountSubqueryProvider implements SubqueryProvider {

        @Override
        public &lt;T&gt; T createSubquery(SubqueryInitiator&lt;T&gt; subqueryBuilder) {
            return subqueryBuilder.from(Cat.class, "subCat")
                    .select("COUNT(*)")
                    .whereOr()
                        .where("subCat.father.id").eqExpression("OUTER(id)")
                        .where("subCat.mother.id").eqExpression("OUTER(id)")
                    .endOr()
                .end();
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>This entity view already comes into contact with the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html">core</a> API for creating subqueries.
It produces just what it defines, a subquery in the select clause.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.father.id = cat.id
           OR subCat.mother.id = cat.id
    )
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>In the subquery provider before you saw the usage of <code>OUTER</code> which is gone in the final query.
This is because <code>OUTER</code> is a way to refer to attributes of the parent query root without having to refer to the concrete the query alias.
For more information on this check out the documentation of the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#outer-function"><code>OUTER</code> function</a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The subquery was just used for illustration purposes and could be replaced with a basic mapping <code>SIZE(kittens)</code> which would also generate a more efficient query.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="anchor-parameter-mappings"><a class="anchor" href="#anchor-parameter-mappings"></a>3.8. Parameter mappings</h3>
<div class="paragraph">
<p>A parameter mapping is a convenient way to <em>inject</em> the values of query parameters or optional parameters into instances of an entity view.
Introducing a parameter mapping with <code>@MappingParameter</code> will introduce a <em>fake</em> select item. If a parameter is not used in a query, <code>NULL</code> will be injected into the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @MappingParameter("myParam")
    String getMyParam();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, NULLIF(1,1)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>Parameter mappings are probably most useful in <a href="#anchor-constructor-mapping">constructor mappings</a> where they can be used for some transformation logic.</p>
</div>
</div>
<div class="sect2">
<h3 id="entity-mappings"><a class="anchor" href="#entity-mappings"></a>3.9. Entity mappings</h3>
<div class="paragraph">
<p>Apart from having custom projections for entity or embeddable types through subviews, you can also map the JPA managed types directly.
You can use the <code>@Mapping</code> annotation if desired and map any path expression as singular or plural attribute(i.e. collection) with managed types.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    Cat getFather();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, father_1
FROM Cat cat
LEFT JOIN cat.father father_1</pre>
</div>
</div>
<div class="paragraph">
<p>Beware that when using managed types directly, you might run into <em>lazy loading</em> issues when accessing uninitialized/un-fetched properties of the entity.</p>
</div>
<div class="paragraph">
<p>You can however specify what properties should be fetched for such entity mappings by using the <code>fetches</code> configuration.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @Mapping(fetches = "kittens")
    Cat getFather();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will fetch the kittens of the father.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, father_1
FROM Cat cat
LEFT JOIN cat.father father_1
LEFT JOIN FETCH father_1.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="collection-mappings"><a class="anchor" href="#collection-mappings"></a>3.10. Collection mappings</h3>
<div class="paragraph">
<p>One of the most important features of the Blaze Persistence entity view module is the possibility to map collections.
You can map collections defined in the entity model to collections in the entity view model in multiple ways.</p>
</div>
<div class="sect3">
<h4 id="simple-1-1-collection-mapping"><a class="anchor" href="#simple-1-1-collection-mapping"></a>3.10.1. Simple 1:1 collection mapping</h4>
<div class="paragraph">
<p>The simplest possible mapping is a 1:1 mapping of e.g. a *ToMany collection.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    Set&lt;Cat&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will simply join the <code>kittens</code> collection. During entity view construction the elements are collected and the result is flattened as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subset-basic-collection-mapping"><a class="anchor" href="#subset-basic-collection-mapping"></a>3.10.2. Subset basic collection mapping</h4>
<div class="paragraph">
<p>Most of the time, only a subset of the properties of a relation is needed. In case only a single property is required,
the use of <code>@Mapping</code> to refer to the property within a collection can be used.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    @Mapping("kittens.name")
    Set&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will join the <code>kittens</code> collection and only select their <code>name</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subview-collection-mapping"><a class="anchor" href="#subview-collection-mapping"></a>3.10.3. Subview collection mapping</h4>
<div class="paragraph">
<p>For the cases when multiple properties of a relation are needed, you can also use subviews.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    Set&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Applying the <code>CatView</code> entity view will again join the <code>kittens</code> collection but this time select some more properties.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>A subview within a collection can have subviews and collections of subviews again i.e. there is no limit to nesting.</p>
</div>
</div>
<div class="sect3">
<h4 id="collection-type-re-mapping"><a class="anchor" href="#collection-type-re-mapping"></a>3.10.4. Collection type re-mapping</h4>
<div class="paragraph">
<p>Another nice feature of Blaze Persistence entity views is the ability to re-map a collection to a different collection type.
In the entity model one might for example choose to always use a <code>java.util.Set</code> for mapping collections,
but to be able to make use of the elements in a UI, you might require e.g. a <code>java.util.List</code>.</p>
</div>
<div class="paragraph">
<p>Although the <code>kittens</code> relation in the <code>Cat</code> entity uses a <code>Set</code>, you can map the <code>kittens</code> as <code>List</code> in the <code>CatView</code>.
As you might expect, the order of the elements will then depend on the order of the query result.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    List&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>By executing the query with a custom <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-order-by-clause"><code>ORDER BY</code> clause</a>, the result order can be made deterministic.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;CatView&gt; result = entityViewManager.applySetting(
        EntityViewSetting.create(CatView.class),
        cb.create(Cat.class)
            .orderByAsc("name")
            .orderByAsc("kittens.name")
    ).getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1
ORDER BY cat.name       ASC NULLS LAST,
         kittens_1.name ASC NULLS LAST</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We do not recommend to rely on this behavior but instead make use of sorted collection mappings.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ordered-collection-mapping"><a class="anchor" href="#ordered-collection-mapping"></a>3.10.5. Ordered collection mapping</h4>
<div class="paragraph">
<p>Apart from changing the collection type to e.g. <code>List</code> it is also possible to get <em>ordered</em> results with sets.
By specifying <code>ordered = true</code> for the collection via the annotation <code>@CollectionMapping</code> you can force a set implementation that retains the insertion order like a <code>LinkedHashSet</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @CollectionMapping(ordered = true)
    Set&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The query doesn&#8217;t change, the only thing that does, is the implementation for the collection.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>This oviously only makes sense when used along with an <em>ORDER BY</em> clause that orders the result set deterministically.</p>
</div>
</div>
<div class="sect3">
<h4 id="sorted-collection-mapping"><a class="anchor" href="#sorted-collection-mapping"></a>3.10.6. Sorted collection mapping</h4>
<div class="paragraph">
<p>In addition to ordering, the following sorted collection types are supported</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SortedSet</code> and <code>NavigableSet</code></p>
</li>
<li>
<p><code>SortedMap</code> and <code>NavigableMap</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can specify the comparator for the collection via the annotation <code>@CollectionMapping</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();

    static class DefaultComparator implements Comparator&lt;SimpleCatView&gt; {

        @Override
        public int compare(SimpleCatView o1, SimpleCatView o2) {
            return String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName());
        }
    }
}

@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @CollectionMapping(comparator = SimpleCatView.DefaultComparator.class)
    SortedSet&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure the correct ordering of the collection elements regardless of the query ordering.
The query stays the same.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittens_1.id, kittens_1.name
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="indexed-collection-re-mapping"><a class="anchor" href="#indexed-collection-re-mapping"></a>3.10.7. Indexed collection re-mapping</h4>
<div class="paragraph">
<p>Mapping an indexed collection like a <code>java.util.Map</code> or <code>java.util.List</code> with an <code>@OrderColumn</code> can happen in multiple ways.
Let&#8217;s consider the following model.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
class Cat {
    @Id
    Long id;

    @OneToMany
    @OrderColumn
    List&lt;Cat&gt; indexedKittens;

    @ManyToMany
    Map&lt;Cat, Cat&gt; kittensBestFriends;
}

@EntityView(Cat.class)
interface SimpleCatView {
    @IdMapping
    Long getId();

    String getName();
}</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Indexed mapping</dt>
<dd>
<p>One way is to map the collections indexed again, i.e. a <code>Map</code> in the entity is mapped as <code>Map</code> in the entity view.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    List&lt;SimpleCatView&gt; getIndexedKittens();

    Map&lt;SimpleCatView, SimpleCatView&gt; getKittensBestFriends(); <i class="conum" data-value="1"></i><b>(1)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Careful when mapping the key to a subview. This is only supported in the latest JPA provider versions</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,

    INDEX(indexedKittens_1),
    indexedKittens_1.id,
    indexedKittens_1.name

    KEY(kittensBestFriends_1).id,
    KEY(kittensBestFriends_1).name,

    kittensBestFriends_1.id,
    kittensBestFriends_1.name
FROM Cat cat
LEFT JOIN cat.indexedKittens indexedKittens_1
LEFT JOIN cat.kittensBestFriends kittensBestFriends_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Map-Key only mapping</dt>
<dd>
<p>By using the qualified expression <code>KEY()</code> you can map the keys of a map to a collection by using <code>@Mapping</code></p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @Mapping("KEY(kittensBestFriends)")
    List&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, KEY(kittensBestFriends_1).id, KEY(kittensBestFriends_1).name
FROM Cat cat
LEFT JOIN cat.kittensBestFriends kittensBestFriends_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Map-Value only mapping</dt>
<dd>
<p>Simply mapping a path expression for a <code>Map</code> to a normal collection, will result in only fetching the map values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @Mapping("kittensBestFriends")
    List&lt;SimpleCatView&gt; getBestFriends();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, kittensBestFriends_1.id, kittensBestFriends_1.name
FROM Cat cat
LEFT JOIN cat.kittensBestFriends kittensBestFriends_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">List-Value only mapping</dt>
<dd>
<p>Sometimes it might be required to ignore the index of an indexed <code>List</code> when mapping it to a <code>List</code> again. To do so use <code>ignoreIndex</code> on <code>@CollectionMapping</code></p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView extends SimpleCatView {

    @Mapping("indexedKittens")
    @CollectionMapping(ignoreIndex = true)
    List&lt;SimpleCatView&gt; getKittens();
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, indexedKittens_1.id, indexedKittens_1.name
FROM Cat cat
LEFT JOIN cat.indexedKittens indexedKittens_1</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="singular-collection-type-mappings"><a class="anchor" href="#singular-collection-type-mappings"></a>3.11. Singular collection type mappings</h3>
<div class="paragraph">
<p>There are cases when the entity model defines a collection that is actually a singular entity attribute. This can happen when you use custom type implementations or JPA 2.1 attribute converters that produce collections.
A custom type or converter could map a DBMS array, json, xml or any other type to a collection. Since such an entity attribute is not a relation, it can only be a singular attribute.
By default Blaze Persistence entity views assume that an entity view attribute with a collection type is a plural attribute and the mapping refers to a plural entity attribute.
In order to be able to map such special singular attribute collections, you have to specifically use <code>@MappingSingular</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
class Cat {

    @Id
    Long id;

    @Basic
    @Convert(converter = StringSetConverter.class)
    Set&lt;String&gt; tags;
}

class StringSetConverter implements AttributeConverter&lt;String, Set&lt;String&gt;&gt; { ... }

@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    @MappingSingular
    Set&lt;String&gt; getTags();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Beware that you can&#8217;t re-map the collection type in this case although this might soon be possible. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/361">#361</a> for further information.</p>
</div>
<div class="paragraph">
<p>The query will not generate a join but simply select the <code>tags</code> since it&#8217;s a singular attribute.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, cat.tags
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-correlation-mappings"><a class="anchor" href="#anchor-correlation-mappings"></a>3.12. Correlated mappings</h3>
<div class="paragraph">
<p>In some entity models, not every relation between entities might be explicitly mapped. There are multiple possible reasons for that like e.g. not wanting to have explicit dependencies, to keep it simple etc.
Apart from unmapped relations, there is sometimes the need to <em>correlate</em> entities based on some criteria with other entities which are more of an ad-hoc nature than explicit relations.</p>
</div>
<div class="paragraph">
<p>For these cases Blaze Persistence entity views introduces the concept of <em>correlated mappings</em>. These mappings can be used to connect entities through a custom criteria instead of through mapped entity relations.
Correlated mappings can be used for any attribute type(basic, entity, subview, collection) although singular basic attributes can also be implemented as <a href="#subquery-mappings">normal subqueries</a>.</p>
</div>
<div class="paragraph">
<p>A correlation mapping is declared by annotating the desired attribute with <code>@MappingCorrelated</code> or <code>@MappingCorrelatedSimple</code>.</p>
</div>
<div class="sect3">
<h4 id="general-correlated-mappings"><a class="anchor" href="#general-correlated-mappings"></a>3.12.1. General correlated mappings</h4>
<div class="paragraph">
<p>In order to map the correlation you need to specify some values</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>correlationBasis</code> - An expression that maps to the so called <em>correlation key</em></p>
</li>
<li>
<p><code>correlator</code> - The <code>CorrelationProvider</code> to use for the correlation that introduces a so called <em>correlated entity</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the correlated entity type is <em>projected into</em> the view. To map a specific property of the entity type, use the <code>correlationResult</code> attribute.
There is also the possibility to specify a <a href="#anchor-fetch-strategies"><em>fetch strategy</em></a> that should be used for the correlation. By default, the <code>SELECT</code> strategy is used.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        fetch = FetchStrategy.JOIN
    )
    Set&lt;Person&gt; getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String alias = builder.getCorrelationAlias();  <i class="conum" data-value="1"></i><b>(1)</b>
            builder.correlate(Person.class)
                .on(alias + ".age").inExpressions(correlationExpression) <i class="conum" data-value="2"></i><b>(2)</b>
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>getCorrelationAlias()</code> defines the alias for the correlated entity</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>correlationExpression</code> represents the <code>correlationBasis</code>. We generally recommend to use the <code>IN</code> predicate through <code>inExpressions()</code> to be able to easily switch the fetch strategy</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on the fetch strategy multiple other queries might be executed. Check out the different <a href="#anchor-fetch-strategies">fetch strategies</a> for further information.
In this case, the <code>JOIN</code> strategy was used, so the following query is generated.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, pers
FROM Cat cat
LEFT JOIN Person correlated_SameAgedPersons <i class="conum" data-value="1"></i><b>(1)</b>
       ON cat.age = correlated_SameAgedPersons.age <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This makes use of the so called <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-entity-joins"><code>entity join</code> feature</a> which is only available in newer JPA provider versions</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Note that the <code>IN</code> predicate which was used in the correlation provider was rewritten to a equality predicate</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since entity joins are required for using the <code>JOIN</code> fetch strategy with correlation mappings you have to make sure your JPA provider supports them.
If your JPA provider does not support entity joins, you have to use a different fetch strategy instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="simple-correlated-mappings"><a class="anchor" href="#simple-correlated-mappings"></a>3.12.2. Simple correlated mappings</h4>
<div class="paragraph">
<p>Since correlation providers are mostly static, Blaze Persistence also offers a way to define simple correlations in a declarative manner.
The <code>@MappingCorrelatedSimple</code> annotation only requires a few values</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>correlationBasis</code> - An expression that maps to the so called <em>correlation key</em></p>
</li>
<li>
<p><code>correlated</code> - The <em>correlated entity</em> type</p>
</li>
<li>
<p><code>correlationExpression</code> - The expression to use for correlating the <em>correlated entity</em> type to the view</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
public interface PersonView {

    @IdMapping
    Long getId();

    String getName();
}

@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlated = Person.class,
        correlationExpression = "age IN correlationKey" <i class="conum" data-value="1"></i><b>(1)</b>
        fetch = FetchStrategy.JOIN
    )
    Set&lt;PersonView&gt; getSameAgedPersons(); <i class="conum" data-value="2"></i><b>(2)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The expression uses the default name for the correlation key but could use a different name by specifying the attribute <code>correlationKeyAlias</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As you see here, it is obviously also possible to map subviews for correlated entity types</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just like the general correlation, by default, the correlated entity type is <em>projected into</em> the view. To map a specific property of the entity type, use the <code>correlationResult</code> attribute.
There is also the possibility to specify a <a href="#anchor-fetch-strategies"><em>fetch strategy</em></a> that should be used for the correlation. By default, the <code>SELECT</code> strategy is used.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="special-method-attributes"><a class="anchor" href="#special-method-attributes"></a>3.13. Special method attributes</h3>
<div class="paragraph">
<p>There are some special methods that can be declared abstract in an entity view type which have special runtime support.</p>
</div>
<div class="sect3">
<h4 id="entity-view-special-method-entity-view-manager-getter"><a class="anchor" href="#entity-view-special-method-entity-view-manager-getter"></a>3.13.1. EntityViewManager getter</h4>
<div class="paragraph">
<p>An abstract method that returns <code>EntityViewManager</code> will not be considered to be an attribute.
Such a method has special runtime support as it will always return the associated <code>EntityViewManager</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
public abstract class PersonView {

    @IdMapping
    public abstract Long getId();

    abstract EntityViewManager getEntityViewManager();

    public void someMethod() {
        // ... use getEntityViewManager()
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>This is especially useful for <a href="#updatable-entity-views">Updatable Entity Views</a> when a method wants to create a new instance of a subview or get a reference to a subview.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping-expression-extensions"><a class="anchor" href="#mapping-expression-extensions"></a>3.14. Mapping expression extensions</h3>
<div class="paragraph">
<p>Blaze Persistence entity views generally supports the full set of <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#expressions">expressions</a> that JPQL and Blaze Persistence core module supports,
but in addition to that, also offers some expression extensions.</p>
</div>
<div class="sect3">
<h4 id="this"><a class="anchor" href="#this"></a>3.14.1. THIS</h4>
<div class="paragraph">
<p>Similar to the <code>this</code> expression in Java, in a mapping expression within entity views the <code>this</code> expression can be used to refer to the entity type backing the entity view.
The expression can be used to implement embedded objects that are able to refer to the entity type of the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface EmbeddedCatView {

    @IdMapping
    Long getId();

    String getName();
}

@EmbeddableEntityView(Cat.class)
interface ExternalInterfaceView {

    @Mapping("name")
    String getExternalName();
}

@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    @Mapping("this")
    EmbeddedCatView getEmbedded();

    @Mapping("this")
    ExternalInterfaceView getAdapter();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Both <code>EmbeddedCatView</code> and <code>ExternalInterfaceView</code> refer to the same <code>Cat</code> as their parent <code>CatView</code>.
The query looks as if the types were directly embedded into the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    cat.id,
    cat.name,
    cat.name
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="outer"><a class="anchor" href="#outer"></a>3.14.2. OUTER</h4>
<div class="paragraph">
<p>In Blaze Persistence core the <code>OUTER</code> function can be used to refer to the query root of a parent query from within a subquery.
This is still the same with Blaze Persistence entity views but might lead to unintuitive behavior when the subquery provider uses <code>OUTER</code> and is used in a subview.
The following example shows the unintuitive behavior.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    Set&lt;KittenCatView&gt; getKittens();
}

@EntityView(Cat.class)
interface KittenCatView {

    @IdMapping
    Long getId();

    @MappingSubquery(KittenCountSubqueryProvider.class)
    Long getKittenCount();

    class KittenCountSubqueryProvider implements SubqueryProvider {

        @Override
        public &lt;T&gt; T createSubquery(SubqueryInitiator&lt;T&gt; subqueryBuilder) {
            return subqueryBuilder.from(Cat.class, "subCat")
                    .select("COUNT(*)")
                    .whereOr()
                        .where("subCat.father.id").eqExpression("OUTER(id)")
                        .where("subCat.mother.id").eqExpression("OUTER(id)")
                    .endOr()
                .end();
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>When applying the <code>KittenCatView</code> directly, everything works as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.father.id = cat.id
        OR subCat.mother.id = cat.id
    )
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>But when using <code>KittenCatView</code> as subview within <code>CatView</code>, it starts to break.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.id,
    kittens_1.id,
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.father.id = cat.id <i class="conum" data-value="1"></i><b>(1)</b>
           OR subCat.mother.id = cat.id
    )
FROM Cat cat
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>OUTER</code> resolved to <code>cat</code> instead of <code>kittens_1</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>OUTER</code> function doesn&#8217;t know about the entity view structure and will remain to refer to the <strong>query root</strong>.</p>
</div>
<div class="paragraph">
<p>In the future, a function <code>EMBEDDING_VIEW</code> will be introduced to be able to refer to the <em>embedding entity view</em>. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/367">#367</a> for more information on this.</p>
</div>
</div>
<div class="sect3">
<h4 id="view_root"><a class="anchor" href="#view_root"></a>3.14.3. VIEW_ROOT</h4>
<div class="paragraph">
<p>The <code>VIEW_ROOT</code> function can be used to refer to the relation for which the main entity view is applied.
Normally this will resolve to the query root, but beware that the entity view root might not always be the query root.
One of the main use cases for this function is when using <a href="#anchor-correlation-mappings">correlated subview mappings</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For further information on applying a different entity view root take a look into the <a href="#anchor-entity-view-apply-root">querying chapter</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>VIEW_ROOT</code> function can be used in a correlation provider to additionally refer to a view root.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = CatAgeCorrelationProvider.class
    )
    Set&lt;Cat&gt; getSameAgedCats();

    static class CatAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String correlatedCat = builder.getCorrelationAlias();
            builder.correlate(Cat.class)
                .on(correlatedCat + ".age").inExpressions(correlationExpression)
                .on(correlatedCat + ".id").notInExpressions("VIEW_ROOT(id)") <i class="conum" data-value="1"></i><b>(1)</b>
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We generally recommend to use the <code>IN</code> predicate through <code>inExpressions()</code> or <code>notInExpressions()</code> to be able to easily switch the fetch strategy</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>VIEW_ROOT</code> function is usable with every fetch strategy. In case of the <code>JOIN</code> fetch strategy the result is just as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, correlatedCat
FROM Cat cat
LEFT JOIN Cat correlatedCat
       ON correlatedCat.age = cat.age
      AND correlatedCat.id &lt;&gt; cat.id <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Again, the <code>IN</code> predicate was rewritten to an equality predicate</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Make sure you understand the &lt;&lt;anchor-select-fetch-strategy-view-root,implication&gt; of the <code>VIEW_ROOT</code> function when using the batched <code>SELECT</code> fetch strategy as this might affect performance.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-constructor-mapping"><a class="anchor" href="#anchor-constructor-mapping"></a>3.15. Entity View constructor mapping</h3>
<div class="paragraph">
<p>So far, all mapping examples used interfaces for entity views, but as outlined in the beginning, Blaze Persistence entity views also has support for abstract classes.
There are multiple use cases for using abstract classes for entity views, but in general we recommend to use an interface as often as possible.
The biggest advantage of using abstract classes is that you can have a custom constructor which can further apply transformations on data.</p>
</div>
<div class="sect3">
<h4 id="abstract-class-entity-view-with-custom-equals-hashcode"><a class="anchor" href="#abstract-class-entity-view-with-custom-equals-hashcode"></a>3.15.1. Abstract class Entity View with custom equals-hashCode</h4>
<div class="paragraph">
<p>Abstract classes, contrary to interfaces, can define an implementation for the equals and hashCode methods which is normally generated for the runtime implementations of Entity Views.
If you decide to have a custom implementation you have to fulfill the general requirement, that the equals and hashCode methods use</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only the attribute mapped with <code>@IdMapping</code> if there is one</p>
</li>
<li>
<p>Otherwise use all attributes of the Entity View</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Not following these requirements could lead to unexpected results so it is generally best to rely on the default implementation.
For every custom implementation that is detected during the bootstrap a warning message will be logged.</p>
</div>
</div>
<div class="sect3">
<h4 id="map-external-data-model-with-view-constructor"><a class="anchor" href="#map-external-data-model-with-view-constructor"></a>3.15.2. Map external data model with view constructor</h4>
<div class="paragraph">
<p>One of those use cases for a view constructor is integrating with an existing external data model.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">class CatRestDTO {
    private final Long id;
    private final String name;

    public MyOldCatDTO(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>In general we recommend to use the entity view types directly instead of an external data model, because of the additional boilerplate code needed.
Note that the creators of Blaze Persistence are not generally against external data models since it is reasonable to have them e.g. in API projects that shouldn&#8217;t expose a library dependency.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView extends CatRestDTO {

    public CatView(
        @Mapping("id") Long id,
        @Mapping("name") String name
    ) {
        super(id, name);
    }

}</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the <code>CatView</code> for efficient querying but still have objects that are an instance of <code>CatRestDTO</code> and can thus be used like normal <code>CatRestDTO</code> instances.
To decouple the actual entity view <code>CatView</code> from the data access or service one normally uses method signatures like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">interface CatDAO {
    &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityViewClass); <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;T&gt; List&lt;T&gt; findAll(EntityViewSetting&lt;T, CriteriaBuilder&lt;T&gt;&gt; entityViewSetting); <i class="conum" data-value="2"></i><b>(2)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the <code>EntityViewSetting</code> within the implementation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Supply a custom <code>EntityViewSetting</code> which can also have filters, sorts, optional parameters and pagination information</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By using one of these approaches you can have a projection independent implementation for <code>CatDAO</code> and let the consumer i.e. a REST endpoint decide about the representation.</p>
</div>
</div>
<div class="sect3">
<h4 id="additional-data-transformation-in-view-constructor"><a class="anchor" href="#additional-data-transformation-in-view-constructor"></a>3.15.3. Additional data transformation in view constructor</h4>
<div class="paragraph">
<p>Another use case for view constructors is the transformation of data. Sometimes it is just easier to do the transformation in Java code instead of through a JPQL expression,
but then there are also times when there is no other way than doing it in Java code.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume you want to have an attribute that contains different text based on the age.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {

    @IdMapping
    Long getId();

    @Mapping("CASE WHEN age = 0 THEN 'newborn' WHEN age &lt; 10 THEN 'child' WHEN age &lt; 18 THEN 'teenager' ELSE 'adult' END")
    String getText();

}</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>CASE WHEN</code> expression can be used to implement that, but if the text is only static, there is no need to use that kind of expression.
You can instead just inject the <code>age</code> as constructor parameter and do the mapping to the text in Java code.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(@Mapping("age") long age) {
        if (age == 0) {
            this.text = "newborn";
        } else if (age &lt; 10) {
            this.text = "child";
        } else if (age &lt; 18) {
            this.text = "teenager";
        } else {
            this.text = "adult";
        }
    }

    @IdMapping
    public abstract Long getId();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Since that kind of mapping logic is normally externalized, Blaze Persistence entity views also offers a way to <em>inject</em> external services.
You can provide services to entity views via <a href="#anchor-optional-parameters"><em>optional parameters</em></a> like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, CriteriaBuilder&lt;CatView&gt;&gt; setting
    = EntityViewSetting.create(CatView.class);

setting.addOptionalParameter("ageMapper", new AgeToTextMapper());
List&lt;CatView&gt; result = entityViewManager.applySetting(setting, cbf.create(em, Cat.class))
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>The services, or optional parameters in general can be consumed either as attributes or as constructor parameters with <code>@MappingParameter</code>.
If the parameter is not supplied, <code>null</code> is injected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(
        @Mapping("age") long age,
        @MappingParameter("ageMapper") AgeToTextMapper mapper
    ) {
        this.text = ageMapper.map(age);
    }

    @IdMapping
    public abstract Long getId();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anchor-named-constructor"><a class="anchor" href="#anchor-named-constructor"></a>3.15.4. Multiple named constructors</h4>
<div class="paragraph">
<p>So far, the example always used no or just a single constructor, but it is actually possible to have multiple constructors.
Every constructor in an entity view must have a name defined via <code>@ViewConstructor</code>. The default name is <code>init</code> and is used for constructors that have no <code>@ViewConstructor</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(
        @Mapping("age") long age,
        @MappingParameter("ageMapper") AgeToTextMapper mapper
    ) {
        this.text = ageMapper.map(age);
    }

    @ViewConstructor("special")
    public CatView(@Mapping("age") long age) {
        this.text = age &gt; 80 ? "oldy" : "normal";
    }

    @IdMapping
    public abstract Long getId();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The constructor name can be chosen when constructing a <code>EntityViewSetting</code> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#create(java.lang.Class,%20java.lang.String)"><code>create()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting.create(CatView.class, "special");</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-attribute-getters-in-constructor"><a class="anchor" href="#using-attribute-getters-in-constructor"></a>3.15.5. Using attribute getters in constructor</h4>
<div class="paragraph">
<p>Since mapping constructor parameters can become very cumbersome and oftentimes you need a value not only in the constructor but also accessible directly via a getter,
Blaze Persistence came up with a solution that allows you to use the getters of attributes in the constructor.</p>
</div>
<div class="paragraph">
<p>It might not be immediately obvious why this is a special thing. Since entity views are declared as abstract classes you can imagine that the runtime has to actually create concrete classes.
These concrete classes <em>normally</em> initialize fields <strong>after</strong> calling the super constructor, thus making it impossible for the super constructor to actually retrieve values by using the attribute getters.
The JVM enforces that fields can only be accessed after the super constructor has been called, so normally there is no way that the getter implementations that serve the fields can return non-null values in the super constructor.
Fortunately, Blaze Persistence entity views found a way around this limitation of the JVM by making use of the infamous <code>sun.misc.Unsafe</code> to define a class that would normally fail bytecode verification.
The trick is, that the implementations that are generated will set the fields before calling the super constructor thus making the values available to the super constructor.</p>
</div>
<div class="paragraph">
<p>By default, all abstract classes will be defined through <code>sun.misc.Unsafe</code>.
If you don&#8217;t want that behavior and instead want bytecode verifiable implementations to be generated, you can always disable this strategy by using a <a href="#proxy-unsafe-allowed">configuration property</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public abstract class CatView {

    private final String text;

    public CatView(@MappingParameter("ageMapper") AgeToTextMapper mapper) {
        this.text = ageMapper.map(getAge()); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @IdMapping
    public abstract Long getId();

    public abstract Long getAge();

    public String getText() {
        return text;
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the unsafe proxy is used, <code>getAge()</code> will return the actual value, otherwise it will return <code>null</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inheritance-mapping"><a class="anchor" href="#inheritance-mapping"></a>3.16. Inheritance mapping</h3>
<div class="paragraph">
<p>Entity views can have an inheritance relationship to subtypes via an inheritance mapping. This relationship allows instances of an entity view subtype to be materialized when a selection predicate
defined by an inheritance mapping is satisfied.</p>
</div>
<div class="paragraph">
<p>The inheritance feature for an entity view is activated by annotating <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewInheritance.html"><code>@EntityViewInheritance</code></a> on an entity view.
By default, all subtypes of the entity view are considered as inheritance subtypes and thus require a so called <em>inheritance mapping</em>.</p>
</div>
<div class="paragraph">
<p>An <em>inheritance mapping</em> is defined by annotating the subtype with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewInheritanceMapping.html"><code>@EntityViewInheritanceMapping</code></a> and defining
a selection predicate that represents the condition on which decides the instantiation of that subtype. The predicate is a normal <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#expressions">JPQL predicate expression</a>
and can refer to all attributes of the mapped entity type.</p>
</div>
<div class="paragraph">
<p>Consider the following example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@EntityViewInheritance
public interface BaseCatView {
    String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &lt; 18")
public interface YoungCatView extends BaseCatView {
    @Mapping("mother.name")
    String getMotherName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &gt; 18")
public interface OldCatView extends BaseCatView {
    @Mapping("kittens.name")
    List&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When querying for entity views of the type <code>BaseCatView</code>, the selection predicates <code>age &lt; 18</code> and <code>age &gt; 18</code> are <em>merged</em> into a <em>type discriminator</em> expression that returns a type index.
The type index refers to the entity view type into which a result should be materialized. The resulting JPQL query for such an entity view looks like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    CASE
        WHEN age &lt; 18 THEN 1
        WHEN age &gt; 18 THEN 2
        ELSE 0
    END,
    cat.name,
    mother_1.name,
    kittens_1.name
FROM Cat cat
LEFT JOIN cat.mother mother_1
LEFT JOIN cat.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>The type index 0 refers to the base type <code>BaseCatView</code>, hence instances of <code>BaseCatView</code> are materialized when the age of a result equals 18.</p>
</div>
<div class="paragraph">
<p>Since it might not be desirable to use all entity view subtypes for the inheritance relationship, it is possible to explicitly declare the subtypes in the <code>@EntityViewInheritance</code> annotation on the super type.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@EntityViewInheritance({ YoungCatView.class })
public interface BaseCatView {
    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>This has the effect, that only <code>BaseCatView</code> or <code>YoungCatView</code> instances are materialized for a result.</p>
</div>
</div>
<div class="sect2">
<h3 id="inheritance-subview-mapping"><a class="anchor" href="#inheritance-subview-mapping"></a>3.17. Inheritance subview mapping</h3>
<div class="paragraph">
<p>Similarly to specifying the entity view inheritance subtypes at the declaration site, i.e. <code>BaseCatView</code>, it is also possible to define subtypes at the <em>use site</em>, i.e. at the subview attribute.
By annotating the subview attribute with <code>@MappingInheritance</code>, it is possible to delimit and override the entity view subtype mappings that are considered for materialization from the result.
When using the <code>@MappingInheritance</code> annotation, it is required to list all desired subtypes via <code>@MappingInheritanceSubtype</code> annotations that can optionally override the inheritance mapping.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
interface PersonView {
    String getName();
    @MappingInheritance({
        @MappingInheritanceSubtype(mapping = "age &lt;= 18", value = YoungCatView.class)
    })
    Set&lt;BaseCatView&gt; getCats();
}

@EntityView(Cat.class)
@EntityViewInheritance
public interface BaseCatView {
    String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &lt; 18")
public interface YoungCatView extends BaseCatView {
    @Mapping("mother.name")
    String getMotherName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &gt; 18")
public interface OldCatView extends BaseCatView {
    @Mapping("kittens.name")
    List&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When querying for <code>PersonView</code>, <code>YoungCatView</code> instances will be materialized if the cat&#8217;s age is lower <strong>or equal</strong> to 18 and otherwise instances of <code>BaseCatView</code> will be created.
By setting the annotation property <code>onlySubtypes</code> to true, instances of the base type <code>BaseCatView</code> aren&#8217;t materialized but a null is propagated.
Apart from skipping the base type, it is also possible to define the base type via <code>@MappingInheritanceSubtype</code> which allows to specify the inheritance mapping for the base type.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When no <code>@MappingInheritanceSubtype</code> elements are given, only the base type is materialized which can be used to <em>disable</em> the inheritance feature for an attribute.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is illegal to set <code>onlySubtypes</code> to true and have an empty set of subtype mappings as that would always result in a <code>null</code> object.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="inheritance-mapping-with-constructors"><a class="anchor" href="#inheritance-mapping-with-constructors"></a>3.17.1. Inheritance mapping with constructors</h4>
<div class="paragraph">
<p>Entity view inheritance is not limited to interface types but can also be used with custom constructors.
If a view constructor is used, all entity view inheritance subtypes must have a view constructor with the same name.
In case of just a single constructor the <code>@ViewConstructor</code> does not have to be applied, as the name <code>init</code> is chosen by default as name.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@EntityViewInheritance
public abstract class BaseCatView {

    private final String parentName;

    public BaseCatView(@Mapping("father.name") String parentName) {
        this.parentName = parentName;
    }

    public abstract String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &lt; 18")
public abstract class YoungCatView extends BaseCatView {

    public YoungCatView(@Mapping("mother.name") String parentName) {
        super(parentName);
    }

    @Mapping("mother.name")
    public abstract String getMotherName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping("age &gt; 18")
public abstract class OldCatView extends BaseCatView {

    public OldCatView() {
        super("None");
    }

    @Mapping("kittens.name")
    public abstract List&lt;String&gt; getKittenNames();
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="inheritance-mapping-and-jpa-inheritance"><a class="anchor" href="#inheritance-mapping-and-jpa-inheritance"></a>3.17.2. Inheritance mapping and JPA inheritance</h4>
<div class="paragraph">
<p>The most obvious use case for entity view inheritance is mapping JPA entities that use an inheritance relationship.
Blaze Persistence supports this and also makes use of defaults for the inheritance mapping in case a entity view subtype uses an entity subtype in the <code>@EntityView</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Animal.class)
@EntityViewInheritance
public interface AnimalView {

    String getName();
}

@EntityView(Cat.class)
@EntityViewInheritanceMapping
public interface CatView extends AnimalView {

    String getKittyName();
}

@EntityView(Dog.class)
@EntityViewInheritanceMapping
public interface DogView extends AnimalView {

    String getDoggyName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DogView</code> uses the entity <code>Dog</code> and <code>CatView</code> the entity <code>Cat</code> which are both subtypes of <code>Animal</code>. In this case no inheritance mapping needs to be provided as Blaze Persistence will
generate a type constraint like <code>TYPE(this) = Dog</code> or <code>TYPE(this) = Cat</code> for the respective entity view subtypes <code>DogView</code> and <code>CatView</code>.
The resulting JPQL query when using <code>AnimalView</code> might look like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    CASE
        WHEN TYPE(animal) = Cat THEN 1
        WHEN TYPE(animal) = Dog THEN 2
        ELSE 0
    END,
    animal.name,
    TREAT(animal AS Cat).kittyName,
    TREAT(animal AS Dog).doggyName
FROM Animal animal</pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, the expressions for the access of the subtype properties rightfully make use of the <code>TREAT</code> operator.</p>
</div>
<div class="paragraph">
<p>An entity view could also be modelled flat i.e. not mirroring the entity inheritance relationship as entity views, but just put the desired properties on a single entity view type.
This can be done by making use of the <code>TREAT</code> operator and the <code>this</code> expression in the entity view mappings just as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Animal.class)
@EntityViewInheritance
public interface MyAnimalView {

    String getName();

    @Mapping("TREAT(this AS Cat).kittyName")
    String getKittyName();

    @Mapping("TREAT(this AS Dog).doggyName")
    String getDoggyName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The generated query looks approximately like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    animal.name,
    TREAT(animal AS Cat).kittyName,
    TREAT(animal AS Dog).doggyName
FROM Animal animal</pre>
</div>
</div>
<div class="paragraph">
<p>and in case an animal is not of the treated type, a <code>null</code> value will be produced.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anchor-fetch-strategies"><a class="anchor" href="#anchor-fetch-strategies"></a>4. Fetch strategies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are multiple different fetch strategies available for fetching. A fetch strategy can be applied to all kinds of mappings,
except for <code>@MappingParameter</code> and <code>@MappingSubquery</code>. These mappings will always use a <code>JOIN</code> strategy, i.e. the mapping will be put into the main query.</p>
</div>
<div class="paragraph">
<p>Any attribute in an entity view can be fetched separately by specifying a fetch strategy other than <code>JOIN</code>.</p>
</div>
<div class="paragraph">
<p>Every fetch strategy has some pros and cons but most of the time, the <code>JOIN</code> fetch strategy is a good choice.
Unless you can&#8217;t use the <code>JOIN</code> strategy because your JPA provider doesn&#8217;t support entity joins, you should always stick with it by default
and only change the strategy on a case by case basis.</p>
</div>
<div class="sect2">
<h3 id="join-fetch-strategy"><a class="anchor" href="#join-fetch-strategy"></a>4.1. Join fetch strategy</h3>
<div class="paragraph">
<p>If your JPA provider supports entity joins, the <code>JOIN</code> strategy usually makes sense most of the time.
In case of correlated mappings it will result in a <code>LEFT JOIN</code> <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-entity-joins">entity join</a> of the correlated entity type.
The correlation expression created by the <code>CorrelationProvider</code> will be used in the <code>ON</code> condition.</p>
</div>
<div class="paragraph">
<p>For an example query that is generated by this strategy take a look at the <a href="#anchor-correlation-mappings">correlation mappings</a> chapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="select-fetch-strategy"><a class="anchor" href="#select-fetch-strategy"></a>4.2. Select fetch strategy</h3>
<div class="paragraph">
<p>In general, the <code>SELECT</code> strategy will create a separate query for every attribute that uses it.
It will collect up to <em>N</em> distinct correlation basis values and then will execute that query to actually fetch the values for the attributes of the instances.
The parameter <em>N</em> is the batch size that can be configured at multiple levels.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example that shows what happens</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @BatchFetch(20) <i class="conum" data-value="1"></i><b>(1)</b>
    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        fetch = FetchStrategy.SELECT
    )
    Set&lt;Person&gt; getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String pers = builder.getCorrelationAlias();
            builder.correlate(Person.class)
                .on(pers + ".age").inExpressions(correlationExpression)
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines the batch size to use for loading</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using this entity view, there are 2 queries that are generated.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The main query will fetch the <code>correlationBasis</code> and all the other attributes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    TREAT_LONG(correlationParams.value),
    correlated_SameAgedPersons
FROM Person correlated_SameAgedPersons,
     VALUES ((?), (?), ...) correlationParams <i class="conum" data-value="1"></i><b>(1)</b>
WHERE correlated_SameAgedPersons.age = TREAT_LONG(correlationParams.value)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Actually there will be 20 question marks here because of the defined batch size of 20</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The correlation query on the other hand will select the correlation value and the <code>Person</code> instances with an age matching any of the <code>correlationParams</code> values.
What you see here is the use of the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-values-clause"><code>VALUES</code> clause</a> for making multiple values available like a table for querying which is required when wanting to select the correlation value.
Selecting the actual correlation value via <code>TREAT_LONG(correlationParams.value)</code> along with the <code>Person</code> is necessary to be able to correlate the instances to the instance of the main query.</p>
</div>
<div class="paragraph">
<p>Depending on how many different values for <code>age</code> there are(cardinality), the correlation query might get executed multiple times.
In general, the runtime will collect up to <em>batch size</em> different values and then execute the correlation query for these values.
Results for a correlation value are cached during the querying to avoid querying the same correlation values multiple times in different batches.</p>
</div>
<div class="paragraph">
<p>This strategy works best when the cardinality of the <code>correlationBasis</code> is low i.e. there are only a few distinct values.
If the cardinality is high and the batch size is too low, this can lead to something similar as an <em>N + 1 select</em> known from lazy loading of collection elements.
You could theoretically choose a very big batch size to be able to handle more correlation values per query, but beware that there are limits to the efficiency of this approach.
Also beware that the amount of possible parameters might be limited by the DBMS. A value of <em>1000</em> for the batch size shouldn&#8217;t generally be a problem for a DBMS,
but before you configure such a high value, look into the <a href="#anchor-subselect-fetch-strategy">subselect</a> strategy which might be more appropriate for higher cardinalities.</p>
</div>
<div class="sect3">
<h4 id="select-fetch-strategy-with-batching"><a class="anchor" href="#select-fetch-strategy-with-batching"></a>4.2.1. Select fetch strategy with batching</h4>
<div class="paragraph">
<p>Apart from using the <code>@BatchFetch</code> annotation, there are some other ways to define a batch size for fetching of an attribute.</p>
</div>
<div class="sect4">
<h5 id="batch-size-default-per-entity-view"><a class="anchor" href="#batch-size-default-per-entity-view"></a>Batch size default per entity view</h5>
<div class="paragraph">
<p>A default batch size can be defined by setting the property <a href="#default-batch-size"><code>com.blazebit.persistence.view.batch_size</code></a> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>.
The value serves as default value and can be overridden on a per attribute basis.</p>
</div>
</div>
<div class="sect4">
<h5 id="batch-size-per-entity-view-attribute"><a class="anchor" href="#batch-size-per-entity-view-attribute"></a>Batch size per entity view attribute</h5>
<div class="paragraph">
<p>The batch size for a specific attribute can be defined either by using the <code>@BatchFetch</code> annotation or by setting the <a href="#default-batch-size"><code>com.blazebit.persistence.view.batch_size</code></a> property suffixed with the attribute name.
In order to set the batch size for an attribute named <em>someAttribute</em> you have to set the property <code>com.blazebit.persistence.view.batch_size.someAttribute</code> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>.
The path to the attribute is based on the entity view which is queried and can also be deep i.e. <code>someSubview.someAttribute</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anchor-select-fetch-strategy-view-root"><a class="anchor" href="#anchor-select-fetch-strategy-view-root"></a>4.2.2. Select fetch strategy with VIEW_ROOT</h4>
<div class="paragraph">
<p>One possible problem with this strategy might arise when using the <code>VIEW_ROOT</code> function. The use of two correlation keys i.e. the view root and the correlation basis,
will affect the way the batching can be done. Before querying for the correlated date, the runtime will determine the cardinality of the view root ids and the correlation basis values.
After that, it will group the values with higher cardinality by the values with lower cardinality to be able to do efficient batching.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what that means</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    Set&lt;KittenCatView&gt; getKittens();

}

@EntityView(Cat.class)
public interface KittenCatView {

    @IdMapping
    Long getId();

    @BatchFetch(20)
    @MappingCorrelated(
        correlationBasis = "age",
        correlator = CatAgeCorrelationProvider.class,
        fetch = FetchStrategy.SELECT
    )
    Set&lt;Cat&gt; getSameAgedCats();

    static class CatAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String correlatedCat = builder.getCorrelationAlias();
            builder.correlate(Cat.class)
                .on(correlatedCat + ".age").inExpressions(correlationExpression)
                .on(correlatedCat + ".id").notInExpressions("VIEW_ROOT(id)")
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>In this example the batching might happen either for view roots or correlation basis values depending on the data.
If the number of distinct view root ids is lower than the number of distinct correlation basis values, the correlation basis values are grouped by view root ids.
The runtime will then execute a batched query for every view root id.</p>
</div>
<div class="paragraph">
<p>The good thing is, the runtime will adapt based on the data to minimize the number of queries, but still, if the cardinality is high, this can result in many queries being executed.</p>
</div>
<div class="sect4">
<h5 id="batching-expectation-fine-tuning"><a class="anchor" href="#batching-expectation-fine-tuning"></a>Batching expectation fine tuning</h5>
<div class="paragraph">
<p>By default the runtime assumes that the <code>VIEW_ROOT</code> function is not used and generates a query that batches correlation basis values.
If this assumption fails because the <code>VIEW_ROOT</code> function is used and the batching is done based on view root ids, a new query has to be built.</p>
</div>
<div class="paragraph">
<p>The way the <code>VIEW_ROOT</code> function is implemented requires to invoke the <code>CorrelationProvider</code> again for building the new query.</p>
</div>
<div class="paragraph">
<p>To avoid this unnecessary rebuilding of the query, you can specify the batch expectation for all attributes by setting the property
<a href="#expect-batch-correlation-values"><code>com.blazebit.persistence.view.batch_correlation_values</code></a> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>
to <code>false</code> if batching is expected to be done on a view root id basis. The value serves as default value and can be overridden on a per attribute basis by suffixing the property name with the attribute name.
In order to set the batch expectation for an attribute named <em>someAttribute</em> you have to set the property <code>com.blazebit.persistence.view.batch_correlation_values.someAttribute</code> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>.
The path to the attribute is based on the entity view which is queried and can also be deep i.e. <code>someSubview.someAttribute</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-subselect-fetch-strategy"><a class="anchor" href="#anchor-subselect-fetch-strategy"></a>4.3. Subselect fetch strategy</h3>
<div class="paragraph">
<p>The <code>SUBSELECT</code> strategy will create one query for every attribute that uses it and is especially efficient for bigger collections.
It creates a separate query based on the outer query and applies the <code>CorrelationProvider</code> to it.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Correlating subviews that contain collections when using <code>firstResult</code>/<code>maxResults</code> or applying an entity view on queries that use <code>ORDER BY</code> select aliases does not yet work. For more information also see <a href="https://github.com/Blazebit/blaze-persistence/issues/370">#370</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example that shows what happens</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        correlationResult = "pers",
        fetch = FetchStrategy.SUBSELECT
    )
    Set&lt;Person&gt; getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String pers = builder.getCorrelationAlias();
            builder.correlate(Person.class)
                .on(pers + ".age").inExpressions(correlationExpression)
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>When using this entity view, there are 2 queries that are generated.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The main query will fetch the <code>correlationBasis</code> and all the other attributes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.age,
    correlated_SameAgedPersons
FROM Cat cat,
     Person correlated_SameAgedPersons
WHERE correlated_SameAgedPersons.age = cat.age</pre>
</div>
</div>
<div class="paragraph">
<p>The correlation query looks very similar since it&#8217;s based on the main query, but has a custom select clause.
It selects the correlation key as well as the attributes for the target representation in the main entity view.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="filter-and-sorter-api"><a class="anchor" href="#filter-and-sorter-api"></a>5. Filter and Sorter API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apart from mapping projections, Blaze Persistence entity views also provides support for filtering and sorting on attribute-level.
Implementing the filtering and sorting based on attributes allows to completely encapsulate the entity model behind an entity view.
The structure of an entity view is driven by the consumer and basing the filtering and sorting aspects on that very same structure is only natural for a consumer.</p>
</div>
<div class="paragraph">
<p>The filter and sorter API is provided via <code>com.blazebit.persistence.view.EntityViewSetting</code> and allows filtering and sorting to be applied to entity views dynamically.
<em>Dynamic</em> in this context means that the filters and sorters can be added/enabled without the need to explicitly modify the entity view type itself
or the criteria builder which the entity view is based on.</p>
</div>
<div id="filter-sorter-introductory-example" class="paragraph">
<p>Let&#8217;s consider the following data access method for an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">&lt;V, C extends CriteriaBuilder&lt;V&gt;&gt; getHungryCats(EntityViewSetting&lt;V, C&gt; settings) { ... }</pre>
</div>
</div>
<div class="paragraph">
<p>It implements the basic business logic of how to obtain all hungry cats via a <code>CriteriaBuilder</code> from the database. The method supports
entity views to allow fetching only the fields which are needed for a concrete use cases. For example when displaying the
cats in a dropdown, their names might be sufficient but when displaying them in a table it might be desirable to include more details.</p>
</div>
<div class="paragraph">
<p>Likewise, one might want to retrieve the cats sorted by name or by age depending on the use case. Having to
introduce 2 new methods for this purpose would be painful:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">&lt;V, C extends CriteriaBuilder&lt;V&gt;&gt; getHungryCatsSortedByName(EntityViewSetting&lt;V, C&gt; settings);

&lt;V, C extends CriteriaBuilder&lt;V&gt;&gt; getHungryCatsSortedByAge(EntityViewSetting&lt;V, C&gt; settings);</pre>
</div>
</div>
<div class="paragraph">
<p>The above approach does not even account for different sort orders so in reality we might rather go for
parameterizing the original method which is painful nevertheless:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">&lt;V, C extends CriteriaBuilder&lt;V&gt;&gt; getHungryCats(EntityViewSetting&lt;V, C&gt; settings, String sortField, String sortOrder);</pre>
</div>
</div>
<div class="paragraph">
<p>Instead it is possible to apply the sorting to the <code>EntityViewSetting</code> instance that is passed to
your data access layer:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">settings.addAttributeSorter("name", com.blazebit.persistence.view.Sorters.ascending());
dataAccess.getHungryCats(settings);</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All attribute names specified using the filter or sorter API refer to the entity view attribute names rather than entity attribute names.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="filter-api"><a class="anchor" href="#filter-api"></a>5.1. Filter API</h3>
<div class="paragraph">
<p>The filter API allows to enable and parameterize a filter for entity view attributes.</p>
</div>
<div class="paragraph">
<p>Entity view filters are defined by annotating respective entity view attributes with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/AttributeFilter.html"><code>@AttributeFilter</code></a>
or <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/AttributeFilters.html"><code>@AttributeFilters</code></a> for multiple named filters.</p>
</div>
<div class="paragraph">
<p>In the annotation you can supply an optional filter name and a filter provider class which needs to extend
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/AttributeFilterProvider.html"><code>AttributeFilterProvider</code></a>. An attribute filter&#8217;s name must be unique for the
attribute it is annotated on. The attribute filter without a filter name is the <em>default filter</em>. Only a single default attribute filter per attribute is allowed.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {
    @IdMapping
    Integer getId();

    @AttributeFilters({
        AttributeFilter(ContainsIgnoreCaseFilter.class),
        AttributeFilter(name = "containsCaseSensitive", value = ContainsFilter.class)
    })
    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Default attribute filters are enabled by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#addAttributeFilter(java.lang.String,%20java.lang.Object)"><code>addAttributeFilter(String attributeName, Object filterValue)</code></a>
whereas named filters require calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#addAttributeFilter(java.lang.String,%20java.lang.String,%20java.lang.Object)"><code>addAttributeFilter(String attributeName, String filterName, Object filterValue)</code></a>.</p>
</div>
<div class="paragraph">
<p>The supplied object values are used by the filter provider to append the appropriate restrictions to the query builder.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, CriteriaBuilder&lt;CatView&gt;&gt; setting = EntityViewSetting.create(CatView.class);
setting.addAttributeFilter("name", "kitty"); <i class="conum" data-value="1"></i><b>(1)</b>
setting.addAttributeFilter("name", "containsCaseSensitive", "kitty"); <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Enables the default filter <code>ContainsIgnoreCaseFilter</code>, so e.g. <em>KITTY</em> matches</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Enables the named filter <code>ContainsFilter</code>, so e.g. <em>KITTY</em> doesn&#8217;t match</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At most one attribute filter can be enabled per attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Blaze Persistence provides a number of built-in filter providers in the <code>com.blazebit.persistence.view.filter</code> package:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Built-in filters</th>
<th class="tableblock halign-left valign-top">Supported filter value types</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GreaterOrEqualFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, Date</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LessOrEqualFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, Date</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GreaterThanFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, Date</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LessThanFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, Date</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EqualFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StartsWithFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EndsWithFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ContainsFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StartsWithIgnoreCaseFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EndsWithIgnoreCaseFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ContainsIgnoreCaseFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NullFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean - <code>true</code> includes NULLs, <code>false</code> excludes NULLs</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>It is also possible to filter by subview attributes. The following example illustrates this:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {
    @IdMapping
    Integer getId();

    ChildCatView getChild();
}

@EntityView(Cat.class)
public interface ChildCatView {
    @IdMapping
    Integer getId();

    @AttributeFilter(LessOrEqualFilter.class)
    Integer getAge();
}

CriteriaBuilderFactory cbf = ...;
EntityViewManager evm = ...;
EntityViewSetting&lt;CatView, CriteriaBuilder&lt;CatView&gt;&gt; setting = EntityViewSetting.create(CatView.class);
// by adding this filter, only cats with a child of age &lt;= 10 will be selected
setting.addAttributeFilter("child.age", "10");</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently there is no support for collection filters like "has at least one" semantics. This is
<a href="https://github.com/Blazebit/blaze-persistence/issues/109">planned</a> for a future version. When applying an attribute filter
on a collection attribute or a subview attribute contained in a collection, the collection&#8217;s elements will currently be filtered.
In the meantime, collection filters can be implemented by creating a custom attribute filter, applying restrictions directly on the entity view&#8217;s base query or by using a view filter.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="view-filters"><a class="anchor" href="#view-filters"></a>5.1.1. View filters</h4>
<div class="paragraph">
<p>View filters allow filtering based on attributes of the view-backing entity as opposed to attribute filters which
relate to entity view attributes.</p>
</div>
<div class="paragraph">
<p>For example, the following entity view uses a view filter to filter by the <code>age</code> entity attribute of the
<code>Cat</code> entity without this attribute being mapped in the entity view.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
@ViewFilter(name = "ageFilter", value = AgeFilterProvider.class)
public interface CatView {
    @IdMapping
    Integer getId();

    String getName();

    class AgeFilterProvider implements ViewFilterProvider {
        @Override
        public &lt;T extends WhereBuilder&lt;T&gt;&gt; T apply(T whereBuilder) {
            return whereBuilder.where("age").gt(2L);
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>View filters need to be activated via the <code>EntityViewSetting</code>:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">setting.addViewFilter("ageFilter");</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="custom-filters"><a class="anchor" href="#custom-filters"></a>5.1.2. Custom filters</h4>
<div class="paragraph">
<p>If the built-in filters do not satisfy your requirements you are free to implement custom attribute filters by
extending <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/AttributeFilterProvider.html"><code>AttributeFilterProvider</code></a> with either one constructor accepting</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Class&lt;?&gt;</code> - The attribute type</p>
</li>
<li>
<p><code>Object</code> - The filter value</p>
</li>
<li>
<p><code>Class&lt;?&gt;</code> and <code>Object</code> - The attribute type and the filter value</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Have a look at how a range filter could be implemented:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class MyCustomFilter extends com.blazebit.persistence.view.AttributeFilterProvider {

    private final Range range;

    public EndsWithFilterImpl(Object value) {
        this.value = (Range) value;
    }

    protected &lt;T&gt; T apply(RestrictionBuilder&lt;T&gt; restrictionBuilder) {
        return restrictionBuilder.between(range.lower).and(range.upper);
    }

    public static class Range {
        private final Number lower;
        private final Number upper;

        public Range(Number lower, Number upper) {
            this.lower = lower;
            this.upper = upper;
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The filter implementation only uses the filter value in the constructor and assumes it to be of the <code>Range</code> type.
By accepting the attribute type, a string to object conversion for the filter value can be implemented.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sorter-api"><a class="anchor" href="#sorter-api"></a>5.2. Sorter API</h3>
<div class="paragraph">
<p>The sorter API allows to sort entity views by their attributes.
A sorter can be applied for an attribute by invoking <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#addAttributeSorter(java.lang.String,%20com.blazebit.persistence.view.Sorter)"><code>addAttributeSorter(String attributeName, Sorter sorter)</code></a></p>
</div>
<div class="paragraph">
<p>For an example of how to use the sorter API refer to the <a href="#filter-sorter-introductory-example">introductory example</a>.</p>
</div>
<div class="paragraph">
<p>Blaze Persistence provides default sorters via the static methods in the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/Sorters.html"><code>Sorters</code></a> class.
These methods allow to easily create any combination of ascending/descending and nulls-first/nulls-last sorter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At most one attribute sorter can be enabled per attribute.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Sorting by subquery attributes (see ??) is problematic for some DBs.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Currently, sorting by correlated attribute mappings (see ??) is also not fully supported.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="custom-sorter"><a class="anchor" href="#custom-sorter"></a>5.2.1. Custom sorter</h4>
<div class="paragraph">
<p>If the built-in sorters do not satisfy your requirements you are free to create a custom sorter by
implementing the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/Sorter.html"><code>Sorter</code></a> interface.</p>
</div>
<div class="paragraph">
<p>An example for a custom sorter might be a case insensitive sorter</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class MySorter implements com.blazebit.persistence.view.Sorter {

    private final Sorter sorter;

    private MySorter(Sorter sorter) {
        this.sorter = sorter;
    }

    public static Sorter asc() {
        return new MySorter(Sorters.ascending());
    }

    public static Sorter desc() {
        return new MySorter(Sorters.descending());
    }

    public &lt;T extends OrderByBuilder&lt;T&gt;&gt; T apply(T sortable, String expression) {
        return sorter.apply(sortable, "UPPER(" + expression + ")");
    }
}</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="querying-and-pagination-api"><a class="anchor" href="#querying-and-pagination-api"></a>6. Querying and Pagination API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main entry point to entity views is via the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#create(java.lang.Class)"><code>EntityViewSetting.create()</code></a> API.
There are multiple different variants of the static <code>create()</code> method that allow to construct a <code>EntityViewSetting</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>create(Class&lt;?&gt; entityViewClass)</code></dt>
<dd>
<p>Creates a simple entity view setting without pagination.</p>
</dd>
<dt class="hdlist1"><code>create(Class&lt;T&gt; entityViewClass, int firstResult, int maxResults)</code></dt>
<dd>
<p>Creates a entity view setting that will apply pagination to a <code>CriteriaBuilder</code> via <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#pagination"><code>page(int firstResult, int maxResults)</code></a></p>
<div class="ulist">
<ul>
<li>
<p><code>create(Class&lt;T&gt; entityViewClass, Object entityId, int maxRows)</code>
Creates a entity view setting that will apply pagination to a <code>CriteriaBuilder</code> via <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-navigate-entity-page"><code>page(Object entityId, int maxResults)</code></a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Every of the variants also has an overload that additionally accepts a <code>viewConstructorName</code> to be able to construct entity views via <a href="#anchor-named-constructor">named constructors</a>.</p>
</div>
<div class="paragraph">
<p>A <code>EntityViewSetting</code> essentially is configuration that can be applied to a <code>CriteriaBuilder</code> and contains the following aspects</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Projection and DTO construction based on the entity view class</p>
</li>
<li>
<p>Entity view attribute based filtering</p>
</li>
<li>
<p>Entity view attribute based sorting</p>
</li>
<li>
<p>Query pagination</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Allowing the actual data consumer i.e. the UI to specify these aspects is essential for efficient and easy to maintain data retrieval.</p>
</div>
<div class="paragraph">
<p>For a simple lookup by id there is also a convenience <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#find(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.Object)"><code>EntityViewManager.find()</code></a> method available
that allows you to skip some of the <code>CriteriaBuilder</code> ceremony and that works analogous to how <code>EntityManager.find()</code> works, but with entity views.</p>
</div>
<div class="sect2">
<h3 id="querying-entity-views"><a class="anchor" href="#querying-entity-views"></a>6.1. Querying entity views</h3>
<div class="paragraph">
<p>Code in the presentation layer is intended to create an <code>EntityViewSetting</code> via the <code>create()</code> API and pass the entity view setting to a data access method.
The data access method then applies the setting onto a <code>CriteriaBuilder</code> instance which it created to build a query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We know that the current state of the <code>EntityViewSetting</code> API requires some verbose generics and we are going to fix that in 2.0. For further information also see <a href="https://github.com/Blazebit/blaze-persistence/issues/371">#371</a>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="normal-criteriabuilder-use"><a class="anchor" href="#normal-criteriabuilder-use"></a>6.1.1. Normal CriteriaBuilder use</h4>
<div class="paragraph">
<p>Depending on the need for pagination, an <code>EntityViewSetting</code> object is normally created like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, CriteriaBuilder&lt;CatView&gt;&gt; setting;
// Use this if no pagination is required
setting = EntityViewSetting.create(CatView.class);
// Apply filters and sorters on setting
List&lt;CatView&gt; list = catDataAccess.findAll(setting);</pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the <code>catDataAccess</code> is quite simple. It creates a query with the <code>CriteriaBuilder</code> API as usual,
and finally applies the setting on the builder through the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#applySetting(com.blazebit.persistence.view.EntityViewSetting,%20com.blazebit.persistence.CriteriaBuilder)"><code>EntityViewManager.applySetting()</code></a> method.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Inject these somehow
CriteriaBuilderFactory criteriaBuilderFactory;
EntityViewManager entityViewManager;

public &lt;V, Q extends CriteriaBuilder&lt;V&gt;&gt; List&lt;V&gt; findAll(EntityViewSetting&lt;V, Q&gt; setting) {
    CriteriaBuilder&lt;Cat&gt; criteriaBuilder = criteriaBuilderFactory.create(Cat.class);

    // Apply business logic filters
    criteriaBuilder.where("deleted").eq(false);

    return entityViewManager.applySetting(setting, criteriaBuilder)
                .getResultList();
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="paginating-entity-view-results"><a class="anchor" href="#paginating-entity-view-results"></a>6.1.2. Paginating entity view results</h4>
<div class="paragraph">
<p>When data pagination is required, the <code>firstResult</code> and <code>maxResults</code> parameters are required to be specified when creating the <code>EntityViewSetting</code> object</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, PaginatedCriteriaBuilder&lt;CatView&gt;&gt; setting;
// Paginate and show only the 10 first records by doing this
setting = EntityViewSetting.create(CatView.class, 0, 10);
// Apply filters and sorters on setting
PagedList&lt;CatView&gt; list = catDataAccess.findAll(setting);</pre>
</div>
</div>
<div class="paragraph">
<p>To actually be able to get the <code>PagedList</code> instead of a normal list, the following data access implementation is required</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Inject these somehow
CriteriaBuilderFactory criteriaBuilderFactory;
EntityViewManager entityViewManager;

public &lt;V, Q extends PaginatedCriteriaBuilder&lt;V&gt;&gt; PagedList&lt;V&gt; findAll(EntityViewSetting&lt;V, Q&gt; setting) {
    CriteriaBuilder&lt;Cat&gt; criteriaBuilder = criteriaBuilderFactory.create(Cat.class);

    // Apply business logic filters
    criteriaBuilder.where("deleted").eq(false);

    return entityViewManager.applySetting(setting, criteriaBuilder)
                .getResultList();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The only difference to the former implementation is that this method uses the <code>PaginatedCriteriaBuilder</code> as upper bound for the type variable and a different return type.
By using a different type variable bound, the <code>EntityViewManager.applySetting()</code> will return an instance of <code>PaginatedCriteriaBuilder</code>. It&#8217;s <code>getResultList()</code> returns a <code>PagedList</code> instead of a <em>normal</em> list.</p>
</div>
</div>
<div class="sect3">
<h4 id="keyset-pagination-with-entity-views"><a class="anchor" href="#keyset-pagination-with-entity-views"></a>6.1.3. Keyset pagination with entity views</h4>
<div class="paragraph">
<p>The <code>EntityViewSetting</code> API also comes with an integration with the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-keyset-pagination">keyset pagination</a> feature.</p>
</div>
<div class="paragraph">
<p>A <code>EntityViewSetting</code> that serves for normal offset based pagination, can be additionally enriched with a <code>KeysetPage</code>
by invoking <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#withKeysetPage(com.blazebit.persistence.KeysetPage)"><code>withKeysetPage(KeysetPage keysetPage)</code></a>.
Supplying a keyset page allows the runtime to choose keyset pagination instead of offset pagination based on the requested page and the supplied keyset page.</p>
</div>
<div class="paragraph">
<p>To be able to use keyset pagination, it is required to <em>remember</em> the last known keyset page.
When using a server side UI technology, this can be done very easily by simply saving the keyset page in the HTTP session.
With e.g. CDI the <code>KeysetPage</code> could simply be declared as <em>field</em> of a session-like scoped bean.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, PaginatedCriteriaBuilder&lt;CatView&gt;&gt; setting;

int maxResults = ...; // elements per page
int firstResult = ...; // (pageNumber - 1) * elementsPerPage

setting = EntityViewSetting.create(CatView.class, firstResult, maxResults);
// Apply filters and sorters on setting

setting.withKeysetPage(previousKeysetPage);

PagedList&lt;CatView&gt; list = catDataAccess.findAll(setting);
previousKeysetPage = list.getKeysetPage();</pre>
</div>
</div>
<div class="paragraph">
<p>When using a more stateless approach like it is often the case with RESTful backends, the keyset page has to be <em>serialized</em> to the client and <em>deserialized</em> back when reading from the client.
Depending on your requirements, you can serialize the <code>KeysetPage</code> directly into e.g. a JSON object and should be able to deserialize it with the most common serialization libraries.
Another possible way to integrate this, is to generate URLs that contain the keyset in some custom format which should then be used by the client to navigate to the next or previous page.</p>
</div>
<div class="paragraph">
<p>Any of these approaches will require custom implementations of the <code>KeysetPage</code> and <code>Keyset</code> interfaces.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We are working on a more easy integration with REST technologies. For further information see <a href="https://github.com/Blazebit/blaze-persistence/issues/373">#373</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="entity-page-navigation-with-entity-views"><a class="anchor" href="#entity-page-navigation-with-entity-views"></a>6.1.4. Entity page navigation with entity views</h4>
<div class="paragraph">
<p>Sometimes it is necessary to navigate to a specific entry with a specific id. When required to also display the entry in a paginated table marked as <em>selected</em>,
it is necessary to determine the page at which an entry with an id is located. This feature is implemented by the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#anchor-navigate-entity-page">navigate to entity page</a> feature
and can be used by creating an <code>EntityViewSetting</code> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#create(java.lang.Class,%20java.lang.Object,%20int)"><code>create(Class&lt;T&gt; entityViewClass, Object entityId, int maxResults)</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, PaginatedCriteriaBuilder&lt;CatView&gt;&gt; setting;

setting = EntityViewSetting.create(CatView.class, catId, maxResults);
// Apply filters and sorters on setting

// Use this to activate keyset pagination
setting.withKeysetPage(null);

PagedList&lt;CatView&gt; list = catDataAccess.findAll(setting);
previousKeysetPage = list.getKeysetPage();</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-optional-parameters"><a class="anchor" href="#anchor-optional-parameters"></a>6.2. Optional parameters and configuration</h3>
<div class="paragraph">
<p>Apart from the already presented aspects, a <code>EntityViewSetting</code> also contains so called <em>optional parameters</em> and configuration properties.</p>
</div>
<div class="paragraph">
<p>Optional parameters are set on a query if no value is set and also injected into entity views if requested by a <a href="#anchor-parameter-mappings">parameter mapping</a>
and are a very good integration point for <em>dependency injection</em> into entity views.
They can be set with the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#addOptionalParameter(java.lang.String,%20java.lang.Object)"><code>addOptionalParameter(String parameterName, Object value)</code></a> method.</p>
</div>
<div class="paragraph">
<p><a href="#anchor-configuration-properties">Configuration properties</a> denoted as being <em>always applicable</em> can be set via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>setProperty(String propertyName, Object value)</code></a>
and allow to override or fine tune configuration time behavior for a single query.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-entity-view-apply-root"><a class="anchor" href="#anchor-entity-view-apply-root"></a>6.3. Applying entity views on specific relations</h3>
<div class="paragraph">
<p>Up until now, an entity view setting has always been applied on the query root of a <code>CriteriaBuilder</code> which might not always be doable because of the way relations are mapped or how the query is done.
Fortunately, Blaze Persistence entity views also allow to apply a setting on a relation of the query root via
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#applySetting(com.blazebit.persistence.view.EntityViewSetting,%20com.blazebit.persistence.CriteriaBuilder,%20java.lang.String)"><code>EntityViewManager.applySetting(EntityViewSetting setting, CriteriaBuilder criteriaBuilder, String entityViewRoot)</code></a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Mapping this entity view on e.g. the father relation like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderFactory criteriaBuilderFactory = ...;
EntityViewManager entityViewManager = ...;

CriteriaBuilder&lt;Cat&gt; criteriaBuilder = criteriaBuilderFactory.create(Cat.class);
criteriaBuilder.where("father").isNotNull();

List&lt;CatView&gt; list = entityViewManager.applySetting(
    EntityViewSetting.create(CatView.class),
    criteriaBuilder,
    "father"
);</pre>
</div>
</div>
<div class="paragraph">
<p>This will map all <em>fathers</em> of cats to the <code>CatView</code> and roughly produce a query like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT father_1.id, father_1.name
FROM Cat cat
LEFT JOIN cat.father father_1
WHERE father_1 IS NOT NULL</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="updatable-entity-views"><a class="anchor" href="#updatable-entity-views"></a>7. Updatable Entity Views</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Updatable entity views represent DTOs for the write concern of an application. Updatable entity views are like a normal entity views,
except that changes to attributes are tracked and can be inspected through the <a href="#updatable-entity-view-change-model-api">Change Model API</a> or flushed to the backing data store.</p>
</div>
<div class="paragraph">
<p>Updatable entity views are also a lot like normal entities and can be thought of being similar to what is sometimes referred to as <em>sub-entities</em>.
The main idea is to model use-case specific representations with a limited scope of attributes that can change.
Usually, when using an entity type, many more attributes are exposed as being <em>changable</em> to the consumer of the type, although they might not even need to be <em>updatable</em>.
Updatable entity views allows for perfect reuse of attribute declarations thanks to it&#8217;s use of interfaces but also brings a lot more to the table than using plain entities.</p>
</div>
<div class="paragraph">
<p>Apart from a concept for updating existing objects, Blaze Persistence also has a notion for <em>creating</em> new objects.
With only JPA, a developer is often left with some open question like e.g. how to implement <em>equals-hashCode</em> for entities.
Thanks to the first class notion of creatable entity views, this question and others can be easily answered as discussed below.</p>
</div>
<div class="sect2">
<h3 id="update-mapping"><a class="anchor" href="#update-mapping"></a>7.1. Update mapping</h3>
<div class="paragraph">
<p>To declare an entity view as being updatable, it is required to additionally annotate it with <code>@UpdatableEntityView</code>.
By default an updatable entity view will do full updates i.e. always update all (owned) updatable attributes if at least one (owned) attribute is dirty.
Owned attributes are ones that belong the the backing entity type like e.g. basic typed attributes. Inverse attributes aren&#8217;t owned and are thus independent.
This behavior can be configured by setting the <code>mode</code> attribute on the <code>@UpdatableEntityView</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PARTIAL</code> - The mode will only flush values of actually changed attributes</p>
</li>
<li>
<p><code>LAZY</code> - The default, will flush all updatable values if at least one attribute is dirty</p>
</li>
<li>
<p><code>FULL</code> - Always flushes all updatable attributes, regardless of dirtyness</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The flushing, by default, is done by executing JPQL DML statements, but can be configured to use entities instead by setting the <code>strategy</code> attribute on the <code>@UpdatableEntityView</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QUERY</code> - The default, will flush changes by executing JPQL DML statements. Falling back to entity flushing if necessary</p>
</li>
<li>
<p><code>ENTITY</code> - Will flush changes by loading the dirty entity graph and applying changes onto it</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="create-mapping"><a class="anchor" href="#create-mapping"></a>7.2. Create mapping</h3>
<div class="paragraph">
<p>To declare an entity view as being creatable, it is required to additionally annotate it with <code>@CreatableEntityView</code>.
Note that updatable entity views for embeddable types are implicitly also creatable, yet the <code>@CreatableEntityView</code> annotation can still be applied for further configuration.
By default, a creatable entity view is validated against the backing model regarding it&#8217;s <em>persistability</em> i.e. it is checked if an instance could be successfully persisted regarding the non-null constraints of the entity model.
This allows to catch errors early that occur when adding new attributes to the entity model but forgetting to do so in the entity view.
The validation can be disabled by setting the <code>validatePersistability</code> attribute on the <code>@CreatableEntityView</code> to <code>false</code>
but can also be controlled in a fine grained manner by excluding specific entity attributes from the validation via the <code>excludedEntityAttributes</code> attribute.
The latter is useful for attributes that are known to be set on the entity model through entity listeners or entity view listeners.</p>
</div>
<div class="paragraph">
<p>Creatable views are converted to their context specific declaration type after persisting.
This mean that if a creatable entity view is used as value for an attribute of an updatable entity view, the instance is replaced by an equivalent instance
of the type that is declared for the attribute. Consider the following example model for illustration.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    OwnerView getOwner();
    void setOwner(OwnerView owner);
}
@EntityView(Person.class)
interface OwnerView {
    @IdMapping
    Long getId();

    String getName();
}
@CreatableEntityView
@EntityView(Person.class)
interface OwnerCreateView extends OwnerView {
    void setName(String name);
}</pre>
</div>
</div>
<div class="paragraph">
<p>When flushing an instance of the type <code>CatUpdateView</code> that contains an owner of the creatable entity view type <code>OwnerCreateView</code> the following happens</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <code>Person</code> entity is created with the defined properties</p>
</li>
<li>
<p>The <code>Person</code> entity is persisted via <code>EntityManager.persist()</code></p>
</li>
<li>
<p>The generated identifier is set on the <code>OwnerCreateView</code> object</p>
</li>
<li>
<p>The <code>OwnerCreateView</code> object is converted to the context specific declared type <code>OwnerView</code></p>
</li>
<li>
<p>The <code>OwnerCreateView</code> object is replaced by the <code>OwnerView</code> object</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The same replacing happens for creatable entity views that are contained in a collection, thus developers don&#8217;t need to think about possible problems related to primary key based equals-hashCode implementations.
Since the object is properly replaced, the assignment of a generated primary key, which would change the object regarding equals-hashCode, is not problematic.
Still, the object can safely make use of the primary key based equals-hashCode implementation that is generated for all entity views by default.</p>
</div>
</div>
<div class="sect2">
<h3 id="api-usage"><a class="anchor" href="#api-usage"></a>7.3. API usage</h3>
<div class="paragraph">
<p>An updatable as well as an creatable entity view is flushed by invoking <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#update(javax.persistence.EntityManager,%20java.lang.Object)"><code>EntityViewManager.update(EntityManager em, Object view)</code></a>
and will flush changes according to the flush strategy and mode. Changes to collections are flushed depending on the collection mapping.</p>
</div>
<div class="paragraph">
<p>If the entity for which a collection is mapped <em>owns</em> the collection i.e. no use of <em>mappedBy</em>, the changes will be applied to an entity reference.
For collections that are <em>not owned</em> by the containing entity i.e. use a <em>mappedBy</em>, changes will be applied by creating/updating/deleting the target entities.</p>
</div>
<div class="paragraph">
<p>Creatable entity views are constructed via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#create(java.lang.Class)"><code>EntityViewManager.create(Class type)</code></a> and
always result in a persist when being flushed directly or through an updatable attribute having the <code>CascadeType.PERSIST</code> enabled.</p>
</div>
<div class="paragraph">
<p>Deletion of entities through view types works either by supplying an existing view object to <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#remove(javax.persistence.EntityManager,%20java.lang.Object)"><code>EntityViewManager.remove(EntityManager em, Object view)</code></a>
or by entity id via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#remove(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.Object)"><code>EntityViewManager.remove(EntityManager em, Class viewType, Object id)</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="lifecycle-and-listeners"><a class="anchor" href="#lifecycle-and-listeners"></a>7.4. Lifecycle and listeners</h3>
<div class="paragraph">
<p>An entity view similar to a JPA entity also has something like a lifecycle, though within entity views, the states correspond to different entity view java types, rather than a transaction state.
There are essentially 3 different kinds of entity views:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>new</strong></dt>
<dd>
<p>An instance of a creatable entity view type(<code>@CreatableEntityView</code>) that is created via <code>EntityViewManager.create(Class)</code>.
After flushing of such an instance, the instance transitions to the <em>updatable</em> state if the entity view java type is also updatable(<code>@UpdatableEntityView</code>)
otherwise to the <em>read-only</em> state. If it is used within an updatable view, it is then converted to the context specific type which replaces the creatable entity view instance.</p>
</dd>
<dt class="hdlist1"><strong>read-only</strong></dt>
<dd>
<p>A normal entity view <strong>without</strong> updatable or creatable configuration(<code>@UpdatableEntityView</code>, <code>@CreatableEntityView</code>).</p>
</dd>
<dt class="hdlist1"><strong>updatable</strong></dt>
<dd>
<p>An entity view with updatable configuration(<code>@UpdatableEntityView</code>).</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is still in development, so not all features might be available yet. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/433" class="bare">https://github.com/Blazebit/blaze-persistence/issues/433</a> for more information.
</td>
</tr>
</table>
</div>
<div class="imageblock">
  <div class="content">
        <a href="javascript:;" onclick="document.location.hash='images/entity-view-write-model-lifecycle-diagram.png';">
          <img src="images/entity-view-write-model-lifecycle-diagram.png" alt="entity view write model lifecycle diagram" width="1050" height="448">
        </a>
        <div class="lightbox" id="images/entity-view-write-model-lifecycle-diagram.png">
          <a href="javascript:;" onclick="document.location.hash='_';" class="btn-close">X</a>
          <img src="images/entity-view-write-model-lifecycle-diagram.png" alt="entity view write model lifecycle diagram" width="1050" height="448">
        </div>
  </div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>load</strong></dt>
<dd>
<p>An entity view is loaded by applying an <code>EntityViewSetting</code> to a <code>CriteriaBuilder</code> which also happens implicitly when using <code>EntityViewManager.find()</code>.
Another way to <em>load</em> is to get a <em>reference</em> for an entity view via <code>EntityViewManager.getReference()</code>.</p>
</dd>
<dt class="hdlist1"><strong>remove</strong></dt>
<dd>
<p>Removing is done explicitly by calling <code>EntityViewManager.remove()</code> or implicitly when <a href="#updatable-entity-view-delete-cascading-orphan-removal">delete cascading or orphan removal</a> is activated.</p>
</dd>
<dt class="hdlist1"><strong>create</strong></dt>
<dd>
<p>Creating of entity view instances is done by calling <code>EntityViewManager.create()</code>.</p>
</dd>
<dt class="hdlist1"><strong>flush/update</strong></dt>
<dd>
<p>Flushing/Updating happens when invoking <code>EntityViewManager.update()</code> or <code>EntityViewManager.updateFull()</code> as well as implicitly for <code>CascadeType.UPDATE</code> enabled attributes.</p>
</dd>
<dt class="hdlist1"><strong>convert</strong></dt>
<dd>
<p>Conversion happens when calling <code>EntityViewManager.convert()</code> which implicitly happens for creatable entity views within a context after persisting.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For most of the operations it is possible to register a listener which is invoked before or after an operation.
The listeners can react to specific events but in some cases also alter the state of the corresponding object.</p>
</div>
<div class="paragraph">
<p>A listener can be defined within an entity view class but within a class hierarchy there may only be one listener. If multiple listeners from e.g. super interfaces are inherited,
the entity view type must declare a listener to disambiguate the situation. The listener then can invoke other listener methods or skip them.</p>
</div>
<div class="paragraph">
<p>Most listeners can be defined for a specific update or remove operation to react to change events in a particular manner for a specific use case,
but it is also possible to register listeners globally. The globally registered listeners can be used to implement cross cutting concerns like soft-deletion, auditing, etc.
Global listeners are registered via one of the <code>EntityViewConfiguration.registerListener</code> methods.</p>
</div>
<div class="sect3">
<h4 id="post-create-listener"><a class="anchor" href="#post-create-listener"></a>7.4.1. Post create listener</h4>
<div class="paragraph">
<p>Within an entity view type a concrete method annotated with <code>@PostCreate</code> is considered to be a post create listener.
It may optionally define a parameter of the type <code>EntityViewManager</code> and must have a return type of void.</p>
</div>
<div class="paragraph">
<p>Such a listener is usually used for creatable entity view types to setup default values.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">enum LifeState {
    ALIVE,
    DEAD;
}

@CreatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    String getName();
    void setName(String name);

    LifeState getState();
    void setState(LifeState state);

    @PostCreate
    default void init() {
        setState(LifeState.ALIVE);
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pre-remove-listener"><a class="anchor" href="#pre-remove-listener"></a>7.4.2. Pre remove listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-remove-listener"><a class="anchor" href="#post-remove-listener"></a>7.4.3. Post remove listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pre-persist-listener"><a class="anchor" href="#pre-persist-listener"></a>7.4.4. Pre persist listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-persist-listener"><a class="anchor" href="#post-persist-listener"></a>7.4.5. Post persist listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pre-update-listener"><a class="anchor" href="#pre-update-listener"></a>7.4.6. Pre update listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-update-listener"><a class="anchor" href="#post-update-listener"></a>7.4.7. Post update listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attribute-mappings"><a class="anchor" href="#attribute-mappings"></a>7.5. Attribute mappings</h3>
<div class="paragraph">
<p>When an entity view has <code>@UpdatableEntityView</code> annotated, every attribute for which a setter method exists, is considered to be <em>updatable</em>.
For an attribute to be <em>updatable</em> means that changes done to the attribute of an entity view, can be flushed to the attribute they map to of an entity.
There is also a notion of <em>mutable</em> attributes which means that an attribute is <em>updatable</em> and/or the type of the attribute&#8217;s value might be <em>mutable</em>.</p>
</div>
<div class="paragraph">
<p>An unknown type is mutable by default and needs to be configured by registering a <a href="#entity-view-basic-user-type-spi">basic user type</a>.
Entity view types are only considered being mutable if they are updatable(<code>@UpdatableEntityView</code>) or creatable(<code>@CreatableEntityView</code>).
Entity types are always considered to be mutable.</p>
</div>
<div class="paragraph">
<p>Singular attributes with an updatable flat view type are also considered updatable even without a setter method.</p>
</div>
<div class="paragraph">
<p>The mappings for updatable attributes must follow some rules</p>
</div>
<div class="ulist">
<ul>
<li>
<p>May not use complex expressions like arithmetic or functions</p>
</li>
<li>
<p>May not access elements or attributes of elements through a collection e.g. <code>kittens.name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The general understanding is that mappings should be bi-directional i.e. it should be possible to map a value back to a specific entity attribute.</p>
</div>
<div class="paragraph">
<p>To prevent an attribute being considered updatable, it can be annotated with <code>@UpdatableMapping(updatable = false)</code>.
Sometimes, it&#8217;s also useful to annotate plural attributes i.e. collection attributes with <code>@UpdatableMapping(updatable = true)</code> when a setter is inappropriate.</p>
</div>
<div class="paragraph">
<p>Note that updatable and creatable entity view types require an <a href="#anchor-id-mappings">id mapping</a> to work properly, which is validated during the building of the metamodel.
The getters and setters of abstract entity view classes may use the protected or default visibility setting which allows to encapsulate the access to these attributes properly.</p>
</div>
<div class="sect3">
<h4 id="updatable-mappings-basic"><a class="anchor" href="#updatable-mappings-basic"></a>7.5.1. Basic type mappings</h4>
<div class="paragraph">
<p>Singular attributes with a basic type i.e. all types except entity view types, entity types or collection types,
do not have a nested domain structure since they are <em>basic</em>. Values of such types usually change by setting a different value,
though there are some mutable types as well. Basic types in general are handled by registered <a href="#entity-view-basic-user-type-spi">basic user types</a>
and define the necessary means to safely handle values of such types.</p>
</div>
<div class="paragraph">
<p>Values set for a basic type entity view attribute are only flushed to the entity attribute it refers to, if the entity view attribute is <em>updatable</em>.
This means that even if the type is mutable, a basic type attribute is never considered to be updatable as long as there is no setter or an explicit <code>@UpdatableMapping(updatable = true)</code> present.
If a type is immutable, an attribute with such a type obviously needs a setter to be considered updatable as there would otherwise be no way to change a value.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    String getName();
    void setName(String name);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Changes made via calls to e.g. <code>setName()</code> can be flushed later in a different persistence context.
The following shows a simple example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Load the updatable entity view
CatUpdateView view = entityViewManager.find(entityManager, CatUpdateView.class, catId);

// Update the name of the view
view.setName("newName");

// Flush the changes to the persistence context
eventityViewManager.update(entityManager, view);</pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the configured flush strategy, this will either load the <code>Cat</code> entity and apply changes to it
or create an update query that set&#8217;s the updatable attributes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = :name
WHERE cat.id = :id</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-subview"><a class="anchor" href="#updatable-mappings-subview"></a>7.5.2. Subview mappings</h4>
<div class="paragraph">
<p>Just like *ToOne relationships can be mapped in entities, it is possible to map these relationships as subviews.
It is not required for such subview type to be updatable, in fact, it is encouraged to use a subview type that best fits the modeled use case.</p>
</div>
<div class="paragraph">
<p>In general, Blaze Persistence distinguishes between two concepts regarding <em>updatability</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Updatability of the relationship role i.e. the attribute <code>owner</code> or more specifically the <code>owner_id</code> column</p>
</li>
<li>
<p>Updatability of the relation type represented by the entity view <code>PersonView</code> or more specifically the row in the <code>person</code> table</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example illustrates a case where the relation type <code>PersonView</code> is not updatable,
but the relationship represented by the attribute <code>owner</code> is updatable.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
interface PersonView {
    @IdMapping
    Long getId();

    String getName();
}

@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    String getName();

    PersonView getOwner();
    void setOwner(PersonView owner);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Even if the <code>PersonView</code> had a <code>setName()</code> method, changes done to that attribute would not be flushed, since <code>PersonView</code> is not updatable(<code>@UpdatableEntityView</code>).</p>
</div>
<div class="paragraph">
<p>Having only an updatable relationship role is very common, because it is rarely necessary to do cascading updates.
Note that it is also possible to just make the entity view type <code>PersonView</code> updatable(annotate <code>@UpdatableEntityView</code>) without the setter <code>setOwner()</code>.
That way, the relationship role wouldn&#8217;t be allowed to change, but the changes to the underlying <code>Person</code> would be cascaded.</p>
</div>
<div class="paragraph">
<p>When the subview type is updatable(<code>@UpdatableEntityView</code>), updates are by default cascaded. If the subview type is also creatable(<code>@CreatableEntityView</code>), persists are also cascaded.
To disable or fine tune this behavior, it is possible to annotate the attribute getter with <code>@UpdatableMapping</code> and specify the <code>cascade</code> attribute.
Apart from defining which <code>CascadeType</code> is enabled, it is also possible to restrict the allowed subtypes via the attributes <code>subtypes</code>, <code>persistSubtypes</code> and <code>updateSubtypes</code>.
By default, instances of the declared type i.e. the compile time attribute type, are allowed to be set as attribute values.
Subtypes that are non-updatable and non-creatable are also allowed.
If the attribute defines <code>UPDATE</code> cascading or the declared type is updatable(<code>@UpdatableEntityView</code>), all updatable subtypes are also allowed.
If the attribute defines <code>PERSIST</code> cascading or the declared type is creatable(<code>@CreatableEntityView</code>), all creatable subtypes are also allowed.</p>
</div>
<div class="paragraph">
<p>In case of immutable or non-updatable subview types the method <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#getReference(java.lang.Class,%20java.lang.Object)"><code>EntityViewManager.getReference(Class viewType, Object id)</code></a> might come in handy.
This method allows to retrieve an instance of the given view type having the defined identifier. This is very useful for cases when just a relationship role like e.g. <em>owner</em> should be set without the need to query <code>PersonView</code> objects.
A common use case might be to set the tenant which owns an object. There is no need to query the tenant as the information is unnecessary for simply setting the relationship role, but the tenant&#8217;s identity is known.</p>
</div>
<div class="paragraph">
<p>To be able to encapsulate the creation of subviews or the access to references for subviews it is recommended to make use of the <a href="#entity-view-special-method-entity-view-manager-getter">special EntityViewManager getter method</a>.
The idea is to define an abstract getter method with protected or default visibility returning an <code>EntityViewManager</code>. Methods that create subviews or want a reference to a subview by id can then invoke the getter to get access to the <code>EntityViewManager</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-flat-view"><a class="anchor" href="#updatable-mappings-flat-view"></a>7.5.3. Flat view mappings</h4>
<div class="paragraph">
<p>Updatable flat view mappings are currently only supported for embeddable types. An updatable flat view type is also always creatable.
Flat views are always flushed as whole objects, which means that an updatable flat view should always at least map all attributes as read-only.
Read-only i.e. non-updatable attributes are <em>passed-through</em> to the embeddable object when recreating it.</p>
</div>
<div class="paragraph">
<p>Apart from that, a flat view is just like a normal subview.</p>
</div>
</div>
<div class="sect3">
<h4 id="subquery-parameter-mappings"><a class="anchor" href="#subquery-parameter-mappings"></a>7.5.4. Subquery &amp; parameter mappings</h4>
<div class="paragraph">
<p>Since subqueries and parameter mappings aren&#8217;t bidirectional, attributes using these kinds of mappings are never considered to be updatable.</p>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-entity"><a class="anchor" href="#updatable-mappings-entity"></a>7.5.5. Entity mappings</h4>
<div class="paragraph">
<p>Entity types are similar to subview types as they have an identity and are specially handled when loading and merging data.
Since entity types are mutable by design, <code>PERSIST</code> and <code>UPDATE</code> cascading are by default enabled for attributes that use entity types.
The cascading can be overridden by defining the cascade type via a <code>@UpdatableMapping</code> annotation on the attribute.
Note that the handling of entity types can be fine tuned by registering a <a href="#entity-view-basic-user-type-spi">basic user type</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    @UpdatableMapping(cascade = { CascadeType.UPDATE }) <i class="conum" data-value="1"></i><b>(1)</b>
    Cat getFather();
    void setFather(Cat father);
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines that only updates are cascaded. Unknown i.e. <em>new</em> Cat instances aren&#8217;t persisted</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Changes that are done via <code>setFather()</code> will update the <code>father</code> attribute in the entity model when flushed.
If query flushing is configured, a query like the following will be generated when updating the <code>father</code> relation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.father = :father
WHERE cat.id = :id</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-collection"><a class="anchor" href="#updatable-mappings-collection"></a>7.5.6. Collection mappings</h4>
<div class="paragraph">
<p>Updatable collection mappings must be simple paths referring to a collection of the backing entity type. Paths to a nested collection like e.g. <code>owner.kittens</code> are not allowed.
Currently, a collection attribute is considered to be <em>updatable</em> if a setter for the attribute exists, or <code>@UpdatableMapping</code> is declared on the getter method of an attribute.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
At this point, collections can not be remapped automatically yet, so you have to use the same collection type as in the entity model.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Updates to owned collection are currently simply <em>replayed</em> on the collection of an entity reference.
Note that currently only inverse collections are considered <em>not owned</em> i.e. don&#8217;t require loading the real collection for doing updates.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    Set&lt;Cat&gt; getKittens();
    void setKittens(Set&lt;Cat&gt; kittens);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Any modification done to a collection</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatUpdateView view = ...;

// Update the view
Cat newKitten = entityManager.find(Cat.class, 2L);
view.getKittens().add(newKitten);

// Flush the changes to the persistence context
entityViewManager.update(entityManager, view);</pre>
</div>
</div>
<div class="paragraph">
<p>Will be applied on the collection of an entity reference during <code>update()</code> as if the following was done.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatUpdateView view = ...;
// Actually a query that loads the graph being dirty is issued
Cat cat = entityManager.find(Cat.class, view.getId());

cat.getKittens().add(newKitten);</pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>kittens</code> collection is dirty i.e. a new kitten was added and the collection is <em>owned</em> by the <code>Cat</code> entity, it will be loaded along with the <code>Cat</code>.
If <code>kittens</code> were an inverse collection, it wouldn&#8217;t need loading during flushing as adding the new kitten would be a matter of issuing an update query or persisting an entity.</p>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-collection"><a class="anchor" href="#updatable-mappings-collection"></a>7.5.7. Inverse mappings</h4>
<div class="paragraph">
<p>Changes to inverse relations like OneToOne&#8217;s and *ToMany collections are flushed by persisting, updating or removing the inverse relation objects.
There is no special mapping required. If the entity model defines that an attribute is an inverse mapping by specifying a <em>mappedBy</em>,
updatable entity view attributes mapping to such attributes automatically discover the <em>mappedBy</em> configuration and
will cause the attribute being maintained by managing inverse relation objects.</p>
</div>
<div class="paragraph">
<p>There are several strategies that can be configured to handle the removal of elements via the <code>removeStrategy</code> attribute of <code>@MappingInverse</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> - The default. Ignores elements that have been removed i.e. does not maintain the relationship automatically.</p>
</li>
<li>
<p><code>REMOVE</code> - Removes the inverse relation object when determined to be removed from the inverse relationship.</p>
</li>
<li>
<p><code>SET_NULL</code> - Sets the <em>mappedBy</em> attribute to <code>NULL</code> on the inverse relation object when found to be removed from the inverse relationship.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Person.class)
interface PersonUpdateView {
    @IdMapping
    Long getId();

    // mappedBy = "owner"
    @MappingInverse(removeStrategy = InverseRemoveStrategy.REMOVE)
    Set&lt;Cat&gt; getKittens();
    void setKittens(Set&lt;Cat&gt; kittens);
}</pre>
</div>
</div>
<div class="paragraph">
<p>A modification of the kittens collection&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">PersonUpdateView view = ...;

// Update the view
view.getKittens().remove(someKitten);

// Flush the changes to the persistence context
entityViewManager.update(entityManager, view);</pre>
</div>
</div>
<div class="paragraph">
<p>will cause the Cat <code>someKitten</code> to be removed.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE Cat c WHERE c.id = :someKittenId</pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>SET_NULL</code> strategy were used, the <code>owner</code> would be set to <code>NULL</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat c SET owner = NULL WHERE c.id = :someKittenId</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-correlated"><a class="anchor" href="#updatable-mappings-correlated"></a>7.5.8. Correlated mappings</h4>
<div class="paragraph">
<p>Attributes with correlated mappings are currently not considered to be updatable as there is no way to map back to the entity model.
A future version might allow to treat such mappings as custom inverse mappings.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking-support"><a class="anchor" href="#locking-support"></a>7.6. Locking support</h3>
<div class="paragraph">
<p>Blaze Persistence entity views by default automatically makes use of a version field mapped in the entity type for optimistic locking.
This is controlled by the <code>lockMode</code> attribute on the <code>@UpdatableEntityView</code> annotation which by default is set to <code>AUTO</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LockMode.AUTO</code> - The default. Uses the version field of the entity type the entity view is referring to for optimistic locking</p>
</li>
<li>
<p><code>LockMode.OPTIMISTIC</code> - Forces the use of optimistic locking based on the entity version field</p>
</li>
<li>
<p><code>LockMode.PESSIMISTIC_READ</code> - Acquires a JPA <code>PESSIMISTIC_READ</code> lock when reading the entity view</p>
</li>
<li>
<p><code>LockMode.PESSIMISTIC_WRITE</code> - Acquires a JPA <code>PESSIMISTIC_WRITE</code> lock when reading the entity view</p>
</li>
<li>
<p><code>LockMode.NONE</code> - Don&#8217;t use any locking even if a version attribute is available</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, all updatable attributes in an entity view are protected by optimistic locking.
This means that if the value of an attribute was changed, the change will be flushed with the optimistic lock condition.
Attribute changes that should be excluded from optimistic locking can be annotated with <code>@OptimisticLock(exclude = true)</code> to prevent the optimistic lock condition
when only such attributes are changed.</p>
</div>
<div class="paragraph">
<p>The entity type for which the optimistic lock condition is asserted is called the <em>lock owner</em>.
If the entity type of an entity view does not have a version field and the <code>LockMode.AUTO</code> is used, the parent entity view type is considered being the lock owner.
If the parent has no version field, it&#8217;s parent is considered and so forth. If no lock owner can be found, no optimistic locking is done.</p>
</div>
<div class="paragraph">
<p>When specifying a lock mode other than <code>LockMode.AUTO</code>, the entity object for an entity view becomes the lock owner.
By annotating <code>@LockOwner</code> on an updatable entity view type, a custom lock owner can be defined.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is still in development, so not all features might be available yet. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/439" class="bare">https://github.com/Blazebit/blaze-persistence/issues/439</a> and <a href="https://github.com/Blazebit/blaze-persistence/issues/438" class="bare">https://github.com/Blazebit/blaze-persistence/issues/438</a> for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-persist-and-update-cascading"><a class="anchor" href="#updatable-entity-view-persist-and-update-cascading"></a>7.7. Persist and Update cascading</h3>
<div class="paragraph">
<p>The cascade types defined in Blaze Persistence entity views have different semantics than what JPA offers and should not be mixed up.
JPA defines cascade types for <em>logical operations</em> whereas Blaze Persistence entity views defines cascade types for state changes.
In a JPA entity, one can define for which operations the changes done to an attribute should be flushed.
For example the JPA <code>CascadeType.PERSIST</code> will cause a flush of an attributes affected values only if the owning entity is about to be persisted.</p>
</div>
<div class="paragraph">
<p>Blaze Persistence entity views cascade types define whether a value of an attribute may do a specific state transition.
If an attribute defines <code>CascadeType.PERSIST</code>, it means that <em>new</em> objects i.e. the ones created via <code>EntityViewManager.create()</code>,
are allowed to be used as values and that these object should be persisted during flushing.
Updates done to mutable values of an attribute are only flushed if the <code>CascadeType.UPDATE</code> is enabled.</p>
</div>
<div class="paragraph">
<p>Normally, the update or persist cascading is enabled for all subtypes of the declared attribute type,
but can be restricted by specifying specific subtypes for which to allow updates or persists.
This can be done via the <code>subtypes</code> attribute of the <code>@UpdatableMapping</code> or the <code>updateSubtypes</code> or <code>persistSubtypes</code> attributes for the corresponding cascade types.</p>
</div>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-delete-cascading-orphan-removal"><a class="anchor" href="#updatable-entity-view-delete-cascading-orphan-removal"></a>7.8. Cascading deletes and orphan removal</h3>
<div class="paragraph">
<p>Delete cascading and orphan removal have the same semantics as in JPA.
If you delete an entity A that refers to entity B through an attribute that defines delete cascading,
entity B is going to be deleted as well.
When removing a reference from entity A to entity B through an attribute that defines orphan removal, entity B is going to be deleted.
Orphan removal also implies delete cascading, so entity B is also deleted when deleting entity A.</p>
</div>
<div class="paragraph">
<p>Most JPA implementations only support cascading deletes and orphan removal for managed entities whereas DML statements for the entity types do not consider this configuration.
Blaze Persistence respects the settings all the way, even for the removal by id action done via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#remove(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.Object)">EntityViewManager.remove(EntityManager, Class, Object)</a>.
When an entity graph for an entity view type has an <em>arbitrary depth relationship</em>, Blaze Persistence still has to do some entity data loading, but it tries to reduce the executed statements as much as possible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At some point, DML statements might be grouped together via Updatable CTEs for DBMS that support that. For more information about that, see <a href="https://github.com/Blazebit/blaze-persistence/issues/500" class="bare">https://github.com/Blazebit/blaze-persistence/issues/500</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable delete cascading for an attribute, the <code>CascadeType.DELETE</code> has to be added to the <code>cascade</code> attribute of a <code>@UpdatableMapping</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    @UpdatableMapping(cascade = { CascadeType.DELETE })
    Person getOwner();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When deleting a <code>Cat</code> like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">entityViewManager.remove(entityManager, CatUpdateView.class, catId);</pre>
</div>
</div>
<div class="paragraph">
<p>the owner is going to be deleted along with the <code>Cat</code>. The delete cascading even works for attributes that are only defined to do delete cascading in the entity.
Assuming <code>Cat</code> does not have the <em>arbitrary depth relationship</em> <code>kittens</code>, the removal might trigger the following <em>logical</em> JPQL statements.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE Cat(nickNames) cat WHERE cat.id = :catId
DELETE Cat cat WHERE cat.id = :catId RETURNING owner.id
DELETE Person person WHERE person.id = :ownerId</pre>
</div>
</div>
<div class="paragraph">
<p>First, the cascading delete enabled collections like e.g. the <code>nickNames</code> collection is deleted.
Then the <code>Cat</code> is deleted and while doing that, the ids of the *ToOne relations with enabled cascading deletes like e.g. the <em>owner&#8217;s id</em> are returned.
For DBMS not supporting the <code>RETURNING</code> clause for DML statements, a <code>SELECT</code> statement is issued before the <code>DELETE</code> to extract the ids of the *ToOne relations.
Finally, the cascading deletes for the *ToOne relations are done e.g. the <code>Person</code> is deleted.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A future strategy for deletion might facilitate temporary tables if the DBMS supports it rather than selecting. For more information see <a href="https://github.com/Blazebit/blaze-persistence/issues/220" class="bare">https://github.com/Blazebit/blaze-persistence/issues/220</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the entity type for an updatable entity view uses delete cascading or orphan removal for an attribute, an updatable mapping for that attribute must use these configurations as well.
So if the entity type uses delete cascading for the <code>owner</code> of <code>Cat</code>, it would be an error to omit the delete cascading configuration.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    @UpdatableMapping(cascade = { }) <i class="conum" data-value="1"></i><b>(1)</b>
    Person getOwner();
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Can&#8217;t omit delete cascading if entity attribute uses delete cascading</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same goes for orphan removal and the idea behind this is, that it makes delete cascading and orphan removal configurations visible in every updatable view, thus making it less surprising.
It would make no sense to allow disabling delete cascading or orphan removal configurations because then the entity flush strategy would produce different results than the query flush strategy.
Obviously the other way around i.e. enabling delete cascading or orphan removal if the entity attribute does not use these configurations, is very valid.
Sometimes there are cases where delete cascading or orphan removal shouldn&#8217;t be done which means the cascading can&#8217;t be configured on the entity type attributes.
This where Blaze Persistence entity views show their strength as they allow to control these configurations on a per-use case basis.</p>
</div>
</div>
<div class="sect2">
<h3 id="conversion-support"><a class="anchor" href="#conversion-support"></a>7.9. Conversion support</h3>
<div class="paragraph">
<p>As explained in the beginning, the vision for updatable entity views is to support the modelling of use case specific write models.
Although most of the data that is generally updatable is mostly loaded once when starting a <em>conversation</em> it is rarely necessary to make it updatable right away.
Some use cases might require only a subset of the data to be updatable, while others require a different subset.
To support modelling this appropriately it is possible to convert between entity views types.</p>
</div>
<div class="paragraph">
<p>Imagine the following model for illustration purposes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface KittenView {
    @IdMapping
    Long getId();
}

@EntityView(Cat.class)
interface CatBaseView extends KittenView {
    PersonView getOwner();

    Set&lt;KittenView&gt; getKittens();
}

@UpdatableEntityView
@EntityView(Cat.class)
interface CatOwnerUpdateView extends CatBaseView {
    @UpdatableMapping
    PersonView getOwner();
    void setOwner(PersonView owner);
}

@UpdatableEntityView
@EntityView(Cat.class)
interface CatKittenUpdateView extends CatBaseView {
    @UpdatableMapping
    Set&lt;KittenView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When navigating to the detail UI for a <code>Cat</code> the <code>CatBaseView</code> would be loaded.
If the UI had a special action to initiate a transfer to a different owner, doing that action would lead to the conversion of the <code>CatBaseView</code> to the <code>CatOwnerUpdateView</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatBaseView catBaseView = //...
CatOwnerUpdateView catOwnerUpdate = entityViewManager.convert(CatOwnerUpdateView.class, catBaseView);</pre>
</div>
</div>
<div class="paragraph">
<p>After setting the new owner and flushing the changes via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#update(javax.persistence.EntityManager,%20java.lang.Object)">EntityViewManager.update(EntityManager, Object)</a>
the view is converted back to the base view by invoking <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#convert(java.lang.Class,%20java.lang.Object,%20com.blazebit.persistence.view.ConvertOption&#8230;&#8203;)">EntityViewManager.convert(Class, Object, ConvertOption&#8230;&#8203;)</a> again.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatOwnerUpdateView catOwnerUpdate = //...
catBaseView = entityViewManager.convert(CatBaseView.class, catBaseView);</pre>
</div>
</div>
<div class="paragraph">
<p>When initiating the kitten update action the conversion would be done to <code>CatKittenUpdateView</code>.</p>
</div>
<div class="paragraph">
<p>Keep in mind that most UIs do not necessarily work this way and that the added complexity might not be beneficial in all cases.
Although this mechanism enables a clear separation for use cases, it might just as well be the case, that use cases are so small that it is better to have just a single write model.
In some special cases like e.g. when simply changing a status of an object, it might not even be necessary to have an explicit write model.
For such cases it is often more appropriate to have a specialized service method.</p>
</div>
<div class="paragraph">
<p>Note that internally, the conversion feature is used for converting successfully persisted creatable entity views to their context specific declaration type.</p>
</div>
<div class="paragraph">
<p>There are of course other possible use cases for this feature like e.g. conversion from a <em>more detailed</em> view to a view containing only a subset of the information,
though it is recommended to query the view with the subset of information rather than querying more if possible/practical to not do unnecessary data loading.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="entity-view-basic-user-type-spi"><a class="anchor" href="#entity-view-basic-user-type-spi"></a>8. BasicUserType SPI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just like JPA providers offer an SPI to make use of custom types for basic values, Blaze Persistence also does.
For read models, the type isn&#8217;t very important as the JPA provider handles the construction of the values and only provides entity views with object instance.
Since write models need to handle change detection and mutability aspects of basic types i.e. non-subview type, the <code>BasicUserType</code> interface SPI is needed.</p>
</div>
<div class="sect2">
<h3 id="supported-types"><a class="anchor" href="#supported-types"></a>8.1. Supported types</h3>
<div class="paragraph">
<p>There are several well known types registered out of the box.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean</code>, <code>java.lang.Boolean</code></p>
</li>
<li>
<p><code>char</code>, <code>java.lang.Character</code></p>
</li>
<li>
<p><code>byte</code>, <code>java.lang.Byte</code></p>
</li>
<li>
<p><code>short</code>, <code>java.lang.Short</code></p>
</li>
<li>
<p><code>int</code>, <code>java.lang.Integer</code></p>
</li>
<li>
<p><code>long</code>, <code>java.lang.Long</code></p>
</li>
<li>
<p><code>float</code>, <code>java.lang.Float</code></p>
</li>
<li>
<p><code>double</code>, <code>java.lang.Double</code></p>
</li>
<li>
<p><code>java.lang.String</code></p>
</li>
<li>
<p><code>java.math.BigInteger</code>, <code>java.math.BigDecimal</code></p>
</li>
<li>
<p><code>java.util.Date</code>, <code>java.sql.Time</code>, <code>java.sql.Date</code>, <code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>java.util.Calendar</code>, <code>java.util.GregorianCalendar</code></p>
</li>
<li>
<p><code>java.util.TimeZone</code>, <code>java.lang.Class</code></p>
</li>
<li>
<p><code>java.util.UUID</code>, <code>java.net.URL</code></p>
</li>
<li>
<p><code>java.util.Locale</code>,  <code>java.util.Currency</code></p>
</li>
<li>
<p><code>byte[]</code>, <code>java.lang.Byte[]</code></p>
</li>
<li>
<p><code>char[]</code>, <code>java.lang.Character[]</code></p>
</li>
<li>
<p><code>java.io.InputStream</code>, <code>java.sql.Blob</code></p>
</li>
<li>
<p><code>java.sql.Clob</code>, <code>java.sql.NClob</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If found on the classpath, types for the following classes are registered</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.time.LocalDate</code>, <code>java.time.LocalDateTime</code>, <code>java.time.LocalTime</code></p>
</li>
<li>
<p><code>java.time.OffsetTime</code>, <code>java.time.OffsetDateTime</code>, <code>java.time.ZonedDateTime</code></p>
</li>
<li>
<p><code>java.time.Duration</code>, <code>java.time.Instant</code></p>
</li>
<li>
<p><code>java.time.MonthDay</code>, <code>java.time.Year</code>, <code>java.time.YearMonth</code>, <code>java.time.Period</code></p>
</li>
<li>
<p><code>java.time.ZoneId</code>, <code>java.time.ZoneOffset</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you miss a type you can register it via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/spi/EntityViewConfiguration.html#registerBasicUserType(java.lang.Class,com.blazebit.persistence.view.spi.type.BasicUserType)"><code>EntityViewConfiguration.registerBasicUserType(Class type, BasicUserType userType)</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="type-support-for-write-models"><a class="anchor" href="#type-support-for-write-models"></a>8.2. Type support for write models</h3>
<div class="paragraph">
<p>When a basic type is used in a write model, it is very important that an appropriate <code>BasicUserType</code> is registered.
If no basic user type is registered for a type, by default the <code>com.blazebit.persistence.view.spi.type.MutableBasicUserType</code> is used.
This basic user type assume the type is mutable which will cause values of that type to always be assumed being dirty.
Updatable entity views containing values of such a type are thus always considered being dirty which has the effect, that every call to
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#update(java.lang.Object)"><code>EntityViewManager.update(Object view)</code></a>
will cause a flush of attributes containing that value.
The <a href="#Change Model API">updatable-entity-view-change-model-api</a> is also affected of this by always reporting such attributes as being dirty.</p>
</div>
<div class="paragraph">
<p>Immutable types, like e.g. <code>java.lang.String</code> already does, can use the basic user type implementation <code>com.blazebit.persistence.view.spi.type.ImmutableBasicUserType</code>
which assumes objects of the type are immutable.</p>
</div>
<div class="paragraph">
<p>A proper basic user type implementation for mutable types, when based on the provided type <code>com.blazebit.persistence.view.spi.type.AbstractMutableBasicUserType</code>
only needs an implementation for cloning a value. The cloned value is used to e.g. keep the initial state so that later changes can be detected by checking equality.</p>
</div>
</div>
<div class="sect2">
<h3 id="type-support-for-jpa-managed-types"><a class="anchor" href="#type-support-for-jpa-managed-types"></a>8.3. Type support for JPA managed types</h3>
<div class="paragraph">
<p>JPA managed types are also considered mutable by default, and since no dirty tracking information is available by default, objects of that such types are always considered dirty thus also always flushed.
An integration with the native dirty tracking mechanism of the JPA provider might improve performance and will be considered in future versions.
Entity types that handle change tracking manually, can implement a custom basic user type to improve the performance for usages of that entity type within updatable entity views,
but are generally recommended to switch to subviews instead.</p>
</div>
<div class="paragraph">
<p>For further information on the possible SPI methods consult the JavaDoc of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/spi/type/BasicUserType.html"><code>BasicUserType</code> interface</a></p>
</div>
</div>
<div class="sect2">
<h3 id="optimistic-locking-version-type-support"><a class="anchor" href="#optimistic-locking-version-type-support"></a>8.4. Optimistic locking version type support</h3>
<div class="paragraph">
<p>To allow an attribute to be used as version for optimistic locking, the registered basic type also needs to implement the <code>com.blazebit.persistence.view.spi.type.VersionBasicUserType</code> interface.
This type additionally requires to provide an implementation for returning the <em>next version</em> based on a given current version.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="entity-view-type-converter-api"><a class="anchor" href="#entity-view-type-converter-api"></a>9. TypeConverter API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The TypeConverter API is similar to the JPA AttributeConverter API as it allows to convert between an entity view model type and an underlying type.
This is similar to the <a href="#entity-view-basic-user-type-spi">BasicUserType SPI</a> but can also be used to convert view types to custom types.
All this might sound very generic, but it is the foundation for the support of wrapping a type in a <code>java.util.Optional</code>.</p>
</div>
<div class="paragraph">
<p>A <code>TypeConverter</code> is responsible for figuring out the actual underlying type of an entity view attribute type.
In case of an attribute like e.g. <code>Optional&lt;Integer&gt; getId()</code> the <code>TypeConverter</code> for the <code>java.util.Optional</code> support determines the underlying type which is <code>Integer</code>.
Apart from this, the <code>TypeConverter</code> must also implement the conversion from the view type to the underlying type and the other way around.</p>
</div>
<div class="sect2">
<h3 id="builtin-typeconverters"><a class="anchor" href="#builtin-typeconverters"></a>9.1. Builtin TypeConverters</h3>
<div class="paragraph">
<p>There are several <code>TypeConverters</code> registered out of the box.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Converters for <code>java.sql.Blob</code>, <code>java.sql.Clob</code>, <code>java.sql.NClob</code> to implement dirty tracking in coordination with a custom <code>BasicUserType</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If found on the classpath, <code>TypeConverters</code> for the following types are registered</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Optional</code> for all Object types</p>
</li>
<li>
<p><code>java.util.OptionalInt</code> for <code>java.lang.Integer</code></p>
</li>
<li>
<p><code>java.util.OptionalLong</code> for <code>java.lang.Long</code></p>
</li>
<li>
<p><code>java.util.OptionalDouble</code> for <code>java.lang.Double</code></p>
</li>
<li>
<p><code>java.time.LocalDate</code> for entity types</p>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
<li>
<p><code>java.util.GregorianCalendar</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.time.LocalDateTime</code> for entity types</p>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
<li>
<p><code>java.util.GregorianCalendar</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.time.LocalTime</code> for <code>java.sql.Time</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you miss a <code>TypeConverter</code> you can register it via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/spi/EntityViewConfiguration.html#registerTypeConverter(java.lang.Class,%20java.lang.Class,%20com.blazebit.persistence.view.spi.type.TypeConverter)"><code>EntityViewConfiguration.registerTypeConverter(Class entityModelType, Class viewModelType, TypeConverter typeConverter)</code></a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="updatable-entity-view-change-model-api"><a class="anchor" href="#updatable-entity-view-change-model-api"></a>10. Updatable Entity View Change Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Updatable entity views are not only better write model DTOs, but also allow to retrieving logical changes via the ChangeModel API.
Using updatable entity views allows the persistence model to be efficiently updated, but the <em>cost</em> for doing that is hiding the persistent/initial state from the user.
Oftentimes part of the persistent/initial state is compared with values that are about to be written to <em>detect</em> logical changes.
Since updatable entity views handle the persistent state behind the scenes, such a manual comparison isn&#8217;t possible. Thanks to the ChangeModel API it is unnecessary.</p>
</div>
<div class="paragraph">
<p>The ChangeModel API entry point is
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#getChangeModel(java.lang.Object)"><code>EntityViewManager.getChangeModel(Object view)</code></a>
and returns the change model for a given updatable entity view.
A change model instance provides access to the initial and current state of an object and the <code>ChangeKind</code> of a change model.
Singular change models also give access to the change models of the respective attributes of an entity view type.
Plural change models additionally give access to the added, removed and mutated element change models.
A map change model also allows to distinguish between element and key change models.</p>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-change-model-api-overview"><a class="anchor" href="#updatable-entity-view-change-model-api-overview"></a>10.1. Change Model API overview</h3>
<div class="paragraph">
<p>To detect if a model or one of it&#8217;s child models is dirty, one can use the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/ChangeModel.html#isDirty()"><code>ChangeModel.isDirty()</code></a> method.
The actual change models of dirty elements within a <code>SingularChangeModel</code> can be retrieved via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/SingularChangeModel.html#getDirtyChanges()"><code>SingularChangeModel.getDirtyChanges()</code></a>.
Only attributes of the queried object are reported as change models i.e. only a single level.</p>
</div>
<div class="paragraph">
<p>The singular change models allow access to the attributes change models either via attribute path or via the metamodel attribute objects by using one of the overloaded
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/SingularChangeModel.html#get(java.lang.String)"><code>SingularChangeModel.get(String attributePath)</code></a> methods.
The term <em>path</em> implicates a nested attribute access is possible, which is the case, but beware that accessing attributes of collection elements will result in an exception
unless the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/SingularChangeModel.html#getAll(java.lang.String)"><code>SingularChangeModel.getAll(String attributePath)</code></a> variant is used
which returns a list of change models instead of a single one.</p>
</div>
<div class="paragraph">
<p>Another notable feature the singular change model provides is the checking for dirtyness of a specific attribute path. Instead of materializing every change model
along the path, the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/SingularChangeModel.html#isDirty(java.lang.String)"><code>SingularChangeModel.isDirty(String attributePath)</code></a> method
only reports the dirtyness of the object accessible through the given attribute path.
A variant of this method <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/SingularChangeModel.html#isChanged(java.lang.String)"><code>SingularChangeModel.isChanged(String attributePath)</code></a>
will return early if one of the parent attributes was updated i.e. the identity was changed.</p>
</div>
<div class="paragraph">
<p>The plural change model is similar in the respect that it provides analogous methods that simply return a list of change models instead of a single one.
It also allows to access the change models of the added, removed or mutated elements separately.
To access all dirty changes similar to what is possible with <code>SingularChangeModel#getDirtyChanges()</code>, plural change models provide the method
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/change/PluralChangeModel.html#getElementChanges()"><code>PluralChangeModel.getElementChanges()</code></a> for doing the same.</p>
</div>
<div class="paragraph">
<p>The map change model additionally allows to differentiate between changes to key objects and element objects. It offers methods to access the key changes
as well as the overall object changes with analogously named methods <code>getAddedObjects()</code>, <code>getAddedKeys()</code> etc.</p>
</div>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-change-model-tx-support"><a class="anchor" href="#updatable-entity-view-change-model-tx-support"></a>10.2. Transaction support</h3>
<div class="paragraph">
<p>The change model implementation gains it&#8217;s insights by inspecting the dirty tracking information of the actual objects.
Since a transaction commit will flush dirty changes i.e. the dirtyness is resetted, change model objects won&#8217;t report any dirty changes after a commit.
If information about the change models should be retained after a transaction commit, it must be serialized with a custom mechanism.
When a rollback occurs, the dirtyness is restored to be able to commit again after doing further changes which also means that change models will work as expected.</p>
</div>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-change-model-type-support"><a class="anchor" href="#updatable-entity-view-change-model-type-support"></a>10.3. User type support</h3>
<div class="paragraph">
<p>The Change Model API builds on top of the <code>BasicUserType</code> foundation and it is thus essential to have a correct implementation for the type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unknown types are considered mutable which has the effect, that objects of that type are always considered dirty. Provide a <code>deepClone</code> implementation or mark the type as immutable to avoid this.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-data-integration"><a class="anchor" href="#spring-data-integration"></a>11. Spring Data integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apart from a plain Spring integration which is handy for configuring and providing an <code>EntityViewManager</code> for injection,
there is also a Spring Data integration module which tries to make using entity views with Spring Data as convenient as using entities.</p>
</div>
<div class="sect2">
<h3 id="spring-data-setup"><a class="anchor" href="#spring-data-setup"></a>11.1. Setup</h3>
<div class="paragraph">
<p>To setup the project for Spring Data you have to add dependencies as described in the <a href="#getting-started-setup">Setup</a> section
and make beans available for <code>CriteriaBuilderFactory</code> and <code>EntityViewManager</code> instances as laid out in the <a href="#anchor-environment-spring">Spring environment</a> section.</p>
</div>
<div class="paragraph">
<p>In short, the following Maven dependencies are required</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-spring-data-2.x&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-hibernate-5.2&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If you still work with Spring Data 1.x you will have to use a different integration as Spring Data 2.x changed quite a bit.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-spring-data-1.x&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The dependencies for other JPA providers or other versions can be found in the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#maven-setup">core module setup section</a>.</p>
</div>
<div class="paragraph">
<p>A possible bean configuration for the required beans <code>CriteriaBuilderFactory</code> and <code>EntityViewManager</code> in short might look like this.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Configuration
public class BlazePersistenceConfiguration {

    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy(false)
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        // do some configuration
        return config.createCriteriaBuilderFactory(entityManagerFactory);
    }
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Configuration
public class BlazePersistenceConfiguration {

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy(false)
    // inject the criteria builder factory which will be used along with the entity view manager
    public EntityViewManager createEntityViewManager(CriteriaBuilderFactory cbf, EntityViewConfiguration entityViewConfiguration) {
        return entityViewConfiguration.createEntityViewManager(cbf);
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>When enabling JPA repositories, make sure you configure <code>BlazePersistenceRepositoryFactoryBean</code> as <em>repositoryFactoryBeanClass</em>.
Optionally specify a custom basePackage for repository class scanning and a custom entityManagerFactoryRef.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EnableJpaRepositories(repositoryFactoryBeanClass = BlazePersistenceRepositoryFactoryBean.class)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-data-features"><a class="anchor" href="#spring-data-features"></a>11.2. Features</h3>
<div class="paragraph">
<p>The integration comes with a convenience base interface <code>com.blazebit.persistence.spring.data.repository.EntityViewRepository</code>
that you can use for your repository definitions.</p>
</div>
<div class="paragraph">
<p>Assume we have the following entity view:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface SimpleCatView {

    @IdMapping
    public getId();

    String getName();

    @Mapping("LOWER(name)")
    String getLowerCaseName();

    Integer getAge();
}</pre>
</div>
</div>
<div class="paragraph">
<p>A very simple repository might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Transactional(readOnly = true)
public interface SimpleCatViewRepository extends EntityViewRepository&lt;SimpleCatView, Long&gt; {

    List&lt;SimpleCatView&gt; findByLowerCaseName(String lowerCaseName);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Since we use EntityViewRepository as a base interface we inherit the most commonly used repository methods.
You can now use this repository as any other Spring Data repository:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Controller
public class MyCatController {

    @Autowired
    private SimpleCatViewRepository simpleCatViewRepository;

    public Iterable&lt;SimpleCatView&gt; getCatDataForDisplay() {
        return simpleCatViewRepository.findAll();
    }

    public SimpleCatView findCatByName(String name) {
        return simpleCatViewRepository.findByLowerCaseName(name.toLowerCase());
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications">Spring Data Specifications</a> can be used without restrictions. There is also the convenience base interface <code>com.blazebit.persistence.spring.data.repository.EntityViewSpecificationExecutor</code> that can be extended from.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Transactional(readOnly = true)
public interface SimpleCatViewRepository extends EntityViewRepository&lt;SimpleCatView, Long&gt;, EntityViewSpecificationExecutor&lt;SimpleCatView, Cat&gt; {
}

@Controller
public class MyCatController {

    @Autowired
    private SimpleCatViewRepository simpleCatViewRepository;

    public Iterable&lt;SimpleCatView&gt; getCatDataForDisplay(final int minAge) {
        return simpleCatViewRepository.findAll(new Specification&lt;Cat&gt;() {
            @Override
            public Predicate toPredicate(Root&lt;Cat&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
                return criteriaBuilder.ge(root.&lt;Integer&gt;get("age"), minAge);
            }
        });
    }</pre>
</div>
</div>
<div class="paragraph">
<p>The integration handles ad-hoc uses of <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.entity-graph"><code>@EntityGraph</code></a> by adapting the query generation through call of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilder.html#fetch(java.lang.String&#8230;&#8203;)"><code>CriteriaBuilder.fetch()</code></a> rather than passing the entity graphs as hints.</p>
</div>
<div class="paragraph">
<p>Another notable feature the integration provides is the support for the return type <code>KeysetAwarePage</code> as a replacement for <code>Page</code>.
By using <code>KeysetAwarePage</code> the keyset pagination feature is enabled for the repository method.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Transactional(readOnly = true)
public interface KeysetAwareCatViewRepository extends Repository&lt;Cat, Long&gt; {

    KeysetAwarePage&lt;SimpleCatView&gt; findAll(Pageable pageable);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>Pageable</code> should be an instance of <code>KeysetPageable</code> if keyset pagination should be used. A <code>KeysetPageable</code> can be retrieved through the <code>KeysetAwarePage</code> or manually
by constructing a <code>KeysetPageRequest</code>. Note that constructing a <code>KeysetPageRequest</code> or actually the contained <code>KeysetPage</code> manually is not recommended. When working with Spring MVC,
the Spring Data Rest integration might come in handy. For stateful server side frameworks, it&#8217;s best to put the <code>KeysetAwarePage</code> into a session like storage
to be able to use the <code>previousOrFirst()</code> and <code>next()</code> methods for retrieving <code>KeysetPageable</code> objects.</p>
</div>
<div class="paragraph">
<p>All other Spring Data repository features like restrictions, pagination, slices and ordering are supported as usual.
Please consult the Spring Data documentation for further information.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-data-rest-integration"><a class="anchor" href="#spring-data-rest-integration"></a>11.3. Spring Data Rest integration</h3>
<div class="paragraph">
<p>The Spring Data Rest integration offers similar pagination features for keyset pagination to what Spring Data already offers for normal pagination.
First, a keyset pagination enabled repository is needed.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Transactional(readOnly = true)
public interface KeysetAwareCatViewRepository extends Repository&lt;Cat, Long&gt; {

    KeysetAwarePage&lt;SimpleCatView&gt; findAll(Pageable pageable);
}</pre>
</div>
</div>
<div class="paragraph">
<p>A controller can then use this repository like the following:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Controller
public class MyCatController {

    @Autowired
    private KeysetAwareCatViewRepository simpleCatViewRepository;

    @RequestMapping(path = "/cats", method = RequestMethod.GET)
    public Page&lt;SimpleCatView&gt; getCats(@KeysetConfig(Cat.class) KeysetPageable pageable) {
        return simpleCatViewRepository.findAll(pageable);
    }</pre>
</div>
</div>
<div class="paragraph">
<p>Note that Blaze Persistence imposes some very important requirements that have to be fulfilled</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There must always be a sort specification</p>
</li>
<li>
<p>The last sort specification must be the entity identifier</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the keyset pagination to kick in, the client has to <em>remember</em> the values by which the sorting is done of the first and the last element of the result.
The values then need to be passed to the next request as JSON encoded query parameters. The values of the first element should use the parameter <code>lowest</code> and the last element the parameter <code>highest</code>.</p>
</div>
<div class="paragraph">
<p>The following will illustrate how this works.</p>
</div>
<div class="paragraph">
<p>First, the client makes an initial request.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint">GET /cats?page=0&amp;size=3&amp;sort=id,desc
{
    content: [
        { id: 10, name: 'Felix', age: 10 },
        { id: 9, name: 'Robin', age: 4 },
        { id: 8, name: 'Billy', age: 7 }
    ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s the responsibility of the client to remember the attributes by which it sorts of the first and last element.
In this case, <code>{id: 10}</code> will be remembered as <code>lowest</code> and <code>{id: 8}</code> as <code>highest</code>. The client also has to remember the page and size which was used to request this data.
When the client then wants to switch to the next page, it has to pass <code>lowest</code> and <code>highest</code> as parameters as well as <code>prevPage</code> representing the page that was used before.</p>
</div>
<div class="paragraph">
<p>Note that the following is just an example for illustration. Stringified JSON objects in JavaScript should be encoded view <code>encodeURI()</code> before being used as query parameter.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint">GET /cats?page=1&amp;size=3&amp;sort=id,desc&amp;prevPage=0&amp;lowest={id:10}&amp;highest={id:8}
{
    content: [
        { id: 7, name: 'Kitty', age: 1 },
        { id: 6, name: 'Bob', age: 8 },
        { id: 5, name: 'Frank', age: 14 }
    ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will make use of keyset pagination as can be seen by looking at the generated JPQL or SQL query.</p>
</div>
<div class="paragraph">
<p>Note that the client should <em>drop</em> or <em>forget</em> the <code>lowest</code>, <code>highest</code> and <code>prevPage</code> values when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the page size changes</p>
</li>
<li>
<p>the sorting changes</p>
</li>
<li>
<p>the filtering changes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a full AngularJS example see the following <a href="https://github.com/Blazebit/blaze-persistence/blob/master/examples/spring-data-rest/src/main/resources/static/app.js">example project</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deltaspike-data-integration"><a class="anchor" href="#deltaspike-data-integration"></a>12. DeltaSpike Data integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Blaze Persistence provides an integration with <a href="https://deltaspike.apache.org/documentation/data.html">DeltaSpike Data</a> to create entity view based repositories.</p>
</div>
<div class="sect2">
<h3 id="deltaspike-data-setup"><a class="anchor" href="#deltaspike-data-setup"></a>12.1. Setup</h3>
<div class="paragraph">
<p>To setup the project for DeltaSpike Data you have to add the entity view and CDI integration dependencies as described
in the <a href="#getting-started-setup">getting started</a> section along with the integration dependencies for your JPA provider
as described in the <a href="https://persistence.blazebit.com/documentation/core/manual/en_US/index.html#maven-setup">core module setup section</a>.</p>
</div>
<div class="paragraph">
<p>In addition, the following Maven dependencies are required:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-deltaspike-data-api&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-deltaspike-data-impl-1.8&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If you still work with DeltaSpike Data 1.7 you will have to use a different integration as DeltaSpike Data 1.8 changed quite a bit.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-deltaspike-data-impl-1.7&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You also need to make beans available for <code>CriteriaBuilderFactory</code> and <code>EntityViewManager</code> as laid out in the
<a href="#anchor-environments-cdi">CDI environment</a> section.</p>
</div>
</div>
<div class="sect2">
<h3 id="deltaspike-data-features"><a class="anchor" href="#deltaspike-data-features"></a>12.2. Features</h3>
<div class="paragraph">
<p>To mark a class or an interface as repository, use the DeltaSpike <code>org.apache.deltaspike.data.api.Repository</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Repository(forEntity = Person.class)
public interface PersonViewRepository {
    PersonView findAnyByName(String name);
}</pre>
</div>
</div>
<div class="paragraph">
<p>The integration provides the following base interfaces that you may optionally extend to define entity view repositories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.blazebit.persistence.deltaspike.data.api.EntityViewRepository</code> provides simple base methods.</p>
</li>
<li>
<p><code>com.blazebit.persistence.deltaspike.data.api.FullEntityViewRepository</code> adds JPA criteria support to the <code>com.blazebit.persistence.deltaspike.data.api.EntityViewRepository</code> interface.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Repository
public abstract class PersonViewRepository extends FullEntityViewRepository&lt;Person, PersonView, String&gt; {
    public abstract PersonView findAnyByName(String name);

    public List&lt;PersonView&gt; getPersonsByComplexCondition() {
        return criteria().or(
                criteria().gt(Person_.position, 3),
                criteria().likeIgnoreCase(Person_.name, "john%")
        ).select(PersonView.class).orderAsc(Person_.id).getResultList();
    }
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="metamodel"><a class="anchor" href="#metamodel"></a>13. Metamodel</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The metamodel for entity views is very similar to the JPA metamodel and the entry point is <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/metamodel/ViewMetamodel.html"><code>ViewMetamodel</code></a>
which can be acquired through <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-entity-view-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/view/EntityViewManager.html#getMetamodel()"><code>EntityViewManager.getMetamodel()</code></a></p>
</div>
<div class="paragraph">
<p>It allows access to views(<code>ViewType</code>) and flat views(<code>FlatViewType</code>) which both are subtypes of managed views(<code>ManagedViewType</code>).
The only difference between the two is that a flat view has no id mapping, so it&#8217;s identity is composed of all attributes
which results in some limitations as described in the <a href="#flat-view-mappings">flat view mapping</a> section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x6c38c529&gt;&gt;
interface ManagedViewType {
    +getJavaType()
    +getEntityClass()
    +getAttributes()
    +getAttribute(String name)
    +getDefaultBatchSize()
    +getConstructors()
    +getConstructor(Class&lt;?&gt;... paramTypes)
    +getConstructorNames()
    +getConstructor(String name)
}
interface ViewType {
    +getName()
    +getIdAttribute()
    +isUpdatable()
    +isPartiallyUpdatable()
    +getViewFilter(String name)
    +getViewFilters()
}
interface FlatViewType {
}
interface MappingConstructor {
    +getName()
    +getDeclaringType()
    +getJavaConstructor()
    +getParameterAttributes()
    +getParameterAttribute(int index)
}
interface FilterMapping {
    +getName()
    +isViewFilter()
    +getFilterClass()
}
interface ViewFilterMapping {
    +getDeclaringType()
}
ManagedViewType &lt;|-- ViewType
ManagedViewType &lt;|-- FlatViewType
FilterMapping &lt;|-- ViewFilterMapping

hide fields
hide FlatViewType members</pre>
</div>
</div>
<div class="paragraph">
<p>A view can have multiple named constructors that have parameter attributes. Additionally, a view can also have multiple named view filters.
Every managed view has attributes which are structured based on the arity(singular or plural), the mapping type(parameter or method) and correlation type(normal, subquery or correlated).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x6c38c529&gt;&gt;
interface Attribute {
    +getDeclaringType()
    +getJavaType()
    +isSubquery()
    +isCollection()
    +isSubview()
    +isCorrelated()
    +getFetchStrategy()
    +getBatchSize()
}

interface SingularAttribute {
    +isQueryParameter()
    +isId()
}

interface PluralAttribute {
    +getCollectionType()
    +getElementType()
    +isIndexed()
    +isOrdered()
    +isSorted()
    +getComparator()
    +getComparatorClass()
}

interface MethodAttribute {
    +getName()
    +isUpdatable()
    +getJavaMethod()
    +getFilter(String filterName)
    +getFilters()
}
interface ParameterAttribute {
    +getIndex()
    +getDeclaringConstructor()
}

interface MappingAttribute {
    +getMapping()
}
interface CorrelatedAttribute {
    +getCorrelationProvider()
    +getCorrelationBasis()
    +getCorrelationResult()
}
interface SubqueryAttribute {
    +getSubqueryProvider()
    +getSubqueryExpression()
    +getSubqueryAlias()
}

enum CollectionType {
    COLLECTION
    LIST
    MAP
    SET
}

interface CollectionAttribute
interface SetAttribute
interface ListAttribute
interface MapAttribute {
    +getKeyType()
    +isKeySubview()
}

interface FilterMapping {
    +getName()
    +isViewFilter()
    +getFilterClass()
}
interface AttributeFilterMapping {
    +getDeclaringAttribute()
}


Attribute &lt;|-- SingularAttribute
Attribute &lt;|-- PluralAttribute

Attribute &lt;|-- MethodAttribute
Attribute &lt;|-- ParameterAttribute

Attribute &lt;|-- MappingAttribute
Attribute &lt;|-- CorrelatedAttribute
SingularAttribute &lt;|-- SubqueryAttribute

PluralAttribute &lt;|-- ListAttribute
PluralAttribute &lt;|-- MapAttribute
PluralAttribute &lt;|-- CollectionAttribute
PluralAttribute &lt;|-- SetAttribute

FilterMapping &lt;|-- AttributeFilterMapping

hide fields
hide CollectionAttribute members
hide SetAttribute members
hide ListAttribute members
show CollectionType fields
hide CollectionType methods</pre>
</div>
</div>
<div class="paragraph">
<p>An attribute is always either an instance of <code>ParameterAttribute</code> or <code>MethodAttribute</code> depending on whether it is defined on a constructor as parameter or as getter method.
A parameter attribute is defined by it&#8217;s index and it&#8217;s declaring <code>MappingConstructor</code>.
Method attributes have a name, may have multiple named attribute filters and might possibly be updatable.</p>
</div>
<div class="paragraph">
<p>A singular attribute is always an instance of <code>SingularAttribute</code> and is given if <code>isCollection()</code> returns <code>false</code>.
If it is a subquery i.e. <code>isSubquery()</code> returns <code>true</code>, it is also an instance of <code>SubqueryAttribute</code>.
If it is correlated i.e. <code>isCorrelated()</code> returns <code>true</code>, it is also an instance of <code>CorrelatedAttribute</code>.
If it is neither a subquery nor correlated, it is going to be an instance of <code>MappingAttribute</code>.</p>
</div>
<div class="paragraph">
<p>A plural attribute is always an instance of <code>PluralAttribute</code> and is given if <code>isCollection()</code> return <code>true</code>.
Since plural attributes can&#8217;t be defined via a subquery mapping, it is never an instance of <code>SubqueryAttribute</code>.
If it is correlated i.e. <code>isCorrelated()</code> returns <code>true</code>, it is also an instance of <code>CorrelatedAttribute</code>, otherwise it is going to be an instance of <code>MappingAttribute</code>.
Depending on the collection type returned by <code>getCollectionType</code> a plural attribute is also an instance of</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CollectionAttribute</code> if <code>CollectionType.COLLECTION</code></p>
</li>
<li>
<p><code>ListAttribute</code> if <code>CollectionType.LIST</code></p>
</li>
<li>
<p><code>SetAttribute</code> if <code>CollectionType.SET</code></p>
</li>
<li>
<p><code>MapAttribute</code> if <code>CollectionType.MAP</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>14. Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Blaze Persistence can be configured by setting properties on a <code>com.blazebit.persistence.view.spi.EntityViewConfiguration</code> object and creating a <code>EntityViewManager</code> from it.</p>
</div>
<div class="sect2">
<h3 id="anchor-configuration-properties"><a class="anchor" href="#anchor-configuration-properties"></a>14.1. Configuration properties</h3>
<div class="sect3">
<h4 id="proxy_eager_loading"><a class="anchor" href="#proxy_eager_loading"></a>14.1.1. PROXY_EAGER_LOADING</h4>
<div class="paragraph">
<p>Defines whether proxy classes for entity views should be created eagerly when creating the <code>EntityViewManager</code> or on demand.
To improve startup performance this is deactivated by default. When using entity views in a clustered environment you might want to enable this!</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.proxy.eager_loading</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="template_eager_loading"><a class="anchor" href="#template_eager_loading"></a>14.1.2. TEMPLATE_EAGER_LOADING</h4>
<div class="paragraph">
<p>Defines whether entity view template objects should be created eagerly when creating the <code>EntityViewManager</code> or on demand.
To improve startup performance this is deactivated by default. In a production environment you might want to enable this so that templates don&#8217;t have to be built on-demand but are retrieved from a cache.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.eager_loading</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="proxy_unsafe_allowed"><a class="anchor" href="#proxy_unsafe_allowed"></a>14.1.3. PROXY_UNSAFE_ALLOWED</h4>
<div class="paragraph">
<p>Defines whether proxy classes that support using the getter methods in a constructor should be allowed.
These proxy classes have to be defined via <code>sun.misc.Unsafe</code> to avoid class verification errors.
Disabling this property makes the use of the getter in the constructor return the default value for the property instead of the actual value.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.proxy.unsafe_allowed</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="expression_validation_disabled"><a class="anchor" href="#expression_validation_disabled"></a>14.1.4. EXPRESSION_VALIDATION_DISABLED</h4>
<div class="paragraph">
<p>Defines whether the expressions of entity view mappings should be validated.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.expression_validation_disabled</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="default_batch_size"><a class="anchor" href="#default_batch_size"></a>14.1.5. DEFAULT_BATCH_SIZE</h4>
<div class="paragraph">
<p>Defines the default batch size to be used for attributes that are fetched via the <code>SELECT</code> fetch strategy.
To specify the batch size of a specific attribute, append the attribute name after the "batch_size" like
e.g. <code>com.blazebit.persistence.view.batch_size.subProperty</code></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.batch_size</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="expect_batch_correlation_values"><a class="anchor" href="#expect_batch_correlation_values"></a>14.1.6. EXPECT_BATCH_CORRELATION_VALUES</h4>
<div class="paragraph">
<p>Defines whether by default batching of correlation values or view root ids is expected for attributes that are fetched via the <code>SELECT</code> fetch strategy.
To specify the batch expectation of a specific attribute, append the attribute name after the "batch_correlation_values" like
e.g. <code>com.blazebit.persistence.view.batch_correlation_values.subProperty</code></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.batch_correlation_values</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="updater_eager_loading"><a class="anchor" href="#updater_eager_loading"></a>14.1.7. UPDATER_EAGER_LOADING</h4>
<div class="paragraph">
<p>Defines whether entity view updater objects should be created eagerly when creating the <code>EntityViewManager</code> or on demand.
To improve startup performance this is deactivated by default. In a production environment you might want to enable this so that updaters don&#8217;t have to be built on-demand but are retrieved from a cache.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.updater.eager_loading</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="updater_flush_mode"><a class="anchor" href="#updater_flush_mode"></a>14.1.8. UPDATER_FLUSH_MODE</h4>
<div class="paragraph">
<p>Defines the flush mode the entity view updater objects should be using which is normally defined via <code>@UpdatableEntityView(mode = ...)</code>.
This is a global override. To override the flush mode of a specific class, append the fully qualified class name after the "flush_mode" part like
e.g. <code>com.blazebit.persistence.view.updater.flush_mode.com.test.MyUpdatableCatView</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.updater.flush_mode</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Values</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partial, lazy or full</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="updater_flush_strategy"><a class="anchor" href="#updater_flush_strategy"></a>14.1.9. UPDATER_FLUSH_STRATEGY</h4>
<div class="paragraph">
<p>Defines the flush strategy the entity view updater objects should be using which is normally defined via <code>@UpdatableEntityView(strategy = ...)</code>.
This is a global override. To override the flush strategy of a specific class, append the fully qualified class name after the "flush_strategy" part like
e.g. <code>com.blazebit.persistence.view.updater.flush_strategy.com.test.MyUpdatableCatView</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.view.updater.flush_strategy</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Values</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">entity or query</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.2.0-SNAPSHOT<br>
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>