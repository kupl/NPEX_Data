<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Querying and Pagination API</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#querying-and-pagination-api">Querying and Pagination API</a>
<ul class="sectlevel2">
<li><a href="#querying-entity-views">Querying entity views</a></li>
<li><a href="#anchor-optional-parameters">Optional parameters and configuration</a></li>
<li><a href="#anchor-entity-view-apply-root">Applying entity views on specific relations</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="querying-and-pagination-api"><a class="anchor" href="#querying-and-pagination-api"></a>Querying and Pagination API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main entry point to entity views is via the <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#create(java.lang.Class)"><code>EntityViewSetting.create()</code></a> API.
There are multiple different variants of the static <code>create()</code> method that allow to construct a <code>EntityViewSetting</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>create(Class&lt;?&gt; entityViewClass)</code></dt>
<dd>
<p>Creates a simple entity view setting without pagination.</p>
</dd>
<dt class="hdlist1"><code>create(Class&lt;T&gt; entityViewClass, int firstResult, int maxResults)</code></dt>
<dd>
<p>Creates a entity view setting that will apply pagination to a <code>CriteriaBuilder</code> via <a href="{core_doc}#pagination"><code>page(int firstResult, int maxResults)</code></a></p>
<div class="ulist">
<ul>
<li>
<p><code>create(Class&lt;T&gt; entityViewClass, Object entityId, int maxRows)</code>
Creates a entity view setting that will apply pagination to a <code>CriteriaBuilder</code> via <a href="{core_doc}#anchor-navigate-entity-page"><code>page(Object entityId, int maxResults)</code></a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Every of the variants also has an overload that additionally accepts a <code>viewConstructorName</code> to be able to construct entity views via <a href="#anchor-named-constructor">named constructors</a>.</p>
</div>
<div class="paragraph">
<p>A <code>EntityViewSetting</code> essentially is configuration that can be applied to a <code>CriteriaBuilder</code> and contains the following aspects</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Projection and DTO construction based on the entity view class</p>
</li>
<li>
<p>Entity view attribute based filtering</p>
</li>
<li>
<p>Entity view attribute based sorting</p>
</li>
<li>
<p>Query pagination</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Allowing the actual data consumer i.e. the UI to specify these aspects is essential for efficient and easy to maintain data retrieval.</p>
</div>
<div class="paragraph">
<p>For a simple lookup by id there is also a convenience <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#find(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.Object)"><code>EntityViewManager.find()</code></a> method available
that allows you to skip some of the <code>CriteriaBuilder</code> ceremony and that works analogous to how <code>EntityManager.find()</code> works, but with entity views.</p>
</div>
<div class="sect2">
<h3 id="querying-entity-views"><a class="anchor" href="#querying-entity-views"></a>Querying entity views</h3>
<div class="paragraph">
<p>Code in the presentation layer is intended to create an <code>EntityViewSetting</code> via the <code>create()</code> API and pass the entity view setting to a data access method.
The data access method then applies the setting onto a <code>CriteriaBuilder</code> instance which it created to build a query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We know that the current state of the <code>EntityViewSetting</code> API requires some verbose generics and we are going to fix that in 2.0. For further information also see <a href="https://github.com/Blazebit/blaze-persistence/issues/371">#371</a>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="normal-criteriabuilder-use"><a class="anchor" href="#normal-criteriabuilder-use"></a>Normal CriteriaBuilder use</h4>
<div class="paragraph">
<p>Depending on the need for pagination, an <code>EntityViewSetting</code> object is normally created like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, CriteriaBuilder&lt;CatView&gt;&gt; setting;
// Use this if no pagination is required
setting = EntityViewSetting.create(CatView.class);
// Apply filters and sorters on setting
List&lt;CatView&gt; list = catDataAccess.findAll(setting);</pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the <code>catDataAccess</code> is quite simple. It creates a query with the <code>CriteriaBuilder</code> API as usual,
and finally applies the setting on the builder through the <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#applySetting(com.blazebit.persistence.view.EntityViewSetting,%20com.blazebit.persistence.CriteriaBuilder)"><code>EntityViewManager.applySetting()</code></a> method.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Inject these somehow
CriteriaBuilderFactory criteriaBuilderFactory;
EntityViewManager entityViewManager;

public &lt;V, Q extends CriteriaBuilder&lt;V&gt;&gt; List&lt;V&gt; findAll(EntityViewSetting&lt;V, Q&gt; setting) {
    CriteriaBuilder&lt;Cat&gt; criteriaBuilder = criteriaBuilderFactory.create(Cat.class);

    // Apply business logic filters
    criteriaBuilder.where("deleted").eq(false);

    return entityViewManager.applySetting(setting, criteriaBuilder)
                .getResultList();
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="paginating-entity-view-results"><a class="anchor" href="#paginating-entity-view-results"></a>Paginating entity view results</h4>
<div class="paragraph">
<p>When data pagination is required, the <code>firstResult</code> and <code>maxResults</code> parameters are required to be specified when creating the <code>EntityViewSetting</code> object</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, PaginatedCriteriaBuilder&lt;CatView&gt;&gt; setting;
// Paginate and show only the 10 first records by doing this
setting = EntityViewSetting.create(CatView.class, 0, 10);
// Apply filters and sorters on setting
PagedList&lt;CatView&gt; list = catDataAccess.findAll(setting);</pre>
</div>
</div>
<div class="paragraph">
<p>To actually be able to get the <code>PagedList</code> instead of a normal list, the following data access implementation is required</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Inject these somehow
CriteriaBuilderFactory criteriaBuilderFactory;
EntityViewManager entityViewManager;

public &lt;V, Q extends PaginatedCriteriaBuilder&lt;V&gt;&gt; PagedList&lt;V&gt; findAll(EntityViewSetting&lt;V, Q&gt; setting) {
    CriteriaBuilder&lt;Cat&gt; criteriaBuilder = criteriaBuilderFactory.create(Cat.class);

    // Apply business logic filters
    criteriaBuilder.where("deleted").eq(false);

    return entityViewManager.applySetting(setting, criteriaBuilder)
                .getResultList();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The only difference to the former implementation is that this method uses the <code>PaginatedCriteriaBuilder</code> as upper bound for the type variable and a different return type.
By using a different type variable bound, the <code>EntityViewManager.applySetting()</code> will return an instance of <code>PaginatedCriteriaBuilder</code>. It&#8217;s <code>getResultList()</code> returns a <code>PagedList</code> instead of a <em>normal</em> list.</p>
</div>
</div>
<div class="sect3">
<h4 id="keyset-pagination-with-entity-views"><a class="anchor" href="#keyset-pagination-with-entity-views"></a>Keyset pagination with entity views</h4>
<div class="paragraph">
<p>The <code>EntityViewSetting</code> API also comes with an integration with the <a href="{core_doc}#anchor-keyset-pagination">keyset pagination</a> feature.</p>
</div>
<div class="paragraph">
<p>A <code>EntityViewSetting</code> that serves for normal offset based pagination, can be additionally enriched with a <code>KeysetPage</code>
by invoking <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#withKeysetPage(com.blazebit.persistence.KeysetPage)"><code>withKeysetPage(KeysetPage keysetPage)</code></a>.
Supplying a keyset page allows the runtime to choose keyset pagination instead of offset pagination based on the requested page and the supplied keyset page.</p>
</div>
<div class="paragraph">
<p>To be able to use keyset pagination, it is required to <em>remember</em> the last known keyset page.
When using a server side UI technology, this can be done very easily by simply saving the keyset page in the HTTP session.
With e.g. CDI the <code>KeysetPage</code> could simply be declared as <em>field</em> of a session-like scoped bean.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, PaginatedCriteriaBuilder&lt;CatView&gt;&gt; setting;

int maxResults = ...; // elements per page
int firstResult = ...; // (pageNumber - 1) * elementsPerPage

setting = EntityViewSetting.create(CatView.class, firstResult, maxResults);
// Apply filters and sorters on setting

setting.withKeysetPage(previousKeysetPage);

PagedList&lt;CatView&gt; list = catDataAccess.findAll(setting);
previousKeysetPage = list.getKeysetPage();</pre>
</div>
</div>
<div class="paragraph">
<p>When using a more stateless approach like it is often the case with RESTful backends, the keyset page has to be <em>serialized</em> to the client and <em>deserialized</em> back when reading from the client.
Depending on your requirements, you can serialize the <code>KeysetPage</code> directly into e.g. a JSON object and should be able to deserialize it with the most common serialization libraries.
Another possible way to integrate this, is to generate URLs that contain the keyset in some custom format which should then be used by the client to navigate to the next or previous page.</p>
</div>
<div class="paragraph">
<p>Any of these approaches will require custom implementations of the <code>KeysetPage</code> and <code>Keyset</code> interfaces.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We are working on a more easy integration with REST technologies. For further information see <a href="https://github.com/Blazebit/blaze-persistence/issues/373">#373</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="entity-page-navigation-with-entity-views"><a class="anchor" href="#entity-page-navigation-with-entity-views"></a>Entity page navigation with entity views</h4>
<div class="paragraph">
<p>Sometimes it is necessary to navigate to a specific entry with a specific id. When required to also display the entry in a paginated table marked as <em>selected</em>,
it is necessary to determine the page at which an entry with an id is located. This feature is implemented by the <a href="{core_doc}#anchor-navigate-entity-page">navigate to entity page</a> feature
and can be used by creating an <code>EntityViewSetting</code> via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#create(java.lang.Class,%20java.lang.Object,%20int)"><code>create(Class&lt;T&gt; entityViewClass, Object entityId, int maxResults)</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">EntityViewSetting&lt;CatView, PaginatedCriteriaBuilder&lt;CatView&gt;&gt; setting;

setting = EntityViewSetting.create(CatView.class, catId, maxResults);
// Apply filters and sorters on setting

// Use this to activate keyset pagination
setting.withKeysetPage(null);

PagedList&lt;CatView&gt; list = catDataAccess.findAll(setting);
previousKeysetPage = list.getKeysetPage();</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-optional-parameters"><a class="anchor" href="#anchor-optional-parameters"></a>Optional parameters and configuration</h3>
<div class="paragraph">
<p>Apart from the already presented aspects, a <code>EntityViewSetting</code> also contains so called <em>optional parameters</em> and configuration properties.</p>
</div>
<div class="paragraph">
<p>Optional parameters are set on a query if no value is set and also injected into entity views if requested by a <a href="#anchor-parameter-mappings">parameter mapping</a>
and are a very good integration point for <em>dependency injection</em> into entity views.
They can be set with the <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#addOptionalParameter(java.lang.String,%20java.lang.Object)"><code>addOptionalParameter(String parameterName, Object value)</code></a> method.</p>
</div>
<div class="paragraph">
<p><a href="#anchor-configuration-properties">Configuration properties</a> denoted as being <em>always applicable</em> can be set via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>setProperty(String propertyName, Object value)</code></a>
and allow to override or fine tune configuration time behavior for a single query.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-entity-view-apply-root"><a class="anchor" href="#anchor-entity-view-apply-root"></a>Applying entity views on specific relations</h3>
<div class="paragraph">
<p>Up until now, an entity view setting has always been applied on the query root of a <code>CriteriaBuilder</code> which might not always be doable because of the way relations are mapped or how the query is done.
Fortunately, {projectname} entity views also allow to apply a setting on a relation of the query root via
<a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#applySetting(com.blazebit.persistence.view.EntityViewSetting,%20com.blazebit.persistence.CriteriaBuilder,%20java.lang.String)"><code>EntityViewManager.applySetting(EntityViewSetting setting, CriteriaBuilder criteriaBuilder, String entityViewRoot)</code></a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface CatView {
    @IdMapping
    Long getId();

    String getName();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Mapping this entity view on e.g. the father relation like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderFactory criteriaBuilderFactory = ...;
EntityViewManager entityViewManager = ...;

CriteriaBuilder&lt;Cat&gt; criteriaBuilder = criteriaBuilderFactory.create(Cat.class);
criteriaBuilder.where("father").isNotNull();

List&lt;CatView&gt; list = entityViewManager.applySetting(
    EntityViewSetting.create(CatView.class),
    criteriaBuilder,
    "father"
);</pre>
</div>
</div>
<div class="paragraph">
<p>This will map all <em>fathers</em> of cats to the <code>CatView</code> and roughly produce a query like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT father_1.id, father_1.name
FROM Cat cat
LEFT JOIN cat.father father_1
WHERE father_1 IS NOT NULL</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>