<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fetch strategies</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#anchor-fetch-strategies">Fetch strategies</a>
<ul class="sectlevel2">
<li><a href="#join-fetch-strategy">Join fetch strategy</a></li>
<li><a href="#select-fetch-strategy">Select fetch strategy</a></li>
<li><a href="#anchor-subselect-fetch-strategy">Subselect fetch strategy</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="anchor-fetch-strategies"><a class="anchor" href="#anchor-fetch-strategies"></a>Fetch strategies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are multiple different fetch strategies available for fetching. A fetch strategy can be applied to all kinds of mappings,
except for <code>@MappingParameter</code> and <code>@MappingSubquery</code>. These mappings will always use a <code>JOIN</code> strategy, i.e. the mapping will be put into the main query.</p>
</div>
<div class="paragraph">
<p>Any attribute in an entity view can be fetched separately by specifying a fetch strategy other than <code>JOIN</code>.</p>
</div>
<div class="paragraph">
<p>Every fetch strategy has some pros and cons but most of the time, the <code>JOIN</code> fetch strategy is a good choice.
Unless you can&#8217;t use the <code>JOIN</code> strategy because your JPA provider doesn&#8217;t support entity joins, you should always stick with it by default
and only change the strategy on a case by case basis.</p>
</div>
<div class="sect2">
<h3 id="join-fetch-strategy"><a class="anchor" href="#join-fetch-strategy"></a>Join fetch strategy</h3>
<div class="paragraph">
<p>If your JPA provider supports entity joins, the <code>JOIN</code> strategy usually makes sense most of the time.
In case of correlated mappings it will result in a <code>LEFT JOIN</code> <a href="{core_doc}#anchor-entity-joins">entity join</a> of the correlated entity type.
The correlation expression created by the <code>CorrelationProvider</code> will be used in the <code>ON</code> condition.</p>
</div>
<div class="paragraph">
<p>For an example query that is generated by this strategy take a look at the <a href="#anchor-correlation-mappings">correlation mappings</a> chapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="select-fetch-strategy"><a class="anchor" href="#select-fetch-strategy"></a>Select fetch strategy</h3>
<div class="paragraph">
<p>In general, the <code>SELECT</code> strategy will create a separate query for every attribute that uses it.
It will collect up to <em>N</em> distinct correlation basis values and then will execute that query to actually fetch the values for the attributes of the instances.
The parameter <em>N</em> is the batch size that can be configured at multiple levels.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example that shows what happens</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @BatchFetch(20) <i class="conum" data-value="1"></i><b>(1)</b>
    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        fetch = FetchStrategy.SELECT
    )
    Set&lt;Person&gt; getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String pers = builder.getCorrelationAlias();
            builder.correlate(Person.class)
                .on(pers + ".age").inExpressions(correlationExpression)
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines the batch size to use for loading</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using this entity view, there are 2 queries that are generated.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The main query will fetch the <code>correlationBasis</code> and all the other attributes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    TREAT_LONG(correlationParams.value),
    correlated_SameAgedPersons
FROM Person correlated_SameAgedPersons,
     VALUES ((?), (?), ...) correlationParams <i class="conum" data-value="1"></i><b>(1)</b>
WHERE correlated_SameAgedPersons.age = TREAT_LONG(correlationParams.value)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Actually there will be 20 question marks here because of the defined batch size of 20</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The correlation query on the other hand will select the correlation value and the <code>Person</code> instances with an age matching any of the <code>correlationParams</code> values.
What you see here is the use of the <a href="{core_doc}#anchor-values-clause"><code>VALUES</code> clause</a> for making multiple values available like a table for querying which is required when wanting to select the correlation value.
Selecting the actual correlation value via <code>TREAT_LONG(correlationParams.value)</code> along with the <code>Person</code> is necessary to be able to correlate the instances to the instance of the main query.</p>
</div>
<div class="paragraph">
<p>Depending on how many different values for <code>age</code> there are(cardinality), the correlation query might get executed multiple times.
In general, the runtime will collect up to <em>batch size</em> different values and then execute the correlation query for these values.
Results for a correlation value are cached during the querying to avoid querying the same correlation values multiple times in different batches.</p>
</div>
<div class="paragraph">
<p>This strategy works best when the cardinality of the <code>correlationBasis</code> is low i.e. there are only a few distinct values.
If the cardinality is high and the batch size is too low, this can lead to something similar as an <em>N + 1 select</em> known from lazy loading of collection elements.
You could theoretically choose a very big batch size to be able to handle more correlation values per query, but beware that there are limits to the efficiency of this approach.
Also beware that the amount of possible parameters might be limited by the DBMS. A value of <em>1000</em> for the batch size shouldn&#8217;t generally be a problem for a DBMS,
but before you configure such a high value, look into the <a href="#anchor-subselect-fetch-strategy">subselect</a> strategy which might be more appropriate for higher cardinalities.</p>
</div>
<div class="sect3">
<h4 id="select-fetch-strategy-with-batching"><a class="anchor" href="#select-fetch-strategy-with-batching"></a>Select fetch strategy with batching</h4>
<div class="paragraph">
<p>Apart from using the <code>@BatchFetch</code> annotation, there are some other ways to define a batch size for fetching of an attribute.</p>
</div>
<div class="sect4">
<h5 id="batch-size-default-per-entity-view"><a class="anchor" href="#batch-size-default-per-entity-view"></a>Batch size default per entity view</h5>
<div class="paragraph">
<p>A default batch size can be defined by setting the property <a href="#default-batch-size"><code>com.blazebit.persistence.view.batch_size</code></a> via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>.
The value serves as default value and can be overridden on a per attribute basis.</p>
</div>
</div>
<div class="sect4">
<h5 id="batch-size-per-entity-view-attribute"><a class="anchor" href="#batch-size-per-entity-view-attribute"></a>Batch size per entity view attribute</h5>
<div class="paragraph">
<p>The batch size for a specific attribute can be defined either by using the <code>@BatchFetch</code> annotation or by setting the <a href="#default-batch-size"><code>com.blazebit.persistence.view.batch_size</code></a> property suffixed with the attribute name.
In order to set the batch size for an attribute named <em>someAttribute</em> you have to set the property <code>com.blazebit.persistence.view.batch_size.someAttribute</code> via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>.
The path to the attribute is based on the entity view which is queried and can also be deep i.e. <code>someSubview.someAttribute</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anchor-select-fetch-strategy-view-root"><a class="anchor" href="#anchor-select-fetch-strategy-view-root"></a>Select fetch strategy with VIEW_ROOT</h4>
<div class="paragraph">
<p>One possible problem with this strategy might arise when using the <code>VIEW_ROOT</code> function. The use of two correlation keys i.e. the view root and the correlation basis,
will affect the way the batching can be done. Before querying for the correlated date, the runtime will determine the cardinality of the view root ids and the correlation basis values.
After that, it will group the values with higher cardinality by the values with lower cardinality to be able to do efficient batching.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what that means</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    Set&lt;KittenCatView&gt; getKittens();

}

@EntityView(Cat.class)
public interface KittenCatView {

    @IdMapping
    Long getId();

    @BatchFetch(20)
    @MappingCorrelated(
        correlationBasis = "age",
        correlator = CatAgeCorrelationProvider.class,
        fetch = FetchStrategy.SELECT
    )
    Set&lt;Cat&gt; getSameAgedCats();

    static class CatAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String correlatedCat = builder.getCorrelationAlias();
            builder.correlate(Cat.class)
                .on(correlatedCat + ".age").inExpressions(correlationExpression)
                .on(correlatedCat + ".id").notInExpressions("VIEW_ROOT(id)")
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>In this example the batching might happen either for view roots or correlation basis values depending on the data.
If the number of distinct view root ids is lower than the number of distinct correlation basis values, the correlation basis values are grouped by view root ids.
The runtime will then execute a batched query for every view root id.</p>
</div>
<div class="paragraph">
<p>The good thing is, the runtime will adapt based on the data to minimize the number of queries, but still, if the cardinality is high, this can result in many queries being executed.</p>
</div>
<div class="sect4">
<h5 id="batching-expectation-fine-tuning"><a class="anchor" href="#batching-expectation-fine-tuning"></a>Batching expectation fine tuning</h5>
<div class="paragraph">
<p>By default the runtime assumes that the <code>VIEW_ROOT</code> function is not used and generates a query that batches correlation basis values.
If this assumption fails because the <code>VIEW_ROOT</code> function is used and the batching is done based on view root ids, a new query has to be built.</p>
</div>
<div class="paragraph">
<p>The way the <code>VIEW_ROOT</code> function is implemented requires to invoke the <code>CorrelationProvider</code> again for building the new query.</p>
</div>
<div class="paragraph">
<p>To avoid this unnecessary rebuilding of the query, you can specify the batch expectation for all attributes by setting the property
<a href="#expect-batch-correlation-values"><code>com.blazebit.persistence.view.batch_correlation_values</code></a> via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>
to <code>false</code> if batching is expected to be done on a view root id basis. The value serves as default value and can be overridden on a per attribute basis by suffixing the property name with the attribute name.
In order to set the batch expectation for an attribute named <em>someAttribute</em> you have to set the property <code>com.blazebit.persistence.view.batch_correlation_values.someAttribute</code> via <a href="{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)"><code>EntityViewSetting.setProperty()</code></a>.
The path to the attribute is based on the entity view which is queried and can also be deep i.e. <code>someSubview.someAttribute</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-subselect-fetch-strategy"><a class="anchor" href="#anchor-subselect-fetch-strategy"></a>Subselect fetch strategy</h3>
<div class="paragraph">
<p>The <code>SUBSELECT</code> strategy will create one query for every attribute that uses it and is especially efficient for bigger collections.
It creates a separate query based on the outer query and applies the <code>CorrelationProvider</code> to it.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Correlating subviews that contain collections when using <code>firstResult</code>/<code>maxResults</code> or applying an entity view on queries that use <code>ORDER BY</code> select aliases does not yet work. For more information also see <a href="https://github.com/Blazebit/blaze-persistence/issues/370">#370</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example that shows what happens</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
public interface CatView {

    @IdMapping
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        correlationResult = "pers",
        fetch = FetchStrategy.SUBSELECT
    )
    Set&lt;Person&gt; getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            final String pers = builder.getCorrelationAlias();
            builder.correlate(Person.class)
                .on(pers + ".age").inExpressions(correlationExpression)
            .end();
        }

    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>When using this entity view, there are 2 queries that are generated.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id, cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The main query will fetch the <code>correlationBasis</code> and all the other attributes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    cat.age,
    correlated_SameAgedPersons
FROM Cat cat,
     Person correlated_SameAgedPersons
WHERE correlated_SameAgedPersons.age = cat.age</pre>
</div>
</div>
<div class="paragraph">
<p>The correlation query looks very similar since it&#8217;s based on the main query, but has a custom select clause.
It selects the correlation key as well as the attributes for the target representation in the main entity view.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>