<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Updatable Entity Views</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#updatable-entity-views">Updatable Entity Views</a>
<ul class="sectlevel2">
<li><a href="#update-mapping">Update mapping</a></li>
<li><a href="#create-mapping">Create mapping</a></li>
<li><a href="#api-usage">API usage</a></li>
<li><a href="#lifecycle-and-listeners">Lifecycle and listeners</a></li>
<li><a href="#attribute-mappings">Attribute mappings</a></li>
<li><a href="#locking-support">Locking support</a></li>
<li><a href="#updatable-entity-view-persist-and-update-cascading">Persist and Update cascading</a></li>
<li><a href="#updatable-entity-view-delete-cascading-orphan-removal">Cascading deletes and orphan removal</a></li>
<li><a href="#conversion-support">Conversion support</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="updatable-entity-views"><a class="anchor" href="#updatable-entity-views"></a>Updatable Entity Views</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Updatable entity views represent DTOs for the write concern of an application. Updatable entity views are like a normal entity views,
except that changes to attributes are tracked and can be inspected through the <a href="#updatable-entity-view-change-model-api">Change Model API</a> or flushed to the backing data store.</p>
</div>
<div class="paragraph">
<p>Updatable entity views are also a lot like normal entities and can be thought of being similar to what is sometimes referred to as <em>sub-entities</em>.
The main idea is to model use-case specific representations with a limited scope of attributes that can change.
Usually, when using an entity type, many more attributes are exposed as being <em>changable</em> to the consumer of the type, although they might not even need to be <em>updatable</em>.
Updatable entity views allows for perfect reuse of attribute declarations thanks to it&#8217;s use of interfaces but also brings a lot more to the table than using plain entities.</p>
</div>
<div class="paragraph">
<p>Apart from a concept for updating existing objects, {projectname} also has a notion for <em>creating</em> new objects.
With only JPA, a developer is often left with some open question like e.g. how to implement <em>equals-hashCode</em> for entities.
Thanks to the first class notion of creatable entity views, this question and others can be easily answered as discussed below.</p>
</div>
<div class="sect2">
<h3 id="update-mapping"><a class="anchor" href="#update-mapping"></a>Update mapping</h3>
<div class="paragraph">
<p>To declare an entity view as being updatable, it is required to additionally annotate it with <code>@UpdatableEntityView</code>.
By default an updatable entity view will do full updates i.e. always update all (owned) updatable attributes if at least one (owned) attribute is dirty.
Owned attributes are ones that belong the the backing entity type like e.g. basic typed attributes. Inverse attributes aren&#8217;t owned and are thus independent.
This behavior can be configured by setting the <code>mode</code> attribute on the <code>@UpdatableEntityView</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PARTIAL</code> - The mode will only flush values of actually changed attributes</p>
</li>
<li>
<p><code>LAZY</code> - The default, will flush all updatable values if at least one attribute is dirty</p>
</li>
<li>
<p><code>FULL</code> - Always flushes all updatable attributes, regardless of dirtyness</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The flushing, by default, is done by executing JPQL DML statements, but can be configured to use entities instead by setting the <code>strategy</code> attribute on the <code>@UpdatableEntityView</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QUERY</code> - The default, will flush changes by executing JPQL DML statements. Falling back to entity flushing if necessary</p>
</li>
<li>
<p><code>ENTITY</code> - Will flush changes by loading the dirty entity graph and applying changes onto it</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="create-mapping"><a class="anchor" href="#create-mapping"></a>Create mapping</h3>
<div class="paragraph">
<p>To declare an entity view as being creatable, it is required to additionally annotate it with <code>@CreatableEntityView</code>.
Note that updatable entity views for embeddable types are implicitly also creatable, yet the <code>@CreatableEntityView</code> annotation can still be applied for further configuration.
By default, a creatable entity view is validated against the backing model regarding it&#8217;s <em>persistability</em> i.e. it is checked if an instance could be successfully persisted regarding the non-null constraints of the entity model.
This allows to catch errors early that occur when adding new attributes to the entity model but forgetting to do so in the entity view.
The validation can be disabled by setting the <code>validatePersistability</code> attribute on the <code>@CreatableEntityView</code> to <code>false</code>
but can also be controlled in a fine grained manner by excluding specific entity attributes from the validation via the <code>excludedEntityAttributes</code> attribute.
The latter is useful for attributes that are known to be set on the entity model through entity listeners or entity view listeners.</p>
</div>
<div class="paragraph">
<p>Creatable views are converted to their context specific declaration type after persisting.
This mean that if a creatable entity view is used as value for an attribute of an updatable entity view, the instance is replaced by an equivalent instance
of the type that is declared for the attribute. Consider the following example model for illustration.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    OwnerView getOwner();
    void setOwner(OwnerView owner);
}
@EntityView(Person.class)
interface OwnerView {
    @IdMapping
    Long getId();

    String getName();
}
@CreatableEntityView
@EntityView(Person.class)
interface OwnerCreateView extends OwnerView {
    void setName(String name);
}</pre>
</div>
</div>
<div class="paragraph">
<p>When flushing an instance of the type <code>CatUpdateView</code> that contains an owner of the creatable entity view type <code>OwnerCreateView</code> the following happens</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <code>Person</code> entity is created with the defined properties</p>
</li>
<li>
<p>The <code>Person</code> entity is persisted via <code>EntityManager.persist()</code></p>
</li>
<li>
<p>The generated identifier is set on the <code>OwnerCreateView</code> object</p>
</li>
<li>
<p>The <code>OwnerCreateView</code> object is converted to the context specific declared type <code>OwnerView</code></p>
</li>
<li>
<p>The <code>OwnerCreateView</code> object is replaced by the <code>OwnerView</code> object</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The same replacing happens for creatable entity views that are contained in a collection, thus developers don&#8217;t need to think about possible problems related to primary key based equals-hashCode implementations.
Since the object is properly replaced, the assignment of a generated primary key, which would change the object regarding equals-hashCode, is not problematic.
Still, the object can safely make use of the primary key based equals-hashCode implementation that is generated for all entity views by default.</p>
</div>
</div>
<div class="sect2">
<h3 id="api-usage"><a class="anchor" href="#api-usage"></a>API usage</h3>
<div class="paragraph">
<p>An updatable as well as an creatable entity view is flushed by invoking <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#update(javax.persistence.EntityManager,%20java.lang.Object)"><code>EntityViewManager.update(EntityManager em, Object view)</code></a>
and will flush changes according to the flush strategy and mode. Changes to collections are flushed depending on the collection mapping.</p>
</div>
<div class="paragraph">
<p>If the entity for which a collection is mapped <em>owns</em> the collection i.e. no use of <em>mappedBy</em>, the changes will be applied to an entity reference.
For collections that are <em>not owned</em> by the containing entity i.e. use a <em>mappedBy</em>, changes will be applied by creating/updating/deleting the target entities.</p>
</div>
<div class="paragraph">
<p>Creatable entity views are constructed via <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#create(java.lang.Class)"><code>EntityViewManager.create(Class type)</code></a> and
always result in a persist when being flushed directly or through an updatable attribute having the <code>CascadeType.PERSIST</code> enabled.</p>
</div>
<div class="paragraph">
<p>Deletion of entities through view types works either by supplying an existing view object to <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#remove(javax.persistence.EntityManager,%20java.lang.Object)"><code>EntityViewManager.remove(EntityManager em, Object view)</code></a>
or by entity id via <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#remove(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.Object)"><code>EntityViewManager.remove(EntityManager em, Class viewType, Object id)</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="lifecycle-and-listeners"><a class="anchor" href="#lifecycle-and-listeners"></a>Lifecycle and listeners</h3>
<div class="paragraph">
<p>An entity view similar to a JPA entity also has something like a lifecycle, though within entity views, the states correspond to different entity view java types, rather than a transaction state.
There are essentially 3 different kinds of entity views:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>new</strong></dt>
<dd>
<p>An instance of a creatable entity view type(<code>@CreatableEntityView</code>) that is created via <code>EntityViewManager.create(Class)</code>.
After flushing of such an instance, the instance transitions to the <em>updatable</em> state if the entity view java type is also updatable(<code>@UpdatableEntityView</code>)
otherwise to the <em>read-only</em> state. If it is used within an updatable view, it is then converted to the context specific type which replaces the creatable entity view instance.</p>
</dd>
<dt class="hdlist1"><strong>read-only</strong></dt>
<dd>
<p>A normal entity view <strong>without</strong> updatable or creatable configuration(<code>@UpdatableEntityView</code>, <code>@CreatableEntityView</code>).</p>
</dd>
<dt class="hdlist1"><strong>updatable</strong></dt>
<dd>
<p>An entity view with updatable configuration(<code>@UpdatableEntityView</code>).</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is still in development, so not all features might be available yet. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/433" class="bare">https://github.com/Blazebit/blaze-persistence/issues/433</a> for more information.
</td>
</tr>
</table>
</div>
<div class="imageblock">
  <div class="content">
        <a href="javascript:;" onclick="document.location.hash='images/entity-view-write-model-lifecycle-diagram.png';">
          <img src="images/entity-view-write-model-lifecycle-diagram.png" alt="entity view write model lifecycle diagram" width="1050" height="448">
        </a>
        <div class="lightbox" id="images/entity-view-write-model-lifecycle-diagram.png">
          <a href="javascript:;" onclick="document.location.hash='_';" class="btn-close">X</a>
          <img src="images/entity-view-write-model-lifecycle-diagram.png" alt="entity view write model lifecycle diagram" width="1050" height="448">
        </div>
  </div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>load</strong></dt>
<dd>
<p>An entity view is loaded by applying an <code>EntityViewSetting</code> to a <code>CriteriaBuilder</code> which also happens implicitly when using <code>EntityViewManager.find()</code>.
Another way to <em>load</em> is to get a <em>reference</em> for an entity view via <code>EntityViewManager.getReference()</code>.</p>
</dd>
<dt class="hdlist1"><strong>remove</strong></dt>
<dd>
<p>Removing is done explicitly by calling <code>EntityViewManager.remove()</code> or implicitly when <a href="#updatable-entity-view-delete-cascading-orphan-removal">delete cascading or orphan removal</a> is activated.</p>
</dd>
<dt class="hdlist1"><strong>create</strong></dt>
<dd>
<p>Creating of entity view instances is done by calling <code>EntityViewManager.create()</code>.</p>
</dd>
<dt class="hdlist1"><strong>flush/update</strong></dt>
<dd>
<p>Flushing/Updating happens when invoking <code>EntityViewManager.update()</code> or <code>EntityViewManager.updateFull()</code> as well as implicitly for <code>CascadeType.UPDATE</code> enabled attributes.</p>
</dd>
<dt class="hdlist1"><strong>convert</strong></dt>
<dd>
<p>Conversion happens when calling <code>EntityViewManager.convert()</code> which implicitly happens for creatable entity views within a context after persisting.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For most of the operations it is possible to register a listener which is invoked before or after an operation.
The listeners can react to specific events but in some cases also alter the state of the corresponding object.</p>
</div>
<div class="paragraph">
<p>A listener can be defined within an entity view class but within a class hierarchy there may only be one listener. If multiple listeners from e.g. super interfaces are inherited,
the entity view type must declare a listener to disambiguate the situation. The listener then can invoke other listener methods or skip them.</p>
</div>
<div class="paragraph">
<p>Most listeners can be defined for a specific update or remove operation to react to change events in a particular manner for a specific use case,
but it is also possible to register listeners globally. The globally registered listeners can be used to implement cross cutting concerns like soft-deletion, auditing, etc.
Global listeners are registered via one of the <code>EntityViewConfiguration.registerListener</code> methods.</p>
</div>
<div class="sect3">
<h4 id="post-create-listener"><a class="anchor" href="#post-create-listener"></a>Post create listener</h4>
<div class="paragraph">
<p>Within an entity view type a concrete method annotated with <code>@PostCreate</code> is considered to be a post create listener.
It may optionally define a parameter of the type <code>EntityViewManager</code> and must have a return type of void.</p>
</div>
<div class="paragraph">
<p>Such a listener is usually used for creatable entity view types to setup default values.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">enum LifeState {
    ALIVE,
    DEAD;
}

@CreatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    String getName();
    void setName(String name);

    LifeState getState();
    void setState(LifeState state);

    @PostCreate
    default void init() {
        setState(LifeState.ALIVE);
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pre-remove-listener"><a class="anchor" href="#pre-remove-listener"></a>Pre remove listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-remove-listener"><a class="anchor" href="#post-remove-listener"></a>Post remove listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pre-persist-listener"><a class="anchor" href="#pre-persist-listener"></a>Pre persist listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-persist-listener"><a class="anchor" href="#post-persist-listener"></a>Post persist listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pre-update-listener"><a class="anchor" href="#pre-update-listener"></a>Pre update listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-update-listener"><a class="anchor" href="#post-update-listener"></a>Post update listener</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not yet available.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attribute-mappings"><a class="anchor" href="#attribute-mappings"></a>Attribute mappings</h3>
<div class="paragraph">
<p>When an entity view has <code>@UpdatableEntityView</code> annotated, every attribute for which a setter method exists, is considered to be <em>updatable</em>.
For an attribute to be <em>updatable</em> means that changes done to the attribute of an entity view, can be flushed to the attribute they map to of an entity.
There is also a notion of <em>mutable</em> attributes which means that an attribute is <em>updatable</em> and/or the type of the attribute&#8217;s value might be <em>mutable</em>.</p>
</div>
<div class="paragraph">
<p>An unknown type is mutable by default and needs to be configured by registering a <a href="#entity-view-basic-user-type-spi">basic user type</a>.
Entity view types are only considered being mutable if they are updatable(<code>@UpdatableEntityView</code>) or creatable(<code>@CreatableEntityView</code>).
Entity types are always considered to be mutable.</p>
</div>
<div class="paragraph">
<p>Singular attributes with an updatable flat view type are also considered updatable even without a setter method.</p>
</div>
<div class="paragraph">
<p>The mappings for updatable attributes must follow some rules</p>
</div>
<div class="ulist">
<ul>
<li>
<p>May not use complex expressions like arithmetic or functions</p>
</li>
<li>
<p>May not access elements or attributes of elements through a collection e.g. <code>kittens.name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The general understanding is that mappings should be bi-directional i.e. it should be possible to map a value back to a specific entity attribute.</p>
</div>
<div class="paragraph">
<p>To prevent an attribute being considered updatable, it can be annotated with <code>@UpdatableMapping(updatable = false)</code>.
Sometimes, it&#8217;s also useful to annotate plural attributes i.e. collection attributes with <code>@UpdatableMapping(updatable = true)</code> when a setter is inappropriate.</p>
</div>
<div class="paragraph">
<p>Note that updatable and creatable entity view types require an <a href="#anchor-id-mappings">id mapping</a> to work properly, which is validated during the building of the metamodel.
The getters and setters of abstract entity view classes may use the protected or default visibility setting which allows to encapsulate the access to these attributes properly.</p>
</div>
<div class="sect3">
<h4 id="updatable-mappings-basic"><a class="anchor" href="#updatable-mappings-basic"></a>Basic type mappings</h4>
<div class="paragraph">
<p>Singular attributes with a basic type i.e. all types except entity view types, entity types or collection types,
do not have a nested domain structure since they are <em>basic</em>. Values of such types usually change by setting a different value,
though there are some mutable types as well. Basic types in general are handled by registered <a href="#entity-view-basic-user-type-spi">basic user types</a>
and define the necessary means to safely handle values of such types.</p>
</div>
<div class="paragraph">
<p>Values set for a basic type entity view attribute are only flushed to the entity attribute it refers to, if the entity view attribute is <em>updatable</em>.
This means that even if the type is mutable, a basic type attribute is never considered to be updatable as long as there is no setter or an explicit <code>@UpdatableMapping(updatable = true)</code> present.
If a type is immutable, an attribute with such a type obviously needs a setter to be considered updatable as there would otherwise be no way to change a value.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    String getName();
    void setName(String name);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Changes made via calls to e.g. <code>setName()</code> can be flushed later in a different persistence context.
The following shows a simple example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// Load the updatable entity view
CatUpdateView view = entityViewManager.find(entityManager, CatUpdateView.class, catId);

// Update the name of the view
view.setName("newName");

// Flush the changes to the persistence context
eventityViewManager.update(entityManager, view);</pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the configured flush strategy, this will either load the <code>Cat</code> entity and apply changes to it
or create an update query that set&#8217;s the updatable attributes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = :name
WHERE cat.id = :id</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-subview"><a class="anchor" href="#updatable-mappings-subview"></a>Subview mappings</h4>
<div class="paragraph">
<p>Just like *ToOne relationships can be mapped in entities, it is possible to map these relationships as subviews.
It is not required for such subview type to be updatable, in fact, it is encouraged to use a subview type that best fits the modeled use case.</p>
</div>
<div class="paragraph">
<p>In general, {projectname} distinguishes between two concepts regarding <em>updatability</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Updatability of the relationship role i.e. the attribute <code>owner</code> or more specifically the <code>owner_id</code> column</p>
</li>
<li>
<p>Updatability of the relation type represented by the entity view <code>PersonView</code> or more specifically the row in the <code>person</code> table</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example illustrates a case where the relation type <code>PersonView</code> is not updatable,
but the relationship represented by the attribute <code>owner</code> is updatable.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Person.class)
interface PersonView {
    @IdMapping
    Long getId();

    String getName();
}

@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    String getName();

    PersonView getOwner();
    void setOwner(PersonView owner);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Even if the <code>PersonView</code> had a <code>setName()</code> method, changes done to that attribute would not be flushed, since <code>PersonView</code> is not updatable(<code>@UpdatableEntityView</code>).</p>
</div>
<div class="paragraph">
<p>Having only an updatable relationship role is very common, because it is rarely necessary to do cascading updates.
Note that it is also possible to just make the entity view type <code>PersonView</code> updatable(annotate <code>@UpdatableEntityView</code>) without the setter <code>setOwner()</code>.
That way, the relationship role wouldn&#8217;t be allowed to change, but the changes to the underlying <code>Person</code> would be cascaded.</p>
</div>
<div class="paragraph">
<p>When the subview type is updatable(<code>@UpdatableEntityView</code>), updates are by default cascaded. If the subview type is also creatable(<code>@CreatableEntityView</code>), persists are also cascaded.
To disable or fine tune this behavior, it is possible to annotate the attribute getter with <code>@UpdatableMapping</code> and specify the <code>cascade</code> attribute.
Apart from defining which <code>CascadeType</code> is enabled, it is also possible to restrict the allowed subtypes via the attributes <code>subtypes</code>, <code>persistSubtypes</code> and <code>updateSubtypes</code>.
By default, instances of the declared type i.e. the compile time attribute type, are allowed to be set as attribute values.
Subtypes that are non-updatable and non-creatable are also allowed.
If the attribute defines <code>UPDATE</code> cascading or the declared type is updatable(<code>@UpdatableEntityView</code>), all updatable subtypes are also allowed.
If the attribute defines <code>PERSIST</code> cascading or the declared type is creatable(<code>@CreatableEntityView</code>), all creatable subtypes are also allowed.</p>
</div>
<div class="paragraph">
<p>In case of immutable or non-updatable subview types the method <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#getReference(java.lang.Class,%20java.lang.Object)"><code>EntityViewManager.getReference(Class viewType, Object id)</code></a> might come in handy.
This method allows to retrieve an instance of the given view type having the defined identifier. This is very useful for cases when just a relationship role like e.g. <em>owner</em> should be set without the need to query <code>PersonView</code> objects.
A common use case might be to set the tenant which owns an object. There is no need to query the tenant as the information is unnecessary for simply setting the relationship role, but the tenant&#8217;s identity is known.</p>
</div>
<div class="paragraph">
<p>To be able to encapsulate the creation of subviews or the access to references for subviews it is recommended to make use of the <a href="#entity-view-special-method-entity-view-manager-getter">special EntityViewManager getter method</a>.
The idea is to define an abstract getter method with protected or default visibility returning an <code>EntityViewManager</code>. Methods that create subviews or want a reference to a subview by id can then invoke the getter to get access to the <code>EntityViewManager</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-flat-view"><a class="anchor" href="#updatable-mappings-flat-view"></a>Flat view mappings</h4>
<div class="paragraph">
<p>Updatable flat view mappings are currently only supported for embeddable types. An updatable flat view type is also always creatable.
Flat views are always flushed as whole objects, which means that an updatable flat view should always at least map all attributes as read-only.
Read-only i.e. non-updatable attributes are <em>passed-through</em> to the embeddable object when recreating it.</p>
</div>
<div class="paragraph">
<p>Apart from that, a flat view is just like a normal subview.</p>
</div>
</div>
<div class="sect3">
<h4 id="subquery-parameter-mappings"><a class="anchor" href="#subquery-parameter-mappings"></a>Subquery &amp; parameter mappings</h4>
<div class="paragraph">
<p>Since subqueries and parameter mappings aren&#8217;t bidirectional, attributes using these kinds of mappings are never considered to be updatable.</p>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-entity"><a class="anchor" href="#updatable-mappings-entity"></a>Entity mappings</h4>
<div class="paragraph">
<p>Entity types are similar to subview types as they have an identity and are specially handled when loading and merging data.
Since entity types are mutable by design, <code>PERSIST</code> and <code>UPDATE</code> cascading are by default enabled for attributes that use entity types.
The cascading can be overridden by defining the cascade type via a <code>@UpdatableMapping</code> annotation on the attribute.
Note that the handling of entity types can be fine tuned by registering a <a href="#entity-view-basic-user-type-spi">basic user type</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    @UpdatableMapping(cascade = { CascadeType.UPDATE }) <i class="conum" data-value="1"></i><b>(1)</b>
    Cat getFather();
    void setFather(Cat father);
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines that only updates are cascaded. Unknown i.e. <em>new</em> Cat instances aren&#8217;t persisted</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Changes that are done via <code>setFather()</code> will update the <code>father</code> attribute in the entity model when flushed.
If query flushing is configured, a query like the following will be generated when updating the <code>father</code> relation.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.father = :father
WHERE cat.id = :id</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-collection"><a class="anchor" href="#updatable-mappings-collection"></a>Collection mappings</h4>
<div class="paragraph">
<p>Updatable collection mappings must be simple paths referring to a collection of the backing entity type. Paths to a nested collection like e.g. <code>owner.kittens</code> are not allowed.
Currently, a collection attribute is considered to be <em>updatable</em> if a setter for the attribute exists, or <code>@UpdatableMapping</code> is declared on the getter method of an attribute.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
At this point, collections can not be remapped automatically yet, so you have to use the same collection type as in the entity model.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Updates to owned collection are currently simply <em>replayed</em> on the collection of an entity reference.
Note that currently only inverse collections are considered <em>not owned</em> i.e. don&#8217;t require loading the real collection for doing updates.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    Set&lt;Cat&gt; getKittens();
    void setKittens(Set&lt;Cat&gt; kittens);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Any modification done to a collection</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatUpdateView view = ...;

// Update the view
Cat newKitten = entityManager.find(Cat.class, 2L);
view.getKittens().add(newKitten);

// Flush the changes to the persistence context
entityViewManager.update(entityManager, view);</pre>
</div>
</div>
<div class="paragraph">
<p>Will be applied on the collection of an entity reference during <code>update()</code> as if the following was done.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatUpdateView view = ...;
// Actually a query that loads the graph being dirty is issued
Cat cat = entityManager.find(Cat.class, view.getId());

cat.getKittens().add(newKitten);</pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>kittens</code> collection is dirty i.e. a new kitten was added and the collection is <em>owned</em> by the <code>Cat</code> entity, it will be loaded along with the <code>Cat</code>.
If <code>kittens</code> were an inverse collection, it wouldn&#8217;t need loading during flushing as adding the new kitten would be a matter of issuing an update query or persisting an entity.</p>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-collection"><a class="anchor" href="#updatable-mappings-collection"></a>Inverse mappings</h4>
<div class="paragraph">
<p>Changes to inverse relations like OneToOne&#8217;s and *ToMany collections are flushed by persisting, updating or removing the inverse relation objects.
There is no special mapping required. If the entity model defines that an attribute is an inverse mapping by specifying a <em>mappedBy</em>,
updatable entity view attributes mapping to such attributes automatically discover the <em>mappedBy</em> configuration and
will cause the attribute being maintained by managing inverse relation objects.</p>
</div>
<div class="paragraph">
<p>There are several strategies that can be configured to handle the removal of elements via the <code>removeStrategy</code> attribute of <code>@MappingInverse</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> - The default. Ignores elements that have been removed i.e. does not maintain the relationship automatically.</p>
</li>
<li>
<p><code>REMOVE</code> - Removes the inverse relation object when determined to be removed from the inverse relationship.</p>
</li>
<li>
<p><code>SET_NULL</code> - Sets the <em>mappedBy</em> attribute to <code>NULL</code> on the inverse relation object when found to be removed from the inverse relationship.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Person.class)
interface PersonUpdateView {
    @IdMapping
    Long getId();

    // mappedBy = "owner"
    @MappingInverse(removeStrategy = InverseRemoveStrategy.REMOVE)
    Set&lt;Cat&gt; getKittens();
    void setKittens(Set&lt;Cat&gt; kittens);
}</pre>
</div>
</div>
<div class="paragraph">
<p>A modification of the kittens collection&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">PersonUpdateView view = ...;

// Update the view
view.getKittens().remove(someKitten);

// Flush the changes to the persistence context
entityViewManager.update(entityManager, view);</pre>
</div>
</div>
<div class="paragraph">
<p>will cause the Cat <code>someKitten</code> to be removed.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE Cat c WHERE c.id = :someKittenId</pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>SET_NULL</code> strategy were used, the <code>owner</code> would be set to <code>NULL</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat c SET owner = NULL WHERE c.id = :someKittenId</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updatable-mappings-correlated"><a class="anchor" href="#updatable-mappings-correlated"></a>Correlated mappings</h4>
<div class="paragraph">
<p>Attributes with correlated mappings are currently not considered to be updatable as there is no way to map back to the entity model.
A future version might allow to treat such mappings as custom inverse mappings.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking-support"><a class="anchor" href="#locking-support"></a>Locking support</h3>
<div class="paragraph">
<p>{projectname} entity views by default automatically makes use of a version field mapped in the entity type for optimistic locking.
This is controlled by the <code>lockMode</code> attribute on the <code>@UpdatableEntityView</code> annotation which by default is set to <code>AUTO</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LockMode.AUTO</code> - The default. Uses the version field of the entity type the entity view is referring to for optimistic locking</p>
</li>
<li>
<p><code>LockMode.OPTIMISTIC</code> - Forces the use of optimistic locking based on the entity version field</p>
</li>
<li>
<p><code>LockMode.PESSIMISTIC_READ</code> - Acquires a JPA <code>PESSIMISTIC_READ</code> lock when reading the entity view</p>
</li>
<li>
<p><code>LockMode.PESSIMISTIC_WRITE</code> - Acquires a JPA <code>PESSIMISTIC_WRITE</code> lock when reading the entity view</p>
</li>
<li>
<p><code>LockMode.NONE</code> - Don&#8217;t use any locking even if a version attribute is available</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, all updatable attributes in an entity view are protected by optimistic locking.
This means that if the value of an attribute was changed, the change will be flushed with the optimistic lock condition.
Attribute changes that should be excluded from optimistic locking can be annotated with <code>@OptimisticLock(exclude = true)</code> to prevent the optimistic lock condition
when only such attributes are changed.</p>
</div>
<div class="paragraph">
<p>The entity type for which the optimistic lock condition is asserted is called the <em>lock owner</em>.
If the entity type of an entity view does not have a version field and the <code>LockMode.AUTO</code> is used, the parent entity view type is considered being the lock owner.
If the parent has no version field, it&#8217;s parent is considered and so forth. If no lock owner can be found, no optimistic locking is done.</p>
</div>
<div class="paragraph">
<p>When specifying a lock mode other than <code>LockMode.AUTO</code>, the entity object for an entity view becomes the lock owner.
By annotating <code>@LockOwner</code> on an updatable entity view type, a custom lock owner can be defined.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is still in development, so not all features might be available yet. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/439" class="bare">https://github.com/Blazebit/blaze-persistence/issues/439</a> and <a href="https://github.com/Blazebit/blaze-persistence/issues/438" class="bare">https://github.com/Blazebit/blaze-persistence/issues/438</a> for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-persist-and-update-cascading"><a class="anchor" href="#updatable-entity-view-persist-and-update-cascading"></a>Persist and Update cascading</h3>
<div class="paragraph">
<p>The cascade types defined in {projectname} entity views have different semantics than what JPA offers and should not be mixed up.
JPA defines cascade types for <em>logical operations</em> whereas {projectname} entity views defines cascade types for state changes.
In a JPA entity, one can define for which operations the changes done to an attribute should be flushed.
For example the JPA <code>CascadeType.PERSIST</code> will cause a flush of an attributes affected values only if the owning entity is about to be persisted.</p>
</div>
<div class="paragraph">
<p>{projectname} entity views cascade types define whether a value of an attribute may do a specific state transition.
If an attribute defines <code>CascadeType.PERSIST</code>, it means that <em>new</em> objects i.e. the ones created via <code>EntityViewManager.create()</code>,
are allowed to be used as values and that these object should be persisted during flushing.
Updates done to mutable values of an attribute are only flushed if the <code>CascadeType.UPDATE</code> is enabled.</p>
</div>
<div class="paragraph">
<p>Normally, the update or persist cascading is enabled for all subtypes of the declared attribute type,
but can be restricted by specifying specific subtypes for which to allow updates or persists.
This can be done via the <code>subtypes</code> attribute of the <code>@UpdatableMapping</code> or the <code>updateSubtypes</code> or <code>persistSubtypes</code> attributes for the corresponding cascade types.</p>
</div>
</div>
<div class="sect2">
<h3 id="updatable-entity-view-delete-cascading-orphan-removal"><a class="anchor" href="#updatable-entity-view-delete-cascading-orphan-removal"></a>Cascading deletes and orphan removal</h3>
<div class="paragraph">
<p>Delete cascading and orphan removal have the same semantics as in JPA.
If you delete an entity A that refers to entity B through an attribute that defines delete cascading,
entity B is going to be deleted as well.
When removing a reference from entity A to entity B through an attribute that defines orphan removal, entity B is going to be deleted.
Orphan removal also implies delete cascading, so entity B is also deleted when deleting entity A.</p>
</div>
<div class="paragraph">
<p>Most JPA implementations only support cascading deletes and orphan removal for managed entities whereas DML statements for the entity types do not consider this configuration.
{projectname} respects the settings all the way, even for the removal by id action done via <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#remove(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.Object)">EntityViewManager.remove(EntityManager, Class, Object)</a>.
When an entity graph for an entity view type has an <em>arbitrary depth relationship</em>, {projectname} still has to do some entity data loading, but it tries to reduce the executed statements as much as possible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At some point, DML statements might be grouped together via Updatable CTEs for DBMS that support that. For more information about that, see <a href="https://github.com/Blazebit/blaze-persistence/issues/500" class="bare">https://github.com/Blazebit/blaze-persistence/issues/500</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable delete cascading for an attribute, the <code>CascadeType.DELETE</code> has to be added to the <code>cascade</code> attribute of a <code>@UpdatableMapping</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    @UpdatableMapping(cascade = { CascadeType.DELETE })
    Person getOwner();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When deleting a <code>Cat</code> like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">entityViewManager.remove(entityManager, CatUpdateView.class, catId);</pre>
</div>
</div>
<div class="paragraph">
<p>the owner is going to be deleted along with the <code>Cat</code>. The delete cascading even works for attributes that are only defined to do delete cascading in the entity.
Assuming <code>Cat</code> does not have the <em>arbitrary depth relationship</em> <code>kittens</code>, the removal might trigger the following <em>logical</em> JPQL statements.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE Cat(nickNames) cat WHERE cat.id = :catId
DELETE Cat cat WHERE cat.id = :catId RETURNING owner.id
DELETE Person person WHERE person.id = :ownerId</pre>
</div>
</div>
<div class="paragraph">
<p>First, the cascading delete enabled collections like e.g. the <code>nickNames</code> collection is deleted.
Then the <code>Cat</code> is deleted and while doing that, the ids of the *ToOne relations with enabled cascading deletes like e.g. the <em>owner&#8217;s id</em> are returned.
For DBMS not supporting the <code>RETURNING</code> clause for DML statements, a <code>SELECT</code> statement is issued before the <code>DELETE</code> to extract the ids of the *ToOne relations.
Finally, the cascading deletes for the *ToOne relations are done e.g. the <code>Person</code> is deleted.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A future strategy for deletion might facilitate temporary tables if the DBMS supports it rather than selecting. For more information see <a href="https://github.com/Blazebit/blaze-persistence/issues/220" class="bare">https://github.com/Blazebit/blaze-persistence/issues/220</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the entity type for an updatable entity view uses delete cascading or orphan removal for an attribute, an updatable mapping for that attribute must use these configurations as well.
So if the entity type uses delete cascading for the <code>owner</code> of <code>Cat</code>, it would be an error to omit the delete cascading configuration.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@UpdatableEntityView
@EntityView(Cat.class)
interface CatUpdateView {
    @IdMapping
    Long getId();

    @UpdatableMapping(cascade = { }) <i class="conum" data-value="1"></i><b>(1)</b>
    Person getOwner();
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Can&#8217;t omit delete cascading if entity attribute uses delete cascading</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same goes for orphan removal and the idea behind this is, that it makes delete cascading and orphan removal configurations visible in every updatable view, thus making it less surprising.
It would make no sense to allow disabling delete cascading or orphan removal configurations because then the entity flush strategy would produce different results than the query flush strategy.
Obviously the other way around i.e. enabling delete cascading or orphan removal if the entity attribute does not use these configurations, is very valid.
Sometimes there are cases where delete cascading or orphan removal shouldn&#8217;t be done which means the cascading can&#8217;t be configured on the entity type attributes.
This where {projectname} entity views show their strength as they allow to control these configurations on a per-use case basis.</p>
</div>
</div>
<div class="sect2">
<h3 id="conversion-support"><a class="anchor" href="#conversion-support"></a>Conversion support</h3>
<div class="paragraph">
<p>As explained in the beginning, the vision for updatable entity views is to support the modelling of use case specific write models.
Although most of the data that is generally updatable is mostly loaded once when starting a <em>conversation</em> it is rarely necessary to make it updatable right away.
Some use cases might require only a subset of the data to be updatable, while others require a different subset.
To support modelling this appropriately it is possible to convert between entity views types.</p>
</div>
<div class="paragraph">
<p>Imagine the following model for illustration purposes.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@EntityView(Cat.class)
interface KittenView {
    @IdMapping
    Long getId();
}

@EntityView(Cat.class)
interface CatBaseView extends KittenView {
    PersonView getOwner();

    Set&lt;KittenView&gt; getKittens();
}

@UpdatableEntityView
@EntityView(Cat.class)
interface CatOwnerUpdateView extends CatBaseView {
    @UpdatableMapping
    PersonView getOwner();
    void setOwner(PersonView owner);
}

@UpdatableEntityView
@EntityView(Cat.class)
interface CatKittenUpdateView extends CatBaseView {
    @UpdatableMapping
    Set&lt;KittenView&gt; getKittens();
}</pre>
</div>
</div>
<div class="paragraph">
<p>When navigating to the detail UI for a <code>Cat</code> the <code>CatBaseView</code> would be loaded.
If the UI had a special action to initiate a transfer to a different owner, doing that action would lead to the conversion of the <code>CatBaseView</code> to the <code>CatOwnerUpdateView</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatBaseView catBaseView = //...
CatOwnerUpdateView catOwnerUpdate = entityViewManager.convert(CatOwnerUpdateView.class, catBaseView);</pre>
</div>
</div>
<div class="paragraph">
<p>After setting the new owner and flushing the changes via <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#update(javax.persistence.EntityManager,%20java.lang.Object)">EntityViewManager.update(EntityManager, Object)</a>
the view is converted back to the base view by invoking <a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#convert(java.lang.Class,%20java.lang.Object,%20com.blazebit.persistence.view.ConvertOption&#8230;&#8203;)">EntityViewManager.convert(Class, Object, ConvertOption&#8230;&#8203;)</a> again.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CatOwnerUpdateView catOwnerUpdate = //...
catBaseView = entityViewManager.convert(CatBaseView.class, catBaseView);</pre>
</div>
</div>
<div class="paragraph">
<p>When initiating the kitten update action the conversion would be done to <code>CatKittenUpdateView</code>.</p>
</div>
<div class="paragraph">
<p>Keep in mind that most UIs do not necessarily work this way and that the added complexity might not be beneficial in all cases.
Although this mechanism enables a clear separation for use cases, it might just as well be the case, that use cases are so small that it is better to have just a single write model.
In some special cases like e.g. when simply changing a status of an object, it might not even be necessary to have an explicit write model.
For such cases it is often more appropriate to have a specialized service method.</p>
</div>
<div class="paragraph">
<p>Note that internally, the conversion feature is used for converting successfully persisted creatable entity views to their context specific declaration type.</p>
</div>
<div class="paragraph">
<p>There are of course other possible use cases for this feature like e.g. conversion from a <em>more detailed</em> view to a view containing only a subset of the information,
though it is recommended to query the view with the subset of information rather than querying more if possible/practical to not do unnecessary data loading.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-04 13:32:35 KST
</div>
</div>
</body>
</html>