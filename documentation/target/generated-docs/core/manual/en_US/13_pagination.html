<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pagination</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#pagination">Pagination</a>
<ul class="sectlevel2">
<li><a href="#pagination-under-the-hood">Under the hood</a></li>
<li><a href="#anchor-offset-pagination">Offset pagination</a></li>
<li><a href="#anchor-keyset-pagination">Keyset pagination</a></li>
<li><a href="#anchor-navigate-entity-page">Navigate to entity page</a></li>
<li><a href="#pagination-limitations">Limitations</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="pagination"><a class="anchor" href="#pagination"></a>Pagination</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pagination is often used to make large data sets consumable. It requires an ordered set of elements/rows to be able to deterministically split the data into pages.
Imagine the following ordered data set</p>
</div>
<div class="imageblock">
  <div class="content">
        <img src="images/diag-f483c03175a48593dea1cac3c31c7f79.png" alt="diag f483c03175a48593dea1cac3c31c7f79" width="1090" height="98">
  </div>
</div>
<div class="paragraph">
<p>If we split it up into pages of the size of 5 elements we get 6 pages and the last one only containing 1 element</p>
</div>
<div class="imageblock">
  <div class="content">
        <img src="images/diag-4c8b83ab63944d674ba8c39498440fe5.png" alt="diag 4c8b83ab63944d674ba8c39498440fe5" width="470" height="238">
  </div>
</div>
<div class="paragraph">
<p>{projectname} provides two ways to do pagination.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conventional pagination via <a href="{core_jdoc}/persistence/LimitBuilder.html#setFirstResult(int)"><code>setFirstResult()</code></a> and <a href="{core_jdoc}/persistence/LimitBuilder.html#setMaxResults(int)"><code>setMaxResults()</code></a></p>
</li>
<li>
<p>Extended pagination support via the <a href="{core_jdoc}/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a> API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Conventional pagination in JPA only works on the main query which is also possible with {projectname}.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; secondCat = cbf.create(em, Cat.class)
    .orderByAsc("id")
    .setFirstResult(1)
    .setMaxResults(1)
    .getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
ORDER BY cat.id ASC NULLS LAST
--LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="paragraph">
<p>In addition to that, offset pagination for subqueries is also possible.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; secondCat = cbf.create(em, Cat.class)
    .fetch("kittens")
    .where("id").in()
        .from(Cat.class, "subCat")
        .select("subCat.id")
        .orderByAsc("id")
        .setFirstResult(1)
        .setMaxResults(1)
    .end()
    .getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.kittens kittens_1
WHERE cat.id IN LIMIT((                 <i class="conum" data-value="1"></i><b>(1)</b>
    SELECT subCat.id
    FROM Cat cat
    ORDER BY cat.id ASC NULLS LAST
),1 ,1) --LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uses the <a href="#limit-function"><code>LIMIT</code> function</a> to apply a <code>LIMIT</code>/<code>OFFSET</code> clause on the subquery</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The extended pagination support comes via the criteria builder&#8217;s <a href="{core_jdoc}/persistence/FullQueryBuilder.html#page(int,%20int)"><code>page()</code></a> methods which come in three flavours:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/FullQueryBuilder.html#page(int,%20int)"><code>page(int firstResult, int maxResults)</code></a></dt>
<dd>
<p>Performs <a href="#anchor-offset-pagination">offset pagination</a> by skipping <code>firstResult</code> elements and from there on, show <code>maxResults</code> elements.</p>
</dd>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/FullQueryBuilder.html#page(com.blazebit.persistence.KeysetPage,%20int,%20int)"><code>page(KeysetPage keysetPage, int firstResult, int maxResults)</code></a></dt>
<dd>
<p>Performs <a href="#anchor-keyset-pagination">keyset pagination</a> if possible and falls back to offset pagination otherwise.</p>
</dd>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/FullQueryBuilder.html#page(java.lang.Object,%20int)"><code>page(Object entityId, int maxResults)</code></a></dt>
<dd>
<p>Navigates to the <a href="#anchor-navigate-entity-page">page containing the entity</a> with the given <code>entityId</code>. Falls back to the first page if no entity for the id exists.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="pagination-under-the-hood"><a class="anchor" href="#pagination-under-the-hood"></a>Under the hood</h3>
<div class="paragraph">
<p>In {projectname} we have followed a more involved approach for implementing pagination than plainly using JPA standard
methods like <code>javax.persistence.Query.setMaxResults()</code> or <code>javax.persistence.Query.setFirstResult()</code> to steer the result set
dimensions. This is due to deficiencies in some JPA providers when it comes to handling paginated queries containing
join fetches for collections.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, when using fetch joins for collections with Hibernate, all results are fetched instead of only the selected page.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The approach used in {projectname} consists of up to three queries executed consecutively:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <strong>count query</strong> is used to fetch the total element count which is needed to populate <code>com.blazebit.persistence.PagedList.getTotalSize()</code> and
<code>com.blazebit.persistence.PagedList.getTotalPages()</code>. If this query returns 0, no further queries are executed.</p>
</li>
<li>
<p>The <strong>ID query</strong> is used to fetch the entity ids that are contained in the target page. In this step, the previously
mentioned <code>javax.persistence.Query.setMaxResults()</code> and <code>javax.persistence.Query.setFirstResult()</code> are used to select the
target ID set. Only selecting the IDs allows to omit all fetch joins, especially collection joins that might trigger inefficient jpa provider
strategies. The <strong>ID query</strong> is omitted if no collection fetch joins are done, because in that case JPA providers tend to do the right thing when paginating directly.</p>
</li>
<li>
<p>Finally, the <strong>object query</strong> is used to fetch the entities as described by the original query specified by the user.
This query uses an <code>IN</code> predicate for the ID set retrieved in the previous step to restrict the fetched entities to the target
page.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In a future version it might be possible to combine queries or disable the count query. For more information on that see <a href="https://github.com/Blazebit/blaze-persistence/issues/248">#248</a>,
<a href="https://github.com/Blazebit/blaze-persistence/issues/249">#249</a> and <a href="https://github.com/Blazebit/blaze-persistence/issues/255">#255</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can inspect the query strings by using <a href="{core_jdoc}/persistence/PaginatedCriteriaBuilder.html#getPageCountQueryString()"><code>getPageCountQueryString()</code></a>,
<a href="{core_jdoc}/persistence/PaginatedCriteriaBuilder.html#getPageIdQueryString()"><code>getPageIdQueryString()</code></a> and <a href="{core_jdoc}/persistence/Queryable.html#getQueryString()"><code>getQueryString()</code></a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="anchor-offset-pagination"><a class="anchor" href="#anchor-offset-pagination"></a>Offset pagination</h3>
<div class="paragraph">
<p>As already laid out in the <a href="#pagination">introduction</a>, pagination works on an ordered set of elements/rows.
Offset pagination basically looks at the ordered set from left to right and counts elements until the count reaches <code>firstResult</code>.
From that point on elements are collected until <code>maxResults</code> of elements have been collected or no more elements are available.</p>
</div>
<div class="paragraph">
<p>This basically means that the <code>OFFSET</code> i.e. <code>firstResult</code> part forces a DBMS to actually determine an element/row is visible for a transaction and then <em>ignore</em>/<em>skip</em> it.
The bigger the <code>firstResult</code> value, the more resources the DBMS has to waste for <em>skipping</em> elements/rows.
This essentially means that when employing offset pagination, accessing the latter pages will become more and more expensive.
In order for this approach to be actually usable with larger data sets, a DBMS index that can be used for the ordering is required to avoid constantly loading and sorting data.
In addition to that, the DBMS should have enough RAM to keep the index fully in-memory to avoid costly disk fetches.</p>
</div>
<div class="paragraph">
<p>Although offset pagination works in every case, it should be avoided if possible because of the performance implications.
As you will see in the <a href="#anchor-keyset-pagination">keyset pagination part</a> there is a more efficient approach to pagination that almost uses the same API.</p>
</div>
<div class="paragraph">
<p>The following example illustrates the usage and what happens behind the scenes</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">PagedList&lt;Cat&gt; page2 = cbf.create(em, Cat.class)
    .fetch("kittens")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(5, 5)
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Executes the following queries</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(*)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <strong>ID query</strong> is necessary because of the join fetched collection <code>kittens</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id
FROM Cat cat
ORDER BY cat.id ASC NULLS LAST
--LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.kittens kittens_1
WHERE cat.id IN :idParams
ORDER BY cat.id ASC NULLS LAST</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-keyset-pagination"><a class="anchor" href="#anchor-keyset-pagination"></a>Keyset pagination</h3>
<div class="paragraph">
<p>Keyset pagination is a way to efficiently paginate or scroll through a large data set by querying for elements that come before or after a reference point.
The idea of a keyset is, that every tuple can be uniquely identified by that keyset. So a keyset essentially is a reference point of a tuple in a data set ordered by keysets.
Keyset pagination in contrast to offset pagination makes efficient use of the ordering property of the data set.
By remembering the highest and lowest keysets of a page, it is possible to query the previous and next pages efficiently.</p>
</div>
<div class="paragraph">
<p>A keyset in terms of query results consists of the values of the <code>ORDER BY</code> expressions of a tuple.
In order to satisfy the uniqueness constraint, it is generally a good idea to use an entity&#8217;s id as last expression in the <code>ORDER BY</code> clause.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently the entity id is the <strong>only</strong> possible expression that satisfies the uniqueness constraint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Keyset pagination just like offset pagination requires index support on the DBMS side to work efficiently. A range-scan enabled index like provided by a b-tree index is required for keyset pagination to work best.
In contrast to offset pagination, an index does not have to be traversed like a list in order to <em>ignore</em>/<em>skip</em> a certain amount of elements/rows. Instead, a DBMS can make use of the structure of the index
and traverse it in <code>O(log N)</code> as compared to <code>O(N)</code> to get to the <code>firstResult</code>. This characteristic makes keyset pagination especially useful for accessing latter pages.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t allow too many different sort combinations as every combination requires a custom index to work efficiently.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the obvious requirements for keyset pagination to work, is the need for a reference point i.e. a keyset from which point on the next or previous elements should be queried.</p>
</div>
<div class="paragraph">
<p>The API in {projectname} tries to allow making use of keyset pagination in a transparent and easy manner without compromises.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// In the beginning we don't have a keyset page
KeysetPage oldPage = null;
PagedList&lt;Cat&gt; page2 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(oldPage, 5, 5) <i class="conum" data-value="1"></i><b>(1)</b>
    .getResultList();

// Query the next page with the keyset page of page2
PagedList&lt;Cat&gt; page3 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(page2.getKeysetPage(), 10, 5) <i class="conum" data-value="2"></i><b>(2)</b>
    .getResultList();

// Query the previous page with the keyset page of page2
PagedList&lt;Cat&gt; page1 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(page2.getKeysetPage(), 0, 5) <i class="conum" data-value="3"></i><b>(3)</b>
    .getResultList();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The oldPage in this case is <code>null</code>, so internally it falls back to offset pagination</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When querying the <em>next</em> page of <code>page2</code>, it can use the <a href="{core_jdoc}/persistence/KeysetPage.html#getHighest()">upper bound</a> of the <a href="{core_jdoc}/persistence/PagedList.html#getKeysetPage()">keyset page</a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>When querying the <em>previous</em> page of <code>page2</code>, it can use the <a href="{core_jdoc}/persistence/KeysetPage.html#getLowest()">lower bound</a> of the <a href="{core_jdoc}/persistence/PagedList.html#getKeysetPage()">keyset page</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since we are not fetching any collections, the ID query is avoided. For brevity, we skip the count query.
So let&#8217;s look at the object queries generated</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat, cat.id <i class="conum" data-value="1"></i><b>(1)</b>
FROM Cat cat
ORDER BY cat.birthday ASC NULLS LAST, cat.id ASC NULLS LAST
--LIMIT 5 OFFSET 5</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The expression <code>cat.id</code> is for constructing the keyset and contains all expressions of the <code>ORDER BY</code> clause</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see, nothing fancy, except for the additional select that is used for extracting the keyset.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat, cat.id
FROM Cat cat
WHERE cat.birthday &gt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &gt; :_keysetParameter_1
)
ORDER BY cat.birthday ASC NULLS LAST, cat.id ASC NULLS LAST
--LIMIT 5</pre>
</div>
</div>
<div class="paragraph">
<p>This time the query made efficient use of the keyset by filtering out elements/rows that come before the reference point</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat, cat.id
FROM Cat cat
WHERE cat.birthday &lt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &lt; :_keysetParameter_1
)
ORDER BY cat.birthday DESC NULLS FIRST, cat.id DESC NULLS FIRST
--LIMIT 5</pre>
</div>
</div>
<div class="paragraph">
<p>Before the query filtered out elements/rows that came <strong>before</strong> the reference point, this time it does the opposite. It filters out elements/rows coming <strong>after</strong> the reference point.
Another interesting thing to notice, the ordering was reversed too. This has the effect that the DBMS can traverse the index backwards and essentially is how keyset pagination works.
The ordering is reversed again in-memory, so you don&#8217;t notice anything of these details.</p>
</div>
<div class="paragraph">
<p>Note that in the following situations, the implementation automatically falls back to offset pagination</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The keyset is invalid i.e. it is <code>null</code></p>
</li>
<li>
<p>The ordering of the query changed</p>
</li>
<li>
<p>The page to navigate to is arbitrary i.e. not the next or previous page of a <code>keysetPage</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To be able to make use of keyset pagination either via the <a href="{core_jdoc}/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a> API or the <a href="#keyset-pagination-support">manual keyset filter API</a>,
the <a href="{core_jdoc}/persistence/KeysetPage.html"><code>KeysetPage</code></a> or the respective <a href="{core_jdoc}/persistence/Keyset.html"><code>Keyset</code></a> elements have to be preserved across page requests.
Applications that can retain state between requests(i.e. via a session) can just preserve the <code>KeysetPage</code> object itself. Applications that try to avoid server side state have to serialize and deserialize the state somehow.</p>
</div>
<div class="paragraph">
<p>Since the keyset state is available through <a href="{core_jdoc}/persistence/Keyset.html#getTuple()">getter methods</a>, it shouldn&#8217;t be too hard to do the serialization and deserialization.
When implementing a custom <code>Keyset</code>, the <code>equals()</code> and <code>hashCode()</code> contracts have to make use of just the tuple. A custom <code>KeysetPage</code> implementation has to provide access to the lowest and highest  keysets,
as well as the <code>firstResult</code> and <code>maxResults</code> values used for querying that page.</p>
</div>
<div class="paragraph">
<p>Beware that keyset pagination isn&#8217;t perfect. If entries can be <em>prepended</em> relative to the current keyset/reference point,
it might happen that the page number calculation becomes wrong over time. Most of the time this is negligible as it kind of gives the illusion that the user works on a snapshot of the data.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-navigate-entity-page"><a class="anchor" href="#anchor-navigate-entity-page"></a>Navigate to entity page</h3>
<div class="paragraph">
<p>The navigation to the page on which an entity with a specific id is involves finding out the position of the entity.
{projectname} offers a custom function named <a href="#page-position"><code>PAGE_POSITION</code></a> which determines the absolute position of an entity in an ordered set.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat knownCat = //...
PagedList&lt;Cat&gt; page3 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page((Object) knownCat.getId(), 3) <i class="conum" data-value="1"></i><b>(1)</b>
    .getResultList();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If your id type is a primitive <code>int</code>, you must cast to <code>Object</code> or <code>Integer</code> to use the right method</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(*), FUNCTION('PAGE_POSITION',(
    SELECT _page_position_cat.id
    FROM Cat _page_position_cat
    GROUP BY _page_position_cat.id, _page_position_cat.birthday
    ORDER BY _page_position_cat.birthday DESC NULLS FIRST, _page_position_cat.id DESC NULLS FIRST
), :_entityPagePositionParameter)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The count query contains the page position determination logic. It essentially passes an ID query as subquery to the <code>PAGE_POSITION</code> function.
The concrete SQL implementation of that function depends on the DBMS, but they all follow the same main idea.
Wrap the ID query and count the row numbers. In another wrapper around that, filter for the row with the matching id and return the row number as position.
The element/row number of the first element on that page is calculated and used as <code>firstResult</code>. Apart from this speciality, the rest of the query is just like a normal offset pagination query.</p>
</div>
</div>
<div class="sect2">
<h3 id="pagination-limitations"><a class="anchor" href="#pagination-limitations"></a>Limitations</h3>
<div class="paragraph">
<p>Since the <code>PaginatedCriteriaBuilder</code> API can only paginate on entity level, the results are implicitly grouped by id and therefore distinct.
Because of that, the usage of <code>distinct()</code> or <code>groupBy()</code> on a <code>PaginatedCriteriaBuilder</code> is disallowed and will result in an exception.</p>
</div>
<div class="paragraph">
<p>If these limitations are not ok for your use case, you will have to implement a custom pagination strategy via <code>setFirstResult()</code> and <code>setMaxResults()</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>