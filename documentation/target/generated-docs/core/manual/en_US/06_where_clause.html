<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Where clause</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#where-clause">Where clause</a>
<ul class="sectlevel2">
<li><a href="#keyset-pagination-support">Keyset pagination support</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="where-clause"><a class="anchor" href="#where-clause"></a>Where clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>WHERE</code> clause has mostly been described already in the <a href="#Predicate Builder">[Predicate Builder]</a> chapter.
The clause is applicable to all statement types, but <a href="#implicit-joins">implicit joins</a> are only possible in <code>SELECT</code> statements,
therefore it is advised to move relation access to an exists subquery in DML statements like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.update(em, Cat.class, "c")
    .setExpression("age", "age + 1")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("subCat.id").eqExpression("c.id")
        .where("subCat.father.name").like().value("Bill%").noEscape()
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>Which will roughly render to the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat c
SET c.age = c.age + 1
WHERE EXISTS(
    SELECT 1
    FROM Cat subCat
    LEFT JOIN subCat.father father_1
    WHERE subCat.id = c.id
      AND father_1.name LIKE :param_1
)</pre>
</div>
</div>
<div class="sect2">
<h3 id="keyset-pagination-support"><a class="anchor" href="#keyset-pagination-support"></a>Keyset pagination support</h3>
<div class="paragraph">
<p>Keyset pagination or scrolling/filtering is way to efficiently paginate or scroll through a large data set.
The idea of a keyset is, that every tuple can be uniquely identified by that keyset. Pagination only makes sense when the tuples in a data set are ordered
and keyset pagination in contrast to offset pagination makes efficient use of the ordering property of the data set.
By remembering the highest and lowest keysets of a page, it is possible to query the previous and next pages efficiently.</p>
</div>
<div class="paragraph">
<p>Apart from the <a href="#keyset-pagination">transparent keyset pagination support</a>, it is also possible to implement keyset scrolling/filtering manually.
A keyset consists of the values of the <code>ORDER BY</code> expressions of a tuple and the last expression must uniquely identify a tuple.
The id of an entity is not only a good candidate in general for the last expression, but also currently the only possible expression to satisfy this constraint.</p>
</div>
<div class="paragraph">
<p>The following query will order cats by their birthday and second by their id.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .orderByAsc("cat.birthday")
    .orderByAsc("cat.id")</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
ORDER BY cat.birthday ASC, cat.id ASC</pre>
</div>
</div>
<div class="sect3">
<h4 id="positional-keyset-pagination"><a class="anchor" href="#positional-keyset-pagination"></a>Positional keyset pagination</h4>
<div class="paragraph">
<p>In order to receive only the first 10 cats you would do</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; cats = cb.setMaxResults(10)
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>In order to receive the next cats after the last seen cat (highest keyset) with positional keyset elements you would do</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat lastCat = cats.get(cats.size() - 1);
List&lt;Cat&gt; nextCats = cb.afterKeyset(lastCat.getBirthday(), lastCat.getId())
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>which roughly translates to the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.birthday &gt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &gt; :_keysetParameter_1
)
ORDER BY cat.birthday ASC NULLS LAST, cat.id ASC NULLS LAST</pre>
</div>
</div>
<div class="paragraph">
<p>The positional part roughly means that the keyset element as passed into <a href="{core_jdoc}/persistence/KeysetQueryBuilder.html#afterKeyset(java.io.Serializable&#8230;&#8203;)">afterKeyset()</a>
or <a href="{core_jdoc}/persistence/KeysetQueryBuilder.html#beforeKeyset(java.io.Serializable&#8230;&#8203;)">beforeKeyset()</a> must match the order of the corresponding <code>ORDER BY</code> expressions.</p>
</div>
<div class="paragraph">
<p>Note that this is in general much more efficient than an <code>OFFSET</code> based paging/scrolling because this approach can <em>scroll</em> to the next and previous page in <code>O(log n)</code>,
whereas using <code>OFFSET</code> results in a complexity of <code>O(n)</code>, thus making it harder to get to latter pages in big data sets.
This is due to how a keyset paginated query can efficiently traverse an index on the DBMS side. Using <code>OFFSET</code> paging requires actually counting tuples that should be skipped which is less efficient.</p>
</div>
<div class="paragraph">
<p>Similarly to scrolling to a page that comes <a href="{core_jdoc}/persistence/KeysetQueryBuilder.html#afterKeyset(java.io.Serializable&#8230;&#8203;)">after a keyset</a>,
it is also possible to scroll to a page that comes <a href="{core_jdoc}/persistence/KeysetQueryBuilder.html#beforeKeyset(java.io.Serializable&#8230;&#8203;)">before a keyset</a></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat firstCat = nextCats.get(0);
List&lt;Cat&gt; previousCats = cb.beforeKeyset(firstCat.getBirthday(), firstCat.getId())
    .getResultList();
// cats and previousCats are equal</pre>
</div>
</div>
<div class="paragraph">
<p>but this time the JPQL looks differently</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.birthday &lt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &lt; :_keysetParameter_1
)
ORDER BY cat.birthday DESC NULLS FIRST, cat.id DESC NULLS FIRST</pre>
</div>
</div>
<div class="paragraph">
<p>This is how keyset pagination works, but still, the DBMS can use the same index as before. This time, it just traverses it backwards!</p>
</div>
</div>
<div class="sect3">
<h4 id="expression-based-keyset-pagination"><a class="anchor" href="#expression-based-keyset-pagination"></a>Expression based keyset pagination</h4>
<div class="paragraph">
<p>This is just like <a href="#positional-keyset-pagination">positional keyset pagination</a> but instead of relying on the order of keyset elements and <code>ORDER BY</code> expressions,
this makes use of the <a href="{core_jdoc}/persistence/KeysetBuilder.html"><code>KeysetBuilder</code></a> which matches by the expression.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat firstCat = nextCats.get(0);
List&lt;Cat&gt; previousCats = cb.beforeKeyset()
        .with("cat.birthday", firstCat.getBirthday())
        .with("cat.id", firstCat.getId())
    .end()
    .getResultList();
// cats and previousCats are equal</pre>
</div>
</div>
<div class="paragraph">
<p>This results in the same JPQL as seen above. It&#8217;s a matter of taste which style to choose.</p>
</div>
</div>
<div class="sect3">
<h4 id="keyset-page-based-keyset-pagination"><a class="anchor" href="#keyset-page-based-keyset-pagination"></a>Keyset page based keyset pagination</h4>
<div class="paragraph">
<p>When using the <a href="#keyset-pagination">transparent keyset pagination support</a> through the <a href="{core_jdoc}/persistence/FullQueryBuilder.html#page(int,%20int)"><code>PaginatedQueryBuilder</code></a> API
with <a href="{core_jdoc}/persistence/PaginatedCriteriaBuilder.html#withKeysetExtraction(boolean)">keyset extraction</a> it is possible to get access to an extracted
<a href="{core_jdoc}/persistence/PagedList.html#getKeysetPage()"><code>KeysetPage</code></a> and thus also to the <a href="{core_jdoc}/persistence/KeysetPage.html#getHighest()">highest</a>
and <a href="{core_jdoc}/persistence/KeysetPage.html#getLowest()">lowest</a> keysets.</p>
</div>
<div class="paragraph">
<p>These keysets can also be used for paging/scrolling although when already having access to a <a href="{core_jdoc}/persistence/KeysetPage.html"><code>KeysetPage</code></a> it might be better to use the
<a href="{core_jdoc}/persistence/PaginatedQueryBuilder.html"><code>PaginatedQueryBuilder</code></a> API instead.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-04 13:32:35 KST
</div>
</div>
</body>
</html>