<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Query Language</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#query-language">Query Language</a>
<ul class="sectlevel2">
<li><a href="#statement-types">Statement types</a></li>
<li><a href="#select-statement">Select statement</a></li>
<li><a href="#insert-statement">Insert statement</a></li>
<li><a href="#update-statement">Update statement</a></li>
<li><a href="#delete-statement">Delete statement</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="query-language"><a class="anchor" href="#query-language"></a>Query Language</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Note that this is just a specification work in progress that is not yet implemented.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The query language that can be used with {projectname} is a super-set of JPQL and we like to call it JPQL.next.
It adds support for various more modern DBMS features that depending on the native DBMS support pass through as expected or are emulated.
This is a reference overview of the language, the specific features and the support matrices are in other sections that are referenced.</p>
</div>
<div class="sect2">
<h3 id="statement-types"><a class="anchor" href="#statement-types"></a>Statement types</h3>
<div class="paragraph">
<p>The normally known statement types are extended to support CTEs and set operations as well as the LIMIT and OFFSET clause.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint antlr4 lang-antlr4">statement
    : with_clause? simple_statement ;
simple_statement
    : select_statement
    | from_statement
    | insert_statement
    | update_statement
    | delete_statement
    ;
with_clause : WITH RECURSIVE? cteEntityName '(' attributeName (',' attributeName)* ')' AS '(' simple_statement ')' ;</pre>
</div>
</div>
<div class="paragraph">
<p>When defining a CTE, the <em>cteEntityName</em> must be a valid JPA entity name or FQN for a JPA entity class.
All <em>columns</em> of the defined attributes of the JPA entity class that is used for a CTE have to be declared as attributes within the parenthesis.
The statement in a CTE must provide the same amount of select expressions or returning attributes that bind by position to the declared CTE attributes.
If a CTE intends to reference itself for recursive processing, the RECURSIVE keyword must be added.</p>
</div>
</div>
<div class="sect2">
<h3 id="select-statement"><a class="anchor" href="#select-statement"></a>Select statement</h3>
<div class="paragraph">
<p>A from statement is essentially like a select statement, but without the select part in the top level queries.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint antlr4 lang-antlr4">from_statement      : from_specification window_clause? order_by_clause? ;
select_statement    : query_expression window_clause? order_by_clause? ;
subquery            : subquery_expression order_by_clause_subquery? ;

from_query_expression
    : ( from_specification | '(' from_query_expression ')' ) from_query_set_operator_expression* ;
query_expression
    : ( query_specification | '(' query_expression ')' ) set_operator_expression* ;
subquery_expression
    : ( subquery_specification | '(' subquery_expression ')' ) subquery_set_operator_expression* ;

set_operator
    : ( UNION | EXCEPT | INTERSECT ) ALL?;
from_query_set_operator_expression
    : set_operator ( from_specification | ( '(' from_query_expression ')' ) ) ;
set_operator_expression
    : set_operator ( query_specification | ( '(' query_expression ')' ) ) ;
subquery_set_operator_expression
    : set_operator ( subquery_specification | ( '(' subquery_expression ')' ) ) ;

query_specification
    : SELECT DISTINCT? select_list_elem ( ',' select_list_elem )*
      from_specification
    ;</pre>
</div>
</div>
<div class="paragraph">
<p>Select statements can use set operators which will work on the scalar results as expected.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint antlr4 lang-antlr4">from_specification :
      FROM from_elements
      keyset_clause?
      where_clause?
      group_by_clause?
      having_clause?
    ;
subquery_specification
    : SELECT DISTINCT? select_list_elem ( ',' select_list_elem )*
      FROM from_elements_subquery
      keyset_clause?
      where_clause?
      group_by_clause?
      having_clause?
    ;

keyset_clause
    : ( BEFORE | AFTER ) ( parameter_expression | '(' parameter_or_literal_expression ( ',' parameter_or_literal_expression )* ')' )
    ;

select_list_elem        : expression ( AS selectAlias )? ;
from_elements           : from_element ( ',' from_element )*
from_elements_subquery  : from_element_subquery ( ',' from_element_subquery )*

from_element            : from_group | ( '(' from_group ')' )
from_element_subquery   : from_group_subquery | ( '(' from_group_subquery ')' )

from_group              : from_item fetch_join*
from_group_subquery     : from_item_subquery join*

from_item
    : values_from_item
    | (
        entityName
      | ( OLD | NEW ) '(' entityName ')'
//      | '(' select_statement ')'
    ) ( AS? entityAlias )?
    ;
from_item_subquery
    : values_from_item
    | (
        entityName
      | ( OLD | NEW ) '(' entityName ')'
      | identification_variable '.' association_path_expression
//      | '(' select_statement ')'
    ) ( AS? entityAlias )?
    ;

// The syntax with a value count is the usual way to go
// But the inline value definition is for ad-hoc queries
values_from_item
    : (
        simpleTypeName '(' valueCount VALUES ')'
      | entityName ( '.' idName )? '(' valueCount VALUES ')'
      | simpleTypeName '(' VALUES values_item ( ',' values_item  )* ')'
      | entityName ( '.' idName )? '(' VALUES values_item ( ',' values_item  )* ')'
    ) AS? entityAlias
    ;

values_item : '(' literal_expression ( ',' literal_expression )* ')' ;
join_spec   : DEFAULT? ( INNER? | ( LEFT | RIGHT ) OUTER? ) JOIN ;

join        : join_spec from_join_element ON condition_expression ;
fetch_join  : join_spec FETCH? from_join_element ON condition_expression ;

from_join_element
    : (
        from_element
      | identification_variable '.' association_path_expression
//      | '(' select_statement ')'
      ) ( AS? entityAlias )?
    ;

where_clause    : ( WHERE condition_expression )? ;
group_by_clause : GROUP BY group_by_item ( ',' group_by_item )* ;
group_by_item
    : expression
//    | rollup_spec
//    | cube_spec
//    | grouping_sets_spec
//    | grand_total
    ;
having_clause   : HAVING condition_expression ;

order_by_clause
    : ORDER BY order_by_expression ( ',' order_by_expression )*
    ( LIMIT expression )?
    ( OFFSET expression | JUMP TO PAGE CONTAINING parameterExpression )?
    ;
order_by_clause_subquery
    : ORDER BY order_by_expression ( ',' order_by_expression )*
    (
       LIMIT expression
     | ( LIMIT expression )? OFFSET expression
    )
    ;
order_by_expression
    : expression ( ASC | DESC )? ( NULLS ( FIRST | LAST ) )?

window_clause
    : WINDOW windowName AS '(' window_definition ')' ( ',' windowName AS '(' window_definition ')' )*
    ;

window_definition
    : existing_window_name?
      ( PARTITION BY expression ( ',' expression )* )?
      ( ORDER BY order_by_expression ( ',' order_by_expression )* )?
      ( ( RANGE | ROWS ) ( frame_start | BETWEEN frame_spec AND frame_spec ) )?
    ;

frame_spec
    : UNBOUNDED PRECEDING
    | literalValue PRECEDING
    | CURRENT ROW
    | literalValue FOLLOWING
    | UNBOUNDED FOLLOWING
    ;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="insert-statement"><a class="anchor" href="#insert-statement"></a>Insert statement</h3>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint antlr4 lang-antlr4">dml_attribute
    : attributePath
    | 'KEY' '(' attributeName ')'
    | 'INDEX' '(' attributeName ')'
    ;
insert_statement : INSERT INTO entityName ( '.' collectionName )? '(' dml_attribute (',' dml_attribute)* ')' select_statement returning_clause? ;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="update-statement"><a class="anchor" href="#update-statement"></a>Update statement</h3>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint antlr4 lang-antlr4">update_statement : UPDATE entityName ( '(' collectionName ')' )? ( AS? entityAlias )? SET dml_attribute '=' expression ( ',' dml_attribute '=' expression )* where_clause? returning_clause?</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delete-statement"><a class="anchor" href="#delete-statement"></a>Delete statement</h3>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint antlr4 lang-antlr4">delete_statement : DELETE FROM? entityName ( '(' collectionName ')' )? ( AS? entityAlias )? where_clause? returning_clause?</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>