<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CTEs</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#ctes">CTEs</a>
<ul class="sectlevel2">
<li><a href="#cte-implementation-notes">Implementation notes</a></li>
<li><a href="#recursive-ctes">Recursive CTEs</a></li>
<li><a href="#updatable-ctes">Updatable CTEs</a></li>
<li><a href="#anchor-ctes-dbms-compatibility">DBMS compatibility</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="ctes"><a class="anchor" href="#ctes"></a>CTEs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>CTEs provide a way to introduce statements into a larger query that can be reused. CTEs are like temporary entity sets/tables that are created for the scope of the query and then deleted.
A CTE normally contains a <code>SELECT</code> statement, but depending on the DBMS support, can also contain <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This feature is currently only supported with Hibernate!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Before you can define a query for a CTE, the structure of the it has to be defined in a similar manner as an entity is defined.
Don&#8217;t forget to also add it to your persistence.xml so that the JPA provider can discover it.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@CTE    // from com.blazebit.persistence
@Entity // from javax.persistence
public class MyCte {

    private Long id;

    @Id // from javax.persistence
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The difference to a normal entity is that in addition to that, the <code>CTE</code> annotation is applied which treats it like a view i.e. no DDL is generated for it.
A CTE can be defined on a top level query builder by using the <a href="{core_jdoc}/persistence/CTEBuilder.html#with(java.lang.Class)"><code>with(Class&lt;?&gt;)</code></a> method.
The created CTE builder has to be finished by calling <code>end()</code> on it.</p>
</div>
<div class="paragraph">
<p>All attributes of a CTE must be bound to expressions with <a href="{core_jdoc}/SelectBaseCTECriteriaBuilder.html#bind(java.lang.String)"><code>bind()</code></a> like in the following.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;MyCte&gt; cb = cbf.create(em, MyCte.class)
    .with(MyCte.class)
        .from(Cat.class, "cat")
        .bind("id").select("cat.id")
    .end();</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since you can map columns multiple times in the CTE entity, it is sufficient to make sure that all columns have values bound through attribute bindings. If a column is left out, you will get an exception.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see from the example, the API tries to look as much as possible like the CTE syntax as defined in the SQL-99 standard.
As for all advanced features, the query string returned by <a href="{core_jdoc}/persistence/Queryable.html#getQueryString()"><code>getQueryString()</code></a> only represents the <em>logical structure</em> of the whole query in a syntax that might be used one day by JPA providers to support this feature natively.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    SELECT cat.id FROM Cat cat
)
SELECT myCte FROM MyCte myCte</pre>
</div>
</div>
<div class="sect2">
<h3 id="cte-implementation-notes"><a class="anchor" href="#cte-implementation-notes"></a>Implementation notes</h3>
<div class="paragraph">
<p>Currently the CTE support is only implemented for Hibernate because of the deep integration that is needed for it to work.
The integration with the persistence provider happens in the implementation of <a href="{core_jdoc}/persistence/spi/ExtendedQuerySupport.html"><code>com.blazebit.persistence.spi.ExtendedQuerySupport</code></a>
which tries to focus on the minimal necessary methods needed for the integration to work.</p>
</div>
<div class="paragraph">
<p>In case of Hibernate, a CTE entity class is treated as if <code>org.hibernate.annotations.Subselect</code> was annotated.
Hibernate generally generates from clause elements of the form <code>( select * from MyCTE )</code> for <code>Subselect</code> entities which we replace simply by the name of the CTE.</p>
</div>
<div class="paragraph">
<p>The current implementation extracts the SQL from various template JPQL queries that are created behind the scenes.
After applying different transformations on the SQL and merging it together to a single SQL query, the new SQL replaces is used in a special JPQL query object.
The special JPQL query object is what you can finally execute. It will make use of the SQL query that was created before.</p>
</div>
<div class="paragraph">
<p>Every CTE will result in a separate JPQL query behind the scenes from which the SQL is extracted.
The SQL from the main query, together with the SQLs from the CTEs are put together to form the full SQL query.
It is that SQL, the special JPQL query receives for later execution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In order to support the <code>org.hibernate.FetchMode.SUBSELECT</code> this library ships with custom implementations of <code>org.hibernate.persister.collection.CollectionPersister</code>.
Custom persister implementations should be made aware of CTEs in a similar fashion to be able to make use of the fetch mode.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="recursive-ctes"><a class="anchor" href="#recursive-ctes"></a>Recursive CTEs</h3>
<div class="paragraph">
<p>CTEs not only provide a way to extract subqueries or use subqueries in the FROM clause, but also to implement recursive queries.</p>
</div>
<div class="paragraph">
<p>A recursive CTE is normally composed of two parts, a base query(non-recursive query) and a recursive query connected with the <strong>SET</strong> operator <code>UNION</code> or <code>UNION ALL</code>.
The recursive part is allowed to refer to the CTE itself.</p>
</div>
<div class="paragraph">
<p>A recursive CTE is normally evaluated in iterations</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The base query is evaluated and the result put into a temporary work set/table</p>
</li>
<li>
<p>The recursive query operates on the work set/table data and replaces it with the newly produced data</p>
</li>
<li>
<p>When the recursive query didn&#8217;t produce data, the recursion and thus the query is finished</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following illustrates how the ancestor hierarchy of an entity can be retrieved.</p>
</div>
<div class="listingblock">
<div class="title">CTE structure definition</div>
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@CTE    // from com.blazebit.persistence
@Entity // from javax.persistence
public class CatCte {

    private Long id;
    private Cat ancestor;

    @Id // from javax.persistence
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    @ManyToOne
    public Cat getAncestor() { return ancestor; }
    public void setAncestor(Cat ancestor) { this.ancestor = ancestor; }
}</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Recursive query</div>
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;CatCte&gt; cb = cbf.create(em, CatCte.class)
    .withRecursive(CatCte.class)
        .from(Cat.class, "cat") <i class="conum" data-value="1"></i><b>(1)</b>
        .bind("id").select("cat.id")
        .bind("ancestor").select("cat.ancestor")
        .where("id").eq(someCatId)
    .unionAll()
        .from(Cat.class, "cat")
        .from(CatCte.class, "parentCat") <i class="conum" data-value="2"></i><b>(2)</b>
        .bind("id").select("cat.id")
        .bind("ancestor").select("cat.ancestor")
        .where("id").eqExpression("parentCat.ancestor.id") <i class="conum" data-value="3"></i><b>(3)</b>
    .end();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start with the non-recursive query and just bind the cat attributes of the desired cat</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We refer to the CTE itself in the recursive query to be able to <em>join</em> data with data of the previous iteration</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Only <em>join</em> the cats that are an <code>ancestor</code> of the cats from the previous iteration</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Logical representation</div>
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH RECURSIVE CatCte(id, ancestor) AS(
    SELECT cat.id, cat.ancestor FROM Cat cat WHERE cat.id = :someCatId
    UNION ALL
    SELECT cat.id, cat.ancestor FROM Cat cat, CatCte parentCat WHERE cat.id = parentCat.ancestor.id
)
SELECT catCte FROM CatCte catCte</pre>
</div>
</div>
<div class="paragraph">
<p>This will return all the ancestors of the Cat with an id equal to <strong>someCatId</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="updatable-ctes"><a class="anchor" href="#updatable-ctes"></a>Updatable CTEs</h3>
<div class="paragraph">
<p>An updatable CTE is like a normal CTE, but the data comes from returned attributes of a DML statement.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At this point, only PostgreSQL and DB2 support this feature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can start an updatable CTE with the <a href="{core_jdoc}/persistence/CTEBuilder.html#withReturning(java.lang.Class)"><code>withReturning()</code></a> method and subsequently decide the DML statement type.
The query builder for the DML statement provides a <a href="{core_jdoc}/persistence/ReturningBuilder.html#returning(java.lang.String,%20java.lang.String)"><code>returning()</code></a> method for binding attributes of the DML statement to a CTE attribute.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;MyCte&gt; cb = cbf.create(em, MyCte.class)
    .withReturning(MyCte.class)
        .delete(Cat.class, "cat")
        .where("cat.name").isNull()
        .returning("id", "cat.id")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    DELETE FROM Cat cat
    WHERE cat.name IS NULL
    RETURNING id
)
SELECT myCte FROM MyCte myCte</pre>
</div>
</div>
<div class="paragraph">
<p>The query deletes cats with a <code>NULL</code> name. For every deleted cat, a temporary <code>MyCte</code> entity with the cat&#8217;s id bound is created. Finally the deleted cats are queried through <code>MyCte</code>.</p>
</div>
<div class="paragraph">
<p>As you can imagine, this can be used to define very efficient data pipelines.</p>
</div>
<div class="paragraph">
<p>One problem with updatable CTEs that might come up is, that you might want to query an entity in one CTE, while also wanting to do a modification in a different CTE.
Since the visibility of changes that are done in updatable CTEs might differ from one to another DBMS, {projectname} offers a way to resolve this special case.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .withReturning(MyCte.class)
        .delete(Cat.class, "cat")
        .where("cat.name").isNull()
        .returning("id", "cat.id")
    .end()
    .from(Cat.class, "theCat");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    DELETE FROM Cat cat
    WHERE cat.name IS NULL
    RETURNING id
)
SELECT theCat FROM Cat theCat</pre>
</div>
</div>
<div class="paragraph">
<p>Although the CTE <code>MyCte</code> is never used, it is still executed. Depending on the DBMS you are on, the <code>SELECT</code> statement will return the state before or after the <code>DELETE</code> statement happened.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Multiple updatable CTEs for the same entity in a single query are not supported.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to make the <code>SELECT</code> statement portable, {projectname} provides a way to qualify a <code>FROM</code> clause element to use the <em>old</em> or <em>new</em> state i.e. before or after modifications happened.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .withReturning(MyCte.class)
        .delete(Cat.class, "cat")
        .where("cat.name").isNull()
        .returning("id", "cat.id")
    .end()
    .fromOld(Cat.class, "theCat");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    DELETE FROM Cat cat
    WHERE cat.name IS NULL
    RETURNING id
)
SELECT theCat FROM OLD(Cat) theCat</pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="{core_jdoc}/persistence/FromBuilder.html#fromOld(java.lang.Class,%20java.lang.String)"><code>fromOld()</code></a> method qualifies the <code>FROM</code> element in the query as <em>old</em>.
In the same way does <a href="{core_jdoc}/persistence/FromBuilder.html#fromNew(java.lang.Class,%20java.lang.String)"><code>fromNew()</code></a> qualify the <code>FROM</code> element as <em>new</em>.</p>
</div>
<div class="paragraph">
<p>In general, we advise you to rethink how you do the querying when having a need for this feature. It should only be used as a last resort.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-ctes-dbms-compatibility"><a class="anchor" href="#anchor-ctes-dbms-compatibility"></a>DBMS compatibility</h3>
<div class="paragraph">
<p>Currently there is no emulation implemented for databases that do not support CTEs natively.
CTEs are well tested with <strong>PostgreSQL</strong>, <strong>DB2</strong>, <strong>Oracle</strong> and <strong>Microsoft SQL Server</strong>. Many of the basic features work with <strong>H2</strong>, but beware that H2 support for CTEs is still experimental.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
We do not recommend using CTEs with H2 because of some very serious limitations. Using a CTE in an <code>IN</code> predicate or using <code>LIMIT</code> within the CTE have proven to produce wrong results. You also can&#8217;t have multiple CTEs per query.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DB2 does not support JOINs in the recursive part of a CTE: <a href="https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/com.ibm.db2z10.doc.codes/src/tpc/n345.dita" class="bare">https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/com.ibm.db2z10.doc.codes/src/tpc/n345.dita</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>CTEs in DML</em> are uses of a CTE where the top level statement is a DML. In contrast, <em>Updatable CTEs</em> are CTEs that <strong>contain</strong> DML and get their values from a <code>RETURNING</code> clause of the DML.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>DBMS</strong></th>
<th class="tableblock halign-left valign-top">Normal CTEs</th>
<th class="tableblock halign-left valign-top">Recursive CTEs</th>
<th class="tableblock halign-left valign-top">CTEs in DML</th>
<th class="tableblock halign-left valign-top">Updatable CTEs</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL Server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-04 13:32:35 KST
</div>
</div>
</body>
</html>