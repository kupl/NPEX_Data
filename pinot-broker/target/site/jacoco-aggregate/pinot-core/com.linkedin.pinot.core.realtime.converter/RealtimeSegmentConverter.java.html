<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RealtimeSegmentConverter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-broker</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.realtime.converter</a> &gt; <span class="el_source">RealtimeSegmentConverter.java</span></div><h1>RealtimeSegmentConverter.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.realtime.converter;

import com.linkedin.pinot.common.config.ColumnPartitionConfig;
import com.linkedin.pinot.common.config.SegmentPartitionConfig;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.data.StarTreeIndexSpec;
import com.linkedin.pinot.common.data.TimeFieldSpec;
import com.linkedin.pinot.common.data.TimeGranularitySpec;
import com.linkedin.pinot.common.metrics.ServerGauge;
import com.linkedin.pinot.common.metrics.ServerMetrics;
import com.linkedin.pinot.core.indexsegment.generator.SegmentGeneratorConfig;
import com.linkedin.pinot.core.indexsegment.generator.SegmentVersion;
import com.linkedin.pinot.core.io.compression.ChunkCompressorFactory;
import com.linkedin.pinot.core.realtime.converter.stats.RealtimeSegmentSegmentCreationDataSource;
import com.linkedin.pinot.core.realtime.impl.RealtimeSegmentImpl;
import com.linkedin.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;


public class RealtimeSegmentConverter {

  private RealtimeSegmentImpl realtimeSegmentImpl;
  private String outputPath;
  private Schema dataSchema;
  private String tableName;
  private String segmentName;
  private String sortedColumn;
  private List&lt;String&gt; invertedIndexColumns;
  private List&lt;String&gt; noDictionaryColumns;
  private StarTreeIndexSpec starTreeIndexSpec;

  public RealtimeSegmentConverter(RealtimeSegmentImpl realtimeSegment, String outputPath, Schema schema,
      String tableName, String segmentName, String sortedColumn, List&lt;String&gt; invertedIndexColumns,
<span class="fc" id="L55">      List&lt;String&gt; noDictionaryColumns, StarTreeIndexSpec starTreeIndexSpec) {</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    if (new File(outputPath).exists()) {</span>
<span class="nc" id="L57">      throw new IllegalAccessError(&quot;path already exists:&quot; + outputPath);</span>
    }
<span class="fc" id="L59">    TimeFieldSpec original = schema.getTimeFieldSpec();</span>
    // Use outgoing granularity for creating segment
<span class="fc" id="L61">    TimeGranularitySpec outgoing = original.getOutgoingGranularitySpec();</span>

<span class="fc" id="L63">    TimeFieldSpec newTimeSpec = new TimeFieldSpec(outgoing);</span>

<span class="fc" id="L65">    Schema newSchema = new Schema();</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">    for (String dimension : schema.getDimensionNames()) {</span>
<span class="fc" id="L67">      newSchema.addField(schema.getFieldSpecFor(dimension));</span>
<span class="fc" id="L68">    }</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    for (String metric : schema.getMetricNames()) {</span>
<span class="fc" id="L70">      newSchema.addField(schema.getFieldSpecFor(metric));</span>
<span class="fc" id="L71">    }</span>

<span class="fc" id="L73">    newSchema.addField(newTimeSpec);</span>
<span class="fc" id="L74">    this.realtimeSegmentImpl = realtimeSegment;</span>
<span class="fc" id="L75">    this.outputPath = outputPath;</span>
<span class="fc" id="L76">    this.invertedIndexColumns = new ArrayList&lt;&gt;(invertedIndexColumns);</span>
<span class="pc bpc" id="L77" title="3 of 4 branches missed.">    if (sortedColumn != null &amp;&amp; this.invertedIndexColumns.contains(sortedColumn)) {</span>
<span class="nc" id="L78">      this.invertedIndexColumns.remove(sortedColumn);</span>
    }
<span class="fc" id="L80">    this.dataSchema = newSchema;</span>
<span class="fc" id="L81">    this.sortedColumn = sortedColumn;</span>
<span class="fc" id="L82">    this.tableName = tableName;</span>
<span class="fc" id="L83">    this.segmentName = segmentName;</span>
<span class="fc" id="L84">    this.noDictionaryColumns = noDictionaryColumns;</span>
<span class="fc" id="L85">    this.starTreeIndexSpec = starTreeIndexSpec;</span>
<span class="fc" id="L86">  }</span>

  public RealtimeSegmentConverter(RealtimeSegmentImpl realtimeSegment, String outputPath, Schema schema,
      String tableName, String segmentName, String sortedColumn) {
<span class="fc" id="L90">    this(realtimeSegment, outputPath, schema, tableName, segmentName, sortedColumn, new ArrayList&lt;String&gt;(),</span>
        new ArrayList&lt;String&gt;(), null/*StarTreeIndexSpec*/);
<span class="fc" id="L92">  }</span>

  public void build(@Nullable SegmentVersion segmentVersion, ServerMetrics serverMetrics) throws Exception {
    // lets create a record reader
    RealtimeSegmentRecordReader reader;
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">    if (sortedColumn == null) {</span>
<span class="fc" id="L98">      reader = new RealtimeSegmentRecordReader(realtimeSegmentImpl, dataSchema);</span>
    } else {
<span class="nc" id="L100">      reader = new RealtimeSegmentRecordReader(realtimeSegmentImpl, dataSchema, sortedColumn);</span>
    }
<span class="fc" id="L102">    SegmentGeneratorConfig genConfig = new SegmentGeneratorConfig(dataSchema);</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">    if (invertedIndexColumns != null &amp;&amp; !invertedIndexColumns.isEmpty()) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      for (String column : invertedIndexColumns) {</span>
<span class="nc" id="L105">        genConfig.createInvertedIndexForColumn(column);</span>
<span class="nc" id="L106">      }</span>
    }
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">    if (noDictionaryColumns != null) {</span>
<span class="fc" id="L109">      genConfig.setRawIndexCreationColumns(noDictionaryColumns);</span>
<span class="fc" id="L110">      Map&lt;String, ChunkCompressorFactory.CompressionType&gt; columnToCompressionType = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">      for (String column : noDictionaryColumns) {</span>
<span class="nc" id="L112">        FieldSpec fieldSpec = dataSchema.getFieldSpecFor(column);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (fieldSpec.getFieldType().equals(FieldSpec.FieldType.METRIC)) {</span>
<span class="nc" id="L114">          columnToCompressionType.put(column, ChunkCompressorFactory.CompressionType.PASS_THROUGH);</span>
        }
<span class="nc" id="L116">      }</span>
<span class="fc" id="L117">      genConfig.setRawIndexCompressionType(columnToCompressionType);</span>
    }

    // Presence of the spec enables star tree generation.
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">    if (starTreeIndexSpec != null) {</span>
<span class="nc" id="L122">      genConfig.enableStarTreeIndex(starTreeIndexSpec);</span>
    }

<span class="fc" id="L125">    genConfig.setTimeColumnName(dataSchema.getTimeFieldSpec().getOutgoingTimeColumnName());</span>
<span class="fc" id="L126">    genConfig.setSegmentTimeUnit(dataSchema.getTimeFieldSpec().getOutgoingGranularitySpec().getTimeType());</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">    if (segmentVersion != null) {</span>
<span class="fc" id="L128">      genConfig.setSegmentVersion(segmentVersion);</span>
    }
<span class="fc" id="L130">    genConfig.setTableName(tableName);</span>
<span class="fc" id="L131">    genConfig.setOutDir(outputPath);</span>
<span class="fc" id="L132">    genConfig.setSegmentName(segmentName);</span>
<span class="fc" id="L133">    SegmentPartitionConfig segmentPartitionConfig = realtimeSegmentImpl.getSegmentPartitionConfig();</span>
<span class="fc" id="L134">    genConfig.setSegmentPartitionConfig(segmentPartitionConfig);</span>
<span class="fc" id="L135">    final SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();</span>
<span class="fc" id="L136">    RealtimeSegmentSegmentCreationDataSource dataSource =</span>
        new RealtimeSegmentSegmentCreationDataSource(realtimeSegmentImpl, reader, dataSchema);
<span class="fc" id="L138">    driver.init(genConfig, dataSource);</span>
<span class="fc" id="L139">    driver.build();</span>

<span class="pc bpc" id="L141" title="3 of 4 branches missed.">    if (segmentPartitionConfig != null &amp;&amp; segmentPartitionConfig.getColumnPartitionMap() != null) {</span>
<span class="nc" id="L142">      Map&lt;String, ColumnPartitionConfig&gt; columnPartitionMap = segmentPartitionConfig.getColumnPartitionMap();</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      for (String columnName : columnPartitionMap.keySet()) {</span>
<span class="nc" id="L144">        int partitionRangeWidth = driver.getSegmentStats().getColumnProfileFor(columnName).getPartitionRangeWidth();</span>
<span class="nc" id="L145">        serverMetrics.addValueToTableGauge(tableName, ServerGauge.REALTIME_SEGMENT_PARTITION_WIDTH, partitionRangeWidth);</span>
<span class="nc" id="L146">      }</span>
    }
<span class="fc" id="L148">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>