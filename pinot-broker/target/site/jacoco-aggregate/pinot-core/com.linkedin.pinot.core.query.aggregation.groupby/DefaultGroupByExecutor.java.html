<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DefaultGroupByExecutor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-broker</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.query.aggregation.groupby</a> &gt; <span class="el_source">DefaultGroupByExecutor.java</span></div><h1>DefaultGroupByExecutor.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.query.aggregation.groupby;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.request.GroupBy;
import com.linkedin.pinot.core.common.BlockMetadata;
import com.linkedin.pinot.core.common.BlockValSet;
import com.linkedin.pinot.core.operator.blocks.TransformBlock;
import com.linkedin.pinot.core.plan.DocIdSetPlanNode;
import com.linkedin.pinot.core.query.aggregation.AggregationFunctionContext;
import com.linkedin.pinot.core.query.aggregation.function.AggregationFunction;
import com.linkedin.pinot.core.query.aggregation.function.AggregationFunctionFactory;
import java.util.List;
import javax.annotation.Nonnull;


/**
 * This class implements group by aggregation.
 * It is optimized for performance, and uses the best possible algorithm/data-structure
 * for a given query based on the following parameters:
 * - Maximum number of group keys possible.
 * - Single/Multi valued columns.
 */
public class DefaultGroupByExecutor implements GroupByExecutor {
  // Thread local (reusable) array for dict id to group key mapping.
<span class="fc" id="L41">  private static final ThreadLocal&lt;int[]&gt; THREAD_LOCAL_DICT_ID_TO_GROUP_KEY = new ThreadLocal&lt;int[]&gt;() {</span>
    @Override
    protected int[] initialValue() {
<span class="fc" id="L44">      return new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];</span>
    }
  };

  // Thread local (reusable) array for dict id to MV group key mapping.
<span class="fc" id="L49">  private static final ThreadLocal&lt;int[][]&gt; THREAD_LOCAL_DICT_ID_TO_MV_GROUP_KEY = new ThreadLocal&lt;int[][]&gt;() {</span>
    @Override
    protected int[][] initialValue() {
<span class="fc" id="L52">      return new int[DocIdSetPlanNode.MAX_DOC_PER_CALL][];</span>
    }
  };

  private static final double GROUP_BY_TRIM_FACTOR = 0.9;
  private final int _numAggrFunc;
  private final int _maxInitialResultHolderCapacity;
  private final int _numGroupsLimit;
  private final AggregationFunctionContext[] _aggrFunctionContexts;
  private final AggregationFunction[] _aggregationFunctions;

  private GroupKeyGenerator _groupKeyGenerator;
  private GroupByResultHolder[] _resultHolderArray;
  private final String[] _groupByColumns;

  private int[] _docIdToSVGroupKey;
  private int[][] _docIdToMVGroupKey;

<span class="fc" id="L70">  private boolean _hasMVGroupByColumns = false;</span>
<span class="fc" id="L71">  private boolean _inited = false; // boolean to ensure init() has been called.</span>
<span class="fc" id="L72">  private boolean _finished = false; // boolean to ensure that finish() has been called.</span>
<span class="fc" id="L73">  private boolean _groupByInited = false; // boolean for lazy creation of group-key generator etc.</span>
<span class="fc" id="L74">  private boolean _hasColumnsWithoutDictionary = false;</span>

  /**
   * Constructor for the class.
   * @param aggrFunctionContexts Array of aggregation functions
   * @param groupBy Group by from broker request
   * @param maxInitialResultHolderCapacity Maximum initial capacity for the result holder
   * @param numGroupsLimit Limit on number of aggregation groups returned in the result
   */
  public DefaultGroupByExecutor(@Nonnull AggregationFunctionContext[] aggrFunctionContexts, GroupBy groupBy,
<span class="fc" id="L84">      int maxInitialResultHolderCapacity, int numGroupsLimit) {</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">    Preconditions.checkNotNull(aggrFunctionContexts.length &gt; 0);</span>
<span class="fc" id="L86">    Preconditions.checkNotNull(groupBy);</span>

<span class="fc" id="L88">    List&lt;String&gt; groupByColumns = groupBy.getColumns();</span>
<span class="fc" id="L89">    List&lt;String&gt; groupByExpressions = groupBy.getExpressions();</span>

    // Expressions contain simple group by columns (ie without any transform) as well.
<span class="pc bpc" id="L92" title="2 of 4 branches missed.">    if (groupByExpressions != null &amp;&amp; !groupByExpressions.isEmpty()) {</span>
<span class="fc" id="L93">      _groupByColumns = groupByExpressions.toArray(new String[groupByExpressions.size()]);</span>
    } else {
<span class="nc" id="L95">      _groupByColumns = groupByColumns.toArray(new String[groupByColumns.size()]);</span>
    }

<span class="fc" id="L98">    _numAggrFunc = aggrFunctionContexts.length;</span>
<span class="fc" id="L99">    _maxInitialResultHolderCapacity = maxInitialResultHolderCapacity;</span>

    // TODO: revisit the trim factor. Usually the factor should be 5-10, and based on the 'TOP' limit.
    // When results are trimmed, drop bottom 10% of groups.
<span class="fc" id="L103">    _numGroupsLimit = (int) (GROUP_BY_TRIM_FACTOR * numGroupsLimit);</span>

<span class="fc" id="L105">    _aggrFunctionContexts = aggrFunctionContexts;</span>
<span class="fc" id="L106">    _aggregationFunctions = new AggregationFunction[_numAggrFunc];</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">    for (int i = 0; i &lt; _numAggrFunc; i++) {</span>
<span class="fc" id="L108">      _aggregationFunctions[i] = aggrFunctionContexts[i].getAggregationFunction();</span>
    }
<span class="fc" id="L110">  }</span>

  /**
   * {@inheritDoc}
   * No-op for this implementation of GroupKeyGenerator. Most initialization happens lazily
   * in process(), as a transform is required to initialize group key generator, etc.
   */
  @Override
  public void init() {
    // Returned if already initialized.
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    if (_inited) {</span>
<span class="nc" id="L121">      return;</span>
    }

<span class="fc" id="L124">    _inited = true;</span>
<span class="fc" id="L125">  }</span>

  /**
   * Process the provided set of docId's to perform the requested aggregation-group-by-operation.
   *
   * @param transformBlock Transform block to process
   */
  @Override
  public void process(TransformBlock transformBlock) {
<span class="fc" id="L134">    Preconditions.checkState(_inited,</span>
        &quot;Method 'process' cannot be called before 'init' for class &quot; + getClass().getName());

<span class="fc" id="L137">    initGroupBy(transformBlock);</span>
<span class="fc" id="L138">    generateGroupKeysForBlock(transformBlock);</span>
<span class="fc" id="L139">    int capacityNeeded = _groupKeyGenerator.getCurrentGroupKeyUpperBound();</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">    for (int i = 0; i &lt; _numAggrFunc; i++) {</span>
<span class="fc" id="L142">      _resultHolderArray[i].ensureCapacity(capacityNeeded);</span>
<span class="fc" id="L143">      aggregateColumn(transformBlock, _aggrFunctionContexts[i], _resultHolderArray[i]);</span>

      // Result holder limits the max number of group keys (default 100k), if the number of groups
      // exceeds beyond that limit, groups with lower values (as per sort order) are trimmed.
      // Once result holder trims those groups, the group key generator needs to purge them.
<span class="fc bfc" id="L148" title="All 2 branches covered.">      if (!_hasColumnsWithoutDictionary) {</span>
<span class="fc" id="L149">        int[] trimmedKeys = _resultHolderArray[i].trimResults();</span>
<span class="fc" id="L150">        _groupKeyGenerator.purgeKeys(trimmedKeys);</span>
      }
    }
<span class="fc" id="L153">  }</span>

  /**
   * Helper method to perform aggregation for a given column.
   *
   * @param transformBlock Transform block to aggregate
   * @param aggrFuncContext Aggregation function context
   * @param resultHolder Holder for results of aggregation
   */
  @SuppressWarnings(&quot;ConstantConditions&quot;)
  private void aggregateColumn(TransformBlock transformBlock, AggregationFunctionContext aggrFuncContext,
      GroupByResultHolder resultHolder) {
<span class="fc" id="L165">    AggregationFunction aggregationFunction = aggrFuncContext.getAggregationFunction();</span>
<span class="fc" id="L166">    String[] aggregationColumns = aggrFuncContext.getAggregationColumns();</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    Preconditions.checkState(aggregationColumns.length == 1);</span>
<span class="fc" id="L168">    int length = transformBlock.getNumDocs();</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">    if (!aggregationFunction.getName().equals(AggregationFunctionFactory.AggregationFunctionType.COUNT.getName())) {</span>
<span class="fc" id="L171">      BlockValSet blockValueSet = transformBlock.getBlockValueSet(aggregationColumns[0]);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">      if (_hasMVGroupByColumns) {</span>
<span class="fc" id="L173">        aggregationFunction.aggregateGroupByMV(length, _docIdToMVGroupKey, resultHolder, blockValueSet);</span>
      } else {
<span class="fc" id="L175">        aggregationFunction.aggregateGroupBySV(length, _docIdToSVGroupKey, resultHolder, blockValueSet);</span>
      }
<span class="fc" id="L177">    } else {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">      if (_hasMVGroupByColumns) {</span>
<span class="fc" id="L179">        aggregationFunction.aggregateGroupByMV(length, _docIdToMVGroupKey, resultHolder);</span>
      } else {
<span class="fc" id="L181">        aggregationFunction.aggregateGroupBySV(length, _docIdToSVGroupKey, resultHolder);</span>
      }
    }
<span class="fc" id="L184">  }</span>

  /**
   * {@inheritDoc}
   */
  @Override
  public void finish() {
<span class="fc" id="L191">    Preconditions.checkState(_inited,</span>
        &quot;Method 'finish' cannot be called before 'init' for class &quot; + getClass().getName());

<span class="fc" id="L194">    _finished = true;</span>
<span class="fc" id="L195">  }</span>

  /**
   * Return the final result of the aggregation-group-by operation.
   * This method should be called after all docIdSets have been 'processed'.
   *
   * @return Results of aggregation group by.
   */
  @Override
  public AggregationGroupByResult getResult() {
<span class="fc" id="L205">    Preconditions.checkState(_finished,</span>
        &quot;Method 'getResult' cannot be called before 'finish' for class &quot; + getClass().getName());

    // If group by was not initialized (in case of no transform blocks), return null.
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    if (!_groupByInited) {</span>
<span class="nc" id="L210">      return null;</span>
    }

<span class="fc" id="L213">    return new AggregationGroupByResult(_groupKeyGenerator, _aggregationFunctions, _resultHolderArray);</span>
  }

  /**
   * Generate group keys for the given docIdSet. For single valued columns, each docId has one group key,
   * but for multi-valued columns, each docId could have more than one group key.
   *
   * For SV keys: _docIdToSVGroupKey mapping is updated.
   * For MV keys: _docIdToMVGroupKey mapping is updated.
   *
   * @param transformBlock Transform block for which to generate group keys
   */
  private void generateGroupKeysForBlock(TransformBlock transformBlock) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">    if (_hasMVGroupByColumns) {</span>
<span class="fc" id="L227">      _groupKeyGenerator.generateKeysForBlock(transformBlock, _docIdToMVGroupKey);</span>
    } else {
<span class="fc" id="L229">      _groupKeyGenerator.generateKeysForBlock(transformBlock, _docIdToSVGroupKey);</span>
    }
<span class="fc" id="L231">  }</span>

  /**
   * Helper method to initialize result holder array.
   *
   * @param trimSize Trim size for group by keys
   * @param maxNumResults Maximum number of groups possible
   */
  private void initResultHolderArray(int trimSize, int maxNumResults) {
<span class="fc" id="L240">    _resultHolderArray = new GroupByResultHolder[_numAggrFunc];</span>
<span class="fc" id="L241">    int initialCapacity = Math.min(maxNumResults, _maxInitialResultHolderCapacity);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    for (int i = 0; i &lt; _numAggrFunc; i++) {</span>
<span class="fc" id="L243">      _resultHolderArray[i] = _aggrFunctionContexts[i].getAggregationFunction()</span>
          .createGroupByResultHolder(initialCapacity, maxNumResults, trimSize);
    }
<span class="fc" id="L246">  }</span>

  /**
   * Allocate storage for docId to group keys mapping.
   */
  private void initDocIdToGroupKeyMap() {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (_hasMVGroupByColumns) {</span>
      // TODO: Revisit block fetching of multi-valued columns
<span class="fc" id="L254">      _docIdToMVGroupKey = THREAD_LOCAL_DICT_ID_TO_MV_GROUP_KEY.get();</span>
    } else {
<span class="fc" id="L256">      _docIdToSVGroupKey = THREAD_LOCAL_DICT_ID_TO_GROUP_KEY.get();</span>
    }
<span class="fc" id="L258">  }</span>

  /**
   * Initializes the following:
   * &lt;p&gt; - Group key generator. &lt;/p&gt;
   * &lt;p&gt; - Result holders &lt;/p&gt;
   * &lt;p&gt; - Re-usable storage (eg docId to group key mapping) &lt;/p&gt;
   *
   * This is separate from init(), as this can only happen within process as transform block is
   * required to create group key generator.
   *
   * @param transformBlock Transform block to group by.
   */
  private void initGroupBy(TransformBlock transformBlock) {
<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (_groupByInited) {</span>
<span class="fc" id="L273">      return;</span>
    }

<span class="fc" id="L276">    FieldSpec.DataType dataType = null;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">    for (String groupByColumn : _groupByColumns) {</span>
<span class="fc" id="L278">      BlockMetadata metadata = transformBlock.getBlockMetadata(groupByColumn);</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">      if (!metadata.isSingleValue()) {</span>
<span class="fc" id="L281">        _hasMVGroupByColumns = true;</span>
      }

<span class="fc bfc" id="L284" title="All 2 branches covered.">      if (!metadata.hasDictionary()) {</span>
<span class="fc" id="L285">        _hasColumnsWithoutDictionary = true;</span>
      }

      // Used only for single group-by case, so ok to overwrite.
<span class="fc" id="L289">      dataType = metadata.getDataType();</span>
    }

<span class="fc bfc" id="L292" title="All 2 branches covered.">    if (_hasColumnsWithoutDictionary) {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">      if (_groupByColumns.length == 1) {</span>
<span class="fc" id="L294">        _groupKeyGenerator = new NoDictionarySingleColumnGroupKeyGenerator(_groupByColumns[0], dataType);</span>
      } else {
<span class="nc" id="L296">        _groupKeyGenerator = new NoDictionaryMultiColumnGroupKeyGenerator(transformBlock, _groupByColumns);</span>
      }
    } else {
<span class="fc" id="L299">      _groupKeyGenerator =</span>
          new DictionaryBasedGroupKeyGenerator(transformBlock, _groupByColumns, _maxInitialResultHolderCapacity);
    }

<span class="fc" id="L303">    int maxNumResults = _groupKeyGenerator.getGlobalGroupKeyUpperBound();</span>
<span class="fc" id="L304">    initResultHolderArray(_numGroupsLimit, maxNumResults);</span>
<span class="fc" id="L305">    initDocIdToGroupKeyMap();</span>
<span class="fc" id="L306">    _groupByInited = true;</span>
<span class="fc" id="L307">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>