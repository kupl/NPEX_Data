<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DataTableBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-broker</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.common.datatable</a> &gt; <span class="el_source">DataTableBuilder.java</span></div><h1>DataTableBuilder.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.common.datatable;

import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.request.AggregationInfo;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.request.Selection;
import com.linkedin.pinot.common.utils.DataSchema;
import com.linkedin.pinot.common.utils.DataTable;
import com.linkedin.pinot.core.query.aggregation.AggregationFunctionContext;
import com.linkedin.pinot.core.query.aggregation.function.AggregationFunction;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnull;


/**
 *
 * Datatable that holds data in a matrix form. The purpose of this class is to
 * provide a way to construct a datatable and ability to serialize and
 * deserialize.&lt;br&gt;
 * Why can't we use existing serialization/deserialization mechanism. Most
 * existing techniques protocol buffer, thrift, avro are optimized for
 * transporting a single record but Pinot transfers quite a lot of data from
 * server to broker during the scatter/gather operation. The cost of
 * serialization and deserialization directly impacts the performance. Most
 * ser/deser requires us to convert the primitives data types in objects like
 * Integer etc. This is waste of cpu resource and increase the payload size. We
 * optimize the data format for Pinot usecase. We can also support lazy
 * construction of obejcts. Infact we retain the bytes as it is and will be able
 * to lookup the a field directly within a byte buffer.&lt;br&gt;
 *
 * USAGE:
 *
 * Datatable is initialized with the schema of the table. Schema describes the
 * columnnames, their order and data type for each column.&lt;br&gt;
 * Each row must follow the same convention. We don't support MultiValue columns
 * for now. Format,
 * |VERSION,DATA_START_OFFSET,DICTIONARY_START_OFFSET,INDEX_START_OFFSET
 * ,METADATA_START_OFFSET | |&amp;lt;DATA&amp;gt; |
 *
 * |&amp;lt;DICTIONARY&amp;gt;|
 *
 *
 * |&amp;lt;METADATA&amp;gt;| Data contains the actual values written by the application We
 * first write the entire data in its raw byte format. For example if you data
 * type is Int, it will write 4 bytes. For most data types that are fixed width,
 * we just write the raw data. For special cases like String, we create a
 * dictionary. Dictionary will be never exposed to the user. All conversions
 * will be done internally. In future, we might decide dynamically if dictionary
 * creation is needed, for now we will always create dictionaries for string
 * columns. During deserialization we will always load the dictionary
 * first.Overall having dictionary allow us to convert data table into a fixed
 * width matrix and thus allowing look up and easy traversal.
 *
 *
 */
// TODO: potential optimizations:
// TODO:   1. Fix float size.
// TODO:   2. Use one dictionary for all columns (save space).
// TODO:   3. Given a data schema, write all values one by one instead of using rowId and colId to position (save time).
public class DataTableBuilder {
  private static final String COUNT_STAR = &quot;count_star&quot;;
  private final DataSchema _dataSchema;
  private final int[] _columnOffsets;
  private final int _rowSizeInBytes;
<span class="fc" id="L87">  private final Map&lt;String, Map&lt;String, Integer&gt;&gt; _dictionaryMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L88">  private final Map&lt;String, Map&lt;Integer, String&gt;&gt; _reverseDictionaryMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L89">  private final ByteArrayOutputStream _fixedSizeDataByteArrayOutputStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L90">  private final ByteArrayOutputStream _variableSizeDataByteArrayOutputStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L91">  private final DataOutputStream _variableSizeDataOutputStream =</span>
      new DataOutputStream(_variableSizeDataByteArrayOutputStream);

  private int _numRows;
  private ByteBuffer _currentRowDataByteBuffer;

<span class="fc" id="L97">  public DataTableBuilder(@Nonnull DataSchema dataSchema) {</span>
<span class="fc" id="L98">    _dataSchema = dataSchema;</span>
<span class="fc" id="L99">    _columnOffsets = new int[dataSchema.size()];</span>
<span class="fc" id="L100">    _rowSizeInBytes = DataTableUtils.computeColumnOffsets(dataSchema, _columnOffsets);</span>
<span class="fc" id="L101">  }</span>

  public void startRow() {
<span class="fc" id="L104">    _numRows++;</span>
<span class="fc" id="L105">    _currentRowDataByteBuffer = ByteBuffer.allocate(_rowSizeInBytes);</span>
<span class="fc" id="L106">  }</span>

  public void setColumn(int colId, boolean value) {
<span class="fc" id="L109">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (value) {</span>
<span class="fc" id="L111">      _currentRowDataByteBuffer.put((byte) 1);</span>
    } else {
<span class="fc" id="L113">      _currentRowDataByteBuffer.put((byte) 0);</span>
    }
<span class="fc" id="L115">  }</span>

  public void setColumn(int colId, byte value) {
<span class="fc" id="L118">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L119">    _currentRowDataByteBuffer.put(value);</span>
<span class="fc" id="L120">  }</span>

  public void setColumn(int colId, char value) {
<span class="fc" id="L123">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L124">    _currentRowDataByteBuffer.putChar(value);</span>
<span class="fc" id="L125">  }</span>

  public void setColumn(int colId, short value) {
<span class="fc" id="L128">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L129">    _currentRowDataByteBuffer.putShort(value);</span>
<span class="fc" id="L130">  }</span>

  public void setColumn(int colId, int value) {
<span class="fc" id="L133">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L134">    _currentRowDataByteBuffer.putInt(value);</span>
<span class="fc" id="L135">  }</span>

  public void setColumn(int colId, long value) {
<span class="fc" id="L138">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L139">    _currentRowDataByteBuffer.putLong(value);</span>
<span class="fc" id="L140">  }</span>

  public void setColumn(int colId, float value) {
<span class="fc" id="L143">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L144">    _currentRowDataByteBuffer.putFloat(value);</span>
<span class="fc" id="L145">  }</span>

  public void setColumn(int colId, double value) {
<span class="fc" id="L148">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L149">    _currentRowDataByteBuffer.putDouble(value);</span>
<span class="fc" id="L150">  }</span>

  public void setColumn(int colId, @Nonnull String value) {
<span class="fc" id="L153">    String columnName = _dataSchema.getColumnName(colId);</span>
<span class="fc" id="L154">    Map&lt;String, Integer&gt; dictionary = _dictionaryMap.get(columnName);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">    if (dictionary == null) {</span>
<span class="fc" id="L156">      dictionary = new HashMap&lt;&gt;();</span>
<span class="fc" id="L157">      _dictionaryMap.put(columnName, dictionary);</span>
<span class="fc" id="L158">      _reverseDictionaryMap.put(columnName, new HashMap&lt;Integer, String&gt;());</span>
    }

<span class="fc" id="L161">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L162">    Integer dictId = dictionary.get(value);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (dictId == null) {</span>
<span class="fc" id="L164">      dictId = dictionary.size();</span>
<span class="fc" id="L165">      dictionary.put(value, dictId);</span>
<span class="fc" id="L166">      _reverseDictionaryMap.get(columnName).put(dictId, value);</span>
    }
<span class="fc" id="L168">    _currentRowDataByteBuffer.putInt(dictId);</span>
<span class="fc" id="L169">  }</span>

  public void setColumn(int colId, @Nonnull Object value)
      throws IOException {
<span class="fc" id="L173">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L174">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L175">    byte[] bytes = ObjectCustomSerDe.serialize(value);</span>
<span class="fc" id="L176">    _currentRowDataByteBuffer.putInt(bytes.length);</span>
<span class="fc" id="L177">    _variableSizeDataOutputStream.writeInt(ObjectCustomSerDe.getObjectType(value).getValue());</span>
<span class="fc" id="L178">    _variableSizeDataByteArrayOutputStream.write(bytes);</span>
<span class="fc" id="L179">  }</span>

  public void setColumn(int colId, @Nonnull byte[] values) {
<span class="fc" id="L182">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L183">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L184">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">    for (byte value : values) {</span>
<span class="fc" id="L186">      _variableSizeDataByteArrayOutputStream.write(value);</span>
    }
<span class="fc" id="L188">  }</span>

  public void setColumn(int colId, @Nonnull char[] values)
      throws IOException {
<span class="fc" id="L192">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L193">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L194">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">    for (char value : values) {</span>
<span class="fc" id="L196">      _variableSizeDataOutputStream.writeChar(value);</span>
    }
<span class="fc" id="L198">  }</span>

  public void setColumn(int colId, @Nonnull short[] values)
      throws IOException {
<span class="fc" id="L202">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L203">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L204">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">    for (short value : values) {</span>
<span class="fc" id="L206">      _variableSizeDataOutputStream.writeShort(value);</span>
    }
<span class="fc" id="L208">  }</span>

  public void setColumn(int colId, @Nonnull int[] values)
      throws IOException {
<span class="fc" id="L212">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L213">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L214">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    for (int value : values) {</span>
<span class="fc" id="L216">      _variableSizeDataOutputStream.writeInt(value);</span>
    }
<span class="fc" id="L218">  }</span>

  public void setColumn(int colId, @Nonnull long[] values)
      throws IOException {
<span class="fc" id="L222">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L223">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L224">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">    for (long value : values) {</span>
<span class="fc" id="L226">      _variableSizeDataOutputStream.writeLong(value);</span>
    }
<span class="fc" id="L228">  }</span>

  public void setColumn(int colId, @Nonnull float[] values)
      throws IOException {
<span class="fc" id="L232">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L233">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L234">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    for (float value : values) {</span>
<span class="fc" id="L236">      _variableSizeDataOutputStream.writeFloat(value);</span>
    }
<span class="fc" id="L238">  }</span>

  public void setColumn(int colId, @Nonnull double[] values)
      throws IOException {
<span class="fc" id="L242">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L243">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L244">    _currentRowDataByteBuffer.putInt(values.length);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">    for (double value : values) {</span>
<span class="fc" id="L246">      _variableSizeDataOutputStream.writeDouble(value);</span>
    }
<span class="fc" id="L248">  }</span>

  public void setColumn(int colId, @Nonnull String[] values)
      throws IOException {
<span class="fc" id="L252">    _currentRowDataByteBuffer.position(_columnOffsets[colId]);</span>
<span class="fc" id="L253">    _currentRowDataByteBuffer.putInt(_variableSizeDataByteArrayOutputStream.size());</span>
<span class="fc" id="L254">    _currentRowDataByteBuffer.putInt(values.length);</span>

<span class="fc" id="L256">    String columnName = _dataSchema.getColumnName(colId);</span>
<span class="fc" id="L257">    Map&lt;String, Integer&gt; dictionary = _dictionaryMap.get(columnName);</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">    if (dictionary == null) {</span>
<span class="fc" id="L259">      dictionary = new HashMap&lt;&gt;();</span>
<span class="fc" id="L260">      _dictionaryMap.put(columnName, dictionary);</span>
<span class="fc" id="L261">      _reverseDictionaryMap.put(columnName, new HashMap&lt;Integer, String&gt;());</span>
    }

<span class="fc bfc" id="L264" title="All 2 branches covered.">    for (String value : values) {</span>
<span class="fc" id="L265">      Integer dictId = dictionary.get(value);</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">      if (dictId == null) {</span>
<span class="fc" id="L267">        dictId = dictionary.size();</span>
<span class="fc" id="L268">        dictionary.put(value, dictId);</span>
<span class="fc" id="L269">        _reverseDictionaryMap.get(columnName).put(dictId, value);</span>
      }
<span class="fc" id="L271">      _variableSizeDataOutputStream.writeInt(dictId);</span>
    }
<span class="fc" id="L273">  }</span>

  public void finishRow()
      throws IOException {
<span class="fc" id="L277">    _fixedSizeDataByteArrayOutputStream.write(_currentRowDataByteBuffer.array());</span>
<span class="fc" id="L278">  }</span>

  public DataTable build() {
<span class="fc" id="L281">    return new DataTableImplV2(_numRows, _dataSchema, _reverseDictionaryMap,</span>
        _fixedSizeDataByteArrayOutputStream.toByteArray(), _variableSizeDataByteArrayOutputStream.toByteArray());
  }

  /**
   * Build an empty data table based on the broker request.
   */
  public static DataTable buildEmptyDataTable(BrokerRequest brokerRequest)
      throws IOException {
    // Selection query.
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (brokerRequest.isSetSelections()) {</span>
<span class="nc" id="L292">      Selection selection = brokerRequest.getSelections();</span>
<span class="nc" id="L293">      List&lt;String&gt; selectionColumns = selection.getSelectionColumns();</span>
<span class="nc" id="L294">      int numSelectionColumns = selectionColumns.size();</span>
<span class="nc" id="L295">      FieldSpec.DataType[] dataTypes = new FieldSpec.DataType[numSelectionColumns];</span>
      // Use STRING data type as default for selection query.
<span class="nc" id="L297">      Arrays.fill(dataTypes, FieldSpec.DataType.STRING);</span>
<span class="nc" id="L298">      DataSchema dataSchema = new DataSchema(selectionColumns.toArray(new String[numSelectionColumns]), dataTypes);</span>
<span class="nc" id="L299">      return new DataTableBuilder(dataSchema).build();</span>
    }

    // Aggregation query.
<span class="nc" id="L303">    List&lt;AggregationInfo&gt; aggregationsInfo = brokerRequest.getAggregationsInfo();</span>
<span class="nc" id="L304">    int numAggregations = aggregationsInfo.size();</span>
<span class="nc" id="L305">    AggregationFunctionContext[] aggregationFunctionContexts = new AggregationFunctionContext[numAggregations];</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">    for (int i = 0; i &lt; numAggregations; i++) {</span>
<span class="nc" id="L307">      aggregationFunctionContexts[i] = AggregationFunctionContext.instantiate(aggregationsInfo.get(i));</span>
    }
<span class="nc bnc" id="L309" title="All 2 branches missed.">    if (brokerRequest.isSetGroupBy()) {</span>
      // Aggregation group-by query.

<span class="nc" id="L312">      String[] columnNames = new String[]{&quot;functionName&quot;, &quot;GroupByResultMap&quot;};</span>
<span class="nc" id="L313">      FieldSpec.DataType[] columnTypes = new FieldSpec.DataType[]{FieldSpec.DataType.STRING, FieldSpec.DataType.OBJECT};</span>

      // Build the data table.
<span class="nc" id="L316">      DataTableBuilder dataTableBuilder = new DataTableBuilder(new DataSchema(columnNames, columnTypes));</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">      for (int i = 0; i &lt; numAggregations; i++) {</span>
<span class="nc" id="L318">        dataTableBuilder.startRow();</span>
<span class="nc" id="L319">        dataTableBuilder.setColumn(0, aggregationFunctionContexts[i].getAggregationColumnName());</span>
<span class="nc" id="L320">        dataTableBuilder.setColumn(1, new HashMap&lt;String, Object&gt;());</span>
<span class="nc" id="L321">        dataTableBuilder.finishRow();</span>
      }
<span class="nc" id="L323">      return dataTableBuilder.build();</span>
    } else {
      // Aggregation only query.

<span class="nc" id="L327">      String[] aggregationColumnNames = new String[numAggregations];</span>
<span class="nc" id="L328">      FieldSpec.DataType[] dataTypes = new FieldSpec.DataType[numAggregations];</span>
<span class="nc" id="L329">      Object[] aggregationResults = new Object[numAggregations];</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">      for (int i = 0; i &lt; numAggregations; i++) {</span>
<span class="nc" id="L331">        AggregationFunctionContext aggregationFunctionContext = aggregationFunctionContexts[i];</span>
<span class="nc" id="L332">        aggregationColumnNames[i] = aggregationFunctionContext.getAggregationColumnName();</span>
<span class="nc" id="L333">        AggregationFunction aggregationFunction = aggregationFunctionContext.getAggregationFunction();</span>
<span class="nc" id="L334">        dataTypes[i] = aggregationFunction.getIntermediateResultDataType();</span>
<span class="nc" id="L335">        aggregationResults[i] =</span>
            aggregationFunction.extractAggregationResult(aggregationFunction.createAggregationResultHolder());
      }

      // Build the data table.
<span class="nc" id="L340">      DataTableBuilder dataTableBuilder = new DataTableBuilder(new DataSchema(aggregationColumnNames, dataTypes));</span>
<span class="nc" id="L341">      dataTableBuilder.startRow();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">      for (int i = 0; i &lt; numAggregations; i++) {</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">        switch (dataTypes[i]) {</span>
          case LONG:
<span class="nc" id="L345">            dataTableBuilder.setColumn(i, ((Number) aggregationResults[i]).longValue());</span>
<span class="nc" id="L346">            break;</span>
          case DOUBLE:
<span class="nc" id="L348">            dataTableBuilder.setColumn(i, ((Double) aggregationResults[i]).doubleValue());</span>
<span class="nc" id="L349">            break;</span>
          case OBJECT:
<span class="nc" id="L351">            dataTableBuilder.setColumn(i, aggregationResults[i]);</span>
<span class="nc" id="L352">            break;</span>
          default:
<span class="nc" id="L354">            throw new UnsupportedOperationException(</span>
                &quot;Unsupported aggregation column data type: &quot; + dataTypes[i] + &quot; for column: &quot;
                    + aggregationColumnNames[i]);
        }
      }
<span class="nc" id="L359">      dataTableBuilder.finishRow();</span>
<span class="nc" id="L360">      return dataTableBuilder.build();</span>
    }
  }

  /**
   * Builds a Data table for count(*) with the provided value.
   *
   * @param count Value of count(*)
   * @return DataTable for count(*)
   *
   * @throws IOException
   */
  public static DataTable buildCountStarDataTable(long count)
      throws IOException {
<span class="nc" id="L374">    String[] aggregationColumnNames = new String[]{COUNT_STAR};</span>
<span class="nc" id="L375">    FieldSpec.DataType[] dataTypes = new FieldSpec.DataType[] {FieldSpec.DataType.LONG};</span>

<span class="nc" id="L377">    DataTableBuilder dataTableBuilder = new DataTableBuilder(new DataSchema(aggregationColumnNames, dataTypes));</span>
<span class="nc" id="L378">    dataTableBuilder.startRow();</span>
<span class="nc" id="L379">    dataTableBuilder.setColumn(0, count);</span>
<span class="nc" id="L380">    dataTableBuilder.finishRow();</span>
<span class="nc" id="L381">    DataTable dataTable = dataTableBuilder.build();</span>
<span class="nc" id="L382">    Map&lt;String, String&gt; metadata = dataTable.getMetadata();</span>

    // Set num docs scanned as well, for backward compatibility.
<span class="nc" id="L385">    String totalDocs = Long.toString(count);</span>
<span class="nc" id="L386">    metadata.put(DataTable.NUM_DOCS_SCANNED_METADATA_KEY, totalDocs);</span>
<span class="nc" id="L387">    metadata.put(DataTable.TOTAL_DOCS_METADATA_KEY, totalDocs);</span>
<span class="nc" id="L388">    return dataTable;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>