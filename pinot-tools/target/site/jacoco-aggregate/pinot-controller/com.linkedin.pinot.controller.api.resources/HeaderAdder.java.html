<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HeaderAdder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-tools</a> &gt; <a href="../index.html" class="el_bundle">pinot-controller</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.controller.api.resources</a> &gt; <span class="el_source">HeaderAdder.java</span></div><h1>HeaderAdder.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.controller.api.resources;

import java.io.IOException;
import java.net.URI;
import javax.annotation.Priority;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.ext.Provider;


// A class to add the headers that we expect from clients. Pre-jersey API, the clients have been lax in specifying the
// actual content type that they POST or PUT. Most cases, it is JSON. In the jersey API, we have the power to receive
// objects as a typed object, if it can be de-serialized into one. So, we resort to replacing the content type with
// the expected one.
@PreMatching
@Provider
@Priority(1)
<span class="fc" id="L38">public class HeaderAdder implements ContainerRequestFilter {</span>
<span class="fc" id="L39">  public static final Logger LOGGER = LoggerFactory.getLogger(HeaderAdder.class);</span>

  // Method is PUT or POST, we need to decide if a header is to be inserted for body being JSON
  private String modifiedContentType(String path) {
<span class="fc bfc" id="L43" title="All 2 branches covered.">    if (path.startsWith(&quot;tenants&quot;)) {</span>
<span class="fc" id="L44">      return MediaType.APPLICATION_JSON;</span>
    }
<span class="fc bfc" id="L46" title="All 2 branches covered.">    if (path.startsWith(&quot;instances&quot;)) {</span>
      // If we post a new instance, that is in JSON
      // But if we enable/disable the state of an instance, that is plain text.
<span class="fc" id="L49">      String[] pathParts = path.split(&quot;/&quot;);</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">      if (pathParts[pathParts.length-1].equals(&quot;state&quot;)) {</span>
<span class="fc" id="L51">        return MediaType.TEXT_PLAIN;</span>
      }
<span class="fc" id="L53">      return MediaType.APPLICATION_JSON;</span>
    }
<span class="fc" id="L55">    return null;</span>
  }

  @Override
  public void filter(ContainerRequestContext req) throws IOException {
    {
      // TODO HACK TO BE REMOVED ONCE CLIENTS HAVE UPGRADED TO NEW THIRD-EYE JAR
      // When a client sends an HTTP request without the leading slash (e.g. &quot;GET tables HTTP/1.1&quot;)
      // then jersey seems to not parse it correctly. In these cases, the &quot;incomingBaseUri&quot; turns out as
      // http://localhost:21000/ and the &quot;incomingReqUri&quot; turns out as &quot;http://localhost:21000tables&quot;
      // We want to rewrite the incoming request URI to include the slash, otherwise, &quot;localhost:21000tables&quot; is parsed
      // as the authority.
      //
      // An older version of the http client used by third-eye jar sent http requests without leading slash
      // in the URI, causing jersey APIs to break.
<span class="fc" id="L70">      final String incomingReqUri = req.getUriInfo().getRequestUri().toString();</span>
<span class="fc" id="L71">      final String incomingBaseUri = req.getUriInfo().getBaseUri().toASCIIString();</span>
      try {
<span class="fc" id="L73">        String baseUriWithoutSlash = incomingBaseUri;</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (incomingBaseUri.endsWith(&quot;/&quot;)) {</span>
          // Remove the trailing slash
<span class="fc" id="L76">          baseUriWithoutSlash = incomingBaseUri.substring(0, incomingBaseUri.length() - 1);</span>
        }
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (incomingReqUri.startsWith(baseUriWithoutSlash)) {</span>
<span class="fc" id="L79">          String relativeUri = incomingReqUri.substring(baseUriWithoutSlash.length());</span>
          // In the example described above, relativeUri will be &quot;tables&quot;
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">          if (!relativeUri.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L82">            URI newReqUri = new URI(baseUriWithoutSlash + &quot;/&quot; + relativeUri);</span>
<span class="nc" id="L83">            LOGGER.warn(&quot;Rewriting new Request URI {} (incomingBaseUri = {}, incomingReqUri = {})&quot;,</span>
                newReqUri.toString(), incomingBaseUri, incomingReqUri);
<span class="nc" id="L85">            req.setRequestUri(newReqUri);</span>
          }
        }
<span class="nc" id="L88">      } catch (Exception e) {</span>
<span class="nc" id="L89">        LOGGER.error(&quot;Exception handling incoming URI {}, base URI {}&quot;, incomingReqUri, incomingBaseUri);</span>
<span class="fc" id="L90">      }</span>
    }

    // Add outgoing headers if this is a PUT or a POST
<span class="fc" id="L94">    String path = req.getUriInfo().getPath();</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">    if ((req.getMethod().equalsIgnoreCase(&quot;PUT&quot;) ||</span>
        req.getMethod().equalsIgnoreCase(&quot;POST&quot;))) {
<span class="fc" id="L97">      String mediaType = modifiedContentType(path);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">      if (mediaType != null) {</span>
<span class="fc" id="L99">        req.getHeaders().remove(HttpHeaders.CONTENT_TYPE);</span>
<span class="fc" id="L100">        req.getHeaders().add(HttpHeaders.CONTENT_TYPE, mediaType);</span>
      }
    }
<span class="fc" id="L103">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>