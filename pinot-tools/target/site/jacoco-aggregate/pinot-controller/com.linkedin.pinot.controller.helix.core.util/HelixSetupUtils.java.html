<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HelixSetupUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-tools</a> &gt; <a href="../index.html" class="el_bundle">pinot-controller</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.controller.helix.core.util</a> &gt; <span class="el_source">HelixSetupUtils.java</span></div><h1>HelixSetupUtils.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.controller.helix.core.util;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.apache.helix.AccessOption;
import org.apache.helix.HelixAdmin;
import org.apache.helix.HelixDataAccessor;
import org.apache.helix.HelixManager;
import org.apache.helix.PropertyKey;
import org.apache.helix.PropertyPathConfig;
import org.apache.helix.PropertyType;
import org.apache.helix.ZNRecord;
import org.apache.helix.controller.HelixControllerMain;
import org.apache.helix.manager.zk.ZKHelixAdmin;
import org.apache.helix.manager.zk.ZKHelixDataAccessor;
import org.apache.helix.manager.zk.ZKHelixManager;
import org.apache.helix.manager.zk.ZNRecordSerializer;
import org.apache.helix.manager.zk.ZkBaseDataAccessor;
import org.apache.helix.manager.zk.ZkClient;
import org.apache.helix.messaging.handling.HelixTaskExecutor;
import org.apache.helix.model.HelixConfigScope;
import org.apache.helix.model.HelixConfigScope.ConfigScopeProperty;
import org.apache.helix.model.IdealState;
import org.apache.helix.model.Message.MessageType;
import org.apache.helix.model.StateModelDefinition;
import org.apache.helix.model.builder.HelixConfigScopeBuilder;
import org.apache.helix.store.zk.ZkHelixPropertyStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.common.utils.helix.HelixHelper;
import com.linkedin.pinot.controller.helix.core.PinotHelixBrokerResourceOnlineOfflineStateModelGenerator;
import com.linkedin.pinot.controller.helix.core.PinotHelixSegmentOnlineOfflineStateModelGenerator;
import com.linkedin.pinot.controller.helix.core.PinotTableIdealStateBuilder;


/**
 * HelixSetupUtils handles how to create or get a helixCluster in controller.
 *
 *
 */
<span class="nc" id="L59">public class HelixSetupUtils {</span>

<span class="fc" id="L61">  private static final Logger LOGGER = LoggerFactory.getLogger(HelixSetupUtils.class);</span>

  public static synchronized HelixManager setup(String helixClusterName, String zkPath, String pinotControllerInstanceId,
      boolean isUpdateStateModel) {

    try {
<span class="fc" id="L67">      createHelixClusterIfNeeded(helixClusterName, zkPath, isUpdateStateModel);</span>
<span class="nc" id="L68">    } catch (final Exception e) {</span>
<span class="nc" id="L69">      LOGGER.error(&quot;Caught exception&quot;, e);</span>
<span class="nc" id="L70">      return null;</span>
<span class="fc" id="L71">    }</span>

    try {
<span class="fc" id="L74">      return startHelixControllerInStandadloneMode(helixClusterName, zkPath, pinotControllerInstanceId);</span>
<span class="nc" id="L75">    } catch (final Exception e) {</span>
<span class="nc" id="L76">      LOGGER.error(&quot;Caught exception&quot;, e);</span>
<span class="nc" id="L77">      return null;</span>
    }
  }

  public static void createHelixClusterIfNeeded(String helixClusterName, String zkPath) {
<span class="nc" id="L82">    createHelixClusterIfNeeded(helixClusterName, zkPath);</span>
<span class="nc" id="L83">  }</span>

  public static void createHelixClusterIfNeeded(String helixClusterName, String zkPath, boolean isUpdateStateModel) {
<span class="fc" id="L86">    final HelixAdmin admin = new ZKHelixAdmin(zkPath);</span>
<span class="fc" id="L87">    final String segmentStateModelName = PinotHelixSegmentOnlineOfflineStateModelGenerator.PINOT_SEGMENT_ONLINE_OFFLINE_STATE_MODEL;</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (admin.getClusters().contains(helixClusterName)) {</span>
<span class="fc" id="L90">      LOGGER.info(&quot;cluster already exists ********************************************* &quot;);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">      if (isUpdateStateModel) {</span>
<span class="nc" id="L92">        final StateModelDefinition curStateModelDef = admin.getStateModelDef(helixClusterName, segmentStateModelName);</span>
<span class="nc" id="L93">        List&lt;String&gt; states = curStateModelDef.getStatesPriorityList();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (states.contains(PinotHelixSegmentOnlineOfflineStateModelGenerator.CONSUMING_STATE)) {</span>
<span class="nc" id="L95">          LOGGER.info(&quot;State model {} already updated to contain CONSUMING state&quot;, segmentStateModelName);</span>
<span class="nc" id="L96">          return;</span>
        } else {
<span class="nc" id="L98">          LOGGER.info(&quot;Updating {} to add states for low level kafka consumers&quot;, segmentStateModelName);</span>
<span class="nc" id="L99">          StateModelDefinition newStateModelDef = PinotHelixSegmentOnlineOfflineStateModelGenerator.generatePinotStateModelDefinition();</span>
<span class="nc" id="L100">          ZkClient zkClient = new ZkClient(zkPath);</span>
<span class="nc" id="L101">          zkClient.waitUntilConnected(20, TimeUnit.SECONDS);</span>
<span class="nc" id="L102">          zkClient.setZkSerializer(new ZNRecordSerializer());</span>
<span class="nc" id="L103">          HelixDataAccessor accessor = new ZKHelixDataAccessor(helixClusterName, new ZkBaseDataAccessor&lt;ZNRecord&gt;(zkClient));</span>
<span class="nc" id="L104">          PropertyKey.Builder keyBuilder = accessor.keyBuilder();</span>
<span class="nc" id="L105">          accessor.setProperty(keyBuilder.stateModelDef(segmentStateModelName), newStateModelDef);</span>
<span class="nc" id="L106">          LOGGER.info(&quot;Completed updating statemodel {}&quot;, segmentStateModelName);</span>
<span class="nc" id="L107">          zkClient.close();</span>
        }
      }
<span class="fc" id="L110">      return;</span>
    }

<span class="fc" id="L113">    LOGGER.info(&quot;Creating a new cluster, as the helix cluster : &quot; + helixClusterName</span>
        + &quot; was not found ********************************************* &quot;);
<span class="fc" id="L115">    admin.addCluster(helixClusterName, false);</span>

<span class="fc" id="L117">    LOGGER.info(&quot;Enable auto join.&quot;);</span>
<span class="fc" id="L118">    final HelixConfigScope scope =</span>
        new HelixConfigScopeBuilder(ConfigScopeProperty.CLUSTER).forCluster(helixClusterName).build();

<span class="fc" id="L121">    final Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L122">    props.put(ZKHelixManager.ALLOW_PARTICIPANT_AUTO_JOIN, String.valueOf(true));</span>
    //we need only one segment to be loaded at a time
<span class="fc" id="L124">    props.put(MessageType.STATE_TRANSITION + &quot;.&quot; + HelixTaskExecutor.MAX_THREADS, String.valueOf(1));</span>

<span class="fc" id="L126">    admin.setConfig(scope, props);</span>

<span class="fc" id="L128">    LOGGER.info(&quot;Adding state model {} (with CONSUMED state) generated using {} **********************************************&quot;,</span>
        segmentStateModelName , PinotHelixSegmentOnlineOfflineStateModelGenerator.class.toString());

    // If this is a fresh cluster we are creating, then the cluster will see the CONSUMING state in the
    // state model. But then the servers will never be asked to go to that STATE (whether they have the code
    // to handle it or not) unil we complete the feature using low-level kafka consumers and turn the feature on.
<span class="fc" id="L134">    admin.addStateModelDef(helixClusterName, segmentStateModelName,</span>
        PinotHelixSegmentOnlineOfflineStateModelGenerator.generatePinotStateModelDefinition());

<span class="fc" id="L137">    LOGGER.info(&quot;Adding state model definition named : &quot;</span>
        + PinotHelixBrokerResourceOnlineOfflineStateModelGenerator.PINOT_BROKER_RESOURCE_ONLINE_OFFLINE_STATE_MODEL
        + &quot; generated using : &quot; + PinotHelixBrokerResourceOnlineOfflineStateModelGenerator.class.toString()
        + &quot; ********************************************** &quot;);

<span class="fc" id="L142">    admin.addStateModelDef(helixClusterName,</span>
        PinotHelixBrokerResourceOnlineOfflineStateModelGenerator.PINOT_BROKER_RESOURCE_ONLINE_OFFLINE_STATE_MODEL,
        PinotHelixBrokerResourceOnlineOfflineStateModelGenerator.generatePinotStateModelDefinition());

<span class="fc" id="L146">    LOGGER.info(&quot;Adding empty ideal state for Broker!&quot;);</span>
<span class="fc" id="L147">    HelixHelper.updateResourceConfigsFor(new HashMap&lt;String, String&gt;(), CommonConstants.Helix.BROKER_RESOURCE_INSTANCE,</span>
        helixClusterName, admin);
<span class="fc" id="L149">    IdealState idealState =</span>
        PinotTableIdealStateBuilder.buildEmptyIdealStateForBrokerResource(admin, helixClusterName);
<span class="fc" id="L151">    admin.setResourceIdealState(helixClusterName, CommonConstants.Helix.BROKER_RESOURCE_INSTANCE, idealState);</span>
<span class="fc" id="L152">    initPropertyStorePath(helixClusterName, zkPath);</span>
<span class="fc" id="L153">    LOGGER.info(&quot;New Cluster setup completed... ********************************************** &quot;);</span>
<span class="fc" id="L154">  }</span>

  private static void initPropertyStorePath(String helixClusterName, String zkPath) {
<span class="fc" id="L157">    String propertyStorePath = PropertyPathConfig.getPath(PropertyType.PROPERTYSTORE, helixClusterName);</span>
<span class="fc" id="L158">    ZkHelixPropertyStore&lt;ZNRecord&gt; propertyStore = new ZkHelixPropertyStore&lt;ZNRecord&gt;(zkPath, new ZNRecordSerializer(), propertyStorePath);</span>
<span class="fc" id="L159">    propertyStore.create(&quot;/CONFIGS&quot;, new ZNRecord(&quot;&quot;), AccessOption.PERSISTENT);</span>
<span class="fc" id="L160">    propertyStore.create(&quot;/CONFIGS/CLUSTER&quot;, new ZNRecord(&quot;&quot;), AccessOption.PERSISTENT);</span>
<span class="fc" id="L161">    propertyStore.create(&quot;/CONFIGS/TABLE&quot;, new ZNRecord(&quot;&quot;), AccessOption.PERSISTENT);</span>
<span class="fc" id="L162">    propertyStore.create(&quot;/CONFIGS/INSTANCE&quot;, new ZNRecord(&quot;&quot;), AccessOption.PERSISTENT);</span>
<span class="fc" id="L163">    propertyStore.create(&quot;/SCHEMAS&quot;, new ZNRecord(&quot;&quot;), AccessOption.PERSISTENT);</span>
<span class="fc" id="L164">    propertyStore.create(&quot;/SEGMENTS&quot;, new ZNRecord(&quot;&quot;), AccessOption.PERSISTENT);</span>
<span class="fc" id="L165">  }</span>

  private static HelixManager startHelixControllerInStandadloneMode(String helixClusterName, String zkUrl,
      String pinotControllerInstanceId) {
<span class="fc" id="L169">    LOGGER.info(&quot;Starting Helix Standalone Controller ... &quot;);</span>
<span class="fc" id="L170">    return HelixControllerMain.startHelixController(zkUrl, helixClusterName, pinotControllerInstanceId,</span>
        HelixControllerMain.STANDALONE);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>