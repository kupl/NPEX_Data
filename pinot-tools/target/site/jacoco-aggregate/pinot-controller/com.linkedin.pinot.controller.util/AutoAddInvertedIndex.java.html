<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AutoAddInvertedIndex.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-tools</a> &gt; <a href="../index.html" class="el_bundle">pinot-controller</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.controller.util</a> &gt; <span class="el_source">AutoAddInvertedIndex.java</span></div><h1>AutoAddInvertedIndex.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.controller.util;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.config.IndexingConfig;
import com.linkedin.pinot.common.config.TableConfig;
import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.data.TimeFieldSpec;
import com.linkedin.pinot.common.metadata.ZKMetadataProvider;
import com.linkedin.pinot.controller.helix.ControllerRequestURLBuilder;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nonnull;
import org.apache.helix.PropertyPathConfig;
import org.apache.helix.PropertyType;
import org.apache.helix.ZNRecord;
import org.apache.helix.manager.zk.ZKHelixAdmin;
import org.apache.helix.manager.zk.ZNRecordSerializer;
import org.apache.helix.store.zk.ZkHelixPropertyStore;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The &lt;code&gt;AutoAddInvertedIndex&lt;/code&gt; class can be used to automatically add inverted index to tables based on the
 * strategy and mode specified.
 * &lt;p&gt;Currently support:
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     Strategy:
 *     &lt;ul&gt;
 *       &lt;li&gt;
 *         QUERY: add inverted index based on the query result
 *         &lt;ul&gt;
 *           &lt;li&gt;1. Get the table size, only add inverted index to large tables&lt;/li&gt;
 *           &lt;li&gt;2. Get the latest timestamp, only get dimension DISTINCTCOUNT values for one timestamp&lt;/li&gt;
 *           &lt;li&gt;3. Sort the DISTINCTCOUNT value for all dimensions&lt;/li&gt;
 *           &lt;li&gt;4. Add inverted index to dimensions with large DISTINCTCOUNT value&lt;/li&gt;
 *         &lt;/ul&gt;
 *       &lt;/li&gt;
 *     &lt;/ul&gt;
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     Mode:
 *     &lt;ul&gt;
 *       &lt;li&gt;NEW: apply only to tables without inverted index&lt;/li&gt;
 *       &lt;li&gt;REMOVE: remove all auto-generated inverted index&lt;/li&gt;
 *       &lt;li&gt;REFRESH: refresh the auto-generated inverted index&lt;/li&gt;
 *       &lt;li&gt;APPEND: append to the auto-generated inverted index&lt;/li&gt;
 *     &lt;/ul&gt;
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 */
public class AutoAddInvertedIndex {
<span class="nc" id="L81">  public enum Strategy {</span>
<span class="nc" id="L82">    QUERY     // Add inverted index based on the query result</span>
  }

<span class="nc" id="L85">  public enum Mode {</span>
<span class="nc" id="L86">    NEW,      // Apply only to tables without inverted index</span>
<span class="nc" id="L87">    REMOVE,   // Remove all auto-generated inverted index</span>
<span class="nc" id="L88">    REFRESH,  // Refresh the auto-generated inverted index</span>
<span class="nc" id="L89">    APPEND    // Append to the auto-generated inverted index</span>
  }

  public static final long DEFAULT_TABLE_SIZE_THRESHOLD = 10_000_000;
  public static final long DEFAULT_CARDINALITY_THRESHOLD = 100;
  public static final int DEFAULT_MAX_NUM_INVERTED_INDEX_ADDED = 2;

<span class="nc" id="L96">  private static final Logger LOGGER = LoggerFactory.getLogger(AutoAddInvertedIndex.class);</span>

  private final String _clusterName;
  private final String _controllerAddress;
  private final String _brokerAddress;
  private final ZKHelixAdmin _helixAdmin;
  private final ZkHelixPropertyStore&lt;ZNRecord&gt; _propertyStore;
  private final Strategy _strategy;
  private final Mode _mode;

<span class="nc" id="L106">  private String _tableNamePattern = null;</span>
<span class="nc" id="L107">  private long _tableSizeThreshold = DEFAULT_TABLE_SIZE_THRESHOLD;</span>
<span class="nc" id="L108">  private long _cardinalityThreshold = DEFAULT_CARDINALITY_THRESHOLD;</span>
<span class="nc" id="L109">  private int _maxNumInvertedIndexAdded = DEFAULT_MAX_NUM_INVERTED_INDEX_ADDED;</span>

  public AutoAddInvertedIndex(@Nonnull String zkAddress, @Nonnull String clusterName, @Nonnull String controllerAddress,
<span class="nc" id="L112">      @Nonnull String brokerAddress, @Nonnull Strategy strategy, @Nonnull Mode mode) {</span>
<span class="nc" id="L113">    _clusterName = clusterName;</span>
<span class="nc" id="L114">    _controllerAddress = controllerAddress;</span>
<span class="nc" id="L115">    _brokerAddress = brokerAddress;</span>
<span class="nc" id="L116">    _helixAdmin = new ZKHelixAdmin(zkAddress);</span>
<span class="nc" id="L117">    _propertyStore = new ZkHelixPropertyStore&lt;&gt;(zkAddress, new ZNRecordSerializer(),</span>
        PropertyPathConfig.getPath(PropertyType.PROPERTYSTORE, clusterName));
<span class="nc" id="L119">    _strategy = strategy;</span>
<span class="nc" id="L120">    _mode = mode;</span>
<span class="nc" id="L121">  }</span>

  public void overrideDefaultSettings(@Nonnull String tableNamePattern, long tableSizeThreshold,
      long cardinalityThreshold, int maxNumInvertedIndex) {
<span class="nc" id="L125">    _tableNamePattern = tableNamePattern;</span>
<span class="nc" id="L126">    _tableSizeThreshold = tableSizeThreshold;</span>
<span class="nc" id="L127">    _cardinalityThreshold = cardinalityThreshold;</span>
<span class="nc" id="L128">    _maxNumInvertedIndexAdded = maxNumInvertedIndex;</span>
<span class="nc" id="L129">  }</span>

  public void run()
      throws Exception {
<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (_strategy == Strategy.QUERY) {</span>
<span class="nc" id="L134">      runQueryStrategy();</span>
    } else {
<span class="nc" id="L136">      throw new IllegalStateException(&quot;Invalid Strategy: &quot; + _strategy);</span>
    }
<span class="nc" id="L138">  }</span>

  private void runQueryStrategy()
      throws Exception {
    // Get all resources in cluster
<span class="nc" id="L143">    List&lt;String&gt; resourcesInCluster = _helixAdmin.getResourcesInCluster(_clusterName);</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">    for (String tableNameWithType : resourcesInCluster) {</span>
      // Skip non-table resources
<span class="nc bnc" id="L147" title="All 2 branches missed.">      if (!TableNameBuilder.isTableResource(tableNameWithType)) {</span>
<span class="nc" id="L148">        continue;</span>
      }

      // Skip tables that do not match the defined name pattern
<span class="nc bnc" id="L152" title="All 4 branches missed.">      if (_tableNamePattern != null &amp;&amp; !tableNameWithType.matches(_tableNamePattern)) {</span>
<span class="nc" id="L153">        continue;</span>
      }
<span class="nc" id="L155">      LOGGER.info(&quot;Table: {} matches the table name pattern: {}&quot;, tableNameWithType, _tableNamePattern);</span>

      // Get the inverted index config
<span class="nc" id="L158">      TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);</span>
<span class="nc" id="L159">      Preconditions.checkNotNull(tableConfig);</span>
<span class="nc" id="L160">      IndexingConfig indexingConfig = tableConfig.getIndexingConfig();</span>
<span class="nc" id="L161">      List&lt;String&gt; invertedIndexColumns = indexingConfig.getInvertedIndexColumns();</span>
<span class="nc" id="L162">      boolean autoGeneratedInvertedIndex = indexingConfig.isAutoGeneratedInvertedIndex();</span>

      // Handle auto-generated inverted index
<span class="nc bnc" id="L165" title="All 2 branches missed.">      if (autoGeneratedInvertedIndex) {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        Preconditions.checkState(!invertedIndexColumns.isEmpty(), &quot;Auto-generated inverted index list is empty&quot;);</span>

        // NEW mode, skip
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (_mode == Mode.NEW) {</span>
<span class="nc" id="L170">          LOGGER.info(</span>
              &quot;Table: {}, skip adding inverted index because it has auto-generated inverted index and under NEW mode&quot;,
              tableNameWithType);
<span class="nc" id="L173">          continue;</span>
        }

        // REMOVE mode, remove the inverted index and update
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (_mode == Mode.REMOVE) {</span>
<span class="nc" id="L178">          invertedIndexColumns.clear();</span>
<span class="nc" id="L179">          indexingConfig.setAutoGeneratedInvertedIndex(false);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">          if (updateIndexConfig(tableNameWithType, tableConfig)) {</span>
<span class="nc" id="L181">            LOGGER.info(&quot;Table: {}, removed auto-generated inverted index&quot;, tableNameWithType);</span>
          } else {
<span class="nc" id="L183">            LOGGER.error(&quot;Table: {}, failed to remove auto-generated inverted index&quot;, tableNameWithType);</span>
          }
<span class="nc" id="L185">          continue;</span>
        }

        // REFRESH mode, remove auto-generated inverted index
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (_mode == Mode.REFRESH) {</span>
<span class="nc" id="L190">          invertedIndexColumns.clear();</span>
        }
      } else {
        // Handle null inverted index columns
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (invertedIndexColumns == null) {</span>
<span class="nc" id="L195">          invertedIndexColumns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L196">          indexingConfig.setInvertedIndexColumns(invertedIndexColumns);</span>
        }

        // Remove empty strings
        int emptyStringIndex;
<span class="nc bnc" id="L201" title="All 2 branches missed.">        while ((emptyStringIndex = invertedIndexColumns.indexOf(&quot;&quot;)) != -1) {</span>
<span class="nc" id="L202">          invertedIndexColumns.remove(emptyStringIndex);</span>
        }

        // Skip non-empty non-auto-generated inverted index
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (!invertedIndexColumns.isEmpty()) {</span>
<span class="nc" id="L207">          LOGGER.info(&quot;Table: {}, skip adding inverted index because it has non-auto-generated inverted index&quot;,</span>
              tableNameWithType);
<span class="nc" id="L209">          continue;</span>
        }
      }

      // Skip tables without a schema
<span class="nc" id="L214">      Schema tableSchema = ZKMetadataProvider.getTableSchema(_propertyStore, tableNameWithType);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">      if (tableSchema == null) {</span>
<span class="nc" id="L216">        LOGGER.info(&quot;Table: {}, skip adding inverted index because it does not have a schema&quot;, tableNameWithType);</span>
<span class="nc" id="L217">        continue;</span>
      }

      // Skip tables without dimensions
<span class="nc" id="L221">      List&lt;String&gt; dimensionNames = tableSchema.getDimensionNames();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      if (dimensionNames.size() == 0) {</span>
<span class="nc" id="L223">        LOGGER.info(&quot;Table: {}, skip adding inverted index because it does not have any dimension column&quot;,</span>
            tableNameWithType);
<span class="nc" id="L225">        continue;</span>
      }

      // Skip tables without a proper time column
<span class="nc" id="L229">      TimeFieldSpec timeFieldSpec = tableSchema.getTimeFieldSpec();</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">      if (timeFieldSpec == null || timeFieldSpec.getDataType() == FieldSpec.DataType.STRING) {</span>
<span class="nc" id="L231">        LOGGER.info(&quot;Table: {}, skip adding inverted index because it does not have a numeric time column&quot;,</span>
            tableNameWithType);
<span class="nc" id="L233">        continue;</span>
      }
<span class="nc" id="L235">      String timeColumnName = timeFieldSpec.getName();</span>
<span class="nc" id="L236">      TimeUnit timeUnit = timeFieldSpec.getOutgoingGranularitySpec().getTimeType();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">      if (timeUnit != TimeUnit.DAYS) {</span>
<span class="nc" id="L238">        LOGGER.warn(&quot;Table: {}, time column {] has non-DAYS time unit: {}&quot;, timeColumnName, timeUnit);</span>
      }

      // Only add inverted index to table larger than a threshold
<span class="nc" id="L242">      JSONObject queryResponse = sendQuery(&quot;SELECT COUNT(*) FROM &quot; + tableNameWithType);</span>
<span class="nc" id="L243">      long numTotalDocs = queryResponse.getLong(&quot;totalDocs&quot;);</span>
<span class="nc" id="L244">      LOGGER.info(&quot;Table: {}, number of total documents: {}&quot;, tableNameWithType, numTotalDocs);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">      if (numTotalDocs &lt;= _tableSizeThreshold) {</span>
<span class="nc" id="L246">        LOGGER.info(&quot;Table: {}, skip adding inverted index because the table is too small&quot;, tableNameWithType);</span>
<span class="nc" id="L247">        continue;</span>
      }

      // Get each dimension's cardinality on one timestamp's data
<span class="nc" id="L251">      queryResponse = sendQuery(&quot;SELECT Max(&quot; + timeColumnName + &quot;) FROM &quot; + tableNameWithType);</span>
<span class="nc" id="L252">      int maxTimeStamp = queryResponse.getJSONArray(&quot;aggregationResults&quot;).getJSONObject(0).getInt(&quot;value&quot;);</span>
<span class="nc" id="L253">      LOGGER.info(&quot;Table: {}, max time column {}: {}&quot;, tableNameWithType, timeColumnName, maxTimeStamp);</span>

      // Query DISTINCTCOUNT on all dimensions in one query might cause timeout, so query them separately
<span class="nc" id="L256">      List&lt;ResultPair&gt; resultPairs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      for (String dimensionName : dimensionNames) {</span>
<span class="nc" id="L258">        String query =</span>
            &quot;SELECT DISTINCTCOUNT(&quot; + dimensionName + &quot;) FROM &quot; + tableNameWithType + &quot; WHERE &quot; + timeColumnName + &quot; = &quot;
                + maxTimeStamp;
<span class="nc" id="L261">        queryResponse = sendQuery(query);</span>
<span class="nc" id="L262">        JSONObject result = queryResponse.getJSONArray(&quot;aggregationResults&quot;).getJSONObject(0);</span>
<span class="nc" id="L263">        resultPairs.add(</span>
            new ResultPair(result.getString(&quot;function&quot;).substring(&quot;distinctCount_&quot;.length()), result.getLong(&quot;value&quot;)));
<span class="nc" id="L265">      }</span>

      // Sort the dimensions based on their cardinalities
<span class="nc" id="L268">      Collections.sort(resultPairs);</span>

      // Add the top dimensions into inverted index columns
<span class="nc" id="L271">      int numInvertedIndex = Math.min(_maxNumInvertedIndexAdded, resultPairs.size());</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      for (int i = 0; i &lt; numInvertedIndex; i++) {</span>
<span class="nc" id="L273">        ResultPair resultPair = resultPairs.get(i);</span>
<span class="nc" id="L274">        String columnName = resultPair._key;</span>
<span class="nc" id="L275">        long cardinality = resultPair._value;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (cardinality &gt; _cardinalityThreshold) {</span>
          // Do not append inverted index if already exists
<span class="nc bnc" id="L278" title="All 2 branches missed.">          if (!invertedIndexColumns.contains(columnName)) {</span>
<span class="nc" id="L279">            invertedIndexColumns.add(columnName);</span>
          }
<span class="nc" id="L281">          LOGGER.info(&quot;Table: {}, add inverted index to column {} with cardinality: {}&quot;, tableNameWithType, columnName,</span>
              cardinality);
        } else {
<span class="nc" id="L284">          LOGGER.info(&quot;Table: {}, skip adding inverted index to column {} with cardinality: {}&quot;, tableNameWithType,</span>
              columnName, cardinality);
<span class="nc" id="L286">          break;</span>
        }
      }

      // Update indexing config
<span class="nc bnc" id="L291" title="All 2 branches missed.">      if (!invertedIndexColumns.isEmpty()) {</span>
<span class="nc" id="L292">        indexingConfig.setAutoGeneratedInvertedIndex(true);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (updateIndexConfig(tableNameWithType, tableConfig)) {</span>
<span class="nc" id="L294">          LOGGER.info(&quot;Table: {}, added inverted index to columns: {}&quot;, tableNameWithType, invertedIndexColumns);</span>
        } else {
<span class="nc" id="L296">          LOGGER.error(&quot;Table: {}, failed to add inverted index to columns: {}&quot;, tableNameWithType,</span>
              invertedIndexColumns);
        }
      } else {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (autoGeneratedInvertedIndex) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">          Preconditions.checkState(_mode == Mode.REFRESH);</span>

          // Remove existing auto-generated inverted index because no column matches all the conditions
<span class="nc" id="L304">          indexingConfig.setAutoGeneratedInvertedIndex(false);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">          if (updateIndexConfig(tableNameWithType, tableConfig)) {</span>
<span class="nc" id="L306">            LOGGER.info(&quot;Table: {}, removed auto-generated inverted index&quot;, tableNameWithType);</span>
          } else {
<span class="nc" id="L308">            LOGGER.error(&quot;Table: {}, failed to remove auto-generated inverted index&quot;, tableNameWithType);</span>
          }
        }
      }
<span class="nc" id="L312">    }</span>
<span class="nc" id="L313">  }</span>

  private JSONObject sendQuery(String query)
      throws Exception {
<span class="nc" id="L317">    URLConnection urlConnection = new URL(&quot;http://&quot; + _brokerAddress + &quot;/query&quot;).openConnection();</span>
<span class="nc" id="L318">    urlConnection.setDoOutput(true);</span>

<span class="nc" id="L320">    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(urlConnection.getOutputStream(), &quot;UTF-8&quot;));</span>
<span class="nc" id="L321">    writer.write(new JSONObject().put(&quot;pql&quot;, query).toString());</span>
<span class="nc" id="L322">    writer.flush();</span>

<span class="nc" id="L324">    BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), &quot;UTF-8&quot;));</span>
<span class="nc" id="L325">    return new JSONObject(reader.readLine());</span>
  }

  private boolean updateIndexConfig(String tableName, TableConfig tableConfig)
      throws Exception {
<span class="nc" id="L330">    String request =</span>
        ControllerRequestURLBuilder.baseUrl(&quot;http://&quot; + _controllerAddress).forTableUpdateIndexingConfigs(tableName);
<span class="nc" id="L332">    HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(request).openConnection();</span>
<span class="nc" id="L333">    httpURLConnection.setDoOutput(true);</span>
<span class="nc" id="L334">    httpURLConnection.setRequestMethod(&quot;PUT&quot;);</span>

<span class="nc" id="L336">    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(httpURLConnection.getOutputStream(), &quot;UTF-8&quot;));</span>
<span class="nc" id="L337">    writer.write(tableConfig.toJSONConfigString());</span>
<span class="nc" id="L338">    writer.flush();</span>

<span class="nc" id="L340">    BufferedReader reader = new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream(), &quot;UTF-8&quot;));</span>
<span class="nc" id="L341">    return reader.readLine().equals(&quot;done&quot;);</span>
  }

  private static class ResultPair implements Comparable&lt;ResultPair&gt; {
    private final String _key;
    private final long _value;

<span class="nc" id="L348">    public ResultPair(String key, long value) {</span>
<span class="nc" id="L349">      _key = key;</span>
<span class="nc" id="L350">      _value = value;</span>
<span class="nc" id="L351">    }</span>

    @Override
    public int compareTo(@Nonnull ResultPair o) {
<span class="nc" id="L355">      return Long.compare(o._value, _value);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L360">      return _key + &quot;: &quot; + _value;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>