<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BrokerReduceService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-tools</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.query.reduce</a> &gt; <span class="el_source">BrokerReduceService.java</span></div><h1>BrokerReduceService.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.query.reduce;

import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.exception.QueryException;
import com.linkedin.pinot.common.metrics.BrokerMeter;
import com.linkedin.pinot.common.metrics.BrokerMetrics;
import com.linkedin.pinot.common.query.ReduceService;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.request.GroupBy;
import com.linkedin.pinot.common.request.HavingFilterQuery;
import com.linkedin.pinot.common.request.HavingFilterQueryMap;
import com.linkedin.pinot.common.request.Selection;
import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.common.response.broker.AggregationResult;
import com.linkedin.pinot.common.response.broker.BrokerResponseNative;
import com.linkedin.pinot.common.response.broker.GroupByResult;
import com.linkedin.pinot.common.response.broker.QueryProcessingException;
import com.linkedin.pinot.common.response.broker.SelectionResults;
import com.linkedin.pinot.common.utils.DataSchema;
import com.linkedin.pinot.common.utils.DataTable;
import com.linkedin.pinot.core.query.aggregation.function.AggregationFunction;
import com.linkedin.pinot.core.query.aggregation.function.AggregationFunctionUtils;
import com.linkedin.pinot.core.query.aggregation.groupby.AggregationGroupByTrimmingService;
import com.linkedin.pinot.core.query.selection.SelectionOperatorService;
import com.linkedin.pinot.core.query.selection.SelectionOperatorUtils;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.concurrent.ThreadSafe;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The &lt;code&gt;BrokerReduceService&lt;/code&gt; class provides service to reduce data tables gathered from multiple servers
 * to {@link BrokerResponseNative}.
 */
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">@ThreadSafe</span>
<span class="fc" id="L62">public class BrokerReduceService implements ReduceService&lt;BrokerResponseNative&gt; {</span>
<span class="fc" id="L63">  private static final Logger LOGGER = LoggerFactory.getLogger(BrokerReduceService.class);</span>

  @Nonnull
  @Override
  public BrokerResponseNative reduceOnDataTable(@Nonnull BrokerRequest brokerRequest,
      @Nonnull Map&lt;ServerInstance, DataTable&gt; dataTableMap, @Nullable BrokerMetrics brokerMetrics) {
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">    if (dataTableMap.size() == 0) {</span>
      // Empty response.
<span class="nc" id="L71">      return BrokerResponseNative.empty();</span>
    }

<span class="fc" id="L74">    BrokerResponseNative brokerResponseNative = new BrokerResponseNative();</span>
<span class="fc" id="L75">    List&lt;QueryProcessingException&gt; processingExceptions = brokerResponseNative.getProcessingExceptions();</span>
<span class="fc" id="L76">    long numDocsScanned = 0L;</span>
<span class="fc" id="L77">    long numEntriesScannedInFilter = 0L;</span>
<span class="fc" id="L78">    long numEntriesScannedPostFilter = 0L;</span>
<span class="fc" id="L79">    long numTotalRawDocs = 0L;</span>

    // Cache a data schema from data tables (try to cache one with data rows associated with it).
<span class="fc" id="L82">    DataSchema cachedDataSchema = null;</span>

    // Process server response metadata.
<span class="fc" id="L85">    Iterator&lt;Map.Entry&lt;ServerInstance, DataTable&gt;&gt; iterator = dataTableMap.entrySet().iterator();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    while (iterator.hasNext()) {</span>
<span class="fc" id="L87">      Map.Entry&lt;ServerInstance, DataTable&gt; entry = iterator.next();</span>
<span class="fc" id="L88">      ServerInstance serverInstance = entry.getKey();</span>
<span class="fc" id="L89">      DataTable dataTable = entry.getValue();</span>
<span class="fc" id="L90">      Map&lt;String, String&gt; metadata = dataTable.getMetadata();</span>

      // Reduce on trace info.
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">      if (brokerRequest.isEnableTrace()) {</span>
<span class="nc" id="L94">        brokerResponseNative.getTraceInfo()</span>
            .put(serverInstance.getHostname(), metadata.get(DataTable.TRACE_INFO_METADATA_KEY));
      }

      // Reduce on exceptions.
<span class="fc bfc" id="L99" title="All 2 branches covered.">      for (String key : metadata.keySet()) {</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (key.startsWith(DataTable.EXCEPTION_METADATA_KEY)) {</span>
<span class="nc" id="L101">          processingExceptions.add(new QueryProcessingException(Integer.parseInt(key.substring(9)), metadata.get(key)));</span>
        }
<span class="fc" id="L103">      }</span>

      // Reduce on execution statistics.
<span class="fc" id="L106">      String numDocsScannedString = metadata.get(DataTable.NUM_DOCS_SCANNED_METADATA_KEY);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">      if (numDocsScannedString != null) {</span>
<span class="fc" id="L108">        numDocsScanned += Long.parseLong(numDocsScannedString);</span>
      }
<span class="fc" id="L110">      String numEntriesScannedInFilterString = metadata.get(DataTable.NUM_ENTRIES_SCANNED_IN_FILTER_METADATA_KEY);</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">      if (numEntriesScannedInFilterString != null) {</span>
<span class="fc" id="L112">        numEntriesScannedInFilter += Long.parseLong(numEntriesScannedInFilterString);</span>
      }
<span class="fc" id="L114">      String numEntriesScannedPostFilterString = metadata.get(DataTable.NUM_ENTRIES_SCANNED_POST_FILTER_METADATA_KEY);</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">      if (numEntriesScannedPostFilterString != null) {</span>
<span class="fc" id="L116">        numEntriesScannedPostFilter += Long.parseLong(numEntriesScannedPostFilterString);</span>
      }
<span class="fc" id="L118">      String numTotalRawDocsString = metadata.get(DataTable.TOTAL_DOCS_METADATA_KEY);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">      if (numTotalRawDocsString != null) {</span>
<span class="fc" id="L120">        numTotalRawDocs += Long.parseLong(numTotalRawDocsString);</span>
      }

      // After processing the metadata, remove data tables without data rows inside.
<span class="fc" id="L124">      DataSchema dataSchema = dataTable.getDataSchema();</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">      if (dataSchema == null) {</span>
<span class="nc" id="L126">        iterator.remove();</span>
      } else {
        // Try to cache a data table with data rows inside, or cache one with data schema inside.
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (dataTable.getNumberOfRows() == 0) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">          if (cachedDataSchema == null) {</span>
<span class="nc" id="L131">            cachedDataSchema = dataSchema;</span>
          }
<span class="nc" id="L133">          iterator.remove();</span>
        } else {
<span class="fc" id="L135">          cachedDataSchema = dataSchema;</span>
        }
      }
<span class="fc" id="L138">    }</span>

    // Set execution statistics.
<span class="fc" id="L141">    brokerResponseNative.setNumDocsScanned(numDocsScanned);</span>
<span class="fc" id="L142">    brokerResponseNative.setNumEntriesScannedInFilter(numEntriesScannedInFilter);</span>
<span class="fc" id="L143">    brokerResponseNative.setNumEntriesScannedPostFilter(numEntriesScannedPostFilter);</span>
<span class="fc" id="L144">    brokerResponseNative.setTotalDocs(numTotalRawDocs);</span>

    // Update broker metrics.
<span class="fc" id="L147">    String tableName = brokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L148">    String rawTableName = TableNameBuilder.extractRawTableName(tableName);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">    if (brokerMetrics != null) {</span>
<span class="nc" id="L150">      brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.DOCUMENTS_SCANNED, numDocsScanned);</span>
<span class="nc" id="L151">      brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.ENTRIES_SCANNED_IN_FILTER,</span>
          numEntriesScannedInFilter);
<span class="nc" id="L153">      brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.ENTRIES_SCANNED_POST_FILTER,</span>
          numEntriesScannedPostFilter);
    }

<span class="pc bpc" id="L157" title="1 of 2 branches missed.">    if (dataTableMap.isEmpty()) {</span>
      // For empty data table map, construct empty result using the cached data schema.

      // This will only happen to selection query.
<span class="nc bnc" id="L161" title="All 2 branches missed.">      if (cachedDataSchema != null) {</span>
<span class="nc" id="L162">        List&lt;String&gt; selectionColumns =</span>
            SelectionOperatorUtils.getSelectionColumns(brokerRequest.getSelections().getSelectionColumns(),
                cachedDataSchema);
<span class="nc" id="L165">        brokerResponseNative.setSelectionResults(</span>
            new SelectionResults(selectionColumns, new ArrayList&lt;Serializable[]&gt;(0)));
<span class="nc" id="L167">      }</span>
    } else {
      // Reduce server responses data and set query results into the broker response.
<span class="pc bpc" id="L170" title="2 of 4 branches missed.">      assert cachedDataSchema != null;</span>

<span class="pc bpc" id="L172" title="1 of 2 branches missed.">      if (brokerRequest.isSetSelections()) {</span>
        // Selection query.

        // For data table map with more than one data tables, remove conflicting data tables.
<span class="nc" id="L176">        DataSchema masterDataSchema = cachedDataSchema.clone();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (dataTableMap.size() &gt; 1) {</span>
<span class="nc" id="L178">          List&lt;String&gt; droppedServers = removeConflictingResponses(masterDataSchema, dataTableMap);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">          if (!droppedServers.isEmpty()) {</span>
<span class="nc" id="L180">            String errorMessage =</span>
                QueryException.MERGE_RESPONSE_ERROR.getMessage() + &quot;: responses for table: &quot; + tableName
                    + &quot; from servers: &quot; + droppedServers + &quot; got dropped due to data schema inconsistency.&quot;;
<span class="nc" id="L183">            LOGGER.info(errorMessage);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (brokerMetrics != null) {</span>
<span class="nc" id="L185">              brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.RESPONSE_MERGE_EXCEPTIONS, 1L);</span>
            }
<span class="nc" id="L187">            brokerResponseNative.addToExceptions(</span>
                new QueryProcessingException(QueryException.MERGE_RESPONSE_ERROR_CODE, errorMessage));
          }
        }
<span class="nc" id="L191">        setSelectionResults(brokerResponseNative, brokerRequest.getSelections(), dataTableMap, masterDataSchema);</span>
<span class="nc" id="L192">      } else {</span>
        // Aggregation query.
<span class="fc" id="L194">        AggregationFunction[] aggregationFunctions =</span>
            AggregationFunctionUtils.getAggregationFunctions(brokerRequest.getAggregationsInfo());
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (!brokerRequest.isSetGroupBy()) {</span>
          // Aggregation only query.
<span class="fc" id="L198">          setAggregationResults(brokerResponseNative, aggregationFunctions, dataTableMap, cachedDataSchema);</span>
        } else {
          // Aggregation group-by query.
<span class="fc" id="L201">          boolean[] aggregationFunctionSelectStatus =</span>
              AggregationFunctionUtils.getAggregationFunctionsSelectStatus(brokerRequest.getAggregationsInfo());
<span class="fc" id="L203">          setGroupByHavingResults(brokerResponseNative, aggregationFunctions, aggregationFunctionSelectStatus,</span>
              brokerRequest.getGroupBy(), dataTableMap, brokerRequest.getHavingFilterQuery(),
              brokerRequest.getHavingFilterSubQueryMap());
        }
      }
    }
<span class="fc" id="L209">    return brokerResponseNative;</span>
  }

  /**
   * Given a data schema, remove data tables that are not compatible with this data schema.
   * &lt;p&gt;Upgrade the data schema passed in to cover all remaining data schemas.
   *
   * @param dataSchema data schema.
   * @param dataTableMap map from server to data table.
   * @return list of server names where the data table got removed.
   */
  @Nonnull
  private List&lt;String&gt; removeConflictingResponses(@Nonnull DataSchema dataSchema,
      @Nonnull Map&lt;ServerInstance, DataTable&gt; dataTableMap) {
<span class="nc" id="L223">    List&lt;String&gt; droppedServers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L224">    Iterator&lt;Map.Entry&lt;ServerInstance, DataTable&gt;&gt; iterator = dataTableMap.entrySet().iterator();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">    while (iterator.hasNext()) {</span>
<span class="nc" id="L226">      Map.Entry&lt;ServerInstance, DataTable&gt; entry = iterator.next();</span>
<span class="nc" id="L227">      DataSchema dataSchemaToCompare = entry.getValue().getDataSchema();</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">      assert dataSchemaToCompare != null;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      if (!dataSchema.isTypeCompatibleWith(dataSchemaToCompare)) {</span>
<span class="nc" id="L230">        droppedServers.add(entry.getKey().toString());</span>
<span class="nc" id="L231">        iterator.remove();</span>
      } else {
<span class="nc" id="L233">        dataSchema.upgradeToCover(dataSchemaToCompare);</span>
      }
<span class="nc" id="L235">    }</span>
<span class="nc" id="L236">    return droppedServers;</span>
  }

  /**
   * Reduce selection results from multiple servers and set them into BrokerResponseNative passed in.
   *
   * @param brokerResponseNative broker response.
   * @param selection selection information.
   * @param dataTableMap map from server to data table.
   * @param dataSchema data schema.
   */
  private void setSelectionResults(@Nonnull BrokerResponseNative brokerResponseNative, @Nonnull Selection selection,
      @Nonnull Map&lt;ServerInstance, DataTable&gt; dataTableMap, @Nonnull DataSchema dataSchema) {
    // Reduce the selection results.
    SelectionResults selectionResults;
<span class="nc" id="L251">    int selectionSize = selection.getSize();</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">    if (selection.isSetSelectionSortSequence() &amp;&amp; selectionSize != 0) {</span>
      // Selection order-by.
<span class="nc" id="L254">      SelectionOperatorService selectionService = new SelectionOperatorService(selection, dataSchema);</span>
<span class="nc" id="L255">      selectionService.reduceWithOrdering(dataTableMap);</span>
<span class="nc" id="L256">      selectionResults = selectionService.renderSelectionResultsWithOrdering();</span>
<span class="nc" id="L257">    } else {</span>
      // Selection only.
<span class="nc" id="L259">      selectionResults = SelectionOperatorUtils.renderSelectionResultsWithoutOrdering(</span>
          SelectionOperatorUtils.reduceWithoutOrdering(dataTableMap, selectionSize), dataSchema,
          SelectionOperatorUtils.getSelectionColumns(selection.getSelectionColumns(), dataSchema));
    }

<span class="nc" id="L264">    brokerResponseNative.setSelectionResults(selectionResults);</span>
<span class="nc" id="L265">  }</span>

  /**
   * Reduce aggregation results from multiple servers and set them into BrokerResponseNative passed in.
   *
   * @param brokerResponseNative broker response.
   * @param aggregationFunctions array of aggregation functions.
   * @param dataTableMap map from server to data table.
   * @param dataSchema data schema.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private void setAggregationResults(@Nonnull BrokerResponseNative brokerResponseNative,
      @Nonnull AggregationFunction[] aggregationFunctions, @Nonnull Map&lt;ServerInstance, DataTable&gt; dataTableMap,
      @Nonnull DataSchema dataSchema) {
<span class="fc" id="L279">    int numAggregationFunctions = aggregationFunctions.length;</span>

    // Merge results from all data tables.
<span class="fc" id="L282">    Object[] intermediateResults = new Object[numAggregationFunctions];</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">    for (DataTable dataTable : dataTableMap.values()) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">      for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
        Object intermediateResultToMerge;
<span class="fc" id="L286">        FieldSpec.DataType columnType = dataSchema.getColumnType(i);</span>
<span class="pc bpc" id="L287" title="1 of 4 branches missed.">        switch (columnType) {</span>
          case LONG:
<span class="fc" id="L289">            intermediateResultToMerge = dataTable.getLong(0, i);</span>
<span class="fc" id="L290">            break;</span>
          case DOUBLE:
<span class="fc" id="L292">            intermediateResultToMerge = dataTable.getDouble(0, i);</span>
<span class="fc" id="L293">            break;</span>
          case OBJECT:
<span class="fc" id="L295">            intermediateResultToMerge = dataTable.getObject(0, i);</span>
<span class="fc" id="L296">            break;</span>
          default:
<span class="pc" id="L298">            throw new IllegalStateException(&quot;Illegal column type in aggregation results: &quot; + columnType);</span>
        }
<span class="fc" id="L300">        Object mergedIntermediateResult = intermediateResults[i];</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (mergedIntermediateResult == null) {</span>
<span class="fc" id="L302">          intermediateResults[i] = intermediateResultToMerge;</span>
        } else {
<span class="fc" id="L304">          intermediateResults[i] = aggregationFunctions[i].merge(mergedIntermediateResult, intermediateResultToMerge);</span>
        }
      }
<span class="fc" id="L307">    }</span>

    // Extract final results and set them into the broker response.
<span class="fc" id="L310">    List&lt;AggregationResult&gt; reducedAggregationResults = new ArrayList&lt;&gt;(numAggregationFunctions);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">    for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="fc" id="L312">      String formattedResult =</span>
          AggregationFunctionUtils.formatValue(aggregationFunctions[i].extractFinalResult(intermediateResults[i]));
<span class="fc" id="L314">      reducedAggregationResults.add(new AggregationResult(dataSchema.getColumnName(i), formattedResult));</span>
    }
<span class="fc" id="L316">    brokerResponseNative.setAggregationResults(reducedAggregationResults);</span>
<span class="fc" id="L317">  }</span>

  /**
   * Reduce group-by results from multiple servers and set them into BrokerResponseNative passed in.
   *
   * @param brokerResponseNative broker response.
   * @param aggregationFunctions array of aggregation functions.
   * @param groupBy group-by information.
   * @param dataTableMap map from server to data table.
   * @param havingFilterQuery having filter query
   * @param havingFilterQueryMap having filter query map
   */
  @SuppressWarnings(&quot;unchecked&quot;)

  private void setGroupByHavingResults(@Nonnull BrokerResponseNative brokerResponseNative,
      @Nonnull AggregationFunction[] aggregationFunctions, boolean[] aggregationFunctionsSelectStatus,
      @Nonnull GroupBy groupBy, @Nonnull Map&lt;ServerInstance, DataTable&gt; dataTableMap,
      HavingFilterQuery havingFilterQuery, HavingFilterQueryMap havingFilterQueryMap) {
<span class="fc" id="L335">    int numAggregationFunctions = aggregationFunctions.length;</span>

    // Merge results from all data tables.
<span class="fc" id="L338">    String[] columnNames = new String[numAggregationFunctions];</span>
<span class="fc" id="L339">    Map&lt;String, Object&gt;[] intermediateResultMaps = new Map[numAggregationFunctions];</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">    for (DataTable dataTable : dataTableMap.values()) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">      for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (columnNames[i] == null) {</span>
<span class="fc" id="L343">          columnNames[i] = dataTable.getString(i, 0);</span>
<span class="fc" id="L344">          intermediateResultMaps[i] = dataTable.getObject(i, 1);</span>
        } else {
<span class="fc" id="L346">          Map&lt;String, Object&gt; mergedIntermediateResultMap = intermediateResultMaps[i];</span>
<span class="fc" id="L347">          Map&lt;String, Object&gt; intermediateResultMapToMerge = dataTable.getObject(i, 1);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">          for (Map.Entry&lt;String, Object&gt; entry : intermediateResultMapToMerge.entrySet()) {</span>
<span class="fc" id="L349">            String groupKey = entry.getKey();</span>
<span class="fc" id="L350">            Object intermediateResultToMerge = entry.getValue();</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            if (mergedIntermediateResultMap.containsKey(groupKey)) {</span>
<span class="fc" id="L352">              Object mergedIntermediateResult = mergedIntermediateResultMap.get(groupKey);</span>
<span class="fc" id="L353">              mergedIntermediateResultMap.put(groupKey,</span>
                  aggregationFunctions[i].merge(mergedIntermediateResult, intermediateResultToMerge));
<span class="fc" id="L355">            } else {</span>
<span class="nc" id="L356">              mergedIntermediateResultMap.put(groupKey, intermediateResultToMerge);</span>
            }
<span class="fc" id="L358">          }</span>
        }
      }
<span class="fc" id="L361">    }</span>

    // Extract final result maps from the merged intermediate result maps.
<span class="fc" id="L364">    Map&lt;String, Comparable&gt;[] finalResultMaps = new Map[numAggregationFunctions];</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="fc" id="L366">      Map&lt;String, Object&gt; intermediateResultMap = intermediateResultMaps[i];</span>
<span class="fc" id="L367">      Map&lt;String, Comparable&gt; finalResultMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">      for (String groupKey : intermediateResultMap.keySet()) {</span>
<span class="fc" id="L369">        Object intermediateResult = intermediateResultMap.get(groupKey);</span>
<span class="fc" id="L370">        finalResultMap.put(groupKey, aggregationFunctions[i].extractFinalResult(intermediateResult));</span>
<span class="fc" id="L371">      }</span>
<span class="fc" id="L372">      finalResultMaps[i] = finalResultMap;</span>
    }
    //If HAVING clause is set, we further filter the group by results based on the HAVING predicate
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">    if (havingFilterQuery != null) {</span>
<span class="nc" id="L376">      HavingClauseComparisonTree havingClauseComparisonTree =</span>
          HavingClauseComparisonTree.buildHavingClauseComparisonTree(havingFilterQuery, havingFilterQueryMap);
      //Applying close policy
      //We just keep those groups (from different aggregation functions) that are exist in the result set of all aggregation functions.
      //In other words, we just keep intersection of groups of different aggregation functions.
      //Here we calculate the intersection of group key sets of different aggregation functions
<span class="nc" id="L382">      Set&lt;String&gt; intersectionOfKeySets = finalResultMaps[0].keySet();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      for (int i = 1; i &lt; numAggregationFunctions; i++) {</span>
<span class="nc" id="L384">        intersectionOfKeySets.retainAll(finalResultMaps[i].keySet());</span>
      }

      //Now it is time to remove those groups that do not validate HAVING clause predicate
      //We use TreeMap which supports CASE_INSENSITIVE_ORDER
<span class="nc" id="L389">      Map&lt;String, Comparable&gt; singleGroupAggResults = new TreeMap&lt;String, Comparable&gt;(String.CASE_INSENSITIVE_ORDER);</span>
<span class="nc" id="L390">      Map&lt;String, Comparable&gt;[] finalFilteredResultMaps = new Map[numAggregationFunctions];</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">      for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="nc" id="L392">        finalFilteredResultMaps[i] = new HashMap&lt;&gt;();</span>
      }

<span class="nc bnc" id="L395" title="All 2 branches missed.">      for (String groupKey : intersectionOfKeySets) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">        for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="nc" id="L397">          singleGroupAggResults.put(columnNames[i], finalResultMaps[i].get(groupKey));</span>
        }
        //if this group validate HAVING predicate keep it in the new map
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (havingClauseComparisonTree.isThisGroupPassPredicates(singleGroupAggResults)) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">          for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="nc" id="L402">            finalFilteredResultMaps[i].put(groupKey, singleGroupAggResults.get(columnNames[i]));</span>
          }
        }
<span class="nc" id="L405">      }</span>
      //update the final results
<span class="nc" id="L407">      finalResultMaps = finalFilteredResultMaps;</span>
    }

<span class="fc" id="L410">    int aggregationNumsInFinalResult = 0;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">    for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">      if (aggregationFunctionsSelectStatus[i]) {</span>
<span class="fc" id="L413">        aggregationNumsInFinalResult++;</span>
      }
    }

<span class="pc bpc" id="L417" title="1 of 2 branches missed.">    if (aggregationNumsInFinalResult &gt; 0) {</span>
<span class="fc" id="L418">      String[] finalColumnNames = new String[aggregationNumsInFinalResult];</span>
<span class="fc" id="L419">      Map&lt;String, Comparable&gt;[] finalOutResultMaps = new Map[aggregationNumsInFinalResult];</span>
<span class="fc" id="L420">      AggregationFunction[] finalAggregationFunctions = new AggregationFunction[aggregationNumsInFinalResult];</span>
<span class="fc" id="L421">      int count = 0;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">      for (int i = 0; i &lt; numAggregationFunctions; i++) {</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (aggregationFunctionsSelectStatus[i]) {</span>
<span class="fc" id="L424">          finalColumnNames[count] = columnNames[i];</span>
<span class="fc" id="L425">          finalOutResultMaps[count] = finalResultMaps[i];</span>
<span class="fc" id="L426">          finalAggregationFunctions[count] = aggregationFunctions[i];</span>
<span class="fc" id="L427">          count++;</span>
        }
      }
      // Trim the final result maps to topN and set them into the broker response.
<span class="fc" id="L431">      AggregationGroupByTrimmingService aggregationGroupByTrimmingService =</span>
          new AggregationGroupByTrimmingService(finalAggregationFunctions, (int) groupBy.getTopN());
<span class="fc" id="L433">      List&lt;GroupByResult&gt;[] groupByResultLists = aggregationGroupByTrimmingService.trimFinalResults(finalOutResultMaps);</span>
<span class="fc" id="L434">      List&lt;AggregationResult&gt; aggregationResults = new ArrayList&lt;&gt;(count);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">      for (int i = 0; i &lt; aggregationNumsInFinalResult; i++) {</span>
<span class="fc" id="L436">        List&lt;GroupByResult&gt; groupByResultList = groupByResultLists[i];</span>
<span class="fc" id="L437">        List&lt;String&gt; groupByColumns = groupBy.getExpressions();</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">        if (groupByColumns == null) {</span>
<span class="nc" id="L439">          groupByColumns = groupBy.getColumns();</span>
        }
<span class="fc" id="L441">        aggregationResults.add(new AggregationResult(groupByResultList, groupByColumns, finalColumnNames[i]));</span>
      }
<span class="fc" id="L443">      brokerResponseNative.setAggregationResults(aggregationResults);</span>
<span class="fc" id="L444">    } else {</span>
<span class="nc" id="L445">      throw new IllegalStateException(</span>
          &quot;There should be minimum one aggregation function in the select list of a Group by query&quot;);
    }
<span class="fc" id="L448">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>