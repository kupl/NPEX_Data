<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RealtimeColumnStatistics.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-tools</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.realtime.converter.stats</a> &gt; <span class="el_source">RealtimeColumnStatistics.java</span></div><h1>RealtimeColumnStatistics.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.realtime.converter.stats;

import com.linkedin.pinot.common.config.ColumnPartitionConfig;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.core.common.Block;
import com.linkedin.pinot.core.common.BlockMultiValIterator;
import com.linkedin.pinot.core.data.partition.PartitionFunction;
import com.linkedin.pinot.core.data.partition.PartitionFunctionFactory;
import com.linkedin.pinot.core.io.reader.SingleColumnSingleValueReader;
import com.linkedin.pinot.core.operator.blocks.SingleValueBlock;
import com.linkedin.pinot.core.realtime.impl.dictionary.MutableDictionary;
import com.linkedin.pinot.core.segment.creator.ColumnStatistics;
import com.linkedin.pinot.core.segment.index.data.source.ColumnDataSource;
import java.util.Arrays;
import java.util.List;
import org.apache.commons.lang.math.IntRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Column statistics for a column coming from an in-memory realtime segment.
 */
public class RealtimeColumnStatistics implements ColumnStatistics {
<span class="fc" id="L40">  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeColumnStatistics.class);</span>

  private final ColumnDataSource _dataSource;
  private final int[] _sortedDocIdIterationOrder;
  private final MutableDictionary _dictionaryReader;
  private final Block _block;
  private PartitionFunction partitionFunction;
  private int numPartitions;
<span class="fc" id="L48">  private int partitionRangeStart = Integer.MAX_VALUE;</span>
<span class="fc" id="L49">  private int partitionRangeEnd = Integer.MIN_VALUE;</span>

  public RealtimeColumnStatistics(ColumnDataSource dataSource, int[] sortedDocIdIterationOrder,
<span class="fc" id="L52">      ColumnPartitionConfig columnPartitionConfig) {</span>
<span class="fc" id="L53">    _dataSource = dataSource;</span>
<span class="fc" id="L54">    _sortedDocIdIterationOrder = sortedDocIdIterationOrder;</span>
<span class="fc" id="L55">    _dictionaryReader = (MutableDictionary) dataSource.getDictionary();</span>
<span class="fc" id="L56">    _block = dataSource.nextBlock();</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">    if (columnPartitionConfig != null) {</span>
<span class="nc" id="L58">      String functionName = columnPartitionConfig.getFunctionName();</span>
<span class="nc" id="L59">      numPartitions = columnPartitionConfig.getNumPartitions();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      partitionFunction =</span>
          (functionName != null) ? PartitionFunctionFactory.getPartitionFunction(functionName, numPartitions) : null;
<span class="nc bnc" id="L62" title="All 2 branches missed.">      if (partitionFunction != null) {</span>
<span class="nc" id="L63">        updatePartition();</span>
      }
    }
<span class="fc" id="L66">  }</span>

  @Override
  public Object getMinValue() {
<span class="fc" id="L70">    return _dictionaryReader.getMinVal();</span>
  }

  @Override
  public Object getMaxValue() {
<span class="fc" id="L75">    return _dictionaryReader.getMaxVal();</span>
  }

  @Override
  public Object getUniqueValuesSet() {
<span class="fc" id="L80">    return _dictionaryReader.getSortedValues();</span>
  }

  @Override
  public int getCardinality() {
<span class="fc" id="L85">    return _dictionaryReader.length();</span>
  }

  @Override
  public int getLengthOfLargestElement() {
    // Length of longest string
<span class="fc" id="L91">    int maximumStringLength = 0;</span>

    // If this column is a string column, iterate over the dictionary to find the maximum length
<span class="fc bfc" id="L94" title="All 2 branches covered.">    if (_dataSource.getDataSourceMetadata().getDataType() == FieldSpec.DataType.STRING) {</span>
<span class="fc" id="L95">      final int length = _dictionaryReader.length();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L97">        maximumStringLength = Math.max(_dictionaryReader.getStringValue(i).length(), maximumStringLength);</span>
      }
    }

<span class="fc" id="L101">    return maximumStringLength;</span>
  }

  @Override
  public boolean isSorted() {
    // Multivalue columns can't be in sorted order
<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (!_block.getMetadata().isSingleValue()) {</span>
<span class="fc" id="L108">      return false;</span>
    }

    // If this is a single value, then by definition the data is sorted
<span class="fc" id="L112">    final int blockLength = _block.getMetadata().getLength();</span>
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">    if (blockLength &lt;= 1 || getCardinality() &lt;= 1) {</span>
<span class="fc" id="L114">      return true;</span>
    }

    // Iterate over all data to figure out whether or not it's in sorted order
<span class="fc" id="L118">    SingleColumnSingleValueReader singleValueReader = ((SingleValueBlock) _block).getReader();</span>

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    int docIdIndex = _sortedDocIdIterationOrder != null ? _sortedDocIdIterationOrder[0] : 0;</span>
<span class="fc" id="L121">    int dictionaryId = singleValueReader.getInt(docIdIndex);</span>
<span class="fc" id="L122">    Comparable previousValue = (Comparable) _dictionaryReader.get(dictionaryId);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">    for (int i = 1; i &lt; blockLength; i++) {</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">      docIdIndex = _sortedDocIdIterationOrder != null ? _sortedDocIdIterationOrder[i] : i;</span>
<span class="fc" id="L125">      dictionaryId = singleValueReader.getInt(docIdIndex);</span>
<span class="fc" id="L126">      Comparable currentValue = (Comparable) _dictionaryReader.get(dictionaryId);</span>
      // If previousValue is greater than currentValue
<span class="fc bfc" id="L128" title="All 2 branches covered.">      if (0 &lt; previousValue.compareTo(currentValue)) {</span>
<span class="fc" id="L129">        return false;</span>
      } else {
<span class="fc" id="L131">        previousValue = currentValue;</span>
      }
    }

<span class="nc" id="L135">    return true;</span>
  }

  @Override
  public int getTotalNumberOfEntries() {
    // Number of multivalue entries
<span class="fc" id="L141">    int multivalueEntryCount = 0;</span>

    // If this column is a multivalue column, iterate over all data to find the total number of multivalue entries (this
    // information doesn't seem to be exposed via an API)
<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (!_block.getMetadata().isSingleValue()) {</span>
<span class="fc" id="L146">      int[] dictionaryIds = new int[getMaxNumberOfMultiValues()];</span>

<span class="fc" id="L148">      BlockMultiValIterator valIterator = (BlockMultiValIterator) _block.getBlockValueSet().iterator();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">      while (valIterator.hasNext()) {</span>
<span class="fc" id="L150">        multivalueEntryCount += valIterator.nextIntVal(dictionaryIds);</span>
      }
    }

<span class="fc" id="L154">    return multivalueEntryCount;</span>
  }

  @Override
  public int getMaxNumberOfMultiValues() {
<span class="fc" id="L159">    return _block.getMetadata().getMaxNumberOfMultiValues();</span>
  }

  @Override
  public boolean hasNull() {
<span class="fc" id="L164">    return false;</span>
  }

  @Override
  public PartitionFunction getPartitionFunction() {
<span class="fc" id="L169">    return partitionFunction;</span>
  }

  @Override
  public int getNumPartitions() {
<span class="fc" id="L174">    return numPartitions;</span>
  }

  @Override
  public List&lt;IntRange&gt; getPartitionRanges() {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">    if (partitionRangeStart &lt;= partitionRangeEnd) {</span>
<span class="nc" id="L180">      return Arrays.asList(new IntRange(partitionRangeStart, partitionRangeEnd));</span>
    } else {
<span class="fc" id="L182">      return null;</span>
    }
  }

  /**
   * Update partition ranges based on column values.
   *
   */
  void updatePartition() {
    // Iterate over the dictionary to check the partitioning
<span class="nc" id="L192">    final int length = _dictionaryReader.length();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L194">      int partition = partitionFunction.getPartition(_dictionaryReader.get(i));</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">      if (partition &lt; partitionRangeStart) {</span>
<span class="nc" id="L197">        partitionRangeStart = partition;</span>
      }

<span class="nc bnc" id="L200" title="All 2 branches missed.">      if (partition &gt; partitionRangeEnd) {</span>
<span class="nc" id="L201">        partitionRangeEnd = partition;</span>
      }
    }
<span class="nc" id="L204">  }</span>

  @Override
  public int getPartitionRangeWidth() {
<span class="nc" id="L208">    return partitionRangeEnd - partitionRangeStart + 1;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>