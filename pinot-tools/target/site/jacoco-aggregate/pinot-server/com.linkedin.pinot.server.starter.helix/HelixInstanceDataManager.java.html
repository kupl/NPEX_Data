<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HelixInstanceDataManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-tools</a> &gt; <a href="../index.html" class="el_bundle">pinot-server</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.server.starter.helix</a> &gt; <span class="el_source">HelixInstanceDataManager.java</span></div><h1>HelixInstanceDataManager.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.server.starter.helix;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.linkedin.pinot.common.config.TableConfig;
import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.metadata.ZKMetadataProvider;
import com.linkedin.pinot.common.metrics.ServerMetrics;
import com.linkedin.pinot.common.segment.SegmentMetadata;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.core.data.manager.config.TableDataManagerConfig;
import com.linkedin.pinot.core.data.manager.offline.InstanceDataManager;
import com.linkedin.pinot.core.data.manager.offline.SegmentDataManager;
import com.linkedin.pinot.core.data.manager.offline.TableDataManager;
import com.linkedin.pinot.core.data.manager.offline.TableDataManagerProvider;
import com.linkedin.pinot.core.indexsegment.IndexSegment;
import com.linkedin.pinot.core.indexsegment.columnar.ColumnarSegmentLoader;
import com.linkedin.pinot.core.segment.index.loader.IndexLoadingConfig;
import com.linkedin.pinot.core.segment.index.loader.LoaderUtils;
import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.io.FileUtils;
import org.apache.helix.ZNRecord;
import org.apache.helix.store.zk.ZkHelixPropertyStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The class &lt;code&gt;HelixInstanceDataManager&lt;/code&gt; is the instance data manager based on Helix.
 *
 * TODO: add locks and remove synchronized to add segments in parallel
 * TODO: move SegmentFetcherAndLoader into this class to make this the top level manager
 */
<span class="nc" id="L60">public class HelixInstanceDataManager implements InstanceDataManager {</span>
<span class="nc" id="L61">  private static final Logger LOGGER = LoggerFactory.getLogger(HelixInstanceDataManager.class);</span>

<span class="nc" id="L63">  private final Map&lt;String, TableDataManager&gt; _tableDataManagerMap = new HashMap&lt;&gt;();</span>

  private HelixInstanceDataManagerConfig _instanceDataManagerConfig;
  private String _instanceId;
  private ZkHelixPropertyStore&lt;ZNRecord&gt; _propertyStore;
  private ServerMetrics _serverMetrics;
<span class="nc" id="L69">  private boolean _started = false;</span>

  @Override
  public synchronized void init(Configuration config, ZkHelixPropertyStore&lt;ZNRecord&gt; propertyStore,
      ServerMetrics serverMetrics) {
    try {
<span class="nc" id="L75">      _instanceDataManagerConfig = new HelixInstanceDataManagerConfig(config);</span>
<span class="nc" id="L76">      _instanceId = _instanceDataManagerConfig.getInstanceId();</span>
<span class="nc" id="L77">      _propertyStore = propertyStore;</span>
<span class="nc" id="L78">      _serverMetrics = serverMetrics;</span>

<span class="nc" id="L80">      LOGGER.info(&quot;InstanceDataManager Config:&quot; + _instanceDataManagerConfig.toString());</span>
<span class="nc" id="L81">      File instanceDataDir = new File(_instanceDataManagerConfig.getInstanceDataDir());</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">      if (!instanceDataDir.exists()) {</span>
<span class="nc" id="L83">        Preconditions.checkState(instanceDataDir.mkdirs());</span>
      }
<span class="nc" id="L85">      File instanceSegmentTarDir = new File(_instanceDataManagerConfig.getInstanceSegmentTarDir());</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">      if (!instanceSegmentTarDir.exists()) {</span>
<span class="nc" id="L87">        Preconditions.checkState(instanceSegmentTarDir.mkdirs());</span>
      }
<span class="nc" id="L89">    } catch (Exception e) {</span>
<span class="nc" id="L90">      LOGGER.error(&quot;Caught exception while initializing Helix instance data manager&quot;, e);</span>
<span class="nc" id="L91">      throw new RuntimeException(e);</span>
<span class="nc" id="L92">    }</span>
<span class="nc" id="L93">  }</span>

  @Override
  public synchronized void start() {
<span class="nc" id="L97">    LOGGER.info(&quot;Starting Helix instance data manager&quot;);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (_started) {</span>
<span class="nc" id="L99">      LOGGER.info(&quot;Helix instance data manager is already started&quot;);</span>
<span class="nc" id="L100">      return;</span>
    }

    // Nothing to be done

<span class="nc" id="L105">    _started = true;</span>
<span class="nc" id="L106">    LOGGER.info(&quot;Finish starting Helix instance data manager&quot;);</span>
<span class="nc" id="L107">  }</span>

  @Override
  public synchronized void shutDown() {
<span class="nc" id="L111">    LOGGER.info(&quot;Shutting down Helix instance data manager&quot;);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">    if (!_started) {</span>
<span class="nc" id="L113">      LOGGER.info(&quot;Helix instance data manager is not running&quot;);</span>
<span class="nc" id="L114">      return;</span>
    }

<span class="nc bnc" id="L117" title="All 2 branches missed.">    for (TableDataManager tableDataManager : getTableDataManagers()) {</span>
<span class="nc" id="L118">      tableDataManager.shutDown();</span>
<span class="nc" id="L119">    }</span>

<span class="nc" id="L121">    _started = false;</span>
<span class="nc" id="L122">    LOGGER.info(&quot;Finish shutting down Helix instance data manager&quot;);</span>
<span class="nc" id="L123">  }</span>

  @Override
  public synchronized void addOfflineSegment(@Nonnull String offlineTableName, @Nonnull String segmentName,
      @Nonnull File indexDir) throws Exception {
<span class="nc" id="L128">    LOGGER.info(&quot;Adding segment: {} to OFFLINE table: {}&quot;, segmentName, offlineTableName);</span>
<span class="nc" id="L129">    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, offlineTableName);</span>
<span class="nc" id="L130">    Preconditions.checkNotNull(tableConfig);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">    if (!_tableDataManagerMap.containsKey(offlineTableName)) {</span>
<span class="nc" id="L132">      addTable(offlineTableName, tableConfig);</span>
    }

<span class="nc" id="L135">    _tableDataManagerMap.get(offlineTableName)</span>
        .addSegment(indexDir, new IndexLoadingConfig(_instanceDataManagerConfig, tableConfig));
<span class="nc" id="L137">    LOGGER.info(&quot;Added segment: {} to OFFLINE table: {}&quot;, segmentName, offlineTableName);</span>
<span class="nc" id="L138">  }</span>

  @Override
  public synchronized void addRealtimeSegment(@Nonnull String realtimeTableName, @Nonnull String segmentName)
      throws Exception {
<span class="nc" id="L143">    LOGGER.info(&quot;Adding segment: {} to REALTIME table: {}&quot;, segmentName, realtimeTableName);</span>
<span class="nc" id="L144">    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, realtimeTableName);</span>
<span class="nc" id="L145">    Preconditions.checkNotNull(tableConfig);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (!_tableDataManagerMap.containsKey(realtimeTableName)) {</span>
<span class="nc" id="L147">      addTable(realtimeTableName, tableConfig);</span>
    }

<span class="nc" id="L150">    _tableDataManagerMap.get(realtimeTableName)</span>
        .addSegment(segmentName, tableConfig, new IndexLoadingConfig(_instanceDataManagerConfig, tableConfig));
<span class="nc" id="L152">    LOGGER.info(&quot;Added segment: {} to REALTIME table: {}&quot;, segmentName, realtimeTableName);</span>
<span class="nc" id="L153">  }</span>

  private void addTable(@Nonnull String tableNameWithType, @Nonnull TableConfig tableConfig)
      throws ConfigurationException {
<span class="nc" id="L157">    LOGGER.info(&quot;Adding table: {}&quot;, tableNameWithType);</span>
<span class="nc" id="L158">    TableDataManagerConfig tableDataManagerConfig =</span>
        TableDataManagerConfig.getDefaultHelixTableDataManagerConfig(_instanceDataManagerConfig, tableNameWithType);
<span class="nc" id="L160">    tableDataManagerConfig.overrideConfigs(tableConfig);</span>
<span class="nc" id="L161">    TableDataManager tableDataManager =</span>
        TableDataManagerProvider.getTableDataManager(tableDataManagerConfig, _instanceId, _propertyStore,
            _serverMetrics);
<span class="nc" id="L164">    tableDataManager.start();</span>
<span class="nc" id="L165">    _tableDataManagerMap.put(tableNameWithType, tableDataManager);</span>
<span class="nc" id="L166">    LOGGER.info(&quot;Added table: {}&quot;, tableNameWithType);</span>
<span class="nc" id="L167">  }</span>

  @Override
  public synchronized void removeSegment(@Nonnull String tableNameWithType, @Nonnull String segmentName)
      throws Exception {
<span class="nc" id="L172">    TableDataManager tableDataManager = _tableDataManagerMap.get(tableNameWithType);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (tableDataManager != null) {</span>
<span class="nc" id="L174">      tableDataManager.removeSegment(segmentName);</span>
    }
<span class="nc" id="L176">  }</span>

  @Override
  public synchronized void reloadSegment(@Nonnull String tableNameWithType, @Nonnull String segmentName)
      throws Exception {
<span class="nc" id="L181">    SegmentMetadata segmentMetadata = getSegmentMetadata(tableNameWithType, segmentName);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (segmentMetadata == null) {</span>
<span class="nc" id="L183">      LOGGER.warn(&quot;Cannot locate segment: {} in table: {]&quot;, segmentName, tableNameWithType);</span>
<span class="nc" id="L184">      return;</span>
    }

<span class="nc" id="L187">    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);</span>
<span class="nc" id="L188">    Preconditions.checkNotNull(tableConfig);</span>

<span class="nc" id="L190">    Schema schema = null;</span>
    // For OFFLINE table, try to get schema for default columns
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (TableNameBuilder.OFFLINE.tableHasTypeSuffix(tableNameWithType)) {</span>
<span class="nc" id="L193">      schema = ZKMetadataProvider.getTableSchema(_propertyStore, tableNameWithType);</span>
    }

<span class="nc" id="L196">    reloadSegment(tableNameWithType, segmentMetadata, tableConfig, schema);</span>
<span class="nc" id="L197">  }</span>

  @Override
  public synchronized void reloadAllSegments(@Nonnull String tableNameWithType) throws Exception {
<span class="nc" id="L201">    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, tableNameWithType);</span>
<span class="nc" id="L202">    Preconditions.checkNotNull(tableConfig);</span>

<span class="nc" id="L204">    Schema schema = null;</span>
    // For OFFLINE table, try to get schema for default columns
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (TableNameBuilder.OFFLINE.tableHasTypeSuffix(tableNameWithType)) {</span>
<span class="nc" id="L207">      schema = ZKMetadataProvider.getTableSchema(_propertyStore, tableNameWithType);</span>
    }

<span class="nc bnc" id="L210" title="All 2 branches missed.">    for (SegmentMetadata segmentMetadata : getAllSegmentsMetadata(tableNameWithType)) {</span>
<span class="nc" id="L211">      reloadSegment(tableNameWithType, segmentMetadata, tableConfig, schema);</span>
<span class="nc" id="L212">    }</span>
<span class="nc" id="L213">  }</span>

  private void reloadSegment(@Nonnull String tableNameWithType, @Nonnull SegmentMetadata segmentMetadata,
      @Nonnull TableConfig tableConfig, @Nullable Schema schema) throws Exception {
<span class="nc" id="L217">    String segmentName = segmentMetadata.getName();</span>
<span class="nc" id="L218">    LOGGER.info(&quot;Reloading segment: {} in table: {}&quot;, segmentName, tableNameWithType);</span>

<span class="nc" id="L220">    String indexDirString = segmentMetadata.getIndexDir();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    if (indexDirString == null) {</span>
<span class="nc" id="L222">      LOGGER.info(&quot;Skip reloading REALTIME consuming segment: {} in table: {}&quot;, segmentName, tableNameWithType);</span>
<span class="nc" id="L223">      return;</span>
    }

<span class="nc" id="L226">    File indexDir = new File(indexDirString);</span>
<span class="nc" id="L227">    Preconditions.checkState(indexDir.isDirectory(), &quot;Index directory: %s is not a directory&quot;, indexDir);</span>

<span class="nc" id="L229">    File parentFile = indexDir.getParentFile();</span>
<span class="nc" id="L230">    File segmentBackupDir =</span>
        new File(parentFile, indexDir.getName() + CommonConstants.Segment.SEGMENT_BACKUP_DIR_SUFFIX);
    try {
      // First rename index directory to segment backup directory so that original segment have all file descriptors
      // point to the segment backup directory to ensure original segment serves queries properly

      // Rename index directory to segment backup directory (atomic)
<span class="nc" id="L237">      Preconditions.checkState(indexDir.renameTo(segmentBackupDir),</span>
          &quot;Failed to rename index directory: %s to segment backup directory: %s&quot;, indexDir, segmentBackupDir);

      // Copy from segment backup directory back to index directory
<span class="nc" id="L241">      FileUtils.copyDirectory(segmentBackupDir, indexDir);</span>

      // Load from index directory
<span class="nc" id="L244">      IndexSegment indexSegment =</span>
          ColumnarSegmentLoader.load(indexDir, new IndexLoadingConfig(_instanceDataManagerConfig, tableConfig), schema);

      // Replace the old segment in memory
<span class="nc" id="L248">      _tableDataManagerMap.get(tableNameWithType).addSegment(indexSegment);</span>

      // Rename segment backup directory to segment temporary directory (atomic)
      // The reason to first rename then delete is that, renaming is an atomic operation, but deleting is not. When we
      // rename the segment backup directory to segment temporary directory, we know the reload already succeeded, so
      // that we can safely delete the segment temporary directory
<span class="nc" id="L254">      File segmentTempDir = new File(parentFile, indexDir.getName() + CommonConstants.Segment.SEGMENT_TEMP_DIR_SUFFIX);</span>
<span class="nc" id="L255">      Preconditions.checkState(segmentBackupDir.renameTo(segmentTempDir),</span>
          &quot;Failed to rename segment backup directory: %s to segment temporary directory: %s&quot;, segmentBackupDir,
          segmentTempDir);
<span class="nc" id="L258">      LOGGER.info(&quot;Reloaded segment: {} in table: {}&quot;, segmentName, tableNameWithType);</span>

      // Delete segment temporary directory
<span class="nc" id="L261">      FileUtils.deleteDirectory(segmentTempDir);</span>
    } finally {
<span class="nc" id="L263">      LoaderUtils.reloadFailureRecovery(indexDir);</span>
<span class="nc" id="L264">    }</span>
<span class="nc" id="L265">  }</span>

  @Nonnull
  @Override
  public Collection&lt;TableDataManager&gt; getTableDataManagers() {
<span class="nc" id="L270">    return _tableDataManagerMap.values();</span>
  }

  @Nullable
  @Override
  public TableDataManager getTableDataManager(String tableName) {
<span class="nc" id="L276">    return _tableDataManagerMap.get(tableName);</span>
  }

  @Nonnull
  @Override
  public String getSegmentDataDirectory() {
<span class="nc" id="L282">    return _instanceDataManagerConfig.getInstanceDataDir();</span>
  }

  @Nonnull
  @Override
  public String getSegmentFileDirectory() {
<span class="nc" id="L288">    return _instanceDataManagerConfig.getInstanceSegmentTarDir();</span>
  }

  @Override
  public int getMaxParallelRefreshThreads() {
<span class="nc" id="L293">    return _instanceDataManagerConfig.getMaxParallelRefreshThreads();</span>
  }

  @Nullable
  @Override
  public SegmentMetadata getSegmentMetadata(@Nonnull String tableNameWithType, @Nonnull String segmentName) {
<span class="nc" id="L299">    TableDataManager tableDataManager = _tableDataManagerMap.get(tableNameWithType);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (tableDataManager != null) {</span>
<span class="nc" id="L301">      SegmentDataManager segmentDataManager = null;</span>
      try {
<span class="nc" id="L303">        segmentDataManager = tableDataManager.acquireSegment(segmentName);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (segmentDataManager != null) {</span>
<span class="nc" id="L305">          return segmentDataManager.getSegment().getSegmentMetadata();</span>
        }
      } finally {
<span class="nc bnc" id="L308" title="All 6 branches missed.">        if (segmentDataManager != null) {</span>
<span class="nc" id="L309">          tableDataManager.releaseSegment(segmentDataManager);</span>
        }
      }
    }
<span class="nc" id="L313">    return null;</span>
  }

  @Nonnull
  @Override
  public List&lt;SegmentMetadata&gt; getAllSegmentsMetadata(@Nonnull String tableNameWithType) {
<span class="nc" id="L319">    TableDataManager tableDataManager = _tableDataManagerMap.get(tableNameWithType);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">    if (tableDataManager == null) {</span>
<span class="nc" id="L321">      return Collections.emptyList();</span>
    } else {
<span class="nc" id="L323">      ImmutableList&lt;SegmentDataManager&gt; segmentDataManagers = null;</span>
      try {
<span class="nc" id="L325">        segmentDataManagers = tableDataManager.acquireAllSegments();</span>
<span class="nc" id="L326">        List&lt;SegmentMetadata&gt; segmentsMetadata = new ArrayList&lt;&gt;(segmentDataManagers.size());</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        for (SegmentDataManager segmentDataManager : segmentDataManagers) {</span>
<span class="nc" id="L328">          segmentsMetadata.add(segmentDataManager.getSegment().getSegmentMetadata());</span>
<span class="nc" id="L329">        }</span>
<span class="nc" id="L330">        return segmentsMetadata;</span>
      } finally {
<span class="nc bnc" id="L332" title="All 4 branches missed.">        if (segmentDataManagers != null) {</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">          for (SegmentDataManager segmentDataManager : segmentDataManagers) {</span>
<span class="nc" id="L334">            tableDataManager.releaseSegment(segmentDataManager);</span>
<span class="nc" id="L335">          }</span>
        }
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>