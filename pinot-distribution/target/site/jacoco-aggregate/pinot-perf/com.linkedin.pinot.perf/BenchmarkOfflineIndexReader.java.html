<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BenchmarkOfflineIndexReader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-perf</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.perf</a> &gt; <span class="el_source">BenchmarkOfflineIndexReader.java</span></div><h1>BenchmarkOfflineIndexReader.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.perf;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.segment.ReadMode;
import com.linkedin.pinot.common.utils.TarGzCompressionUtils;
import com.linkedin.pinot.core.io.reader.ReaderContext;
import com.linkedin.pinot.core.io.reader.impl.v1.FixedBitMultiValueReader;
import com.linkedin.pinot.core.io.reader.impl.v1.FixedBitSingleValueReader;
import com.linkedin.pinot.core.io.reader.impl.v1.SortedIndexReader;
import com.linkedin.pinot.core.segment.creator.SegmentIndexCreationDriver;
import com.linkedin.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;
import com.linkedin.pinot.core.segment.index.ColumnMetadata;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import com.linkedin.pinot.core.segment.index.readers.DoubleDictionary;
import com.linkedin.pinot.core.segment.index.readers.FloatDictionary;
import com.linkedin.pinot.core.segment.index.readers.IntDictionary;
import com.linkedin.pinot.core.segment.index.readers.LongDictionary;
import com.linkedin.pinot.core.segment.index.readers.StringDictionary;
import com.linkedin.pinot.core.segment.store.ColumnIndexType;
import com.linkedin.pinot.core.segment.store.SegmentDirectory;
import com.linkedin.pinot.integration.tests.ClusterTest;
import com.linkedin.pinot.segments.v1.creator.SegmentTestUtils;
import com.linkedin.pinot.util.TestUtils;
import java.io.File;
import java.net.URL;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import org.apache.commons.io.FileUtils;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.TearDown;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;
import org.openjdk.jmh.runner.options.TimeValue;


@SuppressWarnings(&quot;unused&quot;)
@State(Scope.Benchmark)
<span class="nc" id="L60">public class BenchmarkOfflineIndexReader {</span>
<span class="nc" id="L61">  private static final File TEMP_DIR = new File(FileUtils.getTempDirectory(), &quot;BenchmarkOfflineIndexReader&quot;);</span>
<span class="nc" id="L62">  private static final Random RANDOM = new Random();</span>
<span class="nc" id="L63">  private static final URL RESOURCE_URL =</span>
      ClusterTest.class.getClassLoader().getResource(&quot;On_Time_On_Time_Performance_2014_100k_subset_nonulls.tar.gz&quot;);
  private static final String AVRO_FILE_NAME = &quot;On_Time_On_Time_Performance_2014_1.avro&quot;;
  private static final String TABLE_NAME = &quot;table&quot;;

  // Forward index
  private static final String SV_UNSORTED_COLUMN_NAME = &quot;FlightNum&quot;;
  private static final String SV_SORTED_COLUMN_NAME = &quot;DaysSinceEpoch&quot;;
  private static final String MV_COLUMN_NAME = &quot;DivTailNums&quot;;

  // Dictionary
  private static final int NUM_ROUNDS = 10000;
  private static final String INT_COLUMN_NAME = &quot;DivActualElapsedTime&quot;;
  private static final String LONG_COLUMN_NAME = &quot;DivTotalGTimes&quot;;
  private static final String FLOAT_COLUMN_NAME = &quot;DepDelayMinutes&quot;;
  private static final String DOUBLE_COLUMN_NAME = &quot;DepDelay&quot;;
  private static final String STRING_COLUMN_NAME = &quot;DestCityName&quot;;

  // Forward index
  private int _numDocs;
  private FixedBitSingleValueReader _fixedBitSingleValueReader;
  private SortedIndexReader _sortedForwardIndexReader;
  private FixedBitMultiValueReader _fixedBitMultiValueReader;
  private int[] _buffer;

  // Dictionary
  private IntDictionary _intDictionary;
  private LongDictionary _longDictionary;
  private FloatDictionary _floatDictionary;
  private DoubleDictionary _doubleDictionary;
  private StringDictionary _stringDictionary;

  @Setup
  public void setUp() throws Exception {
<span class="nc" id="L97">    Preconditions.checkNotNull(RESOURCE_URL);</span>
<span class="nc" id="L98">    FileUtils.deleteQuietly(TEMP_DIR);</span>

<span class="nc" id="L100">    File avroDir = new File(TEMP_DIR, &quot;avro&quot;);</span>
<span class="nc" id="L101">    TarGzCompressionUtils.unTar(new File(TestUtils.getFileFromResourceUrl(RESOURCE_URL)), avroDir);</span>
<span class="nc" id="L102">    File avroFile = new File(avroDir, AVRO_FILE_NAME);</span>

<span class="nc" id="L104">    File dataDir = new File(TEMP_DIR, &quot;index&quot;);</span>
<span class="nc" id="L105">    SegmentIndexCreationDriver driver = new SegmentIndexCreationDriverImpl();</span>
<span class="nc" id="L106">    driver.init(SegmentTestUtils.getSegmentGeneratorConfigWithoutTimeColumn(avroFile, dataDir, TABLE_NAME));</span>
<span class="nc" id="L107">    driver.build();</span>

<span class="nc" id="L109">    File indexDir = new File(dataDir, TABLE_NAME);</span>
<span class="nc" id="L110">    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(indexDir);</span>
<span class="nc" id="L111">    SegmentDirectory segmentDirectory = SegmentDirectory.createFromLocalFS(indexDir, segmentMetadata, ReadMode.mmap);</span>
<span class="nc" id="L112">    SegmentDirectory.Reader segmentReader = segmentDirectory.createReader();</span>

    // Forward index
<span class="nc" id="L115">    _numDocs = segmentMetadata.getTotalDocs();</span>
<span class="nc" id="L116">    _fixedBitSingleValueReader =</span>
        new FixedBitSingleValueReader(segmentReader.getIndexFor(SV_UNSORTED_COLUMN_NAME, ColumnIndexType.FORWARD_INDEX),
            _numDocs, segmentMetadata.getColumnMetadataFor(SV_UNSORTED_COLUMN_NAME).getBitsPerElement());
<span class="nc" id="L119">    _sortedForwardIndexReader =</span>
        new SortedIndexReader(segmentReader.getIndexFor(SV_SORTED_COLUMN_NAME, ColumnIndexType.FORWARD_INDEX),
            segmentMetadata.getColumnMetadataFor(SV_SORTED_COLUMN_NAME).getCardinality());
<span class="nc" id="L122">    ColumnMetadata mvColumnMetadata = segmentMetadata.getColumnMetadataFor(MV_COLUMN_NAME);</span>
<span class="nc" id="L123">    _fixedBitMultiValueReader =</span>
        new FixedBitMultiValueReader(segmentReader.getIndexFor(MV_COLUMN_NAME, ColumnIndexType.FORWARD_INDEX), _numDocs,
            mvColumnMetadata.getTotalNumberOfEntries(), mvColumnMetadata.getBitsPerElement());
<span class="nc" id="L126">    _buffer = new int[mvColumnMetadata.getMaxNumberOfMultiValues()];</span>

    // Dictionary
<span class="nc" id="L129">    _intDictionary = new IntDictionary(segmentReader.getIndexFor(INT_COLUMN_NAME, ColumnIndexType.DICTIONARY),</span>
        segmentMetadata.getColumnMetadataFor(INT_COLUMN_NAME).getCardinality());
<span class="nc" id="L131">    _longDictionary = new LongDictionary(segmentReader.getIndexFor(LONG_COLUMN_NAME, ColumnIndexType.DICTIONARY),</span>
        segmentMetadata.getColumnMetadataFor(LONG_COLUMN_NAME).getCardinality());
<span class="nc" id="L133">    _floatDictionary = new FloatDictionary(segmentReader.getIndexFor(FLOAT_COLUMN_NAME, ColumnIndexType.DICTIONARY),</span>
        segmentMetadata.getColumnMetadataFor(FLOAT_COLUMN_NAME).getCardinality());
<span class="nc" id="L135">    _doubleDictionary = new DoubleDictionary(segmentReader.getIndexFor(DOUBLE_COLUMN_NAME, ColumnIndexType.DICTIONARY),</span>
        segmentMetadata.getColumnMetadataFor(DOUBLE_COLUMN_NAME).getCardinality());
<span class="nc" id="L137">    ColumnMetadata stringColumnMetadata = segmentMetadata.getColumnMetadataFor(STRING_COLUMN_NAME);</span>
<span class="nc" id="L138">    _stringDictionary = new StringDictionary(segmentReader.getIndexFor(STRING_COLUMN_NAME, ColumnIndexType.DICTIONARY),</span>
        stringColumnMetadata.getCardinality(), stringColumnMetadata.getStringColumnMaxLength(), (byte) 0);
<span class="nc" id="L140">  }</span>

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int fixedBitSingleValueReader() {
<span class="nc" id="L146">    ReaderContext context = _fixedBitSingleValueReader.createContext();</span>
<span class="nc" id="L147">    int ret = 0;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">    for (int i = 0; i &lt; _numDocs; i++) {</span>
<span class="nc" id="L149">      ret += _fixedBitSingleValueReader.getInt(i, context);</span>
    }
<span class="nc" id="L151">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int sortedForwardIndexReaderSequential() {
<span class="nc" id="L158">    SortedIndexReader.Context context = _sortedForwardIndexReader.createContext();</span>
<span class="nc" id="L159">    int ret = 0;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">    for (int i = 0; i &lt; _numDocs; i++) {</span>
<span class="nc" id="L161">      ret += _sortedForwardIndexReader.getInt(i, context);</span>
    }
<span class="nc" id="L163">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int sortedForwardIndexReaderRandom() {
<span class="nc" id="L170">    SortedIndexReader.Context context = _sortedForwardIndexReader.createContext();</span>
<span class="nc" id="L171">    int ret = 0;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">    for (int i = 0; i &lt; _numDocs; i++) {</span>
<span class="nc" id="L173">      ret += _sortedForwardIndexReader.getInt(RANDOM.nextInt(_numDocs), context);</span>
    }
<span class="nc" id="L175">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int fixedBitMultiValueReaderSequential() {
<span class="nc" id="L182">    FixedBitMultiValueReader.Context context = _fixedBitMultiValueReader.createContext();</span>
<span class="nc" id="L183">    int ret = 0;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">    for (int i = 0; i &lt; _numDocs; i++) {</span>
<span class="nc" id="L185">      ret += _fixedBitMultiValueReader.getIntArray(i, _buffer, context);</span>
    }
<span class="nc" id="L187">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int fixedBitMultiValueReaderRandom() {
<span class="nc" id="L194">    FixedBitMultiValueReader.Context context = _fixedBitMultiValueReader.createContext();</span>
<span class="nc" id="L195">    int ret = 0;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">    for (int i = 0; i &lt; _numDocs; i++) {</span>
<span class="nc" id="L197">      ret += _fixedBitMultiValueReader.getIntArray(RANDOM.nextInt(_numDocs), _buffer, context);</span>
    }
<span class="nc" id="L199">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public double intDictionary() {
<span class="nc" id="L206">    int length = _intDictionary.length();</span>
<span class="nc" id="L207">    int ret = 0;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ROUNDS; i++) {</span>
<span class="nc" id="L209">      int value = _intDictionary.getIntValue(RANDOM.nextInt(length));</span>
<span class="nc" id="L210">      ret += _intDictionary.indexOf(value);</span>
    }
<span class="nc" id="L212">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int longDictionary() {
<span class="nc" id="L219">    int length = _longDictionary.length();</span>
<span class="nc" id="L220">    int ret = 0;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ROUNDS; i++) {</span>
<span class="nc" id="L222">      long value = _longDictionary.getLongValue(RANDOM.nextInt(length));</span>
<span class="nc" id="L223">      ret += _longDictionary.indexOf(value);</span>
    }
<span class="nc" id="L225">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int floatDictionary() {
<span class="nc" id="L232">    int length = _floatDictionary.length();</span>
<span class="nc" id="L233">    int ret = 0;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ROUNDS; i++) {</span>
<span class="nc" id="L235">      float value = _floatDictionary.getFloatValue(RANDOM.nextInt(length));</span>
<span class="nc" id="L236">      ret += _floatDictionary.indexOf(value);</span>
    }
<span class="nc" id="L238">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int doubleDictionary() {
<span class="nc" id="L245">    int length = _doubleDictionary.length();</span>
<span class="nc" id="L246">    int ret = 0;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ROUNDS; i++) {</span>
<span class="nc" id="L248">      double value = _doubleDictionary.getDoubleValue(RANDOM.nextInt(length));</span>
<span class="nc" id="L249">      ret += _doubleDictionary.indexOf(value);</span>
    }
<span class="nc" id="L251">    return ret;</span>
  }

  @Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  public int stringDictionary() {
<span class="nc" id="L258">    int length = _stringDictionary.length();</span>
<span class="nc" id="L259">    int ret = 0;</span>
<span class="nc" id="L260">    int[] dictIds = new int[NUM_ROUNDS];</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ROUNDS; i++) {</span>
<span class="nc" id="L262">      int dictId = RANDOM.nextInt(length);</span>
<span class="nc" id="L263">      String value = _stringDictionary.getStringValue(dictId);</span>
<span class="nc" id="L264">      ret += _stringDictionary.indexOf(value);</span>
<span class="nc" id="L265">      dictIds[i] = dictId;</span>
    }
<span class="nc" id="L267">    String[] outValues = new String[NUM_ROUNDS];</span>
<span class="nc" id="L268">    _stringDictionary.readStringValues(dictIds, 0, NUM_ROUNDS, outValues, 0);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ROUNDS; i++) {</span>
<span class="nc" id="L270">      ret += outValues[0].length();</span>
    }
<span class="nc" id="L272">    return ret;</span>
  }

  @TearDown
  public void tearDown() {
<span class="nc" id="L277">    _fixedBitSingleValueReader.close();</span>
<span class="nc" id="L278">    _sortedForwardIndexReader.close();</span>
<span class="nc" id="L279">    _fixedBitMultiValueReader.close();</span>
<span class="nc" id="L280">    _intDictionary.close();</span>
<span class="nc" id="L281">    _longDictionary.close();</span>
<span class="nc" id="L282">    _floatDictionary.close();</span>
<span class="nc" id="L283">    _doubleDictionary.close();</span>
<span class="nc" id="L284">    _stringDictionary.close();</span>

<span class="nc" id="L286">    FileUtils.deleteQuietly(TEMP_DIR);</span>
<span class="nc" id="L287">  }</span>

  public static void main(String[] args) throws Exception {
<span class="nc" id="L290">    Options opt = new OptionsBuilder().include(BenchmarkOfflineIndexReader.class.getSimpleName())</span>
        .warmupTime(TimeValue.seconds(5))
        .warmupIterations(2)
        .measurementTime(TimeValue.seconds(5))
        .measurementIterations(3)
        .forks(1)
        .build();

<span class="nc" id="L298">    new Runner(opt).run();</span>
<span class="nc" id="L299">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>