<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FilterOperatorBenchmark.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-perf</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.perf</a> &gt; <span class="el_source">FilterOperatorBenchmark.java</span></div><h1>FilterOperatorBenchmark.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.perf;

import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.segment.ReadMode;
import com.linkedin.pinot.core.common.Block;
import com.linkedin.pinot.core.common.BlockDocIdIterator;
import com.linkedin.pinot.core.common.BlockDocIdSet;
import com.linkedin.pinot.core.common.Constants;
import com.linkedin.pinot.core.common.Operator;
import com.linkedin.pinot.core.indexsegment.IndexSegment;
import com.linkedin.pinot.core.indexsegment.columnar.ColumnarSegmentLoader;
import com.linkedin.pinot.core.plan.FilterPlanNode;
import com.linkedin.pinot.core.segment.index.IndexSegmentImpl;
import com.linkedin.pinot.core.segment.index.loader.IndexLoadingConfig;
import com.linkedin.pinot.pql.parsers.Pql2Compiler;
import java.io.File;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.log4j.Level;

/**
 * Allows us to benchmark filter operator in isolation
 * USAGE FilterOperatorBenchmark &amp;lt;IndexRootDir&amp;gt; &amp;lt;Query&amp;gt;
 */
<span class="nc" id="L49">public class FilterOperatorBenchmark {</span>
  static {
<span class="nc" id="L51">    org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);</span>
<span class="nc" id="L52">  }</span>

  public static void main(String[] args) throws Exception {
<span class="nc" id="L55">    String rootDir = args[0];</span>
<span class="nc" id="L56">    File[] segmentDirs = new File(rootDir).listFiles();</span>
<span class="nc" id="L57">    String query = args[1];</span>
<span class="nc" id="L58">    AtomicInteger totalDocsMatched = new AtomicInteger(0);</span>
<span class="nc" id="L59">    Pql2Compiler pql2Compiler = new Pql2Compiler();</span>
<span class="nc" id="L60">    BrokerRequest brokerRequest = pql2Compiler.compileToBrokerRequest(query);</span>
<span class="nc" id="L61">    List&lt;Callable&lt;Void&gt;&gt; segmentProcessors = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L62">    long[] timesSpent = new long[segmentDirs.length];</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">    for (int i = 0; i &lt; segmentDirs.length; i++) {</span>
<span class="nc" id="L64">      File indexSegmentDir = segmentDirs[i];</span>
<span class="nc" id="L65">      System.out.println(&quot;Loading &quot; + indexSegmentDir.getName());</span>

<span class="nc" id="L67">      Set&lt;String&gt; invertedColumns = new HashSet&lt;&gt;();</span>
<span class="nc" id="L68">      String[] indexFiles = indexSegmentDir.list(new FilenameFilter() {</span>
        @Override
        public boolean accept(File dir, String name) {
<span class="nc" id="L71">          return name.endsWith(&quot;.bitmap.inv&quot;);</span>
        }
      });
<span class="nc bnc" id="L74" title="All 2 branches missed.">      for (String indexFileName : indexFiles) {</span>
<span class="nc" id="L75">        invertedColumns.add(indexFileName.replace(&quot;.bitmap.inv&quot;, &quot;&quot;));</span>
      }
<span class="nc" id="L77">      IndexLoadingConfig indexLoadingConfig = new IndexLoadingConfig();</span>
<span class="nc" id="L78">      indexLoadingConfig.setReadMode(ReadMode.heap);</span>
<span class="nc" id="L79">      indexLoadingConfig.setInvertedIndexColumns(invertedColumns);</span>

<span class="nc" id="L81">      IndexSegmentImpl indexSegmentImpl =</span>
          (IndexSegmentImpl) ColumnarSegmentLoader.load(indexSegmentDir, indexLoadingConfig);
<span class="nc" id="L83">      segmentProcessors.add(new SegmentProcessor(i, indexSegmentImpl, brokerRequest,</span>
          totalDocsMatched, timesSpent));
    }
<span class="nc" id="L86">    ExecutorService executorService = Executors.newCachedThreadPool();</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    for (int run = 0; run &lt; 5; run++) {</span>
<span class="nc" id="L88">      System.out.println(&quot;START RUN:&quot;+ run );</span>
<span class="nc" id="L89">      totalDocsMatched.set(0);</span>
<span class="nc" id="L90">      long start = System.currentTimeMillis();</span>
<span class="nc" id="L91">      List&lt;Future&lt;Void&gt;&gt; futures = executorService.invokeAll(segmentProcessors);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">      for (int i = 0; i &lt; futures.size(); i++) {</span>
<span class="nc" id="L93">        futures.get(i).get();</span>
      }
<span class="nc" id="L95">      long end = System.currentTimeMillis();</span>
<span class="nc" id="L96">      System.out.println(&quot;Total docs matched:&quot; + totalDocsMatched + &quot; took:&quot; + (end - start));</span>
<span class="nc" id="L97">      System.out.println(&quot;Times spent:&quot; + Arrays.toString(timesSpent));</span>
<span class="nc" id="L98">      System.out.println(&quot;END RUN:&quot;+ run );</span>
    }
<span class="nc" id="L100">    System.exit(0);</span>
<span class="nc" id="L101">  }</span>

<span class="nc" id="L103">  public static class SegmentProcessor implements Callable&lt;Void&gt; {</span>
    private IndexSegment indexSegmentImpl;
    private BrokerRequest brokerRequest;
    AtomicInteger totalDocsMatched;
    private long[] timesSpent;
    private int id;

    public SegmentProcessor(int id, IndexSegment indexSegmentImpl, BrokerRequest brokerRequest,
         AtomicInteger totalDocsMatched, long[] timesSpent) {
<span class="nc" id="L112">      super();</span>
<span class="nc" id="L113">      this.id = id;</span>
<span class="nc" id="L114">      this.indexSegmentImpl = indexSegmentImpl;</span>
<span class="nc" id="L115">      this.brokerRequest = brokerRequest;</span>
<span class="nc" id="L116">      this.totalDocsMatched = totalDocsMatched;</span>
<span class="nc" id="L117">      this.timesSpent = timesSpent;</span>
<span class="nc" id="L118">    }</span>

<span class="nc" id="L120">    int[] docIds = new int[10000];</span>
<span class="nc" id="L121">    int[] dictIds = new int[10000];</span>
<span class="nc" id="L122">    long[] values = new long[10000];</span>

    public Void call() {
      long start, end;
<span class="nc" id="L126">      start = System.currentTimeMillis();</span>
<span class="nc" id="L127">      FilterPlanNode planNode = new FilterPlanNode(indexSegmentImpl, brokerRequest);</span>
<span class="nc" id="L128">      Operator filterOperator = planNode.run();</span>
<span class="nc" id="L129">      Block block = filterOperator.nextBlock();</span>
<span class="nc" id="L130">      BlockDocIdSet filteredDocIdSet = block.getBlockDocIdSet();</span>
<span class="nc" id="L131">      BlockDocIdIterator iterator = filteredDocIdSet.iterator();</span>
      int docId;
<span class="nc" id="L133">      int matchedCount = 0;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      while ((docId = iterator.next()) != Constants.EOF) {</span>
<span class="nc" id="L135">        matchedCount = matchedCount + 1;</span>
        /* Sample ode to print a particular column from matched records
        {
          final String columnName = &quot;someColumn&quot;;
          BlockSingleValIterator it =
              (BlockSingleValIterator) indexSegmentImpl.getDataSource(columnName).getNextBlock().getBlockValueSet()
                  .iterator();
          it.skipTo(docId);
          int dictId = it.nextIntVal();  // dict id
          // get the dictionary and use this dictionary id to get the value
          System.out.println(&quot;Segment &quot; + indexSegmentImpl.getSegmentName() + &quot; &quot; + columnName + &quot; &quot; + indexSegmentImpl
              .getDataSource(columnName).getDictionary().get(dictId));
        }
        */
      }


<span class="nc" id="L152">      end = System.currentTimeMillis();</span>
<span class="nc" id="L153">      timesSpent[id] = (end - start);</span>
<span class="nc" id="L154">      totalDocsMatched.addAndGet(matchedCount);</span>
<span class="nc" id="L155">      return null;</span>
    }

  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>