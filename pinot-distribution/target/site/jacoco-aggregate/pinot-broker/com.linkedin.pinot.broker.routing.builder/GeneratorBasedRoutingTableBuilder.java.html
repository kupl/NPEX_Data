<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>GeneratorBasedRoutingTableBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-broker</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.broker.routing.builder</a> &gt; <span class="el_source">GeneratorBasedRoutingTableBuilder.java</span></div><h1>GeneratorBasedRoutingTableBuilder.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.linkedin.pinot.broker.routing.builder;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.helix.model.ExternalView;
import org.apache.helix.model.InstanceConfig;


/**
 * Routing table builder that uses a random routing table generator to create multiple routing tables. See a more
 * detailed explanation of the algorithm in {@link KafkaLowLevelConsumerRoutingTableBuilder} and
 * {@link LargeClusterRoutingTableBuilder}.
 */
<span class="fc" id="L38">public abstract class GeneratorBasedRoutingTableBuilder extends BaseRoutingTableBuilder {</span>

  /** Number of routing tables to keep */
  protected static final int ROUTING_TABLE_COUNT = 500;

  /** Number of routing tables to generate during the optimization phase */
  protected static final int ROUTING_TABLE_GENERATION_COUNT = 1000;

  /**
   * Generates a routing table, decorated with a metric.
   *
   * @param routingTableGenerator The routing table generator to use to generate routing tables.
   * @return A pair of a routing table and its associated metric.
   */
  private Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt; generateRoutingTableWithMetric(
      RoutingTableGenerator routingTableGenerator) {
<span class="fc" id="L54">    Map&lt;String, List&lt;String&gt;&gt; routingTable = routingTableGenerator.generateRoutingTable();</span>
<span class="fc" id="L55">    int segmentCount = 0;</span>
<span class="fc" id="L56">    int serverCount = 0;</span>

    // Compute the number of segments and servers (for the average part of the variance)
<span class="fc bfc" id="L59" title="All 2 branches covered.">    for (List&lt;String&gt; segmentsForServer : routingTable.values()) {</span>
<span class="fc" id="L60">      int segmentCountForServer = segmentsForServer.size();</span>
<span class="fc" id="L61">      segmentCount += segmentCountForServer;</span>
<span class="fc" id="L62">      serverCount++;</span>
<span class="fc" id="L63">    }</span>

    // Compute the variance of the number of segments allocated per server
<span class="fc" id="L66">    float averageSegmentCount = ((float) segmentCount) / serverCount;</span>
<span class="fc" id="L67">    float variance = 0.0f;</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">    for (List&lt;String&gt; segmentsForServer : routingTable.values()) {</span>
<span class="fc" id="L69">      int segmentCountForServer = segmentsForServer.size();</span>
<span class="fc" id="L70">      float difference = segmentCountForServer - averageSegmentCount;</span>
<span class="fc" id="L71">      variance += difference * difference;</span>
<span class="fc" id="L72">    }</span>

<span class="fc" id="L74">    return new ImmutablePair&lt;&gt;(routingTable, variance);</span>
  }

  protected interface RoutingTableGenerator {
    void init(ExternalView externalView, List&lt;InstanceConfig&gt; instanceConfigList);

    Map&lt;String, List&lt;String&gt;&gt; generateRoutingTable();
  }

<span class="fc" id="L83">  protected abstract class BaseRoutingTableGenerator implements RoutingTableGenerator {</span>
    private final int _targetNumServersPerQuery;

<span class="fc" id="L86">    public BaseRoutingTableGenerator(int targetNumServersPerQuery) {</span>
<span class="fc" id="L87">      _targetNumServersPerQuery = targetNumServersPerQuery;</span>
<span class="fc" id="L88">    }</span>

    /**
     * Get the map from segment to list of servers that are serving it.
     */
    protected abstract Map&lt;String, List&lt;String&gt;&gt; getSegmentToServersMap();

    public Map&lt;String, List&lt;String&gt;&gt; generateRoutingTable() {
<span class="fc" id="L96">      Map&lt;String, List&lt;String&gt;&gt; routingTable = new HashMap&lt;&gt;();</span>

<span class="fc" id="L98">      Map&lt;String, List&lt;String&gt;&gt; segmentToServersMap = getSegmentToServersMap();</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">      if (segmentToServersMap.isEmpty()) {</span>
<span class="nc" id="L100">        return routingTable;</span>
      }

      // Construct the map from server to list of segments
<span class="fc" id="L104">      Map&lt;String, List&lt;String&gt;&gt; serverToSegmentsMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">      for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : segmentToServersMap.entrySet()) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (String serverName : entry.getValue()) {</span>
<span class="fc" id="L107">          List&lt;String&gt; segmentsForServer = serverToSegmentsMap.get(serverName);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">          if (segmentsForServer == null) {</span>
<span class="fc" id="L109">            segmentsForServer = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L110">            serverToSegmentsMap.put(serverName, segmentsForServer);</span>
          }
<span class="fc" id="L112">          segmentsForServer.add(entry.getKey());</span>
<span class="fc" id="L113">        }</span>
<span class="fc" id="L114">      }</span>

<span class="fc" id="L116">      int numSegments = segmentToServersMap.size();</span>
<span class="fc" id="L117">      List&lt;String&gt; servers = new ArrayList&lt;&gt;(serverToSegmentsMap.keySet());</span>
<span class="fc" id="L118">      int numServers = servers.size();</span>

      // Set of segments that have no instance serving them
<span class="fc" id="L121">      Set&lt;String&gt; segmentsNotHandledByServers = new HashSet&lt;&gt;(segmentToServersMap.keySet());</span>

      // Set of servers in this routing table
<span class="fc" id="L124">      Set&lt;String&gt; serversInRoutingTable = new HashSet&lt;&gt;(_targetNumServersPerQuery);</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">      if (numServers &lt;= _targetNumServersPerQuery) {</span>
        // If there are not enough instances, add them all
<span class="fc" id="L128">        serversInRoutingTable.addAll(servers);</span>
<span class="fc" id="L129">        segmentsNotHandledByServers.clear();</span>
      } else {
        // Otherwise add _targetNumServersPerQuery instances
<span class="fc bfc" id="L132" title="All 2 branches covered.">        while (serversInRoutingTable.size() &lt; _targetNumServersPerQuery) {</span>
<span class="fc" id="L133">          String randomServer = servers.get(_random.nextInt(numServers));</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">          if (!serversInRoutingTable.contains(randomServer)) {</span>
<span class="fc" id="L135">            serversInRoutingTable.add(randomServer);</span>
<span class="fc" id="L136">            segmentsNotHandledByServers.removeAll(serverToSegmentsMap.get(randomServer));</span>
          }
<span class="fc" id="L138">        }</span>
      }

      // If there are segments that have no instance that can serve them, add a server to serve them
<span class="fc bfc" id="L142" title="All 2 branches covered.">      while (!segmentsNotHandledByServers.isEmpty()) {</span>
<span class="fc" id="L143">        String segmentNotHandledByServers = segmentsNotHandledByServers.iterator().next();</span>

        // Pick a random server that can serve this segment
<span class="fc" id="L146">        List&lt;String&gt; serversForSegment = segmentToServersMap.get(segmentNotHandledByServers);</span>
<span class="fc" id="L147">        String randomServer = serversForSegment.get(_random.nextInt(serversForSegment.size()));</span>
<span class="fc" id="L148">        serversInRoutingTable.add(randomServer);</span>
<span class="fc" id="L149">        segmentsNotHandledByServers.removeAll(serverToSegmentsMap.get(randomServer));</span>
<span class="fc" id="L150">      }</span>

      // Sort all the segments to be used during assignment in ascending order of replicas
<span class="fc" id="L153">      PriorityQueue&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt; segmentToReplicaSetQueue =</span>
<span class="fc" id="L154">          new PriorityQueue&lt;&gt;(numSegments, new Comparator&lt;Pair&lt;String, List&lt;String&gt;&gt;&gt;() {</span>
            @Override
            public int compare(Pair&lt;String, List&lt;String&gt;&gt; firstPair, Pair&lt;String, List&lt;String&gt;&gt; secondPair) {
<span class="fc" id="L157">              return Integer.compare(firstPair.getRight().size(), secondPair.getRight().size());</span>
            }
          });

<span class="fc bfc" id="L161" title="All 2 branches covered.">      for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : segmentToServersMap.entrySet()) {</span>
        // Servers for the segment is the intersection of all servers for this segment and the servers that we have in
        // this routing table
<span class="fc" id="L164">        List&lt;String&gt; serversForSegment = new ArrayList&lt;&gt;(entry.getValue());</span>
<span class="fc" id="L165">        serversForSegment.retainAll(serversInRoutingTable);</span>

<span class="fc" id="L167">        segmentToReplicaSetQueue.add(new ImmutablePair&lt;&gt;(entry.getKey(), serversForSegment));</span>
<span class="fc" id="L168">      }</span>

      // Assign each segment to a server
      Pair&lt;String, List&lt;String&gt;&gt; segmentServersPair;
<span class="fc bfc" id="L172" title="All 2 branches covered.">      while ((segmentServersPair = segmentToReplicaSetQueue.poll()) != null) {</span>
<span class="fc" id="L173">        String segmentName = segmentServersPair.getLeft();</span>
<span class="fc" id="L174">        List&lt;String&gt; serversForSegment = segmentServersPair.getRight();</span>

<span class="fc" id="L176">        String serverWithLeastSegmentsAssigned = getServerWithLeastSegmentsAssigned(serversForSegment, routingTable);</span>
<span class="fc" id="L177">        List&lt;String&gt; segmentsAssignedToServer = routingTable.get(serverWithLeastSegmentsAssigned);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (segmentsAssignedToServer == null) {</span>
<span class="nc" id="L179">          segmentsAssignedToServer = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L180">          routingTable.put(serverWithLeastSegmentsAssigned, segmentsAssignedToServer);</span>
        }
<span class="fc" id="L182">        segmentsAssignedToServer.add(segmentName);</span>
<span class="fc" id="L183">      }</span>

<span class="fc" id="L185">      return routingTable;</span>
    }

    /*
    The weighted random selection logic for reference
    This can be used to replace getServerWithLeastSegmentsAssigned()

    private String pickWeightedRandomReplica(Set&lt;String&gt; validReplicaSet,
        Map&lt;String, Set&lt;String&gt;&gt; instanceToSegmentSetMap, Random random) {

      // No replicas?
      if (validReplicaSet.isEmpty()) {
        return null;
      }

      // Only one valid replica?
      if (validReplicaSet.size() == 1) {
        return validReplicaSet.iterator().next();
      }

      // Find maximum segment count assigned to a replica
      String[] replicas = validReplicaSet.toArray(new String[validReplicaSet.size()]);
      int[] replicaSegmentCounts = new int[validReplicaSet.size()];

      int maxSegmentCount = 0;
      for (int i = 0; i &lt; replicas.length; i++) {
        String replica = replicas[i];
        int replicaSegmentCount = 0;

        if (instanceToSegmentSetMap.containsKey(replica)) {
          replicaSegmentCount = instanceToSegmentSetMap.get(replica).size();
        }

        replicaSegmentCounts[i] = replicaSegmentCount;

        if (maxSegmentCount &lt; replicaSegmentCount) {
          maxSegmentCount = replicaSegmentCount;
        }
      }

      // Compute replica weights
      int[] replicaWeights = new int[validReplicaSet.size()];
      int totalReplicaWeights = 0;
      for (int i = 0; i &lt; replicas.length; i++) {
        int replicaWeight = maxSegmentCount - replicaSegmentCounts[i];
        replicaWeights[i] = replicaWeight;
        totalReplicaWeights += replicaWeight;
      }

      // If all replicas are equal, just pick a random replica
      if (totalReplicaWeights == 0) {
        return replicas[random.nextInt(replicas.length)];
      }

      // Pick the proper replica given their respective weights
      int randomValue = random.nextInt(totalReplicaWeights);
      int i = 0;
      while(replicaWeights[i] == 0 || replicaWeights[i] &lt;= randomValue) {
        randomValue -= replicaWeights[i];
        ++i;
      }

      return replicas[i];
    }
    */
  }

  protected abstract RoutingTableGenerator buildRoutingTableGenerator();

  @Override
  public void computeRoutingTableFromExternalView(String tableName, ExternalView externalView,
      List&lt;InstanceConfig&gt; instanceConfigs) {
    // The default routing table algorithm tries to balance all available segments across all servers, so that each
    // server is hit on every query. This works fine with small clusters (say less than 20 servers) but for larger
    // clusters, this adds up to significant overhead (one request must be enqueued for each server, processed,
    // returned, deserialized, aggregated, etc.).
    //
    // For large clusters, we want to avoid hitting every server, as this also has an adverse effect on client tail
    // latency. This is due to the fact that a query cannot return until it has received a response from each server,
    // and the greater the number of servers that are hit, the more likely it is that one of the servers will be a
    // straggler (eg. due to contention for query processing threads, GC, etc.). We also want to balance the segments
    // within any given routing table so that each server in the routing table has approximately the same number of
    // segments to process.
    //
    // To do so, we have a routing table generator that generates routing tables by picking a random subset of servers.
    // With this set of servers, we check if the set of segments served by these servers is complete. If the set of
    // segments served does not cover all of the segments, we compute the list of missing segments and pick a random
    // server that serves these missing segments until we have complete coverage of all the segments.
    //
    // We then order the segments in ascending number of replicas within our server set, in order to allocate the
    // segments with fewer replicas first. This ensures that segments that are 'easier' to allocate are more likely to
    // end up on a server with fewer segments.
    //
    // Then, we pick a server with least segments already assigned for each segment. This ensures that we build a
    // routing table that's as even as possible.
    //
    // The algorithm to generate a routing table is thus:
    // 1. Compute the inverse external view, a mapping of servers to segments
    // 2. For each routing table to generate:
    //   a) Pick _targetNumServersPerQuery distinct servers
    //   b) Check if the server set covers all the segments; if not, add additional servers until it does
    //   c) Order the segments in our server set in ascending order of number of replicas present in our server set
    //   d) For each segment, pick a server with least segments already assigned
    //   e) Return that routing table
    //
    // Given that we can generate routing tables at will, we then generate many routing tables and use them to optimize
    // according to two criteria: the variance in workload per server for any individual table as well as the variance
    // in workload per server across all the routing tables. To do so, we generate an initial set of routing tables
    // according to a per-routing table metric and discard the worst routing tables.

<span class="fc" id="L295">    RoutingTableGenerator routingTableGenerator = buildRoutingTableGenerator();</span>
<span class="fc" id="L296">    routingTableGenerator.init(externalView, instanceConfigs);</span>

<span class="fc" id="L298">    PriorityQueue&lt;Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt;&gt; topRoutingTables =</span>
<span class="fc" id="L299">        new PriorityQueue&lt;&gt;(ROUTING_TABLE_COUNT, new Comparator&lt;Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt;&gt;() {</span>
          @Override
          public int compare(Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt; left,
              Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt; right) {
            // Float.compare sorts in ascending order and we want a max heap, so we need to return the negative of the comparison
<span class="fc" id="L304">            return -Float.compare(left.getValue(), right.getValue());</span>
          }
        });

<span class="fc bfc" id="L308" title="All 2 branches covered.">    for (int i = 0; i &lt; ROUTING_TABLE_COUNT; i++) {</span>
<span class="fc" id="L309">      topRoutingTables.add(generateRoutingTableWithMetric(routingTableGenerator));</span>
    }

    // Generate routing more tables and keep the ROUTING_TABLE_COUNT top ones
<span class="fc bfc" id="L313" title="All 2 branches covered.">    for (int i = 0; i &lt; (ROUTING_TABLE_GENERATION_COUNT - ROUTING_TABLE_COUNT); ++i) {</span>
<span class="fc" id="L314">      Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt; newRoutingTable = generateRoutingTableWithMetric(routingTableGenerator);</span>
<span class="fc" id="L315">      Pair&lt;Map&lt;String, List&lt;String&gt;&gt;, Float&gt; worstRoutingTable = topRoutingTables.peek();</span>

      // If the new routing table is better than the worst one, keep it
<span class="fc bfc" id="L318" title="All 2 branches covered.">      if (newRoutingTable.getRight() &lt; worstRoutingTable.getRight()) {</span>
<span class="fc" id="L319">        topRoutingTables.poll();</span>
<span class="fc" id="L320">        topRoutingTables.add(newRoutingTable);</span>
      }
    }

    // Return the best routing tables
<span class="fc" id="L325">    List&lt;Map&lt;String, List&lt;String&gt;&gt;&gt; routingTables = new ArrayList&lt;&gt;(topRoutingTables.size());</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">    while (!topRoutingTables.isEmpty()) {</span>
<span class="fc" id="L327">      routingTables.add(topRoutingTables.poll().getKey());</span>
    }

<span class="fc" id="L330">    setRoutingTables(routingTables);</span>
<span class="fc" id="L331">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>