<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StarTreeQueryGenerator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-tools</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.tools.query.comparison</a> &gt; <span class="el_source">StarTreeQueryGenerator.java</span></div><h1>StarTreeQueryGenerator.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.tools.query.comparison;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.segment.ReadMode;
import com.linkedin.pinot.common.segment.SegmentMetadata;
import com.linkedin.pinot.common.utils.request.RequestUtils;
import com.linkedin.pinot.core.indexsegment.IndexSegment;
import com.linkedin.pinot.core.segment.index.loader.Loaders;
import com.linkedin.pinot.pql.parsers.Pql2Compiler;
import java.io.File;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;


/**
 * Given a list of dimension and metric columns, and possible values for dimension columns:
 * Generate queries of the form: SELECT SUM(m1), SUM(m2)... WHERE d1='v1' AND d2='v2'... GROUP BY d3,d4...
 */
public class StarTreeQueryGenerator {
  private static final String SELECT = &quot;SELECT &quot;;
  private static final String FROM = &quot; FROM &quot;;
  private static final String WHERE = &quot; WHERE &quot;;
  private static final String GROUP_BY = &quot; GROUP BY &quot;;
  private static final String BETWEEN = &quot; BETWEEN &quot;;
  private static final String IN = &quot; IN &quot;;
  private static final String NOT_IN = &quot; NOT IN &quot;;
  private static final String AND = &quot; AND &quot;;

  private static final int MAX_NUM_AGGREGATIONS = 5;
  private static final int MAX_NUM_PREDICATES = 10;
  private static final int MAX_NUM_GROUP_BYS = 3;
  private static final int MAX_NUM_IN_VALUES = 5;
  private static final int SHUFFLE_THRESHOLD = 5 * MAX_NUM_IN_VALUES;
<span class="nc" id="L55">  private static final Random RANDOM = new Random();</span>
  // Add more functions here to generate them in the queries.
<span class="nc" id="L57">  private static final List&lt;String&gt; AGGREGATION_FUNCTIONS = Collections.singletonList(&quot;SUM&quot;);</span>
  // Add more comparators here to generate them in the 'WHERE' clause.
<span class="nc" id="L59">  private static final List&lt;String&gt; COMPARATORS = Arrays.asList(&quot;=&quot;, &quot;&lt;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;);</span>

  private final String _tableName;
  private final List&lt;String&gt; _singleValueDimensionColumns;
  private final List&lt;String&gt; _metricColumns;
  private final Map&lt;String, List&lt;Object&gt;&gt; _singleValueDimensionValuesMap;


  public StarTreeQueryGenerator(String tableName, List&lt;String&gt; singleValueDimensionColumns, List&lt;String&gt; metricColumns,
<span class="nc" id="L68">      Map&lt;String, List&lt;Object&gt;&gt; singleValueDimensionValuesMap) {</span>
<span class="nc" id="L69">    _tableName = tableName;</span>
<span class="nc" id="L70">    _singleValueDimensionColumns = singleValueDimensionColumns;</span>
<span class="nc" id="L71">    _metricColumns = metricColumns;</span>
<span class="nc" id="L72">    _singleValueDimensionValuesMap = singleValueDimensionValuesMap;</span>
<span class="nc" id="L73">  }</span>

  /**
   * Generate one aggregation function for the given metric column.
   *
   * @param metricColumn metric column.
   * @return aggregation function.
   */
  private StringBuilder generateAggregation(String metricColumn) {
<span class="nc" id="L82">    StringBuilder stringBuilder =</span>
        new StringBuilder(AGGREGATION_FUNCTIONS.get(RANDOM.nextInt(AGGREGATION_FUNCTIONS.size())));
<span class="nc" id="L84">    return stringBuilder.append('(').append(metricColumn).append(')');</span>
  }

  /**
   * Generate the aggregation section of the query, returns at least one aggregation.
   *
   * @return aggregation section.
   */
  private StringBuilder generateAggregations() {
<span class="nc" id="L93">    StringBuilder stringBuilder = new StringBuilder();</span>

<span class="nc" id="L95">    int numAggregations = Math.min(RANDOM.nextInt(MAX_NUM_AGGREGATIONS) + 1, _metricColumns.size());</span>
<span class="nc" id="L96">    Collections.shuffle(_metricColumns);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">    for (int i = 0; i &lt; numAggregations; i++) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">      if (i != 0) {</span>
<span class="nc" id="L99">        stringBuilder.append(',').append(' ');</span>
      }
<span class="nc" id="L101">      stringBuilder.append(generateAggregation(_metricColumns.get(i)));</span>
    }

<span class="nc" id="L104">    return stringBuilder;</span>
  }

  /**
   * Generate a comparison predicate for the given dimension column.
   *
   * @param dimensionColumn dimension column.
   * @return comparison predicate.
   */
  private StringBuilder generateComparisonPredicate(String dimensionColumn) {
<span class="nc" id="L114">    StringBuilder stringBuilder = new StringBuilder(dimensionColumn);</span>

<span class="nc" id="L116">    stringBuilder.append(' ').append(COMPARATORS.get(RANDOM.nextInt(COMPARATORS.size()))).append(' ');</span>

<span class="nc" id="L118">    List&lt;Object&gt; valueArray = _singleValueDimensionValuesMap.get(dimensionColumn);</span>
<span class="nc" id="L119">    Object value = valueArray.get(RANDOM.nextInt(valueArray.size()));</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">    if (value instanceof String) {</span>
<span class="nc" id="L121">      stringBuilder.append('\'').append(((String) value).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
    } else {
<span class="nc" id="L123">      stringBuilder.append(value);</span>
    }

<span class="nc" id="L126">    return stringBuilder;</span>
  }

  /**
   * Generate a between predicate for the given dimension column.
   *
   * @param dimensionColumn dimension column.
   * @return between predicate.
   */
  private StringBuilder generateBetweenPredicate(String dimensionColumn) {
<span class="nc" id="L136">    StringBuilder stringBuilder = new StringBuilder(dimensionColumn).append(BETWEEN);</span>

<span class="nc" id="L138">    List&lt;Object&gt; valueArray = _singleValueDimensionValuesMap.get(dimensionColumn);</span>
<span class="nc" id="L139">    Object value1 = valueArray.get(RANDOM.nextInt(valueArray.size()));</span>
<span class="nc" id="L140">    Object value2 = valueArray.get(RANDOM.nextInt(valueArray.size()));</span>

<span class="nc bnc" id="L142" title="All 8 branches missed.">    Preconditions.checkState((value1 instanceof String &amp;&amp; value2 instanceof String)</span>
        || (value1 instanceof Number &amp;&amp; value2 instanceof Number));

<span class="nc bnc" id="L145" title="All 2 branches missed.">    if (value1 instanceof String) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">      if (((String) value1).compareTo((String) value2) &lt; 0) {</span>
<span class="nc" id="L147">        stringBuilder.append('\'').append(((String) value1).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
<span class="nc" id="L148">        stringBuilder.append(AND);</span>
<span class="nc" id="L149">        stringBuilder.append('\'').append(((String) value2).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
      } else {
<span class="nc" id="L151">        stringBuilder.append('\'').append(((String) value2).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
<span class="nc" id="L152">        stringBuilder.append(AND);</span>
<span class="nc" id="L153">        stringBuilder.append('\'').append(((String) value1).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
      }
    } else {
<span class="nc bnc" id="L156" title="All 2 branches missed.">      if (((Number) value1).doubleValue() &lt; ((Number) value2).doubleValue()) {</span>
<span class="nc" id="L157">        stringBuilder.append(value1).append(AND).append(value2);</span>
      } else {
<span class="nc" id="L159">        stringBuilder.append(value2).append(AND).append(value1);</span>
      }
    }

<span class="nc" id="L163">    return stringBuilder;</span>
  }

  /**
   * Generate a in predicate for the given dimension column.
   *
   * @param dimensionColumn dimension column.
   * @return in predicate.
   */
  private StringBuilder generateInPredicate(String dimensionColumn) {
<span class="nc" id="L173">    StringBuilder stringBuilder = new StringBuilder(dimensionColumn);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    if (RANDOM.nextBoolean()) {</span>
<span class="nc" id="L175">      stringBuilder.append(IN).append('(');</span>
    } else {
<span class="nc" id="L177">      stringBuilder.append(NOT_IN).append('(');</span>
    }

<span class="nc" id="L180">    List&lt;Object&gt; valueArray = _singleValueDimensionValuesMap.get(dimensionColumn);</span>
<span class="nc" id="L181">    int size = valueArray.size();</span>
<span class="nc" id="L182">    int numValues = Math.min(RANDOM.nextInt(MAX_NUM_IN_VALUES) + 1, size);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (size &lt; SHUFFLE_THRESHOLD) {</span>
      // For smaller size values, use shuffle strategy.
<span class="nc" id="L185">      Collections.shuffle(valueArray);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">      for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (i != 0) {</span>
<span class="nc" id="L188">          stringBuilder.append(',').append(' ');</span>
        }
<span class="nc" id="L190">        Object value = valueArray.get(i);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (value instanceof String) {</span>
<span class="nc" id="L192">          stringBuilder.append('\'').append(((String) value).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
        } else {
<span class="nc" id="L194">          stringBuilder.append(value);</span>
        }
      }
    } else {
      // For larger size values, use random indices strategy.
<span class="nc" id="L199">      Set&lt;Integer&gt; indices = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      while (indices.size() &lt; numValues) {</span>
<span class="nc" id="L201">        indices.add(RANDOM.nextInt(size));</span>
      }
<span class="nc" id="L203">      boolean isFirst = true;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">      for (int index : indices) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (isFirst) {</span>
<span class="nc" id="L206">          isFirst = false;</span>
        } else {
<span class="nc" id="L208">          stringBuilder.append(',').append(' ');</span>
        }
<span class="nc" id="L210">        Object value = valueArray.get(index);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (value instanceof String) {</span>
<span class="nc" id="L212">          stringBuilder.append('\'').append(((String) value).replaceAll(&quot;'&quot;, &quot;''&quot;)).append('\'');</span>
        } else {
<span class="nc" id="L214">          stringBuilder.append(value);</span>
        }
<span class="nc" id="L216">      }</span>
    }

<span class="nc" id="L219">    return stringBuilder.append(')');</span>
  }

  /**
   * Randomly generate the WHERE clause of the query, may return empty string.
   *
   * @return all predicates.
   */
  private StringBuilder generatePredicates() {
<span class="nc" id="L228">    int numPredicates = RANDOM.nextInt(MAX_NUM_PREDICATES + 1);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">    if (numPredicates == 0) {</span>
<span class="nc" id="L230">      return null;</span>
    }

<span class="nc" id="L233">    StringBuilder stringBuilder = new StringBuilder(WHERE);</span>
<span class="nc" id="L234">    Collections.shuffle(_singleValueDimensionColumns);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">    for (int i = 0; i &lt; numPredicates; i++) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">      if (i != 0) {</span>
<span class="nc" id="L237">        stringBuilder.append(AND);</span>
      }
<span class="nc" id="L239">      String dimensionName = _singleValueDimensionColumns.get(RANDOM.nextInt(numPredicates));</span>
<span class="nc bnc" id="L240" title="All 3 branches missed.">      switch (RANDOM.nextInt(3)) {</span>
        case 0:
<span class="nc" id="L242">          stringBuilder.append(generateComparisonPredicate(dimensionName));</span>
<span class="nc" id="L243">          break;</span>
        case 1:
<span class="nc" id="L245">          stringBuilder.append(generateBetweenPredicate(dimensionName));</span>
<span class="nc" id="L246">          break;</span>
        default:
<span class="nc" id="L248">          stringBuilder.append(generateInPredicate(dimensionName));</span>
          break;
      }
    }

<span class="nc" id="L253">    return stringBuilder;</span>
  }

  /**
   * Randomly generate the GROUP BY section, may return empty string.
   *
   * @return group by section.
   */
  private StringBuilder generateGroupBys() {
<span class="nc" id="L262">    int numGroupBys = Math.min(RANDOM.nextInt(MAX_NUM_GROUP_BYS + 1), _singleValueDimensionColumns.size());</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">    if (numGroupBys == 0) {</span>
<span class="nc" id="L264">      return null;</span>
    }

<span class="nc" id="L267">    StringBuilder stringBuilder = new StringBuilder(GROUP_BY);</span>
<span class="nc" id="L268">    Collections.shuffle(_singleValueDimensionColumns);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">    for (int i = 0; i &lt; numGroupBys; i++) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      if (i != 0) {</span>
<span class="nc" id="L271">        stringBuilder.append(',').append(' ');</span>
      }
<span class="nc" id="L273">      stringBuilder.append(_singleValueDimensionColumns.get(i));</span>
    }

<span class="nc" id="L276">    return stringBuilder;</span>
  }

  /**
   * Combine the various sections to form the overall query.
   *
   * @param aggregations aggregation section.
   * @param predicates predicate section.
   * @param groupBys group by section.
   * @return overall query.
   */
  private String buildQuery(StringBuilder aggregations, StringBuilder predicates, StringBuilder groupBys) {
<span class="nc" id="L288">    StringBuilder stringBuilder = new StringBuilder(SELECT).append(aggregations);</span>
<span class="nc" id="L289">    stringBuilder.append(FROM).append(_tableName);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (predicates != null) {</span>
<span class="nc" id="L291">      stringBuilder.append(predicates);</span>
    }
<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (groupBys != null) {</span>
<span class="nc" id="L294">      stringBuilder.append(groupBys);</span>
    }
<span class="nc" id="L296">    return stringBuilder.toString();</span>
  }

  /**
   * Randomly generate a query.
   *
   * @return Return the generated query.
   */
  public String nextQuery() {
<span class="nc" id="L305">    return buildQuery(generateAggregations(), generatePredicates(), generateGroupBys());</span>
  }

  /**
   * Given star tree segments directory and number of queries, generate star tree queries.
   * Usage: StarTreeQueryGenerator starTreeSegmentsDirectory numQueries
   *
   * @param args arguments.
   */
  public static void main(String[] args)
      throws Exception {
<span class="nc bnc" id="L316" title="All 2 branches missed.">    if (args.length != 2) {</span>
<span class="nc" id="L317">      System.err.println(&quot;Usage: StarTreeQueryGenerator starTreeSegmentsDirectory numQueries&quot;);</span>
<span class="nc" id="L318">      return;</span>
    }

    // Get segment metadata for the first segment to get table name and verify query is fit for star tree.
<span class="nc" id="L322">    File segmentsDir = new File(args[0]);</span>
<span class="nc" id="L323">    Preconditions.checkState(segmentsDir.exists());</span>
<span class="nc" id="L324">    Preconditions.checkState(segmentsDir.isDirectory());</span>
<span class="nc" id="L325">    File[] segments = segmentsDir.listFiles();</span>
<span class="nc" id="L326">    Preconditions.checkNotNull(segments);</span>
<span class="nc" id="L327">    File segment = segments[0];</span>
<span class="nc" id="L328">    IndexSegment indexSegment = Loaders.IndexSegment.load(segment, ReadMode.heap);</span>
<span class="nc" id="L329">    SegmentMetadata segmentMetadata = indexSegment.getSegmentMetadata();</span>
<span class="nc" id="L330">    String tableName = segmentMetadata.getTableName();</span>

    // Set up star tree query generator.
<span class="nc" id="L333">    int numQueries = Integer.parseInt(args[1]);</span>
<span class="nc" id="L334">    SegmentInfoProvider infoProvider = new SegmentInfoProvider(args[0]);</span>
<span class="nc" id="L335">    StarTreeQueryGenerator generator =</span>
        new StarTreeQueryGenerator(tableName, infoProvider.getSingleValueDimensionColumns(),
            infoProvider.getMetricColumns(), infoProvider.getSingleValueDimensionValuesMap());
<span class="nc" id="L338">    Pql2Compiler compiler = new Pql2Compiler();</span>

<span class="nc bnc" id="L340" title="All 2 branches missed.">    for (int i = 0; i &lt; numQueries; i++) {</span>
<span class="nc" id="L341">      String query = generator.nextQuery();</span>
<span class="nc" id="L342">      System.out.println(query);</span>

      // Verify that query is fit for star tree.
<span class="nc" id="L345">      BrokerRequest brokerRequest = compiler.compileToBrokerRequest(query);</span>
<span class="nc" id="L346">      Preconditions.checkState(RequestUtils.isFitForStarTreeIndex(segmentMetadata, brokerRequest,</span>
          RequestUtils.generateFilterQueryTree(brokerRequest)));
    }
<span class="nc" id="L349">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>