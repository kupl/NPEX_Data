<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentQueryProcessor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-tools</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.tools.scan.query</a> &gt; <span class="el_source">SegmentQueryProcessor.java</span></div><h1>SegmentQueryProcessor.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.tools.scan.query;

import com.linkedin.pinot.common.request.AggregationInfo;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.request.FilterOperator;
import com.linkedin.pinot.common.request.GroupBy;
import com.linkedin.pinot.common.segment.ReadMode;
import com.linkedin.pinot.common.utils.request.FilterQueryTree;
import com.linkedin.pinot.common.utils.request.RequestUtils;
import com.linkedin.pinot.core.common.BlockMultiValIterator;
import com.linkedin.pinot.core.common.BlockSingleValIterator;
import com.linkedin.pinot.core.query.utils.Pair;
import com.linkedin.pinot.core.segment.index.ColumnMetadata;
import com.linkedin.pinot.core.segment.index.IndexSegmentImpl;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import com.linkedin.pinot.core.segment.index.loader.Loaders;
import com.linkedin.pinot.core.segment.index.readers.Dictionary;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


class SegmentQueryProcessor {
<span class="nc" id="L45">  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentQueryProcessor.class);</span>

  private File _segmentDir;
  private Set&lt;String&gt; _mvColumns;
  private Map&lt;String, int[]&gt; _mvColumnArrayMap;

  private final SegmentMetadataImpl _metadata;
  private final IndexSegmentImpl _indexSegment;

  private final String _tableName;
  private final String _segmentName;
  private final int _totalDocs;

  SegmentQueryProcessor(File segmentDir)
<span class="nc" id="L59">      throws Exception {</span>
<span class="nc" id="L60">    _segmentDir = segmentDir;</span>

<span class="nc" id="L62">    _indexSegment = (IndexSegmentImpl) Loaders.IndexSegment.load(_segmentDir, ReadMode.mmap);</span>
<span class="nc" id="L63">    _metadata = new SegmentMetadataImpl(_segmentDir);</span>
<span class="nc" id="L64">    _tableName = _metadata.getTableName();</span>
<span class="nc" id="L65">    _segmentName = _metadata.getName();</span>

<span class="nc" id="L67">    _totalDocs = _metadata.getTotalDocs();</span>

<span class="nc" id="L69">    _mvColumns = new HashSet&lt;&gt;();</span>
<span class="nc" id="L70">    _mvColumnArrayMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L72" title="All 2 branches missed.">    for (ColumnMetadata columnMetadata : _metadata.getColumnMetadataMap().values()) {</span>
<span class="nc" id="L73">      String column = columnMetadata.getColumnName();</span>

<span class="nc bnc" id="L75" title="All 2 branches missed.">      if (!columnMetadata.isSingleValue()) {</span>
<span class="nc" id="L76">        _mvColumns.add(column);</span>
      }
<span class="nc" id="L78">      _mvColumnArrayMap.put(column, new int[columnMetadata.getMaxNumberOfMultiValues()]);</span>
<span class="nc" id="L79">    }</span>
<span class="nc" id="L80">  }</span>

  public void close() {
<span class="nc" id="L83">    _metadata.close();</span>
<span class="nc" id="L84">    _indexSegment.destroy();</span>
<span class="nc" id="L85">  }</span>

  public ResultTable process(BrokerRequest brokerRequest)
      throws Exception {
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (pruneSegment(brokerRequest)) {</span>
<span class="nc" id="L90">      return null;</span>
    }

<span class="nc" id="L93">    LOGGER.debug(&quot;Processing segment: {}&quot;, _segmentName);</span>
<span class="nc" id="L94">    FilterQueryTree filterQueryTree = RequestUtils.generateFilterQueryTree(brokerRequest);</span>
<span class="nc" id="L95">    List&lt;Integer&gt; filteredDocIds = filterDocIds(filterQueryTree, null);</span>

<span class="nc" id="L97">    ResultTable result = null;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (brokerRequest.isSetAggregationsInfo()) {</span>
      // Aggregation only
<span class="nc bnc" id="L100" title="All 2 branches missed.">      if (!brokerRequest.isSetGroupBy()) {</span>
<span class="nc" id="L101">        Aggregation aggregation =</span>
            new Aggregation(_indexSegment, _metadata, filteredDocIds, brokerRequest.getAggregationsInfo(), null, 10);
<span class="nc" id="L103">        result = aggregation.run();</span>
<span class="nc" id="L104">      } else { // Aggregation GroupBy</span>
<span class="nc" id="L105">        GroupBy groupBy = brokerRequest.getGroupBy();</span>
<span class="nc" id="L106">        Aggregation aggregation =</span>
            new Aggregation(_indexSegment, _metadata, filteredDocIds, brokerRequest.getAggregationsInfo(),
                groupBy.getColumns(), groupBy.getTopN());
<span class="nc" id="L109">        result = aggregation.run();</span>
<span class="nc" id="L110">      }</span>
    } else {// Only Selection
<span class="nc bnc" id="L112" title="All 2 branches missed.">      if (brokerRequest.isSetSelections()) {</span>
<span class="nc" id="L113">        List&lt;String&gt; columns = brokerRequest.getSelections().getSelectionColumns();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (columns.contains(&quot;*&quot;)) {</span>
<span class="nc" id="L115">          columns = new ArrayList&lt;&gt;(_indexSegment.getColumnNames());</span>
        }
<span class="nc" id="L117">        List&lt;Pair&gt; selectionColumns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L118">        Set&lt;String&gt; columSet = new HashSet&lt;&gt;();</span>

        // Collect a unique list of columns, in case input has duplicates.
<span class="nc bnc" id="L121" title="All 2 branches missed.">        for (String column : columns) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">          if (!columSet.contains(column)) {</span>
<span class="nc" id="L123">            selectionColumns.add(new Pair(column, null));</span>
<span class="nc" id="L124">            columSet.add(column);</span>
          }
<span class="nc" id="L126">        }</span>
<span class="nc" id="L127">        Selection selection = new Selection(_indexSegment, _metadata, filteredDocIds, selectionColumns);</span>
<span class="nc" id="L128">        result = selection.run();</span>
      }
    }

<span class="nc" id="L132">    result.setNumDocsScanned(filteredDocIds.size());</span>
<span class="nc" id="L133">    result.setTotalDocs(_totalDocs);</span>
<span class="nc" id="L134">    return result;</span>
  }

  private boolean pruneSegment(BrokerRequest brokerRequest) {
    // Check if segment belongs to the table being queried.
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (!_tableName.equals(brokerRequest.getQuerySource().getTableName())) {</span>
<span class="nc" id="L140">      LOGGER.debug(&quot;Skipping segment {} from different table {}&quot;, _segmentName, _tableName);</span>
<span class="nc" id="L141">      return true;</span>
    }

    // Check if any column in the query does not exist in the segment.
<span class="nc" id="L145">    Set&lt;String&gt; allColumns = _metadata.getAllColumns();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (brokerRequest.isSetAggregationsInfo()) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      for (AggregationInfo aggregationInfo : brokerRequest.getAggregationsInfo()) {</span>
<span class="nc" id="L148">        Map&lt;String, String&gt; aggregationParams = aggregationInfo.getAggregationParams();</span>

<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (String column : aggregationParams.values()) {</span>
<span class="nc bnc" id="L151" title="All 8 branches missed.">          if (column != null &amp;&amp; !column.isEmpty() &amp;&amp; !column.equals(&quot;*&quot;) &amp;&amp; !allColumns.contains(column)) {</span>
<span class="nc" id="L152">            LOGGER.debug(&quot;Skipping segment '{}', as it does not have column '{}'&quot;, _metadata.getName(), column);</span>
<span class="nc" id="L153">            return true;</span>
          }
<span class="nc" id="L155">        }</span>

<span class="nc" id="L157">        GroupBy groupBy = brokerRequest.getGroupBy();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (groupBy != null) {</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">          for (String column : groupBy.getColumns()) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            if (!allColumns.contains(column)) {</span>
<span class="nc" id="L161">              LOGGER.debug(&quot;Skipping segment '{}', as it does not have column '{}'&quot;, _metadata.getName(), column);</span>
<span class="nc" id="L162">              return true;</span>
            }
<span class="nc" id="L164">          }</span>
        }
<span class="nc" id="L166">      }</span>
    } else {
<span class="nc bnc" id="L168" title="All 2 branches missed.">      if (brokerRequest.isSetSelections()) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (String column : brokerRequest.getSelections().getSelectionColumns()) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">          if (!allColumns.contains(column)) {</span>
<span class="nc" id="L171">            LOGGER.debug(&quot;Skipping segment '{}', as it does not have column '{}'&quot;, _metadata.getName(), column);</span>
<span class="nc" id="L172">            return true;</span>
          }
<span class="nc" id="L174">        }</span>
      }
    }
<span class="nc" id="L177">    return false;</span>
  }

  private List&lt;Integer&gt; filterDocIds(FilterQueryTree filterQueryTree, List&lt;Integer&gt; inputDocIds) {
    // If no filter predicate, return the input without filtering.
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (filterQueryTree == null) {</span>
<span class="nc" id="L183">      List&lt;Integer&gt; allDocs = new ArrayList&lt;&gt;(_totalDocs);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      for (int i = 0; i &lt; _totalDocs; ++i) {</span>
<span class="nc" id="L185">        allDocs.add(i);</span>
      }
<span class="nc" id="L187">      return allDocs;</span>
    }

<span class="nc" id="L190">    final List&lt;FilterQueryTree&gt; childFilters = filterQueryTree.getChildren();</span>
<span class="nc bnc" id="L191" title="All 4 branches missed.">    final boolean isLeaf = (childFilters == null) || childFilters.isEmpty();</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">    if (isLeaf) {</span>
<span class="nc" id="L194">      FilterOperator filterType = filterQueryTree.getOperator();</span>
<span class="nc" id="L195">      String column = filterQueryTree.getColumn();</span>
<span class="nc" id="L196">      final List&lt;String&gt; value = filterQueryTree.getValue();</span>
<span class="nc" id="L197">      return getMatchingDocIds(inputDocIds, filterType, column, value);</span>
    }

<span class="nc" id="L200">    List&lt;Integer&gt; result = filterDocIds(childFilters.get(0), inputDocIds);</span>
<span class="nc" id="L201">    final FilterOperator operator = filterQueryTree.getOperator();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    for (int i = 1; i &lt; childFilters.size(); ++i) {</span>
//      List&lt;Integer&gt; childResult = operator.equals(FilterOperator.AND) ? filterDocIds(childFilters.get(i), result)
//          : filterDocIds(childFilters.get(i), inputDocIds);
<span class="nc" id="L205">      List&lt;Integer&gt; childResult = filterDocIds(childFilters.get(i), inputDocIds);</span>
<span class="nc" id="L206">      result = combine(result, childResult, operator);</span>
    }
<span class="nc" id="L208">    return result;</span>
  }

  private List&lt;Integer&gt; combine(List&lt;Integer&gt; operand1, List&lt;Integer&gt; operand2, FilterOperator operator) {
<span class="nc" id="L212">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L213">    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L215" title="All 3 branches missed.">    switch (operator) {</span>
      case AND:
<span class="nc" id="L217">        set.addAll(operand1);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (Integer docId : operand2) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">          if (set.contains(docId)) {</span>
<span class="nc" id="L220">            result.add(docId);</span>
          }
<span class="nc" id="L222">        }</span>
<span class="nc" id="L223">        break;</span>

      case OR:
<span class="nc" id="L226">        set.addAll(operand1);</span>
<span class="nc" id="L227">        set.addAll(operand2);</span>
<span class="nc" id="L228">        result.addAll(set);</span>
<span class="nc" id="L229">        break;</span>

      default:
<span class="nc" id="L232">        throw new RuntimeException(&quot;Unsupported combine operator&quot;);</span>
    }

<span class="nc" id="L235">    return result;</span>
  }

  List&lt;Integer&gt; getMatchingDocIds(List&lt;Integer&gt; inputDocIds, FilterOperator filterType, String column,
      List&lt;String&gt; value) {
<span class="nc" id="L240">    Dictionary dictionaryReader = _indexSegment.getDictionaryFor(column);</span>
    PredicateFilter predicateFilter;

<span class="nc bnc" id="L243" title="All 6 branches missed.">    switch (filterType) {</span>
      case EQUALITY:
<span class="nc" id="L245">        predicateFilter = new EqualsPredicateFilter(dictionaryReader, value.get(0));</span>
<span class="nc" id="L246">        break;</span>

      case NOT:
<span class="nc" id="L249">        predicateFilter = new NotPredicateFilter(dictionaryReader, value.get(0));</span>
<span class="nc" id="L250">        break;</span>

      case IN:
<span class="nc" id="L253">        predicateFilter = new InPredicateFilter(dictionaryReader, value);</span>
<span class="nc" id="L254">        break;</span>

      case NOT_IN:
<span class="nc" id="L257">        predicateFilter = new NotInPredicateFilter(dictionaryReader, value);</span>
<span class="nc" id="L258">        break;</span>

      case RANGE:
<span class="nc" id="L261">        predicateFilter = new RangePredicateFilter(dictionaryReader, value);</span>
<span class="nc" id="L262">        break;</span>

      case REGEXP_LIKE:
      default:
<span class="nc" id="L266">        throw new UnsupportedOperationException(&quot;Unsupported filterType:&quot; + filterType);</span>
    }

<span class="nc" id="L269">    return evaluatePredicate(inputDocIds, column, predicateFilter);</span>
  }

  private List&lt;Integer&gt; evaluatePredicate(List&lt;Integer&gt; inputDocIds, String column, PredicateFilter predicateFilter) {
<span class="nc" id="L273">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">    if (!_mvColumns.contains(column)) {</span>
<span class="nc" id="L275">      BlockSingleValIterator bvIter =</span>
          (BlockSingleValIterator) _indexSegment.getDataSource(column).nextBlock().getBlockValueSet().iterator();

<span class="nc" id="L278">      int i = 0;</span>
<span class="nc bnc" id="L279" title="All 6 branches missed.">      while (bvIter.hasNext() &amp;&amp; (inputDocIds == null || i &lt; inputDocIds.size())) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        int docId = (inputDocIds != null) ? inputDocIds.get(i++) : i++;</span>
<span class="nc" id="L281">        bvIter.skipTo(docId);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (predicateFilter.apply(bvIter.nextIntVal())) {</span>
<span class="nc" id="L283">          result.add(docId);</span>
        }
<span class="nc" id="L285">      }</span>
<span class="nc" id="L286">    } else {</span>
<span class="nc" id="L287">      BlockMultiValIterator bvIter =</span>
          (BlockMultiValIterator) _indexSegment.getDataSource(column).nextBlock().getBlockValueSet().iterator();

<span class="nc" id="L290">      int i = 0;</span>
<span class="nc bnc" id="L291" title="All 6 branches missed.">      while (bvIter.hasNext() &amp;&amp; (inputDocIds == null || i &lt; inputDocIds.size())) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        int docId = (inputDocIds != null) ? inputDocIds.get(i++) : i++;</span>
<span class="nc" id="L293">        bvIter.skipTo(docId);</span>

<span class="nc" id="L295">        int[] dictIds = _mvColumnArrayMap.get(column);</span>
<span class="nc" id="L296">        int numMVValues = bvIter.nextIntVal(dictIds);</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (predicateFilter.apply(dictIds, numMVValues)) {</span>
<span class="nc" id="L299">          result.add(docId);</span>
        }
<span class="nc" id="L301">      }</span>
    }
<span class="nc" id="L303">    return result;</span>
  }

  public String getSegmentName() {
<span class="nc" id="L307">    return _segmentName;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>