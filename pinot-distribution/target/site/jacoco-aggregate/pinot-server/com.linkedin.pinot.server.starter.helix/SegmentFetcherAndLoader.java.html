<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentFetcherAndLoader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-server</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.server.starter.helix</a> &gt; <span class="el_source">SegmentFetcherAndLoader.java</span></div><h1>SegmentFetcherAndLoader.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.server.starter.helix;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.Utils;
import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.data.DataManager;
import com.linkedin.pinot.common.exception.PermanentDownloadException;
import com.linkedin.pinot.common.metadata.ZKMetadataProvider;
import com.linkedin.pinot.common.metadata.segment.OfflineSegmentZKMetadata;
import com.linkedin.pinot.common.segment.SegmentMetadata;
import com.linkedin.pinot.common.segment.fetcher.SegmentFetcherFactory;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.common.utils.TarGzCompressionUtils;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import com.linkedin.pinot.core.segment.index.loader.LoaderUtils;
import com.linkedin.pinot.core.segment.index.loader.V3RemoveIndexException;
import java.io.File;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.io.FileUtils;
import org.apache.helix.ZNRecord;
import org.apache.helix.store.zk.ZkHelixPropertyStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class SegmentFetcherAndLoader {
<span class="nc" id="L45">  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentFetcherAndLoader.class);</span>

  private final ZkHelixPropertyStore&lt;ZNRecord&gt; _propertyStore;
  private final DataManager _dataManager;

  private final int _segmentLoadMaxRetryCount;
  private final long _segmentLoadMinRetryDelayMs; // Min delay (in msecs) between retries

  public SegmentFetcherAndLoader(DataManager dataManager, ZkHelixPropertyStore&lt;ZNRecord&gt; propertyStore,
<span class="nc" id="L54">      Configuration pinotHelixProperties) throws Exception {</span>
<span class="nc" id="L55">    _propertyStore = propertyStore;</span>
<span class="nc" id="L56">    _dataManager = dataManager;</span>
<span class="nc" id="L57">    int maxRetries = Integer.parseInt(CommonConstants.Server.DEFAULT_SEGMENT_LOAD_MAX_RETRY_COUNT);</span>
    try {
<span class="nc" id="L59">      maxRetries =</span>
          pinotHelixProperties.getInt(CommonConstants.Server.CONFIG_OF_SEGMENT_LOAD_MAX_RETRY_COUNT, maxRetries);
<span class="nc" id="L61">    } catch (Exception e) {</span>
      // Keep the default value
<span class="nc" id="L63">    }</span>
<span class="nc" id="L64">    _segmentLoadMaxRetryCount = maxRetries;</span>

<span class="nc" id="L66">    long minRetryDelayMillis = Long.parseLong(CommonConstants.Server.DEFAULT_SEGMENT_LOAD_MIN_RETRY_DELAY_MILLIS);</span>
    try {
<span class="nc" id="L68">      minRetryDelayMillis =</span>
          pinotHelixProperties.getLong(CommonConstants.Server.CONFIG_OF_SEGMENT_LOAD_MIN_RETRY_DELAY_MILLIS,
              minRetryDelayMillis);
<span class="nc" id="L71">    } catch (Exception e) {</span>
      // Keep the default value
<span class="nc" id="L73">    }</span>
<span class="nc" id="L74">    _segmentLoadMinRetryDelayMs = minRetryDelayMillis;</span>
<span class="nc" id="L75">    Configuration segmentFetcherFactoryConfig =</span>
        pinotHelixProperties.subset(CommonConstants.Server.PREFIX_OF_CONFIG_OF_SEGMENT_FETCHER_FACTORY);

<span class="nc" id="L78">    SegmentFetcherFactory.getInstance().init(segmentFetcherFactoryConfig);</span>
<span class="nc" id="L79">  }</span>

  public void addOrReplaceOfflineSegment(String tableName, String segmentId, boolean retryOnFailure) {
<span class="nc" id="L82">    OfflineSegmentZKMetadata newSegmentZKMetadata =</span>
        ZKMetadataProvider.getOfflineSegmentZKMetadata(_propertyStore, tableName, segmentId);
<span class="nc" id="L84">    Preconditions.checkNotNull(newSegmentZKMetadata);</span>

<span class="nc" id="L86">    LOGGER.info(&quot;Adding or replacing segment {} for table {}, metadata {}&quot;, segmentId, tableName, newSegmentZKMetadata);</span>
    try {
      // We lock the segment in order to get its metadata, and then release the lock, so it is possible
      // that the segment is dropped after we get its metadata.
<span class="nc" id="L90">      SegmentMetadata localSegmentMetadata = _dataManager.getSegmentMetadata(tableName, segmentId);</span>

<span class="nc bnc" id="L92" title="All 2 branches missed.">      if (localSegmentMetadata == null) {</span>
<span class="nc" id="L93">        LOGGER.info(&quot;Segment {} of table {} is not loaded in memory, checking disk&quot;, segmentId, tableName);</span>
<span class="nc" id="L94">        File indexDir = new File(getSegmentLocalDirectory(tableName, segmentId));</span>
        // Restart during segment reload might leave segment in inconsistent state (index directory might not exist but
        // segment backup directory existed), need to first try to recover from reload failure before checking the
        // existence of the index directory and loading segment metadata from it
<span class="nc" id="L98">        LoaderUtils.reloadFailureRecovery(indexDir);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (indexDir.exists()) {</span>
<span class="nc" id="L100">          LOGGER.info(&quot;Segment {} of table {} found on disk, attempting to load it&quot;, segmentId, tableName);</span>
          try {
<span class="nc" id="L102">            localSegmentMetadata = new SegmentMetadataImpl(indexDir);</span>
<span class="nc" id="L103">            LOGGER.info(&quot;Found segment {} of table {} with crc {} on disk&quot;, segmentId, tableName,</span>
                localSegmentMetadata.getCrc());
<span class="nc" id="L105">          } catch (Exception e) {</span>
            // The localSegmentDir should help us get the table name,
<span class="nc" id="L107">            LOGGER.error(&quot;Failed to load segment metadata from {}. Deleting it.&quot;, indexDir, e);</span>
<span class="nc" id="L108">            FileUtils.deleteQuietly(indexDir);</span>
<span class="nc" id="L109">            localSegmentMetadata = null;</span>
<span class="nc" id="L110">          }</span>
          try {
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (!isNewSegmentMetadata(newSegmentZKMetadata, localSegmentMetadata)) {</span>
<span class="nc" id="L113">              LOGGER.info(&quot;Segment metadata same as before, loading {} of table {} (crc {}) from disk&quot;, segmentId,</span>
                  tableName, localSegmentMetadata.getCrc());
<span class="nc" id="L115">              _dataManager.addOfflineSegment(tableName, segmentId, indexDir);</span>
              // TODO Update zk metadata with CRC for this instance
<span class="nc" id="L117">              return;</span>
            }
<span class="nc" id="L119">          } catch (V3RemoveIndexException e) {</span>
<span class="nc" id="L120">            LOGGER.info(</span>
                &quot;Unable to remove local index from V3 format segment: {}, table: {}, try to reload it from controller.&quot;,
                segmentId, tableName, e);
<span class="nc" id="L123">            FileUtils.deleteQuietly(indexDir);</span>
<span class="nc" id="L124">            localSegmentMetadata = null;</span>
<span class="nc" id="L125">          } catch (Exception e) {</span>
<span class="nc" id="L126">            LOGGER.error(&quot;Failed to load {} of table {} from local, will try to reload it from controller!&quot;, segmentId,</span>
                tableName, e);
<span class="nc" id="L128">            FileUtils.deleteQuietly(indexDir);</span>
<span class="nc" id="L129">            localSegmentMetadata = null;</span>
<span class="nc" id="L130">          }</span>
        }
      }
      // There is a very unlikely race condition that we may have gotten the metadata of a
      // segment that was not dropped when we checked, but was dropped after the check above.
      // That is possible only if we get two helix transitions (to drop, and then to add back) the
      // segment at the same, or very close to each other.If the race condition triggers, and the
      // two segments are same in metadata, then we may end up NOT adding back the segment
      // that is in the process of being dropped.

      // If we get here, then either it is the case that we have the segment loaded in memory (and therefore present
      // in disk) or, we need to load from the server. In the former case, we still need to check if the metadata
      // that we have is different from that in zookeeper.
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (isNewSegmentMetadata(newSegmentZKMetadata, localSegmentMetadata)) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (localSegmentMetadata == null) {</span>
<span class="nc" id="L145">          LOGGER.info(&quot;Loading new segment {} of table {} from controller&quot;, segmentId, tableName);</span>
        } else {
<span class="nc" id="L147">          LOGGER.info(&quot;Trying to refresh segment {} of table {} with new data.&quot;, segmentId, tableName);</span>
        }
        int retryCount;
<span class="nc" id="L150">        int maxRetryCount = 1;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (retryOnFailure) {</span>
<span class="nc" id="L152">          maxRetryCount = _segmentLoadMaxRetryCount;</span>
        }
<span class="nc bnc" id="L154" title="All 2 branches missed.">        for (retryCount = 0; retryCount &lt; maxRetryCount; ++retryCount) {</span>
<span class="nc" id="L155">          long attemptStartTime = System.currentTimeMillis();</span>
          try {
<span class="nc" id="L157">            final String uri = newSegmentZKMetadata.getDownloadUrl();</span>
<span class="nc" id="L158">            final String localSegmentDir = downloadSegmentToLocal(uri, tableName, segmentId);</span>
<span class="nc" id="L159">            final SegmentMetadata segmentMetadata = new SegmentMetadataImpl(new File(localSegmentDir));</span>
<span class="nc" id="L160">            _dataManager.addOfflineSegment(tableName, segmentId, new File(localSegmentDir));</span>
<span class="nc" id="L161">            LOGGER.info(&quot;Downloaded segment {} of table {} crc {} from controller&quot;, segmentId, tableName,</span>
                segmentMetadata.getCrc());

            // Successfully loaded the segment, break out of the retry loop
<span class="nc" id="L165">            break;</span>
<span class="nc" id="L166">          } catch (PermanentDownloadException e) {</span>
<span class="nc" id="L167">            LOGGER.error(&quot;Caught exception while loading segment {} (table {}), attempt {} of {}. Aborting&quot;, segmentId,</span>
                tableName, (retryCount + 1), maxRetryCount, e);
<span class="nc" id="L169">            Utils.rethrowException(e);</span>
<span class="nc" id="L170">          } catch (Exception e) {</span>
<span class="nc" id="L171">            long attemptDurationMillis = System.currentTimeMillis() - attemptStartTime;</span>
<span class="nc" id="L172">            LOGGER.warn(</span>
                &quot;Caught exception while loading segment &quot; + segmentId + &quot;(table &quot; + tableName + &quot;), attempt &quot; + (
                    retryCount + 1) + &quot; of &quot; + maxRetryCount, e);

            // Do we need to wait for the next retry attempt?
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (retryCount &lt; maxRetryCount - 1) {</span>
              // Exponentially back off, wait for (minDuration + attemptDurationMillis) *
              // 1.0..(2^retryCount)+1.0
<span class="nc" id="L180">              double maxRetryDurationMultiplier = Math.pow(2.0, (retryCount + 1));</span>
<span class="nc" id="L181">              double retryDurationMultiplier = Math.random() * maxRetryDurationMultiplier + 1.0;</span>
<span class="nc" id="L182">              long waitTime = (long) ((_segmentLoadMinRetryDelayMs + attemptDurationMillis) * retryDurationMultiplier);</span>

<span class="nc" id="L184">              LOGGER.warn(&quot;Waiting for &quot; + TimeUnit.MILLISECONDS.toSeconds(waitTime) + &quot; seconds to retry(&quot; + segmentId</span>
                  + &quot; of table &quot; + tableName);
<span class="nc" id="L186">              long waitEndTime = System.currentTimeMillis() + waitTime;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">              while (System.currentTimeMillis() &lt; waitEndTime) {</span>
                try {
<span class="nc" id="L189">                  Thread.sleep(Math.max(System.currentTimeMillis() - waitEndTime, 1L));</span>
<span class="nc" id="L190">                } catch (InterruptedException ie) {</span>
                  // Ignore spurious wakeup
<span class="nc" id="L192">                }</span>
              }
            }
<span class="nc" id="L195">          }</span>
        }
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (retryCount == maxRetryCount) {</span>
<span class="nc" id="L198">          throw new RuntimeException(</span>
              &quot;Failed to download and load segment &quot; + segmentId + &quot; (table &quot; + tableName + &quot; after &quot; + retryCount
                  + &quot; retries&quot;);
        }
<span class="nc" id="L202">      } else {</span>
<span class="nc" id="L203">        LOGGER.info(&quot;Got already loaded segment {} of table {} crc {} again, will do nothing.&quot;, segmentId, tableName,</span>
            localSegmentMetadata.getCrc());
      }
<span class="nc" id="L206">    } catch (final Exception e) {</span>
<span class="nc" id="L207">      LOGGER.error(&quot;Cannot load segment : &quot; + segmentId + &quot; for table &quot; + tableName, e);</span>
<span class="nc" id="L208">      Utils.rethrowException(e);</span>
<span class="nc" id="L209">      throw new AssertionError(&quot;Should not reach this&quot;);</span>
<span class="nc" id="L210">    }</span>
<span class="nc" id="L211">  }</span>

  private boolean isNewSegmentMetadata(@Nonnull OfflineSegmentZKMetadata newSegmentZKMetadata,
      @Nullable SegmentMetadata existedSegmentMetadata) {
<span class="nc" id="L215">    String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(newSegmentZKMetadata.getTableName());</span>
<span class="nc" id="L216">    String segmentName = newSegmentZKMetadata.getSegmentName();</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (existedSegmentMetadata == null) {</span>
<span class="nc" id="L219">      LOGGER.info(&quot;Existed segment metadata is null for segment: {} in table: {}&quot;, segmentName, offlineTableName);</span>
<span class="nc" id="L220">      return true;</span>
    }

<span class="nc" id="L223">    long newCrc = newSegmentZKMetadata.getCrc();</span>
<span class="nc" id="L224">    long existedCrc = Long.valueOf(existedSegmentMetadata.getCrc());</span>
<span class="nc" id="L225">    LOGGER.info(&quot;New segment CRC: {}, existed segment CRC: {} for segment: {} in table: {}&quot;, newCrc, existedCrc,</span>
        segmentName, offlineTableName);
<span class="nc bnc" id="L227" title="All 2 branches missed.">    return newCrc != existedCrc;</span>
  }

  @Nonnull
  private String downloadSegmentToLocal(@Nonnull String uri, @Nonnull String tableName, @Nonnull String segmentName)
      throws Exception {
<span class="nc" id="L233">    File tempDir = new File(new File(_dataManager.getSegmentFileDirectory(), tableName),</span>
        &quot;tmp_&quot; + segmentName + &quot;_&quot; + System.nanoTime());
<span class="nc" id="L235">    FileUtils.forceMkdir(tempDir);</span>
<span class="nc" id="L236">    File tempTarFile = new File(tempDir, segmentName + &quot;.tar.gz&quot;);</span>
<span class="nc" id="L237">    File tempSegmentDir = new File(tempDir, segmentName);</span>
    try {
<span class="nc" id="L239">      SegmentFetcherFactory.getInstance().getSegmentFetcherBasedOnURI(uri).fetchSegmentToLocal(uri, tempTarFile);</span>
<span class="nc" id="L240">      LOGGER.info(&quot;Downloaded tarred segment: {} for table: {} from: {} to: {}, file length: {}&quot;, segmentName,</span>
          tableName, uri, tempTarFile, tempTarFile.length());
<span class="nc" id="L242">      TarGzCompressionUtils.unTar(tempTarFile, tempSegmentDir);</span>
<span class="nc" id="L243">      File[] files = tempSegmentDir.listFiles();</span>
<span class="nc bnc" id="L244" title="All 4 branches missed.">      Preconditions.checkState(files != null &amp;&amp; files.length == 1);</span>
<span class="nc" id="L245">      File tempIndexDir = files[0];</span>

<span class="nc" id="L247">      File indexDir = new File(new File(_dataManager.getSegmentDataDirectory(), tableName), segmentName);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (indexDir.exists()) {</span>
<span class="nc" id="L249">        LOGGER.info(&quot;Deleting existing index directory for segment: {} for table: {}&quot;, segmentName, tableName);</span>
<span class="nc" id="L250">        FileUtils.deleteDirectory(indexDir);</span>
      }
<span class="nc" id="L252">      FileUtils.moveDirectory(tempIndexDir, indexDir);</span>
<span class="nc" id="L253">      LOGGER.info(&quot;Successfully downloaded segment: {} for table: {} to: {}&quot;, segmentName, tableName, indexDir);</span>
<span class="nc" id="L254">      return indexDir.getAbsolutePath();</span>
    } finally {
<span class="nc" id="L256">      FileUtils.deleteQuietly(tempDir);</span>
    }
  }

  public String getSegmentLocalDirectory(String tableName, String segmentId) {
<span class="nc" id="L261">    return _dataManager.getSegmentDataDirectory() + &quot;/&quot; + tableName + &quot;/&quot; + segmentId;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>