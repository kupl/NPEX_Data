<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentOnlineOfflineStateModelFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-server</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.server.starter.helix</a> &gt; <span class="el_source">SegmentOnlineOfflineStateModelFactory.java</span></div><h1>SegmentOnlineOfflineStateModelFactory.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.server.starter.helix;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.Utils;
import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.metadata.ZKMetadataProvider;
import com.linkedin.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;
import com.linkedin.pinot.common.utils.CommonConstants.Helix.TableType;
import com.linkedin.pinot.common.utils.LLCSegmentName;
import com.linkedin.pinot.common.utils.SegmentName;
import com.linkedin.pinot.core.data.manager.offline.InstanceDataManager;
import com.linkedin.pinot.core.data.manager.offline.SegmentDataManager;
import com.linkedin.pinot.core.data.manager.offline.TableDataManager;
import com.linkedin.pinot.core.data.manager.realtime.LLRealtimeSegmentDataManager;
import java.io.File;
import org.apache.commons.io.FileUtils;
import org.apache.helix.NotificationContext;
import org.apache.helix.ZNRecord;
import org.apache.helix.model.Message;
import org.apache.helix.participant.statemachine.StateModel;
import org.apache.helix.participant.statemachine.StateModelFactory;
import org.apache.helix.participant.statemachine.StateModelInfo;
import org.apache.helix.participant.statemachine.Transition;
import org.apache.helix.store.zk.ZkHelixPropertyStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Data Server layer state model to take over how to operate on:
 * 1. Add a new segment
 * 2. Refresh an existed now serving segment.
 * 3. Delete an existed segment.
 */
public class SegmentOnlineOfflineStateModelFactory extends StateModelFactory&lt;StateModel&gt; {
  private final String _instanceId;
  private final InstanceDataManager _instanceDataManager;
  private final SegmentFetcherAndLoader _fetcherAndLoader;
  private final ZkHelixPropertyStore&lt;ZNRecord&gt; _propertyStore;

  public SegmentOnlineOfflineStateModelFactory(String instanceId, InstanceDataManager instanceDataManager,
<span class="nc" id="L57">      SegmentFetcherAndLoader fetcherAndLoader, ZkHelixPropertyStore&lt;ZNRecord&gt; propertyStore) {</span>
<span class="nc" id="L58">    _instanceId = instanceId;</span>
<span class="nc" id="L59">    _instanceDataManager = instanceDataManager;</span>
<span class="nc" id="L60">    _fetcherAndLoader = fetcherAndLoader;</span>
<span class="nc" id="L61">    _propertyStore = propertyStore;</span>
<span class="nc" id="L62">  }</span>

  public static String getStateModelName() {
<span class="nc" id="L65">    return &quot;SegmentOnlineOfflineStateModel&quot;;</span>
  }

  @Override
  public StateModel createNewStateModel(String resourceName, String partitionName) {
<span class="nc" id="L70">    return new SegmentOnlineOfflineStateModel();</span>
  }

  // Helix seems to need StateModelInfo annotation for 'initialState'. It does not use the 'states' field.
  // The transitions in the helix messages indicate the from/to states, and helix uses the
  // Transition annotations (but only if StateModelInfo is defined).
  @SuppressWarnings(&quot;unused&quot;)
  @StateModelInfo(states = &quot;{'OFFLINE','ONLINE', 'CONSUMING', 'DROPPED'}&quot;, initialState = &quot;OFFLINE&quot;)
<span class="nc" id="L78">  public class SegmentOnlineOfflineStateModel extends StateModel {</span>
<span class="nc" id="L79">    private final Logger _logger = LoggerFactory.getLogger(_instanceId + &quot; - &quot; + getClass().getName());</span>

    @Transition(from = &quot;OFFLINE&quot;, to = &quot;CONSUMING&quot;)
    public void onBecomeConsumingFromOffline(Message message, NotificationContext context) {
<span class="nc" id="L83">      Preconditions.checkState(SegmentName.isLowLevelConsumerSegmentName(message.getPartitionName()),</span>
          &quot;Tried to go into CONSUMING state on non-low level segment&quot;);
<span class="nc" id="L85">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeConsumingFromOffline() : &quot; + message);</span>
      // We do the same processing as usual for going to the consuming state, which adds the segment to the table data
      // manager and starts Kafka consumption
<span class="nc" id="L88">      onBecomeOnlineFromOffline(message, context);</span>
<span class="nc" id="L89">    }</span>

    @Transition(from = &quot;CONSUMING&quot;, to = &quot;ONLINE&quot;)
    public void onBecomeOnlineFromConsuming(Message message, NotificationContext context) {
<span class="nc" id="L93">      String realtimeTableName = message.getResourceName();</span>
<span class="nc" id="L94">      String segmentNameStr = message.getPartitionName();</span>
<span class="nc" id="L95">      LLCSegmentName segmentName = new LLCSegmentName(segmentNameStr);</span>

<span class="nc" id="L97">      TableDataManager tableDataManager = _instanceDataManager.getTableDataManager(realtimeTableName);</span>
<span class="nc" id="L98">      Preconditions.checkNotNull(tableDataManager);</span>
<span class="nc" id="L99">      SegmentDataManager acquiredSegment = tableDataManager.acquireSegment(segmentNameStr);</span>
      // For this transition to be correct in helix, we should already have a segment that is consuming
<span class="nc bnc" id="L101" title="All 2 branches missed.">      if (acquiredSegment == null) {</span>
<span class="nc" id="L102">        throw new RuntimeException(&quot;Segment &quot; + segmentNameStr + &quot; + not present &quot;);</span>
      }

      try {
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (!(acquiredSegment instanceof LLRealtimeSegmentDataManager)) {</span>
          // We found a LLC segment that is not consuming right now, must be that we already swapped it with a
          // segment that has been built. Nothing to do for this state transition.
<span class="nc" id="L109">          _logger.info(</span>
              &quot;Segment {} not an instance of LLRealtimeSegmentDataManager. Reporting success for the transition&quot;,
              acquiredSegment.getSegmentName());
          return;
        }
<span class="nc" id="L114">        LLRealtimeSegmentDataManager segmentDataManager = (LLRealtimeSegmentDataManager) acquiredSegment;</span>
<span class="nc" id="L115">        RealtimeSegmentZKMetadata metadata =</span>
            ZKMetadataProvider.getRealtimeSegmentZKMetadata(_propertyStore, segmentName.getTableName(), segmentNameStr);
<span class="nc" id="L117">        segmentDataManager.goOnlineFromConsuming(metadata);</span>
<span class="nc" id="L118">      } catch (InterruptedException e) {</span>
<span class="nc" id="L119">        _logger.warn(&quot;State transition interrupted&quot;, e);</span>
<span class="nc" id="L120">        throw new RuntimeException(e);</span>
      } finally {
<span class="nc" id="L122">        tableDataManager.releaseSegment(acquiredSegment);</span>
<span class="nc" id="L123">      }</span>
<span class="nc" id="L124">    }</span>

    @Transition(from = &quot;CONSUMING&quot;, to = &quot;OFFLINE&quot;)
    public void onBecomeOfflineFromConsuming(Message message, NotificationContext context) {
<span class="nc" id="L128">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeOfflineFromConsuming() : &quot; + message);</span>
<span class="nc" id="L129">      String realtimeTableName = message.getResourceName();</span>
<span class="nc" id="L130">      String segmentName = message.getPartitionName();</span>
      try {
<span class="nc" id="L132">        _instanceDataManager.removeSegment(realtimeTableName, segmentName);</span>
<span class="nc" id="L133">      } catch (Exception e) {</span>
<span class="nc" id="L134">        _logger.error(&quot;Caught exception in state transition from CONSUMING -&gt; OFFLINE for resource: {}, partition: {}&quot;,</span>
            realtimeTableName, segmentName, e);
<span class="nc" id="L136">        Utils.rethrowException(e);</span>
<span class="nc" id="L137">      }</span>
<span class="nc" id="L138">    }</span>

    @Transition(from = &quot;CONSUMING&quot;, to = &quot;DROPPED&quot;)
    public void onBecomeDroppedFromConsuming(Message message, NotificationContext context) {
<span class="nc" id="L142">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeDroppedFromConsuming() : &quot; + message);</span>
      try {
<span class="nc" id="L144">        onBecomeOfflineFromConsuming(message, context);</span>
<span class="nc" id="L145">        onBecomeDroppedFromOffline(message, context);</span>
<span class="nc" id="L146">      } catch (final Exception e) {</span>
<span class="nc" id="L147">        _logger.error(&quot;Caught exception on CONSUMING -&gt; DROPPED state transition&quot;, e);</span>
<span class="nc" id="L148">        Utils.rethrowException(e);</span>
<span class="nc" id="L149">      }</span>
<span class="nc" id="L150">    }</span>

    @Transition(from = &quot;OFFLINE&quot;, to = &quot;ONLINE&quot;)
    public void onBecomeOnlineFromOffline(Message message, NotificationContext context) {
<span class="nc" id="L154">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeOnlineFromOffline() : &quot; + message);</span>
<span class="nc" id="L155">      String tableNameWithType = message.getResourceName();</span>
<span class="nc" id="L156">      String segmentName = message.getPartitionName();</span>
      try {
<span class="nc" id="L158">        TableType tableType = TableNameBuilder.getTableTypeFromTableName(message.getResourceName());</span>
<span class="nc" id="L159">        Preconditions.checkNotNull(tableType);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (tableType == TableType.OFFLINE) {</span>
<span class="nc" id="L161">          _fetcherAndLoader.addOrReplaceOfflineSegment(tableNameWithType, segmentName, /*retryOnFailure=*/true);</span>
        } else {
<span class="nc" id="L163">          _instanceDataManager.addRealtimeSegment(tableNameWithType, segmentName);</span>
        }
<span class="nc" id="L165">      } catch (Exception e) {</span>
<span class="nc" id="L166">        _logger.error(&quot;Caught exception in state transition from OFFLINE -&gt; ONLINE for resource: {}, partition: {}&quot;,</span>
            tableNameWithType, segmentName, e);
<span class="nc" id="L168">        Utils.rethrowException(e);</span>
<span class="nc" id="L169">      }</span>
<span class="nc" id="L170">    }</span>

    // Remove segment from InstanceDataManager.
    // Still keep the data files in local.
    @Transition(from = &quot;ONLINE&quot;, to = &quot;OFFLINE&quot;)
    public void onBecomeOfflineFromOnline(Message message, NotificationContext context) {
<span class="nc" id="L176">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeOfflineFromOnline() : &quot; + message);</span>
<span class="nc" id="L177">      String tableNameWithType = message.getResourceName();</span>
<span class="nc" id="L178">      String segmentName = message.getPartitionName();</span>
      try {
<span class="nc" id="L180">        _instanceDataManager.removeSegment(tableNameWithType, segmentName);</span>
<span class="nc" id="L181">      } catch (Exception e) {</span>
<span class="nc" id="L182">        _logger.error(&quot;Caught exception in state transition from ONLINE -&gt; OFFLINE for resource: {}, partition: {}&quot;,</span>
            tableNameWithType, segmentName, e);
<span class="nc" id="L184">        Utils.rethrowException(e);</span>
<span class="nc" id="L185">      }</span>
<span class="nc" id="L186">    }</span>

    // Delete segment from local directory.
    @Transition(from = &quot;OFFLINE&quot;, to = &quot;DROPPED&quot;)
    public void onBecomeDroppedFromOffline(Message message, NotificationContext context) {
<span class="nc" id="L191">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeDroppedFromOffline() : &quot; + message);</span>
<span class="nc" id="L192">      final String segmentId = message.getPartitionName();</span>
<span class="nc" id="L193">      final String tableName = message.getResourceName();</span>
      try {
<span class="nc" id="L195">        final File segmentDir = new File(_fetcherAndLoader.getSegmentLocalDirectory(tableName, segmentId));</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (segmentDir.exists()) {</span>
<span class="nc" id="L197">          FileUtils.deleteQuietly(segmentDir);</span>
<span class="nc" id="L198">          _logger.info(&quot;Deleted segment directory {}&quot;, segmentDir);</span>
        }
<span class="nc" id="L200">      } catch (final Exception e) {</span>
<span class="nc" id="L201">        _logger.error(&quot;Cannot delete the segment : &quot; + segmentId + &quot; from local directory!\n&quot; + e.getMessage(), e);</span>
<span class="nc" id="L202">        Utils.rethrowException(e);</span>
<span class="nc" id="L203">      }</span>
<span class="nc" id="L204">    }</span>

    @Transition(from = &quot;ONLINE&quot;, to = &quot;DROPPED&quot;)
    public void onBecomeDroppedFromOnline(Message message, NotificationContext context) {
<span class="nc" id="L208">      _logger.info(&quot;SegmentOnlineOfflineStateModel.onBecomeDroppedFromOnline() : &quot; + message);</span>
      try {
<span class="nc" id="L210">        onBecomeOfflineFromOnline(message, context);</span>
<span class="nc" id="L211">        onBecomeDroppedFromOffline(message, context);</span>
<span class="nc" id="L212">      } catch (final Exception e) {</span>
<span class="nc" id="L213">        _logger.error(&quot;Caught exception on ONLINE -&gt; DROPPED state transition&quot;, e);</span>
<span class="nc" id="L214">        Utils.rethrowException(e);</span>
<span class="nc" id="L215">      }</span>
<span class="nc" id="L216">    }</span>

    @Transition(from = &quot;ERROR&quot;, to = &quot;OFFLINE&quot;)
    public void onBecomeOfflineFromError(Message message, NotificationContext context) {
<span class="nc" id="L220">      _logger.info(&quot;Resetting the state for segment:{} from ERROR to OFFLINE&quot;, message.getPartitionName());</span>
<span class="nc" id="L221">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>