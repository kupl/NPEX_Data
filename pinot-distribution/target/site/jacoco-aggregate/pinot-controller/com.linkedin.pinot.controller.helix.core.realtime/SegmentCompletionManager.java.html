<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentCompletionManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-controller</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.controller.helix.core.realtime</a> &gt; <span class="el_source">SegmentCompletionManager.java</span></div><h1>SegmentCompletionManager.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.linkedin.pinot.controller.helix.core.realtime;

import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;
import com.linkedin.pinot.common.metrics.ControllerMeter;
import com.linkedin.pinot.common.metrics.ControllerMetrics;
import com.linkedin.pinot.common.protocols.SegmentCompletionProtocol;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.common.utils.LLCSegmentName;
import com.linkedin.pinot.controller.ControllerConf;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import org.apache.helix.HelixManager;
import org.apache.helix.ZNRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * This is a singleton class in the controller that drives the state machines for segments that are in the
 * committing stage.
 *
 * SegmentCompletionManager has a sub-class that represents the FSM that the segment goes through while
 * executing the segment completion protocol between pinot servers and pinot controller. The protocol is
 * described in SegmentCompletionProtocol.
 */
public class SegmentCompletionManager {
  // TODO Can we log using the segment name in the log message?
<span class="fc" id="L49">  public static Logger LOGGER = LoggerFactory.getLogger(SegmentCompletionManager.class);</span>
<span class="pc" id="L50">  private enum State {</span>
<span class="fc" id="L51">    PARTIAL_CONSUMING,  // Indicates that at least one replica has reported that it has stopped consuming.</span>
<span class="fc" id="L52">    HOLDING,          // the segment has started finalizing.</span>
<span class="fc" id="L53">    COMMITTER_DECIDED, // We know who the committer will be, we will let them know next time they call segmentConsumed()</span>
<span class="fc" id="L54">    COMMITTER_NOTIFIED, // we notified the committer to commit.</span>
<span class="fc" id="L55">    COMMITTER_UPLOADING,  // committer is uploading.</span>
<span class="fc" id="L56">    COMMITTING, // we are in the process of committing to zk</span>
<span class="fc" id="L57">    COMMITTED,    // We already committed a segment.</span>
<span class="fc" id="L58">    ABORTED,      // state machine is aborted. we will start a fresh one when the next segmentConsumed comes in.</span>
  }

<span class="fc" id="L61">  private static SegmentCompletionManager _instance = null;</span>

  private final HelixManager _helixManager;
  // A map that holds the FSM for each segment.
<span class="fc" id="L65">  private final Map&lt;String, SegmentCompletionFSM&gt; _fsmMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L66">  private final Map&lt;String, Long&gt; _commitTimeMap = new ConcurrentHashMap&lt;&gt;();</span>
  private final PinotLLCRealtimeSegmentManager _segmentManager;
  private final ControllerMetrics _controllerMetrics;

  private static final int MAX_COMMIT_TIME_FOR_ALL_SEGMENTS_SECONDS = 1800; // Half hour max commit time for all segments

  public static int getMaxCommitTimeForAllSegmentsSeconds() {
<span class="fc" id="L73">    return MAX_COMMIT_TIME_FOR_ALL_SEGMENTS_SECONDS;</span>
  }

  // TODO keep some history of past committed segments so that we can avoid looking up PROPERTYSTORE if some server comes in late.

  protected SegmentCompletionManager(HelixManager helixManager, PinotLLCRealtimeSegmentManager segmentManager,
<span class="fc" id="L79">      ControllerMetrics controllerMetrics) {</span>
<span class="fc" id="L80">    _helixManager = helixManager;</span>
<span class="fc" id="L81">    _segmentManager = segmentManager;</span>
<span class="fc" id="L82">    _controllerMetrics = controllerMetrics;</span>
<span class="fc" id="L83">  }</span>

  public boolean isSplitCommitEnabled() {
<span class="fc" id="L86">    return _segmentManager.getIsSplitCommitEnabled();</span>
  }

  public String getControllerVipUrl() {
<span class="fc" id="L90">    return _segmentManager.getControllerVipUrl();</span>
  }

  public static SegmentCompletionManager create(HelixManager helixManager,
      PinotLLCRealtimeSegmentManager segmentManager, ControllerConf controllerConf,
      ControllerMetrics controllerMetrics) {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">    if (_instance != null) {</span>
<span class="nc" id="L97">      throw new RuntimeException(&quot;Cannot create multiple instances&quot;);</span>
    }
<span class="fc" id="L99">    _instance = new SegmentCompletionManager(helixManager, segmentManager, controllerMetrics);</span>
<span class="fc" id="L100">    SegmentCompletionProtocol.setMaxSegmentCommitTimeMs(</span>
        TimeUnit.MILLISECONDS.convert(controllerConf.getSegmentCommitTimeoutSeconds(), TimeUnit.SECONDS));
<span class="fc" id="L102">    return _instance;</span>
  }

  public static SegmentCompletionManager getInstance() {
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (_instance == null) {</span>
<span class="nc" id="L107">      throw new RuntimeException(&quot;Not yet created&quot;);</span>
    }
<span class="nc" id="L109">    return _instance;</span>
  }

  protected long getCurrentTimeMs() {
<span class="nc" id="L113">    return System.currentTimeMillis();</span>
  }

  // We need to make sure that we never create multiple FSMs for the same segment, so this method must be synchronized.
  private synchronized SegmentCompletionFSM lookupOrCreateFsm(final LLCSegmentName segmentName, String msgType) {
<span class="fc" id="L118">    final String segmentNameStr = segmentName.getSegmentName();</span>
<span class="fc" id="L119">    SegmentCompletionFSM fsm = _fsmMap.get(segmentNameStr);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">    if (fsm == null) {</span>
      // Look up propertystore to see if this is a completed segment
      ZNRecord segment;
      try {
        // TODO if we keep a list of last few committed segments, we don't need to go to zk for this.
<span class="fc" id="L125">        final String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(segmentName.getTableName());</span>
<span class="fc" id="L126">        LLCRealtimeSegmentZKMetadata segmentMetadata =</span>
            _segmentManager.getRealtimeSegmentZKMetadata(realtimeTableName, segmentName.getSegmentName(), null);
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (segmentMetadata.getStatus().equals(CommonConstants.Segment.Realtime.Status.DONE)) {</span>
          // Best to go through the state machine for this case as well, so that all code regarding state handling is in one place
          // Also good for synchronization, because it is possible that multiple threads take this path, and we don't want
          // multiple instances of the FSM to be created for the same commit sequence at the same time.
<span class="fc" id="L132">          final long endOffset = segmentMetadata.getEndOffset();</span>
<span class="fc" id="L133">          fsm = SegmentCompletionFSM.fsmInCommit(_segmentManager, this, segmentName, segmentMetadata.getNumReplicas(), endOffset);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        } else if (msgType.equals(SegmentCompletionProtocol.MSG_TYPE_STOPPED_CONSUMING)) {</span>
<span class="fc" id="L135">          fsm = SegmentCompletionFSM.fsmStoppedConsuming(_segmentManager, this, segmentName, segmentMetadata.getNumReplicas());</span>
        } else {
          // Segment is in the process of completing, and this is the first one to respond. Create fsm
<span class="fc" id="L138">          fsm = SegmentCompletionFSM.fsmInHolding(_segmentManager, this, segmentName, segmentMetadata.getNumReplicas());</span>
        }
<span class="fc" id="L140">        LOGGER.info(&quot;Created FSM {}&quot;, fsm);</span>
<span class="fc" id="L141">        _fsmMap.put(segmentNameStr, fsm);</span>
<span class="fc" id="L142">      } catch (Exception e) {</span>
        // Server gone wonky. Segment does not exist in propstore
<span class="fc" id="L144">        LOGGER.error(&quot;Exception creating FSM for segment {}&quot;, segmentNameStr, e);</span>
<span class="fc" id="L145">        throw new RuntimeException(&quot;Exception creating FSM for segment &quot; + segmentNameStr, e);</span>
<span class="fc" id="L146">      }</span>
    }
<span class="fc" id="L148">    return fsm;</span>
  }

  /**
   * This method is to be called when a server calls in with the segmentConsumed() API, reporting an offset in kafka
   * that it currently has (i.e. next offset that it will consume, if it continues to consume).
   */
  public SegmentCompletionProtocol.Response segmentConsumed(SegmentCompletionProtocol.Request.Params reqParams) {
<span class="fc bfc" id="L156" title="All 4 branches covered.">    if (!_helixManager.isLeader() || !_helixManager.isConnected()) {</span>
<span class="fc" id="L157">      return SegmentCompletionProtocol.RESP_NOT_LEADER;</span>
    }
<span class="fc" id="L159">    final String segmentNameStr = reqParams.getSegmentName();</span>
<span class="fc" id="L160">    final String instanceId = reqParams.getInstanceId();</span>
<span class="fc" id="L161">    final String stopReason = reqParams.getReason();</span>
<span class="fc" id="L162">    final long offset = reqParams.getOffset();</span>

<span class="fc" id="L164">    LLCSegmentName segmentName = new LLCSegmentName(segmentNameStr);</span>
<span class="fc" id="L165">    SegmentCompletionProtocol.Response response = SegmentCompletionProtocol.RESP_FAILED;</span>
<span class="fc" id="L166">    SegmentCompletionFSM fsm = null;</span>
    try {
<span class="fc" id="L168">      fsm = lookupOrCreateFsm(segmentName, SegmentCompletionProtocol.MSG_TYPE_CONSUMED);</span>
<span class="fc" id="L169">      response = fsm.segmentConsumed(instanceId, offset, stopReason);</span>
<span class="fc" id="L170">    } catch (Exception e) {</span>
      // Return failed response
<span class="fc" id="L172">    }</span>
<span class="fc bfc" id="L173" title="All 4 branches covered.">    if (fsm != null &amp;&amp; fsm.isDone()) {</span>
<span class="fc" id="L174">      LOGGER.info(&quot;Removing FSM (if present):{}&quot;, fsm.toString());</span>
<span class="fc" id="L175">      _fsmMap.remove(segmentNameStr);</span>
    }
<span class="fc" id="L177">    return response;</span>
  }

  /**
   * This method is to be called when a server calls in with the segmentCommit() API. The server sends in the segment
   * along with the API, but it is the caller's responsibility to save the segment after this call (and before the
   * segmentCommitEnd() call).
   *
   * If successful, this method will return Response.COMMIT_CONTINUE, in which case, the caller should save the incoming
   * segment and then call segmentCommitEnd().
   *
   * Otherwise, this method will return a protocol response to be returned to the client right away (without saving the
   * incoming segment).
   */
  public SegmentCompletionProtocol.Response segmentCommitStart(final SegmentCompletionProtocol.Request.Params reqParams) {
<span class="pc bpc" id="L192" title="1 of 4 branches missed.">    if (!_helixManager.isLeader() || !_helixManager.isConnected()) {</span>
<span class="fc" id="L193">      return SegmentCompletionProtocol.RESP_NOT_LEADER;</span>
    }
<span class="fc" id="L195">    final String segmentNameStr = reqParams.getSegmentName();</span>
<span class="fc" id="L196">    final String instanceId = reqParams.getInstanceId();</span>
<span class="fc" id="L197">    final long offset = reqParams.getOffset();</span>
<span class="fc" id="L198">    LLCSegmentName segmentName = new LLCSegmentName(segmentNameStr);</span>
<span class="fc" id="L199">    SegmentCompletionFSM fsm = null;</span>
<span class="fc" id="L200">    SegmentCompletionProtocol.Response response = SegmentCompletionProtocol.RESP_FAILED;</span>
    try {
<span class="fc" id="L202">      fsm = lookupOrCreateFsm(segmentName, SegmentCompletionProtocol.MSG_TYPE_COMMIT);</span>
<span class="fc" id="L203">      response = fsm.segmentCommitStart(instanceId, offset);</span>
<span class="nc" id="L204">    } catch (Exception e) {</span>
      // Return failed response
<span class="fc" id="L206">    }</span>
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">    if (fsm != null &amp;&amp; fsm.isDone()) {</span>
<span class="fc" id="L208">      LOGGER.info(&quot;Removing FSM (if present):{}&quot;, fsm.toString());</span>
<span class="fc" id="L209">      _fsmMap.remove(segmentNameStr);</span>
    }
<span class="fc" id="L211">    return response;</span>
  }

  public SegmentCompletionProtocol.Response extendBuildTime(final SegmentCompletionProtocol.Request.Params reqParams) {
<span class="pc bpc" id="L215" title="2 of 4 branches missed.">    if (!_helixManager.isLeader() || !_helixManager.isConnected()) {</span>
<span class="nc" id="L216">      return SegmentCompletionProtocol.RESP_NOT_LEADER;</span>
    }
<span class="fc" id="L218">    final String segmentNameStr = reqParams.getSegmentName();</span>
<span class="fc" id="L219">    final String instanceId = reqParams.getInstanceId();</span>
<span class="fc" id="L220">    final long offset = reqParams.getOffset();</span>
<span class="fc" id="L221">    final int extTimeSec = reqParams.getExtraTimeSec();</span>
<span class="fc" id="L222">    LLCSegmentName segmentName = new LLCSegmentName(segmentNameStr);</span>
<span class="fc" id="L223">    SegmentCompletionFSM fsm = null;</span>
<span class="fc" id="L224">    SegmentCompletionProtocol.Response response = SegmentCompletionProtocol.RESP_FAILED;</span>
    try {
<span class="fc" id="L226">      fsm = lookupOrCreateFsm(segmentName, SegmentCompletionProtocol.MSG_TYPE_COMMIT);</span>
<span class="fc" id="L227">      response = fsm.extendBuildTime(instanceId, offset, extTimeSec);</span>
<span class="nc" id="L228">    } catch (Exception e) {</span>
      // Return failed response
<span class="fc" id="L230">    }</span>
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">    if (fsm != null &amp;&amp; fsm.isDone()) {</span>
<span class="fc" id="L232">      LOGGER.info(&quot;Removing FSM (if present):{}&quot;, fsm.toString());</span>
<span class="fc" id="L233">      _fsmMap.remove(segmentNameStr);</span>
    }
<span class="fc" id="L235">    return response;</span>
  }


  /**
   * This method is to be called when a server reports that it has stopped consuming a real-time segment.
   *
   * @return
   */
  public SegmentCompletionProtocol.Response segmentStoppedConsuming(SegmentCompletionProtocol.Request.Params reqParams) {
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">    if (!_helixManager.isLeader() || !_helixManager.isConnected()) {</span>
<span class="nc" id="L246">      return SegmentCompletionProtocol.RESP_NOT_LEADER;</span>
    }
<span class="fc" id="L248">    final String segmentNameStr = reqParams.getSegmentName();</span>
<span class="fc" id="L249">    final String instanceId = reqParams.getInstanceId();</span>
<span class="fc" id="L250">    final long offset = reqParams.getOffset();</span>
<span class="fc" id="L251">    final String reason = reqParams.getReason();</span>
<span class="fc" id="L252">    LLCSegmentName segmentName = new LLCSegmentName(segmentNameStr);</span>
<span class="fc" id="L253">    SegmentCompletionFSM fsm = null;</span>
<span class="fc" id="L254">    SegmentCompletionProtocol.Response response = SegmentCompletionProtocol.RESP_FAILED;</span>
    try {
<span class="fc" id="L256">      fsm = lookupOrCreateFsm(segmentName, SegmentCompletionProtocol.MSG_TYPE_STOPPED_CONSUMING);</span>
<span class="fc" id="L257">      response = fsm.stoppedConsuming(instanceId, offset, reason);</span>
<span class="nc" id="L258">    } catch (Exception e) {</span>
      // Return failed response
<span class="fc" id="L260">    }</span>
<span class="pc bpc" id="L261" title="2 of 4 branches missed.">    if (fsm != null &amp;&amp; fsm.isDone()) {</span>
<span class="nc" id="L262">      LOGGER.info(&quot;Removing FSM (if present):{}&quot;, fsm.toString());</span>
<span class="nc" id="L263">      _fsmMap.remove(segmentNameStr);</span>
    }
<span class="fc" id="L265">    return response;</span>
  }

  /**
   * This method is to be called when the segment sent in by the server has been saved locally in the correct path that
   * is downloadable by the servers.
   *
   * It returns a response code to be sent back to the client.
   *
   * If the repsonse code is not COMMIT_SUCCESS, then the caller may remove the segment that has been saved.
   *
   * @return
   */
  public SegmentCompletionProtocol.Response segmentCommitEnd(SegmentCompletionProtocol.Request.Params reqParams, boolean success, boolean isSplitCommit) {
<span class="fc" id="L279">    String segmentLocation = reqParams.getSegmentLocation();</span>
<span class="pc bpc" id="L280" title="2 of 4 branches missed.">    if (!_helixManager.isLeader() || !_helixManager.isConnected()) {</span>
<span class="nc" id="L281">      return SegmentCompletionProtocol.RESP_NOT_LEADER;</span>
    }
<span class="fc" id="L283">    final String segmentNameStr = reqParams.getSegmentName();</span>
<span class="fc" id="L284">    final String instanceId = reqParams.getInstanceId();</span>
<span class="fc" id="L285">    final long offset = reqParams.getOffset();</span>
<span class="fc" id="L286">    final long memoryUsedBytes = reqParams.getMemoryUsedBytes();</span>
<span class="fc" id="L287">    LLCSegmentName segmentName = new LLCSegmentName(segmentNameStr);</span>
<span class="fc" id="L288">    SegmentCompletionFSM fsm = null;</span>
<span class="fc" id="L289">    SegmentCompletionProtocol.Response response = SegmentCompletionProtocol.RESP_FAILED;</span>
    try {
<span class="fc" id="L291">      fsm = lookupOrCreateFsm(segmentName, SegmentCompletionProtocol.MSG_TYPE_COMMIT);</span>
<span class="fc" id="L292">      response = fsm.segmentCommitEnd(instanceId, offset, success, isSplitCommit, segmentLocation, memoryUsedBytes);</span>
<span class="nc" id="L293">    } catch (Exception e) {</span>
      // Return failed response
<span class="fc" id="L295">    }</span>
<span class="pc bpc" id="L296" title="2 of 4 branches missed.">    if (fsm != null &amp;&amp; fsm.isDone()) {</span>
<span class="fc" id="L297">      LOGGER.info(&quot;Removing FSM (if present):{}&quot;, fsm.toString());</span>
<span class="fc" id="L298">      _fsmMap.remove(segmentNameStr);</span>
    }

<span class="fc" id="L301">    return response;</span>
  }


  /**
   * This class implements the FSM on the controller side for each completing segment.
   *
   * An FSM is is created when we first hear about a segment (typically through the segmentConsumed message).
   * When an FSM is created, it may have one of two start states (HOLDING, or COMMITTED), depending on the
   * constructor used.
   *
   * We kick off an FSM in the COMMITTED state (rare) when we find that PROPERTYSTORE already has the segment
   * with the Status set to DONE.
   *
   * We kick off an FSM in the HOLDING state (typical) when a sementConsumed() message arrives from the
   * first server we hear from.
   *
   * The FSM does not have a timer. It is clocked by the servers, which, typically, are retransmitting their
   * segmentConsumed() message every so often (SegmentCompletionProtocol.MAX_HOLD_TIME_MS).
   *
   * See https://github.com/linkedin/pinot/wiki/Low-level-kafka-consumers
   */
  private static class SegmentCompletionFSM {
    // We will have some variation between hosts, so we add 10% to the max hold time to pick a winner.
    // If there is more than 10% variation, then it is handled as an error case (i.e. the first few to
    // come in will have a winner, and the later ones will just download the segment)
    private static final long  MAX_TIME_TO_PICK_WINNER_MS =
      SegmentCompletionProtocol.MAX_HOLD_TIME_MS + (SegmentCompletionProtocol.MAX_HOLD_TIME_MS / 10);

    // Once we pick a winner, the winner may get notified in the next call, so add one hold time plus some.
    // It may be that the winner is not the server that we are currently processing a segmentConsumed()
    // message from. In that case, we will wait for the next segmetnConsumed() message from the picked winner.
    // If the winner does not come back to us within that time, we abort the state machine and start over.
    private static final long MAX_TIME_TO_NOTIFY_WINNER_MS = MAX_TIME_TO_PICK_WINNER_MS +
      SegmentCompletionProtocol.MAX_HOLD_TIME_MS + (SegmentCompletionProtocol.MAX_HOLD_TIME_MS / 10);

    public final Logger LOGGER;

<span class="fc" id="L339">    State _state = State.HOLDING;   // Typically start off in HOLDING state.</span>
    final long _startTimeMs;
    private final LLCSegmentName _segmentName;
    private final int _numReplicas;
    private final Set&lt;String&gt; _excludedServerStateMap;
    private final Map&lt;String, Long&gt; _commitStateMap;
<span class="fc" id="L345">    private long _winningOffset = -1L;</span>
    private String _winner;
    private final PinotLLCRealtimeSegmentManager _segmentManager;
    private final SegmentCompletionManager _segmentCompletionManager;
    private final long _maxTimeToPickWinnerMs;
    private final long _maxTimeToNotifyWinnerMs;
    private final long _initialCommitTimeMs;
    // Once the winner is notified, they are expected to commit right away. At this point, it is the segment build
    // time that we need to consider.
    // We may need to add some time here to allow for getting the lock? For now 0
    // We may need to add some time for the committer come back to us (after the build)? For now 0.
    private long _maxTimeAllowedToCommitMs;
    private final boolean _isSplitCommitEnabled;
    private final String _controllerVipUrl;

    public static SegmentCompletionFSM fsmInHolding(PinotLLCRealtimeSegmentManager segmentManager, SegmentCompletionManager segmentCompletionManager, LLCSegmentName segmentName, int numReplicas) {
<span class="fc" id="L361">      return new SegmentCompletionFSM(segmentManager, segmentCompletionManager, segmentName, numReplicas);</span>
    }

    public static SegmentCompletionFSM fsmInCommit(PinotLLCRealtimeSegmentManager segmentManager, SegmentCompletionManager segmentCompletionManager, LLCSegmentName segmentName, int numReplicas, long winningOffset) {
<span class="fc" id="L365">      return new SegmentCompletionFSM(segmentManager, segmentCompletionManager, segmentName, numReplicas, winningOffset);</span>
    }

    public static SegmentCompletionFSM fsmStoppedConsuming(PinotLLCRealtimeSegmentManager segmentManager, SegmentCompletionManager segmentCompletionManager, LLCSegmentName segmentName, int numReplicas) {
<span class="fc" id="L369">      SegmentCompletionFSM fsm = new SegmentCompletionFSM(segmentManager, segmentCompletionManager, segmentName, numReplicas);</span>
<span class="fc" id="L370">      fsm._state = State.PARTIAL_CONSUMING;</span>
<span class="fc" id="L371">      return fsm;</span>
    }

    // Ctor that starts the FSM in HOLDING state
    private SegmentCompletionFSM(PinotLLCRealtimeSegmentManager segmentManager,
<span class="fc" id="L376">        SegmentCompletionManager segmentCompletionManager, LLCSegmentName segmentName, int numReplicas) {</span>
<span class="fc" id="L377">      _segmentName = segmentName;</span>
<span class="fc" id="L378">      _numReplicas = numReplicas;</span>
<span class="fc" id="L379">      _segmentManager = segmentManager;</span>
<span class="fc" id="L380">      _commitStateMap = new HashMap&lt;&gt;(_numReplicas);</span>
<span class="fc" id="L381">      _excludedServerStateMap = new HashSet&lt;&gt;(_numReplicas);</span>
<span class="fc" id="L382">      _segmentCompletionManager = segmentCompletionManager;</span>
<span class="fc" id="L383">      _startTimeMs = _segmentCompletionManager.getCurrentTimeMs();</span>
<span class="fc" id="L384">      _maxTimeToPickWinnerMs = _startTimeMs + MAX_TIME_TO_PICK_WINNER_MS;</span>
<span class="fc" id="L385">      _maxTimeToNotifyWinnerMs = _startTimeMs + MAX_TIME_TO_NOTIFY_WINNER_MS;</span>
<span class="fc" id="L386">      long initialCommitTimeMs = MAX_TIME_TO_NOTIFY_WINNER_MS +</span>
              _segmentManager.getCommitTimeoutMS(_segmentName.getTableName());
<span class="fc" id="L388">      Long savedCommitTime = _segmentCompletionManager._commitTimeMap.get(segmentName.getTableName());</span>
<span class="pc bpc" id="L389" title="3 of 4 branches missed.">      if (savedCommitTime != null &amp;&amp; savedCommitTime &gt; initialCommitTimeMs) {</span>
<span class="nc" id="L390">        initialCommitTimeMs = savedCommitTime;</span>
      }
<span class="fc" id="L392">      LOGGER = LoggerFactory.getLogger(&quot;SegmentCompletionFSM_&quot;  + segmentName.getSegmentName());</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">      if (initialCommitTimeMs &gt; MAX_COMMIT_TIME_FOR_ALL_SEGMENTS_SECONDS * 1000) {</span>
        // The table has a really high value configured for max commit time. Set it to a higher value than default
        // and go from there.
<span class="nc" id="L396">        LOGGER.info(&quot;Configured max commit time {}s too high for table {}, changing to {}s&quot;, initialCommitTimeMs/1000,</span>
            segmentName.getTableName(), MAX_COMMIT_TIME_FOR_ALL_SEGMENTS_SECONDS);
<span class="nc" id="L398">        initialCommitTimeMs = MAX_COMMIT_TIME_FOR_ALL_SEGMENTS_SECONDS * 1000;</span>
      }
<span class="fc" id="L400">      _initialCommitTimeMs = initialCommitTimeMs;</span>
<span class="fc" id="L401">      _maxTimeAllowedToCommitMs = _startTimeMs + _initialCommitTimeMs;</span>
<span class="fc" id="L402">      _isSplitCommitEnabled = segmentCompletionManager.isSplitCommitEnabled();</span>
<span class="fc" id="L403">      _controllerVipUrl = segmentCompletionManager.getControllerVipUrl();</span>
<span class="fc" id="L404">    }</span>

    // Ctor that starts the FSM in COMMITTED state
    private SegmentCompletionFSM(PinotLLCRealtimeSegmentManager segmentManager,
        SegmentCompletionManager segmentCompletionManager, LLCSegmentName segmentName, int numReplicas, long winningOffset) {
      // Constructor used when we get an event after a segment is committed.
<span class="fc" id="L410">      this(segmentManager, segmentCompletionManager, segmentName, numReplicas);</span>
<span class="fc" id="L411">      _state = State.COMMITTED;</span>
<span class="fc" id="L412">      _winningOffset = winningOffset;</span>
<span class="fc" id="L413">      _winner = &quot;UNKNOWN&quot;;</span>
<span class="fc" id="L414">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L418">      return &quot;{&quot; + _segmentName.getSegmentName() + &quot;,&quot; + _state + &quot;,&quot; + _startTimeMs + &quot;,&quot; + _winner + &quot;,&quot; + _winningOffset + &quot;,&quot; + _isSplitCommitEnabled + &quot;,&quot; + _controllerVipUrl + &quot;}&quot;;</span>
    }

    // SegmentCompletionManager releases the FSM from the hashtable when it is done.
    public boolean isDone() {
<span class="fc bfc" id="L423" title="All 4 branches covered.">      return _state.equals(State.COMMITTED) || _state.equals(State.ABORTED);</span>
    }

    /*
     * We just heard from a server that it has reached completion stage, and is reporting the offset
     * that the server is at. Since multiple servers can come in at the same time for this segment,
     * we need to synchronize on the FSM to handle the messages. The processing time itself is small,
     * so we should be OK with this synchronization.
     */
    public SegmentCompletionProtocol.Response segmentConsumed(String instanceId, long offset, final String stopReason) {
<span class="fc" id="L433">      final long now = _segmentCompletionManager.getCurrentTimeMs();</span>
      // We can synchronize the entire block for the SegmentConsumed message.
<span class="fc" id="L435">      synchronized (this) {</span>
<span class="fc" id="L436">        LOGGER.info(&quot;Processing segmentConsumed({}, {})&quot;, instanceId, offset);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (_excludedServerStateMap.contains(instanceId)) {</span>
          // Could be that the server was restarted, and it started consuning again,and somehow got to complete
          // consumption up to this point. We will acccept it.
<span class="fc" id="L440">          LOGGER.info(&quot;Marking instance {} alive again&quot;, instanceId);</span>
<span class="fc" id="L441">          _excludedServerStateMap.remove(instanceId);</span>
        }
<span class="fc" id="L443">        _commitStateMap.put(instanceId, offset);</span>
<span class="pc bpc" id="L444" title="4 of 9 branches missed.">        switch (_state) {</span>
          case PARTIAL_CONSUMING:
<span class="fc" id="L446">            return PARTIAL_CONSUMING__consumed(instanceId, offset, now, stopReason);</span>

          case HOLDING:
<span class="fc" id="L449">            return HOLDING__consumed(instanceId, offset, now, stopReason);</span>

          case COMMITTER_DECIDED: // This must be a retransmit
<span class="fc" id="L452">            return COMMITTER_DECIDED__consumed(instanceId, offset, now);</span>

          case COMMITTER_NOTIFIED:
<span class="fc" id="L455">            return COMMITTER_NOTIFIED__consumed(instanceId, offset, now);</span>

          case COMMITTER_UPLOADING:
<span class="nc" id="L458">            return COMMITTER_UPLOADING__consumed(instanceId, offset, now);</span>

          case COMMITTING:
<span class="nc" id="L461">            return COMMITTING__consumed(instanceId, offset, now);</span>

          case COMMITTED:
<span class="fc" id="L464">            return COMMITTED__consumed(instanceId, offset);</span>

          case ABORTED:
            // FSM has been aborted, just return HOLD
<span class="nc" id="L468">            return hold(instanceId, offset);</span>

          default:
<span class="nc" id="L471">            return fail(instanceId, offset);</span>
        }
<span class="nc" id="L473">      }</span>
    }

    /*
     * A server has sent segmentConsumed() message. The caller will save the segment if we return
     * COMMIT_CONTINUE. We need to verify that it is the same server that we notified as the winner
     * and the offset is the same as what is coming in with the commit. We can then move to
     * COMMITTER_UPLOADING and wait for the segmentCommitEnd() call.
     *
     * In case of discrepancy we move the state machine to ABORTED state so that this FSM is removed
     * from the map, and things start over. In this case, we respond to the server with a 'hold' so
     * that they re-transmit their segmentConsumed() message and start over.
     */
    public SegmentCompletionProtocol.Response segmentCommitStart(String instanceId, long offset) {
<span class="fc" id="L487">      long now = _segmentCompletionManager.getCurrentTimeMs();</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">      if (_excludedServerStateMap.contains(instanceId)) {</span>
<span class="nc" id="L489">        LOGGER.warn(&quot;Not accepting commit from {} since it had stoppd consuming&quot;, instanceId);</span>
<span class="nc" id="L490">        return SegmentCompletionProtocol.RESP_FAILED;</span>
      }
<span class="fc" id="L492">      synchronized (this) {</span>
<span class="fc" id="L493">        LOGGER.info(&quot;Processing segmentCommit({}, {})&quot;, instanceId, offset);</span>
<span class="pc bpc" id="L494" title="7 of 9 branches missed.">        switch (_state) {</span>
          case PARTIAL_CONSUMING:
<span class="nc" id="L496">            return PARTIAL_CONSUMING__commit(instanceId, offset, now);</span>

          case HOLDING:
<span class="fc" id="L499">            return HOLDING__commit(instanceId, offset, now);</span>

          case COMMITTER_DECIDED:
<span class="nc" id="L502">            return COMMITTER_DECIDED__commit(instanceId, offset, now);</span>

          case COMMITTER_NOTIFIED:
<span class="fc" id="L505">            return COMMITTER_NOTIFIED__commit(instanceId, offset, now);</span>

          case COMMITTER_UPLOADING:
<span class="nc" id="L508">            return COMMITTER_UPLOADING__commit(instanceId, offset, now);</span>

          case COMMITTING:
<span class="nc" id="L511">            return COMMITTING__commit(instanceId, offset, now);</span>

          case COMMITTED:
<span class="nc" id="L514">            return COMMITTED__commit(instanceId, offset);</span>

          case ABORTED:
<span class="nc" id="L517">            return hold(instanceId, offset);</span>

          default:
<span class="nc" id="L520">            return fail(instanceId, offset);</span>
        }
<span class="nc" id="L522">      }</span>
    }

    public SegmentCompletionProtocol.Response stoppedConsuming(String instanceId, long offset, String reason) {
<span class="fc" id="L526">      synchronized (this) {</span>
<span class="fc" id="L527">        LOGGER.info(&quot;Processing stoppedConsuming({}, {})&quot;, instanceId, offset);</span>
<span class="fc" id="L528">        _excludedServerStateMap.add(instanceId);</span>
<span class="pc bpc" id="L529" title="7 of 9 branches missed.">        switch (_state) {</span>
          case PARTIAL_CONSUMING:
<span class="fc" id="L531">            return PARTIAL_CONSUMING__stoppedConsuming(instanceId, offset, reason);</span>

          case HOLDING:
<span class="fc" id="L534">            return HOLDING_stoppedConsuming(instanceId, offset, reason);</span>

          case COMMITTER_DECIDED:
<span class="nc" id="L537">            return COMMITTER_DECIDED__stoppedConsuming(instanceId, offset, reason);</span>

          case COMMITTER_NOTIFIED:
<span class="nc" id="L540">            return COMMITTER_NOTIFIED__stoppedConsuming(instanceId, offset, reason);</span>

          case COMMITTER_UPLOADING:
<span class="nc" id="L543">            return COMMITTER_UPLOADING__stoppedConsuming(instanceId, offset, reason);</span>

          case COMMITTING:
<span class="nc" id="L546">            return COMMITTING__stoppedConsuming(instanceId, offset, reason);</span>

          case COMMITTED:
<span class="nc" id="L549">            return COMMITTED__stoppedConsuming(instanceId, offset, reason);</span>

          case ABORTED:
<span class="nc" id="L552">            LOGGER.info(&quot;Ignoring StoppedConsuming message from {} in state {}&quot;, instanceId, _state);</span>
<span class="nc" id="L553">            return SegmentCompletionProtocol.RESP_PROCESSED;</span>

          default:
<span class="nc" id="L556">            return fail(instanceId, offset);</span>
        }
<span class="nc" id="L558">      }</span>
    }

    public SegmentCompletionProtocol.Response extendBuildTime(final String instanceId, final long offset, final int extTimeSec) {
<span class="fc" id="L562">      final long now = _segmentCompletionManager.getCurrentTimeMs();</span>
<span class="fc" id="L563">      synchronized (this) {</span>
<span class="fc" id="L564">         LOGGER.info(&quot;Processing extendBuildTime({}, {}, {})&quot;, instanceId, offset, extTimeSec);</span>
<span class="pc bpc" id="L565" title="2 of 3 branches missed.">        switch (_state) {</span>
          case PARTIAL_CONSUMING:
          case HOLDING:
          case COMMITTER_DECIDED:
<span class="nc" id="L569">            return fail(instanceId, offset);</span>
          case COMMITTER_NOTIFIED:
<span class="fc" id="L571">            return COMMITTER_NOTIFIED__extendBuildlTime(instanceId, offset, extTimeSec, now);</span>
          case COMMITTER_UPLOADING:
          case COMMITTING:
          case COMMITTED:
          case ABORTED:
          default:
<span class="nc" id="L577">            return fail(instanceId, offset);</span>
        }
<span class="nc" id="L579">      }</span>
    }

    /*
     * We can get this call only when the state is COMMITTER_UPLOADING. Also, the instanceId should be equal to
     * the _winner.
     */
    public SegmentCompletionProtocol.Response segmentCommitEnd(String instanceId, long offset, boolean success,
        boolean isSplitCommit, String segmentLocation, long memoryUsedBytes) {
<span class="fc" id="L588">      synchronized (this) {</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (_excludedServerStateMap.contains(instanceId)) {</span>
<span class="nc" id="L590">          LOGGER.warn(&quot;Not accepting commitEnd from {} since it had stoppd consuming&quot;, instanceId);</span>
<span class="nc" id="L591">          return abortAndReturnFailed();</span>
        }
<span class="fc" id="L593">        LOGGER.info(&quot;Processing segmentCommit({}, {})&quot;, instanceId, offset);</span>
<span class="pc bpc" id="L594" title="2 of 6 branches missed.">        if (!_state.equals(State.COMMITTER_UPLOADING) || !instanceId.equals(_winner) || offset != _winningOffset) {</span>
          // State changed while we were out of sync. return a failed commit.
<span class="fc" id="L596">          LOGGER.warn(&quot;State change during upload: state={} segment={} winner={} winningOffset={}&quot;,</span>
              _state, _segmentName.getSegmentName(), _winner, _winningOffset);
<span class="fc" id="L598">          return abortAndReturnFailed();</span>
        }
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L601">          LOGGER.error(&quot;Segment upload failed&quot;);</span>
<span class="nc" id="L602">          return abortAndReturnFailed();</span>

        }
<span class="fc" id="L605">        SegmentCompletionProtocol.Response response = commitSegment(instanceId, offset, isSplitCommit, segmentLocation, memoryUsedBytes);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (!response.equals(SegmentCompletionProtocol.RESP_COMMIT_SUCCESS)) {</span>
<span class="fc" id="L607">          return abortAndReturnFailed();</span>
        } else {
<span class="fc" id="L609">          return response;</span>
        }
<span class="nc" id="L611">      }</span>
    }


    // Helper methods that log the current state and the response sent
    private SegmentCompletionProtocol.Response fail(String instanceId, long offset) {
<span class="nc" id="L617">      LOGGER.info(&quot;{}:FAIL for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="nc" id="L618">      return SegmentCompletionProtocol.RESP_FAILED;</span>
    }

    private SegmentCompletionProtocol.Response commit(String instanceId, long offset) {
<span class="fc" id="L622">      long allowedBuildTimeSec = (_maxTimeAllowedToCommitMs - _startTimeMs)/1000;</span>
<span class="fc" id="L623">      LOGGER.info(&quot;{}:COMMIT for instance={} offset={} buldTimeSec={}&quot;, _state, instanceId, offset, allowedBuildTimeSec);</span>
<span class="fc" id="L624">      SegmentCompletionProtocol.Response.Params params = new SegmentCompletionProtocol.Response.Params().withOffset(offset).withBuildTimeSeconds(allowedBuildTimeSec)</span>
          .withStatus(SegmentCompletionProtocol.ControllerResponseStatus.COMMIT)
          .withSplitCommit(_isSplitCommitEnabled);
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">      if (_isSplitCommitEnabled) {</span>
<span class="nc" id="L628">        params.withControllerVipUrl(_controllerVipUrl);</span>
      }
<span class="fc" id="L630">      return new SegmentCompletionProtocol.Response(params);</span>
    }

    private SegmentCompletionProtocol.Response discard(String instanceId, long offset) {
<span class="fc" id="L634">      LOGGER.warn(&quot;{}:DISCARD for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L635">      return SegmentCompletionProtocol.RESP_DISCARD;</span>
    }

    private SegmentCompletionProtocol.Response keep(String instanceId, long offset) {
<span class="fc" id="L639">      LOGGER.info(&quot;{}:KEEP for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L640">      return new SegmentCompletionProtocol.Response(new SegmentCompletionProtocol.Response.Params().withOffset(offset).withStatus(</span>
          SegmentCompletionProtocol.ControllerResponseStatus.KEEP));
    }

    private SegmentCompletionProtocol.Response catchup(String instanceId, long offset) {
<span class="fc" id="L645">      LOGGER.info(&quot;{}:CATCHUP for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L646">      return new SegmentCompletionProtocol.Response(new SegmentCompletionProtocol.Response.Params().withOffset(</span>
          _winningOffset).withStatus(SegmentCompletionProtocol.ControllerResponseStatus.CATCH_UP));
    }

    private SegmentCompletionProtocol.Response hold(String instanceId, long offset) {
<span class="fc" id="L651">      LOGGER.info(&quot;{}:HOLD for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L652">      return new SegmentCompletionProtocol.Response(</span>
          new SegmentCompletionProtocol.Response.Params().withStatus(SegmentCompletionProtocol.ControllerResponseStatus.HOLD).withOffset(offset));
    }

    private SegmentCompletionProtocol.Response abortAndReturnHold(long now, String instanceId, long offset) {
<span class="fc" id="L657">      _state = State.ABORTED;</span>
<span class="fc" id="L658">      _segmentCompletionManager._controllerMetrics.addMeteredTableValue(_segmentName.getTableName(),</span>
          ControllerMeter.LLC_STATE_MACHINE_ABORTS, 1);
<span class="fc" id="L660">      return hold(instanceId, offset);</span>
    }

    private SegmentCompletionProtocol.Response abortAndReturnFailed() {
<span class="fc" id="L664">      _state = State.ABORTED;</span>
<span class="fc" id="L665">      _segmentCompletionManager._controllerMetrics.addMeteredTableValue(_segmentName.getTableName(),</span>
          ControllerMeter.LLC_STATE_MACHINE_ABORTS, 1);
<span class="fc" id="L667">      return SegmentCompletionProtocol.RESP_FAILED;</span>
    }

    private SegmentCompletionProtocol.Response abortIfTooLateAndReturnHold(long now, String instanceId, long offset) {
<span class="fc bfc" id="L671" title="All 2 branches covered.">      if (now &gt; _maxTimeAllowedToCommitMs) {</span>
<span class="fc" id="L672">        LOGGER.warn(&quot;{}:Aborting FSM (too late) instance={} offset={} now={} start={}&quot;, _state, instanceId,</span>
            offset, now, _startTimeMs);
<span class="fc" id="L674">        return abortAndReturnHold(now, instanceId, offset);</span>
      }
<span class="fc" id="L676">      return null;</span>
    }

    private int numReplicasToLookFor() {
<span class="fc" id="L680">      return _numReplicas - _excludedServerStateMap.size();</span>
    }

    private SegmentCompletionProtocol.Response PARTIAL_CONSUMING__consumed(String instanceId, long offset, long now,
        final String stopReason) {
      // This is the first time we are getting segmentConsumed() for this segment.
      // Some instance thinks we can close this segment, so go to HOLDING state, and process as normal.
      // We will just be looking for less replicas.
<span class="fc" id="L688">      _state = State.HOLDING;</span>
<span class="fc" id="L689">      return HOLDING__consumed(instanceId, offset, now, stopReason);</span>
    }

    /*
     * This is not a good state to get a commit message, but it is possible that the controller failed while in
     * COMMITTER_NOTIFIED state, and the first message we got in the new controller was a stoppedConsuming
     * message. As long as the committer is not the one who stopped consuming (which we have already checked before
     * coming here), we will trust the server that this is a valid commit.
     */
    private SegmentCompletionProtocol.Response PARTIAL_CONSUMING__commit(String instanceId, long offset, long now) {
      // Do the same as HOLDING__commit
<span class="nc" id="L700">      return processCommitWhileHoldingOrPartialConsuming(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response PARTIAL_CONSUMING__stoppedConsuming(String instanceId, long offset,
        String reason) {
<span class="fc" id="L705">      return processStoppedConsuming(instanceId, offset, reason, true);</span>
    }


    /*
     * If we have waited &quot;enough&quot;, or we have all replicas reported, then we can pick a winner.
     *
     * Otherwise, we ask the server that is reporting to come back again later until one of these conditions hold.
     *
     * If we can pick a winner then we go to COMMITTER_DECIDED or COMMITTER_NOTIIFIED (if the instance
     * in this call is the same as winner).
     *
     * If we can go to COMMITTER_NOTIFIED then we respond with a COMMIT message, otherwise with a HOLD message.
     */
    private SegmentCompletionProtocol.Response HOLDING__consumed(String instanceId, long offset, long now,
        final String stopReason) {
      SegmentCompletionProtocol.Response response;
      // If we are past the max time to pick a winner, or we have heard from all replicas,
      // we are ready to pick a winner.
<span class="fc bfc" id="L724" title="All 2 branches covered.">      if (isWinnerPicked(instanceId, now, stopReason)) {</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (_winner.equals(instanceId)) {</span>
<span class="fc" id="L726">          LOGGER.info(&quot;{}:Committer notified winner instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L727">          response = commit(instanceId, offset);</span>
<span class="fc" id="L728">          _state = State.COMMITTER_NOTIFIED;</span>
        } else {
<span class="fc" id="L730">          LOGGER.info(&quot;{}:Committer decided winner={} offset={}&quot;, _state, _winner, _winningOffset);</span>
<span class="fc" id="L731">          response = catchup(instanceId, offset);</span>
<span class="fc" id="L732">          _state = State.COMMITTER_DECIDED;</span>
        }
      } else {
<span class="fc" id="L735">        response = hold(instanceId, offset);</span>
      }
<span class="fc" id="L737">      return response;</span>
    }

    /*
     * This not a good state to receive a commit message, but then it may be that the controller
     * failed over while in the COMMITTER_NOTIFIED state...
     */
    private SegmentCompletionProtocol.Response HOLDING__commit(String instanceId, long offset, long now) {
<span class="fc" id="L745">      return processCommitWhileHoldingOrPartialConsuming(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response HOLDING_stoppedConsuming(String instanceId, long offset, String reason) {
<span class="fc" id="L749">      return processStoppedConsuming(instanceId, offset, reason, true);</span>
    }

    /*
     * We have already decided who the committer is, but have not let them know yet. If this is the committer that
     * we decided, then respond back with COMMIT. Otherwise, if the offset is smaller, respond back with a CATCHUP.
     * Otherwise, just have the server HOLD. Since the segment is not committed yet, we cannot ask them to KEEP or
     * DISCARD etc. If the committer fails for any reason, we will need a new committer.
     */
    private SegmentCompletionProtocol.Response COMMITTER_DECIDED__consumed(String instanceId, long offset, long now) {
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">      if (offset &gt; _winningOffset) {</span>
<span class="nc" id="L760">        LOGGER.warn(&quot;{}:Aborting FSM (offset larger than winning) instance={} offset={} now={} winning={}&quot;, _state, instanceId,</span>
            offset, now, _winningOffset);
<span class="nc" id="L762">        return abortAndReturnHold(now, instanceId, offset);</span>
      }
      SegmentCompletionProtocol.Response response;
<span class="fc bfc" id="L765" title="All 2 branches covered.">      if (_winner.equals(instanceId)) {</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">        if (_winningOffset == offset) {</span>
<span class="fc" id="L767">          LOGGER.info(&quot;{}:Notifying winner instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L768">          response = commit(instanceId, offset);</span>
<span class="fc" id="L769">          _state = State.COMMITTER_NOTIFIED;</span>
        } else {
          // Winner coming back with a different offset.
<span class="nc" id="L772">          LOGGER.warn(&quot;{}:Winner coming back with different offset for instance={} offset={} prevWinnOffset={}&quot;, _state,</span>
              instanceId, offset, _winningOffset);
<span class="nc" id="L774">          response = abortAndReturnHold(now, instanceId, offset);</span>
        }
<span class="fc bfc" id="L776" title="All 2 branches covered.">      } else  if (offset == _winningOffset) {</span>
        // Wait until winner has posted the segment.
<span class="fc" id="L778">        response = hold(instanceId, offset);</span>
      } else {
<span class="fc" id="L780">        response = catchup(instanceId, offset);</span>
      }
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">      if (now &gt; _maxTimeToNotifyWinnerMs) {</span>
        // Winner never got back to us. Abort the completion protocol and start afresh.
        // We can potentially optimize here to see if this instance has the highest so far, and re-elect them to
        // be winner, but for now, we will abort it and restart
<span class="nc" id="L786">        response = abortAndReturnHold(now, instanceId, offset);</span>
      }
<span class="fc" id="L788">      return response;</span>
    }

    /*
     * We have already decided who the committer is, but have not let them know yet. So, we don't expect
     * a commit() call here.
     */
    private SegmentCompletionProtocol.Response COMMITTER_DECIDED__commit(String instanceId, long offset,
        long now) {
<span class="nc" id="L797">      return processCommitWhileHoldingOrPartialConsuming(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTER_DECIDED__stoppedConsuming(String instanceId, long offset,
        String reason) {
<span class="nc" id="L802">      return processStoppedConsuming(instanceId, offset, reason, false);</span>
    }

    /*
     * We have notified the committer. If we get a consumed message from another server, we can ask them to
     * catchup (if the offset is lower). If anything else, then we pretty much ask them to hold.
     */
    private SegmentCompletionProtocol.Response COMMITTER_NOTIFIED__consumed(String instanceId, long offset, long now) {
      SegmentCompletionProtocol.Response response;
      // We have already picked a winner and notified them but we have not heard from them yet.
      // Common case here is that another server is coming back to us with its offset. We either respond back with HOLD or CATCHUP.
      // If the winner is coming back again, then we have some more conditions to look at.
<span class="fc" id="L814">      response = abortIfTooLateAndReturnHold(now, instanceId, offset);</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">      if (response != null) {</span>
<span class="fc" id="L816">        return response;</span>
      }
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">      if (instanceId.equals(_winner)) {</span>
        // Winner is coming back to after holding. Somehow they never heard us return COMMIT.
        // Allow them to be winner again, since we are still within time to pick a winner.
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if (offset == _winningOffset) {</span>
<span class="nc" id="L822">          response = commit(instanceId, offset);</span>
        } else {
          // Something seriously wrong. Abort the FSM
<span class="nc" id="L825">          response = discard(instanceId, offset);</span>
<span class="nc" id="L826">          LOGGER.warn(&quot;{}:Aborting for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="nc" id="L827">          _state = State.ABORTED;</span>
        }
      } else {
        // Common case: A different instance is reporting.
<span class="fc bfc" id="L831" title="All 2 branches covered.">        if (offset == _winningOffset) {</span>
          // Wait until winner has posted the segment before asking this server to KEEP the segment.
<span class="fc" id="L833">          response = hold(instanceId, offset);</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">        } else if (offset &lt; _winningOffset) {</span>
<span class="fc" id="L835">          response = catchup(instanceId, offset);</span>
        } else {
          // We have not yet committed, so ask the new responder to hold. They may be the new leader in case the
          // committer fails.
<span class="fc" id="L839">          response = hold(instanceId, offset);</span>
        }
      }
<span class="fc" id="L842">      return response;</span>
    }

    /*
     * We have notified the committer. If we get a consumed message from another server, we can ask them to
     * catchup (if the offset is lower). If anything else, then we pretty much ask them to hold.
     */
    private SegmentCompletionProtocol.Response COMMITTER_NOTIFIED__commit(String instanceId, long offset, long now) {
<span class="fc" id="L850">      SegmentCompletionProtocol.Response response = null;</span>
<span class="fc" id="L851">      response = checkBadCommitRequest(instanceId, offset, now);</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">      if (response != null) {</span>
<span class="fc" id="L853">        return response;</span>
      }
<span class="fc" id="L855">      LOGGER.info(&quot;{}:Uploading for instance={} offset={}&quot;, _state, instanceId, offset);</span>
<span class="fc" id="L856">      _state = State.COMMITTER_UPLOADING;</span>
<span class="fc" id="L857">      long commitTimeMs = now - _startTimeMs;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">      if (commitTimeMs &gt; _initialCommitTimeMs) {</span>
        // We assume that the commit time holds for all partitions. It is possible, though, that one partition
        // commits at a lower time than another partition, and the two partitions are going simultaneously,
        // and we may not get the maximum value all the time.
<span class="fc" id="L862">        _segmentCompletionManager._commitTimeMap.put(_segmentName.getTableName(), commitTimeMs);</span>
      }
<span class="fc" id="L864">      return SegmentCompletionProtocol.RESP_COMMIT_CONTINUE;</span>
    }

    private SegmentCompletionProtocol.Response COMMITTER_NOTIFIED__stoppedConsuming(String instanceId, long offset,
        String reason) {
<span class="nc" id="L869">      return processStoppedConsuming(instanceId, offset, reason, false);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTER_NOTIFIED__extendBuildlTime(String instanceId, long offset,
        int extTimeSec, long now) {
<span class="fc" id="L874">      SegmentCompletionProtocol.Response response = abortIfTooLateAndReturnHold(now, instanceId, offset);</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">      if (response == null) {</span>
<span class="fc" id="L876">        long maxTimeAllowedToCommitMs = now + extTimeSec * 1000;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if (maxTimeAllowedToCommitMs &gt; _startTimeMs + MAX_COMMIT_TIME_FOR_ALL_SEGMENTS_SECONDS * 1000) {</span>
<span class="fc" id="L878">          LOGGER.warn(&quot;Not accepting lease extension from {} startTime={} requestedTime={}&quot;, instanceId, _startTimeMs, maxTimeAllowedToCommitMs);</span>
<span class="fc" id="L879">          return abortAndReturnFailed();</span>
        }
<span class="fc" id="L881">        _maxTimeAllowedToCommitMs = maxTimeAllowedToCommitMs;</span>
<span class="fc" id="L882">        response = SegmentCompletionProtocol.RESP_PROCESSED;</span>
      }
<span class="fc" id="L884">      return response;</span>
    }

    private SegmentCompletionProtocol.Response COMMITTER_UPLOADING__consumed(String instanceId, long offset, long now) {
<span class="nc" id="L888">      return processConsumedAfterCommitStart(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTER_UPLOADING__commit(String instanceId, long offset,
        long now) {
<span class="nc" id="L893">      return processCommitWhileUploading(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTER_UPLOADING__stoppedConsuming(String instanceId, long offset,
        String reason) {
<span class="nc" id="L898">      return processStoppedConsuming(instanceId, offset, reason, false);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTING__consumed(String instanceId, long offset, long now) {
<span class="nc" id="L902">      return processConsumedAfterCommitStart(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTING__commit(String instanceId, long offset,
        long now) {
<span class="nc" id="L907">      return processCommitWhileUploading(instanceId, offset, now);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTING__stoppedConsuming(String instanceId, long offset, String reason) {
<span class="nc" id="L911">      return processStoppedConsuming(instanceId, offset, reason, false);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTED__consumed(String instanceId, long offset) {
      SegmentCompletionProtocol.Response
          response;// Server reporting an offset on an already completed segment. Depending on the offset, either KEEP or DISCARD.
<span class="fc bfc" id="L917" title="All 2 branches covered.">      if (offset == _winningOffset) {</span>
<span class="fc" id="L918">        response = keep(instanceId, offset);</span>
      } else {
        // Return DISCARD. It is hard to say how long the server will take to complete things.
<span class="fc" id="L921">        response = discard(instanceId, offset);</span>
      }
<span class="fc" id="L923">      return response;</span>
    }

    private SegmentCompletionProtocol.Response COMMITTED__commit(String instanceId, long offset) {
<span class="nc bnc" id="L927" title="All 2 branches missed.">      if (offset == _winningOffset) {</span>
<span class="nc" id="L928">        return keep(instanceId, offset);</span>
      }
<span class="nc" id="L930">      return discard(instanceId, offset);</span>
    }

    private SegmentCompletionProtocol.Response COMMITTED__stoppedConsuming(String instanceId, long offset, String reason) {
<span class="nc" id="L934">      return processStoppedConsuming(instanceId, offset, reason, false);</span>
    }

    private SegmentCompletionProtocol.Response processStoppedConsuming(String instanceId, long offset, String reason, boolean createNew) {
<span class="fc" id="L938">      LOGGER.info(&quot;Instance {} stopped consuming segment {} at offset {}, state {}, createNew: {}, reason:{}&quot;,</span>
          instanceId, _segmentName, offset, _state, createNew, reason);
<span class="fc" id="L940">      _segmentManager.segmentStoppedConsuming(_segmentName, instanceId);</span>
<span class="fc" id="L941">      return SegmentCompletionProtocol.RESP_PROCESSED;</span>
    }

    // A common method when the state is &gt; COMMITTER_NOTIFIED.
    private SegmentCompletionProtocol.Response processConsumedAfterCommitStart(String instanceId, long offset, long now) {
      SegmentCompletionProtocol.Response response;
      // We have already picked a winner, and may or many not have heard from them.
      // Common case here is that another server is coming back to us with its offset. We either respond back with HOLD or CATCHUP.
      // It may be that we never heard from the committer, or the committer is taking too long to commit the segment.
      // In that case, we abort the FSM and start afresh (i.e, return HOLD).
      // If the winner is coming back again, then we have some more conditions to look at.
<span class="nc" id="L952">      response = abortIfTooLateAndReturnHold(now, instanceId, offset);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">      if (response != null) {</span>
<span class="nc" id="L954">        return null;</span>
      }
<span class="nc bnc" id="L956" title="All 2 branches missed.">      if (instanceId.equals(_winner)) {</span>
        // The winner is coming back to report its offset. Take a decision based on the offset reported, and whether we
        // already notified them
        // Winner is supposedly already in the commit call. Something wrong.
<span class="nc" id="L960">        LOGGER.warn(&quot;{}:Aborting FSM because winner is reporting a segment while it is also committing instance={} offset={} now={}&quot;,</span>
            _state, instanceId, offset, now);
        // Ask them to hold, just in case the committer fails for some reason..
<span class="nc" id="L963">        return abortAndReturnHold(now, instanceId, offset);</span>
      } else {
        // Common case: A different instance is reporting.
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (offset == _winningOffset) {</span>
          // Wait until winner has posted the segment before asking this server to KEEP the segment.
<span class="nc" id="L968">          response = hold(instanceId, offset);</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        } else if (offset &lt; _winningOffset) {</span>
<span class="nc" id="L970">          response = catchup(instanceId, offset);</span>
        } else {
          // We have not yet committed, so ask the new responder to hold. They may be the new leader in case the
          // committer fails.
<span class="nc" id="L974">          response = hold(instanceId, offset);</span>
        }
      }
<span class="nc" id="L977">      return response;</span>
    }

    private SegmentCompletionProtocol.Response commitSegment(String instanceId, long offset, boolean isSplitCommit,
        String segmentLocation, long memoryUsedBytes) {
      boolean success;
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">      if (!_state.equals(State.COMMITTER_UPLOADING)) {</span>
        // State changed while we were out of sync. return a failed commit.
<span class="nc" id="L985">        LOGGER.warn(&quot;State change during upload: state={} segment={} winner={} winningOffset={}&quot;,</span>
            _state, _segmentName.getSegmentName(), _winner, _winningOffset);
<span class="nc" id="L987">        return SegmentCompletionProtocol.RESP_FAILED;</span>
      }
<span class="fc" id="L989">      LOGGER.info(&quot;Committing segment {} at offset {} winner {}&quot;, _segmentName.getSegmentName(), offset, instanceId);</span>
<span class="fc" id="L990">      _state = State.COMMITTING;</span>
      // In case of splitCommit, the segment is uploaded to a unique file name indicated by segmentLocation,
      // so we need to move the segment file to its permanent location first before committing the metadata.
<span class="fc bfc" id="L993" title="All 2 branches covered.">      if (isSplitCommit) {</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (!_segmentManager.commitSegmentFile(_segmentName.getTableName(), segmentLocation, _segmentName.getSegmentName())) {</span>
<span class="fc" id="L995">          return SegmentCompletionProtocol.RESP_FAILED;</span>
        }
      }
<span class="fc" id="L998">      success = _segmentManager.commitSegmentMetadata(_segmentName.getTableName(), _segmentName.getSegmentName(),</span>
          _winningOffset, memoryUsedBytes);
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">      if (success) {</span>
<span class="fc" id="L1001">        _state = State.COMMITTED;</span>
<span class="fc" id="L1002">        LOGGER.info(&quot;Committed segment {} at offset {} winner {}&quot;, _segmentName.getSegmentName(), offset, instanceId);</span>
<span class="fc" id="L1003">        return SegmentCompletionProtocol.RESP_COMMIT_SUCCESS;</span>
      }
<span class="nc" id="L1005">      return SegmentCompletionProtocol.RESP_FAILED;</span>
    }


    private SegmentCompletionProtocol.Response processCommitWhileUploading(String instanceId, long offset, long now) {
<span class="nc" id="L1010">      LOGGER.info(&quot;Processing segmentCommit({}, {})&quot;, instanceId, offset);</span>
<span class="nc" id="L1011">      SegmentCompletionProtocol.Response response = abortIfTooLateAndReturnHold(now, instanceId, offset);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">      if (response != null) {</span>
<span class="nc" id="L1013">        return response;</span>
      }
      // Another committer (or same) came in while one was uploading. Ask them to hold in case this one fails.
<span class="nc" id="L1016">      return new SegmentCompletionProtocol.Response(new SegmentCompletionProtocol.Response.Params().withOffset(offset).withStatus(</span>
          SegmentCompletionProtocol.ControllerResponseStatus.HOLD));
    }

    private SegmentCompletionProtocol.Response checkBadCommitRequest(String instanceId, long offset, long now) {
<span class="fc" id="L1021">      SegmentCompletionProtocol.Response response = abortIfTooLateAndReturnHold(now, instanceId, offset);</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">      if (response != null) {</span>
<span class="fc" id="L1023">        return response;</span>
<span class="pc bpc" id="L1024" title="2 of 4 branches missed.">      } else  if (instanceId.equals(_winner) &amp;&amp; offset != _winningOffset) {</span>
        // Hmm. Committer has been notified, but either a different one is committing, or offset is different
<span class="nc" id="L1026">        LOGGER.warn(&quot;{}:Aborting FSM (bad commit req) instance={} offset={} now={} winning={}&quot;, _state, instanceId,</span>
            offset, now, _winningOffset);
<span class="nc" id="L1028">        return abortAndReturnHold(now, instanceId, offset);</span>
      }
<span class="fc" id="L1030">      return null;</span>
    }

    private SegmentCompletionProtocol.Response processCommitWhileHoldingOrPartialConsuming(String instanceId,
        long offset, long now) {
<span class="fc" id="L1035">      LOGGER.info(&quot;Processing segmentCommit({}, {})&quot;, instanceId, offset);</span>
<span class="fc" id="L1036">      SegmentCompletionProtocol.Response response = abortIfTooLateAndReturnHold(now, instanceId, offset);</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">      if (response != null) {</span>
<span class="nc" id="L1038">        return response;</span>
      }
      // We cannot get a commit if we are in this state, so ask them to hold. Maybe we are starting after a failover.
      // The server will re-send the segmentConsumed message.
<span class="fc" id="L1042">      return hold(instanceId, offset);</span>
    }

    /**
     * Pick a winner if we can, preferring the instance that we are handling right now,
     *
     * We accept the first server to report an offset as long as the server stopped consumption
     * due to row limit. The premise is that other servers will also stop at row limit, and there
     * is no need to wait for them to report an offset in order to decide on a winner. The state machine takes care
     * of the cases where other servers may report different offsets (just in case).
     *
     * If the above condition is not satisfied (i.e. either this is not the first server, or it did not reach
     * row limit), then we can pick a winner only if it is too late to pick a winner, or we have heard from all
     * servers.
     *
     * Otherwise, we wait to hear from more servers.
     *
     * @param preferredInstance The instance that is reporting in this thread.
     * @param now current time
     * @param stopReason reason reported by instance for stopping consumption.
     * @return true if winner picked, false otherwise.
     */
    private boolean isWinnerPicked(String preferredInstance, long now, final String stopReason) {
<span class="pc bpc" id="L1065" title="1 of 4 branches missed.">      if (SegmentCompletionProtocol.REASON_ROW_LIMIT.equals(stopReason) &amp;&amp; _commitStateMap.size() == 1) {</span>
<span class="fc" id="L1066">        _winner = preferredInstance;</span>
<span class="fc" id="L1067">        _winningOffset = _commitStateMap.get(preferredInstance);</span>
<span class="fc" id="L1068">        return true;</span>
<span class="fc bfc" id="L1069" title="All 4 branches covered.">      } else if (now &gt; _maxTimeToPickWinnerMs || _commitStateMap.size() == numReplicasToLookFor()) {</span>
<span class="fc" id="L1070">        LOGGER.info(&quot;{}:Picking winner time={} size={}&quot;, _state, now- _startTimeMs, _commitStateMap.size());</span>
<span class="fc" id="L1071">        long maxOffsetSoFar = -1;</span>
<span class="fc" id="L1072">        String winnerSoFar = null;</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        for (Map.Entry&lt;String, Long&gt; entry : _commitStateMap.entrySet()) {</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">          if (entry.getValue() &gt; maxOffsetSoFar) {</span>
<span class="fc" id="L1075">            maxOffsetSoFar = entry.getValue();</span>
<span class="fc" id="L1076">            winnerSoFar = entry.getKey();</span>
          }
<span class="fc" id="L1078">        }</span>
<span class="fc" id="L1079">        _winningOffset = maxOffsetSoFar;</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        if (_commitStateMap.get(preferredInstance) == maxOffsetSoFar) {</span>
<span class="fc" id="L1081">          winnerSoFar = preferredInstance;</span>
        }
<span class="fc" id="L1083">        _winner = winnerSoFar;</span>
<span class="fc" id="L1084">        return true;</span>
      }
<span class="fc" id="L1086">      return false;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>