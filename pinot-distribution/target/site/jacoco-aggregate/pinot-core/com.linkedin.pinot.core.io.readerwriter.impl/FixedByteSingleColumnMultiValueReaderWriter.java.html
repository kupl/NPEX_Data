<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FixedByteSingleColumnMultiValueReaderWriter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.io.readerwriter.impl</a> &gt; <span class="el_source">FixedByteSingleColumnMultiValueReaderWriter.java</span></div><h1>FixedByteSingleColumnMultiValueReaderWriter.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.io.readerwriter.impl;

import com.linkedin.pinot.core.io.reader.impl.FixedByteSingleValueMultiColReader;
import com.linkedin.pinot.core.io.readerwriter.BaseSingleColumnMultiValueReaderWriter;
import com.linkedin.pinot.core.io.readerwriter.PinotDataBufferMemoryManager;
import com.linkedin.pinot.core.io.writer.impl.FixedByteSingleValueMultiColWriter;
import com.linkedin.pinot.core.segment.memory.PinotDataBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * This class provides expandable off-heap implementation to store a multi-valued column across a number of rows.
 * The maximum number of values in any row must be known while invoking the constructor. Other than that, this class
 * allocates additional memory as needed to accommodate any number of rows.
 *
 * Writes into the data structure are strictly sequential, but reads can be random.
 *
 * Writes are of type:
 *
 *   setIntArray(int rowNumber, int[] values)
 *
 * It is expected that rowNumber starts with 0 and increments by 1 on each invocation, and that it is decided ahead of
 * time that the class is used to store a certain type of data structure (int arrays, or char arrays, etc.) Mix &amp; match
 * is not allowed.
 *
 * Two kinds of data structures are used in this class.
 *
 * 1. A header (essentially an index into the other data structure) that has one entry per row. The entry has 3 integers
 *   - data buffer ID
 *   - offset in the data buffer where column values start
 *   - length (number of values in the multi-valued column).
 *
 *   New header structures are added as new rows come in. Each header class holds the same number of rows (for easy lookup)
 *
 * 2. A data buffer that has the values for the column that the header points to. Data buffers are added as needed,
 *    whenever we reach a limitation that we cannot fit the values of a column in the current buffer.
 *
 * Note that data buffers and headers grow independently.
 *
 * Data format
 * &lt;code&gt;
 *  HEADER SECTION 0
 *    bufferId startIndex length
 *    bufferId startIndex length
 *    bufferId startIndex length
 *    ...
 *  HEADER SECTION 1
 *    bufferId startIndex length
 *    bufferId startIndex length
 *    bufferId startIndex length
 *    ...
 *  Data BUFFER SECTION 0
 *    [set of values of row 0] [set of values of row 1]
 *     .....
 *     [set of values of row m]
 *  Data BUFFER SECTION 1
 *     [set of values of row m +1 ] [set of values of row M +2]
 *     .....
 *     [set of values of row ]
 *  Data BUFFER SECTION N
 *     [set of values of row ... ] [set of values of row ...]
 *     .....
 *     [set of values of row n]
 * &lt;/code&gt;
 *
 */

<span class="pc bpc" id="L87" title="1 of 2 branches missed.">public class FixedByteSingleColumnMultiValueReaderWriter extends BaseSingleColumnMultiValueReaderWriter {</span>

<span class="fc" id="L89">  private static final Logger LOGGER = LoggerFactory.getLogger(FixedByteSingleColumnMultiValueReaderWriter.class);</span>
  /**
   * number of columns is 1, column size is variable but less than _maxNumberOfMultiValuesPerRow
   */

  private static final int SIZE_OF_INT = 4;
  private static final int NUM_COLS_IN_HEADER = 3;

  private static final int INCREMENT_PERCENTAGE = 100;
      //Increments the Initial size by 100% of initial capacity every time we runs out of capacity

  private PinotDataBuffer _headerBuffer;
<span class="fc" id="L101">  private List&lt;PinotDataBuffer&gt; _dataBuffers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L102">  private List&lt;PinotDataBuffer&gt; _headerBuffers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L103">  private List&lt;FixedByteSingleValueMultiColReader&gt; _headerReaders = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L104">  private List&lt;FixedByteSingleValueMultiColWriter&gt; _headerWriters = new ArrayList&lt;&gt;();</span>
  private FixedByteSingleValueMultiColWriter _curHeaderWriter;
<span class="fc" id="L106">  private List&lt;FixedByteSingleValueMultiColWriter&gt; _dataWriters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L107">  private List&lt;FixedByteSingleValueMultiColReader&gt; _dataReaders = new ArrayList&lt;&gt;();</span>
  private FixedByteSingleValueMultiColWriter _currentDataWriter;
<span class="fc" id="L109">  private int _currentDataWriterIndex = -1;</span>
<span class="fc" id="L110">  private int _currentCapacity = 0;</span>
  private int _headerSize;
  private int _incrementalCapacity;
  private int _columnSizeInBytes;
  private int _maxNumberOfMultiValuesPerRow;
  private final int _rowCountPerChunk;
  private final PinotDataBufferMemoryManager _memoryManager;
  private final String _context;
<span class="fc" id="L118">  private int _prevRowStartIndex = 0;  // Offset in the data-buffer for the last row added.</span>
<span class="fc" id="L119">  private int _prevRowLength = 0;  // Number of values in the column for the last row added.</span>

  public FixedByteSingleColumnMultiValueReaderWriter(int maxNumberOfMultiValuesPerRow, int avgMultiValueCount,
<span class="fc" id="L122">      int rowCountPerChunk, int columnSizeInBytes, PinotDataBufferMemoryManager memoryManager, String context) {</span>
<span class="fc" id="L123">    _memoryManager = memoryManager;</span>
<span class="fc" id="L124">    _context = context;</span>
<span class="fc" id="L125">    int initialCapacity = Math.max(maxNumberOfMultiValuesPerRow, rowCountPerChunk * avgMultiValueCount);</span>
<span class="fc" id="L126">    int incrementalCapacity =</span>
        Math.max(maxNumberOfMultiValuesPerRow, (int) (initialCapacity * 1.0f * INCREMENT_PERCENTAGE / 100));
<span class="fc" id="L128">    _columnSizeInBytes = columnSizeInBytes;</span>
<span class="fc" id="L129">    _maxNumberOfMultiValuesPerRow = maxNumberOfMultiValuesPerRow;</span>
<span class="fc" id="L130">    _headerSize = rowCountPerChunk * SIZE_OF_INT * NUM_COLS_IN_HEADER;</span>
<span class="fc" id="L131">    _rowCountPerChunk = rowCountPerChunk;</span>
<span class="fc" id="L132">    addHeaderBuffers();</span>
    //at least create space for million entries, which for INT translates into 4mb buffer
<span class="fc" id="L134">    _incrementalCapacity = incrementalCapacity;</span>
<span class="fc" id="L135">    addDataBuffers(initialCapacity);</span>
    //init(_rowCountPerChunk, _columnSizeInBytes, _maxNumberOfMultiValuesPerRow, initialCapacity, _incrementalCapacity);
<span class="fc" id="L137">  }</span>

  private void addHeaderBuffers() {
<span class="fc" id="L140">    LOGGER.info(&quot;Allocating header buffer of size {} for: {}&quot;, _headerSize, _context);</span>
<span class="fc" id="L141">    _headerBuffer = _memoryManager.allocate(_headerSize, _context);</span>
    // We know that these buffers will not be copied directly into a file (or mapped from a file).
    // So, we can use native byte order here.
<span class="fc" id="L144">    _headerBuffer.order(ByteOrder.nativeOrder());</span>
    // dataBufferId, startIndex, length
<span class="fc" id="L146">    _curHeaderWriter = new FixedByteSingleValueMultiColWriter(_headerBuffer, _rowCountPerChunk, 3,</span>
        new int[]{SIZE_OF_INT, SIZE_OF_INT, SIZE_OF_INT});
<span class="fc" id="L148">    FixedByteSingleValueMultiColReader curHeaderReader =</span>
        new FixedByteSingleValueMultiColReader(_headerBuffer, _rowCountPerChunk,
            new int[]{SIZE_OF_INT, SIZE_OF_INT, SIZE_OF_INT});
<span class="fc" id="L151">    _headerBuffers.add(_headerBuffer);</span>
<span class="fc" id="L152">    _headerWriters.add(_curHeaderWriter);</span>
<span class="fc" id="L153">    _headerReaders.add(curHeaderReader);</span>
<span class="fc" id="L154">  }</span>

  /**
   * This method automatically computes the space needed based on the _columnSizeInBytes
   * @param rowCapacity Additional capacity to be added in terms of number of rows
   * @throws RuntimeException
   */
  private void addDataBuffers(int rowCapacity)
      throws RuntimeException {
    PinotDataBuffer dataBuffer;
    try {
<span class="fc" id="L165">      final long size = rowCapacity * _columnSizeInBytes;</span>
<span class="fc" id="L166">      LOGGER.info(&quot;Allocating data buffer of size {} for column {}&quot;, size, _context);</span>
<span class="fc" id="L167">      dataBuffer = _memoryManager.allocate(size, _context);</span>
<span class="fc" id="L168">      dataBuffer.order(ByteOrder.nativeOrder());</span>
<span class="fc" id="L169">      _dataBuffers.add(dataBuffer);</span>
<span class="fc" id="L170">      _currentDataWriter =</span>
          new FixedByteSingleValueMultiColWriter(dataBuffer, rowCapacity, 1, new int[]{_columnSizeInBytes});
<span class="fc" id="L172">      _dataWriters.add(_currentDataWriter);</span>

<span class="fc" id="L174">      FixedByteSingleValueMultiColReader dataFileReader =</span>
          new FixedByteSingleValueMultiColReader(dataBuffer, rowCapacity, new int[]{_columnSizeInBytes});
<span class="fc" id="L176">      _dataReaders.add(dataFileReader);</span>
      //update the capacity
<span class="fc" id="L178">      _currentCapacity = rowCapacity;</span>
<span class="fc" id="L179">      _currentDataWriterIndex = _currentDataWriterIndex + 1;</span>
<span class="nc" id="L180">    } catch (Exception e) {</span>
<span class="nc" id="L181">      throw new RuntimeException(</span>
          &quot;Error while expanding the capacity by allocating additional buffer with capacity:&quot; + rowCapacity, e);
<span class="fc" id="L183">    }</span>
<span class="fc" id="L184">  }</span>

  @Override
  public void close() {
<span class="fc bfc" id="L188" title="All 2 branches covered.">    for (PinotDataBuffer dataBuffer : _dataBuffers) {</span>
<span class="fc" id="L189">      dataBuffer.close();</span>
<span class="fc" id="L190">    }</span>
<span class="fc" id="L191">    _dataBuffers.clear();</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">    for (PinotDataBuffer headerBuffer : _headerBuffers) {</span>
<span class="fc" id="L193">      headerBuffer.close();</span>
<span class="fc" id="L194">    }</span>
<span class="fc" id="L195">    _headerBuffers.clear();</span>
<span class="fc" id="L196">    _headerBuffer = null;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">    for (FixedByteSingleValueMultiColReader reader : _headerReaders) {</span>
<span class="fc" id="L198">      reader.close();</span>
<span class="fc" id="L199">    }</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">    for (FixedByteSingleValueMultiColReader reader : _dataReaders) {</span>
<span class="fc" id="L201">      reader.close();</span>
<span class="fc" id="L202">    }</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">    for (FixedByteSingleValueMultiColWriter writer : _headerWriters) {</span>
<span class="fc" id="L204">      writer.close();</span>
<span class="fc" id="L205">    }</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">    for (FixedByteSingleValueMultiColWriter writer : _dataWriters) {</span>
<span class="fc" id="L207">      writer.close();</span>
<span class="fc" id="L208">    }</span>
<span class="fc" id="L209">  }</span>

  private void writeIntoHeader(int row, int dataWriterIndex, int startIndex, int length) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">    if (row &gt;= _headerBuffers.size() * _rowCountPerChunk) {</span>
<span class="fc" id="L213">      addHeaderBuffers();</span>
    }
<span class="fc" id="L215">    _curHeaderWriter.setInt(getRowInCurrentHeader(row), 0, dataWriterIndex);</span>
<span class="fc" id="L216">    _curHeaderWriter.setInt(getRowInCurrentHeader(row), 1, startIndex);</span>
<span class="fc" id="L217">    _curHeaderWriter.setInt(getRowInCurrentHeader(row), 2, length);</span>
<span class="fc" id="L218">  }</span>

  // TODO Use powers of two for _rowCountPerChunk to optimize computation for the
  // methods below. Or, assert that the input values to the class are powers of two. TBD.
  private FixedByteSingleValueMultiColReader getCurrentReader(int row) {
<span class="fc" id="L223">    return _headerReaders.get(row / _rowCountPerChunk);</span>
  }

  private int getRowInCurrentHeader(int row) {
<span class="fc" id="L227">    return row % _rowCountPerChunk;</span>
  }

  private int updateHeader(int row, int numValues) {
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">    assert (numValues &lt;= _maxNumberOfMultiValuesPerRow);</span>
<span class="fc" id="L232">    int newStartIndex = _prevRowStartIndex + _prevRowLength;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (newStartIndex + numValues &gt; _currentCapacity) {</span>
<span class="fc" id="L234">      addDataBuffers(_incrementalCapacity);</span>
<span class="fc" id="L235">      _prevRowStartIndex = 0;</span>
<span class="fc" id="L236">      _prevRowLength = 0;</span>
<span class="fc" id="L237">      newStartIndex = 0;</span>
    }
<span class="fc" id="L239">    writeIntoHeader(row, _currentDataWriterIndex, newStartIndex, numValues);</span>
<span class="fc" id="L240">    _prevRowStartIndex = newStartIndex;</span>
<span class="fc" id="L241">    _prevRowLength = numValues;</span>
<span class="fc" id="L242">    return newStartIndex;</span>
  }

  @Override
  public void setCharArray(int row, char[] charArray) {
<span class="nc" id="L247">    int newStartIndex = updateHeader(row, charArray.length);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">    for (int i = 0; i &lt; charArray.length; i++) {</span>
<span class="nc" id="L249">      _currentDataWriter.setChar(newStartIndex + i, 0, charArray[i]);</span>
    }
<span class="nc" id="L251">  }</span>

  @Override
  public void setShortArray(int row, short[] shortsArray) {

<span class="fc" id="L256">    int newStartIndex = updateHeader(row, shortsArray.length);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">    for (int i = 0; i &lt; shortsArray.length; i++) {</span>
<span class="fc" id="L258">      _currentDataWriter.setShort(newStartIndex + i, 0, shortsArray[i]);</span>
    }
<span class="fc" id="L260">  }</span>

  @Override
  public void setIntArray(int row, int[] intArray) {
<span class="fc" id="L264">    int newStartIndex = updateHeader(row, intArray.length);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">    for (int i = 0; i &lt; intArray.length; i++) {</span>
<span class="fc" id="L266">      _currentDataWriter.setInt(newStartIndex + i, 0, intArray[i]);</span>
    }
<span class="fc" id="L268">  }</span>

  @Override
  public void setLongArray(int row, long[] longArray) {
<span class="fc" id="L272">    int newStartIndex = updateHeader(row, longArray.length);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (int i = 0; i &lt; longArray.length; i++) {</span>
<span class="fc" id="L274">      _currentDataWriter.setLong(newStartIndex + i, 0, longArray[i]);</span>
    }
<span class="fc" id="L276">  }</span>

  @Override
  public void setFloatArray(int row, float[] floatArray) {
<span class="fc" id="L280">    int newStartIndex = updateHeader(row, floatArray.length);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">    for (int i = 0; i &lt; floatArray.length; i++) {</span>
<span class="fc" id="L282">      _currentDataWriter.setFloat(newStartIndex + i, 0, floatArray[i]);</span>
    }
<span class="fc" id="L284">  }</span>

  @Override
  public void setDoubleArray(int row, double[] doubleArray) {
<span class="fc" id="L288">    int newStartIndex = updateHeader(row, doubleArray.length);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">    for (int i = 0; i &lt; doubleArray.length; i++) {</span>
<span class="fc" id="L290">      _currentDataWriter.setDouble(newStartIndex + i, 0, doubleArray[i]);</span>
    }
<span class="fc" id="L292">  }</span>

  @Override
  public void setStringArray(int row, String[] stringArray) {
<span class="nc" id="L296">    int newStartIndex = updateHeader(row, stringArray.length);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">    for (int i = 0; i &lt; stringArray.length; i++) {</span>
<span class="nc" id="L298">      _currentDataWriter.setString(newStartIndex + i, 0, stringArray[i]);</span>
    }
<span class="nc" id="L300">  }</span>

  @Override
  public void setBytesArray(int row, byte[][] bytesArray) {
<span class="nc" id="L304">    int newStartIndex = updateHeader(row, bytesArray.length);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">    for (int i = 0; i &lt; bytesArray.length; i++) {</span>
<span class="nc" id="L306">      _currentDataWriter.setBytes(newStartIndex + i, 0, bytesArray[i]);</span>
    }
<span class="nc" id="L308">  }</span>

  @Override
  public int getCharArray(int row, char[] charArray) {
<span class="nc" id="L312">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="nc" id="L313">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="nc" id="L314">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="nc" id="L315">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="nc" id="L316">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="nc" id="L317">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L319">      charArray[i] = dataReader.getChar(startIndex + i, 0);</span>
    }
<span class="nc" id="L321">    return length;</span>
  }

  @Override
  public int getShortArray(int row, short[] shortsArray) {
<span class="fc" id="L326">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="fc" id="L327">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="fc" id="L328">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="fc" id="L329">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="fc" id="L330">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="fc" id="L331">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L333">      shortsArray[i] = dataReader.getShort(startIndex + i, 0);</span>
    }
<span class="fc" id="L335">    return length;</span>
  }

  @Override
  public int getIntArray(int row, int[] intArray) {
<span class="fc" id="L340">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="fc" id="L341">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="fc" id="L342">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="fc" id="L343">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="fc" id="L344">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="fc" id="L345">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L347">      intArray[i] = dataReader.getInt(startIndex + i, 0);</span>
    }
<span class="fc" id="L349">    return length;</span>
  }

  @Override
  public int getLongArray(int row, long[] longArray) {
<span class="fc" id="L354">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="fc" id="L355">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="fc" id="L356">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="fc" id="L357">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="fc" id="L358">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="fc" id="L359">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L361">      longArray[i] = dataReader.getLong(startIndex + i, 0);</span>
    }
<span class="fc" id="L363">    return length;</span>
  }

  @Override
  public int getFloatArray(int row, float[] floatArray) {
<span class="fc" id="L368">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="fc" id="L369">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="fc" id="L370">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="fc" id="L371">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="fc" id="L372">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="fc" id="L373">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L375">      floatArray[i] = dataReader.getFloat(startIndex + i, 0);</span>
    }
<span class="fc" id="L377">    return length;</span>
  }

  @Override
  public int getDoubleArray(int row, double[] doubleArray) {
<span class="fc" id="L382">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="fc" id="L383">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="fc" id="L384">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="fc" id="L385">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="fc" id="L386">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="fc" id="L387">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L389">      doubleArray[i] = dataReader.getDouble(startIndex + i, 0);</span>
    }
<span class="fc" id="L391">    return length;</span>
  }

  @Override
  public int getStringArray(int row, String[] stringArray) {
<span class="nc" id="L396">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="nc" id="L397">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="nc" id="L398">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="nc" id="L399">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="nc" id="L400">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="nc" id="L401">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L403">      stringArray[i] = dataReader.getString(startIndex + i, 0);</span>
    }
<span class="nc" id="L405">    return length;</span>
  }

  @Override
  public int getBytesArray(int row, byte[][] bytesArray) {
<span class="nc" id="L410">    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);</span>
<span class="nc" id="L411">    int rowInCurrentHeader = getRowInCurrentHeader(row);</span>
<span class="nc" id="L412">    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);</span>
<span class="nc" id="L413">    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);</span>
<span class="nc" id="L414">    int length = headerReader.getInt(rowInCurrentHeader, 2);</span>
<span class="nc" id="L415">    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L417">      bytesArray[i] = dataReader.getBytes(startIndex + i, 0);</span>
    }
<span class="nc" id="L419">    return length;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>