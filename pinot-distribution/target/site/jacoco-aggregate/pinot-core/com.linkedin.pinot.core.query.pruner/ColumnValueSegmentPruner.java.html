<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ColumnValueSegmentPruner.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.query.pruner</a> &gt; <span class="el_source">ColumnValueSegmentPruner.java</span></div><h1>ColumnValueSegmentPruner.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.query.pruner;

import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.query.ServerQueryRequest;
import com.linkedin.pinot.common.request.FilterOperator;
import com.linkedin.pinot.common.utils.request.FilterQueryTree;
import com.linkedin.pinot.common.utils.request.RequestUtils;
import com.linkedin.pinot.core.common.predicate.RangePredicate;
import com.linkedin.pinot.core.indexsegment.IndexSegment;
import com.linkedin.pinot.core.segment.index.ColumnMetadata;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnull;
import org.apache.commons.configuration.Configuration;


/**
 * An implementation of SegmentPruner.
 * &lt;p&gt;Pruner will prune segment based on the column value inside the filter.
 */
<span class="fc" id="L37">public class ColumnValueSegmentPruner extends AbstractSegmentPruner {</span>

  @Override
  public void init(Configuration config) {
<span class="fc" id="L41">  }</span>

  @Override
  public boolean prune(@Nonnull IndexSegment segment, @Nonnull ServerQueryRequest queryRequest) {
<span class="fc" id="L45">    FilterQueryTree filterQueryTree = queryRequest.getFilterQueryTree();</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">    if (filterQueryTree == null) {</span>
<span class="fc" id="L47">      return false;</span>
    }
    // For realtime segment, this map can be null.
<span class="nc" id="L50">    Map&lt;String, ColumnMetadata&gt; columnMetadataMap =</span>
        ((SegmentMetadataImpl) segment.getSegmentMetadata()).getColumnMetadataMap();
<span class="nc bnc" id="L52" title="All 4 branches missed.">    return (columnMetadataMap != null) &amp;&amp; pruneSegment(filterQueryTree, columnMetadataMap);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L57">    return &quot;ColumnValueSegmentPruner&quot;;</span>
  }

  /**
   * Helper method to determine if a segment can be pruned based on the column min/max value in segment metadata and
   * the predicates on time column. The algorithm is as follows:
   *
   * &lt;ul&gt;
   *   &lt;li&gt; For leaf node: Returns true if there is a predicate on the column and apply the predicate would result in
   *   filtering out all docs of the segment, false otherwise. &lt;/li&gt;
   *   &lt;li&gt; For non-leaf AND node: True if any of its children returned true, false otherwise. &lt;/li&gt;
   *   &lt;li&gt; For non-leaf OR node: True if all its children returned true, false otherwise. &lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param filterQueryTree Filter tree for the query.
   * @param columnMetadataMap Map from column name to column metadata.
   * @return True if segment can be pruned out, false otherwise.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public boolean pruneSegment(@Nonnull FilterQueryTree filterQueryTree,
      @Nonnull Map&lt;String, ColumnMetadata&gt; columnMetadataMap) {
<span class="fc" id="L79">    FilterOperator filterOperator = filterQueryTree.getOperator();</span>
<span class="fc" id="L80">    List&lt;FilterQueryTree&gt; children = filterQueryTree.getChildren();</span>

<span class="pc bpc" id="L82" title="1 of 4 branches missed.">    if (children == null || children.isEmpty()) {</span>
      // Leaf Node

      // Skip operator other than EQUALITY and RANGE
<span class="pc bpc" id="L86" title="1 of 4 branches missed.">      if ((filterOperator != FilterOperator.EQUALITY) &amp;&amp; (filterOperator != FilterOperator.RANGE)) {</span>
<span class="nc" id="L87">        return false;</span>
      }

<span class="fc" id="L90">      ColumnMetadata columnMetadata = columnMetadataMap.get(filterQueryTree.getColumn());</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">      if (columnMetadata == null) {</span>
        // Should not reach here after DataSchemaSegmentPruner
<span class="nc" id="L93">        return true;</span>
      }

<span class="fc" id="L96">      Comparable minValue = columnMetadata.getMinValue();</span>
<span class="fc" id="L97">      Comparable maxValue = columnMetadata.getMaxValue();</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">      if (filterOperator == FilterOperator.EQUALITY) {</span>
        // EQUALITY

        // Doesn't have min/max value set in metadata
<span class="pc bpc" id="L103" title="1 of 4 branches missed.">        if ((minValue == null) || (maxValue == null)) {</span>
<span class="fc" id="L104">          return false;</span>
        }

        // Check if the value is in the min/max range
<span class="fc" id="L108">        FieldSpec.DataType dataType = columnMetadata.getDataType();</span>
<span class="fc" id="L109">        Comparable value = getValue(filterQueryTree.getValue().get(0), dataType);</span>
<span class="fc bfc" id="L110" title="All 4 branches covered.">        return (value.compareTo(minValue) &lt; 0) || (value.compareTo(maxValue) &gt; 0);</span>
      } else {
        // RANGE

        // Get lower/upper boundary value
<span class="fc" id="L115">        FieldSpec.DataType dataType = columnMetadata.getDataType();</span>
<span class="fc" id="L116">        RangePredicate rangePredicate = new RangePredicate(null, filterQueryTree.getValue());</span>
<span class="fc" id="L117">        String lowerBoundary = rangePredicate.getLowerBoundary();</span>
<span class="fc" id="L118">        boolean includeLowerBoundary = rangePredicate.includeLowerBoundary();</span>
<span class="fc" id="L119">        Comparable lowerBoundaryValue = null;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (!lowerBoundary.equals(RangePredicate.UNBOUNDED)) {</span>
<span class="fc" id="L121">          lowerBoundaryValue = getValue(lowerBoundary, dataType);</span>
        }
<span class="fc" id="L123">        String upperBoundary = rangePredicate.getUpperBoundary();</span>
<span class="fc" id="L124">        boolean includeUpperBoundary = rangePredicate.includeUpperBoundary();</span>
<span class="fc" id="L125">        Comparable upperBoundaryValue = null;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (!upperBoundary.equals(RangePredicate.UNBOUNDED)) {</span>
<span class="fc" id="L127">          upperBoundaryValue = getValue(upperBoundary, dataType);</span>
        }

        // Check if the range is valid
<span class="fc bfc" id="L131" title="All 4 branches covered.">        if ((lowerBoundaryValue != null) &amp;&amp; (upperBoundaryValue != null)) {</span>
<span class="pc bpc" id="L132" title="2 of 4 branches missed.">          if (includeLowerBoundary &amp;&amp; includeUpperBoundary) {</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (lowerBoundaryValue.compareTo(upperBoundaryValue) &gt; 0) {</span>
<span class="fc" id="L134">              return true;</span>
            }
          } else {
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (lowerBoundaryValue.compareTo(upperBoundaryValue) &gt;= 0) {</span>
<span class="nc" id="L138">              return true;</span>
            }
          }
        }

        // Doesn't have min/max value set in metadata
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">        if ((minValue == null) || (maxValue == null)) {</span>
<span class="nc" id="L145">          return false;</span>
        }

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (lowerBoundaryValue != null) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">          if (includeLowerBoundary) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (lowerBoundaryValue.compareTo(maxValue) &gt; 0) {</span>
<span class="fc" id="L151">              return true;</span>
            }
          } else {
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (lowerBoundaryValue.compareTo(maxValue) &gt;= 0) {</span>
<span class="fc" id="L155">              return true;</span>
            }
          }
        }
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (upperBoundaryValue != null) {</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">          if (includeUpperBoundary) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (upperBoundaryValue.compareTo(minValue) &lt; 0) {</span>
<span class="fc" id="L162">              return true;</span>
            }
          } else {
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (upperBoundaryValue.compareTo(minValue) &lt;= 0) {</span>
<span class="fc" id="L166">              return true;</span>
            }
          }
        }
<span class="fc" id="L170">        return false;</span>
      }
    } else {
      // Parent node
<span class="fc" id="L174">      return pruneNonLeaf(filterQueryTree, columnMetadataMap);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>