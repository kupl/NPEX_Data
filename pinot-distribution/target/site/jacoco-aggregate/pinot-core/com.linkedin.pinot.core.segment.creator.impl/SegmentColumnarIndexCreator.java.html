<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentColumnarIndexCreator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.segment.creator.impl</a> &gt; <span class="el_source">SegmentColumnarIndexCreator.java</span></div><h1>SegmentColumnarIndexCreator.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.segment.creator.impl;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.config.ColumnPartitionConfig;
import com.linkedin.pinot.common.data.DateTimeFieldSpec;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.data.FieldSpec.FieldType;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.data.StarTreeIndexSpec;
import com.linkedin.pinot.core.data.GenericRow;
import com.linkedin.pinot.core.data.partition.PartitionFunction;
import com.linkedin.pinot.core.indexsegment.generator.SegmentGeneratorConfig;
import com.linkedin.pinot.core.io.compression.ChunkCompressorFactory;
import com.linkedin.pinot.core.segment.creator.ColumnIndexCreationInfo;
import com.linkedin.pinot.core.segment.creator.ForwardIndexCreator;
import com.linkedin.pinot.core.segment.creator.InvertedIndexCreator;
import com.linkedin.pinot.core.segment.creator.MultiValueForwardIndexCreator;
import com.linkedin.pinot.core.segment.creator.SegmentCreator;
import com.linkedin.pinot.core.segment.creator.SegmentIndexCreationInfo;
import com.linkedin.pinot.core.segment.creator.SingleValueForwardIndexCreator;
import com.linkedin.pinot.core.segment.creator.SingleValueRawIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.fwd.MultiValueUnsortedForwardIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.fwd.SingleValueFixedByteRawIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.fwd.SingleValueSortedForwardIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.fwd.SingleValueUnsortedForwardIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.fwd.SingleValueVarByteRawIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.inv.OffHeapBitmapInvertedIndexCreator;
import com.linkedin.pinot.core.segment.creator.impl.inv.OnHeapBitmapInvertedIndexCreator;
import com.linkedin.pinot.startree.hll.HllConfig;
import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.commons.lang.math.IntRange;

import static com.linkedin.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.*;
import static com.linkedin.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Segment.*;
import static com.linkedin.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.StarTree.*;


/**
 * Segment creator which writes data in a columnar form.
 */
// TODO: check resource leaks
<span class="fc" id="L66">public class SegmentColumnarIndexCreator implements SegmentCreator {</span>
  // TODO Refactor class name to match interface name
  private SegmentGeneratorConfig config;
  private Map&lt;String, ColumnIndexCreationInfo&gt; indexCreationInfoMap;
<span class="fc" id="L70">  private Map&lt;String, SegmentDictionaryCreator&gt; _dictionaryCreatorMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L71">  private Map&lt;String, ForwardIndexCreator&gt; _forwardIndexCreatorMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L72">  private Map&lt;String, InvertedIndexCreator&gt; _invertedIndexCreatorMap = new HashMap&lt;&gt;();</span>
  private String segmentName;
  private Schema schema;
  private File _indexDir;
  private int totalDocs;
  private int totalRawDocs;
  private int totalAggDocs;
  private int totalErrors;
  private int totalNulls;
  private int totalConversions;
  private int totalNullCols;
  private int docIdCounter;

  @Override
  public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreationInfo segmentIndexCreationInfo,
      Map&lt;String, ColumnIndexCreationInfo&gt; indexCreationInfoMap, Schema schema, File outDir)
      throws Exception {
<span class="fc" id="L89">    docIdCounter = 0;</span>
<span class="fc" id="L90">    config = segmentCreationSpec;</span>
<span class="fc" id="L91">    this.indexCreationInfoMap = indexCreationInfoMap;</span>

    // Check that the output directory does not exist
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    Preconditions.checkState(!outDir.exists(), &quot;Segment output directory: %s already exists&quot;, outDir);</span>

<span class="fc" id="L96">    Preconditions.checkState(outDir.mkdirs(), &quot;Failed to create output directory: %s&quot;, outDir);</span>
<span class="fc" id="L97">    _indexDir = outDir;</span>

<span class="fc" id="L99">    this.schema = schema;</span>
<span class="fc" id="L100">    this.totalDocs = segmentIndexCreationInfo.getTotalDocs();</span>
<span class="fc" id="L101">    this.totalAggDocs = segmentIndexCreationInfo.getTotalAggDocs();</span>
<span class="fc" id="L102">    this.totalRawDocs = segmentIndexCreationInfo.getTotalRawDocs();</span>
<span class="fc" id="L103">    this.totalErrors = segmentIndexCreationInfo.getTotalErrors();</span>
<span class="fc" id="L104">    this.totalNulls = segmentIndexCreationInfo.getTotalNulls();</span>
<span class="fc" id="L105">    this.totalConversions = segmentIndexCreationInfo.getTotalConversions();</span>
<span class="fc" id="L106">    this.totalNullCols = segmentIndexCreationInfo.getTotalNullCols();</span>

<span class="fc" id="L108">    Collection&lt;FieldSpec&gt; fieldSpecs = schema.getAllFieldSpecs();</span>
<span class="fc" id="L109">    Set&lt;String&gt; invertedIndexColumns = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    for (String columnName : config.getInvertedIndexCreationColumns()) {</span>
<span class="fc" id="L111">      Preconditions.checkState(schema.hasColumn(columnName),</span>
          &quot;Cannot create inverted index for column: %s because it is not in schema&quot;, columnName);
<span class="fc" id="L113">      invertedIndexColumns.add(columnName);</span>
<span class="fc" id="L114">    }</span>

    // Initialize creators for dictionary, forward index and inverted index
<span class="fc bfc" id="L117" title="All 2 branches covered.">    for (FieldSpec fieldSpec : fieldSpecs) {</span>
<span class="fc" id="L118">      String columnName = fieldSpec.getName();</span>
<span class="fc" id="L119">      ColumnIndexCreationInfo indexCreationInfo = indexCreationInfoMap.get(columnName);</span>
<span class="fc" id="L120">      Preconditions.checkNotNull(indexCreationInfo, &quot;Missing index creation info for column: %s&quot;, columnName);</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">      if (createDictionaryForColumn(indexCreationInfo, segmentCreationSpec, fieldSpec)) {</span>
        // Create dictionary-encoded index

        // TODO: hasNulls is always false, for null value we replace it with default null value
<span class="fc" id="L126">        boolean hasNulls = indexCreationInfo.hasNulls();</span>

        // Initialize dictionary creator
<span class="fc" id="L129">        SegmentDictionaryCreator dictionaryCreator =</span>
            new SegmentDictionaryCreator(hasNulls, indexCreationInfo.getSortedUniqueElementsArray(), fieldSpec,
                _indexDir);
<span class="fc" id="L132">        _dictionaryCreatorMap.put(columnName, dictionaryCreator);</span>

        // Create dictionary
<span class="fc" id="L135">        dictionaryCreator.build();</span>

        // Initialize forward index creator
<span class="fc" id="L138">        int cardinality = indexCreationInfo.getDistinctValueCount();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (fieldSpec.isSingleValueField()) {</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">          if (indexCreationInfo.isSorted()) {</span>
<span class="fc" id="L141">            _forwardIndexCreatorMap.put(columnName,</span>
                new SingleValueSortedForwardIndexCreator(_indexDir, cardinality, fieldSpec));
          } else {
<span class="fc" id="L144">            _forwardIndexCreatorMap.put(columnName,</span>
                new SingleValueUnsortedForwardIndexCreator(fieldSpec, _indexDir, cardinality, totalDocs, totalDocs,
                    hasNulls));
          }
        } else {
<span class="fc" id="L149">          _forwardIndexCreatorMap.put(columnName,</span>
              new MultiValueUnsortedForwardIndexCreator(fieldSpec, _indexDir, cardinality, totalDocs,
                  indexCreationInfo.getTotalNumberOfEntries(), hasNulls));
        }

        // Initialize inverted index creator
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (invertedIndexColumns.contains(columnName)) {</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">          if (segmentCreationSpec.isOnHeap()) {</span>
<span class="nc" id="L157">            _invertedIndexCreatorMap.put(columnName,</span>
                new OnHeapBitmapInvertedIndexCreator(_indexDir, columnName, cardinality));
          } else {
<span class="fc" id="L160">            _invertedIndexCreatorMap.put(columnName,</span>
                new OffHeapBitmapInvertedIndexCreator(_indexDir, fieldSpec, cardinality, totalDocs,
                    indexCreationInfo.getTotalNumberOfEntries()));
          }
        }
<span class="fc" id="L165">      } else {</span>
        // Create raw index

        // TODO: add support to multi-value column and inverted index
<span class="fc" id="L169">        Preconditions.checkState(fieldSpec.isSingleValueField(), &quot;Cannot create raw index for multi-value column: %s&quot;,</span>
            columnName);
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        Preconditions.checkState(!invertedIndexColumns.contains(columnName),</span>
            &quot;Cannot create inverted index for raw index column: %s&quot;, columnName);

<span class="fc" id="L174">        ChunkCompressorFactory.CompressionType compressionType = segmentCreationSpec.getColumnCompressionType(columnName);</span>

        // Initialize forward index creator
<span class="fc" id="L177">        _forwardIndexCreatorMap.put(columnName,</span>
            getRawIndexCreatorForColumn(_indexDir, compressionType, columnName, fieldSpec.getDataType(), totalDocs,
                indexCreationInfo.getLegnthOfLongestEntry()));
      }
<span class="fc" id="L181">    }</span>
<span class="fc" id="L182">  }</span>

  /**
   * Returns true if dictionary should be created for a column, false otherwise.
   * Currently there are two sources for this config:
   * &lt;ul&gt;
   *   &lt;li&gt; ColumnIndexCreationInfo (this is currently hard-coded to always return dictionary). &lt;/li&gt;
   *   &lt;li&gt; SegmentGeneratorConfig&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * This method gives preference to the SegmentGeneratorConfig first.
   *
   * @param info Column index creation info
   * @param config Segment generation config
   * @param spec Field spec for the column
   * @return True if dictionary should be created for the column, false otherwise
   */
  private boolean createDictionaryForColumn(ColumnIndexCreationInfo info, SegmentGeneratorConfig config,
      FieldSpec spec) {
<span class="fc" id="L201">    String column = spec.getName();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (config.getRawIndexCreationColumns().contains(column)) {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">      if (!spec.isSingleValueField()) {</span>
<span class="nc" id="L205">        throw new RuntimeException(</span>
            &quot;Creation of indices without dictionaries is supported for single valued columns only.&quot;);
      }
<span class="fc" id="L208">      return false;</span>
    }
<span class="fc" id="L210">    return info.isCreateDictionary();</span>
  }

  @Override
  public void indexRow(GenericRow row) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">    for (String columnName : _forwardIndexCreatorMap.keySet()) {</span>
<span class="fc" id="L216">      Object columnValueToIndex = row.getValue(columnName);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (columnValueToIndex == null) {</span>
<span class="nc" id="L218">        throw new RuntimeException(&quot;Null value for column:&quot; + columnName);</span>
      }

<span class="fc" id="L221">      SegmentDictionaryCreator dictionaryCreator = _dictionaryCreatorMap.get(columnName);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      if (schema.getFieldSpecFor(columnName).isSingleValueField()) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (dictionaryCreator != null) {</span>
<span class="fc" id="L224">          int dictionaryIndex = dictionaryCreator.indexOfSV(columnValueToIndex);</span>
<span class="fc" id="L225">          ((SingleValueForwardIndexCreator) _forwardIndexCreatorMap.get(columnName)).index(docIdCounter,</span>
              dictionaryIndex);
          // TODO : {refactor inverted index addition}
<span class="fc bfc" id="L228" title="All 2 branches covered.">          if (_invertedIndexCreatorMap.containsKey(columnName)) {</span>
<span class="fc" id="L229">            _invertedIndexCreatorMap.get(columnName).addSV(docIdCounter, dictionaryIndex);</span>
          }
<span class="fc" id="L231">        } else {</span>
<span class="fc" id="L232">          ((SingleValueRawIndexCreator) _forwardIndexCreatorMap.get(columnName)).index(docIdCounter,</span>
              columnValueToIndex);
        }
      } else {
<span class="fc" id="L236">        int[] dictionaryIndex = dictionaryCreator.indexOfMV(columnValueToIndex);</span>
<span class="fc" id="L237">        ((MultiValueForwardIndexCreator) _forwardIndexCreatorMap.get(columnName)).index(docIdCounter, dictionaryIndex);</span>

        // TODO : {refactor inverted index addition}
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (_invertedIndexCreatorMap.containsKey(columnName)) {</span>
<span class="fc" id="L241">          _invertedIndexCreatorMap.get(columnName).addMV(docIdCounter, dictionaryIndex);</span>
        }
      }
<span class="fc" id="L244">    }</span>
<span class="fc" id="L245">    docIdCounter++;</span>
<span class="fc" id="L246">  }</span>

  @Override
  public void setSegmentName(String segmentName) {
<span class="fc" id="L250">    this.segmentName = segmentName;</span>
<span class="fc" id="L251">  }</span>

  @Override
  public void seal()
      throws ConfigurationException, IOException {
<span class="fc bfc" id="L256" title="All 2 branches covered.">    for (InvertedIndexCreator invertedIndexCreator : _invertedIndexCreatorMap.values()) {</span>
<span class="fc" id="L257">      invertedIndexCreator.seal();</span>
<span class="fc" id="L258">    }</span>
<span class="fc" id="L259">    writeMetadata();</span>
<span class="fc" id="L260">  }</span>

  void writeMetadata()
      throws ConfigurationException {
<span class="fc" id="L264">    PropertiesConfiguration properties =</span>
        new PropertiesConfiguration(new File(_indexDir, V1Constants.MetadataKeys.METADATA_FILE_NAME));

<span class="fc" id="L267">    properties.setProperty(SEGMENT_CREATOR_VERSION, config.getCreatorVersion());</span>
<span class="fc" id="L268">    properties.setProperty(SEGMENT_PADDING_CHARACTER, String.valueOf(V1Constants.Str.DEFAULT_STRING_PAD_CHAR));</span>
<span class="fc" id="L269">    properties.setProperty(SEGMENT_NAME, segmentName);</span>
<span class="fc" id="L270">    properties.setProperty(TABLE_NAME, config.getTableName());</span>
<span class="fc" id="L271">    properties.setProperty(DIMENSIONS, config.getDimensions());</span>
<span class="fc" id="L272">    properties.setProperty(METRICS, config.getMetrics());</span>
<span class="fc" id="L273">    properties.setProperty(DATETIME_COLUMNS, config.getDateTimeColumnNames());</span>
<span class="fc" id="L274">    properties.setProperty(TIME_COLUMN_NAME, config.getTimeColumnName());</span>
<span class="fc" id="L275">    properties.setProperty(TIME_INTERVAL, &quot;not_there&quot;);</span>
<span class="fc" id="L276">    properties.setProperty(SEGMENT_TOTAL_RAW_DOCS, String.valueOf(totalRawDocs));</span>
<span class="fc" id="L277">    properties.setProperty(SEGMENT_TOTAL_AGGREGATE_DOCS, String.valueOf(totalAggDocs));</span>
<span class="fc" id="L278">    properties.setProperty(SEGMENT_TOTAL_DOCS, String.valueOf(totalDocs));</span>
<span class="fc" id="L279">    properties.setProperty(STAR_TREE_ENABLED, String.valueOf(config.isEnableStarTreeIndex()));</span>
<span class="fc" id="L280">    properties.setProperty(SEGMENT_TOTAL_ERRORS, String.valueOf(totalErrors));</span>
<span class="fc" id="L281">    properties.setProperty(SEGMENT_TOTAL_NULLS, String.valueOf(totalNulls));</span>
<span class="fc" id="L282">    properties.setProperty(SEGMENT_TOTAL_CONVERSIONS, String.valueOf(totalConversions));</span>
<span class="fc" id="L283">    properties.setProperty(SEGMENT_TOTAL_NULL_COLS, String.valueOf(totalNullCols));</span>

<span class="fc" id="L285">    StarTreeIndexSpec starTreeIndexSpec = config.getStarTreeIndexSpec();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (starTreeIndexSpec != null) {</span>
<span class="fc" id="L287">      properties.setProperty(STAR_TREE_SPLIT_ORDER, starTreeIndexSpec.getDimensionsSplitOrder());</span>
<span class="fc" id="L288">      properties.setProperty(STAR_TREE_MAX_LEAF_RECORDS, starTreeIndexSpec.getMaxLeafRecords());</span>
<span class="fc" id="L289">      properties.setProperty(STAR_TREE_SKIP_STAR_NODE_CREATION_FOR_DIMENSIONS,</span>
          starTreeIndexSpec.getSkipStarNodeCreationForDimensions());
<span class="fc" id="L291">      properties.setProperty(STAR_TREE_SKIP_MATERIALIZATION_CARDINALITY,</span>
          starTreeIndexSpec.getSkipMaterializationCardinalityThreshold());
<span class="fc" id="L293">      properties.setProperty(STAR_TREE_SKIP_MATERIALIZATION_FOR_DIMENSIONS,</span>
          starTreeIndexSpec.getSkipMaterializationForDimensions());
    }

<span class="fc" id="L297">    HllConfig hllConfig = config.getHllConfig();</span>
<span class="fc" id="L298">    Map&lt;String, String&gt; derivedHllFieldToOriginMap = null;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">    if (hllConfig != null) {</span>
<span class="fc" id="L300">      properties.setProperty(SEGMENT_HLL_LOG2M, hllConfig.getHllLog2m());</span>
<span class="fc" id="L301">      derivedHllFieldToOriginMap = hllConfig.getDerivedHllFieldToOriginMap();</span>
    }

<span class="fc" id="L304">    String timeColumn = config.getTimeColumnName();</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">    if (indexCreationInfoMap.get(timeColumn) != null) {</span>
<span class="fc" id="L306">      properties.setProperty(SEGMENT_START_TIME, indexCreationInfoMap.get(timeColumn).getMin());</span>
<span class="fc" id="L307">      properties.setProperty(SEGMENT_END_TIME, indexCreationInfoMap.get(timeColumn).getMax());</span>
<span class="fc" id="L308">      properties.setProperty(TIME_UNIT, config.getSegmentTimeUnit());</span>
    }

<span class="fc bfc" id="L311" title="All 2 branches covered.">    if (config.containsCustomProperty(SEGMENT_START_TIME)) {</span>
<span class="fc" id="L312">      properties.setProperty(SEGMENT_START_TIME, config.getStartTime());</span>
    }
<span class="fc bfc" id="L314" title="All 2 branches covered.">    if (config.containsCustomProperty(SEGMENT_END_TIME)) {</span>
<span class="fc" id="L315">      properties.setProperty(SEGMENT_END_TIME, config.getEndTime());</span>
    }
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">    if (config.containsCustomProperty(TIME_UNIT)) {</span>
<span class="nc" id="L318">      properties.setProperty(TIME_UNIT, config.getSegmentTimeUnit());</span>
    }

<span class="fc bfc" id="L321" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; entry : config.getCustomProperties().entrySet()) {</span>
<span class="fc" id="L322">      properties.setProperty(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L323">    }</span>

<span class="fc bfc" id="L325" title="All 2 branches covered.">    for (Map.Entry&lt;String, ColumnIndexCreationInfo&gt; entry : indexCreationInfoMap.entrySet()) {</span>
<span class="fc" id="L326">      String column = entry.getKey();</span>
<span class="fc" id="L327">      ColumnIndexCreationInfo columnIndexCreationInfo = entry.getValue();</span>
<span class="fc" id="L328">      SegmentDictionaryCreator dictionaryCreator = _dictionaryCreatorMap.get(column);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">      int dictionaryElementSize = (dictionaryCreator != null) ? dictionaryCreator.getStringColumnMaxLength() : 0;</span>

      // TODO: after fixing the server-side dependency on HAS_INVERTED_INDEX and deployed, set HAS_INVERTED_INDEX properly
      // The hasInvertedIndex flag in segment metadata is picked up in ColumnMetadata, and will be used during the query
      // plan phase. If it is set to false, then inverted indexes are not used in queries even if they are created via table
      // configs on segment load. So, we set it to true here for now, until we fix the server to update the value inside
      // ColumnMetadata, export information to the query planner that the inverted index available is current and can be used.
      //
      //    boolean hasInvertedIndex = invertedIndexCreatorMap.containsKey();
<span class="fc" id="L338">      boolean hasInvertedIndex = true;</span>

<span class="fc" id="L340">      String hllOriginColumn = null;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">      if (derivedHllFieldToOriginMap != null) {</span>
<span class="fc" id="L342">        hllOriginColumn = derivedHllFieldToOriginMap.get(column);</span>
      }

<span class="fc" id="L345">      addColumnMetadataInfo(properties, column, columnIndexCreationInfo, totalDocs, totalRawDocs, totalAggDocs,</span>
          schema.getFieldSpecFor(column), _dictionaryCreatorMap.containsKey(column), dictionaryElementSize,
          hasInvertedIndex, hllOriginColumn);
<span class="fc" id="L348">    }</span>

<span class="fc" id="L350">    properties.save();</span>
<span class="fc" id="L351">  }</span>

  public static void addColumnMetadataInfo(PropertiesConfiguration properties, String column,
      ColumnIndexCreationInfo columnIndexCreationInfo, int totalDocs, int totalRawDocs, int totalAggDocs,
      FieldSpec fieldSpec, boolean hasDictionary, int dictionaryElementSize, boolean hasInvertedIndex,
      String hllOriginColumn) {
<span class="fc" id="L357">    int distinctValueCount = columnIndexCreationInfo.getDistinctValueCount();</span>
<span class="fc" id="L358">    properties.setProperty(getKeyFor(column, CARDINALITY), String.valueOf(distinctValueCount));</span>
<span class="fc" id="L359">    properties.setProperty(getKeyFor(column, TOTAL_DOCS), String.valueOf(totalDocs));</span>
<span class="fc" id="L360">    properties.setProperty(getKeyFor(column, TOTAL_RAW_DOCS), String.valueOf(totalRawDocs));</span>
<span class="fc" id="L361">    properties.setProperty(getKeyFor(column, TOTAL_AGG_DOCS), String.valueOf(totalAggDocs));</span>
<span class="fc" id="L362">    properties.setProperty(getKeyFor(column, DATA_TYPE), String.valueOf(fieldSpec.getDataType()));</span>
<span class="fc" id="L363">    properties.setProperty(getKeyFor(column, BITS_PER_ELEMENT),</span>
        String.valueOf(SingleValueUnsortedForwardIndexCreator.getNumOfBits(distinctValueCount)));
<span class="fc" id="L365">    properties.setProperty(getKeyFor(column, DICTIONARY_ELEMENT_SIZE), String.valueOf(dictionaryElementSize));</span>
<span class="fc" id="L366">    properties.setProperty(getKeyFor(column, COLUMN_TYPE), String.valueOf(fieldSpec.getFieldType()));</span>
<span class="fc" id="L367">    properties.setProperty(getKeyFor(column, IS_SORTED), String.valueOf(columnIndexCreationInfo.isSorted()));</span>
<span class="fc" id="L368">    properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));</span>
<span class="fc" id="L369">    properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));</span>
<span class="fc" id="L370">    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),</span>
        String.valueOf(hasInvertedIndex));
<span class="fc" id="L372">    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),</span>
        String.valueOf(fieldSpec.isSingleValueField()));
<span class="fc" id="L374">    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),</span>
        String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));
<span class="fc" id="L376">    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),</span>
        String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));
<span class="fc" id="L378">    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),</span>
        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));

<span class="fc" id="L381">    PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();</span>
<span class="fc" id="L382">    int numPartitions = columnIndexCreationInfo.getNumPartitions();</span>
<span class="fc" id="L383">    List&lt;IntRange&gt; partitionRanges = columnIndexCreationInfo.getPartitionRanges();</span>
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">    if (partitionFunction != null &amp;&amp; partitionRanges != null) {</span>
<span class="fc" id="L385">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),</span>
          partitionFunction.toString());
<span class="fc" id="L387">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS), numPartitions);</span>
<span class="fc" id="L388">      String partitionValues = ColumnPartitionConfig.rangesToString(partitionRanges);</span>
<span class="fc" id="L389">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES), partitionValues);</span>
    }

    // datetime field
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {</span>
<span class="nc" id="L394">      DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;</span>
<span class="nc" id="L395">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),</span>
          dateTimeFieldSpec.getFormat());
<span class="nc" id="L397">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),</span>
          dateTimeFieldSpec.getGranularity());
    }

    // HLL derived fields
<span class="fc bfc" id="L402" title="All 2 branches covered.">    if (hllOriginColumn != null) {</span>
<span class="fc" id="L403">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, ORIGIN_COLUMN), hllOriginColumn);</span>
<span class="fc" id="L404">      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DERIVED_METRIC_TYPE), &quot;HLL&quot;);</span>
    }

<span class="fc" id="L407">    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">    if (defaultNullValue == null) {</span>
<span class="nc" id="L409">      defaultNullValue = fieldSpec.getDefaultNullValue();</span>
    }
<span class="fc" id="L411">    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),</span>
        String.valueOf(defaultNullValue));
<span class="fc" id="L413">  }</span>

  public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,
      String maxValue) {
<span class="fc" id="L417">    properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);</span>
<span class="fc" id="L418">    properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);</span>
<span class="fc" id="L419">  }</span>

  public static void removeColumnMetadataInfo(PropertiesConfiguration properties, String column) {
<span class="fc" id="L422">    properties.clearProperty(getKeyFor(column, CARDINALITY));</span>
<span class="fc" id="L423">    properties.clearProperty(getKeyFor(column, TOTAL_DOCS));</span>
<span class="fc" id="L424">    properties.clearProperty(getKeyFor(column, TOTAL_RAW_DOCS));</span>
<span class="fc" id="L425">    properties.clearProperty(getKeyFor(column, TOTAL_AGG_DOCS));</span>
<span class="fc" id="L426">    properties.clearProperty(getKeyFor(column, DATA_TYPE));</span>
<span class="fc" id="L427">    properties.clearProperty(getKeyFor(column, BITS_PER_ELEMENT));</span>
<span class="fc" id="L428">    properties.clearProperty(getKeyFor(column, DICTIONARY_ELEMENT_SIZE));</span>
<span class="fc" id="L429">    properties.clearProperty(getKeyFor(column, COLUMN_TYPE));</span>
<span class="fc" id="L430">    properties.clearProperty(getKeyFor(column, IS_SORTED));</span>
<span class="fc" id="L431">    properties.clearProperty(getKeyFor(column, HAS_NULL_VALUE));</span>
<span class="fc" id="L432">    properties.clearProperty(getKeyFor(column, HAS_DICTIONARY));</span>
<span class="fc" id="L433">    properties.clearProperty(getKeyFor(column, HAS_INVERTED_INDEX));</span>
<span class="fc" id="L434">    properties.clearProperty(getKeyFor(column, IS_SINGLE_VALUED));</span>
<span class="fc" id="L435">    properties.clearProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS));</span>
<span class="fc" id="L436">    properties.clearProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES));</span>
<span class="fc" id="L437">    properties.clearProperty(getKeyFor(column, IS_AUTO_GENERATED));</span>
<span class="fc" id="L438">    properties.clearProperty(getKeyFor(column, DEFAULT_NULL_VALUE));</span>
<span class="fc" id="L439">    properties.clearProperty(getKeyFor(column, DERIVED_METRIC_TYPE));</span>
<span class="fc" id="L440">    properties.clearProperty(getKeyFor(column, ORIGIN_COLUMN));</span>
<span class="fc" id="L441">    properties.clearProperty(getKeyFor(column, MIN_VALUE));</span>
<span class="fc" id="L442">    properties.clearProperty(getKeyFor(column, MAX_VALUE));</span>
<span class="fc" id="L443">  }</span>

  /**
   * Helper method to build the raw index creator for the column.
   * Assumes that column to be indexed is single valued.
   *
   * @param file Output index file
   * @param column Column name
   * @param totalDocs Total number of documents to index
   * @param lengthOfLongestEntry Length of longest entry
   * @return
   * @throws IOException
   */
  public static SingleValueRawIndexCreator getRawIndexCreatorForColumn(File file,
      ChunkCompressorFactory.CompressionType compressionType, String column, FieldSpec.DataType dataType, int totalDocs,
      int lengthOfLongestEntry)
      throws IOException {

    SingleValueRawIndexCreator indexCreator;
<span class="pc bpc" id="L462" title="1 of 6 branches missed.">    switch (dataType) {</span>
      case INT:
<span class="fc" id="L464">        indexCreator = new SingleValueFixedByteRawIndexCreator(file, compressionType, column, totalDocs,</span>
            V1Constants.Numbers.INTEGER_SIZE);
<span class="fc" id="L466">        break;</span>

      case LONG:
<span class="fc" id="L469">        indexCreator = new SingleValueFixedByteRawIndexCreator(file, compressionType, column, totalDocs,</span>
            V1Constants.Numbers.LONG_SIZE);
<span class="fc" id="L471">        break;</span>

      case FLOAT:
<span class="fc" id="L474">        indexCreator = new SingleValueFixedByteRawIndexCreator(file, compressionType, column, totalDocs,</span>
            V1Constants.Numbers.FLOAT_SIZE);
<span class="fc" id="L476">        break;</span>

      case DOUBLE:
<span class="fc" id="L479">        indexCreator = new SingleValueFixedByteRawIndexCreator(file, compressionType, column, totalDocs,</span>
            V1Constants.Numbers.DOUBLE_SIZE);
<span class="fc" id="L481">        break;</span>

      case STRING:
<span class="fc" id="L484">        indexCreator =</span>
            new SingleValueVarByteRawIndexCreator(file, compressionType, column, totalDocs, lengthOfLongestEntry);
<span class="fc" id="L486">        break;</span>

      default:
<span class="nc" id="L489">        throw new UnsupportedOperationException(&quot;Data type not supported for raw indexing: &quot; + dataType);</span>
    }

<span class="fc" id="L492">    return indexCreator;</span>
  }

  @Override
  public void close()
      throws IOException {
<span class="fc bfc" id="L498" title="All 2 branches covered.">    for (SegmentDictionaryCreator dictionaryCreator : _dictionaryCreatorMap.values()) {</span>
<span class="fc" id="L499">      dictionaryCreator.close();</span>
<span class="fc" id="L500">    }</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">    for (ForwardIndexCreator forwardIndexCreator : _forwardIndexCreatorMap.values()) {</span>
<span class="fc" id="L502">      forwardIndexCreator.close();</span>
<span class="fc" id="L503">    }</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">    for (InvertedIndexCreator invertedIndexCreator : _invertedIndexCreatorMap.values()) {</span>
<span class="fc" id="L505">      invertedIndexCreator.close();</span>
<span class="fc" id="L506">    }</span>
<span class="fc" id="L507">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>