<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Pql2Compiler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-common</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.pql.parsers</a> &gt; <span class="el_source">Pql2Compiler.java</span></div><h1>Pql2Compiler.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.pql.parsers;

import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.request.transform.TransformExpressionTree;
import com.linkedin.pinot.pql.parsers.pql2.ast.AstNode;

import com.linkedin.pinot.pql.parsers.pql2.ast.BaseAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.BetweenPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.ComparisonPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.FunctionCallAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.HavingAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.InPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OutputColumnAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.RegexpLikePredicateAstNode;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonToken;
import org.antlr.v4.runtime.CommonTokenFactory;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.UnbufferedTokenStream;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.misc.Nullable;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.apache.commons.lang.math.NumberUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;


/**
 * PQL 2 compiler.
 */
<span class="fc" id="L54">public class Pql2Compiler implements AbstractCompiler {</span>
<span class="fc" id="L55">  private boolean _splitInClause = false;</span>

<span class="fc" id="L57">  private static class ErrorListener extends BaseErrorListener {</span>
    @Override
    public void syntaxError(@NotNull Recognizer&lt;?, ?&gt; recognizer, @Nullable Object offendingSymbol, int line,
        int charPositionInLine, @NotNull String msg, @Nullable RecognitionException e) {
<span class="fc" id="L61">      throw new Pql2CompilationException(msg, offendingSymbol, line, charPositionInLine, e);</span>
    }
  }

<span class="fc" id="L65">  private static final ErrorListener ERROR_LISTENER = new ErrorListener();</span>

  @Override
  public BrokerRequest compileToBrokerRequest(String expression) throws Pql2CompilationException {
<span class="fc" id="L69">    return compileToBrokerRequest(expression, false);</span>
  }

  /**
   * Compile the given expression into {@link BrokerRequest}.
   *
   * @param expression Expression to compile
   * @param splitInClause Value of in clause sent as list if true, joined with delimiter otherwise. This is a temporary
   *                      argument to keep the broker and server compatible, and will be removed.
   * @return BrokerRequest
   * @throws Pql2CompilationException
   */
  public BrokerRequest compileToBrokerRequest(String expression, boolean splitInClause) throws Pql2CompilationException {
<span class="fc" id="L82">    _splitInClause = splitInClause;</span>
    try {
      //
<span class="fc" id="L85">      CharStream charStream = new ANTLRInputStream(expression);</span>
<span class="fc" id="L86">      PQL2Lexer lexer = new PQL2Lexer(charStream);</span>
<span class="fc" id="L87">      lexer.setTokenFactory(new CommonTokenFactory(true));</span>
<span class="fc" id="L88">      lexer.removeErrorListeners();</span>
<span class="fc" id="L89">      lexer.addErrorListener(ERROR_LISTENER);</span>
<span class="fc" id="L90">      TokenStream tokenStream = new UnbufferedTokenStream&lt;CommonToken&gt;(lexer);</span>
<span class="fc" id="L91">      PQL2Parser parser = new PQL2Parser(tokenStream);</span>
<span class="fc" id="L92">      parser.setErrorHandler(new BailErrorStrategy());</span>
<span class="fc" id="L93">      parser.removeErrorListeners();</span>
<span class="fc" id="L94">      parser.addErrorListener(ERROR_LISTENER);</span>

      // Parse
<span class="fc" id="L97">      ParseTree parseTree = parser.root();</span>

<span class="fc" id="L99">      ParseTreeWalker walker = new ParseTreeWalker();</span>
<span class="fc" id="L100">      Pql2AstListener listener = new Pql2AstListener(expression, _splitInClause);</span>
<span class="fc" id="L101">      walker.walk(listener, parseTree);</span>

<span class="fc" id="L103">      AstNode rootNode = listener.getRootNode();</span>
      //Validate the HAVING clause if any
<span class="fc" id="L105">      validateHavingClause(rootNode);</span>

<span class="fc" id="L107">      BrokerRequest brokerRequest = new BrokerRequest();</span>
<span class="fc" id="L108">      rootNode.updateBrokerRequest(brokerRequest);</span>
<span class="fc" id="L109">      return brokerRequest;</span>
<span class="fc" id="L110">    } catch (Pql2CompilationException e) {</span>
<span class="fc" id="L111">      throw e;</span>
<span class="fc" id="L112">    } catch (Exception e) {</span>
<span class="fc" id="L113">      throw new Pql2CompilationException(ExceptionUtils.getStackTrace(e));</span>
    }
  }

  @Override
  public TransformExpressionTree compileToExpressionTree(String expression) {
<span class="fc" id="L119">    CharStream charStream = new ANTLRInputStream(expression);</span>
<span class="fc" id="L120">    PQL2Lexer lexer = new PQL2Lexer(charStream);</span>
<span class="fc" id="L121">    lexer.setTokenFactory(new CommonTokenFactory(true));</span>
<span class="fc" id="L122">    TokenStream tokenStream = new UnbufferedTokenStream&lt;CommonToken&gt;(lexer);</span>
<span class="fc" id="L123">    PQL2Parser parser = new PQL2Parser(tokenStream);</span>
<span class="fc" id="L124">    parser.setErrorHandler(new BailErrorStrategy());</span>

    // Parse
<span class="fc" id="L127">    ParseTree parseTree = parser.expression();</span>

<span class="fc" id="L129">    ParseTreeWalker walker = new ParseTreeWalker();</span>
<span class="fc" id="L130">    Pql2AstListener listener = new Pql2AstListener(expression, _splitInClause);</span>
<span class="fc" id="L131">    walker.walk(listener, parseTree);</span>

<span class="fc" id="L133">    final AstNode rootNode = listener.getRootNode();</span>
<span class="fc" id="L134">    return TransformExpressionTree.buildTree(rootNode);</span>
  }

  private void validateHavingClause(AstNode rootNode) {
<span class="fc" id="L138">    List&lt;? extends AstNode&gt; children = rootNode.getChildren();</span>
<span class="fc" id="L139">    BaseAstNode outList = (BaseAstNode) children.get(0);</span>
<span class="fc" id="L140">    HavingAstNode havingList = null;</span>
<span class="fc" id="L141">    boolean isThereHaving = false;</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">    for (int i = 1; i &lt; children.size(); i++) {</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">      if (children.get(i) instanceof HavingAstNode) {</span>
<span class="fc" id="L145">        havingList = (HavingAstNode) children.get(i);</span>
<span class="fc" id="L146">        isThereHaving = true;</span>
<span class="fc" id="L147">        break;</span>
      }
    }

<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (isThereHaving) {</span>
      // Check if the HAVING predicate function call is in the select list;
      // if not: add the missing function call to select list and set isInSelectList to false
<span class="fc" id="L154">      List&lt;FunctionCallAstNode&gt; functionCalls = havingTreeDFSTraversalToFindFunctionCalls(havingList);</span>

<span class="pc bpc" id="L156" title="1 of 2 branches missed.">      if (functionCalls.isEmpty()) {</span>
<span class="nc" id="L157">        throw new Pql2CompilationException(&quot;HAVING clause needs to have minimum one function call comparison&quot;);</span>
      }

<span class="fc" id="L160">      List&lt;? extends AstNode&gt; outListChildren = outList.getChildren();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">      for (FunctionCallAstNode havingFunction : functionCalls) {</span>
<span class="fc" id="L162">        boolean functionCallIsInSelectList = false;</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        for (AstNode anOutListChildren : outListChildren) {</span>
<span class="fc" id="L164">          OutputColumnAstNode selectItem = (OutputColumnAstNode) anOutListChildren;</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">          if (selectItem.getChildren().get(0) instanceof FunctionCallAstNode) {</span>
<span class="fc" id="L166">            FunctionCallAstNode function = (FunctionCallAstNode) selectItem.getChildren().get(0);</span>
<span class="pc bpc" id="L167" title="1 of 4 branches missed.">            if (function.getExpression().equalsIgnoreCase(havingFunction.getExpression()) &amp;&amp; function.getName()</span>
                .equalsIgnoreCase(havingFunction.getName())) {
<span class="fc" id="L169">              functionCallIsInSelectList = true;</span>
<span class="fc" id="L170">              break;</span>
            }
          }
<span class="fc" id="L173">        }</span>

<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (functionCallIsInSelectList == false) {</span>
<span class="nc" id="L176">          OutputColumnAstNode havingFunctionAstNode = new OutputColumnAstNode();</span>
<span class="nc" id="L177">          havingFunction.setIsInSelectList(false);</span>
<span class="nc" id="L178">          havingFunctionAstNode.addChild(havingFunction);</span>
<span class="nc" id="L179">          havingFunction.setParent(havingFunctionAstNode);</span>
<span class="nc" id="L180">          outList.addChild(havingFunctionAstNode);</span>
<span class="nc" id="L181">          havingFunctionAstNode.setParent(outList);</span>
        }
<span class="fc" id="L183">      }</span>
    }
<span class="fc" id="L185">  }</span>

  private List&lt;FunctionCallAstNode&gt; havingTreeDFSTraversalToFindFunctionCalls(HavingAstNode havingList) {
<span class="fc" id="L188">    List&lt;FunctionCallAstNode&gt; functionCalls = new ArrayList&lt;FunctionCallAstNode&gt;();</span>
<span class="fc" id="L189">    Stack&lt;AstNode&gt; astNodeStack = new Stack&lt;AstNode&gt;();</span>
<span class="fc" id="L190">    astNodeStack.add(havingList);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">    while (!astNodeStack.isEmpty()) {</span>
<span class="fc" id="L192">      AstNode visitingNode = astNodeStack.pop();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">      if (visitingNode instanceof ComparisonPredicateAstNode) {</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (!((ComparisonPredicateAstNode) visitingNode).isItFunctionCallComparison()) {</span>
<span class="nc" id="L195">          throw new Pql2CompilationException(&quot;Having predicate only compares function calls&quot;);</span>
        }
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (!NumberUtils.isNumber(((ComparisonPredicateAstNode) visitingNode).getValue())) {</span>
<span class="nc" id="L198">          throw new Pql2CompilationException(&quot;Having clause only supports comparing function result with numbers&quot;);</span>
        }
<span class="fc" id="L200">        functionCalls.add(((ComparisonPredicateAstNode) visitingNode).getFunction());</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">      } else if (visitingNode instanceof BetweenPredicateAstNode) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (!((BetweenPredicateAstNode) visitingNode).isItFunctionCallComparison()) {</span>
<span class="nc" id="L203">          throw new Pql2CompilationException(&quot;Having predicate only compares function calls&quot;);</span>
        }
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (!NumberUtils.isNumber(((BetweenPredicateAstNode) visitingNode).getLeftValue())) {</span>
<span class="nc" id="L206">          throw new Pql2CompilationException(&quot;Having clause only supports comparing function result with numbers&quot;);</span>
        }
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (!NumberUtils.isNumber(((BetweenPredicateAstNode) visitingNode).getRightValue())) {</span>
<span class="nc" id="L209">          throw new Pql2CompilationException(&quot;Having clause only supports comparing function result with numbers&quot;);</span>
        }
<span class="nc" id="L211">        functionCalls.add(((BetweenPredicateAstNode) visitingNode).getFunction());</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      } else if (visitingNode instanceof InPredicateAstNode) {</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (!((InPredicateAstNode) visitingNode).isItFunctionCallComparison()) {</span>
<span class="nc" id="L214">          throw new Pql2CompilationException(&quot;Having predicate only compares function calls&quot;);</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (String value : ((InPredicateAstNode) visitingNode).getValues()) {</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">          if (!NumberUtils.isNumber(value)) {</span>
<span class="nc" id="L218">            throw new Pql2CompilationException(&quot;Having clause only supports comparing function result with numbers&quot;);</span>
          }
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">        functionCalls.add(((InPredicateAstNode) visitingNode).getFunction());</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">      } else if (visitingNode instanceof RegexpLikePredicateAstNode) {</span>
<span class="nc" id="L223">        throw new Pql2CompilationException(&quot;Having predicate does not support regular expression&quot;);</span>
      } else {
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (visitingNode.hasChildren()) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">          for (AstNode children : visitingNode.getChildren()) {</span>
<span class="fc" id="L227">            astNodeStack.add(children);</span>
<span class="fc" id="L228">          }</span>
        }
      }
<span class="fc" id="L231">    }</span>
<span class="fc" id="L232">    return functionCalls;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>