<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Pql2AstListener.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-common</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.pql.parsers</a> &gt; <span class="el_source">Pql2AstListener.java</span></div><h1>Pql2AstListener.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.pql.parsers;

import com.linkedin.pinot.pql.parsers.pql2.ast.AstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.BetweenPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.BinaryMathOpAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.BooleanOperatorAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.ComparisonPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.ExpressionParenthesisGroupAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.FloatingPointLiteralAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.FunctionCallAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.GroupByAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.HavingAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.IdentifierAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.InPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.IntegerLiteralAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.IsPredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.LimitAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OptionAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OptionsAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OrderByAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OrderByExpressionAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OutputColumnAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.OutputColumnListAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.PredicateListAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.PredicateParenthesisGroupAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.RegexpLikePredicateAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.SelectAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.StarColumnListAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.StarExpressionAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.StringLiteralAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.TableNameAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.TopAstNode;
import com.linkedin.pinot.pql.parsers.pql2.ast.WhereAstNode;
import java.util.Stack;
import org.antlr.v4.runtime.misc.NotNull;


/**
 * PQL 2 parse tree listener that generates an abstract syntax tree.
 */
public class Pql2AstListener extends PQL2BaseListener {
<span class="fc" id="L57">  Stack&lt;AstNode&gt; _nodeStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L58">  AstNode _rootNode = null;</span>
  private String _expression;
  private final boolean _splitInClause;

<span class="fc" id="L62">  public Pql2AstListener(String expression, boolean splitInClause) {</span>
<span class="fc" id="L63">    _expression = expression; // Original expression being parsed.</span>
<span class="fc" id="L64">    _splitInClause = splitInClause;</span>
<span class="fc" id="L65">  }</span>

  private void pushNode(AstNode node) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">    if (_rootNode == null) {</span>
<span class="fc" id="L69">      _rootNode = node;</span>
    }

<span class="fc" id="L72">    AstNode parentNode = null;</span>

<span class="fc bfc" id="L74" title="All 2 branches covered.">    if (!_nodeStack.isEmpty()) {</span>
<span class="fc" id="L75">      parentNode = _nodeStack.peek();</span>
    }

<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (parentNode != null) {</span>
<span class="fc" id="L79">      parentNode.addChild(node);</span>
    }

<span class="fc" id="L82">    node.setParent(parentNode);</span>

<span class="fc" id="L84">    _nodeStack.push(node);</span>
<span class="fc" id="L85">  }</span>

  private void popNode() {
<span class="fc" id="L88">    AstNode topNode = _nodeStack.pop();</span>

<span class="fc" id="L90">    topNode.doneProcessingChildren();</span>
<span class="fc" id="L91">  }</span>

  public AstNode getRootNode() {
<span class="fc" id="L94">    return _rootNode;</span>
  }

  @Override
  public void enterSelect(@NotNull PQL2Parser.SelectContext ctx) {
<span class="fc" id="L99">    pushNode(new SelectAstNode());</span>
<span class="fc" id="L100">  }</span>

  @Override
  public void exitSelect(@NotNull PQL2Parser.SelectContext ctx) {
<span class="fc" id="L104">    popNode();</span>
<span class="fc" id="L105">  }</span>

  @Override
  public void enterTableName(@NotNull PQL2Parser.TableNameContext ctx) {
<span class="fc" id="L109">    pushNode(new TableNameAstNode(ctx.getText()));</span>
<span class="fc" id="L110">  }</span>

  @Override
  public void exitTableName(@NotNull PQL2Parser.TableNameContext ctx) {
<span class="fc" id="L114">    popNode();</span>
<span class="fc" id="L115">  }</span>

  @Override
  public void enterStarColumnList(@NotNull PQL2Parser.StarColumnListContext ctx) {
<span class="fc" id="L119">    pushNode(new StarColumnListAstNode());</span>
<span class="fc" id="L120">  }</span>

  @Override
  public void exitStarColumnList(@NotNull PQL2Parser.StarColumnListContext ctx) {
<span class="fc" id="L124">    popNode();</span>
<span class="fc" id="L125">  }</span>

  @Override
  public void enterOutputColumnList(@NotNull PQL2Parser.OutputColumnListContext ctx) {
<span class="fc" id="L129">    pushNode(new OutputColumnListAstNode());</span>
<span class="fc" id="L130">  }</span>

  @Override
  public void exitOutputColumnList(@NotNull PQL2Parser.OutputColumnListContext ctx) {
<span class="fc" id="L134">    popNode();</span>
<span class="fc" id="L135">  }</span>

  @Override
  public void enterIsPredicate(@NotNull PQL2Parser.IsPredicateContext ctx) {
<span class="nc" id="L139">    pushNode(new IsPredicateAstNode());</span>
<span class="nc" id="L140">  }</span>

  @Override
  public void exitIsPredicate(@NotNull PQL2Parser.IsPredicateContext ctx) {
<span class="nc" id="L144">    popNode();</span>
<span class="nc" id="L145">  }</span>

  @Override
  public void enterPredicateParenthesisGroup(@NotNull PQL2Parser.PredicateParenthesisGroupContext ctx) {
<span class="fc" id="L149">    pushNode(new PredicateParenthesisGroupAstNode());</span>
<span class="fc" id="L150">  }</span>

  @Override
  public void exitPredicateParenthesisGroup(@NotNull PQL2Parser.PredicateParenthesisGroupContext ctx) {
<span class="fc" id="L154">    popNode();</span>
<span class="fc" id="L155">  }</span>

  @Override
  public void enterComparisonPredicate(@NotNull PQL2Parser.ComparisonPredicateContext ctx) {
<span class="fc" id="L159">    pushNode(new ComparisonPredicateAstNode(ctx.getChild(0).getChild(1).getText()));</span>
<span class="fc" id="L160">  }</span>

  @Override
  public void exitComparisonPredicate(@NotNull PQL2Parser.ComparisonPredicateContext ctx) {
<span class="fc" id="L164">    popNode();</span>
<span class="fc" id="L165">  }</span>

  @Override
  public void enterExpressionParenthesisGroup(@NotNull PQL2Parser.ExpressionParenthesisGroupContext ctx) {
<span class="nc" id="L169">    pushNode(new ExpressionParenthesisGroupAstNode());</span>
<span class="nc" id="L170">  }</span>

  @Override
  public void exitExpressionParenthesisGroup(@NotNull PQL2Parser.ExpressionParenthesisGroupContext ctx) {
<span class="nc" id="L174">    popNode();</span>
<span class="nc" id="L175">  }</span>

  @Override
  public void enterOutputColumn(@NotNull PQL2Parser.OutputColumnContext ctx) {
<span class="fc" id="L179">    pushNode(new OutputColumnAstNode());</span>
<span class="fc" id="L180">  }</span>

  @Override
  public void exitOutputColumn(@NotNull PQL2Parser.OutputColumnContext ctx) {
<span class="fc" id="L184">    popNode();</span>
<span class="fc" id="L185">  }</span>

  @Override
  public void enterIdentifier(@NotNull PQL2Parser.IdentifierContext ctx) {
<span class="fc" id="L189">    pushNode(new IdentifierAstNode(ctx.getText()));</span>
<span class="fc" id="L190">  }</span>

  @Override
  public void exitIdentifier(@NotNull PQL2Parser.IdentifierContext ctx) {
<span class="fc" id="L194">    popNode();</span>
<span class="fc" id="L195">  }</span>

  @Override
  public void enterStarExpression(@NotNull PQL2Parser.StarExpressionContext ctx) {
<span class="fc" id="L199">    pushNode(new StarExpressionAstNode());</span>
<span class="fc" id="L200">  }</span>

  @Override
  public void exitStarExpression(@NotNull PQL2Parser.StarExpressionContext ctx) {
<span class="fc" id="L204">    popNode();</span>
<span class="fc" id="L205">  }</span>

  @Override
  public void enterFunctionCall(@NotNull PQL2Parser.FunctionCallContext ctx) {
<span class="fc" id="L209">    String expression = _expression.substring(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex() + 1);</span>
<span class="fc" id="L210">    pushNode(new FunctionCallAstNode(ctx.getChild(0).getText(), expression));</span>
<span class="fc" id="L211">  }</span>

  @Override
  public void exitFunctionCall(@NotNull PQL2Parser.FunctionCallContext ctx) {
<span class="fc" id="L215">    popNode();</span>
<span class="fc" id="L216">  }</span>

  @Override
  public void enterIntegerLiteral(@NotNull PQL2Parser.IntegerLiteralContext ctx) {
<span class="fc" id="L220">    pushNode(new IntegerLiteralAstNode(Long.parseLong(ctx.getText())));</span>
<span class="fc" id="L221">  }</span>

  @Override
  public void exitIntegerLiteral(@NotNull PQL2Parser.IntegerLiteralContext ctx) {
<span class="fc" id="L225">    popNode();</span>
<span class="fc" id="L226">  }</span>

  @Override
  public void enterOrderBy(@NotNull PQL2Parser.OrderByContext ctx) {
<span class="fc" id="L230">    pushNode(new OrderByAstNode());</span>
<span class="fc" id="L231">  }</span>

  @Override
  public void exitOrderBy(@NotNull PQL2Parser.OrderByContext ctx) {
<span class="fc" id="L235">    popNode();</span>
<span class="fc" id="L236">  }</span>

  @Override
  public void enterGroupBy(@NotNull PQL2Parser.GroupByContext ctx) {
<span class="fc" id="L240">    pushNode(new GroupByAstNode());</span>
<span class="fc" id="L241">  }</span>

  @Override
  public void exitGroupBy(@NotNull PQL2Parser.GroupByContext ctx) {
<span class="fc" id="L245">    popNode();</span>
<span class="fc" id="L246">  }</span>

  @Override
  public void enterBetweenPredicate(@NotNull PQL2Parser.BetweenPredicateContext ctx) {
<span class="fc" id="L250">    pushNode(new BetweenPredicateAstNode());</span>
<span class="fc" id="L251">  }</span>

  @Override
  public void exitBetweenPredicate(@NotNull PQL2Parser.BetweenPredicateContext ctx) {
<span class="fc" id="L255">    popNode();</span>
<span class="fc" id="L256">  }</span>

  @Override
  public void enterBinaryMathOp(@NotNull PQL2Parser.BinaryMathOpContext ctx) {
<span class="nc" id="L260">    pushNode(new BinaryMathOpAstNode(ctx.getChild(1).getText()));</span>
<span class="nc" id="L261">  }</span>

  @Override
  public void exitBinaryMathOp(@NotNull PQL2Parser.BinaryMathOpContext ctx) {
<span class="nc" id="L265">    popNode();</span>
<span class="nc" id="L266">  }</span>

  @Override
  public void enterInPredicate(@NotNull PQL2Parser.InPredicateContext ctx) {
<span class="fc" id="L270">    boolean isNotInClause = false;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">    if (&quot;not&quot;.equalsIgnoreCase(ctx.getChild(0).getChild(1).getText())) {</span>
<span class="fc" id="L272">      isNotInClause = true;</span>
    }
<span class="fc" id="L274">    pushNode(new InPredicateAstNode(isNotInClause, _splitInClause));</span>
<span class="fc" id="L275">  }</span>

  @Override
  public void exitInPredicate(@NotNull PQL2Parser.InPredicateContext ctx) {
<span class="fc" id="L279">    popNode();</span>
<span class="fc" id="L280">  }</span>

  @Override
  public void enterRegexpLikePredicate(@NotNull PQL2Parser.RegexpLikePredicateContext ctx) {
<span class="nc" id="L284">    pushNode(new RegexpLikePredicateAstNode());</span>
<span class="nc" id="L285">  }</span>

  @Override
  public void exitRegexpLikePredicate(@NotNull PQL2Parser.RegexpLikePredicateContext ctx) {
<span class="nc" id="L289">    popNode();</span>
<span class="nc" id="L290">  }</span>

  @Override
  public void enterHaving(@NotNull PQL2Parser.HavingContext ctx) {
<span class="fc" id="L294">    pushNode(new HavingAstNode());</span>
<span class="fc" id="L295">  }</span>

  @Override
  public void exitHaving(@NotNull PQL2Parser.HavingContext ctx) {
<span class="fc" id="L299">    popNode();</span>
<span class="fc" id="L300">  }</span>

  @Override
  public void enterStringLiteral(@NotNull PQL2Parser.StringLiteralContext ctx) {
<span class="fc" id="L304">    String text = ctx.getText();</span>
<span class="fc" id="L305">    int textLength = text.length();</span>

    // String literals can be either 'foo' or &quot;bar&quot;. We support quoting by doubling the beginning character, so that
    // users can write 'Martha''s Vineyard' or &quot;&quot;&quot;foo&quot;&quot;&quot;
<span class="fc" id="L309">    String literalWithoutQuotes = text.substring(1, textLength - 1);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">    if (text.charAt(0) == '\'') {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">      if (literalWithoutQuotes.contains(&quot;''&quot;)) {</span>
<span class="fc" id="L312">        literalWithoutQuotes = literalWithoutQuotes.replaceAll(&quot;''&quot;, &quot;'&quot;);</span>
      }

<span class="fc" id="L315">      pushNode(new StringLiteralAstNode(literalWithoutQuotes));</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">    } else if (text.charAt(0) == '&quot;') {</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">      if (literalWithoutQuotes.contains(&quot;\&quot;\&quot;&quot;)) {</span>
<span class="fc" id="L318">        literalWithoutQuotes = literalWithoutQuotes.replaceAll(&quot;\&quot;\&quot;&quot;, &quot;\&quot;&quot;);</span>
      }

<span class="fc" id="L321">      pushNode(new StringLiteralAstNode(literalWithoutQuotes));</span>
    } else {
<span class="nc" id="L323">      throw new Pql2CompilationException(&quot;String literal does not start with either '  or \&quot;&quot;);</span>
    }
<span class="fc" id="L325">  }</span>

  @Override
  public void exitStringLiteral(@NotNull PQL2Parser.StringLiteralContext ctx) {
<span class="fc" id="L329">    popNode();</span>
<span class="fc" id="L330">  }</span>

  @Override
  public void enterFloatingPointLiteral(@NotNull PQL2Parser.FloatingPointLiteralContext ctx) {
<span class="nc" id="L334">    pushNode(new FloatingPointLiteralAstNode(Double.valueOf(ctx.getText())));</span>
<span class="nc" id="L335">  }</span>

  @Override
  public void exitFloatingPointLiteral(@NotNull PQL2Parser.FloatingPointLiteralContext ctx) {
<span class="nc" id="L339">    popNode();</span>
<span class="nc" id="L340">  }</span>

  @Override
  public void enterLimit(@NotNull PQL2Parser.LimitContext ctx) {
    // Can either be LIMIT &lt;maxRows&gt; or LIMIT &lt;offset&gt;, &lt;maxRows&gt; (the second is a MySQL syntax extension)
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">    if (ctx.getChild(0).getChildCount() == 2) {</span>
<span class="fc" id="L346">      pushNode(new LimitAstNode(Integer.parseInt(ctx.getChild(0).getChild(1).getText())));</span>
    } else {
<span class="nc" id="L348">      pushNode(new LimitAstNode(Integer.parseInt(ctx.getChild(0).getChild(3).getText()),</span>
          Integer.parseInt(ctx.getChild(0).getChild(1).getText())));
    }
<span class="fc" id="L351">  }</span>

  @Override
  public void exitLimit(@NotNull PQL2Parser.LimitContext ctx) {
<span class="fc" id="L355">    popNode();</span>
<span class="fc" id="L356">  }</span>

  @Override
  public void enterWhere(@NotNull PQL2Parser.WhereContext ctx) {
<span class="fc" id="L360">    pushNode(new WhereAstNode());</span>
<span class="fc" id="L361">  }</span>

  @Override
  public void exitWhere(@NotNull PQL2Parser.WhereContext ctx) {
<span class="fc" id="L365">    popNode();</span>
<span class="fc" id="L366">  }</span>

  @Override
  public void enterTopClause(@NotNull PQL2Parser.TopClauseContext ctx) {
<span class="fc" id="L370">    pushNode(new TopAstNode(Integer.parseInt(ctx.getChild(1).getText())));</span>
<span class="fc" id="L371">  }</span>

  @Override
  public void exitTopClause(@NotNull PQL2Parser.TopClauseContext ctx) {
<span class="fc" id="L375">    popNode();</span>
<span class="fc" id="L376">  }</span>

  @Override
  public void enterOrderByExpression(@NotNull PQL2Parser.OrderByExpressionContext ctx) {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">    if (ctx.getChildCount() == 1) {</span>
<span class="fc" id="L381">      pushNode(new OrderByExpressionAstNode(ctx.getChild(0).getText(), &quot;asc&quot;));</span>
    } else {
<span class="nc" id="L383">      pushNode(new OrderByExpressionAstNode(ctx.getChild(0).getText(), ctx.getChild(1).getText()));</span>
    }
<span class="fc" id="L385">  }</span>

  @Override
  public void exitOrderByExpression(@NotNull PQL2Parser.OrderByExpressionContext ctx) {
<span class="fc" id="L389">    popNode();</span>
<span class="fc" id="L390">  }</span>

  @Override
  public void enterPredicateList(@NotNull PQL2Parser.PredicateListContext ctx) {
<span class="fc" id="L394">    pushNode(new PredicateListAstNode());</span>
<span class="fc" id="L395">  }</span>

  @Override
  public void exitPredicateList(@NotNull PQL2Parser.PredicateListContext ctx) {
<span class="fc" id="L399">    popNode();</span>
<span class="fc" id="L400">  }</span>

  @Override
  public void enterBooleanOperator(@NotNull PQL2Parser.BooleanOperatorContext ctx) {
<span class="fc" id="L404">    pushNode(BooleanOperatorAstNode.valueOf(ctx.getText().toUpperCase()));</span>
<span class="fc" id="L405">  }</span>

  @Override
  public void exitBooleanOperator(@NotNull PQL2Parser.BooleanOperatorContext ctx) {
<span class="fc" id="L409">    popNode();</span>
<span class="fc" id="L410">  }</span>

  @Override
  public void enterOption(PQL2Parser.OptionContext ctx) {
<span class="fc" id="L414">    pushNode(new OptionAstNode());</span>
<span class="fc" id="L415">  }</span>

  @Override
  public void exitOption(PQL2Parser.OptionContext ctx) {
<span class="fc" id="L419">    popNode();</span>
<span class="fc" id="L420">  }</span>

  @Override
  public void enterOptions(PQL2Parser.OptionsContext ctx) {
<span class="fc" id="L424">    pushNode(new OptionsAstNode());</span>
<span class="fc" id="L425">  }</span>

  @Override
  public void exitOptions(PQL2Parser.OptionsContext ctx) {
<span class="fc" id="L429">    popNode();</span>
<span class="fc" id="L430">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>