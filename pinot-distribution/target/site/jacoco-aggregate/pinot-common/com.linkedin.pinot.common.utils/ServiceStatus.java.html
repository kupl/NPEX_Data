<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ServiceStatus.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-common</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.common.utils</a> &gt; <span class="el_source">ServiceStatus.java</span></div><h1>ServiceStatus.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.linkedin.pinot.common.utils;

import com.linkedin.pinot.common.config.TableNameBuilder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.helix.HelixAdmin;
import org.apache.helix.HelixDataAccessor;
import org.apache.helix.HelixManager;
import org.apache.helix.PropertyKey;
import org.apache.helix.PropertyKey.Builder;
import org.apache.helix.model.CurrentState;
import org.apache.helix.model.ExternalView;
import org.apache.helix.model.IdealState;
import org.apache.helix.model.LiveInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class to obtain the status of the Pinot instance running in this JVM.
 */
<span class="nc" id="L41">public class ServiceStatus {</span>
<span class="fc" id="L42">  private static final Logger LOGGER = LoggerFactory.getLogger(ServiceStatus.class);</span>

<span class="pc" id="L44">  public enum Status {</span>
<span class="fc" id="L45">    STARTING, GOOD, BAD</span>
  }

<span class="fc" id="L48">  public static String STATUS_DESCRIPTION_NONE = &quot;None&quot;;</span>
<span class="fc" id="L49">  public static String STATUS_DESCRIPTION_INIT = &quot;Init&quot;;</span>

  /**
   * Callback that returns the status of the service.
   */
  public interface ServiceStatusCallback {
    Status getServiceStatus();
    String getStatusDescription();
  }

<span class="fc" id="L59">  private static ServiceStatusCallback serviceStatusCallback = null;</span>

  public static void setServiceStatusCallback(ServiceStatusCallback serviceStatusCallback) {
<span class="fc" id="L62">    ServiceStatus.serviceStatusCallback = serviceStatusCallback;</span>
<span class="fc" id="L63">  }</span>

  public static Status getServiceStatus() {
<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (serviceStatusCallback == null) {</span>
<span class="nc" id="L67">      return Status.STARTING;</span>
    } else {
      try {
<span class="nc" id="L70">        return serviceStatusCallback.getServiceStatus();</span>
<span class="nc" id="L71">      } catch (Exception e) {</span>
<span class="nc" id="L72">        LOGGER.warn(&quot;Caught exception while reading the service status&quot;, e);</span>
<span class="nc" id="L73">        return Status.BAD;</span>
      }
    }
  }

  public static String getStatusDescription() {
<span class="nc bnc" id="L79" title="All 2 branches missed.">    if (serviceStatusCallback == null) {</span>
<span class="nc" id="L80">      return STATUS_DESCRIPTION_INIT;</span>
    } else {
      try {
<span class="nc" id="L83">        return serviceStatusCallback.getStatusDescription();</span>
<span class="nc" id="L84">      } catch (Exception e) {</span>
<span class="nc" id="L85">        return &quot;Exception: &quot; + e.getMessage();</span>
      }
    }
  }

  public static class MultipleCallbackServiceStatusCallback implements ServiceStatusCallback {
    private final List&lt;? extends ServiceStatusCallback&gt; _statusCallbacks;

<span class="fc" id="L93">    public MultipleCallbackServiceStatusCallback(List&lt;? extends ServiceStatusCallback&gt; statusCallbacks) {</span>
<span class="fc" id="L94">      _statusCallbacks = statusCallbacks;</span>
<span class="fc" id="L95">    }</span>

    @Override
    public Status getServiceStatus() {
      // Iterate through all callbacks, returning the first non GOOD one as the service status
<span class="fc bfc" id="L100" title="All 2 branches covered.">      for (ServiceStatusCallback statusCallback : _statusCallbacks) {</span>
<span class="fc" id="L101">        final Status serviceStatus = statusCallback.getServiceStatus();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (serviceStatus != Status.GOOD) {</span>
<span class="fc" id="L103">          return serviceStatus;</span>
        }
<span class="fc" id="L105">      }</span>

      // All callbacks report good, therefore we're good too
<span class="fc" id="L108">      return Status.GOOD;</span>
    }

    public String getStatusDescription() {
<span class="nc" id="L112">      StringBuilder statusDescription = new StringBuilder();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      for (ServiceStatusCallback statusCallback : _statusCallbacks) {</span>
<span class="nc" id="L114">        statusDescription.append(</span>
            statusCallback.getClass().getSimpleName() + &quot;:&quot; + statusCallback.getStatusDescription() + &quot;;&quot;
        );
<span class="nc" id="L117">      }</span>
<span class="nc" id="L118">      return statusDescription.toString();</span>
    }
  }

  /**
   * Service status callback that compares ideal state with another Helix state. Used to share most of the logic between
   * the ideal state/external view comparison and ideal state/current state comparison.
   */
  private static abstract class IdealStateMatchServiceStatusCallback&lt;T&gt; implements ServiceStatusCallback {
    protected String _clusterName;
    protected String _instanceName;
    protected List&lt;String&gt; _resourcesToMonitor;
<span class="fc" id="L130">    protected boolean _finishedStartingUp = false;</span>
    protected HelixManager _helixManager;
    protected HelixAdmin _helixAdmin;
    protected HelixDataAccessor _helixDataAccessor;
    protected Builder _keyBuilder;
<span class="fc" id="L135">    protected Set&lt;String&gt; _resourcesDoneStartingUp = new HashSet&lt;&gt;();</span>
<span class="fc" id="L136">    private String _statusDescription = STATUS_DESCRIPTION_INIT;</span>

<span class="fc" id="L138">    public IdealStateMatchServiceStatusCallback(HelixManager helixManager, String clusterName, String instanceName) {</span>
<span class="fc" id="L139">      _helixManager = helixManager;</span>
<span class="fc" id="L140">      _clusterName = clusterName;</span>
<span class="fc" id="L141">      _instanceName = instanceName;</span>

<span class="pc bpc" id="L143" title="1 of 2 branches missed.">      if (_helixManager != null) {</span>
<span class="fc" id="L144">        _helixAdmin = _helixManager.getClusterManagmentTool();</span>
<span class="fc" id="L145">        _helixDataAccessor = _helixManager.getHelixDataAccessor();</span>
<span class="fc" id="L146">        _keyBuilder = _helixDataAccessor.keyBuilder();</span>
      }

      // Make a list of the resources to monitor
<span class="fc" id="L150">      _resourcesToMonitor = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">      for (String resource : _helixAdmin.getResourcesInCluster(_clusterName)) {</span>
        // Only monitor table resources and broker resource
<span class="pc bpc" id="L154" title="2 of 4 branches missed.">        if (!TableNameBuilder.isTableResource(resource) &amp;&amp; !resource.equals(</span>
            CommonConstants.Helix.BROKER_RESOURCE_INSTANCE)) {
<span class="nc" id="L156">          continue;</span>
        }
<span class="fc" id="L158">        final IdealState idealState = getResourceIdealState(resource);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        for (String partitionInResource : idealState.getPartitionSet()) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">          if (idealState.getInstanceSet(partitionInResource).contains(_instanceName)) {</span>
<span class="nc" id="L161">            _resourcesToMonitor.add(resource);</span>
<span class="nc" id="L162">            break;</span>
          }
<span class="nc" id="L164">        }</span>
<span class="fc" id="L165">      }</span>

<span class="fc" id="L167">      LOGGER.info(&quot;Monitoring resources {} for start up of instance {}&quot;, _resourcesToMonitor, _instanceName);</span>
<span class="fc" id="L168">    }</span>

    public IdealStateMatchServiceStatusCallback(HelixManager helixManager, String clusterName, String instanceName,
<span class="fc" id="L171">        List&lt;String&gt; resourcesToMonitor) {</span>
<span class="fc" id="L172">      _helixManager = helixManager;</span>
<span class="fc" id="L173">      _clusterName = clusterName;</span>
<span class="fc" id="L174">      _instanceName = instanceName;</span>

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">      if (_helixManager != null) {</span>
<span class="nc" id="L177">        _helixAdmin = _helixManager.getClusterManagmentTool();</span>
<span class="nc" id="L178">        _helixDataAccessor = _helixManager.getHelixDataAccessor();</span>
<span class="nc" id="L179">        _keyBuilder = _helixDataAccessor.keyBuilder();</span>
      }

<span class="fc" id="L182">      _resourcesToMonitor = resourcesToMonitor;</span>

<span class="fc" id="L184">      LOGGER.info(&quot;Monitoring resources {} for start up of instance {}&quot;, _resourcesToMonitor, _instanceName);</span>
<span class="fc" id="L185">    }</span>

    public String getStatusDescription() {
<span class="nc" id="L188">      return _statusDescription;</span>
    }

    protected abstract T getState(String resourceName);

    protected abstract Map&lt;String, String&gt; getPartitionStateMap(T state);

    @Override
    public Status getServiceStatus() {
<span class="fc bfc" id="L197" title="All 2 branches covered.">      if (_finishedStartingUp) {</span>
<span class="fc" id="L198">        return Status.GOOD;</span>
      }
<span class="fc" id="L200">      int index = 0;</span>
<span class="fc" id="L201">      final int totalResourceCount = _resourcesToMonitor.size();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">      for (String resourceToMonitor : _resourcesToMonitor) {</span>
<span class="fc" id="L204">        final String completedCountStr = &quot;(&quot; + resourceToMonitor + &quot;:&quot; + index + &quot;/&quot; + totalResourceCount + &quot;)&quot;;</span>
        // If the instance is already done starting up, skip checking its state
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (_resourcesDoneStartingUp.contains(resourceToMonitor)) {</span>
<span class="nc" id="L207">          continue;</span>
        }

<span class="fc" id="L210">        IdealState idealState = getResourceIdealState(resourceToMonitor);</span>
<span class="fc" id="L211">        T helixState = getState(resourceToMonitor);</span>

<span class="fc bfc" id="L213" title="All 4 branches covered.">        if (idealState == null || helixState == null) {</span>
<span class="fc" id="L214">          _statusDescription = &quot;idealState or helixState is null&quot; + completedCountStr;</span>
<span class="fc" id="L215">          return Status.STARTING;</span>
        }

        // If the resource is disabled, ignore it
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (!idealState.isEnabled()) {</span>
<span class="fc" id="L220">          continue;</span>
        }

<span class="fc" id="L223">        Map&lt;String, String&gt; statePartitionStateMap = getPartitionStateMap(helixState);</span>
<span class="fc bfc" id="L224" title="All 4 branches covered.">        if(statePartitionStateMap.isEmpty() &amp;&amp; !idealState.getPartitionSet().isEmpty()) {</span>
<span class="fc" id="L225">          _statusDescription = &quot;statePartitionStateMapSize=&quot; + statePartitionStateMap.size() + &quot;, idealStateSize=&quot;</span>
              + idealState.getPartitionSet().size() + completedCountStr;
<span class="fc" id="L227">          return Status.STARTING;</span>
        }

        // Check that all partitions that are supposed to be in any state other than OFFLINE have the same status in the
        // external view or went to ERROR state (which means that we tried to load the segments/resources but failed for
        // some reason)
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (String partition : idealState.getPartitionSet()) {</span>
<span class="fc" id="L234">          final String idealStateStatus = idealState.getInstanceStateMap(partition).get(_instanceName);</span>

          // Skip this partition if it is not assigned to this instance or if the instance should be offline
<span class="fc bfc" id="L237" title="All 4 branches covered.">          if (idealStateStatus == null || &quot;OFFLINE&quot;.equals(idealStateStatus)) {</span>
<span class="fc" id="L238">            continue;</span>
          }

          // If this instance state is not in the current state, then it hasn't finished starting up
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">          if (!statePartitionStateMap.containsKey(partition)) {</span>
<span class="nc" id="L243">            _statusDescription = &quot;statePartitionStateMap does not have &quot; + partition + completedCountStr;</span>
<span class="nc" id="L244">            return Status.STARTING;</span>
          }

<span class="fc" id="L247">          String currentStateStatus = statePartitionStateMap.get(partition);</span>

          // If the instance state is not ERROR and is not the same as what's expected from the ideal state, then it
          // hasn't finished starting up
<span class="pc bpc" id="L251" title="1 of 4 branches missed.">          if (!&quot;ERROR&quot;.equals(currentStateStatus) &amp;&amp; !idealStateStatus.equals(currentStateStatus)) {</span>
<span class="nc" id="L252">            _statusDescription = partition +&quot; currentStateStatus=&quot; + currentStateStatus + &quot;, idealStateStatus=&quot;</span>
                + idealStateStatus + completedCountStr;
<span class="nc" id="L254">            return Status.STARTING;</span>
          }
<span class="fc" id="L256">        }</span>

        // Resource is done starting up, add it to the list of resources that are done starting up
<span class="fc" id="L259">        _resourcesDoneStartingUp.add(resourceToMonitor);</span>
<span class="fc" id="L260">      }</span>

<span class="fc" id="L262">      LOGGER.info(&quot;Instance {} has finished starting up&quot;, _instanceName);</span>
<span class="fc" id="L263">      _finishedStartingUp = true;</span>
<span class="fc" id="L264">      _statusDescription = STATUS_DESCRIPTION_NONE;</span>
<span class="fc" id="L265">      return Status.GOOD;</span>
    }

    protected IdealState getResourceIdealState(String resourceName) {
<span class="fc" id="L269">      return _helixAdmin.getResourceIdealState(_clusterName, resourceName);</span>
    }
  }

  /**
   * Service status callback that reports starting until all resources relevant to this instance have a matching
   * external view and current state. This callback considers the ERROR state in the current view to be equivalent to
   * the ideal state value.
   */
  public static class IdealStateAndCurrentStateMatchServiceStatusCallback extends IdealStateMatchServiceStatusCallback&lt;CurrentState&gt; {
    public IdealStateAndCurrentStateMatchServiceStatusCallback(HelixManager helixManager, String clusterName, String instanceName) {
<span class="fc" id="L280">      super(helixManager, clusterName, instanceName);</span>
<span class="fc" id="L281">    }</span>

    public IdealStateAndCurrentStateMatchServiceStatusCallback(HelixManager helixManager, String clusterName, String instanceName,
        List&lt;String&gt; resourcesToMonitor) {
<span class="nc" id="L285">      super(helixManager, clusterName, instanceName, resourcesToMonitor);</span>
<span class="nc" id="L286">    }</span>

    @Override
    protected CurrentState getState(String resourceName) {
<span class="nc" id="L290">      LiveInstance liveInstance = _helixDataAccessor.getProperty(_keyBuilder.liveInstance(_instanceName));</span>

<span class="nc" id="L292">      String sessionId = liveInstance.getSessionId();</span>
<span class="nc" id="L293">      PropertyKey currentStateKey = _keyBuilder.currentState(_instanceName, sessionId, resourceName);</span>
<span class="nc" id="L294">      CurrentState currentState = _helixDataAccessor.getProperty(currentStateKey);</span>

<span class="nc" id="L296">      return currentState;</span>
    }

    @Override
    protected Map&lt;String, String&gt; getPartitionStateMap(CurrentState state) {
<span class="nc" id="L301">      return state.getPartitionStateMap();</span>
    }
  }

  /**
   * Service status callback that reports starting until all resources relevant to this instance have a matching
   * external view and ideal state. This callback considers the ERROR state in the external view to be equivalent to the
   * ideal state value.
   */
<span class="nc" id="L310">  public static class IdealStateAndExternalViewMatchServiceStatusCallback extends IdealStateMatchServiceStatusCallback&lt;ExternalView&gt; {</span>
    public IdealStateAndExternalViewMatchServiceStatusCallback(HelixManager helixManager, String clusterName, String instanceName) {
<span class="fc" id="L312">      super(helixManager, clusterName, instanceName);</span>
<span class="fc" id="L313">    }</span>

    public IdealStateAndExternalViewMatchServiceStatusCallback(HelixManager helixManager, String clusterName, String instanceName,
        List&lt;String&gt; resourcesToMonitor) {
<span class="fc" id="L317">      super(helixManager, clusterName, instanceName, resourcesToMonitor);</span>
<span class="fc" id="L318">    }</span>

    @Override
    protected ExternalView getState(String resourceName) {
<span class="nc" id="L322">      return _helixAdmin.getResourceExternalView(_clusterName, resourceName);</span>
    }

    @Override
    protected Map&lt;String, String&gt; getPartitionStateMap(ExternalView state) {
<span class="fc" id="L327">      Map&lt;String, String&gt; partitionState = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">      for (String partition : state.getPartitionSet()) {</span>
<span class="fc" id="L330">        Map&lt;String, String&gt; instanceStateMap = state.getStateMap(partition);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (instanceStateMap.containsKey(_instanceName)) {</span>
<span class="fc" id="L332">          partitionState.put(partition, instanceStateMap.get(_instanceName));</span>
        }
<span class="fc" id="L334">      }</span>

<span class="fc" id="L336">      return partitionState;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>