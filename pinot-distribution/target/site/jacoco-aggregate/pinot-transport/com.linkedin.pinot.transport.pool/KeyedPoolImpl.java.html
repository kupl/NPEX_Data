<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>KeyedPoolImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.pool</a> &gt; <span class="el_source">KeyedPoolImpl.java</span></div><h1>KeyedPoolImpl.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.pool;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.transport.common.AsyncResponseFuture;
import com.linkedin.pinot.transport.common.Callback;
import com.linkedin.pinot.transport.common.Cancellable;
import com.linkedin.pinot.transport.common.CompositeFuture;
import com.linkedin.pinot.transport.common.CompositeFuture.GatherModeOnError;
import com.linkedin.pinot.transport.common.ServerResponseFuture;
import com.linkedin.pinot.transport.common.NoneType;
import com.linkedin.pinot.transport.metrics.AggregatedPoolStats;
import com.linkedin.pinot.transport.metrics.PoolStats;
import com.linkedin.pinot.transport.pool.AsyncPoolImpl.Strategy;
import com.yammer.metrics.core.Histogram;
import com.yammer.metrics.core.MetricsRegistry;


public class KeyedPoolImpl&lt;T&gt; implements KeyedPool&lt;T&gt; {

<span class="fc" id="L45">  protected static Logger LOGGER = LoggerFactory.getLogger(KeyedPoolImpl.class);</span>

  /**
   * State of the pool
   */
<span class="pc" id="L50">  private enum State {</span>
<span class="fc" id="L51">    INIT,</span>
<span class="fc" id="L52">    RUNNING,</span>
<span class="fc" id="L53">    SHUTTING_DOWN,</span>
<span class="fc" id="L54">    SHUTDOWN</span>
  }

  // State of this connection pool
  private State _state;

  // Maximum number of resources allowed per key in the pool
  private final int _maxResourcesPerKey;
  // Minimum number of resources allowed per key in the pool
  private final int _minResourcesPerKey;
  // Idle Timeout (ms) for reaping idle resources
  private final long _idleTimeoutMs;
  // Maximum number of pending checkout requests before requests starts getting rejected
  private final int _maxPendingCheckoutRequests;
  // Executor Service to remove idle objects on timeout.
  private final ScheduledExecutorService _timeoutExecutor;

  //Resource Manager Callback
  private final PooledResourceManager&lt;T&gt; _resourceManager;

  // Executor Service for creating/removing resources
  private final ExecutorService _executorService;

  // Shutdown Future
  private CompositeFuture&lt;NoneType&gt; _shutdownFuture;

  private final MetricsRegistry _metricRegistry;

  private final AggregatedPoolStats&lt;Histogram&gt; _poolStats;

  /**
   * Map of AsyncPools
   */
  private final ConcurrentMap&lt;ServerInstance, AsyncPool&lt;T&gt;&gt; _keyedPool;

  private final ConcurrentMap&lt;ServerInstance, AsyncPoolResourceManagerAdapter&lt;T&gt;&gt; _pooledResourceManagerMap;

  /**
   * All modifications of _keyedPool and all access to _state must be locked on _mutex.
   * READS of _pool are allowed without synchronization
   */
<span class="fc" id="L95">  private final Object _mutex = new Object();</span>

  public KeyedPoolImpl(int minResourcesPerKey, int maxResourcesPerKey, long idleTimeoutMs,
      int maxPendingCheckoutRequests, PooledResourceManager&lt;T&gt; resourceManager,
<span class="fc" id="L99">      ScheduledExecutorService timeoutExecutorService, ExecutorService executorService, MetricsRegistry registry) {</span>
<span class="fc" id="L100">    _keyedPool = new ConcurrentHashMap&lt;ServerInstance, AsyncPool&lt;T&gt;&gt;();</span>
<span class="fc" id="L101">    _pooledResourceManagerMap = new ConcurrentHashMap&lt;ServerInstance, AsyncPoolResourceManagerAdapter&lt;T&gt;&gt;();</span>
<span class="fc" id="L102">    _minResourcesPerKey = minResourcesPerKey;</span>
<span class="fc" id="L103">    _maxResourcesPerKey = maxResourcesPerKey;</span>
<span class="fc" id="L104">    _idleTimeoutMs = idleTimeoutMs;</span>
<span class="fc" id="L105">    _maxPendingCheckoutRequests = maxPendingCheckoutRequests;</span>
<span class="fc" id="L106">    _timeoutExecutor = timeoutExecutorService;</span>
<span class="fc" id="L107">    _executorService = executorService;</span>
<span class="fc" id="L108">    _resourceManager = resourceManager;</span>
<span class="fc" id="L109">    _state = State.INIT;</span>
<span class="fc" id="L110">    _metricRegistry = registry;</span>
<span class="fc" id="L111">    _poolStats = new AggregatedPoolStats&lt;Histogram&gt;();</span>
<span class="fc" id="L112">  }</span>

  @Override
  public void start() {
<span class="fc" id="L116">    _state = State.RUNNING;</span>
<span class="fc" id="L117">  }</span>

  @Override
  public ServerResponseFuture&lt;T&gt; checkoutObject(ServerInstance key, String context) {
<span class="fc" id="L121">    AsyncPool&lt;T&gt; pool = _keyedPool.get(key);</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">    if (null == pool) {</span>
<span class="fc" id="L124">      synchronized (_mutex) {</span>
<span class="fc" id="L125">        pool = _keyedPool.get(key);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (null == pool) {</span>
<span class="fc" id="L127">          String poolName = &quot;Pool for (&quot; + key + &quot;)&quot;;</span>
<span class="fc" id="L128">          AsyncPoolResourceManagerAdapter&lt;T&gt; rmAdapter =</span>
              new AsyncPoolResourceManagerAdapter&lt;T&gt;(key, _resourceManager, _executorService, _metricRegistry);
<span class="fc" id="L130">          pool = new AsyncPoolImpl&lt;T&gt;(poolName, rmAdapter, _maxResourcesPerKey, _idleTimeoutMs, _timeoutExecutor,</span>
              _executorService, _maxPendingCheckoutRequests, Strategy.LRU, _minResourcesPerKey, _metricRegistry);
<span class="fc" id="L132">          _keyedPool.put(key, pool);</span>
<span class="fc" id="L133">          _poolStats.add(pool);</span>
<span class="fc" id="L134">          _pooledResourceManagerMap.put(key, rmAdapter);</span>
<span class="fc" id="L135">          pool.start();</span>
        }
<span class="pc" id="L137">      }</span>
    }

<span class="fc" id="L140">    AsyncResponseFuture&lt;T&gt; future = new AsyncResponseFuture&lt;T&gt;(key, &quot;ConnPool checkout future for key &quot; + key + &quot;(&quot; + context + &quot;)&quot;);</span>
<span class="fc" id="L141">    Cancellable cancellable = pool.get(future);</span>
<span class="fc" id="L142">    future.setCancellable(cancellable);</span>
<span class="fc" id="L143">    return future;</span>
  }

  @Override
  public void checkinObject(ServerInstance key, T object) {
<span class="fc" id="L148">    AsyncPool&lt;T&gt; pool = _keyedPool.get(key);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">    if (null != pool) {</span>
<span class="fc" id="L150">      pool.put(object);</span>
    } else {
<span class="fc" id="L152">      throw new IllegalStateException(</span>
          &quot;Trying to checkin an object from a pool which does not exist. No pool available for key (&quot; + key + &quot;) !!&quot;);
    }
<span class="fc" id="L155">  }</span>

  @Override
  public void destroyObject(ServerInstance key, T object) {
<span class="fc" id="L159">    AsyncPool&lt;T&gt; pool = _keyedPool.get(key);</span>
<span class="fc" id="L160">    LOGGER.info(&quot;Destroying object for the key (&quot; + key + &quot;) object :&quot; + object);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (null != pool) {</span>
<span class="fc" id="L162">      pool.dispose(object);</span>
    } else {
<span class="fc" id="L164">      throw new IllegalStateException(</span>
          &quot;Trying to destroy an object from a pool which does not exist. No pool available for key (&quot; + key + &quot;) !!&quot;);
    }
<span class="fc" id="L167">  }</span>

  @Override
  public ServerResponseFuture&lt;NoneType&gt; shutdown() {
<span class="fc" id="L171">    synchronized (_mutex) {</span>
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">      if ((_state == State.SHUTTING_DOWN) || (_state == State.SHUTDOWN)) {</span>
<span class="fc" id="L173">        return _shutdownFuture;</span>
      }

<span class="fc" id="L176">      _state = State.SHUTTING_DOWN;</span>

<span class="fc" id="L178">      List&lt;ServerResponseFuture&lt; NoneType&gt;&gt; futureList = new ArrayList&lt;ServerResponseFuture&lt;NoneType&gt;&gt;();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">      for (Entry&lt;ServerInstance, AsyncPool&lt;T&gt;&gt; poolEntry : _keyedPool.entrySet()) {</span>
<span class="fc" id="L180">        AsyncResponseFuture&lt;NoneType&gt; shutdownFuture = new AsyncResponseFuture&lt;NoneType&gt;(poolEntry.getKey(),</span>
            &quot;ConnPool shutdown future for pool entry &quot; + poolEntry.getKey());
<span class="fc" id="L182">        poolEntry.getValue().shutdown(shutdownFuture);</span>
<span class="fc" id="L183">        futureList.add(shutdownFuture);</span>
        //Cancel waiters and notify them
<span class="fc" id="L185">        Collection&lt;Callback&lt;T&gt;&gt; waiters = poolEntry.getValue().cancelWaiters();</span>
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">        if ((null != waiters) &amp;&amp; !waiters.isEmpty()) {</span>
<span class="fc" id="L187">          Exception ex = new Exception(&quot;Pool is shutting down !!&quot;);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">          for (Callback&lt;T&gt; w : waiters) {</span>
<span class="fc" id="L189">            w.onError(ex);</span>
<span class="fc" id="L190">          }</span>
<span class="fc" id="L191">          poolEntry.getValue().shutdown(shutdownFuture);</span>
        }
<span class="fc" id="L193">      }</span>
<span class="fc" id="L194">      _shutdownFuture = new CompositeFuture&lt;NoneType&gt;(&quot;Shutdown For Pool&quot;, GatherModeOnError.AND);</span>
<span class="fc" id="L195">      _shutdownFuture.start(futureList);</span>
<span class="fc" id="L196">      _shutdownFuture.addListener(new Runnable() {</span>

        @Override
        public void run() {
<span class="fc" id="L200">          synchronized (_mutex) {</span>
<span class="fc" id="L201">            _state = State.SHUTDOWN;</span>
<span class="pc" id="L202">          }</span>
<span class="fc" id="L203">        }</span>
      }, null);
<span class="pc" id="L205">    }</span>
<span class="fc" id="L206">    return _shutdownFuture;</span>
  }

  @Override
  public PoolStats&lt;Histogram&gt; getStats() {
<span class="fc" id="L211">    return _poolStats;</span>
  }

  @Override
  public boolean validatePool(ServerInstance key, boolean recreate) {
<span class="fc" id="L216">    AsyncPool&lt;T&gt; pool = _keyedPool.get(key);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    if (pool != null) {</span>
<span class="nc" id="L218">      return pool.validate(recreate);</span>
    }
<span class="fc" id="L220">    return true;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>