<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AsyncPoolImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.pool</a> &gt; <span class="el_source">AsyncPoolImpl.java</span></div><h1>AsyncPoolImpl.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.pool;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.linkedin.pinot.common.metrics.LatencyMetric;
import com.linkedin.pinot.common.metrics.MetricsHelper;
import com.linkedin.pinot.transport.common.Callback;
import com.linkedin.pinot.transport.common.Cancellable;
import com.linkedin.pinot.transport.common.LinkedDequeue;
import com.linkedin.pinot.transport.common.NoneType;
import com.linkedin.pinot.transport.metrics.AsyncPoolStats;
import com.linkedin.pinot.transport.metrics.PoolStats;
import com.yammer.metrics.core.Histogram;
import com.yammer.metrics.core.MetricName;
import com.yammer.metrics.core.MetricsRegistry;


/**
 * This is originally copied from R2 AsyncPool.
 *
 *  Modifications include
 *  (1) Fix to discard resources on shutdown
 *  (2) Calling destroy() causes shutdown to hang (the idle/pool-size counters were not maintained correctly in this case)
 *  (3) With minor changes to use Yammer metrics. Original author information below:
 *
 */
public class AsyncPoolImpl&lt;T&gt; implements AsyncPool&lt;T&gt; {
<span class="fc" id="L55">  private static final Logger LOGGER = LoggerFactory.getLogger(AsyncPoolImpl.class);</span>

  // Configured
  private final String _poolName;
  private final Lifecycle&lt;T&gt; _lifecycle;
  private final int _maxSize;
  private final int _maxWaiters;
  private final long _idleTimeout;
  private final ScheduledExecutorService _timeoutExecutor;
  private final ExecutorService _callbackExecutor;
  private final int _minSize;
  private volatile ScheduledFuture&lt;?&gt; _objectTimeoutFuture;

<span class="pc" id="L68">  private enum State {</span>
<span class="fc" id="L69">    NOT_YET_STARTED,</span>
<span class="fc" id="L70">    RUNNING,</span>
<span class="fc" id="L71">    SHUTTING_DOWN,</span>
<span class="fc" id="L72">    STOPPED</span>
  }

<span class="pc" id="L75">  public enum Strategy {</span>
<span class="fc" id="L76">    MRU,</span>
<span class="fc" id="L77">    LRU</span>
  };
  private final Strategy _strategy;

  // All members below are protected by this lock
  // Never call user code (callbacks) while holding this lock
<span class="pc" id="L83">  private final Object _lock = new Object();</span>
  // Including idle, checked out, and creations/destructions in progress
<span class="pc" id="L85">  private int _poolSize = 0;</span>
  // Unused objects live here, sorted by age.
  // The first object is the least recently added object.
<span class="pc" id="L88">  private final Deque&lt;TimedObject&lt;T&gt;&gt; _idle = new LinkedList&lt;TimedObject&lt;T&gt;&gt;();</span>
  // When no unused objects are available, callbacks live here while they wait
  // for a new object (either returned by another user, or newly created)
<span class="pc" id="L91">  private final LinkedDequeue&lt;Callback&lt;T&gt;&gt; _waiters = new LinkedDequeue&lt;Callback&lt;T&gt;&gt;();</span>
<span class="pc" id="L92">  private Throwable _lastCreateError = null;</span>
<span class="pc" id="L93">  private State _state = State.NOT_YET_STARTED;</span>
<span class="pc" id="L94">  private Callback&lt;NoneType&gt; _shutdownCallback = null;</span>
  private final Histogram _waitTime;

  // Statistics for each pool, retrieved with getStats()
  // See PoolStats for details
  // These are total counts over the entire lifetime of the pool
<span class="pc" id="L100">  private int _totalCreated = 0;</span>
<span class="pc" id="L101">  private int _totalDestroyed = 0;</span>
<span class="pc" id="L102">  private int _totalCreateErrors = 0;</span>
<span class="pc" id="L103">  private int _totalDestroyErrors = 0;</span>
<span class="pc" id="L104">  private int _totalBadDestroyed = 0;</span>
<span class="pc" id="L105">  private int _totalTimedOut = 0;</span>
  // These counters reset on each call to getStats()
<span class="pc" id="L107">  private int _sampleMaxCheckedOut = 0;</span>
<span class="pc" id="L108">  private int _sampleMaxPoolSize = 0;</span>
  // These are instantaneous values
<span class="pc" id="L110">  private int _checkedOut = 0;</span>

  /**
   * Creates an AsyncPoolImpl using a MRU (most recently used) strategy
   * of reusing pool objects. The minimum number of pool objects is set
   * to zero. This is a sensible configuration for talking to a single host.
   *
   * @param name Pool name, used in logs and statistics.
   * @param lifecycle The lifecycle used to create and destroy pool objects.
   * @param maxSize The maximum number of objects in the pool.
   * @param idleTimeout The number of milliseconds before an idle pool
   *                    object may be destroyed.
   * @param timeoutExecutor A ScheduledExecutorService that will be used to
   *                        periodically timeout objects.
   */
  public AsyncPoolImpl(String name, Lifecycle&lt;T&gt; lifecycle, int maxSize, long idleTimeout,
      ScheduledExecutorService timeoutExecutor, MetricsRegistry registry) {
<span class="nc" id="L127">    this(name, lifecycle, maxSize, idleTimeout, timeoutExecutor, timeoutExecutor, Integer.MAX_VALUE, registry);</span>
<span class="nc" id="L128">  }</span>

  /**
   * Creates an AsyncPoolImpl with a specified strategy of
   * returning pool objects and a minimum pool size.
   *
   * Supported strategies are MRU (most recently used) and LRU
   * (least recently used).
   *
   * MRU is sensible for communicating with a single host in order
   * to minimize the number of idle pool objects.
   *
   * LRU, in combination with a minimum pool size, is sensible for
   * communicating with a hardware load balancer that directly maps
   * persistent connections to hosts. In this case, the AsyncPoolImpl
   * balances requests evenly across the pool.
   *
   * @param name Pool name, used in logs and statistics.
   * @param lifecycle The lifecycle used to create and destroy pool objects.
   * @param maxSize The maximum number of objects in the pool.
   * @param idleTimeout The number of milliseconds before an idle pool object
   *                    may be destroyed.
   * @param timeoutExecutor A ScheduledExecutorService that will be used to
   *                        periodically timeout objects.
   */
  public AsyncPoolImpl(String name, Lifecycle&lt;T&gt; lifecycle, int maxSize, long idleTimeout,
      ScheduledExecutorService timeoutExecutor, ExecutorService callbackExecutor, int maxWaiters,
<span class="nc" id="L155">      MetricsRegistry registry) {</span>
<span class="nc" id="L156">    _poolName = name;</span>
<span class="nc" id="L157">    _lifecycle = lifecycle;</span>
<span class="nc" id="L158">    _maxSize = maxSize;</span>
<span class="nc" id="L159">    _idleTimeout = idleTimeout;</span>
<span class="nc" id="L160">    _timeoutExecutor = timeoutExecutor;</span>
<span class="nc" id="L161">    _callbackExecutor = callbackExecutor;</span>
<span class="nc" id="L162">    _maxWaiters = maxWaiters;</span>
<span class="nc" id="L163">    _strategy = Strategy.MRU;</span>
<span class="nc" id="L164">    _minSize = 0;</span>
<span class="nc" id="L165">    _waitTime = MetricsHelper.newHistogram(registry, new MetricName(AsyncPoolImpl.class, name), false);</span>
<span class="nc" id="L166">  }</span>

  /**
   * Creates an AsyncPoolImpl with a specified strategy of
   * returning pool objects and a minimum pool size.
   *
   * Supported strategies are MRU (most recently used) and LRU
   * (least recently used).
   *
   * MRU is sensible for communicating with a single host in order
   * to minimize the number of idle pool objects.
   *
   * LRU, in combination with a minimum pool size, is sensible for
   * communicating with a hardware load balancer that directly maps
   * persistent connections to hosts. In this case, the AsyncPoolImpl
   * balances requests evenly across the pool.
   *
   * @param name Pool name, used in logs and statistics.
   * @param lifecycle The lifecycle used to create and destroy pool objects.
   * @param maxSize The maximum number of objects in the pool.
   * @param idleTimeout The number of milliseconds before an idle pool object
   *                    may be destroyed.
   * @param timeoutExecutor A ScheduledExecutorService that will be used to
   *                        periodically timeout objects.
   * @param strategy The strategy used to return pool objects.
   * @param minSize Minimum number of objects in the pool. Set to zero for
   *                no minimum.
   */
  public AsyncPoolImpl(String name, Lifecycle&lt;T&gt; lifecycle, int maxSize, long idleTimeout,
      ScheduledExecutorService timeoutExecutor, ExecutorService callbackExecutor, int maxWaiters, Strategy strategy,
<span class="fc" id="L196">      int minSize, MetricsRegistry registry) {</span>
<span class="fc" id="L197">    _poolName = name;</span>
<span class="fc" id="L198">    _lifecycle = lifecycle;</span>
<span class="fc" id="L199">    _maxSize = maxSize;</span>
<span class="fc" id="L200">    _idleTimeout = idleTimeout;</span>
<span class="fc" id="L201">    _timeoutExecutor = timeoutExecutor;</span>
<span class="fc" id="L202">    _callbackExecutor = callbackExecutor;</span>
<span class="fc" id="L203">    _maxWaiters = maxWaiters;</span>
<span class="fc" id="L204">    _strategy = strategy;</span>
<span class="fc" id="L205">    _minSize = minSize;</span>
<span class="fc" id="L206">    _waitTime = MetricsHelper.newHistogram(registry, new MetricName(AsyncPoolImpl.class, name), false);</span>
<span class="fc" id="L207">  }</span>

  @Override
  public String getName() {
<span class="nc" id="L211">    return _poolName;</span>
  }

  @Override
  public void start() {
<span class="fc" id="L216">    synchronized (_lock) {</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (_state != State.NOT_YET_STARTED) {</span>
<span class="nc" id="L218">        throw new IllegalStateException(_poolName + &quot; is &quot; + _state);</span>
      }
<span class="fc" id="L220">      _state = State.RUNNING;</span>

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">      if (_idleTimeout &gt; 0) {</span>
<span class="fc" id="L223">        LOGGER.info(&quot;{} Setting up timeout job to run every {} ms&quot;, _poolName, _idleTimeout);</span>
<span class="fc" id="L224">        long freq = Math.min(_idleTimeout / 10, 1000);</span>
<span class="fc" id="L225">        _objectTimeoutFuture = _timeoutExecutor.scheduleAtFixedRate(new Runnable() {</span>
          @Override
          public void run() {
<span class="fc" id="L228">            timeoutObjects();</span>
<span class="fc" id="L229">          }</span>
        }, freq, freq, TimeUnit.MILLISECONDS);
      }
<span class="pc" id="L232">    }</span>

    // Make the minimum required number of connections now
<span class="fc bfc" id="L235" title="All 2 branches covered.">    for (int i = 0; i &lt; _minSize; i++) {</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">      if (shouldCreate()) {</span>
<span class="fc" id="L237">        create();</span>
      }
    }
<span class="fc" id="L240">  }</span>

  @Override
  public void shutdown(Callback&lt;NoneType&gt; callback) {
<span class="fc" id="L244">    _lifecycle.shutdown();</span>
    final State state;
<span class="fc" id="L246">    synchronized (_lock) {</span>
<span class="fc" id="L247">      state = _state;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">      if (state == State.RUNNING) {</span>
<span class="fc" id="L249">        _state = State.SHUTTING_DOWN;</span>
<span class="fc" id="L250">        _shutdownCallback = callback;</span>
      }
<span class="pc" id="L252">    }</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">    if (state != State.RUNNING) {</span>
      // Retest state outside the synchronized block, since we don't want to invoke this
      // callback inside a synchronized block
<span class="fc" id="L256">      callback.onError(new IllegalStateException(_poolName + &quot; is &quot; + _state));</span>
<span class="fc" id="L257">      return;</span>
    }
<span class="fc" id="L259">    LOGGER.info(&quot;{}: {}&quot;, _poolName, &quot;shutdown requested&quot;);</span>
<span class="fc" id="L260">    shutdownIfNeeded();</span>
<span class="fc" id="L261">  }</span>

  @Override
  public Collection&lt;Callback&lt;T&gt;&gt; cancelWaiters() {
<span class="fc" id="L265">    synchronized (_lock) {</span>
<span class="fc" id="L266">      List&lt;Callback&lt;T&gt;&gt; cancelled = new ArrayList&lt;Callback&lt;T&gt;&gt;(_waiters.size());</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">      for (Callback&lt;T&gt; item; (item = _waiters.poll()) != null;) {</span>
<span class="fc" id="L268">        cancelled.add(item);</span>
      }
<span class="fc" id="L270">      return cancelled;</span>
<span class="nc" id="L271">    }</span>
  }

  @Override
  public Cancellable get(final Callback&lt;T&gt; callback) {
    // getter needs to add to wait queue atomically with check for empty pool
    // putter needs to add to pool atomically with check for empty wait queue
<span class="fc" id="L278">    boolean create = false;</span>
<span class="fc" id="L279">    boolean reject = false;</span>
    final LinkedDequeue.Node&lt;Callback&lt;T&gt;&gt; node;
<span class="fc" id="L281">    final Callback&lt;T&gt; callbackWithTracking = new TimeTrackingCallback&lt;T&gt;(callback);</span>
    for (;;) {
<span class="fc" id="L283">      TimedObject&lt;T&gt; obj = null;</span>
      final State state;
<span class="fc" id="L285">      synchronized (_lock) {</span>
<span class="fc" id="L286">        state = _state;</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (state == State.RUNNING) {</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">          if (_strategy == Strategy.LRU) {</span>
<span class="fc" id="L289">            obj = _idle.pollFirst();</span>
          } else {
<span class="nc" id="L291">            obj = _idle.pollLast();</span>
          }
<span class="fc bfc" id="L293" title="All 2 branches covered.">          if (obj == null) {</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (_waiters.size() &lt; _maxWaiters) {</span>
              // No objects available and the waiter list is not full; add to waiter list and break out of loop
<span class="fc" id="L296">              node = _waiters.addLastNode(callbackWithTracking);</span>
<span class="fc" id="L297">              create = shouldCreate();</span>
            } else {
<span class="nc" id="L299">              reject = true;</span>
<span class="nc" id="L300">              node = null;</span>
            }
<span class="fc" id="L302">            break;</span>
          }
        }
<span class="pc" id="L305">      }</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">      if (state != State.RUNNING) {</span>
        // Defer execution of the callback until we are out of the synchronized block
<span class="nc" id="L308">        callbackWithTracking.onError(new IllegalStateException(_poolName + &quot; is &quot; + _state));</span>
<span class="nc" id="L309">        return null;</span>
      }
<span class="fc" id="L311">      T rawObj = obj.get();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">      if (_lifecycle.validateGet(rawObj)) {</span>
<span class="fc" id="L313">        trc(&quot;dequeued an idle object&quot;);</span>
        // Valid object; done
<span class="fc" id="L315">        synchronized (_lock) {</span>
<span class="fc" id="L316">          _checkedOut++;</span>
<span class="fc" id="L317">          _sampleMaxCheckedOut = Math.max(_checkedOut, _sampleMaxCheckedOut);</span>
<span class="pc" id="L318">        }</span>
<span class="fc" id="L319">        callbackWithTracking.onSuccess(rawObj);</span>
<span class="fc" id="L320">        return null;</span>
      }
      // Invalid object, discard it and keep trying
<span class="fc" id="L323">      destroy(rawObj, true);</span>
<span class="fc" id="L324">      trc(&quot;dequeued and disposed an invalid idle object&quot;);</span>
<span class="fc" id="L325">    }</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">    if (reject) {</span>
      // This is a recoverable exception. User can simply retry the failed get() operation.
<span class="nc" id="L328">      callbackWithTracking.onError(</span>
          new SizeLimitExceededException(&quot;AsyncPool &quot; + _poolName + &quot; reached maximum waiter size: &quot; + _maxWaiters));
<span class="nc" id="L330">      return null;</span>
    }
<span class="fc" id="L332">    trc(&quot;enqueued a waiter&quot;);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">    if (create) {</span>
<span class="fc" id="L334">      create();</span>
    }
<span class="fc" id="L336">    return new Cancellable() {</span>
      @Override
      public boolean cancel() {
<span class="fc" id="L339">        synchronized (_lock) {</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">          return _waiters.removeNode(node) != null;</span>
<span class="nc" id="L341">        }</span>
      }
    };
  }

  @Override
  public void put(T obj) {
<span class="fc" id="L348">    synchronized (_lock) {</span>
<span class="fc" id="L349">      _checkedOut--;</span>
<span class="pc" id="L350">    }</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">    if (!_lifecycle.validatePut(obj)) {</span>
<span class="nc" id="L352">      destroy(obj, true);</span>
<span class="nc" id="L353">      return;</span>
    }
<span class="fc" id="L355">    add(obj, false);</span>
<span class="fc" id="L356">  }</span>

  private void add(T obj, boolean isNewlyCreatedObject) {
    final Callback&lt;NoneType&gt; shutdown;
    Callback&lt;T&gt; waiter;
<span class="fc" id="L361">    synchronized (_lock) {</span>
      //update pool size if newly created
<span class="fc bfc" id="L363" title="All 2 branches covered.">      if (isNewlyCreatedObject) {</span>
<span class="fc" id="L364">        _poolSize++;</span>
<span class="fc" id="L365">        _sampleMaxPoolSize = Math.max(_poolSize, _sampleMaxPoolSize);</span>
      }
      // If we have waiters, the idle list must already be empty.
      // Therefore, immediately reusing the object is valid with
      // both MRU and LRU strategies.
<span class="fc" id="L370">      waiter = _waiters.poll();</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">      if (waiter == null) {</span>
<span class="fc" id="L373">        _idle.offerLast(new TimedObject&lt;T&gt;(obj));</span>
      } else {
<span class="fc" id="L375">        _checkedOut++;</span>
<span class="fc" id="L376">        _sampleMaxCheckedOut = Math.max(_checkedOut, _sampleMaxCheckedOut);</span>
      }
<span class="fc" id="L378">      shutdown = checkShutdownComplete();</span>
<span class="pc" id="L379">    }</span>

<span class="fc bfc" id="L381" title="All 2 branches covered.">    if (waiter != null) {</span>
<span class="fc" id="L382">      trc(&quot;dequeued a waiter&quot;);</span>
      // TODO probably shouldn't execute the getter's callback on the putting thread
      // If this callback is moved to another thread, make sure shutdownComplete does not get
      // invoked until after this callback is completed
<span class="fc" id="L386">      waiter.onSuccess(obj);</span>
    } else {
<span class="fc" id="L388">      trc(&quot;enqueued an idle object&quot;);</span>
    }
<span class="fc bfc" id="L390" title="All 2 branches covered.">    if (shutdown != null) {</span>
      // Now that the final user callback has been executed, pool shutdown is complete
<span class="fc" id="L392">      finishShutdown(shutdown);</span>
    }
<span class="fc" id="L394">  }</span>

  @Override
  public void dispose(T obj) {
<span class="fc" id="L398">    synchronized (_lock) {</span>
<span class="fc" id="L399">      _checkedOut--;</span>
<span class="pc" id="L400">    }</span>
<span class="fc" id="L401">    destroy(obj, true);</span>
<span class="fc" id="L402">  }</span>

  @Override
  public PoolStats&lt;Histogram&gt; getStats() {
    // get a copy of the stats
<span class="fc" id="L407">    synchronized (_lock) {</span>
<span class="fc" id="L408">      PoolStats.LifecycleStats&lt;Histogram&gt; lifecycleStats = _lifecycle.getStats();</span>
<span class="fc" id="L409">      PoolStats&lt;Histogram&gt; stats =</span>
          new AsyncPoolStats&lt;Histogram&gt;(_totalCreated, _totalDestroyed, _totalCreateErrors, _totalDestroyErrors,
              _totalBadDestroyed, _totalTimedOut, _checkedOut, _maxSize, _minSize, _poolSize, _sampleMaxCheckedOut,
              _sampleMaxPoolSize, _idle.size(), new LatencyMetric&lt;Histogram&gt;(_waitTime), lifecycleStats);
<span class="fc" id="L413">      _sampleMaxCheckedOut = _checkedOut;</span>
<span class="fc" id="L414">      _sampleMaxPoolSize = _poolSize;</span>
<span class="fc" id="L415">      return stats;</span>
<span class="nc" id="L416">    }</span>
  }

  private void destroy(T obj, boolean bad) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">    if (bad) {</span>
<span class="fc" id="L421">      synchronized (_lock) {</span>
<span class="fc" id="L422">        _totalBadDestroyed++;</span>
<span class="pc" id="L423">      }</span>
    }
<span class="fc" id="L425">    trc(&quot;disposing a pooled object&quot;);</span>
<span class="fc" id="L426">    _lifecycle.destroy(obj, bad, new Callback&lt;T&gt;() {</span>
      @Override
      public void onSuccess(T t) {
        boolean create;
<span class="fc" id="L430">        synchronized (_lock) {</span>
<span class="fc" id="L431">          _totalDestroyed++;</span>
<span class="fc" id="L432">          create = objectDestroyed();</span>
<span class="pc" id="L433">        }</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (create) {</span>
<span class="fc" id="L435">          create();</span>
        }
<span class="fc" id="L437">      }</span>

      @Override
      public void onError(Throwable e) {
        boolean create;

<span class="fc" id="L443">        synchronized (_lock) {</span>
<span class="fc" id="L444">          _totalDestroyErrors++;</span>
<span class="fc" id="L445">          create = objectDestroyed();</span>
<span class="pc" id="L446">        }</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (create) {</span>
<span class="nc" id="L448">          create();</span>
        }
        // TODO log this error!
<span class="fc" id="L451">      }</span>
    });
<span class="fc" id="L453">  }</span>

  /**
   * This method is safe to call while holding the lock.
   * @return true if another object creation should be initiated
   */
  private boolean objectDestroyed() {
    boolean create;
<span class="fc" id="L461">    synchronized (_lock) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">      if (_poolSize &gt; 0) {</span>
<span class="fc" id="L463">        _poolSize--;</span>
      }
<span class="fc" id="L465">      create = shouldCreate();</span>
<span class="fc" id="L466">      shutdownIfNeeded();</span>
<span class="pc" id="L467">    }</span>
<span class="fc" id="L468">    return create;</span>
  }

  /**
   * This method is safe to call while holding the lock.  DO NOT
   * call any callbacks in this method!
   * @return true if another object creation should be initiated.
   */
  private boolean shouldCreate() {
<span class="fc" id="L477">    boolean result = false;</span>
<span class="fc" id="L478">    synchronized (_lock) {</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">      if (_state == State.RUNNING) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (_poolSize &gt;= _maxSize) {</span>
          // If we pass up an opportunity to create an object due to full pool, the next
          // timeout is not necessarily caused by any previous creation failure.  Need to
          // think about this a little more.  What if the pool is full due to pending creations
          // that eventually fail?
<span class="fc" id="L485">          _lastCreateError = null;</span>
<span class="fc bfc" id="L486" title="All 4 branches covered.">        } else if ((_waiters.size() &gt; 0) || (_poolSize &lt; _minSize)) {</span>
          // We need to update the below metrics only at the place where we do the actual add. Otherwise
          // destroy() would make shutdown to hang()
          //_poolSize++; &lt;== Moved to add()
          //_sampleMaxPoolSize = Math.max(_poolSize, _sampleMaxPoolSize); &lt;== Moved to add()
<span class="fc" id="L491">          result = true;</span>
        }
      }
<span class="pc" id="L494">    }</span>
<span class="fc" id="L495">    LOGGER.debug(&quot;PoolSize : {} , Min Size : {}, Max Size : {}, Result : {}, State : {}&quot;, _poolSize, _minSize, _maxSize,</span>
        result, _state);

<span class="fc" id="L498">    return result;</span>
  }

  /**
   * DO NOT call this method while holding the lock!  It invokes user code.
   */
  private void create() {
<span class="fc" id="L505">    trc(&quot;initiating object creation&quot;);</span>
<span class="fc" id="L506">    _lifecycle.create(new Callback&lt;T&gt;() {</span>
      @Override
      public void onSuccess(T t) {
<span class="fc" id="L509">        synchronized (_lock) {</span>
<span class="fc" id="L510">          _totalCreated++;</span>
<span class="fc" id="L511">          _lastCreateError = null;</span>
<span class="pc" id="L512">        }</span>
<span class="fc" id="L513">        add(t, true);</span>
<span class="fc" id="L514">      }</span>

      @Override
      public void onError(final Throwable e) {
        boolean create;
        final Collection&lt;Callback&lt;T&gt;&gt; waitersDenied;
<span class="fc" id="L520">        synchronized (_lock) {</span>
<span class="fc" id="L521">          _totalCreateErrors++;</span>
<span class="fc" id="L522">          _lastCreateError = e;</span>
<span class="fc" id="L523">          create = objectDestroyed();</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">          if (!_waiters.isEmpty()) {</span>
<span class="fc" id="L525">            waitersDenied = cancelWaiters();</span>
            //Verify if we really need to create again
<span class="fc" id="L527">            create = shouldCreate();</span>
          } else {
<span class="nc" id="L529">            waitersDenied = Collections.emptyList();</span>
          }
<span class="pc" id="L531">        }</span>
        // Note this callback is invoked by Netty boss thread. We hand the actual callback
        // task to a separate thread since we don't want to block the boss thread
<span class="fc" id="L534">        _callbackExecutor.submit(new Runnable() {</span>
          @Override
          public void run() {
            // Note we drain all waiters if a create fails.  When a create fails, rate-limiting
            // logic may be applied.  In this case, we may be initiating creations at a lower rate
            // than incoming requests.  While creations are suppressed, it is better to deny all
            // waiters and let them see the real reason (this exception) rather than keep them around
            // to eventually get an unhelpful timeout error
<span class="fc bfc" id="L542" title="All 2 branches covered.">            for (Callback&lt;T&gt; denied : waitersDenied) {</span>
<span class="fc" id="L543">              denied.onError(e);</span>
<span class="fc" id="L544">            }</span>
<span class="fc" id="L545">          }</span>
        });
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (create) {</span>
<span class="nc" id="L548">          create();</span>
        }
<span class="fc" id="L550">        LOGGER.error(_poolName + &quot;: object creation failed. Create triggered : {}&quot;, create, e);</span>
<span class="fc" id="L551">      }</span>
    });
<span class="fc" id="L553">  }</span>

  private void timeoutObjects() {
<span class="fc" id="L556">    Collection&lt;T&gt; idle = reap(_idle, _idleTimeout);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">    if (idle.size() &gt; 0) {</span>
<span class="fc" id="L558">      LOGGER.debug(&quot;{}: disposing {} objects due to idle timeout&quot;, _poolName, idle.size());</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">      for (T obj : idle) {</span>
<span class="fc" id="L560">        destroy(obj, false);</span>
<span class="fc" id="L561">      }</span>
    }
<span class="fc" id="L563">  }</span>

  private &lt;U&gt; Collection&lt;U&gt; reap(Queue&lt;TimedObject&lt;U&gt;&gt; queue, long timeout) {
<span class="fc" id="L566">    List&lt;U&gt; toReap = new ArrayList&lt;U&gt;();</span>
<span class="fc" id="L567">    long now = System.currentTimeMillis();</span>
<span class="fc" id="L568">    long target = now - timeout;</span>

<span class="fc" id="L570">    synchronized (_lock) {</span>
<span class="fc" id="L571">      int excess = _poolSize - _minSize;</span>
<span class="pc bpc" id="L572" title="1 of 6 branches missed.">      for (TimedObject&lt;U&gt; p; ((p = queue.peek()) != null) &amp;&amp; (p.getTime() &lt; target) &amp;&amp; (excess &gt; 0); excess--) {</span>
<span class="fc" id="L573">        toReap.add(queue.poll().get());</span>
<span class="fc" id="L574">        _totalTimedOut++;</span>
      }
<span class="pc" id="L576">    }</span>
<span class="fc" id="L577">    return toReap;</span>
  }

  private void shutdownIfNeeded() {
<span class="fc" id="L581">    Callback&lt;NoneType&gt; shutdown = checkShutdownComplete();</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">    if (shutdown != null) {</span>
<span class="fc" id="L583">      finishShutdown(shutdown);</span>
    }
<span class="fc" id="L585">  }</span>

  private Callback&lt;NoneType&gt; checkShutdownComplete() {
<span class="fc" id="L588">    Callback&lt;NoneType&gt; done = null;</span>
    final State state;
    final int waiters;
    final int idle;
    final int poolSize;
<span class="fc" id="L593">    synchronized (_lock) {</span>
      // Save state for logging outside synchronized block
<span class="fc" id="L595">      state = _state;</span>
<span class="fc" id="L596">      waiters = _waiters.size();</span>
<span class="fc" id="L597">      idle = _idle.size();</span>
<span class="fc" id="L598">      poolSize = _poolSize;</span>

      // Now compare against the same state that will be logged
<span class="fc bfc" id="L601" title="All 6 branches covered.">      if ((state == State.SHUTTING_DOWN) &amp;&amp; (waiters == 0) &amp;&amp; (idle == poolSize)) {</span>
<span class="fc" id="L602">        _state = State.STOPPED;</span>
<span class="fc" id="L603">        done = _shutdownCallback;</span>
<span class="fc" id="L604">        _shutdownCallback = null;</span>
      }
<span class="pc" id="L606">    }</span>
<span class="fc bfc" id="L607" title="All 4 branches covered.">    if ((state == State.SHUTTING_DOWN) &amp;&amp; (done == null)) {</span>
<span class="fc" id="L608">      LOGGER.info(&quot;{}: {} waiters and {} objects outstanding before shutdown&quot;,</span>
          new Object[] { _poolName, waiters, poolSize - idle });
    }
<span class="fc" id="L611">    return done;</span>
  }

  private void finishShutdown(Callback&lt;NoneType&gt; shutdown) {
<span class="fc" id="L615">    ScheduledFuture&lt;?&gt; future = _objectTimeoutFuture;</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">    if (future != null) {</span>
<span class="fc" id="L617">      future.cancel(false);</span>
    }

    // We should be calling destroy() on resources while shutting down.
<span class="fc" id="L621">    LOGGER.info(&quot;{}: {}&quot;, _poolName, &quot;Discarding resources before shutdown&quot;);</span>
<span class="fc" id="L622">    TimedObject&lt;T&gt; obj = _idle.pollFirst();</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">    while (obj != null) {</span>
<span class="fc" id="L624">      destroy(obj.get(), false);</span>
<span class="fc" id="L625">      obj = _idle.pollFirst();</span>
    }
<span class="fc" id="L627">    LOGGER.info(&quot;{}: {}&quot;, _poolName, &quot;shutdown complete&quot;);</span>

<span class="fc" id="L629">    shutdown.onSuccess(NoneType.NONE);</span>
<span class="fc" id="L630">  }</span>

  private static class TimedObject&lt;T&gt; {
    private final T _obj;
    private final long _time;

<span class="fc" id="L636">    public TimedObject(T obj) {</span>
<span class="fc" id="L637">      _obj = obj;</span>
<span class="fc" id="L638">      _time = System.currentTimeMillis();</span>
<span class="fc" id="L639">    }</span>

    public T get() {
<span class="fc" id="L642">      return _obj;</span>
    }

    public long getTime() {
<span class="fc" id="L646">      return _time;</span>
    }
  }

  private class TimeTrackingCallback&lt;T2&gt; implements Callback&lt;T2&gt; {
    private final long _startTime;
    private final Callback&lt;T2&gt; _callback;

<span class="fc" id="L654">    public TimeTrackingCallback(Callback&lt;T2&gt; callback) {</span>
<span class="fc" id="L655">      _callback = callback;</span>
<span class="fc" id="L656">      _startTime = System.currentTimeMillis();</span>
<span class="fc" id="L657">    }</span>

    @Override
    public void onError(Throwable e) {
<span class="fc" id="L661">      synchronized (_lock) {</span>
<span class="fc" id="L662">        _waitTime.update(System.currentTimeMillis() - _startTime);</span>
<span class="pc" id="L663">      }</span>
<span class="fc" id="L664">      _callback.onError(e);</span>
<span class="fc" id="L665">    }</span>

    @Override
    public void onSuccess(T2 result) {
<span class="fc" id="L669">      synchronized (_lock) {</span>
<span class="fc" id="L670">        _waitTime.update(System.currentTimeMillis() - _startTime);</span>
<span class="pc" id="L671">      }</span>
<span class="fc" id="L672">      _callback.onSuccess(result);</span>
<span class="fc" id="L673">    }</span>
  }

  private void trc(Object toLog) {
<span class="fc" id="L677">    LOGGER.trace(&quot;{}: {}&quot;, _poolName, toLog);</span>
<span class="fc" id="L678">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L682">    return getStats().toString();</span>
  }

  public Throwable getLastCreateError() {
<span class="nc" id="L686">    return _lastCreateError;</span>
  }

  @Override
  public boolean validate(boolean recreate) {
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">    if (recreate) {</span>
<span class="nc" id="L692">      throw new UnsupportedOperationException(&quot;Recreate=true is not yet supported&quot;);</span>
    }
<span class="fc" id="L694">    synchronized (_lock) {</span>
<span class="fc" id="L695">      Iterator&lt;TimedObject&lt;T&gt;&gt; it = _idle.iterator();</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">      while (it.hasNext()) {</span>
<span class="fc" id="L697">        TimedObject&lt;T&gt; obj = it.next();</span>
<span class="fc" id="L698">        T rawObj = obj.get();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (!_lifecycle.validate(rawObj)) {</span>
<span class="fc" id="L700">          it.remove();</span>
<span class="fc" id="L701">          destroy(rawObj, true);</span>
<span class="fc" id="L702">          LOGGER.info(&quot;Destroyed invalid object &quot; + rawObj);</span>
        } else {
<span class="fc" id="L704">          LOGGER.info(&quot;Keeping valid object &quot; + rawObj);</span>
        }
<span class="fc" id="L706">      }</span>
<span class="pc" id="L707">    }</span>
<span class="fc" id="L708">    return true;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>