<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ScatterGatherImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-distribution</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.scattergather</a> &gt; <span class="el_source">ScatterGatherImpl.java</span></div><h1>ScatterGatherImpl.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.scattergather;

import com.linkedin.pinot.common.metrics.BrokerMeter;
import com.linkedin.pinot.common.metrics.BrokerMetrics;
import com.linkedin.pinot.common.metrics.BrokerQueryPhase;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.transport.common.CompositeFuture;
import com.linkedin.pinot.transport.common.CompositeFuture.GatherModeOnError;
import com.linkedin.pinot.transport.common.ServerResponseFuture;
import com.linkedin.pinot.transport.netty.NettyClientConnection.ResponseFuture;
import com.linkedin.pinot.transport.netty.PooledNettyClientResourceManager;
import com.linkedin.pinot.transport.pool.KeyedPool;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 *
 * Scatter-Gather implementation
 *
 */
public class ScatterGatherImpl implements ScatterGather {
<span class="fc" id="L52">  private static final Logger LOGGER = LoggerFactory.getLogger(ScatterGatherImpl.class);</span>

  private final KeyedPool&lt;PooledNettyClientResourceManager.PooledClientConnection&gt; _connPool;
  private final ExecutorService _executorService;

  public ScatterGatherImpl(@Nonnull KeyedPool&lt;PooledNettyClientResourceManager.PooledClientConnection&gt; connPool,
<span class="fc" id="L58">      @Nonnull ExecutorService executorService) {</span>
<span class="fc" id="L59">    _connPool = connPool;</span>
<span class="fc" id="L60">    _executorService = executorService;</span>
<span class="fc" id="L61">  }</span>

  @Nonnull
  @Override
  public CompositeFuture&lt;byte[]&gt; scatterGather(@Nonnull ScatterGatherRequest scatterGatherRequest,
      @Nonnull ScatterGatherStats scatterGatherStats, @Nullable Boolean isOfflineTable,
      @Nonnull BrokerMetrics brokerMetrics) throws InterruptedException {
<span class="fc" id="L68">    return sendRequest(new ScatterGatherRequestContext(scatterGatherRequest), scatterGatherStats, isOfflineTable,</span>
        brokerMetrics);
  }

  @Nonnull
  @Override
  public CompositeFuture&lt;byte[]&gt; scatterGather(@Nonnull ScatterGatherRequest scatterGatherRequest,
      @Nonnull ScatterGatherStats scatterGatherStats, @Nonnull BrokerMetrics brokerMetrics)
      throws InterruptedException {
<span class="fc" id="L77">    return scatterGather(scatterGatherRequest, scatterGatherStats, null, brokerMetrics);</span>
  }

  /**
   *
   * Helper Function to send scatter-request. This method should be called after the servers are selected
   *
   * @param scatterGatherRequestContext Scatter-Gather Request context with selected servers for each request.
   * @param scatterGatherStats scatter-gather statistics.
   * @param isOfflineTable whether the scatter-gather target is an OFFLINE table.
   * @param brokerMetrics broker metrics to track execution statistics.
   * @return a composite future representing the gather process.
   * @throws InterruptedException
   */
  private CompositeFuture&lt;byte[]&gt; sendRequest(ScatterGatherRequestContext scatterGatherRequestContext,
      ScatterGatherStats scatterGatherStats, Boolean isOfflineTable, BrokerMetrics brokerMetrics)
      throws InterruptedException {
<span class="fc" id="L94">    ScatterGatherRequest scatterGatherRequest = scatterGatherRequestContext._request;</span>
<span class="fc" id="L95">    Map&lt;String, List&lt;String&gt;&gt; routingTable = scatterGatherRequest.getRoutingTable();</span>
<span class="fc" id="L96">    CountDownLatch requestDispatchLatch = new CountDownLatch(routingTable.size());</span>

    // async checkout of connections and then dispatch of request
<span class="fc" id="L99">    List&lt;SingleRequestHandler&gt; handlers = new ArrayList&lt;&gt;(routingTable.size());</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">    for (Entry&lt;String, List&lt;String&gt;&gt; entry : routingTable.entrySet()) {</span>
<span class="fc" id="L102">      ServerInstance serverInstance = ServerInstance.forInstanceName(entry.getKey());</span>
<span class="fc" id="L103">      String shortServerName = serverInstance.getShortHostName();</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">      if (isOfflineTable != null) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (isOfflineTable) {</span>
<span class="nc" id="L106">          shortServerName += ScatterGatherStats.OFFLINE_TABLE_SUFFIX;</span>
        } else {
<span class="nc" id="L108">          shortServerName += ScatterGatherStats.REALTIME_TABLE_SUFFIX;</span>
        }
      }
<span class="fc" id="L111">      scatterGatherStats.initServer(shortServerName);</span>
<span class="fc" id="L112">      SingleRequestHandler handler =</span>
          new SingleRequestHandler(_connPool, serverInstance, scatterGatherRequest, entry.getValue(),
              scatterGatherRequestContext.getRemainingTimeMs(), requestDispatchLatch, brokerMetrics);
      // Submit to thread-pool for checking-out and sending request
<span class="fc" id="L116">      _executorService.submit(handler);</span>
<span class="fc" id="L117">      handlers.add(handler);</span>
<span class="fc" id="L118">    }</span>

    // Create the composite future for returning
<span class="fc" id="L121">    CompositeFuture&lt;byte[]&gt; response = new CompositeFuture&lt;&gt;(&quot;scatterRequest &quot; + scatterGatherRequest.getRequestId(),</span>
        GatherModeOnError.SHORTCIRCUIT_AND);

    // Wait for requests to be sent
<span class="fc" id="L125">    long timeRemaining = scatterGatherRequestContext.getRemainingTimeMs();</span>
<span class="fc" id="L126">    boolean sentSuccessfully = requestDispatchLatch.await(timeRemaining, TimeUnit.MILLISECONDS);</span>

<span class="pc bpc" id="L128" title="1 of 2 branches missed.">    if (sentSuccessfully) {</span>
<span class="fc" id="L129">      List&lt;ServerResponseFuture&lt;byte[]&gt;&gt; responseFutures = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">      for (SingleRequestHandler h : handlers) {</span>
<span class="fc" id="L131">        responseFutures.add(h.getResponseFuture());</span>
<span class="fc" id="L132">        String shortServerName = h.getServer().getShortHostName();</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (isOfflineTable != null) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">          if (isOfflineTable) {</span>
<span class="nc" id="L135">            shortServerName += ScatterGatherStats.OFFLINE_TABLE_SUFFIX;</span>
          } else {
<span class="nc" id="L137">            shortServerName += ScatterGatherStats.REALTIME_TABLE_SUFFIX;</span>
          }
        }
<span class="fc" id="L140">        scatterGatherStats.setSendStartTimeMillis(shortServerName, h.getConnStartTimeMillis());</span>
<span class="fc" id="L141">        scatterGatherStats.setConnStartTimeMillis(shortServerName, h.getStartDelayMillis());</span>
<span class="fc" id="L142">        scatterGatherStats.setSendCompletionTimeMillis(shortServerName, h.getSendCompletionTimeMillis());</span>
<span class="fc" id="L143">      }</span>
<span class="fc" id="L144">      response.start(responseFutures);</span>
<span class="fc" id="L145">    } else {</span>
<span class="nc" id="L146">      LOGGER.error(</span>
          &quot;Request (&quot; + scatterGatherRequest.getRequestId() + &quot;) not sent completely within time (&quot; + timeRemaining
              + &quot; ms) !! Cancelling !!. NumSentFailed:&quot; + requestDispatchLatch.getCount());
<span class="nc" id="L149">      response.start(null);</span>

      // Some requests were not event sent (possibly because of checkout !!)
      // and so we cancel all of them here
<span class="nc bnc" id="L153" title="All 2 branches missed.">      for (SingleRequestHandler h : handlers) {</span>
<span class="nc" id="L154">        LOGGER.info(&quot;Request {} to {} was sent successfully:{}, cancelling.&quot;, scatterGatherRequest.getRequestId(),</span>
            h.getServer(), h.isSent());
<span class="nc" id="L156">        h.cancel();</span>
<span class="nc" id="L157">      }</span>
    }

<span class="fc" id="L160">    return response;</span>
  }

  private static class ScatterGatherRequestContext {
    private final ScatterGatherRequest _request;
    private final long _startTimeMs;

<span class="fc" id="L167">    public ScatterGatherRequestContext(ScatterGatherRequest request) {</span>
<span class="fc" id="L168">      _request = request;</span>
<span class="fc" id="L169">      _startTimeMs = System.currentTimeMillis();</span>
<span class="fc" id="L170">    }</span>

    public long getRemainingTimeMs() {
<span class="fc" id="L173">      long timeout = _request.getRequestTimeoutMs();</span>

<span class="pc bpc" id="L175" title="1 of 2 branches missed.">      if (timeout &lt; 0) {</span>
<span class="nc" id="L176">        return Long.MAX_VALUE;</span>
      }

<span class="fc" id="L179">      long timeElapsed = System.currentTimeMillis() - _startTimeMs;</span>
<span class="fc" id="L180">      return timeout - timeElapsed;</span>
    }
  }

  /**
   * Runnable responsible for sending a request to the server once the connection is available
   *
   */
  private static class SingleRequestHandler implements Runnable {
    private final static int MAX_CONN_RETRIES = 3;  // Max retries for getting a connection
    // Scatter Request
    private final ScatterGatherRequest _request;
    // List Of Partitions to be queried on the server
    private final List&lt;String&gt; _segments;
    // Server Instance to be queried
    private final ServerInstance _server;
    // Latch to signal completion of dispatching request
    private final CountDownLatch _requestDispatchLatch;
    // Future for the response
    private volatile ResponseFuture _responseFuture;

    // Connection Pool: Used if we need to checkin/destroy object in case of timeout
    private final KeyedPool&lt;PooledNettyClientResourceManager.PooledClientConnection&gt; _connPool;

    // Track if request has been dispatched
<span class="fc" id="L205">    private final AtomicBoolean _isSent = new AtomicBoolean(false);</span>

    // Cancel dispatching request
<span class="fc" id="L208">    private final AtomicBoolean _isCancelled = new AtomicBoolean(false);</span>

    // Remaining time budget to connect and process the request.
    private final long _timeoutMS;

    private final long _initTime;
    private final BrokerMetrics _brokerMetrics;
    private long _startTime;
    private long _endTime;

    public SingleRequestHandler(KeyedPool&lt;PooledNettyClientResourceManager.PooledClientConnection&gt; connPool,
        ServerInstance server, ScatterGatherRequest request, List&lt;String&gt; segments, long timeoutMS,
<span class="fc" id="L220">        CountDownLatch latch, final BrokerMetrics brokerMetrics) {</span>
<span class="fc" id="L221">      _connPool = connPool;</span>
<span class="fc" id="L222">      _server = server;</span>
<span class="fc" id="L223">      _request = request;</span>
<span class="fc" id="L224">      _segments = segments;</span>
<span class="fc" id="L225">      _requestDispatchLatch = latch;</span>
<span class="fc" id="L226">      _timeoutMS = timeoutMS;</span>
<span class="fc" id="L227">      _initTime = System.currentTimeMillis();</span>
<span class="fc" id="L228">      _brokerMetrics = brokerMetrics;</span>
<span class="fc" id="L229">    }</span>

    @Override
    public synchronized void run() {
      try {
<span class="fc" id="L234">        _startTime = System.currentTimeMillis();</span>
<span class="fc" id="L235">        runInternal();</span>
      } finally {
<span class="pc" id="L237">        _endTime = System.currentTimeMillis();</span>
<span class="fc" id="L238">      }</span>
<span class="fc" id="L239">    }</span>

    public long getConnStartTimeMillis() {
<span class="fc" id="L242">      return _startTime - _initTime;</span>
    }

    public long getSendCompletionTimeMillis() {
<span class="fc bfc" id="L246" title="All 2 branches covered.">      return _endTime &gt; _initTime ? _endTime - _initTime : 0;</span>
    }

    // If the 'run' gets called more than 5ms after we created this object, something is wrong.
    public long getStartDelayMillis() {
<span class="fc" id="L251">      return _startTime - _initTime;</span>
    }

    private void runInternal() {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">      if (_isCancelled.get()) {</span>
<span class="nc" id="L256">        LOGGER.error(&quot;Request {} to server {} cancelled even before request is sent !! Not sending request&quot;,</span>
            _request.getRequestId(), _server);
<span class="nc" id="L258">        _requestDispatchLatch.countDown();</span>
<span class="nc" id="L259">        return;</span>
      }

<span class="fc" id="L262">      PooledNettyClientResourceManager.PooledClientConnection conn = null;</span>
<span class="fc" id="L263">      ServerResponseFuture&lt;PooledNettyClientResourceManager.PooledClientConnection&gt; serverResponseFuture = null;</span>
<span class="fc" id="L264">      boolean gotConnection = false;</span>
<span class="fc" id="L265">      boolean error = true;</span>
<span class="fc" id="L266">      long timeRemainingMillis = _timeoutMS - (System.currentTimeMillis() - _startTime);</span>
<span class="fc" id="L267">      long startTimeNs = System.nanoTime();</span>
<span class="fc" id="L268">      long timeWaitedNs = 0;</span>
      try {
<span class="fc" id="L270">        serverResponseFuture = _connPool.checkoutObject(_server, String.valueOf(_request.getRequestId()));</span>

<span class="fc" id="L272">        byte[] serializedRequest = _request.getRequestForService(_segments);</span>
<span class="fc" id="L273">        int ntries = 0;</span>
        // Try a maximum of pool size objects.
        while (true) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">          if (timeRemainingMillis &lt;= 0) {</span>
<span class="nc" id="L277">            throw new TimeoutException(</span>
                &quot;Timed out trying to connect to &quot; + _server + &quot;(timeout=&quot; + _timeoutMS + &quot;ms,ntries=&quot; + ntries + &quot;)&quot;);
          }
<span class="fc" id="L280">          conn = serverResponseFuture.getOne(timeRemainingMillis, TimeUnit.MILLISECONDS);</span>
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">          if (conn != null &amp;&amp; conn.validate()) {</span>
<span class="fc" id="L282">            timeWaitedNs = System.nanoTime() - startTimeNs;</span>
<span class="fc" id="L283">            gotConnection = true;</span>
<span class="fc" id="L284">            break;</span>
          }
          // conn may be null when the AsyncPoolImpl.create()
          // is not able to create a connection, and this tried to wait for a connection, and it reached the max waiters limit.
          // In that case, there is no point in retrying  this request
          // If we get a null error map, then it is most likely a case of max waiters limit.
          // The connect errors are obtained from two different objects -- 'conn' and 'keyedFuture'.
          // We pick the error from 'keyedFuture' here, if we find it. Unfortunately there is not a way (now) to pass the
          // error from 'keyedFuture' to 'conn' (need to do it via AsyncPoolImpl)
<span class="nc" id="L293">          Map&lt;ServerInstance, Throwable&gt; errorMap = serverResponseFuture.getError();</span>
<span class="nc" id="L294">          String errStr = &quot;&quot;;</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">          if (errorMap != null &amp;&amp; errorMap.containsKey(_server)) {</span>
<span class="nc" id="L296">            errStr = errorMap.get(_server).getMessage();</span>
          }
<span class="nc bnc" id="L298" title="All 2 branches missed.">          if (conn != null) {</span>
<span class="nc" id="L299">            LOGGER.warn(&quot;Destroying invalid conn {}:{}&quot;, conn, errStr);</span>
<span class="nc" id="L300">            _connPool.destroyObject(_server, conn);</span>
          }
<span class="nc bnc" id="L302" title="All 2 branches missed.">          if (++ntries == MAX_CONN_RETRIES - 1) {</span>
<span class="nc" id="L303">            throw new ConnectionLimitReachedException(</span>
                &quot;Could not connect to &quot; + _server + &quot; after &quot; + ntries + &quot; attempts(timeRemaining=&quot;
                    + timeRemainingMillis + &quot;ms)&quot;);
          }
<span class="nc" id="L307">          serverResponseFuture = _connPool.checkoutObject(_server, &quot;none&quot;);</span>
<span class="nc" id="L308">          timeRemainingMillis = _timeoutMS - (System.currentTimeMillis() - _startTime);</span>
<span class="nc" id="L309">        }</span>
<span class="fc" id="L310">        ByteBuf req = Unpooled.wrappedBuffer(serializedRequest);</span>
<span class="fc" id="L311">        _responseFuture = conn.sendRequest(req, _request.getRequestId(), timeRemainingMillis);</span>
<span class="fc" id="L312">        _isSent.set(true);</span>
<span class="fc" id="L313">        LOGGER.debug(&quot;Response Future is : {}&quot;, _responseFuture);</span>
<span class="fc" id="L314">        error = false;</span>
<span class="nc" id="L315">      } catch (TimeoutException e1) {</span>
<span class="nc" id="L316">        LOGGER.warn(&quot;Timed out waiting for connection for server ({})({})(gotConnection={}):{}. See metric {}&quot;, _server,</span>
            _request.getRequestId(), gotConnection, e1.getMessage(),
            BrokerMeter.REQUEST_DROPPED_DUE_TO_CONNECTION_ERROR.getMeterName());
<span class="nc" id="L319">        _responseFuture = new ResponseFuture(_server, e1, &quot;Error Future for request &quot; + _request.getRequestId());</span>
<span class="nc" id="L320">      } catch (ConnectionLimitReachedException e) {</span>
<span class="nc" id="L321">        LOGGER.warn(&quot;Request {} not sent (gotConnection={}):{}. See metric {}&quot;, _request.getRequestId(), gotConnection,</span>
            e.getMessage(), BrokerMeter.REQUEST_DROPPED_DUE_TO_CONNECTION_ERROR.getMeterName());
<span class="nc" id="L323">        _responseFuture = new ResponseFuture(_server, e, &quot;Error Future for request &quot; + _request.getRequestId());</span>
<span class="nc" id="L324">      } catch (Exception e) {</span>
<span class="nc" id="L325">        LOGGER.error(&quot;Got exception sending request ({})(gotConnection={}). Setting error future&quot;,</span>
            _request.getRequestId(), gotConnection, e);
<span class="nc" id="L327">        _responseFuture = new ResponseFuture(_server, e, &quot;Error Future for request &quot; + _request.getRequestId());</span>
      } finally {
<span class="pc" id="L329">        _requestDispatchLatch.countDown();</span>
<span class="pc" id="L330">        BrokerRequest brokerRequest = _request.getBrokerRequest();</span>
<span class="pc" id="L331">        _brokerMetrics.addPhaseTiming(brokerRequest, BrokerQueryPhase.REQUEST_CONNECTION_WAIT, timeWaitedNs);</span>
<span class="pc bpc" id="L332" title="9 of 10 branches missed.">        if (timeRemainingMillis &lt; 0) {</span>
<span class="nc" id="L333">          _brokerMetrics.addMeteredQueryValue(brokerRequest, BrokerMeter.REQUEST_CONNECTION_TIMEOUTS, 1);</span>
        }
<span class="pc bpc" id="L335" title="9 of 10 branches missed.">        if (error) {</span>
<span class="nc bnc" id="L336" title="All 10 branches missed.">          if (gotConnection) {</span>
            // We must have failed sometime when sending the request
<span class="nc" id="L338">            _brokerMetrics.addMeteredQueryValue(brokerRequest, BrokerMeter.REQUEST_DROPPED_DUE_TO_SEND_ERROR, 1);</span>
          } else {
            // If we got a keyed future, but we did not get to send a request, then cancel the future.
<span class="nc bnc" id="L341" title="All 10 branches missed.">            if (serverResponseFuture != null) {</span>
<span class="nc" id="L342">              serverResponseFuture.cancel(true);</span>
            }
<span class="nc" id="L344">            _brokerMetrics.addMeteredQueryValue(brokerRequest, BrokerMeter.REQUEST_DROPPED_DUE_TO_CONNECTION_ERROR, 1);</span>
          }
        }
<span class="pc" id="L347">      }</span>
<span class="fc" id="L348">    }</span>

    /**
     * Cancel checking-out request if possible. If in unsafe state (request already sent),
     * discard the connection from the pool.
     */
    public synchronized void cancel() {
<span class="nc bnc" id="L355" title="All 2 branches missed.">      if (_isCancelled.get()) {</span>
<span class="nc" id="L356">        return;</span>
      }

<span class="nc" id="L359">      _isCancelled.set(true);</span>

<span class="nc bnc" id="L361" title="All 2 branches missed.">      if (_isSent.get()) {</span>
        /**
         * If the request has already been sent, we cancel the
         * response future. The connection will automatically be returned to the pool if response
         * arrived within timeout or discarded if timeout happened. No need to handle it here.
         */
<span class="nc" id="L367">        _responseFuture.cancel(true);</span>
      }
<span class="nc" id="L369">    }</span>

    public ServerInstance getServer() {
<span class="fc" id="L372">      return _server;</span>
    }

    public ResponseFuture getResponseFuture() {
<span class="fc" id="L376">      return _responseFuture;</span>
    }

    public boolean isSent() {
<span class="nc" id="L380">      return _isSent.get();</span>
    }
  }

  private static class ConnectionLimitReachedException extends RuntimeException {
    ConnectionLimitReachedException(String msg) {
<span class="nc" id="L386">      super(msg);</span>
<span class="nc" id="L387">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>