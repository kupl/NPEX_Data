<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>InvertedIndexHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-hadoop</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.segment.index.loader.invertedindex</a> &gt; <span class="el_source">InvertedIndexHandler.java</span></div><h1>InvertedIndexHandler.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.segment.index.loader.invertedindex;

import com.linkedin.pinot.core.indexsegment.generator.SegmentVersion;
import com.linkedin.pinot.core.io.reader.DataFileReader;
import com.linkedin.pinot.core.io.reader.SingleColumnMultiValueReader;
import com.linkedin.pinot.core.io.reader.impl.v1.FixedBitMultiValueReader;
import com.linkedin.pinot.core.io.reader.impl.v1.FixedBitSingleValueReader;
import com.linkedin.pinot.core.segment.creator.impl.V1Constants;
import com.linkedin.pinot.core.segment.creator.impl.inv.OffHeapBitmapInvertedIndexCreator;
import com.linkedin.pinot.core.segment.index.ColumnMetadata;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import com.linkedin.pinot.core.segment.index.loader.IndexLoadingConfig;
import com.linkedin.pinot.core.segment.index.loader.LoaderUtils;
import com.linkedin.pinot.core.segment.memory.PinotDataBuffer;
import com.linkedin.pinot.core.segment.store.ColumnIndexType;
import com.linkedin.pinot.core.segment.store.SegmentDirectory;
import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import javax.annotation.Nonnull;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class InvertedIndexHandler {
<span class="fc" id="L43">  private static final Logger LOGGER = LoggerFactory.getLogger(InvertedIndexHandler.class);</span>

  private final File _indexDir;
  private final SegmentDirectory.Writer _segmentWriter;
  private final String _segmentName;
  private final SegmentVersion _segmentVersion;
<span class="fc" id="L49">  private final Set&lt;ColumnMetadata&gt; _invertedIndexColumns = new HashSet&lt;&gt;();</span>

  public InvertedIndexHandler(@Nonnull File indexDir, @Nonnull SegmentMetadataImpl segmentMetadata,
<span class="fc" id="L52">      @Nonnull IndexLoadingConfig indexLoadingConfig, @Nonnull SegmentDirectory.Writer segmentWriter) {</span>
<span class="fc" id="L53">    _indexDir = indexDir;</span>
<span class="fc" id="L54">    _segmentWriter = segmentWriter;</span>
<span class="fc" id="L55">    _segmentName = segmentMetadata.getName();</span>
<span class="fc" id="L56">    _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());</span>

    // Do not create inverted index for sorted column
<span class="fc bfc" id="L59" title="All 2 branches covered.">    for (String column : indexLoadingConfig.getInvertedIndexColumns()) {</span>
<span class="fc" id="L60">      ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);</span>
<span class="fc bfc" id="L61" title="All 4 branches covered.">      if (columnMetadata != null &amp;&amp; !columnMetadata.isSorted()) {</span>
<span class="fc" id="L62">        _invertedIndexColumns.add(columnMetadata);</span>
      }
<span class="fc" id="L64">    }</span>
<span class="fc" id="L65">  }</span>

  public void createInvertedIndices() throws IOException {
<span class="fc bfc" id="L68" title="All 2 branches covered.">    for (ColumnMetadata columnMetadata : _invertedIndexColumns) {</span>
<span class="fc" id="L69">      createInvertedIndexForColumn(columnMetadata);</span>
<span class="fc" id="L70">    }</span>
<span class="fc" id="L71">  }</span>

  private void createInvertedIndexForColumn(ColumnMetadata columnMetadata) throws IOException {
<span class="fc" id="L74">    String column = columnMetadata.getColumnName();</span>

<span class="fc" id="L76">    File inProgress = new File(_indexDir, column + &quot;.inv.inprogress&quot;);</span>
<span class="fc" id="L77">    File invertedIndexFile = new File(_indexDir, column + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);</span>

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">    if (!inProgress.exists()) {</span>
      // Marker file does not exist, which means last run ended normally.

<span class="fc bfc" id="L82" title="All 2 branches covered.">      if (_segmentWriter.hasIndexFor(column, ColumnIndexType.INVERTED_INDEX)) {</span>
        // Skip creating inverted index if already exists.

<span class="fc" id="L85">        LOGGER.info(&quot;Found inverted index for segment: {}, column: {}&quot;, _segmentName, column);</span>
<span class="fc" id="L86">        return;</span>
      }

      // Create a marker file.
<span class="fc" id="L90">      FileUtils.touch(inProgress);</span>
    } else {
      // Marker file exists, which means last run gets interrupted.

      // Remove inverted index if exists.
      // For v1 and v2, it's the actual inverted index. For v3, it's the temporary inverted index.
<span class="nc" id="L96">      FileUtils.deleteQuietly(invertedIndexFile);</span>
    }

    // Create new inverted index for the column.
<span class="fc" id="L100">    LOGGER.info(&quot;Creating new inverted index for segment: {}, column: {}&quot;, _segmentName, column);</span>
<span class="fc" id="L101">    int numDocs = columnMetadata.getTotalDocs();</span>
<span class="pc" id="L102">    try (OffHeapBitmapInvertedIndexCreator creator = new OffHeapBitmapInvertedIndexCreator(_indexDir,</span>
        columnMetadata.getFieldSpec(), columnMetadata.getCardinality(), numDocs,
        columnMetadata.getTotalNumberOfEntries())) {
<span class="pc" id="L105">      try (DataFileReader fwdIndex = getForwardIndexReader(columnMetadata, _segmentWriter)) {</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (columnMetadata.isSingleValue()) {</span>
          // Single-value column.

<span class="fc" id="L109">          FixedBitSingleValueReader svFwdIndex = (FixedBitSingleValueReader) fwdIndex;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">          for (int i = 0; i &lt; numDocs; i++) {</span>
<span class="fc" id="L111">            creator.addSV(i, svFwdIndex.getInt(i));</span>
          }
<span class="fc" id="L113">        } else {</span>
          // Multi-value column.

<span class="nc" id="L116">          SingleColumnMultiValueReader mvFwdIndex = (SingleColumnMultiValueReader) fwdIndex;</span>
<span class="nc" id="L117">          int[] dictIds = new int[columnMetadata.getMaxNumberOfMultiValues()];</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">          for (int i = 0; i &lt; numDocs; i++) {</span>
<span class="nc" id="L119">            int numDictIds = mvFwdIndex.getIntArray(i, dictIds);</span>
<span class="nc" id="L120">            creator.addMV(i, dictIds, numDictIds);</span>
          }
        }
<span class="fc" id="L123">        creator.seal();</span>
<span class="pc bpc" id="L124" title="6 of 8 branches missed.">      }</span>
<span class="pc bpc" id="L125" title="6 of 8 branches missed.">    }</span>

    // For v3, write the generated inverted index file into the single file and remove it.
<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (_segmentVersion == SegmentVersion.v3) {</span>
<span class="fc" id="L129">      LoaderUtils.writeIndexToV3Format(_segmentWriter, column, invertedIndexFile, ColumnIndexType.INVERTED_INDEX);</span>
    }

    // Delete the marker file.
<span class="fc" id="L133">    FileUtils.deleteQuietly(inProgress);</span>

<span class="fc" id="L135">    LOGGER.info(&quot;Created inverted index for segment: {}, column: {}&quot;, _segmentName, column);</span>
<span class="fc" id="L136">  }</span>

  private DataFileReader getForwardIndexReader(ColumnMetadata columnMetadata, SegmentDirectory.Writer segmentWriter)
      throws IOException {
<span class="fc" id="L140">    PinotDataBuffer buffer = segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);</span>
<span class="fc" id="L141">    int numRows = columnMetadata.getTotalDocs();</span>
<span class="fc" id="L142">    int numBitsPerValue = columnMetadata.getBitsPerElement();</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">    if (columnMetadata.isSingleValue()) {</span>
<span class="fc" id="L144">      return new FixedBitSingleValueReader(buffer, numRows, numBitsPerValue);</span>
    } else {
<span class="nc" id="L146">      return new FixedBitMultiValueReader(buffer, numRows, columnMetadata.getTotalNumberOfEntries(), numBitsPerValue);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>