<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MultiLevelPriorityQueue.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-hadoop</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.query.scheduler</a> &gt; <span class="el_source">MultiLevelPriorityQueue.java</span></div><h1>MultiLevelPriorityQueue.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.linkedin.pinot.core.query.scheduler;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.query.ServerQueryRequest;
import com.linkedin.pinot.core.query.scheduler.resources.ResourceManager;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.apache.commons.configuration.Configuration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Priority queues of scheduler groups that determines query priority based on tokens
 *
 * This is a multi-level query scheduling queue with each sublevel maintaining a waitlist of
 * queries for the group. The priority between groups is provided by specific SchedulerGroup
 * implementation. If two groups have the same priority then the group with lower
 * resource utilization is selected first. Oldest query from the winning SchedulerGroup
 * is selected for execution.
 */
public class MultiLevelPriorityQueue implements SchedulerPriorityQueue {

<span class="fc" id="L49">  private static Logger LOGGER = LoggerFactory.getLogger(MultiLevelPriorityQueue.class);</span>
  public static final String QUERY_DEADLINE_SECONDS_KEY = &quot;query_deadline_seconds&quot;;
  public static final String MAX_PENDING_PER_GROUP_KEY = &quot;max_pending_per_group&quot;;
  public static final String QUEUE_WAKEUP_MICROS = &quot;queue_wakeup_micros&quot;;

  private static final int DEFAULT_WAKEUP_MICROS = 1000;

<span class="fc" id="L56">  private static int wakeUpTimeMicros = DEFAULT_WAKEUP_MICROS;</span>
  private final int maxPendingPerGroup;

<span class="fc" id="L59">  private final Map&lt;String, SchedulerGroup&gt; schedulerGroups = new HashMap&lt;&gt;();</span>
<span class="fc" id="L60">  private final Lock queueLock = new ReentrantLock();</span>
<span class="fc" id="L61">  private final Condition queryReaderCondition = queueLock.newCondition();</span>
  private final ResourceManager resourceManager;
  private final SchedulerGroupMapper groupSelector;
  private final int queryDeadlineMillis;
  private final SchedulerGroupFactory groupFactory;
  private final Configuration config;


  public MultiLevelPriorityQueue(@Nonnull Configuration config, @Nonnull ResourceManager resourceManager,
      @Nonnull  SchedulerGroupFactory groupFactory,
<span class="fc" id="L71">      @Nonnull SchedulerGroupMapper groupMapper) {</span>
<span class="fc" id="L72">    Preconditions.checkNotNull(config);</span>
<span class="fc" id="L73">    Preconditions.checkNotNull(resourceManager);</span>
<span class="fc" id="L74">    Preconditions.checkNotNull(groupFactory);</span>
<span class="fc" id="L75">    Preconditions.checkNotNull(groupMapper);</span>

    // max available tokens per millisecond equals number of threads (total execution capacity)
    // we are over provisioning tokens here because its better to keep pipe full rather than empty
<span class="fc" id="L79">    queryDeadlineMillis = config.getInt(QUERY_DEADLINE_SECONDS_KEY, 30) * 1000;</span>
<span class="fc" id="L80">    wakeUpTimeMicros = config.getInt(QUEUE_WAKEUP_MICROS, DEFAULT_WAKEUP_MICROS);</span>
<span class="fc" id="L81">    maxPendingPerGroup = config.getInt(MAX_PENDING_PER_GROUP_KEY, 10);</span>
<span class="fc" id="L82">    this.config = config;</span>
<span class="fc" id="L83">    this.resourceManager = resourceManager;</span>
<span class="fc" id="L84">    this.groupFactory = groupFactory;</span>
<span class="fc" id="L85">    this.groupSelector = groupMapper;</span>
<span class="fc" id="L86">  }</span>

  @Override
  public void put(@Nonnull SchedulerQueryContext query) throws OutOfCapacityError {
<span class="fc" id="L90">    Preconditions.checkNotNull(query);</span>
<span class="fc" id="L91">    queueLock.lock();</span>
<span class="fc" id="L92">    String groupName = groupSelector.getSchedulerGroupName(query);</span>
    try {
<span class="fc" id="L94">      SchedulerGroup groupContext = getOrCreateGroupContext(groupName);</span>
<span class="fc" id="L95">      checkGroupHasCapacity(groupContext);</span>
<span class="fc" id="L96">      query.setSchedulerGroupContext(groupContext);</span>
<span class="fc" id="L97">      groupContext.addLast(query);</span>
<span class="fc" id="L98">      queryReaderCondition.signal();</span>
    } finally {
<span class="fc" id="L100">      queueLock.unlock();</span>
<span class="fc" id="L101">    }</span>
<span class="fc" id="L102">  }</span>

  /**
   * Blocking call to read the next query in order of priority
   * @return
   */
  @Override
  public @Nullable SchedulerQueryContext take() {
<span class="fc" id="L110">    queueLock.lock();</span>
    try {
      while (true) {
        SchedulerQueryContext schedulerQueryContext;
<span class="fc bfc" id="L114" title="All 2 branches covered.">        while ( (schedulerQueryContext = takeNextInternal()) == null) {</span>
          try {
<span class="fc" id="L116">            queryReaderCondition.await(wakeUpTimeMicros, TimeUnit.MICROSECONDS);</span>
<span class="fc" id="L117">          } catch (InterruptedException e) {</span>
<span class="fc" id="L118">            return null;</span>
<span class="fc" id="L119">          }</span>
        }
<span class="fc" id="L121">        return schedulerQueryContext;</span>
      }
    } finally {
<span class="pc" id="L124">      queueLock.unlock();</span>
    }
  }

  @Nonnull
  @Override
  public List&lt;SchedulerQueryContext&gt; drain() {
<span class="fc" id="L131">    List&lt;SchedulerQueryContext&gt; pending = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L132">    queueLock.lock();</span>
    try {
<span class="fc bfc" id="L134" title="All 2 branches covered.">      for (Map.Entry&lt;String, SchedulerGroup&gt; groupEntry : schedulerGroups.entrySet()) {</span>
<span class="fc" id="L135">        SchedulerGroup group = groupEntry.getValue();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        while (!group.isEmpty()) {</span>
<span class="fc" id="L137">          pending.add(group.removeFirst());</span>
        }
<span class="fc" id="L139">      }</span>
    } finally {
<span class="pc" id="L141">      queueLock.unlock();</span>
<span class="fc" id="L142">    }</span>
<span class="fc" id="L143">    return pending;</span>
  }

  private SchedulerQueryContext takeNextInternal() {
<span class="fc" id="L147">    SchedulerGroup currentWinnerGroup = null;</span>
<span class="fc" id="L148">    long startTime = System.nanoTime();</span>
<span class="fc" id="L149">    StringBuilder sb = new StringBuilder(&quot;SchedulerInfo:&quot;);</span>
<span class="fc" id="L150">    long deadlineEpochMillis = currentTimeMillis() - queryDeadlineMillis;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">    for (Map.Entry&lt;String, SchedulerGroup&gt; groupInfoEntry : schedulerGroups.entrySet()) {</span>
<span class="fc" id="L152">      SchedulerGroup group = groupInfoEntry.getValue();</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L154">        sb.append(group.toString());</span>
      }
<span class="fc" id="L156">      group.trimExpired(deadlineEpochMillis);</span>
<span class="fc bfc" id="L157" title="All 4 branches covered.">      if (group.isEmpty() || !resourceManager.canSchedule(group)) {</span>
<span class="fc" id="L158">        continue;</span>
      }

<span class="fc bfc" id="L161" title="All 2 branches covered.">      if (currentWinnerGroup == null) {</span>
<span class="fc" id="L162">        currentWinnerGroup = group;</span>
<span class="fc" id="L163">        continue;</span>
      }

      // Preconditions:
      // a. currentGroupResources &lt;= hardLimit
      // b. selectedGroupResources &lt;= hardLimit
      // We prefer group with higher priority but with resource limits.
      // If current group priority are greater than currently winning priority then we choose current
      // group over currentWinnerGroup if
      // a. current group is using less than softLimit resources
      // b. if softLimit &lt; currentGroupResources &lt;= hardLimit then
      //     i. choose group if softLimit &lt;= currentWinnerGroup &lt;= hardLimit
      //     ii. continue with currentWinnerGroup otherwise
<span class="fc" id="L176">      int comparison = group.compareTo(currentWinnerGroup);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">      if (comparison &lt; 0) {</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">        if (currentWinnerGroup.totalReservedThreads() &gt; resourceManager.getTableThreadsSoftLimit() &amp;&amp;</span>
            group.totalReservedThreads() &lt; resourceManager.getTableThreadsSoftLimit()) {
<span class="nc" id="L180">          currentWinnerGroup = group;</span>
        }
        continue;
      }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">      if (comparison &gt;= 0) {</span>
<span class="fc bfc" id="L185" title="All 4 branches covered.">        if (group.totalReservedThreads() &lt; resourceManager.getTableThreadsSoftLimit() ||</span>
            group.totalReservedThreads() &lt; currentWinnerGroup.totalReservedThreads()) {
<span class="fc" id="L187">          currentWinnerGroup = group;</span>
        }
      }
<span class="fc" id="L190">    }</span>

<span class="fc" id="L192">    SchedulerQueryContext query = null;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">    if (currentWinnerGroup != null) {</span>
<span class="fc" id="L194">      ServerQueryRequest queryRequest = currentWinnerGroup.peekFirst().getQueryRequest();</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L196">        sb.append(String.format(&quot; Winner: %s: [%d,%d,%d,%d]&quot;, currentWinnerGroup.name(), queryRequest.getTimerContext().getQueryArrivalTimeMs(),</span>
            queryRequest.getInstanceRequest().getRequestId(), queryRequest.getInstanceRequest().getSearchSegments().size(),
            startTime));
      }
<span class="fc" id="L200">      query = currentWinnerGroup.removeFirst();</span>
    }
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">    if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L203">      LOGGER.debug(sb.toString());</span>
    }
<span class="fc" id="L205">    return query;</span>
  }

  private void checkGroupHasCapacity(SchedulerGroup groupContext) throws OutOfCapacityError {
<span class="pc bpc" id="L209" title="1 of 4 branches missed.">    if (groupContext.numPending() &gt;= maxPendingPerGroup &amp;&amp;</span>
        groupContext.totalReservedThreads() &gt;= resourceManager.getTableThreadsHardLimit()) {
<span class="fc" id="L211">      throw new OutOfCapacityError(</span>
          String.format(&quot;SchedulerGroup %s is out of capacity. numPending: %d, maxPending: %d, reservedThreads: %d threadsHardLimit: %d&quot;,
              groupContext.name(),
              groupContext.numPending(), maxPendingPerGroup,
              groupContext.totalReservedThreads(), resourceManager.getTableThreadsHardLimit()));
    }
<span class="fc" id="L217">  }</span>

  private SchedulerGroup getOrCreateGroupContext(String groupName) {
<span class="fc" id="L220">    SchedulerGroup groupContext = schedulerGroups.get(groupName);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if (groupContext == null) {</span>
<span class="fc" id="L222">      groupContext = groupFactory.create(config, groupName);</span>
<span class="fc" id="L223">      schedulerGroups.put(groupName, groupContext);</span>
    }
<span class="fc" id="L225">    return groupContext;</span>
  }

  // separate method to allow mocking for unit testing
  private long currentTimeMillis() {
<span class="fc" id="L230">    return System.currentTimeMillis();</span>
  }

  @VisibleForTesting
  long getWakeupTimeMicros() {
<span class="fc" id="L235">    return wakeUpTimeMicros;</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>