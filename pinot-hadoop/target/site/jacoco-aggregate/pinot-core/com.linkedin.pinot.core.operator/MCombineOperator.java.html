<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MCombineOperator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-hadoop</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.operator</a> &gt; <span class="el_source">MCombineOperator.java</span></div><h1>MCombineOperator.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.operator;

import com.linkedin.pinot.common.exception.QueryException;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.core.common.Block;
import com.linkedin.pinot.core.common.Operator;
import com.linkedin.pinot.core.operator.blocks.IntermediateResultsBlock;
import com.linkedin.pinot.core.query.reduce.CombineService;
import com.linkedin.pinot.core.util.trace.TraceCallable;
import com.linkedin.pinot.core.util.trace.TraceRunnable;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The &lt;code&gt;MCombineOperator&lt;/code&gt; class is the operator to combine selection results and aggregation only results.
 */
public class MCombineOperator extends BaseOperator&lt;IntermediateResultsBlock&gt; {
<span class="fc" id="L43">  private static final Logger LOGGER = LoggerFactory.getLogger(MCombineOperator.class);</span>
  private static final String OPERATOR_NAME = &quot;MCombineOperator&quot;;

  private final List&lt;Operator&gt; _operators;
  private final BrokerRequest _brokerRequest;
  private final ExecutorService _executorService;
  private final long _timeOutMs;
  //Make this configurable
  //These two control the parallelism on a per query basis, depending on the number of segments to process
  private static final int MIN_THREADS_PER_QUERY;
  private static final int MAX_THREADS_PER_QUERY;
  private static final int MIN_SEGMENTS_PER_THREAD = 10;

  static {
<span class="fc" id="L57">    int numCores = Runtime.getRuntime().availableProcessors();</span>
<span class="fc" id="L58">    MIN_THREADS_PER_QUERY = Math.max(1, (int) (numCores * .5));</span>
    //Dont have more than 10 threads per query
<span class="fc" id="L60">    MAX_THREADS_PER_QUERY = Math.min(10, (int) (numCores * .5));</span>
<span class="fc" id="L61">  }</span>

  public MCombineOperator(List&lt;Operator&gt; operators, ExecutorService executorService, long timeOutMs,
<span class="fc" id="L64">      BrokerRequest brokerRequest) {</span>
<span class="fc" id="L65">    _operators = operators;</span>
<span class="fc" id="L66">    _executorService = executorService;</span>
<span class="fc" id="L67">    _brokerRequest = brokerRequest;</span>
<span class="fc" id="L68">    _timeOutMs = timeOutMs;</span>
<span class="fc" id="L69">  }</span>

  @Override
  protected IntermediateResultsBlock getNextBlock() {
<span class="fc" id="L73">    final long startTime = System.currentTimeMillis();</span>
<span class="fc" id="L74">    final long queryEndTime = System.currentTimeMillis() + _timeOutMs;</span>
<span class="fc" id="L75">    final int numOperators = _operators.size();</span>
    // Ensure that the number of groups is not more than the number of segments
<span class="fc" id="L77">    final int numGroups = Math.min(numOperators, Math.max(MIN_THREADS_PER_QUERY,</span>
        Math.min(MAX_THREADS_PER_QUERY, (numOperators + MIN_SEGMENTS_PER_THREAD - 1) / MIN_SEGMENTS_PER_THREAD)));

<span class="fc" id="L80">    final List&lt;List&lt;Operator&gt;&gt; operatorGroups = new ArrayList&lt;&gt;(numGroups);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">    for (int i = 0; i &lt; numGroups; i++) {</span>
<span class="fc" id="L82">      operatorGroups.add(new ArrayList&lt;Operator&gt;());</span>
    }
<span class="fc bfc" id="L84" title="All 2 branches covered.">    for (int i = 0; i &lt; numOperators; i++) {</span>
<span class="fc" id="L85">      operatorGroups.get(i % numGroups).add(_operators.get(i));</span>
    }

<span class="fc" id="L88">    final BlockingQueue&lt;Block&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(numGroups);</span>
    // Submit operators.
<span class="fc bfc" id="L90" title="All 2 branches covered.">    for (final List&lt;Operator&gt; operatorGroup : operatorGroups) {</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">      _executorService.submit(new TraceRunnable() {</span>
        @Override
        public void runJob() {
<span class="fc" id="L94">          IntermediateResultsBlock mergedBlock = null;</span>
          try {
<span class="fc bfc" id="L96" title="All 2 branches covered.">            for (Operator operator : operatorGroup) {</span>
<span class="fc" id="L97">              IntermediateResultsBlock blockToMerge = (IntermediateResultsBlock) operator.nextBlock();</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">              if (mergedBlock == null) {</span>
<span class="fc" id="L99">                mergedBlock = blockToMerge;</span>
              } else {
                try {
<span class="nc" id="L102">                  CombineService.mergeTwoBlocks(_brokerRequest, mergedBlock, blockToMerge);</span>
<span class="nc" id="L103">                } catch (Exception e) {</span>
<span class="nc" id="L104">                  LOGGER.error(&quot;Caught exception while merging two blocks (step 1).&quot;, e);</span>
<span class="nc" id="L105">                  mergedBlock.addToProcessingExceptions(</span>
                      QueryException.getException(QueryException.MERGE_RESPONSE_ERROR, e));
<span class="nc" id="L107">                }</span>
              }
<span class="fc" id="L109">            }</span>
<span class="nc" id="L110">          } catch (Exception e) {</span>
<span class="nc" id="L111">            LOGGER.error(&quot;Caught exception while executing query.&quot;, e);</span>
<span class="nc" id="L112">            mergedBlock = new IntermediateResultsBlock(e);</span>
<span class="fc" id="L113">          }</span>
<span class="pc bpc" id="L114" title="2 of 4 branches missed.">          assert mergedBlock != null;</span>
<span class="fc" id="L115">          blockingQueue.offer(mergedBlock);</span>
<span class="fc" id="L116">        }</span>
      });
<span class="fc" id="L118">    }</span>
<span class="fc" id="L119">    LOGGER.debug(&quot;Submitting operators to be run in parallel and it took:&quot; + (System.currentTimeMillis() - startTime));</span>

    // Submit merger job:
<span class="fc" id="L122">    Future&lt;IntermediateResultsBlock&gt; mergedBlockFuture =</span>
<span class="fc" id="L123">        _executorService.submit(new TraceCallable&lt;IntermediateResultsBlock&gt;() {</span>
          @Override
          public IntermediateResultsBlock callJob()
              throws Exception {
<span class="fc" id="L127">            int mergedBlocksNumber = 0;</span>
<span class="fc" id="L128">            IntermediateResultsBlock mergedBlock = null;</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            while (mergedBlocksNumber &lt; numGroups) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">              if (mergedBlock == null) {</span>
<span class="fc" id="L131">                mergedBlock = (IntermediateResultsBlock) blockingQueue.poll(queryEndTime - System.currentTimeMillis(),</span>
                    TimeUnit.MILLISECONDS);
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">                if (mergedBlock != null) {</span>
<span class="fc" id="L134">                  mergedBlocksNumber++;</span>
                }
<span class="fc" id="L136">                LOGGER.debug(&quot;Got response from operator 0 after: {}&quot;, (System.currentTimeMillis() - startTime));</span>
              } else {
<span class="fc" id="L138">                IntermediateResultsBlock blockToMerge =</span>
                    (IntermediateResultsBlock) blockingQueue.poll(queryEndTime - System.currentTimeMillis(),
                        TimeUnit.MILLISECONDS);
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                if (blockToMerge != null) {</span>
                  try {
<span class="fc" id="L143">                    LOGGER.debug(&quot;Got response from operator {} after: {}&quot;, mergedBlocksNumber,</span>
                        (System.currentTimeMillis() - startTime));
<span class="fc" id="L145">                    CombineService.mergeTwoBlocks(_brokerRequest, mergedBlock, blockToMerge);</span>
<span class="fc" id="L146">                    LOGGER.debug(&quot;Merged response from operator {} after: {}&quot;, mergedBlocksNumber,</span>
                        (System.currentTimeMillis() - startTime));
<span class="nc" id="L148">                  } catch (Exception e) {</span>
<span class="nc" id="L149">                    LOGGER.error(&quot;Caught exception while merging two blocks (step 2).&quot;, e);</span>
<span class="nc" id="L150">                    mergedBlock.addToProcessingExceptions(</span>
                        QueryException.getException(QueryException.MERGE_RESPONSE_ERROR, e));
<span class="fc" id="L152">                  }</span>
<span class="fc" id="L153">                  mergedBlocksNumber++;</span>
                }
<span class="fc" id="L155">              }</span>
            }
<span class="fc" id="L157">            return mergedBlock;</span>
          }
        });

    // Get merge results.
    IntermediateResultsBlock mergedBlock;
    try {
<span class="fc" id="L164">      mergedBlock = mergedBlockFuture.get(queryEndTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L165">    } catch (InterruptedException e) {</span>
<span class="nc" id="L166">      LOGGER.error(&quot;Caught InterruptedException.&quot;, e);</span>
<span class="nc" id="L167">      mergedBlock = new IntermediateResultsBlock(QueryException.getException(QueryException.FUTURE_CALL_ERROR, e));</span>
<span class="nc" id="L168">    } catch (ExecutionException e) {</span>
<span class="nc" id="L169">      LOGGER.error(&quot;Caught ExecutionException.&quot;, e);</span>
<span class="nc" id="L170">      mergedBlock = new IntermediateResultsBlock(QueryException.getException(QueryException.MERGE_RESPONSE_ERROR, e));</span>
<span class="nc" id="L171">    } catch (TimeoutException e) {</span>
<span class="nc" id="L172">      LOGGER.error(&quot;Caught TimeoutException&quot;, e);</span>
<span class="nc" id="L173">      mergedBlockFuture.cancel(true);</span>
<span class="nc" id="L174">      mergedBlock =</span>
          new IntermediateResultsBlock(QueryException.getException(QueryException.EXECUTION_TIMEOUT_ERROR, e));
<span class="pc" id="L176">    }</span>

    // Update execution statistics.
<span class="fc" id="L179">    ExecutionStatistics executionStatistics = new ExecutionStatistics();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    for (Operator operator : _operators) {</span>
<span class="fc" id="L181">      ExecutionStatistics executionStatisticsToMerge = operator.getExecutionStatistics();</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">      if (executionStatisticsToMerge != null) {</span>
<span class="fc" id="L183">        executionStatistics.merge(executionStatisticsToMerge);</span>
      }
<span class="fc" id="L185">    }</span>
<span class="fc" id="L186">    mergedBlock.setNumDocsScanned(executionStatistics.getNumDocsScanned());</span>
<span class="fc" id="L187">    mergedBlock.setNumEntriesScannedInFilter(executionStatistics.getNumEntriesScannedInFilter());</span>
<span class="fc" id="L188">    mergedBlock.setNumEntriesScannedPostFilter(executionStatistics.getNumEntriesScannedPostFilter());</span>
<span class="fc" id="L189">    mergedBlock.setNumTotalRawDocs(executionStatistics.getNumTotalRawDocs());</span>

<span class="fc" id="L191">    return mergedBlock;</span>
  }

  @Override
  public String getOperatorName() {
<span class="nc" id="L196">    return OPERATOR_NAME;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>