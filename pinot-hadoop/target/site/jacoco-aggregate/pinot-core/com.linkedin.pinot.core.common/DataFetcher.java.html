<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DataFetcher.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-hadoop</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.common</a> &gt; <span class="el_source">DataFetcher.java</span></div><h1>DataFetcher.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.common;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.core.operator.BaseOperator;
import com.linkedin.pinot.core.plan.DocIdSetPlanNode;
import com.linkedin.pinot.core.segment.index.readers.Dictionary;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;


/**
 * DataFetcher is a higher level abstraction for data fetching. Given an index segment, DataFetcher can manage the
 * DataSource, Dictionary, BlockValSet and BlockValIterator for this segment, preventing redundant construction for
 * these instances. DataFetcher can be used by both selection, aggregation and group-by data fetching process, reducing
 * duplicate codes and garbage collection.
 */
public class DataFetcher {
  private final Map&lt;String, Dictionary&gt; _columnToDictionaryMap;
  private final Map&lt;String, BlockValSet&gt; _columnToBlockValSetMap;
  private final Map&lt;String, BlockValIterator&gt; _columnToBlockValIteratorMap;
  private final Map&lt;String, BlockMetadata&gt; _columnToBlockMetadataMap;

  // Map from MV column name to max number of entries for the column.
  private final Map&lt;String, Integer&gt; _columnToMaxNumMultiValuesMap;

  // Thread local (reusable) array for all dictionary ids in the block, of a single valued column
<span class="fc" id="L44">  private static final ThreadLocal&lt;int[]&gt; THREAD_LOCAL_DICT_IDS = new ThreadLocal&lt;int[]&gt;() {</span>
    @Override
    protected int[] initialValue() {
<span class="fc" id="L47">      return new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];</span>
    }
  };

  // Re-usable array to store MV dictionary id's for a given docId
<span class="fc" id="L52">  private static final ThreadLocal&lt;int[]&gt; THREAD_LOCAL_MV_DICT_IDS = new ThreadLocal&lt;int[]&gt;() {</span>
    @Override
    protected int[] initialValue() {
      // Size is known only at runtime, which is when the array is expanded.
<span class="fc" id="L56">      return new int[0];</span>
    }
  };

  private int _reusableMVDictIdSize;

  /**
   * Constructor for DataFetcher.
   *
   * @param columnToDataSourceMap Map from column name to data source
   */
<span class="fc" id="L67">  public DataFetcher(Map&lt;String, BaseOperator&gt; columnToDataSourceMap) {</span>
<span class="fc" id="L68">    _columnToDictionaryMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L69">    _columnToBlockValSetMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L70">    _columnToBlockValIteratorMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L71">    _columnToBlockMetadataMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L72">    _columnToMaxNumMultiValuesMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L74">    _reusableMVDictIdSize = 0;</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">    for (String column : columnToDataSourceMap.keySet()) {</span>
<span class="fc" id="L76">      BaseOperator dataSource = columnToDataSourceMap.get(column);</span>
<span class="fc" id="L77">      Block dataSourceBlock = dataSource.nextBlock();</span>
<span class="fc" id="L78">      BlockMetadata metadata = dataSourceBlock.getMetadata();</span>
<span class="fc" id="L79">      _columnToDictionaryMap.put(column, metadata.getDictionary());</span>

<span class="fc" id="L81">      BlockValSet blockValSet = dataSourceBlock.getBlockValueSet();</span>
<span class="fc" id="L82">      _columnToBlockValSetMap.put(column, blockValSet);</span>
<span class="fc" id="L83">      _columnToBlockValIteratorMap.put(column, blockValSet.iterator());</span>
<span class="fc" id="L84">      _columnToBlockMetadataMap.put(column, metadata);</span>

<span class="fc" id="L86">      int maxNumberOfMultiValues = metadata.getMaxNumberOfMultiValues();</span>
<span class="fc" id="L87">      _columnToMaxNumMultiValuesMap.put(column, maxNumberOfMultiValues);</span>
<span class="fc" id="L88">      _reusableMVDictIdSize = Math.max(_reusableMVDictIdSize, maxNumberOfMultiValues);</span>
<span class="fc" id="L89">    }</span>
<span class="fc" id="L90">  }</span>

  /**
   * Given a column, fetch its dictionary.
   *
   * @param column column name.
   * @return dictionary associated with this column.
   */
  public Dictionary getDictionaryForColumn(String column) {
<span class="fc" id="L99">    return _columnToDictionaryMap.get(column);</span>
  }

  /**
   * Given a column, fetch its block value set.
   *
   * @param column column name.
   * @return block value set associated with this column.
   */
  public BlockValSet getBlockValSetForColumn(String column) {
<span class="fc" id="L109">    return _columnToBlockValSetMap.get(column);</span>
  }

  /**
   * Returns the BlockValIterator for the specified column.
   *
   * @param column Column for which to return the blockValIterator.
   * @return BlockValIterator for the column.
   */
  public BlockValIterator getBlockValIteratorForColumn(String column) {
<span class="fc" id="L119">    return _columnToBlockValIteratorMap.get(column);</span>
  }

  public BlockMetadata getBlockMetadataFor(String column) {
<span class="nc" id="L123">    return _columnToBlockMetadataMap.get(column);</span>
  }

  /**
   * Fetch the dictionary Ids for a single value column.
   *
   * @param column column name.
   * @param inDocIds document Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outDictIds dictionary Id array buffer.
   * @param outStartPos output start position.
   */
  public void fetchSingleDictIds(String column, int[] inDocIds, int inStartPos, int length, int[] outDictIds, int outStartPos) {
<span class="fc" id="L137">    BlockValSet blockValSet = getBlockValSetForColumn(column);</span>
<span class="fc" id="L138">    blockValSet.getDictionaryIds(inDocIds, inStartPos, length, outDictIds, outStartPos);</span>
<span class="fc" id="L139">  }</span>

  /**
   * Fetch the dictionary Ids for a multi value column.
   *
   * @param column column name.
   * @param inDocIds document Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outDictIdsArray dictionary Id array array buffer.
   * @param outStartPos output start position.
   * @param tempDictIdArray temporary holding dictIds read from BlockMultiValIterator.
   *          Array size has to be &gt;= max number of entries for this column.
   */
  public void fetchMultiValueDictIds(String column, int[] inDocIds, int inStartPos, int length, int[][] outDictIdsArray, int outStartPos,
      int[] tempDictIdArray) {
<span class="fc" id="L155">    BlockMultiValIterator iterator = (BlockMultiValIterator) getBlockValIteratorForColumn(column);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    for (int i = inStartPos; i &lt; inStartPos + length; i++, outStartPos++) {</span>
<span class="fc" id="L157">      iterator.skipTo(inDocIds[i]);</span>
<span class="fc" id="L158">      int dictIdLength = iterator.nextIntVal(tempDictIdArray);</span>
<span class="fc" id="L159">      outDictIdsArray[outStartPos] = Arrays.copyOfRange(tempDictIdArray, 0, dictIdLength);</span>
    }
<span class="fc" id="L161">  }</span>

  /**
   * For a given multi-value column, trying to get the max number of
   * entries per row.
   *
   * @param column Column for which to get the max number of multi-values.
   * @return max number of entries for a given column.
   */
  public int getMaxNumberOfEntriesForColumn(String column) {
<span class="fc" id="L171">    return _columnToMaxNumMultiValuesMap.get(column);</span>
  }

  /**
   * Fetch the values for a single int value column.
   *
   * @param column column name.
   * @param inDocIds doc Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchIntValues(String column, int[] inDocIds, int inStartPos, int length, int[] outValues, int outStartPos) {
<span class="fc" id="L185">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (dictionary != null) {</span>
<span class="fc" id="L187">      int[] dictIds = THREAD_LOCAL_DICT_IDS.get();</span>
<span class="fc" id="L188">      fetchSingleDictIds(column, inDocIds, inStartPos, length, dictIds, 0);</span>
<span class="fc" id="L189">      dictionary.readIntValues(dictIds, 0, length, outValues, outStartPos);</span>
<span class="fc" id="L190">    } else {</span>
<span class="fc" id="L191">      BlockValSet blockValSet = _columnToBlockValSetMap.get(column);</span>
<span class="fc" id="L192">      blockValSet.getIntValues(inDocIds, inStartPos, length, outValues, outStartPos);</span>
    }
<span class="fc" id="L194">  }</span>

  /**
   * Fetch the int values for a multi-valued column.
   *
   * @param column column name.
   * @param inDocIds dictionary Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchIntValues(String column, int[] inDocIds, int inStartPos, int length, int[][] outValues, int outStartPos) {
<span class="fc" id="L207">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc" id="L208">    BlockMultiValIterator iterator = (BlockMultiValIterator) getBlockValIteratorForColumn(column);</span>

<span class="fc" id="L210">    int inEndPos = inStartPos + length;</span>
<span class="fc" id="L211">    int[] reusableMVDictIds = getReusableMVDictIds(_reusableMVDictIdSize);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">    for (int i = inStartPos; i &lt; inEndPos; i++, outStartPos++) {</span>
<span class="fc" id="L213">      iterator.skipTo(inDocIds[i]);</span>
<span class="fc" id="L214">      int numValues = iterator.nextIntVal(reusableMVDictIds);</span>
<span class="fc" id="L215">      outValues[outStartPos] = new int[numValues];</span>
<span class="fc" id="L216">      dictionary.readIntValues(reusableMVDictIds, 0, numValues, outValues[outStartPos], 0);</span>
    }
<span class="fc" id="L218">  }</span>

  /**
   * Fetch the values for a single long value column.
   *
   * @param column column name.
   * @param inDocIds doc Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchLongValues(String column, int[] inDocIds, int inStartPos, int length, long[] outValues, int outStartPos) {
<span class="fc" id="L231">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    if (dictionary != null) {</span>
<span class="fc" id="L233">      int[] dictIds = THREAD_LOCAL_DICT_IDS.get();</span>
<span class="fc" id="L234">      fetchSingleDictIds(column, inDocIds, inStartPos, length, dictIds, 0);</span>
<span class="fc" id="L235">      dictionary.readLongValues(dictIds, 0, length, outValues, outStartPos);</span>
<span class="fc" id="L236">    } else {</span>
<span class="fc" id="L237">      BlockValSet blockValSet = _columnToBlockValSetMap.get(column);</span>
<span class="fc" id="L238">      blockValSet.getLongValues(inDocIds, inStartPos, length, outValues, outStartPos);</span>
    }
<span class="fc" id="L240">  }</span>

  /**
   * Fetch the long values for a multi-valued column.
   *
   * @param column column name.
   * @param inDocIds dictionary Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchLongValues(String column, int[] inDocIds, int inStartPos, int length, long[][] outValues, int outStartPos) {
<span class="nc" id="L253">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="nc" id="L254">    BlockMultiValIterator iterator = (BlockMultiValIterator) getBlockValIteratorForColumn(column);</span>

<span class="nc" id="L256">    int inEndPos = inStartPos + length;</span>
<span class="nc" id="L257">    int[] reusableMVDictIds = getReusableMVDictIds(_reusableMVDictIdSize);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">    for (int i = inStartPos; i &lt; inEndPos; i++, outStartPos++) {</span>
<span class="nc" id="L259">      iterator.skipTo(inDocIds[i]);</span>
<span class="nc" id="L260">      int numValues = iterator.nextIntVal(reusableMVDictIds);</span>
<span class="nc" id="L261">      outValues[outStartPos] = new long[numValues];</span>
<span class="nc" id="L262">      dictionary.readLongValues(reusableMVDictIds, 0, numValues, outValues[outStartPos], 0);</span>
    }
<span class="nc" id="L264">  }</span>

  /**
   * Fetch the values for a single float value column.
   *
   * @param column column name.
   * @param inDocIds doc Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchFloatValues(String column, int[] inDocIds, int inStartPos, int length, float[] outValues, int outStartPos) {
<span class="fc" id="L277">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">    if (dictionary != null) {</span>
<span class="fc" id="L279">      int[] dictIds = THREAD_LOCAL_DICT_IDS.get();</span>
<span class="fc" id="L280">      fetchSingleDictIds(column, inDocIds, inStartPos, length, dictIds, 0);</span>
<span class="fc" id="L281">      dictionary.readFloatValues(dictIds, 0, length, outValues, outStartPos);</span>
<span class="fc" id="L282">    } else {</span>
<span class="fc" id="L283">      BlockValSet blockValSet = _columnToBlockValSetMap.get(column);</span>
<span class="fc" id="L284">      blockValSet.getFloatValues(inDocIds, inStartPos, length, outValues, outStartPos);</span>
    }
<span class="fc" id="L286">  }</span>

  /**
   * Fetch the float values for a multi-valued column.
   *
   * @param column column name.
   * @param inDocIds dictionary Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchFloatValues(String column, int[] inDocIds, int inStartPos, int length, float[][] outValues, int outStartPos) {
<span class="nc" id="L299">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="nc" id="L300">    BlockMultiValIterator iterator = (BlockMultiValIterator) getBlockValIteratorForColumn(column);</span>

<span class="nc" id="L302">    int inEndPos = inStartPos + length;</span>
<span class="nc" id="L303">    int[] reusableMVDictIds = getReusableMVDictIds(_reusableMVDictIdSize);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    for (int i = inStartPos; i &lt; inEndPos; i++, outStartPos++) {</span>
<span class="nc" id="L305">      iterator.skipTo(inDocIds[i]);</span>
<span class="nc" id="L306">      int numValues = iterator.nextIntVal(reusableMVDictIds);</span>
<span class="nc" id="L307">      outValues[outStartPos] = new float[numValues];</span>
<span class="nc" id="L308">      dictionary.readFloatValues(reusableMVDictIds, 0, numValues, outValues[outStartPos], 0);</span>
    }
<span class="nc" id="L310">  }</span>

  /**
   * Fetch the values for a single double value column.
   *
   * @param column column name.
   * @param inDocIds dictionary Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchDoubleValues(String column, int[] inDocIds, int inStartPos, int length, double[] outValues, int outStartPos) {
<span class="fc" id="L323">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">    if (dictionary != null) {</span>
<span class="fc" id="L325">      int[] dictIds = THREAD_LOCAL_DICT_IDS.get();</span>
<span class="fc" id="L326">      fetchSingleDictIds(column, inDocIds, inStartPos, length, dictIds, 0);</span>
<span class="fc" id="L327">      dictionary.readDoubleValues(dictIds, 0, length, outValues, outStartPos);</span>
<span class="fc" id="L328">    } else {</span>
<span class="fc" id="L329">      BlockValSet blockValSet = _columnToBlockValSetMap.get(column);</span>
<span class="fc" id="L330">      blockValSet.getDoubleValues(inDocIds, inStartPos, length, outValues, outStartPos);</span>
    }
<span class="fc" id="L332">  }</span>

  /**
   * Fetch the double values for a multi-valued column.
   *
   * @param column column name.
   * @param inDocIds dictionary Id array.
   * @param inStartPos input start position.
   * @param length input length.
   * @param outValues value array buffer.
   * @param outStartPos output start position.
   */
  public void fetchDoubleValues(String column, int[] inDocIds, int inStartPos, int length, double[][] outValues, int outStartPos) {
<span class="fc" id="L345">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc" id="L346">    BlockMultiValIterator iterator = (BlockMultiValIterator) getBlockValIteratorForColumn(column);</span>

<span class="fc" id="L348">    int inEndPos = inStartPos + length;</span>
<span class="fc" id="L349">    int[] reusableMVDictIds = getReusableMVDictIds(_reusableMVDictIdSize);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">    for (int i = inStartPos; i &lt; inEndPos; i++, outStartPos++) {</span>
<span class="fc" id="L351">      iterator.skipTo(inDocIds[i]);</span>
<span class="fc" id="L352">      int numValues = iterator.nextIntVal(reusableMVDictIds);</span>
<span class="fc" id="L353">      outValues[outStartPos] = new double[numValues];</span>
<span class="fc" id="L354">      dictionary.readDoubleValues(reusableMVDictIds, 0, numValues, outValues[outStartPos], 0);</span>
    }
<span class="fc" id="L356">  }</span>

  /**
   *
   * @param column Column for which to fetch the values
   * @param inDocIds Array of docIds for which to fetch the values
   * @param outValues Array of strings where output will be written
   * @param length Length of input docIds
   */
  public void fetchStringValues(String column, int[] inDocIds, int inStartPos, int length, String[] outValues, int outStartPos) {
<span class="fc" id="L366">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">    if (dictionary != null) {</span>
<span class="fc" id="L368">      int[] dictIds = THREAD_LOCAL_DICT_IDS.get();</span>
<span class="fc" id="L369">      fetchSingleDictIds(column, inDocIds, inStartPos, length, dictIds, 0);</span>
<span class="fc" id="L370">      dictionary.readStringValues(dictIds, 0, length, outValues, outStartPos);</span>
<span class="fc" id="L371">    } else {</span>
<span class="fc" id="L372">      BlockValSet blockValSet = _columnToBlockValSetMap.get(column);</span>
<span class="fc" id="L373">      blockValSet.getStringValues(inDocIds, inStartPos, length, outValues, outStartPos);</span>
    }
<span class="fc" id="L375">  }</span>

  /**
   *
   * @param column Column for which to fetch the values
   * @param inDocIds Array of docIds for which to fetch the values
   * @param outValues Array of strings where output will be written
   * @param length Length of input docIds
   */
  public void fetchStringValues(String column, int[] inDocIds, int inStartPos, int length, String[][] outValues, int outStartPos) {
<span class="nc" id="L385">    Dictionary dictionary = getDictionaryForColumn(column);</span>
<span class="nc" id="L386">    BlockMultiValIterator iterator = (BlockMultiValIterator) getBlockValIteratorForColumn(column);</span>

<span class="nc" id="L388">    int inEndPos = inStartPos + length;</span>
<span class="nc" id="L389">    int[] reusableMVDictIds = getReusableMVDictIds(_reusableMVDictIdSize);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">    for (int i = inStartPos; i &lt; inEndPos; i++, outStartPos++) {</span>
<span class="nc" id="L391">      iterator.skipTo(inDocIds[i]);</span>
<span class="nc" id="L392">      int numValues = iterator.nextIntVal(reusableMVDictIds);</span>
<span class="nc" id="L393">      outValues[outStartPos] = new String[numValues];</span>
<span class="nc" id="L394">      dictionary.readStringValues(reusableMVDictIds, 0, numValues, outValues[outStartPos], 0);</span>
    }
<span class="nc" id="L396">  }</span>

  /**
   * Returns the data type for the specified column.
   *
   * @param column Name of column for which to return the data type.
   * @return Data type of the column.
   */
  public FieldSpec.DataType getDataType(String column) {
<span class="fc" id="L405">    BlockMetadata blockMetadata = _columnToBlockMetadataMap.get(column);</span>
<span class="fc" id="L406">    Preconditions.checkNotNull(blockMetadata, &quot;Invalid column &quot; + column + &quot; specified in DataFetcher.&quot;);</span>
<span class="fc" id="L407">    return blockMetadata.getDataType();</span>
  }

  /**
   * Helper method that returns ThreadLocal reusable int array for MV dictionary ids.
   * If desired size is larger than existing thread local storage, the latter is expanded.
   *
   * @param size Desired size.
   * @return Thread local int array of at least desired size.
   */
  private int[] getReusableMVDictIds(int size) {
    // If current size is not large enough, expand to new size.
<span class="fc" id="L419">    int[] reusableMVDictIds = THREAD_LOCAL_MV_DICT_IDS.get();</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (reusableMVDictIds.length &lt; size) {</span>
<span class="fc" id="L422">      reusableMVDictIds = new int[size];</span>
<span class="fc" id="L423">      THREAD_LOCAL_MV_DICT_IDS.set(reusableMVDictIds);</span>
    }
<span class="fc" id="L425">    return reusableMVDictIds;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>