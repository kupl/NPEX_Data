{
    "stanbol_19ee985": {
        "bug_id": "stanbol_19ee985",
        "commit": "https://github.com/apache/stanbol/commit/19ee9852de93cd24523219d35912662bd6fbf2e3",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/19ee9852de93cd24523219d35912662bd6fbf2e3/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java?ref=19ee9852de93cd24523219d35912662bd6fbf2e3",
                "deletions": 4,
                "filename": "entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "patch": "@@ -354,15 +354,12 @@ public final Representation update(Representation representation) throws Illegal\n         return added;\n     }\n     protected final Representation store(Representation representation,boolean allowCreate,boolean canNotCreateIsError) throws IllegalArgumentException, YardException{\n-        log.info(\"store Representation \"+representation.getId());\n-//        log.info(\"  > entityhub size: \"+graph.size());\n         if(representation == null) {\n             return null;\n         }\n+        log.info(\"store Representation \" + representation.getId());\n         if(isRepresentation(representation.getId())){\n-//            log.info(\"  > remove previous version\");\n             remove(representation.getId());\n-//            log.info(\"  > entityhub size: \"+graph.size());\n         } else if(!allowCreate){\n             if(canNotCreateIsError) {\n                 throw new IllegalArgumentException(\"Parsed Representation \"+representation.getId()+\" in not managed by this Yard \"+getName()+\"(id=\"+getId()+\")\");",
                "raw_url": "https://github.com/apache/stanbol/raw/19ee9852de93cd24523219d35912662bd6fbf2e3/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "sha": "517ea4b5953f05189cbc7ab571e1451b60a2a29c",
                "status": "modified"
            }
        ],
        "message": "fixed potential NPE in ClerezzaYard\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/stanbol/trunk@1102376 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/05c58f6db2d856f0ce5d8c8ea7591c3db4da630d",
        "patched_files": [
            "ClerezzaYard.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "ClerezzaYardTest.java"
        ]
    },
    "stanbol_2175e9b": {
        "bug_id": "stanbol_2175e9b",
        "commit": "https://github.com/apache/stanbol/commit/2175e9bc140fae59d0898c30056938b8dcc2c36d",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/pom.xml",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/pom.xml?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/generic/core/pom.xml",
                "patch": "@@ -134,6 +134,12 @@\n       <version>1.4.0</version>\n     </dependency>\n     <!-- for tests -->\n+    <dependency>\n+      <groupId>eu.iksproject</groupId>\n+      <artifactId>eu.iksproject.rick.test</artifactId>\n+      <version>0.1-SNAPSHOT</version>\n+      <scope>test</scope>\n+    </dependency>\n     <dependency>\n       <groupId>junit</groupId>\n       <artifactId>junit</artifactId>",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/pom.xml",
                "sha": "53db1f2e9763f6ae543f78c7705a409edeb75d96",
                "status": "modified"
            },
            {
                "additions": 88,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryRepresentation.java",
                "changes": 113,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryRepresentation.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 25,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryRepresentation.java",
                "patch": "@@ -30,14 +30,25 @@\n     protected final Map<String,Object> representation;\n     protected final Map<String,Object> unmodRepresentation;\n     private final String id;\n-\n-    public InMemoryRepresentation(String id){\n+    /**\n+     * creates a new InMemoryRepresentation for the parsed ID\n+     * @param id the id of the representation\n+     */\n+    protected InMemoryRepresentation(String id){\n         this(id,null);\n     }\n     /**\n-     * Initialise a new InMemoryRepresenation that contains already some data.\n-     * @param id\n-     * @param representation\n+     * Initialise a new InMemoryRepresenation with the parsed map. Note that the\n+     * parsed map is directly used to store the data. That means that callers\n+     * MUST keep in minds that changes to that map will influence the internal\n+     * state of this instance.<br>\n+     * The intension of this constructor is to allow also to define the actual\n+     * map implementation used to store the data.\n+     * If one also wants to directly parse data already contained within an\n+     * other representation one MUST first create deep copy of the according\n+     * map!\n+     * @param id the id for the Representation\n+     * @param representation the map used by this representation to store it's data\n      */\n     protected InMemoryRepresentation(String id, Map<String,Object> representation){\n         if(id == null){\n@@ -54,11 +65,14 @@ protected InMemoryRepresentation(String id, Map<String,Object> representation){\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public void add(String field, Object parsedValue) {\n-        //TODO:add processing of values\n-        // URI, URL -> Reference\n-        // String[] -> Text\n-        // check Collections!\n-        // The rest should be added as Objects\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n+        if(parsedValue == null){\n+            throw new IllegalArgumentException(\"NULL values are not supported by Representations\");\n+        }\n         Collection<Object> newValues = new ArrayList<Object>();\n         ModelUtils.checkValues(valueFactory, parsedValue, newValues);\n         Object values = representation.get(field);\n@@ -81,12 +95,12 @@ public void add(String field, Object parsedValue) {\n             representation.put(field, newValues.size() == 1?newValues.iterator().next():newValues);\n         }\n     }\n-    protected void addValues(String field,Collection<Object> values){\n-\n-    }\n \n     @Override\n     public void addNaturalText(String field, String text, String... languages) {\n+        if(text == null){\n+            throw new IllegalArgumentException(\"NULL was parsed for the text! NULL values are not supported by Representations\");\n+        }\n         if(languages == null || languages.length<1){ //if no language is parse add the default lanugage!\n             add(field,valueFactory.createText(text, null));\n         } else {\n@@ -98,6 +112,9 @@ public void addNaturalText(String field, String text, String... languages) {\n \n     @Override\n     public void addReference(String field, String reference) {\n+        if(reference == null){\n+            throw new IllegalArgumentException(\"NULL values are not supported by Representations\");\n+        }\n         add(field, valueFactory.createReference(reference));\n     }\n     /**\n@@ -108,6 +125,11 @@ public void addReference(String field, String reference) {\n      */\n     @SuppressWarnings(\"unchecked\")\n     private Collection<Object> getValuesAsCollection(String field){\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         Object value = representation.get(field);\n         if(value == null){\n             return Collections.emptySet();\n@@ -125,6 +147,11 @@ public void addReference(String field, String reference) {\n \n     @Override\n     public Iterator<Object> get(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         return getValuesAsCollection(field).iterator();\n     }\n     @Override\n@@ -169,29 +196,53 @@ public String getId() {\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public void remove(String field, Object value) {\n+    public void remove(String field, Object parsedValue) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n+        Collection<Object> removeValues = new ArrayList<Object>();\n+        ModelUtils.checkValues(valueFactory, parsedValue, removeValues);\n         Object values = representation.get(field);\n-        if(values == null) return;\n-        if(value.equals(value)){\n+        if(values == null) {\n+            return;\n+        } else if(removeValues.contains(values)){\n+            //in case this field has a single value and this values is part of\n+            //the values to remove -> remove the whole field\n             representation.remove(field);\n         } else if(values instanceof Collection<?>){\n-            if(((Collection<Object>)values).remove(value) && //remove the Element\n+            if(((Collection<Object>)values).removeAll(removeValues) && //remove all Elements\n                     ((Collection<Object>)values).size()<2){ //if removed check for size\n-                //it only one element remaining -> replace the collection with a Object\n-                representation.put(field, ((Collection<Object>)values).iterator().next());\n+                if(((Collection<Object>)values).size()==1){\n+                    //only one element remaining -> replace the collection with a Object\n+                    representation.put(field, ((Collection<Object>)values).iterator().next());\n+                } else {\n+                    //if no element remains, remove the field\n+                    representation.remove(field);\n+                }\n             }\n-\n-        } //else ignore\n+        } //else ignore (single value for field && value not to be removed)\n     }\n \n     @Override\n     public void removeAll(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         representation.remove(field);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public void removeAllNaturalText(String field, String... languages) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         Object values = representation.get(field);\n         if(values == null) return;\n         if(values instanceof Collection<?>){\n@@ -220,6 +271,11 @@ public void removeAllNaturalText(String field, String... languages) {\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public void removeNaturalText(String field, String text, String... languages) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         Object values = representation.get(field);\n         if(values == null) return;\n         if(values instanceof Collection<?>){\n@@ -259,8 +315,15 @@ public void removeReference(String field, String reference) {\n \n     @Override\n     public void set(String field, Object value) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         representation.remove(field);\n-        add(field,value);\n+        if(value != null){\n+            add(field,value);\n+        }\n \n     }\n \n@@ -307,7 +370,7 @@ public Reference getFirstReference(String field) {\n         Collection<Object> values = getValuesAsCollection(field);\n         return new TypeSaveIterator<Reference>(values.iterator(), Reference.class);\n     }\n-    private static String getNaturalLanguageValue(Object check,Set<String> langSet,boolean isNullLanguage){\n+    protected static String getNaturalLanguageValue(Object check,Set<String> langSet,boolean isNullLanguage){\n         if(check instanceof Text){\n             Text text = (Text)check;\n             if(langSet == null || langSet.contains(text.getLanguage())){\n@@ -318,7 +381,7 @@ private static String getNaturalLanguageValue(Object check,Set<String> langSet,b\n         } //type does not fit -> ignore\n         return null; //no label found\n     }\n-    public static String getNaturalLanguageValue(Object check,String...languages){\n+    protected static String getNaturalLanguageValue(Object check,String...languages){\n         Set<String> langSet;\n         boolean isNullLanguage;\n         if(languages != null && languages.length>1){\n@@ -335,7 +398,7 @@ public static String getNaturalLanguageValue(Object check,String...languages){\n      * @param languages\n      * @return\n      */\n-    public static boolean isNaturalLanguageValue(Object check,String...languages){\n+    protected static boolean isNaturalLanguageValue(Object check,String...languages){\n         return getNaturalLanguageValue(check,languages) != null;\n     }\n     @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryRepresentation.java",
                "sha": "31d8001a0be1fc754c86519403c5892eb829f71d",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryValueFactory.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryValueFactory.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 9,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryValueFactory.java",
                "patch": "@@ -24,15 +24,15 @@ protected InMemoryValueFactory(){\n     @Override\n     public Reference createReference(Object value) {\n         if(value == null){\n-            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n+            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n         }\n         return new ReferenceImpl(value.toString());\n     }\n \n     @Override\n     public Text createText(Object value) {\n         if(value == null){\n-            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n+            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n         }\n         return createText(value.toString(),null);\n     }\n@@ -91,13 +91,13 @@ public ReferenceImpl clone() throws CloneNotSupportedException {\n \n         private final String value;\n         private final String language;\n-        protected TextImpl(String value) {\n+        protected TextImpl(String value) throws NullPointerException {\n             this(value,null);\n         }\n-        protected TextImpl(String value, String language) {\n+        protected TextImpl(String value, String language) throws NullPointerException {\n             super();\n             if(value == null){\n-                throw new IllegalArgumentException(\"The value of the Text MUST NOT be NULL!\");\n+                throw new NullPointerException(\"The value of the Text MUST NOT be NULL!\");\n             }\n             this.value = value;\n             this.language = language;\n@@ -135,10 +135,12 @@ protected Object clone() throws CloneNotSupportedException {\n     }\n     @Override\n     public Representation createRepresentation(String id) {\n-        if(id != null){\n-            return new InMemoryRepresentation(id);\n-        } else {\n-            throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL\");\n+        if (id == null){\n+            throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+         } else if(id.isEmpty()){\n+             throw new IllegalArgumentException(\"The parsed id MUST NOT be empty!\");\n+         } else {\n+             return new InMemoryRepresentation(id);\n         }\n     }\n //    @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/model/InMemoryValueFactory.java",
                "sha": "c4c0bce9add147257d4603a8190d95e1da8baf3e",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/site/CacheImpl.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/site/CacheImpl.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 3,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/site/CacheImpl.java",
                "patch": "@@ -8,14 +8,11 @@\n import org.apache.felix.scr.annotations.Properties;\n import org.apache.felix.scr.annotations.Property;\n import org.apache.felix.scr.annotations.Service;\n-import org.osgi.framework.BundleContext;\n import org.osgi.framework.Constants;\n import org.osgi.framework.InvalidSyntaxException;\n-import org.osgi.framework.ServiceReference;\n import org.osgi.service.cm.ConfigurationException;\n import org.osgi.service.component.ComponentContext;\n import org.osgi.util.tracker.ServiceTracker;\n-import org.osgi.util.tracker.ServiceTrackerCustomizer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/site/CacheImpl.java",
                "sha": "c4bdbde11290025f30d14136e375dba8d9e126ec",
                "status": "modified"
            },
            {
                "additions": 63,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/AdaptingIterator.java",
                "changes": 73,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/AdaptingIterator.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 10,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/AdaptingIterator.java",
                "patch": "@@ -1,10 +1,26 @@\n package eu.iksproject.rick.core.utils;\n \n import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n /**\n  * Uses the parsed Adapter to convert values of type T to values of type\n  * A. If an instance of T can not be converted to A, than such values are\n- * filtered in the Iteration.\n+ * filtered. This means that this implementation can be used for both filtering\n+ * and converting of values of the base iterator. In fact the \n+ * FilteringIterator is implemented based on this class.<p>\n+ * Note that {@link Iterator#remove()} only works as long as \n+ * {@link Iterator#hasNext()} was not called to determine if there are\n+ * further elements. The reason for that is, that in order to filter elements\n+ * of the parent iterator {@link Iterator#next()} has to be called to check\n+ * weather any further element is valid against the used Filter.\n+ * This call to {@link Iterator#next()} causes the parent Iterator to switch\n+ * to the next element, meaning that after that the <code>remove()</code>\n+ * method would delete a different element. To avoid that this Iterator\n+ * throws an {@link IllegalStateException} in such cases. If the parent\n+ * Iterator does not support <code>remove()</code> at all an\n+ * {@link UnsupportedOperationException} is thrown. <p>\n+ * \n  * @author Rupert Westenthaler\n  *\n  * @param <T> The type of the incoming elements\n@@ -13,8 +29,10 @@\n public class AdaptingIterator<T,A> implements Iterator<A> {\n \n     /**\n-     * Adapts values of type T to values of type A.\n-     * @author westei\n+     * Adapts values of type T to values of type A. <code>null</code> indicated\n+     * that the adaption is not possible for the current value of T\n+     * \n+     * @author Rupert Westenthaler\n      *\n      * @param <T>\n      * @param <A>\n@@ -30,10 +48,12 @@\n          */\n         A adapt(T value, Class<A> type);\n     }\n+    \n     protected final Adapter<T, A> adapter;\n     protected final Iterator<T> it;\n     protected final Class<A> type;\n     private A next;\n+    private Boolean hasNext;\n     /**\n      * Constructs an instance based on an iterator of type T, an adapter and the\n      * target type\n@@ -54,23 +74,56 @@ public AdaptingIterator(Iterator<T> it,Adapter<T,A> adapter,Class<A> type){\n         this.it = it;\n         this.adapter = adapter;\n         this.type = type;\n-        //init next\n-        next = prepareNext();\n     }\n     @Override\n     public final boolean hasNext() {\n-        return next != null;\n+        if(hasNext == null){ // only once even with multiple calls\n+            next = prepareNext();\n+            hasNext = next != null;\n+        }\n+        return hasNext;\n     }\n \n     @Override\n     public final A next() {\n-        A current = next;\n-        next = prepareNext();\n-        return current;\n+        hasNext(); //call hasNext (to init next Element if not already done)\n+        if(!hasNext){\n+            throw new NoSuchElementException();\n+        } else {\n+            A current = next;\n+            next = null;\n+            hasNext = null;\n+            return current;\n+        }\n     }\n-\n+    /**\n+     * This implementation of remove does have an additional restriction. It\n+     * is only able to remove the current element of the parent Iterator (parsed\n+     * in the constructor) if {@link #hasNext()} was not yet called. This is\n+     * because {@link #hasNext()} needs to call {@link Iterator#next()} on the\n+     * parent iterator to check if there are further elements that can be\n+     * adapted successfully. This causes that the current element of this\n+     * Iterator (stored in an local variable) is no longer the current element\n+     * of the parent iterator and therefore calls to {@link #remove()} would\n+     * delete an other object within the collection holding the elements used\n+     * for this iteration. To prevent this this method throws an\n+     * {@link IllegalStateException} ins such cases. Users of this method need\n+     * therefore to ensure, that there are no calls to remove between a call\n+     * to {@link #hasNext()} and {@link #next()} (what is not the case in\n+     * typical use cases).\n+     * @see Iterator#remove()\n+     */\n     @Override\n     public final void remove() {\n+        /*\n+         * TODO: See java doc for a detailed description! \n+         * If someone has a better Idea how to solve this please let me know!\n+         * all the best \n+         * Rupert Westenthaler\n+         */\n+        if(hasNext!= null){\n+            throw new IllegalStateException(\"Remove can not be called after calling hasNext()! See java doc for more information.\");\n+        }\n         it.remove();\n     }\n     protected A prepareNext(){",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/AdaptingIterator.java",
                "sha": "c1f047e83933909f4c657b6609a29336060d0ceb",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/c4b216b0b4c46b1083c8ef923a5094fd3273dad2/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/EnumIterator.java",
                "changes": 50,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/EnumIterator.java?ref=c4b216b0b4c46b1083c8ef923a5094fd3273dad2",
                "deletions": 50,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/EnumIterator.java",
                "patch": "@@ -1,50 +0,0 @@\n-package eu.iksproject.rick.core.utils;\n-\n-import java.util.Iterator;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class EnumIterator<T extends Enum<T>> implements Iterator<T> {\n-\n-    private static final Logger log = LoggerFactory.getLogger(EnumIterator.class);\n-\n-    protected final Iterator<String> it;\n-    protected final Class<T> type;\n-    private T next;\n-    public EnumIterator(Iterator<String> it,Class<T> enumClass) {\n-        this.it = it;\n-        this.type = enumClass;\n-        //init the first value\n-        this.next = prepareNext();\n-    }\n-    @Override\n-    public boolean hasNext() {\n-        return next != null;\n-    }\n-\n-    @Override\n-    public T next() {\n-        T current = next;\n-        next = prepareNext();\n-        return current;\n-    }\n-\n-    @Override\n-    public void remove() {\n-        it.remove();\n-    }\n-    protected T prepareNext(){\n-        while(it.hasNext()){\n-            String currentString = it.next();\n-            try {\n-                return Enum.valueOf(type, currentString);\n-            } catch(IllegalArgumentException e){\n-                //ignore\n-                log.debug(\"Value \"+currentString+\" not part of enumeration \"+type+\" -> filter value\",e);\n-            }\n-        }\n-        return null;\n-    }\n-\n-}",
                "raw_url": "https://github.com/apache/stanbol/raw/c4b216b0b4c46b1083c8ef923a5094fd3273dad2/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/EnumIterator.java",
                "sha": "d08f4266815dcf9c578d4f350c6433c6fb9eceb6",
                "status": "removed"
            },
            {
                "additions": 64,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/FilteringIterator.java",
                "changes": 64,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/FilteringIterator.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/FilteringIterator.java",
                "patch": "@@ -0,0 +1,64 @@\n+package eu.iksproject.rick.core.utils;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Implementation of an Iterator that iterates over a filtered set of elements\n+ * of its parent Iterator.<p>\n+ * Note that {@link Iterator#remove()} only works as long as \n+ * {@link Iterator#hasNext()} was not called to determine if there are\n+ * further elements. The reason for that is, that in order to filter elements\n+ * of the parent iterator {@link Iterator#next()} has to be called to check\n+ * weather any further element is valid against the used {@link Filter}.\n+ * This call to {@link Iterator#next()} causes the parent Iterator to switch\n+ * to the next element, meaning that after that the <code>remove()</code>\n+ * method would delete a different element. To avoid that this Iterator\n+ * throws an {@link IllegalStateException} in such cases. If the parent\n+ * Iterator does not support <code>remove()</code> at all an\n+ * {@link UnsupportedOperationException} is thrown. <p>\n+ * This implementation is based on the {@link AdaptingIterator} to avoid\n+ * duplication of the filtering functionality also needed if an adapter can not\n+ * convert a specific value of one type to an other. \n+ * \n+ * @author Rupert Westenthaler\n+ *\n+ * @param <T> the type of the elements\n+ */\n+public class FilteringIterator<T> extends AdaptingIterator<T,T>{\n+    /**\n+     * Interface used by the {@link FilteringIterator} to check if an element\n+     * of the parent Iterator should be filtered or not. If {@link #isValid(Object)}\n+     * returns true the element of the parent iterator is also returned by this\n+     * Iterator. Otherwise the element is filtered.<p>\n+\n+     * @author Rupert Westenthaler\n+     *\n+     * @param <T>\n+     */\n+    public static interface Filter<T> {\n+        boolean isValid(T value);\n+    }\n+    public FilteringIterator(Iterator<T> iterator,Filter<T> filter,Class<T> type) {\n+        super(iterator,new FilterAdapter<T>(filter),type);\n+    }\n+    \n+    private static class FilterAdapter<A> implements Adapter<A,A> {\n+\n+        private Filter<A> filter;\n+        public FilterAdapter(Filter<A> filter) {\n+            if(filter == null){\n+                throw new NullPointerException(\"The parsed Filter MUST NOT be NULL!\");\n+            }\n+            this.filter = filter;\n+        }\n+        @Override\n+        public A adapt(A value, Class<A> type) {\n+            if(filter.isValid(value)){\n+                return value;\n+            } else {\n+                return null;\n+            }\n+        }\n+        \n+    }\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/FilteringIterator.java",
                "sha": "b4d57c2b03b93d720dc775f51e54121f73173930",
                "status": "added"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ModelUtils.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ModelUtils.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 2,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ModelUtils.java",
                "patch": "@@ -3,6 +3,7 @@\n import java.net.URI;\n import java.net.URL;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n@@ -95,6 +96,7 @@ public static void setSeed(long seed) {\n      * Processes a value parsed as object to the representation.\n      * This processing includes:\n      * <ul>\n+     * <li> Removal of <code>null</code> values\n      * <li> Converting URIs and URLs to {@link Reference}\n      * <li> Converting String[] with at least a single entry where the first\n      * entry is not null to {@link Text} (the second entry is used as language.\n@@ -103,11 +105,16 @@ public static void setSeed(long seed) {\n      *      {@link Collection}), {@link Iterator} or {@link Enumeration} is parsed.\n      * <li> All other Objects are added to the result list\n      * </ul>\n+     * TODO: Maybe we need to enable an option to throw {@link IllegalArgumentException}\n+     * in case any of the parsed values is invalid. Currently invalid values are\n+     * just ignored.\n      * @param value the value to parse\n      * @param results the collections the results of the parsing are added to.\n      */\n     public static void checkValues(ValueFactory valueFactory, Object value,Collection<Object> results){\n-        if(value instanceof Iterable<?>){\n+        if(value == null){\n+            return;\n+        } else if(value instanceof Iterable<?>){\n             for(Object current : (Iterable<?>)value){\n                 checkValues(valueFactory,current,results);\n             }\n@@ -126,7 +133,7 @@ public static void checkValues(ValueFactory valueFactory, Object value,Collectio\n                 results.add(valueFactory.createText(((String[])value)[0],\n                         ((String[])value).length>1?((String[])value)[1]:null));\n             } else {\n-                log.warn(\"String[] \"+value+\" is not a valied natural language array! -> ignore value\");\n+                log.warn(\"String[] \"+Arrays.toString((String[])value)+\" is not a valied natural language array! -> ignore value\");\n             }\n         } else {\n             results.add(value);",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ModelUtils.java",
                "sha": "edd06456fc22a57b7b7dfb6819901ddf9c2bb49d",
                "status": "modified"
            },
            {
                "additions": 62,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/OsgiUtils.java",
                "changes": 135,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/OsgiUtils.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 73,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/OsgiUtils.java",
                "patch": "@@ -9,18 +9,7 @@\n import java.util.Hashtable;\n \n import org.osgi.framework.Constants;\n-import org.osgi.framework.InvalidSyntaxException;\n-import org.osgi.framework.ServiceReference;\n import org.osgi.service.cm.ConfigurationException;\n-import org.osgi.service.component.ComponentContext;\n-import org.osgi.service.component.ComponentFactory;\n-import org.osgi.service.component.ComponentInstance;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import eu.iksproject.rick.servicesapi.site.ConfiguredSite;\n-import eu.iksproject.rick.servicesapi.site.EntityDereferencer;\n-import eu.iksproject.rick.servicesapi.site.ReferencedSite;\n \n /**\n  * This class contains some utilities for osgi\n@@ -30,7 +19,7 @@\n  */\n public final class OsgiUtils {\n \n-    private static final Logger log = LoggerFactory.getLogger(OsgiUtils.class);\n+    //private static final Logger log = LoggerFactory.getLogger(OsgiUtils.class);\n \n     private OsgiUtils() {/* do not create instances of utility classes*/}\n \n@@ -113,67 +102,67 @@ public final static URL checkUrlProperty(Dictionary<?, ?> properties,String prop\n             throw new ConfigurationException(propertyName,String.format(\"Property value %s is not a member of Enumeration %s!\",value,enumeration.getName()), e);\n         }\n     }\n-    /**\n-     * search for a {@link ComponentFactory} that has the component.name property\n-     * as configured by {@link ConfiguredSite#DEREFERENCER_TYPE}. Than creates\n-     * an new instance of an {@link EntityDereferencer} and configures it with\n-     * all the properties present for this instance of {@link ReferencedSite} (\n-     * only component.* and service.* properties are ignored).<br>\n-     * The {@link ComponentInstance} and the {@link EntityDereferencer} are\n-     * stored in the according memeber variables.\n-     * @return the ComponentInstance of <code>null</code> if no ComponentFactory\n-     *    was found for the parsed componentService\n-     * @throws ConfigurationException if the {@link ConfiguredSite#DEREFERENCER_TYPE}\n-     * is not present or it's value does not allow to create a {@link EntityDereferencer}\n-     * instance.\n-     */\n-    public static ComponentInstance createComonentInstance(ComponentContext context, String property,Object componentName,Class<?> componentService) throws ConfigurationException {\n-        //Object value = checkProperty(DEREFERENCER_TYPE);\n-        final ServiceReference[] refs;\n-        try {\n-            refs = context.getBundleContext().getServiceReferences(\n-                    ComponentFactory.class.getName(),\n-                    \"(component.name=\"+componentName+\")\");\n-\n-        } catch (InvalidSyntaxException e) {\n-            throw new ConfigurationException(property, \"Unable to get ComponentFactory for parsed value \"+componentName.toString(),e);\n-        }\n-        if(refs != null && refs.length>0){\n-            if(refs.length>1){ //log some warning if more than one Service Reference was found by the query!\n-                log.warn(\"Multiple ComponentFactories found for the property \"+property+\"=\"+componentName+\"! -> First one was used to instantiate the \"+componentService+\" Service\");\n-            }\n-            Object dereferencerFactorySerivceObject = context.getBundleContext().getService(refs[0]);\n-            if(dereferencerFactorySerivceObject != null){\n-                try {\n-                    // I trust the OSGI framework, that the returned service implements the requested Interface\n-                    ComponentFactory dereferencerFactory = (ComponentFactory)dereferencerFactorySerivceObject;\n-                    //log.debug(\"build configuration for \"+EntityDereferencer.class.getSimpleName()+\" \"+componentName.toString());\n-                    Dictionary<String, Object> config = copyConfig(context.getProperties());\n-                    ComponentInstance dereferencerComponentInstance = dereferencerFactory.newInstance(config);\n-                    dereferencerFactory = null;\n-                    //now\n-                    if(dereferencerComponentInstance == null){\n-                        throw new IllegalStateException(\"Unable to create ComponentInstance for Property value \"+componentName+\"!\");\n-                    }\n-                    if(componentService.isAssignableFrom(dereferencerComponentInstance.getInstance().getClass())){\n-                        return dereferencerComponentInstance;\n-                    } else {\n-                        dereferencerComponentInstance.dispose(); //we can not use it -> so dispose it!\n-                        dereferencerComponentInstance = null;\n-                        throw new IllegalStateException(\"ComponentInstance created for Property value \"+componentName+\" does not provide the \"+componentService+\" Service!\");\n-                    }\n-                } finally {\n-                    //we need to unget the ComponentFactory!\n-                    context.getBundleContext().ungetService(refs[0]);\n-                    dereferencerFactorySerivceObject=null;\n-                }\n-            } else {\n-                return null;\n-            }\n-        } else {\n-            return null;\n-        }\n-    }\n+//    /**\n+//     * search for a {@link ComponentFactory} that has the component.name property\n+//     * as configured by {@link ConfiguredSite#DEREFERENCER_TYPE}. Than creates\n+//     * an new instance of an {@link EntityDereferencer} and configures it with\n+//     * all the properties present for this instance of {@link ReferencedSite} (\n+//     * only component.* and service.* properties are ignored).<br>\n+//     * The {@link ComponentInstance} and the {@link EntityDereferencer} are\n+//     * stored in the according memeber variables.\n+//     * @return the ComponentInstance of <code>null</code> if no ComponentFactory\n+//     *    was found for the parsed componentService\n+//     * @throws ConfigurationException if the {@link ConfiguredSite#DEREFERENCER_TYPE}\n+//     * is not present or it's value does not allow to create a {@link EntityDereferencer}\n+//     * instance.\n+//     */\n+//    public static ComponentInstance createComonentInstance(ComponentContext context, String property,Object componentName,Class<?> componentService) throws ConfigurationException {\n+//        //Object value = checkProperty(DEREFERENCER_TYPE);\n+//        final ServiceReference[] refs;\n+//        try {\n+//            refs = context.getBundleContext().getServiceReferences(\n+//                    ComponentFactory.class.getName(),\n+//                    \"(component.name=\"+componentName+\")\");\n+//\n+//        } catch (InvalidSyntaxException e) {\n+//            throw new ConfigurationException(property, \"Unable to get ComponentFactory for parsed value \"+componentName.toString(),e);\n+//        }\n+//        if(refs != null && refs.length>0){\n+//            if(refs.length>1){ //log some warning if more than one Service Reference was found by the query!\n+//                log.warn(\"Multiple ComponentFactories found for the property \"+property+\"=\"+componentName+\"! -> First one was used to instantiate the \"+componentService+\" Service\");\n+//            }\n+//            Object dereferencerFactorySerivceObject = context.getBundleContext().getService(refs[0]);\n+//            if(dereferencerFactorySerivceObject != null){\n+//                try {\n+//                    // I trust the OSGI framework, that the returned service implements the requested Interface\n+//                    ComponentFactory dereferencerFactory = (ComponentFactory)dereferencerFactorySerivceObject;\n+//                    //log.debug(\"build configuration for \"+EntityDereferencer.class.getSimpleName()+\" \"+componentName.toString());\n+//                    Dictionary<String, Object> config = copyConfig(context.getProperties());\n+//                    ComponentInstance dereferencerComponentInstance = dereferencerFactory.newInstance(config);\n+//                    dereferencerFactory = null;\n+//                    //now\n+//                    if(dereferencerComponentInstance == null){\n+//                        throw new IllegalStateException(\"Unable to create ComponentInstance for Property value \"+componentName+\"!\");\n+//                    }\n+//                    if(componentService.isAssignableFrom(dereferencerComponentInstance.getInstance().getClass())){\n+//                        return dereferencerComponentInstance;\n+//                    } else {\n+//                        dereferencerComponentInstance.dispose(); //we can not use it -> so dispose it!\n+//                        dereferencerComponentInstance = null;\n+//                        throw new IllegalStateException(\"ComponentInstance created for Property value \"+componentName+\" does not provide the \"+componentService+\" Service!\");\n+//                    }\n+//                } finally {\n+//                    //we need to unget the ComponentFactory!\n+//                    context.getBundleContext().ungetService(refs[0]);\n+//                    dereferencerFactorySerivceObject=null;\n+//                }\n+//            } else {\n+//                return null;\n+//            }\n+//        } else {\n+//            return null;\n+//        }\n+//    }\n \n     /**\n      * Copy all properties excluding \"{@value Constants#OBJECTCLASS}\",",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/OsgiUtils.java",
                "sha": "f059861ff0f2aeff86d55e775ff81b2d71f88541",
                "status": "modified"
            },
            {
                "additions": 119,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TextIterator.java",
                "changes": 169,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TextIterator.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 50,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TextIterator.java",
                "patch": "@@ -9,12 +9,13 @@\n import eu.iksproject.rick.servicesapi.model.Text;\n import eu.iksproject.rick.servicesapi.model.ValueFactory;\n \n-public class TextIterator implements Iterator<Text> {\n-    protected final Iterator<?> it;\n-    private Text next;\n-    protected final Set<String> languages;\n-    private final boolean isNullLanguage;\n-    protected final ValueFactory valueFactory;\n+public class TextIterator extends AdaptingIterator<Object,Text> implements Iterator<Text> {\n+//    protected final Iterator<?> it;\n+//    private Text next;\n+//    private Boolean hasNext;\n+//    protected final Set<String> languages;\n+//    private final boolean isNullLanguage;\n+//    protected final ValueFactory valueFactory;\n     /**\n      * Creates an instance that iterates over values and returns {@link Text}\n      * instances that confirm to the active languages. If no languages are parsed\n@@ -25,55 +26,123 @@\n      * @param languages The active languages or no values to accept all languages\n      */\n     public TextIterator(ValueFactory valueFactory,Iterator<Object> it,String...languages){\n-        if(it == null){\n-            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n-        }\n-        if(valueFactory == null){\n-            throw new IllegalArgumentException(\"Parsed ValueFactory MUST NOT be NULL!\");\n-        }\n-        this.it = it;\n-        this.valueFactory = valueFactory;\n-        if(languages != null && languages.length>0){\n-            this.languages = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(languages)));\n-            isNullLanguage = this.languages.contains(null);\n-        } else {\n-            this.languages = null;\n-            isNullLanguage = true;\n-        }\n-        //init next ...\n-        next = prepareNext();\n-    }\n-    @Override\n-    public final void remove() {\n-        it.remove();\n-\n-    }\n-\n-    @Override\n-    public final Text next() {\n-        Text current = next;\n-        next = prepareNext();\n-        return current;\n+        super(it,new TextAdapter(valueFactory, languages),Text.class);\n+//        if(it == null){\n+//            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n+//        }\n+//        this.it = it;\n+//        if(valueFactory == null){\n+//            throw new IllegalArgumentException(\"Parsed ValueFactory MUST NOT be NULL!\");\n+//        }\n+//        this.valueFactory = valueFactory;\n+//        if(languages != null && languages.length>0){\n+//            this.languages = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(languages)));\n+//            isNullLanguage = this.languages.contains(null);\n+//        } else {\n+//            this.languages = null;\n+//            isNullLanguage = true;\n+//        }\n     }\n+    private static class TextAdapter implements Adapter<Object,Text>{\n+        protected final Set<String> languages;\n+        private final boolean isNullLanguage;\n+        protected final ValueFactory valueFactory;\n+        \n+        public TextAdapter(ValueFactory valueFactory,String...languages) {\n+            if(valueFactory == null){\n+                throw new IllegalArgumentException(\"Parsed ValueFactory MUST NOT be NULL!\");\n+            }\n+            this.valueFactory = valueFactory;\n+            if(languages != null && languages.length>0){\n+                this.languages = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(languages)));\n+                isNullLanguage = this.languages.contains(null);\n+            } else {\n+                this.languages = null;\n+                isNullLanguage = true;\n+            }\n+            \n+        }\n \n-    @Override\n-    public final boolean hasNext() {\n-        return next != null;\n-    }\n-    protected Text prepareNext(){\n-        Object check;\n-        while(it.hasNext()){\n-            check = it.next();\n-            if(check instanceof Text){\n-                Text text = (Text)check;\n+        @Override\n+        public Text adapt(Object value, Class<Text> type) {\n+            if(value instanceof Text){\n+                Text text = (Text)value;\n                 if(languages == null || languages.contains(text.getLanguage())){\n                     return text;\n+                } else { //language does not fit -> filter\n+                    return null;\n                 }\n-            } else if(isNullLanguage && check instanceof String){\n-                return valueFactory.createText((String)check);\n-            } //type does not fit -> ignore\n+            } else if(isNullLanguage && value instanceof String){\n+                return valueFactory.createText((String)value);\n+            }  else {//type does not fit -> filter\n+                return null;\n+            }\n         }\n-        //no more element and still nothing found ... return end of iteration\n-        return null;\n+        \n     }\n+//    @Override\n+//    public final void remove() {\n+//        /*\n+//         * TODO: Any Iterator that filters elements of the underlying Iterator\n+//         * needs to call Iterator#next() in the underlying Iterator to get the\n+//         * next element that confirms with the filter.\n+//         * However the Iterator#remove() is defined as removing the last element\n+//         * to be returned by Iterator#next(). Therefore calling hasNext would\n+//         * change the element to be removed by this method.\n+//         * Currently I do not know a way around that but I would also like to\n+//         * keep the remove functionality for Iterator that filter elements of an\n+//         * underlying Iterator. To prevent unpredictable behaviour in such cases \n+//         * I throw an IllegalStateException in such cases.\n+//         * This decision assumes, that in most usage scenarios hasNext will not\n+//         * likely be called before calling remove and even in such cases\n+//         * it will be most likely be possible to refactor the code to confirm\n+//         * with this restriction.\n+//         * I hope this will help developers that encounter this exception to\n+//         * modify there code!\n+//         * If someone has a better Idea how to solve this please let me know!\n+//         * best \n+//         * Rupert Westenthaler\n+//         */\n+//        if(hasNext!= null){\n+//            throw new IllegalStateException(\"Remove can not be called after calling hasNext() because this Method needs to call next() on the underlying Interator and therefore would change the element to be removed :(\");\n+//        }\n+//        it.remove();\n+//    }\n+//\n+//    @Override\n+//    public final Text next() {\n+//        hasNext(); //call hasNext (to init next Element if not already done)\n+//        if(!hasNext){\n+//            throw new NoSuchElementException();\n+//        } else {\n+//            Text current = next;\n+//            hasNext = null;\n+//            return current;\n+//        }\n+//    }\n+//\n+//    @Override\n+//    public final boolean hasNext() {\n+//        if(hasNext == null){ // only once even with multiple calls\n+//            next = prepareNext();\n+//            hasNext = next != null;\n+//        }\n+//        return hasNext;\n+//    }\n+//    protected Text prepareNext(){\n+//        Object check;\n+//        while(it.hasNext()){\n+//            check = it.next();\n+//            if(check instanceof Text){\n+//                Text text = (Text)check;\n+//                if(languages == null || languages.contains(text.getLanguage())){\n+//                    return text;\n+//                }\n+//            } else if(isNullLanguage && check instanceof String){\n+//                return valueFactory.createText((String)check);\n+//            } //type does not fit -> ignore\n+//        }\n+//        //no more element and still nothing found ... return end of iteration\n+//        return null;\n+//    }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TextIterator.java",
                "sha": "f874409938b5a110a8efad64451e36bd06c289da",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ToStringIterator.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ToStringIterator.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 2,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ToStringIterator.java",
                "patch": "@@ -2,12 +2,29 @@\n \n import java.util.Iterator;\n \n+/**\n+ * Implementation of an Iterator over {@link String} values, that uses the \n+ * {@link Object#toString()} on elements of the parent Iterator for the \n+ * conversion.<p>\n+ * This Implementation does not use {@link AdaptingIterator}s implementation, \n+ * because the {@link Object#toString()} method can be used to create a string\n+ * representation for every object and therefore there is no need for the\n+ * filtering functionality provided by the {@link AdaptingIterator}.\n+ * \n+ * @author Rupert Westenthaler\n+ */\n public class ToStringIterator implements Iterator<String> {\n \n     protected final Iterator<?> it;\n-    public ToStringIterator(Iterator<?> it){\n+    /**\n+     * Creates an string iterator over parsed parent\n+     * @param it the parent iterator\n+     * @throws NullPointerException if <code>null</code> is parsed as parent\n+     * iterator\n+     */\n+    public ToStringIterator(Iterator<?> it) throws NullPointerException{\n         if(it == null){\n-            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n+            throw new NullPointerException(\"Parsed iterator MUST NOT be NULL!\");\n         }\n         this.it = it;\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/ToStringIterator.java",
                "sha": "08a2bf3d3aaf95a7643a1d55dcbddaf69802e3a9",
                "status": "modified"
            },
            {
                "additions": 90,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TypeSaveIterator.java",
                "changes": 128,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TypeSaveIterator.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 38,
                "filename": "rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TypeSaveIterator.java",
                "patch": "@@ -8,55 +8,107 @@\n  *\n  * @param <T> the type of elements returned by this iterator\n  */\n-public class TypeSaveIterator<T> implements Iterator<T> {\n+public class TypeSaveIterator<T> extends AdaptingIterator<Object,T> implements Iterator<T> {\n \n-    protected final Iterator<?> it;\n-    protected final Class<T> type;\n-    private T next;\n+//    protected final Iterator<?> it;\n+//    protected final Class<T> type;\n+//    private T next;\n+//    private Boolean hasNext;\n     /**\n      * Constructs an iterator that selects only elements of the parsed iterator\n      * that are assignable to the parse type\n      * @param it the base iterator\n      * @param type the type all elements of this Iterator need to be assignable to.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public TypeSaveIterator(Iterator<?> it,Class<T> type){\n-        if(it == null){\n-            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n-        }\n-        if(type == null){\n-            throw new IllegalArgumentException(\"Parsed type MUST NOT be NULL!\");\n-        }\n-        this.it = it;\n-        this.type = type;\n-        //init next ...\n-        next = prepareNext();\n-    }\n-    @Override\n-    public final void remove() {\n-        it.remove();\n-\n-    }\n-\n-    @Override\n-    public final T next() {\n-        T current = next;\n-        next = prepareNext();\n-        return current;\n+        super((Iterator<Object>)it,new AssignableFormAdapter<T>(),type);\n+//        if(it == null){\n+//            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n+//        }\n+//        if(type == null){\n+//            throw new IllegalArgumentException(\"Parsed type MUST NOT be NULL!\");\n+//        }\n+//        this.it = it;\n+//        this.type = type;\n     }\n+//    @Override\n+//    public final void remove() {\n+//        /*\n+//         * TODO: Any Iterator that filters elements of the underlying Iterator\n+//         * needs to call Iterator#next() in the underlying Iterator to get the\n+//         * next element that confirms with the filter.\n+//         * However the Iterator#remove() is defined as removing the last element\n+//         * to be returned by Iterator#next(). Therefore calling hasNext would\n+//         * change the element to be removed by this method.\n+//         * Currently I do not know a way around that but I would also like to\n+//         * keep the remove functionality for Iterator that filter elements of an\n+//         * underlying Iterator. To prevent unpredictable behaviour in such cases \n+//         * I throw an IllegalStateException in such cases.\n+//         * This decision assumes, that in most usage scenarios hasNext will not\n+//         * likely be called before calling remove and even in such cases\n+//         * it will be most likely be possible to refactor the code to confirm\n+//         * with this restriction.\n+//         * I hope this will help developers that encounter this exception to\n+//         * modify there code!\n+//         * If someone has a better Idea how to solve this please let me know!\n+//         * best \n+//         * Rupert Westenthaler\n+//         */\n+//        if(hasNext!= null){\n+//            throw new IllegalStateException(\"Remove can not be called after calling hasNext() because this Method needs to call next() on the underlying Interator and therefore would change the element to be removed :(\");\n+//        }\n+//        it.remove();\n+//    }\n+//\n+//    @Override\n+//    public final T next() {\n+//        hasNext(); //call hasNext (to init next Element if not already done)\n+//        if(!hasNext){\n+//            throw new NoSuchElementException();\n+//        } else {\n+//            T current = next;\n+//            next = null;\n+//            hasNext = null;\n+//            return current;\n+//        }\n+//    }\n+//\n+//    @Override\n+//    public final boolean hasNext() {\n+//        if(hasNext == null){ // only once even with multiple calls\n+//            next = prepareNext();\n+//            hasNext = next != null;\n+//        }\n+//        return hasNext;\n+//    }\n+//    @SuppressWarnings(\"unchecked\")\n+//    protected T prepareNext(){\n+//        Object check;\n+//        while(it.hasNext()){\n+//            check = it.next();\n+//            if(type.isAssignableFrom(check.getClass())){\n+//                return (T)check;\n+//            }\n+//        }\n+//        return null;\n+//    }\n+    /**\n+     * Adapter implementation that uses {@link Class#isAssignableFrom(Class)}\n+     * to check whether a value can be casted to the requested type\n+     */\n+    private static class AssignableFormAdapter<T> implements Adapter<Object,T> {\n \n-    @Override\n-    public final boolean hasNext() {\n-        return next != null;\n-    }\n-    @SuppressWarnings(\"unchecked\")\n-    protected T prepareNext(){\n-        Object check;\n-        while(it.hasNext()){\n-            check = it.next();\n-            if(type.isAssignableFrom(check.getClass())){\n-                return (T)check;\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public T adapt(Object value, Class<T> type) {\n+            if(type.isAssignableFrom(value.getClass())){\n+              return (T)value;\n+            } else {\n+                return null;\n             }\n         }\n-        return null;\n+        \n     }\n }\n+",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/main/java/eu/iksproject/rick/core/utils/TypeSaveIterator.java",
                "sha": "404d305e706018fbb116764819404b9451c566d3",
                "status": "modified"
            },
            {
                "additions": 27,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryRepresentationTest.java",
                "changes": 27,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryRepresentationTest.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryRepresentationTest.java",
                "patch": "@@ -0,0 +1,27 @@\n+package eu.iksproject.rick.core.model;\n+\n+import org.junit.Before;\n+\n+import eu.iksproject.rick.servicesapi.model.ValueFactory;\n+import eu.iksproject.rick.test.model.RepresentationTest;\n+\n+public class InMemoryRepresentationTest extends RepresentationTest {\n+    \n+    private ValueFactory valueFactory;\n+    \n+    @Before\n+    public void init(){\n+     valueFactory = InMemoryValueFactory.getInstance();   \n+    }\n+    \n+    @Override\n+    protected ValueFactory getValueFactory() {\n+        return valueFactory;\n+    }\n+\n+    @Override\n+    protected Object getUnsupportedValueInstance() {\n+        return null; //indicates that all kinds of Objects are supported!\n+    }\n+ \n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryRepresentationTest.java",
                "sha": "d337321118da47b969c04838ef6ab12f1389fe1f",
                "status": "added"
            },
            {
                "additions": 31,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryValueFactoryTest.java",
                "changes": 31,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryValueFactoryTest.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryValueFactoryTest.java",
                "patch": "@@ -0,0 +1,31 @@\n+package eu.iksproject.rick.core.model;\n+\n+import org.junit.Before;\n+\n+import eu.iksproject.rick.servicesapi.model.ValueFactory;\n+import eu.iksproject.rick.test.model.ValueFactoryTest;\n+\n+public class InMemoryValueFactoryTest extends ValueFactoryTest {\n+    \n+    private ValueFactory valueFactory;\n+    \n+    @Before\n+    public void init(){\n+     valueFactory = InMemoryValueFactory.getInstance();   \n+    }\n+    @Override\n+    protected Object getUnsupportedReferenceType() {\n+        return null; //indicates that all types are supported\n+    }\n+    \n+    @Override\n+    protected Object getUnsupportedTextType() {\n+        return null; //indicates that all types are supported\n+    }\n+    \n+    @Override\n+    protected ValueFactory getValueFactory() {\n+        return valueFactory;\n+    }\n+    \n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/core/src/test/java/eu/iksproject/rick/core/model/InMemoryValueFactoryTest.java",
                "sha": "af0ae874dcfcf17453cfc8bffd67263949801d15",
                "status": "added"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/DataTypeEnum.java",
                "changes": 33,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/DataTypeEnum.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 8,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/DataTypeEnum.java",
                "patch": "@@ -20,22 +20,39 @@\n import eu.iksproject.rick.servicesapi.model.Reference;\n import eu.iksproject.rick.servicesapi.model.Text;\n /**\n- * Holds data types used by Rick. Uses the xsd data types where possible.\n- *\n+ * Defines the data types that need to be supported by the model \n+ * implementation.<p>\n+ * Each data type defines:<ul>\n+ * <li><b>short name:</b> An short and human readable ID that is unique within \n+ * the list of data types. Currently <code>prefix:localName</code> is used as \n+ * short name and prefixes are used as defined by the {@link NamespaceEnum}.\n+ * <li><b>uri:</b> Ths is the global unique UD of the namespace. If possible the\n+ * URI defined by XSD is used (e.g. http://www.w3.org/2001/XMLSchema#string for\n+ * strings). \n+ * <li><b>java class:</b> Each data type is mapped to exactly one preferred \n+ * and 0..n optional java representations. Note that\n+ * different data types may use the same preferred as well as optional java class \n+ * meaning. This means that the java class can not be used to uniquely identify \n+ * a data type.\n+ * </ul>\n+ * The {@link #name()} is not used, but typically the local name with an capital\n+ * first letter is used. The URI of the data type is used by the implementation\n+ * of {@link #toString()}.<p>\n+ * In addition the the definition of all the data types this class also provides\n+ * several utilities for getting the data type by short name, URI as well as\n+ * preferred or all defined java class mappings.\n+ * \n  * @author Rupert Westenthaler\n  *\n  */\n public enum DataTypeEnum {\n     //Rick specific\n-    //Reference\n     Reference(NamespaceEnum.rickModel,\"ref\",Reference.class),\n-    //Natural language Text\n     Text(NamespaceEnum.rickModel,\"text\",Text.class),\n     //xsd types\n     /**\n      * currently URIs are preferable mapped to {@link Reference}, because there\n-     * may be RDF URIs that are not valid {@link URI}s nor {@link URL}s. However\n-     * existing URI and URL instances are also accepted.\n+     * may be RDF URIs that are not valid {@link URI}s nor {@link URL}s.\n      */\n     AnyUri(\"anyURI\",Reference.class,URI.class,URL.class),\n     Boolean(\"boolean\",Boolean.class),\n@@ -58,10 +75,10 @@\n     final String shortName;\n     final String uri;\n     final Set<Class<?>> additional;\n-    DataTypeEnum(Class<?> javaType,Class<?>...additional){\n+    private DataTypeEnum(Class<?> javaType,Class<?>...additional){\n         this(null,null,javaType,additional);\n     }\n-    DataTypeEnum(String localName,Class<?> javaType,Class<?>...additional){\n+    private DataTypeEnum(String localName,Class<?> javaType,Class<?>...additional){\n         this(null,localName,javaType,additional);\n     }\n     private DataTypeEnum(NamespaceEnum namespace,Class<?> javaType,Class<?>...additional) {",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/DataTypeEnum.java",
                "sha": "1fad14fa36c2fc18032bd2836de9f3fb64b4c93f",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/NamespaceEnum.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/NamespaceEnum.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 4,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/NamespaceEnum.java",
                "patch": "@@ -3,17 +3,22 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-\n+/**\n+ * Defines commonly used name spaces to prevent multiple definitions in several\n+ * classes\n+ * @author Rupert Westenthaler\n+ *\n+ */\n public enum NamespaceEnum {\n     //Namespaces defined by RICK\n     rickModel(\"rick\",\"http://www.iks-project.eu/ontology/rick/model/\"),\n     rickQuery(\"rick-query\",\"http://www.iks-project.eu/ontology/rick/query/\"),\n \n \n     //First the XML Namespaces\n-    xsd(\"http://www.w3.org/2001/XMLSchema/\"),\n-    xsi(\"http://www.w3.org/2001/XMLSchema-instance/\"),\n-    xml(\"http://www.w3.org/XML/1998/namespace/\"),\n+    xsd(\"http://www.w3.org/2001/XMLSchema#\"),\n+    xsi(\"http://www.w3.org/2001/XMLSchema-instance#\"),\n+    xml(\"http://www.w3.org/XML/1998/namespace#\"),\n     //Start with the semantic Web Namespaces\n     rdf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"),\n     rdfs(\"http://www.w3.org/2000/01/rdf-schema#\"),",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/defaults/NamespaceEnum.java",
                "sha": "dffec9e4f3d31889992abf1f3f189dfb217200a6",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Reference.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Reference.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 1,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Reference.java",
                "patch": "@@ -1,7 +1,8 @@\n package eu.iksproject.rick.servicesapi.model;\n \n /**\n- * Defines a reference to an other entity\n+ * Defines a reference to an other entity <p>\n+ * Implementations of that interface MUST BE immutable\n  * @author Rupert Westenthaler\n  *\n  */",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Reference.java",
                "sha": "2706d3acdc6a42a07a3fa80c72d76377c7e8c8f3",
                "status": "modified"
            },
            {
                "additions": 98,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Representation.java",
                "changes": 144,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Representation.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 46,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Representation.java",
                "patch": "@@ -1,5 +1,8 @@\n package eu.iksproject.rick.servicesapi.model;\n \n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Enumeration;\n import java.util.Iterator;\n \n import eu.iksproject.rick.servicesapi.yard.Yard;\n@@ -14,8 +17,6 @@\n  *       \"normal\" values feels to complex! Need to reevaluate if this differentiation\n  *       is needed or can be done in a more easy way!\n  * TODO: add an API that allows to attach Content!\n- * TODO: Review this interface during the definition of a Query Language for the\n- * Rick (or IKS in general)\n  * TODO: Do we need subNodes or are \"references\" enough.\n  *\n  * TODO: Check to use also Wrappers for fields and values (in analogy to\n@@ -37,8 +38,10 @@\n      * @param type the type of the values\n      * @return the (first) value of that field\n      * @throws IllegalArgumentException if the type is not supported\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    <T> T getFirst(String field,Class<T> type) throws UnsupportedTypeException;\n+    <T> T getFirst(String field,Class<T> type) throws UnsupportedTypeException, NullPointerException, IllegalArgumentException;\n \n     /**\n      * Getter for all values of a field\n@@ -47,41 +50,53 @@\n      * @param type the type\n      * @return the values of the field\n      * @throws UnsupportedTypeException if the parsed type is not supported\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    <T> Iterator<T> get(String field,Class<T> type) throws UnsupportedTypeException;\n+    <T> Iterator<T> get(String field,Class<T> type) throws UnsupportedTypeException, NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for the (first) value for a field\n      * @param field the field\n      * @return the first value of a field\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    Object getFirst(String field);\n+    Object getFirst(String field) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for the first reference value for a field\n      * @param field the field\n      * @return the reference or null of the field has no reference as value\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    Reference getFirstReference(String field);\n+    Reference getFirstReference(String field) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for the first natural language text value of a specific language\n      * @param field the field\n      * @param language the language(s) of the natural language text value\n      *             (If <code>null</code> is parsed as language, than also labels\n      *             without language tag are included in the Result)\n      * @return the first natural language text found for the parsed field\n-     */\n-    Text getFirst(String field, String...language);\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n+    */\n+    Text getFirst(String field, String...language) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for all values for the requested field\n      * @param field the field\n      * @return the values of the field\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    Iterator<Object> get(String field);\n+    Iterator<Object> get(String field) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for all natural language text values of a field\n      * @param field the field\n      * @return the natural text values\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    Iterator<Text> getText(String field);\n+    Iterator<Text> getText(String field) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for all natural language text values of a field\n      * @param field the field\n@@ -90,14 +105,18 @@\n      *             without language tag are included in the Result)\n      * @return iterator over all natural language text values in the requested\n      *             language.\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    Iterator<Text> get(String field,String...language);\n+    Iterator<Text> get(String field,String...language) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for all reference values of a field\n      * @param field the field\n      * @return Iterator over all reference values of a field\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    Iterator<Reference> getReferences(String field);\n+    Iterator<Reference> getReferences(String field) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Adds the object as value to the field.\n      * <p>The type of the value is inferred based on the type of the Object.<br>\n@@ -106,54 +125,62 @@\n      * <li>{@link Reference}\n      * <li>URL, URI: {@link Reference} instances are created for such values</li>\n      * <li>Boolean, Integer, Long, Double and Float as primitive data types</li>\n+     * <li>{@link Date} \n      * <li>{@link Text}\n      * <li>String[]{text,language}: text and language (further entries are ignored)</li>\n      * <li>String: mapped to {@link Text} with the <code>language=null</code></li>\n-     * <li>Collection are used for adding multiple values\n-     * <li>For other types the toString() method is used</li>\n-     * </ul>\n+     * <li>{@link Collection}s, {@link Enumeration}s and {@link Iterator}s are \n+     *     can be used to parse multiple values\n+     * <li>For unsupported types it MUSST be assured the the toString() value\n+     *     of the stored Object is equals to the toString() value of the parsed\n+     *     object.</li>\n+     * </ul> \n      * @param field the field\n      * @param value the value to add\n+     * @throws NullPointerException if <code>null</code> is parsed as field or\n+     * value\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void add(String field, Object value);\n+    void add(String field, Object value) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Adds an reference to the field.\n      * @param field the field\n      * @param reference the string representation of the reference. Note that\n      * the value will be interpreted as a \"reference\" so there might apply\n      * some rules about the format of the string. Regardless of the implementation\n      * any valid URI and URL need to be accepted as a valid reference value\n+     * @throws NullPointerException if <code>null</code> is parsed as field or\n+     * reference\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * or reference and/or <code>null</code> is parsed as value.\n      */\n-    void addReference(String field, String reference);\n+    void addReference(String field, String reference) throws NullPointerException,IllegalArgumentException;\n     /**\n      * Adds a natural language text as value for one or more languages\n      * @param field the field to add the text as value\n      * @param text the natural language text\n      * @param language the text is set for all the parsed languages. Parse\n      *             <code>null</code> to set the text also without any language\n      *             information.\n+     * @throws NullPointerException if <code>null</code> is parsed as field.\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * and/or <code>null</code> is parsed as text. NOTE that <code>null</code> \n+     * is supported for languages.\n      */\n-    void addNaturalText(String field,String text, String...languages);\n+    void addNaturalText(String field,String text, String...languages) throws NullPointerException,IllegalArgumentException;\n     /**\n      * Sets the value of the field to the parsed object. If the parsed value\n      * is <code>null</code> than this method removes all values for the given\n-     * field\n-     * <p>The type of the value is inferred based on the type of the Object.<br>\n-     * Supported Types are:</p>\n-     * <ul>\n-     * <li>{@link Reference}\n-     * <li>URL, URI: {@link Reference} instances are created for such values</li>\n-     * <li>Boolean, Integer, Long, Double and Float as primitive data types</li>\n-     * <li>{@link Text}\n-     * <li>String[]{text,language}: text and language (further entries are ignored)</li>\n-     * <li>String: mapped to {@link Text} with the <code>language=null</code></li>\n-     * <li>Collection are used for adding multiple values\n-     * <li>For other types the toString() method is used</li>\n-     * </ul>\n+     * field<br>\n+     * This Method supports collections as well as value conversions for some\n+     * types. Please see the documentation of {@link #add(String, Object)} for\n+     * details.\n      * @param field the field\n      * @param value the new value for the field\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void set(String field, Object value);\n+    void set(String field, Object value) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Setter for the reference of a field. If the parsed value\n      * is <code>null</code> than this method removes all values for the given\n@@ -163,8 +190,10 @@\n      * the value will be interpreted as a \"reference\" so there might apply\n      * some rules about the format of the string. Regardless of the implementation\n      * any valid URI and URL need to be accepted as a valid reference value\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void setReference(String field, String reference);\n+    void setReference(String field, String reference) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Setter for the natural language text value of a field in the given\n      * languages. If <code>null</code> is parsed as text, all present values\n@@ -175,45 +204,68 @@\n      * @param language the languages of the parsed text. Parse\n      *             <code>null</code> to set the text also without any language\n      *             information.\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void setNaturalText(String field,String text, String...language);\n+    void setNaturalText(String field,String text, String...language) throws NullPointerException, IllegalArgumentException;\n     /**\n-     * Removes the parsed value form the field\n+     * Removes the parsed value form the field. If <code>null</code> is parsed\n+     * as value than the call is ignored.<p>\n+     * This methods follows the same conventions as {@link #add(String, Object)}\n+     * (e.g. parsing a {@link Collection} will cause all values within this\n+     * collection to be removed). See the documentation of {@link #add(String, Object)}\n+     * for details.\n      * @param field the field\n      * @param value the value to remove\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void remove(String field, Object value);\n+    void remove(String field, Object value) throws NullPointerException, IllegalArgumentException; \n     /**\n-     * Removes to parsed reference as value for the given field.\n+     * Removes to parsed reference as value for the given field. If <code>null</code>\n+     * is parsed as reference, that the call is ignored.\n      * @param field the field\n      * @param reference the string representation of the reference. Note that\n      * the value will be interpreted as a \"reference\" so there might apply\n      * some rules about the format of the string. Regardless of the implementation\n      * any valid URI and URL need to be accepted as a valid reference value\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void removeReference(String field,String reference);\n+    void removeReference(String field,String reference) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Removes a natural language text in given languages form a field\n      * @param field the field\n      * @param text the natural language text\n      * @param language the language(s) of the natural language text\n      *             (If <code>null</code> is parsed as language, than also labels\n      *             without language tag might be removed)\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void removeNaturalText(String field,String text,String...languages);\n+    void removeNaturalText(String field,String text,String...languages) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Removes all values of the field\n      * @param field the field\n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void removeAll(String field);\n+    void removeAll(String field) throws NullPointerException, IllegalArgumentException;\n     /**\n-     * Removes all natural language texts for the given languages\n-     * @param field the field\n-     * @param language the language(s) of the natural language text\n-     *             (If <code>null</code> is parsed as language, than also all labels\n-     *             without language tag are removed)\n+     * Removes all natural language texts for the given languages or all natural\n+     * language labels of no language or an empty array is parsed as language.\n+     * To remove values with no language, parse <code>null</code> as entry of the\n+     * languages array.\n+     * @param field the field.\n+     * @param languages the language(s) of the natural language text. If\n+     *             <code>null</code> or an empty array is parsed, than all\n+     *             natural language label are removed. To remove only labels with\n+     *             no language, <code>null</code> needs to be parsed as entry of\n+     *             this array. \n+     * @throws NullPointerException if <code>null</code> is parsed as field\n+     * @throws IllegalArgumentException if an empty string is parsed as field\n      */\n-    void removeAllNaturalText(String field,String...languages);\n+    void removeAllNaturalText(String field,String...languages) throws NullPointerException, IllegalArgumentException;\n     /**\n      * Getter for all the present fields\n      * @return the fields",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Representation.java",
                "sha": "e51587e5b7c188688681f0e7c34e8208a8fa7f3c",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Text.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Text.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 5,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Text.java",
                "patch": "@@ -1,24 +1,33 @@\n package eu.iksproject.rick.servicesapi.model;\n \n /**\n- * Defines a natural language text in a given language.\n+ * Defines a natural language text in a given language.<p>\n+ * The text MUST NOT be <code>null</code> nor an empty {@link String}. The\n+ * language may be <code>null</code> (indicating the default language) or any\n+ * kind of value. It is recommended to use ISO 639-1 codes (two Letter codes).\n+ * By definition it is also allowed to use empty strings as language. However\n+ * implementations of this interface are free to convert the empty language to\n+ * <code>null</code>.<p>\n+ * Implementations of that interface MUST BE immutable\n+ * \n  * @author Rupert Westenthaler\n  */\n public interface Text {\n     /**\n-     * Getter for the text (not <code>null</code>)\n+     * Getter for the text (not <code>null</code> nor empty)\n      * @return the text\n      */\n     String getText();\n     /**\n-     * Getter for the language. <code>null</code> indicates, that the text\n-     * is not specific to a language (e.g. the name of a person)\n+     * Getter for the language. <code>null</code> or an empty string indicate, \n+     * that the text is not specific to a language (e.g. the name of a person).\n+     * Note that implementation can change empty values to <code>null</code> but.\n      * @return the language\n      */\n     String getLanguage();\n     /**\n      * The text without language information - this is the same as returned\n-     * by {@link #getText()}\n+     * by {@link #getText()}.\n      * @return the text\n      */\n     String toString();",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/Text.java",
                "sha": "f82bcffef0d1976e5afea71b3fc2d03fd40ba33b",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/UnsupportedTypeException.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/UnsupportedTypeException.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 5,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/UnsupportedTypeException.java",
                "patch": "@@ -1,23 +1,28 @@\n package eu.iksproject.rick.servicesapi.model;\n \n /**\n- * Indicates, that the type of a source value is not compatible with the requested\n- * DataType of the requested target value.\n+ * Indicates, that the requested type is not supported. <p>\n+ * The definition of the model requires some types to be supported.\n+ * Implementation may support additional types. Components that use a specific\n+ * implementation may therefore use types that are not required to be supported.\n+ * However such components should also be able to deal with this kind of\n+ * exceptions.\n+ * \n  * @author Rupert Westenthaler\n  *\n  */\n-public class UnsupportedTypeException extends RuntimeException {\n+public class UnsupportedTypeException extends IllegalArgumentException {\n \n     /**\n      * uses the default serialVersionUID\n      */\n     private static final long serialVersionUID = 1L;\n \n-    protected UnsupportedTypeException(Class<?> type,String dataType) {\n+    public UnsupportedTypeException(Class<?> type,String dataType) {\n         this(type,dataType,null);\n     }\n \n-    protected UnsupportedTypeException(Class<?> type,String dataType, Throwable cause) {\n+    public UnsupportedTypeException(Class<?> type,String dataType, Throwable cause) {\n         super(String.format(\"Values of Type \\\"%s\\\" are not supported for data type \\\"%s\\\"\",\n                 type,dataType),cause);\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/UnsupportedTypeException.java",
                "sha": "01c3ad4dcf6c0062c5c83cd8f93b32e23eb46abb",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/ValueFactory.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/ValueFactory.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 6,
                "filename": "rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/ValueFactory.java",
                "patch": "@@ -1,5 +1,8 @@\n package eu.iksproject.rick.servicesapi.model;\n \n+import java.net.URI;\n+import java.net.URL;\n+\n import eu.iksproject.rick.servicesapi.model.Sign.SignTypeEnum;\n \n /**\n@@ -17,33 +20,50 @@\n      * @return the Text instance for the parsed object\n      * @throws UnsupportedTypeException if the type of the parsed object is not\n      * can not be used to create Text instances\n+     * @throws IllegalArgumentException If the parsed instance type is supported, but\n+     * the parsed instance can not be used to create a text instance\n+     * @throws NullPointerException If <code>null</code> is parsed\n      */\n-    Text createText(Object value) throws UnsupportedTypeException;\n+    Text createText(Object value) throws UnsupportedTypeException, IllegalArgumentException,NullPointerException;\n     /**\n      * Creates a Text instance for a language\n      * @param text the text\n      * @param language the language or <code>null</code>.\n      * @return the Text instance\n+     * @throws IllegalArgumentException if the parsed parameter can not be used to create a Text instance\n+     * @throws NullPointerException if <code>null</code> is parsed as text.\n      */\n-    Text createText(String text,String language);\n+    Text createText(String text,String language) throws IllegalArgumentException, NullPointerException;\n     /**\n      * Creates a reference instance for the parsed value. Implementations might\n      * support special support for specific classes. As an default the\n      * {@link Object#toString()} method is used to get the unicode representation\n-     * of the reference.\n+     * of the reference.<p>\n+     * Implementation MUST support at least the following types:<ul>\n+     * <li> {@link String}: The parsed string need not be be checked for a valid\n+     *      IRI, URI or URL in any form. However in case of an empty String a \n+     *      {@link IllegalArgumentException} MUST BE thrown)\n+     * <li> {@link URI}: Any valid URI MUST BE accepted\n+     * <li> {@link URL}: any valid URL MUST BE accepted\n+     * </ul>\n      * @param value the unicode representation of the reference\n      * @return the reference instance\n      * @throws UnsupportedTypeException if the type of the parsed object can\n      * not be converted to a Reference.\n+     * @throws IllegalArgumentException if the parsed value can not be used to\n+     * create a valid Reference (e.g. when parsing an empty String)\n+     * @throws NullPointerException if the parsed value is <code>null</code>\n      */\n-    Reference createReference(Object value) throws UnsupportedTypeException;\n+    Reference createReference(Object value) throws UnsupportedTypeException, IllegalArgumentException, NullPointerException;\n     /**\n      * Creates an empty representation instance of with the type {@link SignTypeEnum#Sign}\n-     * for the parsed ID\n+     * for the parsed ID. The id MUST not be <code>null</code> nor empty\n      * @param id The id of the representation\n      * @return the representation\n+     * @throws NullPointerException If <code>null</code> is parsed as ID\n+     * @throws IllegalArgumentException if an empty string is parsed as ID\n      */\n-    Representation createRepresentation(String id);\n+    Representation createRepresentation(String id) throws NullPointerException, IllegalArgumentException;\n //    /**\n //     * Creates a value of the parsed data type for the parsed object\n //     * @param dataTypeUri the data type of the created object",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/servicesapi/src/main/java/eu/iksproject/rick/servicesapi/model/ValueFactory.java",
                "sha": "a0a5155386c80c8bf1efb14c6aef4ed96b1b449b",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/test/pom.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/test/pom.xml?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/generic/test/pom.xml",
                "patch": "@@ -30,6 +30,7 @@\n \t  <dependency>\n \t      <groupId>junit</groupId>\n \t      <artifactId>junit</artifactId>\n+\t      <scope>provided</scope>\n \t  </dependency>\n       <dependency>\n           <groupId>eu.iksproject</groupId>",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/test/pom.xml",
                "sha": "aa3710f730c85f41433b2f57b299f48074f2eca8",
                "status": "modified"
            },
            {
                "additions": 1023,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/test/src/main/java/eu/iksproject/rick/test/model/RepresentationTest.java",
                "changes": 1030,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/test/src/main/java/eu/iksproject/rick/test/model/RepresentationTest.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 7,
                "filename": "rick/generic/test/src/main/java/eu/iksproject/rick/test/model/RepresentationTest.java",
                "patch": "@@ -1,16 +1,1032 @@\n package eu.iksproject.rick.test.model;\n \n+import static junit.framework.Assert.*;\n+\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.Vector;\n+\n+import org.junit.Test;\n+\n+import eu.iksproject.rick.servicesapi.model.Reference;\n import eu.iksproject.rick.servicesapi.model.Representation;\n+import eu.iksproject.rick.servicesapi.model.Text;\n+import eu.iksproject.rick.servicesapi.model.UnsupportedTypeException;\n+import eu.iksproject.rick.servicesapi.model.ValueFactory;\n \n public abstract class RepresentationTest {\n     /**\n-     * Subclasses implement this method to provide implementation instances of\n-     * {@link Representation}. This method may be called an arbitrary amount of time,\n-     * independently whether previously returned MGraph are still in use or not.\n-     *\n-     * @return an empty {@link Representation} of the implementation to be tested\n+     * Subclasses must implement this method and provide a {@link ValueFactory}\n+     * instance that is used to test the actual model implementation\n+     * @return the {@link ValueFactory} for the RICK model implementation to be\n+     * tested\n+     */\n+    protected abstract ValueFactory getValueFactory();\n+    /**\n+     * Getter for an instance of an unsupported type. For add/set operation such\n+     * values are converted to the lexical form by using the\n+     * {@link Object#toString()} method. For {@link Representation#get(String, Class)}\n+     * and {@link Representation#getFirst(String, Class)} an \n+     * {@link UnsupportedTypeException} need to be thrown when requesting values\n+     * of the {@link Object#getClass()} of the returned instance.\n+     * @return An instance of a class that is not supported by the \n+     * tested {@link Representation} implementation or <code>null</code> if the\n+     * tested implementation does support any type (this will deactivate such\n+     * kind of tests).\n+     */\n+    protected abstract Object getUnsupportedValueInstance();\n+    \n+    /*--------------------------------------------------------------------------\n+     * Set of Tests that check if all Methods correctly throw a NullPointerException\n+     * when parsing null as field!\n+     *  - important to prevent NULL fields within the RICK\n+     *--------------------------------------------------------------------------\n+     */\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldAdd(){\n+        Representation rep = createRepresentation(null);\n+        rep.add(null, \"test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldAddNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.addNaturalText(null, \"test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldAddReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.addReference(null, \"urn:test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGet(){\n+        Representation rep = createRepresentation(null);\n+        rep.get(null);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetDataType(){\n+        Representation rep = createRepresentation(null);\n+        rep.get(null, Integer.class);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetNaturalLanguateText(){\n+        Representation rep = createRepresentation(null);\n+        rep.get(null,\"en\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetFirst(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirst(null);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetFirstReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirstReference(null);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetFirstDataType(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirst(null, Integer.class);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetFirstNaturalLanguage(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirst(null, \"en\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetReferences(){\n+        Representation rep = createRepresentation(null);\n+        rep.getReferences(null);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldGetText(){\n+        Representation rep = createRepresentation(null);\n+        rep.getText(null);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldRemove(){\n+        Representation rep = createRepresentation(null);\n+        rep.remove(null, \"test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldRemoveAll(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeAll(null);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldRemoveAllNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeAllNaturalText(null, \"de\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldRemoveNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeNaturalText(null, \"test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldRemoveReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeReference(null, \"urn:test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldSet(){\n+        Representation rep = createRepresentation(null);\n+        rep.set(null, \"test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldSetNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.setNaturalText(null, \"test\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullFieldSetReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.setReference(null, \"urn:test\");\n+    }\n+    /*--------------------------------------------------------------------------\n+     * Set of Tests that check if all Methods correctly throw a IllegalArgumentExceptions\n+     * when parsing an empty string as field\n+     *  - important to prevent \"\" fields within the RICK\n+     *--------------------------------------------------------------------------\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldAdd(){\n+        Representation rep = createRepresentation(null);\n+        rep.add(\"\", \"test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldAddNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.addNaturalText(\"\", \"test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldAddReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.addReference(\"\", \"urn:test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGet(){\n+        Representation rep = createRepresentation(null);\n+        rep.get(\"\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetDataType(){\n+        Representation rep = createRepresentation(null);\n+        rep.get(\"\", Integer.class);\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetNaturalLanguateText(){\n+        Representation rep = createRepresentation(null);\n+        rep.get(\"\",\"en\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetFirst(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirst(\"\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetFirstReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirstReference(\"\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetFirstDataType(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirst(\"\", Integer.class);\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetFirstNaturalLanguage(){\n+        Representation rep = createRepresentation(null);\n+        rep.getFirst(\"\", \"en\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetReferences(){\n+        Representation rep = createRepresentation(null);\n+        rep.getReferences(\"\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldGetText(){\n+        Representation rep = createRepresentation(null);\n+        rep.getText(\"\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldRemove(){\n+        Representation rep = createRepresentation(null);\n+        rep.remove(\"\", \"test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldRemoveAll(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeAll(\"\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldRemoveAllNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeAllNaturalText(\"\", \"de\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldRemoveNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeNaturalText(\"\", \"test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldRemoveReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.removeReference(\"\", \"urn:test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldSet(){\n+        Representation rep = createRepresentation(null);\n+        rep.set(\"\", \"test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldSetNaturalText(){\n+        Representation rep = createRepresentation(null);\n+        rep.setNaturalText(\"\", \"test\");\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyFieldSetReference(){\n+        Representation rep = createRepresentation(null);\n+        rep.setReference(\"\", \"urn:test\");\n+    }\n+    /**\n+     * Tests if value iterators for non existing fields return an Iterator\n+     * with no elements (Here it is important, that in such cases methods do\n+     * not return <code>null</code>).\n+     */\n+    @Test\n+    public void testNonExistingFields(){\n+        String field = \"urn:this.field:does.not:exist\";\n+        //Iterators MUST NOT be NULL but MUST NOT contain any element\n+        Representation rep = createRepresentation(null);\n+        Iterator<String> fieldIt = rep.getFieldNames();\n+        assertNotNull(fieldIt);\n+        assertFalse(fieldIt.hasNext());\n+        Iterator<Object> valueIt = rep.get(field);\n+        assertNotNull(valueIt);\n+        assertFalse(valueIt.hasNext());\n+        Iterator<Reference> refIt = rep.getReferences(field);\n+        assertNotNull(refIt);\n+        assertFalse(refIt.hasNext());\n+        Iterator<Text> textIt = rep.get(field,(String[])null);\n+        assertNotNull(textIt);\n+        assertFalse(textIt.hasNext());\n+    }    \n+    /*--------------------------------------------------------------------------\n+     * Set of Tests that check if all add methods correctly throw an \n+     * IllegalArgumentExceptions when parsing NULL as value\n+     *  - important to prevent NULL values within RICK\n+     *--------------------------------------------------------------------------\n+     */    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void testAddNullReference(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        rep.addReference(field, null);\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testAddNullText(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        rep.addNaturalText(field, null);\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testAddNullObject(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        rep.add(field, null);\n+    }\n+    /*--------------------------------------------------------------------------\n+     * Set of Tests that check if Methods correctly process UnsupportedTypes\n+     * This means that the toString Method is used to get the lexical\n+     * representation of such types\n+     *--------------------------------------------------------------------------\n+     */ \n+    /**\n+     * Adding an unsupported type should use the {@link Object#toString()}\n+     * to store the parsed instance\n+     */\n+    @Test\n+    public void testAddUnsupportedType(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        Object value = getUnsupportedValueInstance();\n+        if(value == null){ //any type is supported by the representation\n+            return; //this test is not needed\n+        }\n+        rep.add(field, value);\n+        Iterator<Object> valueIterator = rep.get(field);\n+        assertNotNull(valueIterator);\n+        assertTrue(valueIterator.hasNext());\n+        Object repValue = valueIterator.next();\n+        assertEquals(value.toString(), repValue.toString());\n+    }\n+    @Test\n+    public void testSetUnsupportedType(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        Object value = getUnsupportedValueInstance();\n+        if(value == null){ //any type is supported by the representation\n+            return; //this test is not needed\n+        }\n+        rep.set(field, value); //this does not test that set removes previous values\n+        Iterator<Object> valueIterator = rep.get(field);\n+        assertNotNull(valueIterator);\n+        assertTrue(valueIterator.hasNext());\n+        Object repValue = valueIterator.next();\n+        assertEquals(value.toString(), repValue.toString());\n+    }\n+    @Test(expected=UnsupportedTypeException.class)\n+    public void testGetValueWithUnsupportedType(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        Object value = getUnsupportedValueInstance();\n+        if(value == null){ //any type is supported by the representation\n+           //this test is not needed therefore return an dummy Exception\n+            throw new UnsupportedTypeException(Object.class,\n+                \"dummy exception to successfully complete this unnecessary test\");\n+        } else {\n+            Class<?> unsupported = value.getClass();\n+            rep.get(field, unsupported);\n+        }\n+    }\n+    @Test(expected=UnsupportedTypeException.class)\n+    public void testGetFirstValueWithUnsupportedType(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        Object value = getUnsupportedValueInstance();\n+        if(value == null){ //any type is supported by the representation\n+           //this test is not needed therefore return an dummy Exception\n+            throw new UnsupportedTypeException(Object.class,\n+                \"dummy exception to successfully complete this unnecessary test\");\n+        } else {\n+            Class<?> unsupported = value.getClass();\n+            rep.getFirst(field, unsupported);\n+        }\n+    }\n+\n+    /**\n+     * If <code>null</code> is parsed as value for any setter method, than all \n+     * values need to be removed for the field. this means that\n+     * <code>set**(field,null)</code> has the same effect as\n+     * <code>{@link Representation#removeAll(String) removeAll(field)} </code> \n+     */\n+    @Test\n+    public void testSetToNullAsRemoveAll(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        String testReference = \"http://www.test.org/test\";\n+        String testText = \"This is a Test\";\n+        Integer testValue = 42;\n+        Representation rep = createRepresentation(null);\n+        rep.add(field, testValue);\n+        rep.addNaturalText(field, testText, \"en\");\n+        rep.addReference(field, testReference);\n+        rep.set(field, null); //need to remove all values\n+        Iterator<Object> values = rep.get(field);\n+        assertNotNull(values);\n+        assertFalse(values.hasNext());\n+        //test specific setter (also specific setters need to remove all values)\n+        rep.add(field, testValue);\n+        rep.addNaturalText(field, testText, \"en\");\n+        rep.addReference(field, testReference);\n+        rep.setNaturalText(field, null);\n+        assertNotNull(values);\n+        assertFalse(values.hasNext());\n+\n+        rep.add(field, testValue);\n+        rep.addNaturalText(field, testText, \"en\");\n+        rep.addReference(field, testReference);\n+        rep.setReference(field, null);\n+        assertNotNull(values);\n+        assertFalse(values.hasNext());\n+    }\n+    \n+    @Test\n+    public void testFieldRemoval() throws URISyntaxException{\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        ValueFactory vf = getValueFactory();\n+        Representation rep = createRepresentation(null);\n+        //Test removal for References\n+        String strRef = \"urn:testValue\";\n+        rep.addReference(field, strRef);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.removeReference(field, strRef);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+        \n+        Reference ref = vf.createReference(\"urn:testValue2\");\n+        rep.add(field, ref);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.remove(field, ref);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+\n+        //test removal for texts (with and without language)\n+        String strText = \"test text\";\n+        String strTextLang = \"en\";\n+        rep.addNaturalText(field, strText, strTextLang);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.removeNaturalText(field, strText, strTextLang);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+\n+        String strTextNoLang = \"test text without lang\";\n+        rep.addNaturalText(field, strTextNoLang);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.removeNaturalText(field, strTextNoLang);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+        \n+        //there is also the possibility to explicitly parse null as language\n+        //could internally case differences however externally this is the same\n+        rep.addNaturalText(field, strTextNoLang,(String)null);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.removeNaturalText(field, strTextNoLang,(String)null);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+        \n+        Text text = vf.createText(\"Das ist ein Text zum testen des Text Objektes\",\"de\");\n+        rep.add(field, text);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.remove(field, text);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+        \n+        //Test a dataTypes values\n+        Integer intValue = 42;\n+        rep.add(field, intValue);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.remove(field, intValue);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+        \n+        //Some Values are converted by the add(String field,Object value) Method\n+        //to other data types. This MUST also be assured for removal\n+        // NOTE: testing the conversions is done in other test methods!\n+        URI testURI = new URI(\"http://www.test.org/test\");\n+        rep.add(field, testURI);\n+        assertTrue(asCollection(rep.getFieldNames()).contains(field));\n+        rep.remove(field, testURI);\n+        assertFalse(asCollection(rep.getFieldNames()).contains(field));\n+    }\n+    /**\n+     * Tests if {@link Reference} instances are correctly generated for {@link URI}.\n+     * This test also depends on the correct implementation of the\n+     * {@link Reference#equals(Object)} method\n+     * @throws URISyntaxException\n+     */\n+    @Test\n+    public void testURIToReferenceConversion() throws URISyntaxException{\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        URI uri = new URI(\"http://www.test.org/uriTest\");\n+        ValueFactory vf = getValueFactory();\n+        Representation rep = createRepresentation(null);\n+        //test conversion\n+        rep.add(field, uri);\n+        Iterator<Reference> refs = rep.getReferences(field);\n+        assertTrue(refs.hasNext());\n+        assertEquals(refs.next().getReference(),uri.toString());\n+        assertFalse(refs.hasNext());\n+        //test multiple adds do not generate duplicate References\n+        rep.add(field, uri);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test adding a equivalent reference\n+        rep.add(field, vf.createReference(uri.toString()));\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test removing\n+        rep.remove(field, uri);\n+        assertFalse(rep.get(field).hasNext());\n+    }\n+    /**\n+     * Tests if {@link Reference} instances are correctly generated for {@link URL}.\n+     * This test also depends on the correct implementation of the\n+     * {@link Reference#equals(Object)} method\n+     * @throws MalformedURLException\n+     */\n+    @Test\n+    public void testURLToReferenceConversion() throws MalformedURLException{\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        URL url = new URL(\"http://www.test.org/urlTest\");\n+        ValueFactory vf = getValueFactory();\n+        Representation rep = createRepresentation(null);\n+        //test conversion\n+        rep.add(field, url);\n+        Iterator<Reference> refs = rep.getReferences(field);\n+        assertTrue(refs.hasNext());\n+        assertEquals(refs.next().getReference(),url.toString());\n+        assertFalse(refs.hasNext());\n+        //test multiple adds do not generate duplicate References\n+        rep.add(field, url);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test adding a equivalent reference\n+        rep.add(field, vf.createReference(url.toString()));\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test removing\n+        rep.remove(field, url);\n+        assertFalse(rep.get(field).hasNext());\n+        \n+    }\n+    /**\n+     * Parsing a String Array with null as first element MUST NOT add a value\n+     * (because null values are not supported by {@link Representation}).\n+     */\n+    @Test\n+    public void testStringArrayWithNullTextConversion(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        rep.add(field, new String[]{null,\"en\"});\n+        assertFalse(rep.get(field).hasNext());\n+    }\n+    /**\n+     * Checks if {@link Text} instances are correctly generated for String[].\n+     * This test depends also on the correct implementation of the\n+     * {@link Text#equals(Object)} method\n+     */\n+    @Test\n+    public void testStringArrayToTextConversion(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        ValueFactory vf = getValueFactory();\n+        Representation rep = createRepresentation(null);\n+        //test conversion of String[] with language as second element\n+        String[] textWithLang = new String[]{\"Test text with language\",\"en\"};\n+        rep.add(field, textWithLang);\n+        Iterator<Text> refs = rep.get(field,(String[])null);\n+        assertTrue(refs.hasNext());\n+        Text test = refs.next();\n+        assertEquals(textWithLang[1],test.getLanguage());\n+        assertEquals(textWithLang[0],test.getText());\n+        assertFalse(refs.hasNext());\n+        //test multiple adds do not generate duplicate References\n+        rep.add(field, textWithLang);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test adding a equivalent reference\n+        rep.add(field, vf.createText(textWithLang[0], textWithLang[1]));\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test removing\n+        rep.remove(field, textWithLang);\n+        assertFalse(rep.get(field).hasNext());\n+\n+        //test conversion of String[] with only one element (default language)\n+        String[] textWithoutLang = new String[]{\"Test text without language\"};\n+        rep.add(field, textWithoutLang);\n+        refs = rep.get(field,(String[])null);\n+        assertTrue(refs.hasNext());\n+        test = refs.next();\n+        assertNull(test.getLanguage());\n+        assertEquals(textWithoutLang[0],test.getText());\n+        assertFalse(refs.hasNext());\n+        //test multiple adds do not generate duplicate References\n+        rep.add(field, textWithoutLang);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test adding a equivalent reference\n+        rep.add(field, vf.createText(textWithoutLang[0]));\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test removing\n+        rep.remove(field, textWithoutLang);\n+        assertFalse(rep.get(field).hasNext());\n+\n+        //test conversion of String[] with null as second element (default language)\n+        String[] textWithDefaultLang = new String[]{\"Test text with default language\",null};\n+        rep.add(field, textWithDefaultLang);\n+        refs = rep.get(field,(String[])null);\n+        assertTrue(refs.hasNext());\n+        test = refs.next();\n+        assertNull(test.getLanguage());\n+        assertEquals(textWithDefaultLang[0],test.getText());\n+        assertFalse(refs.hasNext());\n+        //test multiple adds do not generate duplicate References\n+        rep.add(field, textWithDefaultLang);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test adding a equivalent reference\n+        rep.add(field, vf.createText(textWithDefaultLang[0], null));\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test removing\n+        rep.remove(field, textWithDefaultLang);\n+        assertFalse(rep.get(field).hasNext());\n+        \n+        //finally test if additional Elements are correctly ignored\n+        String[] ignoreAdditionalElements = new String[]{\"Test if additional elements are ignored\",\"en\",\"ignored1\",\"ignored2\",null,\"ignored4\"};\n+        String[] sameText = new String[]{\"Test if additional elements are ignored\",\"en\"};\n+        rep.add(field, ignoreAdditionalElements);\n+        refs = rep.get(field,(String[])null);\n+        assertTrue(refs.hasNext());\n+        test = refs.next();\n+        assertEquals(ignoreAdditionalElements[1],test.getLanguage());\n+        assertEquals(ignoreAdditionalElements[0],test.getText());\n+        assertFalse(refs.hasNext());\n+        //test multiple adds do not generate duplicate References\n+        rep.add(field, ignoreAdditionalElements);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test if an Array with only the first two elements generate the same Text\n+        rep.add(field, sameText);\n+        assertTrue(asCollection(rep.get(field)).size() == 1);\n+        //test removing\n+        rep.remove(field, ignoreAdditionalElements);\n+        assertFalse(rep.get(field).hasNext());\n+    }\n+    @Test\n+    public void testMultipleAddAndRemove() throws MalformedURLException, URISyntaxException{\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        ValueFactory vf = getValueFactory();\n+        Representation rep = createRepresentation(null);\n+        Reference ref = vf.createReference(\"http://www.test.org/test\");\n+        Text text = vf.createText(\"test\", \"en\");\n+        Integer i = 42;\n+        Double d = Math.PI;\n+        URI uri = new URI(\"http://www.test.org/uriTest\");\n+        URL url = new URL(\"http://www.test.org/urlTest\");\n+        String[] textAsArray = new String[]{\"Test text as Array\",\"en\"};\n+        Collection<Object> values = Arrays.asList(ref,text,i,d);\n+        Collection<Object> convertedValues = Arrays.asList((Object)url,uri,textAsArray);\n+        Collection<Object> allValues = Arrays.asList(ref,text,i,d,uri,url,textAsArray);\n+        //test adding of collections\n+        rep.add(field, values);\n+        assertTrue(asCollection(rep.get(field)).size() == 4);\n+        rep.remove(field, values);\n+        assertFalse(rep.get(field).hasNext());\n+        //test adding of Iterators\n+        rep.add(field, values.iterator());\n+        assertTrue(asCollection(rep.get(field)).size() == 4);\n+        rep.remove(field, values.iterator());\n+        assertFalse(rep.get(field).hasNext());\n+        //test adding of Enumerations\n+        Vector<Object> v = new Vector<Object>(values);\n+        rep.add(field, v.elements());\n+        assertTrue(asCollection(rep.get(field)).size() == 4);\n+        rep.remove(field, v.elements());\n+        assertFalse(rep.get(field).hasNext());\n+        //test adding and removing elements that need to be converted\n+        // only for collections this time -> want to test only converting is\n+        // applied for both add and remove\n+        rep.add(field, convertedValues);\n+        assertTrue(asCollection(rep.get(field)).size() == 3);\n+        rep.remove(field, convertedValues);\n+        assertFalse(rep.get(field).hasNext());\n+        //a final test to ensure, that remove does not only delete all values\n+        rep.add(field, allValues);\n+        assertTrue(asCollection(rep.get(field)).size() == 7);\n+        rep.remove(field,convertedValues);\n+        assertTrue(asCollection(rep.get(field)).size() == 4);\n+    }\n+    @Test\n+    public void testReferences(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Set<String> refs = new HashSet<String>(Arrays.asList(\n+            \"http://www.test.org/test1\",\n+            \"urn:test.org:test.1\"));\n+        Representation rep = createRepresentation(null);\n+        for(String ref:refs){\n+            rep.addReference(field, ref);\n+        }\n+        Iterator<Reference> refIterator = rep.getReferences(field);\n+        assertNotNull(refIterator);\n+        while(refIterator.hasNext()){\n+            Reference ref = refIterator.next();\n+            assertTrue(refs.remove(ref.getReference()));\n+        }\n+        assertTrue(refs.isEmpty());\n+    }\n+\n+    private static final String NL_TEST_string = \"String value that has to be treated similar as texts with no language\";\n+    private static final String NL_TEST_noLang = \"kani ofie sfgoeyd\";\n+    private static final String NL_TEST_en = \"This is an English text\";\n+    private static final String NL_TEST_en2 = \"A second English text\";\n+    private static final String NL_TEST_de = \"Das ist ein Deutscher Text\";\n+    private static final String NL_TEST_de_AT = \"Saig kent ma bei uns a nu ois Deutsch durch geh loss'n\";\n+    private static final Collection<String> NL_TEST_all = Arrays.asList(NL_TEST_string,NL_TEST_noLang,NL_TEST_en,NL_TEST_en2,NL_TEST_de,NL_TEST_de_AT);\n+    \n+    /**\n+     * Internally used to initialise the representation used for the various\n+     * tests for natural language texts.\n+     * Tests using this initialisation method expect the current configuration. \n+     * If one changes the values one needs also do adapt the according tests.\n+     * @param field the field used to add the test values\n+     * @param valueSet if not <code>null</code> the added values are added to this set\n+     * @return the initialised representation\n+     */\n+    private Representation initNaturalLanguageTest(String field){\n+        Representation rep = createRepresentation(null);\n+        rep.add(field, NL_TEST_string);\n+        rep.addNaturalText(field, NL_TEST_noLang);\n+        rep.addNaturalText(field, NL_TEST_en, \"en\");\n+        rep.addNaturalText(field, NL_TEST_en2, \"en\");\n+        rep.addNaturalText(field, NL_TEST_de, \"de\");\n+        rep.addNaturalText(field, NL_TEST_de_AT, \"de-AT\");\n+        return rep;\n+    }\n+    @Test\n+    public void testGetNaturalTextWithNoLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //Note that also String values need to be converted to texts with no language\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        Text text;\n+        Iterator<Text> noLangTexts = rep.get(field, (String)null);\n+        assertNotNull(noLangTexts);\n+        while(noLangTexts.hasNext()){\n+            text = noLangTexts.next();\n+            assertNull(text.getLanguage());\n+            assertTrue(textSet.remove(text.getText()));\n+        }\n+        assertTrue(textSet.size() == 4); //check that both text where found\n+    }\n+    @Test\n+    public void testGetNaturalTextWithLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //test de texts\n+        Iterator<Text> deTexts = rep.get(field, \"de\");\n+        assertNotNull(deTexts);\n+        assertTrue(deTexts.hasNext()); //there is one German text in the test set\n+        Text text = deTexts.next();\n+        assertEquals(text.getLanguage(), \"de\"); //\"de\" lang\n+        assertEquals(text.getText(), NL_TEST_de); //the de lang text\n+        assertFalse(deTexts.hasNext());//only one Result\n+        //test en labels (2 results)\n+        Iterator<Text> enTexts = rep.get(field, \"en\");\n+        assertNotNull(enTexts);\n+        Set<String> textSet = new HashSet<String>(Arrays.asList(NL_TEST_en,NL_TEST_en2));\n+        while(enTexts.hasNext()){\n+            text = enTexts.next();\n+            assertEquals(\"en\", text.getLanguage());\n+            assertTrue(textSet.remove(text.getText())); //remove the found\n+        }\n+        assertTrue(textSet.isEmpty()); //all texts found\n+    }\n+    @Test\n+    public void testGetNaturalTextWithMultipleLanguages(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //test multiple language query\n+        Iterator<Text> allDeTexts = rep.get(field, \"de\",\"de-AT\");\n+        assertNotNull(allDeTexts);\n+        Set<String> textSet = new HashSet<String>(Arrays.asList(NL_TEST_de,NL_TEST_de_AT));\n+        while(allDeTexts.hasNext()){\n+            Text text = allDeTexts.next();\n+            assertTrue(text.getLanguage().equals(\"de\") || text.getLanguage().equals(\"de-AT\"));\n+            assertTrue(textSet.remove(text.getText())); //remove the found\n+        }\n+        assertTrue(textSet.isEmpty()); //all texts found\n+    }\n+    @Test\n+    public void testGetNaturalTextWithLanguagesWithoutValues(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //test not present language\n+        Iterator<Text> esTexts = rep.get(field, \"es\");\n+        assertNotNull(esTexts);\n+        assertFalse(esTexts.hasNext());\n+        //test multiple not present languages\n+        Iterator<Text> frItTexts = rep.get(field, \"fr\",\"it\");\n+        assertNotNull(frItTexts);\n+        assertFalse(frItTexts.hasNext());\n+    }\n+    @Test\n+    public void testGetNaturalTextWithAnyLanguageByParsingAnEmptyArray(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //test Iterator for any language (by parsing an empty list)\n+        Iterator<Text> allTexts = rep.get(field, new String[]{});\n+        assertNotNull(allTexts);\n+        assertTrue(asCollection(allTexts).size() == NL_TEST_all.size());\n+    }\n+    @Test\n+    public void testGetNaturalTextWithAnyLanguageByParsingNullAsArray(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //test Iterator for any language (by parsing null)\n+        Iterator<Text> allTexts = rep.get(field, (String[])null);\n+        assertNotNull(allTexts);\n+        assertTrue(asCollection(allTexts).size() == NL_TEST_all.size());\n+    }\n+    @Test\n+    public void testRemoveNaturalTextWithWrongLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //Test removal of natural language\n+        //remove a specific test, but wrong language -> no effect\n+        rep.removeNaturalText(field, NL_TEST_en2, \"de\");\n+        assertTrue(asCollection(rep.get(field)).size() == NL_TEST_all.size());\n+    }\n+    @Test\n+    public void testRemoveNaturalTextWithWrongNullLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //remove a specific text, but with wrong null language -> also no effect\n+        rep.removeNaturalText(field, NL_TEST_de, (String)null);\n+        assertTrue(asCollection(rep.get(field)).size() == NL_TEST_all.size());\n+    }\n+    @Test\n+    public void testRemoveNaturalTextWithCorrectAndWrongLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //remove a specific text, parse one correct and one wrong lang\n+        rep.removeNaturalText(field, NL_TEST_en2, \"de\",\"en\");\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        //remove all remaining values\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        //and check that the value we expect to be removed is still in the set\n+        assertTrue(textSet.size() == 1);\n+        System.out.println(\"TextSet: \"+textSet);\n+        assertTrue(textSet.contains(NL_TEST_en2));\n+    }\n+    /**\n+     * String values are treated the same as natural language values with the\n+     * default (<code>null</code>) language. <br>\n+     * Removing a natural language value with parsing null as language MUST \n+     * therefore also remove a string value with the parse same text.\n+     */\n+    @Test\n+    public void testRemoveStringValuesByRemovingNaturalLanguageTextsWithNullLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+\n+        //remove a string value by parsing the text and null as language\n+        rep.removeNaturalText(field, NL_TEST_string, (String)null);\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        assertTrue(textSet.size() == 1); //only one element should be removed\n+        assertTrue(textSet.remove(NL_TEST_string)); //and this should be the stringTest\n+    }\n+    /**\n+     * String values are treated the same as natural language values with the\n+     * default (<code>null</code>) language. <br>\n+     * Removing a natural language value with no defined language MUST \n+     * therefore also remove a string value with the parse same text.\n+     */\n+    @Test\n+    public void testRemoveStringValuesByRemovingNaturalLanguageTextsWithNoLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        //remove a string value by parsing only the text\n+        rep.removeNaturalText(field, NL_TEST_string);\n+        textSet.addAll(Arrays.asList(NL_TEST_string,NL_TEST_noLang,NL_TEST_en,NL_TEST_en2,NL_TEST_de,NL_TEST_de_AT));\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        assertTrue(textSet.size() == 1); //only one element should be removed\n+        assertTrue(textSet.remove(NL_TEST_string)); //and this should be the stringTest\n+    }\n+    /**\n+     * String values are treated the same as natural language values with the\n+     * default (<code>null</code>) language. <br>\n+     * Removing a natural language value with an empty language array MUST be\n+     * interpreted as default language and therefore remove the String value.\n+     */\n+    @Test\n+    public void testRemoveStringValuesByRemovingNaturalLanguageTextsWithEmptyLanguageArray(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        //remove a string value by parsing an empty list of languages\n+        rep.removeNaturalText(field, NL_TEST_string, new String[]{});\n+        textSet.addAll(Arrays.asList(NL_TEST_string,NL_TEST_noLang,NL_TEST_en,NL_TEST_en2,NL_TEST_de,NL_TEST_de_AT));\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        assertTrue(textSet.size() == 1); //only one element should be removed\n+        assertTrue(textSet.remove(NL_TEST_string)); //and this should be the stringTest\n+        rep.add(field, NL_TEST_string); //re add the value for further tests\n+    }\n+    /**\n+     * Tests the feature to add one and the same natural language text for\n+     * multiple languages\n+     */\n+    public void testAddNaturalLanguageTextForMultipleLanguages(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        //add the same label for multiple language\n+        String[] languageArray = new String []{\"en\",\"de\",null};\n+        rep.addNaturalText(field, NL_TEST_noLang, languageArray);\n+        Set<String> languages = new HashSet<String>(Arrays.asList(languageArray));\n+        Iterator<Text> texts = rep.get(field, (String[])null);\n+        while(texts.hasNext()){\n+            Text text = texts.next();\n+            assertTrue(languages.remove(text.getLanguage()));\n+            assertEquals(NL_TEST_noLang, text.getText());\n+        }\n+        assertTrue(languages.isEmpty());\n+    }\n+    /**\n+     * Tests the feature to remove one and the same natural language text for\n+     * multiple languages\n+     */\n+    public void testRemoveNaturalLanguageValueInMultipleLanguages(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = createRepresentation(null);\n+        //add the same label for multiple languages\n+        rep.addNaturalText(field, NL_TEST_noLang, \"en\",\"de\",null);\n+        rep.removeNaturalText(field, NL_TEST_noLang, \"en\",null);\n+        Iterator<Text> texts = rep.get(field, (String[])null);\n+        assertTrue(texts.hasNext());\n+        Text text = texts.next();\n+        assertFalse(texts.hasNext());\n+        assertEquals(\"de\", text.getLanguage());\n+        assertEquals(NL_TEST_noLang, text.getText());\n+    }\n+    @Test\n+    public void testRemoveAllTextsOfALanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        //remove all texts of a specific language\n+        rep.removeAllNaturalText(field, \"en\");\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        assertTrue(textSet.size() == 2);\n+        assertTrue(textSet.remove(NL_TEST_en2));\n+        assertTrue(textSet.remove(NL_TEST_en));\n+    }\n+    @Test\n+    public void testRemoveAllTextsOfMultipleLanguages(){\n+        //remove all texts of multiple languages\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        rep.removeAllNaturalText(field, \"de\",\"de-AT\");\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        assertTrue(textSet.size() == 2);\n+        assertTrue(textSet.remove(NL_TEST_de));\n+        assertTrue(textSet.remove(NL_TEST_de_AT));\n+    }\n+    @Test\n+    public void testRemoveAllTextsWithNullLanguage(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        Set<String> textSet = new HashSet<String>(NL_TEST_all);\n+        //test removal of null language\n+        rep.removeAllNaturalText(field, (String)null);\n+        for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n+        assertTrue(textSet.size() == 2);\n+        assertTrue(textSet.remove(NL_TEST_noLang));\n+        assertTrue(textSet.remove(NL_TEST_string)); //and this should be the stringTest\n+    }\n+    @Test\n+    public void testRemoveAllNaturalLanguageValues(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //add a reference to ensure that only texts (and strings) are removed\n+        String testReference = \"http://www.test.org/test\";\n+        rep.addReference(field, testReference); \n+        //test removal of all natural language values by parsing no languages\n+        rep.removeAllNaturalText(field);\n+        Iterator<Text> texts = rep.get(field, (String[])null);\n+        assertFalse(texts.hasNext()); //not texts any more\n+        assertTrue(rep.get(field).hasNext()); //but still a reference!\n+    }\n+    @Test\n+    public void testRemoveAllNaturalLanguageValuesByParsingAnEmptyArray(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //add a reference to ensure that only texts (and strings) are removed\n+        String testReference = \"http://www.test.org/test\";\n+        rep.addReference(field, testReference); \n+        //test removal of all natural language values by parsing an empty language array\n+        rep.removeAllNaturalText(field, new String[]{});\n+        Iterator<Text> texts = rep.get(field, (String[])null);\n+        assertFalse(texts.hasNext());\n+        assertTrue(rep.get(field).hasNext()); //text of the added reference is still present\n+    }\n+    @Test\n+    public void testRemoveAllNaturalLanguageValuesByParsingNullAsLanguageArray(){\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation rep = initNaturalLanguageTest(field);\n+        //add a reference to ensure that only texts (and strings) are removed\n+        String testReference = \"http://www.test.org/test\";\n+        rep.addReference(field, testReference); \n+        //test removal of all natural language values by parsing only a single argument\n+        rep.removeAllNaturalText(field);\n+        Iterator<Text> texts = rep.get(field, (String[])null);\n+        assertFalse(texts.hasNext());\n+        assertTrue(rep.get(field).hasNext()); //text of the added reference is still present\n+    }\n+\n+    /**\n+     * Default ID for {@link Representation} used for testing\n+     */\n+    private static final String DEFAULT_REPRESENTATION_ID = \"urm:test:representation.defaultId\";\n+    /**\n+     * Creates a {@link Representation} instance by using the parsed ID or \n+     * {@link RepresentationTest#DEFAULT_REPRESENTATION_ID} if <code>null</code>\n+     * is parsed as ID.\n+     * @param id The ID or <code>null</code> to use the default ID\n+     * @return the Representation.\n+     */\n+    protected Representation createRepresentation(String id){\n+        if(id == null){\n+            id = DEFAULT_REPRESENTATION_ID;\n+        }\n+        return getValueFactory().createRepresentation(id);\n+    }\n+    /**\n+     * Converts an Iterator to a Collection by iterating over all elements and\n+     * adding them to a List.\n+     * @param <T>\n+     * @param it the iterator\n+     * @return the collection containing all elements of the iterator\n      */\n-    protected abstract Representation getEmptyRepresentation();\n+    protected static <T> Collection<T> asCollection(Iterator<T> it){\n+        Collection<T> c = new ArrayList<T>();\n+        while(it.hasNext()){\n+            c.add(it.next());\n+        }\n+        return c;\n+    };\n \n-    //TODO: Write the tests!\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/test/src/main/java/eu/iksproject/rick/test/model/RepresentationTest.java",
                "sha": "b5374d1a3c8f8c7740bc5a6aa79da35dcd945257",
                "status": "modified"
            },
            {
                "additions": 219,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/test/src/main/java/eu/iksproject/rick/test/model/ValueFactoryTest.java",
                "changes": 219,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/generic/test/src/main/java/eu/iksproject/rick/test/model/ValueFactoryTest.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/generic/test/src/main/java/eu/iksproject/rick/test/model/ValueFactoryTest.java",
                "patch": "@@ -0,0 +1,219 @@\n+package eu.iksproject.rick.test.model;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static junit.framework.Assert.assertNotNull;\n+import static junit.framework.Assert.assertNotSame;\n+import static junit.framework.Assert.assertNull;\n+import static junit.framework.Assert.assertTrue;\n+\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+\n+import org.junit.Test;\n+\n+import eu.iksproject.rick.servicesapi.model.Reference;\n+import eu.iksproject.rick.servicesapi.model.Representation;\n+import eu.iksproject.rick.servicesapi.model.Text;\n+import eu.iksproject.rick.servicesapi.model.UnsupportedTypeException;\n+import eu.iksproject.rick.servicesapi.model.ValueFactory;\n+import eu.iksproject.rick.servicesapi.yard.Yard;\n+\n+/**\n+ * General tests for instantiation of model instances by using the different\n+ * value factory methods.\n+ * This also tests the construction of implementation of {@link Reference},\n+ * {@link Text} and {@link Representation}.\n+ * For the immutable {@link Text} and {@link Reference} this tests are sufficient.\n+ * For Representations there is an own Test class\n+ * @author Rupert Westenthaler\n+ *\n+ */\n+public abstract class ValueFactoryTest {\n+    /**\n+     * Subclasses must implement this method and provide a {@link ValueFactory}\n+     * instance that is used to test the actual model implementation\n+     * @return the {@link ValueFactory} for the RICK model implementation to be\n+     * tested\n+     */\n+    protected abstract ValueFactory getValueFactory();\n+    /**\n+     * Returns an instance of a unsupported Type to be parsed to \n+     * {@link ValueFactory#createReference(Object)}. Used to check if this\n+     * Method correctly throws an {@link UnsupportedTypeException}\n+     * @return an instance of an unsupported type or <code>null</code> if all\n+     * types are supported\n+     */\n+    protected abstract Object getUnsupportedReferenceType();\n+    /**\n+     * Returns an instance of a unsupported Type to be parsed to\n+     * {@link ValueFactory#createText(Object)}. Used to check if this Method\n+     * correctly throws an {@link UnsupportedTypeException}\n+     * @return an instance of an unsupported type or <code>null</code> if all\n+     * types are supported\n+     */\n+    protected abstract Object getUnsupportedTextType();\n+    \n+    @Test(expected=NullPointerException.class)\n+    public void testNullReference(){\n+        testRef(null);\n+    }\n+    @Test(expected=UnsupportedTypeException.class)\n+    public void testUnsupportedReferenceType(){\n+        Object unsupported = getUnsupportedReferenceType();\n+        if(unsupported != null){\n+            testRef(unsupported);\n+        } else {\n+            // no unsupported types ... this test is not necessary \n+            // -> create a dummy exception\n+            //TODO: is there a way to deactivate a test if not valid\n+            throw new UnsupportedTypeException(Object.class, \n+                \"dummy exception to successfully complete this unnecessary test\");\n+        }\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyStringReference(){\n+        testRef(\"\");\n+    }\n+    @Test\n+    public void testStringReference(){\n+        Object refObject = \"urn:test.1\";\n+        Reference ref = testRef(refObject);\n+        assertEquals(ref.getReference(), refObject);\n+    }\n+    @Test\n+    public void testUriReference() throws URISyntaxException {\n+        URI refObject = new URI(\"http://www.test.org/uriTest\");\n+        Reference ref = testRef(refObject);\n+        assertEquals(ref.getReference(), refObject.toString());\n+    }\n+    @Test\n+    public void testURLReference() throws MalformedURLException {\n+        URL refObject = new URL(\"http://www.test.org/urlTest\");\n+        Reference ref = testRef(refObject);\n+        assertEquals(ref.getReference(), refObject.toString());\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullText(){\n+        testText(null, \"en\");\n+    }\n+    @Test\n+    public void testNullLanguage(){\n+        testText(\"test\", null);\n+    }\n+    @Test(expected=UnsupportedTypeException.class)\n+    public void testUnsupportedTextType(){\n+        Object unsupported  =getUnsupportedTextType();\n+        if(unsupported != null){\n+            getValueFactory().createText(unsupported);\n+        } else {\n+            // no unsupported types ... this test is not necessary \n+            // -> create a dummy exception\n+            //TODO: is there a way to deactivate a test if not valid\n+            throw new UnsupportedTypeException(Object.class, \n+                \"dummy exception to successfully complete this unnecessary test\");\n+        }\n+    }\n+    @Test\n+    public void testNormalText(){\n+        testText(\"test\",\"en\");\n+    }\n+    /**\n+     * Some Systems use an empty string for the default language,\n+     * other use <code>null</code>. Text does currently not define that\n+     * <code>null</code> need to be used as default language. However it does\n+     * define that <code>null</code> is a valid value for the language!<p>\n+     * Based on that RICK allows implementations to convert an empty language to\n+     * <code>null</code> but does NOT allow to to convert <code>null</code> to\n+     * an empty string.<p>\n+     * This test currently assures, that parsing an empty string as language\n+     * results in an empty string OR <code>null</code>. It also tests that\n+     * parsing an empty string as language does not result in an Exception.\n+     */\n+    @Test\n+    public void testEmptyLanguageText(){\n+        testText(\"test\",\"\");\n+    }\n+    /**\n+     * One can not create a Representation with <code>null</code> as ID.\n+     * NOTE: automatic generation of IDs is supported by the {@link Yard#create()}\n+     * but not by the {@link Representation} itself.\n+     */\n+    @Test(expected=NullPointerException.class)\n+    public void testNullIdRepresentation(){\n+        testRepresentation(null);\n+    }\n+    /**\n+     * One can not create a Representation with an emtpy ID\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testEmptyIdRepresentation(){\n+        testRepresentation(\"\");\n+    }\n+    @Test\n+    public void testMultipleInstanceForSameID(){\n+        Representation rep = testRepresentation(\"urn:testSameId\");\n+        Representation rep1 = testRepresentation(\"urn:testSameId\");\n+        //check that multiple calls with the same ID create different instances\n+        // -> this is very important to allow mapping of Representations (e.g.\n+        //    when they are stored within a cache\n+        assertNotSame(rep, rep1);\n+        //if an ID is parsed, than the two instance should be equal\n+        assertTrue(rep.equals(rep1));\n+        assertTrue(rep.hashCode() == rep1.hashCode()); //check the hash code\n+    }\n+    \n+    private Representation testRepresentation(String id){\n+        ValueFactory vf = getValueFactory();\n+        Representation rep = vf.createRepresentation(id);\n+        assertNotNull(rep);\n+        assertNotNull(rep.getId());\n+        if(id != null){\n+            assertEquals(rep.getId(), id);\n+        }\n+        return rep;\n+    }\n+    /**\n+     * Internally used to create and text {@link Text}s for the different tests\n+     * @param textString the natural language text as string\n+     * @param language the language\n+     * @return the created {@link Text} instance that can be used to perform\n+     * further tests.\n+     */\n+    private Text testText(String textString,String language){\n+        ValueFactory vf = getValueFactory();\n+        Text text = vf.createText(textString, language);\n+        assertNotNull(text.getText());\n+        assertNotNull(text.getText());\n+        assertEquals(text.getText(), textString);\n+        if(language == null){\n+            assertTrue(text.getLanguage() == null);\n+        } else if(language.isEmpty()){\n+            //implementations are free to change an empty language string to null\n+            //NOTE that it is not allowed to change NULL to an empty String!\n+            assertTrue(text.getLanguage() == null || text.getLanguage().isEmpty());\n+        } else {\n+            assertNotNull(text.getLanguage());\n+            assertEquals(text.getLanguage(), language);\n+        }\n+        return text;\n+    }\n+    /**\n+     * Internally used to create and test {@link Reference}s for the different tests\n+     * @param refObject the object representing the reference\n+     * @return the created {@link Reference} that can be used to perform further\n+     * tests.\n+     */\n+    private Reference testRef(Object refObject){\n+        ValueFactory vf = getValueFactory();\n+        Reference ref = vf.createReference(refObject);\n+        //check not null\n+        assertNotNull(ref);\n+        //check reference is not null\n+        assertNotNull(ref.getReference());\n+        return ref;\n+    }\n+\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/generic/test/src/main/java/eu/iksproject/rick/test/model/ValueFactoryTest.java",
                "sha": "74e31454ca53ac1c2eb9a067aef6cb4ca11406d3",
                "status": "added"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/dbPedia/src/main/java/eu/iksproject/rick/indexing/dbPedia/cli/CommandLineRunner.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/indexing/dbPedia/src/main/java/eu/iksproject/rick/indexing/dbPedia/cli/CommandLineRunner.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 1,
                "filename": "rick/indexing/dbPedia/src/main/java/eu/iksproject/rick/indexing/dbPedia/cli/CommandLineRunner.java",
                "patch": "@@ -236,7 +236,7 @@ public static void main(String[] args) throws IOException, ParseException, YardE\n         //50% of the entities are indexed!\n         if(line.hasOption(\"r\")){\n             //resume makes only really sense with the RANKING BASED MODE\n-            indexingConfig.put(KEY_ENTITY_RANKING_BASED_INDEXING_MODE, Boolean.TRUE);\n+            indexingConfig.put(KEY_INDEXING_MODE, IndexingMode.RANKING_MAP_BASED);\n             //set the RESUME MODE\n             indexingConfig.put(KEY_RESUME_MODE, Boolean.TRUE);\n         }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/dbPedia/src/main/java/eu/iksproject/rick/indexing/dbPedia/cli/CommandLineRunner.java",
                "sha": "b574f76b9d5eab48725f10e5b48569a4f5fc8502",
                "status": "modified"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/genericRdf/pom.xml",
                "changes": 60,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/indexing/genericRdf/pom.xml?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 44,
                "filename": "rick/indexing/genericRdf/pom.xml",
                "patch": "@@ -26,7 +26,8 @@\n   <version>0.1-SNAPSHOT</version>\n   <name>IKS RICK Indexing for rdf Resource</name>\n   <description>This indexes all kind of RDF sources by using a prased\n-  configuration (FieldMapper to define index fields and field values and a set of indexed rdf:types) configuration for processing Resources in the Graph.\n+  configuration (FieldMapper to define index fields and field values and a set \n+  of indexed rdf:types) configuration for processing Resources in the Graph.\n   </description>\n   <dependencies>\n     <dependency>\n@@ -44,50 +45,21 @@\n         <version>0.1-SNAPSHOT</version>\n     </dependency>\n     <dependency>\n-        <groupId>eu.iksproject</groupId>\n-        <artifactId>eu.iksproject.rick.core</artifactId>\n-        <version>0.1-SNAPSHOT</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.rdf.utils</artifactId>\n-      <version>0.13-incubating-SNAPSHOT</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.rdf.core</artifactId>\n-      <version>0.12-incubating-SNAPSHOT</version>\n-      <scope>provided</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.jaxrs.rdf.providers</artifactId>\n-      <version>0.13-incubating-SNAPSHOT</version>\n-      <scope>provided</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.rdf.jena.tdb.storage</artifactId>\n-      <version>0.5-incubating-SNAPSHOT</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.rdf.jena.serializer</artifactId>\n-      <version>0.9-incubating-SNAPSHOT</version>\n-      <scope>provided</scope>\n-    </dependency>\n-     <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.rdf.jena.parser</artifactId>\n-      <version>0.10-incubating-SNAPSHOT</version>\n-      <scope>provided</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.clerezza</groupId>\n-      <artifactId>org.apache.clerezza.rdf.rdfjson</artifactId>\n-      <version>0.3-incubating-SNAPSHOT</version>\n-      <scope>provided</scope>\n+      <groupId>com.hp.hpl.jena</groupId>\n+      <artifactId>jena</artifactId>\n+      <version>2.6.4</version>\n+      <exclusions>\n+        <exclusion>\n+          <artifactId>slf4j-log4j12</artifactId>\n+          <groupId>org.slf4j</groupId>\n+        </exclusion>\n+      </exclusions>\n     </dependency>\n+\t<dependency>\n+      <groupId>com.hp.hpl.jena</groupId>\n+\t  <artifactId>tdb</artifactId>\n+\t  <version>0.8.8</version>\n+    </dependency>  \n     <dependency>\n       <groupId>org.apache.commons</groupId>\n       <artifactId>commons-compress</artifactId>",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/genericRdf/pom.xml",
                "sha": "5845be9ff5211126b623efed516501dcb223ccb6",
                "status": "modified"
            },
            {
                "additions": 275,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexer.java",
                "changes": 567,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexer.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 292,
                "filename": "rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexer.java",
                "patch": "@@ -130,7 +130,7 @@\n      * @author Rupert Westenthaler\n      *\n      */\n-    public static enum IndexingMode{ REPLACE, APPEND }\n+    public static enum IndexingMode{ NORMAL, RANKING_MAP_BASED }\n \n     public static final String RDF_XML = \"application/rdf+xml\";\n     public static final String TURTLE = \"text/turtle\";\n@@ -192,299 +192,282 @@\n      * The {@link Object#toString()} method is used on elements to get the actual type!\n      */\n     public static final String KEY_RDF_TYPES = \"eu.iksproject.rick.indexing.rdf.indexedTypes\";\n-    /**\n-     * Key used to parse the indexing mode. Values should be of instance {@link IndexingMode}\n-     * or the {@link Object#toString()} value should be a member of this enum!\n-     */\n-    public static final String KEY_INDEXING_MODE = \"eu.iksproject.rick.indexing.rdf.indexingMode\";\n-    /**\n-     * If <code>true</code> than no RDF data are loaded. Instead it is assumed, that\n-     * the Graph of the parsed {@link #KEY_MODEL_NAME} already contains all the needed\n-     * data!<p>\n-     * This can be useful if one first wants to index rdf:type A and than rdf:type B\n-     * based on the same set of data\n-     */\n-    public static final String KEY_SKIP_READ = \"eu.iksproject.rick.indexing.rdf.skipRead\";\n-    /**\n-     * The number of {@link Representation}s stored at once in the SolrYard!\n-     */\n-    public static final String KEY_CHUNK_SIZE = \"eu.iksproject.rick.indexing.rdf.chunkSize\";\n-    /**\n-     * Can be used to parse a map with {@link String} entity id, {@link Float} rank\n-     * for entities.<p>\n-     * Such values are added to Representations for the {@link RdfResourceEnum#signRank}\n-     * field.\n-     */\n-    public static final String KEY_ENTITY_RANKINGS = \"eu.iksproject.rick.indexing.rdf.entityRankings\";\n-    /**\n-     * Can be used to activate ignoring of Entities without a page rank\n-     */\n-    public static final String KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING = \"eu.iksproject.rick.indexing.rdf.ignoreEntitiesWithoutRankings\";\n-    /**\n-     * If set to a value >= 0 this is used to exclude Entities with a lower or\n-     * missing entity rank\n-     */\n-    public static final String KEY_REQUIRED_ENTITY_RANKING = \"eu.iksproject.rick.indexing.rdf.requiredRanking\";\n-    /**\n-     * The rank for entities with a missing rank. This takes only effect if\n-     * {@link #KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING} is set to <code>false</code>\n-     * (the default)\n-     */\n-    public static final String KEY_DEFAULT_ENTITY_RANKING = \"eu.iksproject.rick.indexing.rdf.defaultRanking\";\n-    /**\n-     * Expert only: This allows to enable indexing based on the keys in the map parsed with the\n-     * entity rankings. This will only index entities that are keys in that map.\n-     * If no Map is parsed by {@link #KEY_ENTITY_RANKINGS}, than activating this mode\n-     * will not be successful and a warning will be written.<p>\n-     * This mode is about 50% slower than the usual indexing mode. Therefore this\n-     * mode makes only sense id less than 50% of the entities are indexed.\n-     */\n-    public static final String KEY_ENTITY_RANKING_BASED_INDEXING_MODE = \"eu.iksproject.rick.indexing.rdf.rankingBasedIndexingMode\";\n-    /**\n-     * The resume Mode first checks if a Resource is already present in the parsed\n-     * Yard. If this is the case, than the representation is not indexes again.<p>\n-     * This mode is intended to resume indexing after stopping a previous call before\n-     * finished. The default value = false.\n-     */\n-    public static final String KEY_RESUME_MODE = \"eu.iksproject.rick.indexing.rdf.resumeMode\";\n-\n-    private final IndexingMode indexingMode;\n-    private final Yard yard;\n-    private final ValueFactory vf;\n-    private final List<File> rdfFiles;\n-    private final File indexingDir;\n-    private final String modelName;\n-//    private final ParsingProvider parser = new JenaParserProvider();\n-    //private final WeightedTcProvider provider;\n-    private final FieldMapper mapper;\n-    private final Set<String> types;\n-    //private MGraph indexingGraph;\n-    private final DatasetGraphTDB indexingDataset;\n-    private final boolean skipRead;\n-    private Location modelLocation;\n-    private int indexingChunkSize = 1000;\n+\t/**\n+\t * Expert only: This allows to set the indexing based on the keys in the map parsed with the\n+\t * entity rankings. This will only index entities that are keys in that map.\n+\t * If no Map is parsed by {@link #KEY_ENTITY_RANKINGS}, than activating this mode\n+\t * will not be successful and a warning will be written.<p>\n+\t * This mode is about 50% slower than the usual indexing mode. Therefore this\n+\t * mode makes only sense id less than 50% of the entities are indexed.\n+\t */\n+\tpublic static final String KEY_INDEXING_MODE = \"eu.iksproject.rick.indexing.rdf.indexingMode\";\n+\t/**\n+\t * If <code>true</code> than no RDF data are loaded. Instead it is assumed, that\n+\t * the Graph of the parsed {@link #KEY_MODEL_NAME} already contains all the needed\n+\t * data!<p>\n+\t * This can be useful if one first wants to index rdf:type A and than rdf:type B\n+\t * based on the same set of data\n+\t */\n+\tpublic static final String KEY_SKIP_READ = \"eu.iksproject.rick.indexing.rdf.skipRead\";\n+\t/**\n+\t * The number of {@link Representation}s stored at once in the SolrYard!\n+\t */\n+\tpublic static final String KEY_CHUNK_SIZE = \"eu.iksproject.rick.indexing.rdf.chunkSize\";\n+\t/**\n+\t * Can be used to parse a map with {@link String} entity id, {@link Float} rank\n+\t * for entities.<p>\n+\t * Such values are added to Representations for the {@link RdfResourceEnum#signRank}\n+\t * field.\n+\t */\n+\tpublic static final String KEY_ENTITY_RANKINGS = \"eu.iksproject.rick.indexing.rdf.entityRankings\";\n+\t/**\n+\t * Can be used to activate ignoring of Entities without a page rank\n+\t */\n+\tpublic static final String KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING = \"eu.iksproject.rick.indexing.rdf.ignoreEntitiesWithoutRankings\";\n+\t/**\n+\t * If set to a value >= 0 this is used to exclude Entities with a lower or \n+\t * missing entity rank\n+\t */\n+\tpublic static final String KEY_REQUIRED_ENTITY_RANKING = \"eu.iksproject.rick.indexing.rdf.requiredRanking\";\n+\t/**\n+\t * The rank for entities with a missing rank. This takes only effect if\n+\t * {@link #KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING} is set to <code>false</code>\n+\t * (the default)\n+\t */\n+\tpublic static final String KEY_DEFAULT_ENTITY_RANKING = \"eu.iksproject.rick.indexing.rdf.defaultRanking\";\n+\t/**\n+\t * The resume Mode first checks if a Resource is already present in the parsed\n+\t * Yard. If this is the case, than the representation is not indexes again.<p>\n+\t * This mode is intended to resume indexing after stopping a previous call before\n+\t * finished. The default value = false.\n+\t */\n+\tpublic static final String KEY_RESUME_MODE = \"eu.iksproject.rick.indexing.rdf.resumeMode\";\n+\t\n+\tprivate final IndexingMode indexingMode;\n+\tprivate final Yard yard;\n+\tprivate final ValueFactory vf;\n+\tprivate final List<File> rdfFiles;\n+\tprivate final File indexingDir;\n+\tprivate final String modelName;\n+//\tprivate final ParsingProvider parser = new JenaParserProvider();\n+\t//private final WeightedTcProvider provider;\n+\tprivate final FieldMapper mapper;\n+\tprivate final Set<String> types;\n+\t//private MGraph indexingGraph;\n+\tprivate final DatasetGraphTDB indexingDataset;\n+\tprivate final boolean skipRead;\n+\tprivate Location modelLocation;\n+\tprivate int indexingChunkSize = 1000;\n+\t\n+\t//vars for entity rankings\n+\tprivate Map<String,Float> entityRankings = null;\n+\tprivate boolean ignoreEntitiesWithoutRank = false;\n+\tprivate float defaultEntityRanking = -1;\n+\tprivate String entityRankingField = RdfResourceEnum.signRank.getUri();\n+\tprivate float minimumRequiredEntityRanking = -1;\n+\tprivate boolean resumeMode;\n+\t\n+\t\n+\tpublic RdfIndexer(Dictionary<String, Object> config){\n+\t\tthis.yard = (Yard)config.get(KEY_YARD);\n+\t\tif(yard == null){\n+\t\t\tthrow new IllegalArgumentException(\"Parsed config MUST CONTAIN a Yard. Use the key \"+KEY_YARD+\" to parse the YardInstance used to store the geonames.org index!\");\n+\t\t} else {\n+\t\t\tlog.info(String.format(\"Using Yard %s (id=%s) to index parsed RDF data\",\n+\t\t\t\t\tyard.getName(),yard.getId()));\n+\t\t}\n+\t\tthis.vf = yard.getValueFactory();\n+\t\tObject rdfFiles = config.get(KEY_RDF_FILES);\n+\t\tif(rdfFiles instanceof Iterable<?>){\n+\t\t\tthis.rdfFiles = new ArrayList<File>();\n+\t\t\tfor(Object value : (Iterable<?>)rdfFiles){\n+\t\t\t\tthis.rdfFiles.add(checkFile(value.toString()));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthis.rdfFiles = Collections.singletonList(checkFile(rdfFiles.toString()));\n+\t\t}\n+\t\tObject indexingDir = config.get(KEY_RDF_STORE_DIR);\n+\t\tif(indexingDir == null){\n+\t\t\tindexingDir = \"indexingData\";\n+\t\t\tconfig.put(KEY_RDF_STORE_DIR, indexingDir);\n+\t\t}\n+\t\tthis.indexingDir = checkFile(indexingDir.toString(), false, true);\n+\t\tObject modelName = config.get(KEY_MODEL_NAME);\n+\t\tif(modelName == null){\n+\t\t\tmodelName = \"indexingModel-\"+ModelUtils.randomUUID().toString();\n+\t\t\tconfig.put(KEY_MODEL_NAME, modelName);\n+\t\t}\n+\t\tthis.modelName = modelName.toString();\n+\t\t//init the types!\n+\t\tIterable<?> types = (Iterable<?>)config.get(KEY_RDF_TYPES);\n+\t\tif(types != null){\n+\t\t\tSet<String> typeSet = new HashSet<String>();\n+\t\t\tfor(Object type : types){\n+\t\t\t\tif(type != null){\n+\t\t\t\t\ttypeSet.add(type.toString());\n+\t\t\t\t\tlog.info(\"  - adding Resoures with rdf:type \"+type);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(typeSet.isEmpty()){\n+\t\t\t\tlog.info(\"  - adding all Types (no rdf:type based restriction for RDF Reseource present)\");\n+\t\t\t\tthis.types = null;\n+\t\t\t} else {\n+\t\t\t\tthis.types = typeSet;\n+\t\t\t}\n+\t\t} else{\n+\t\t\tlog.info(\"  - adding all Types (no rdf:type based restriction for RDF Reseource present)\");\n+\t\t\tthis.types = null; //null or an iterable with one or more elements!\n+\t\t}\n+\t\t//init the indexing mode\n+\t\tObject indexingMode = config.get(KEY_INDEXING_MODE);\n+\t\tif(indexingMode == null){\n+\t\t\tthis.indexingMode = IndexingMode.NORMAL; //default to replace\n+\t\t} else if(indexingMode instanceof IndexingMode){\n+\t\t\tthis.indexingMode = (IndexingMode)indexingMode;\n+\t\t} else {\n+\t\t\ttry {\n+\t\t\t\tthis.indexingMode = IndexingMode.valueOf(indexingMode.toString());\n+\t\t\t}catch (IllegalArgumentException e) {\n+\t\t\t\t//catch and re-throw with a better message!\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tString.format(\"Values of KEY \\\"%s\\\" MUST BE of Type %s or the toString() value MUST BE a member of this Enumeration. If the Key is missing %s is used!\",\n+\t\t\t\t\t\t\t\tKEY_INDEXING_MODE,IndexingMode.class,IndexingMode.NORMAL),e);\n+\t\t\t}\n+\t\t}\n+\t\t//init the fieldMapper\n+\t\tIterable<?> mappings = (Iterable<?>)config.get(KEY_FIELD_MAPPINGS);\n+\t\tList<FieldMapping> fieldMappings;\n+\t\tif(mappings != null){\n+\t\t\tfieldMappings = new ArrayList<FieldMapping>();\n+\t\t\tfor(Object mappingString : mappings){\n+\t\t\t\tif(mappingString != null){\n+\t\t\t\t\tFieldMapping fieldMapping = FieldMappingUtils.parseFieldMapping(mappingString.toString());\n+\t\t\t\t\tif(fieldMapping != null){\n+\t\t\t\t\t\tfieldMappings.add(fieldMapping);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(!fieldMappings.isEmpty()){\n+\t\t\t\tthis.mapper = new DefaultFieldMapperImpl(ValueConverterFactory.getInstance(vf));\n+\t\t\t\tfor(FieldMapping mapping : fieldMappings){\n+\t\t\t\t\tmapper.addMapping(mapping);\n+\t\t\t\t}\n+\t\t\t\t//we need to add a mapping for the field rankings (if a mapper is present)\n+\t\t\t\tmapper.addMapping(new FieldMapping(this.entityRankingField));\n+\t\t\t} else {\n+\t\t\t\tthis.mapper = null;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthis.mapper = null;\n+\t\t}\n+\t\tFile modelDir = new File(this.indexingDir,this.modelName);\n+\t\tif(!modelDir.exists()){\n+\t\t\tmodelDir.mkdir();\n+\t\t} else if(!modelDir.isDirectory()){\n+\t\t\tthrow new IllegalStateException(String.format(\"A directory for %s already exists but is not a directory!\",modelDir.getAbsoluteFile()));\n+\t\t} //else exists and is a dir -> nothing to do\n+\t\tObject skipRead = config.get(KEY_SKIP_READ);\n+\t\tif(skipRead != null){\n+\t\t\tif(skipRead instanceof Boolean){\n+\t\t\t\tthis.skipRead = ((Boolean)skipRead).booleanValue();\n+\t\t\t} else {\n+\t\t\t\tthis.skipRead = Boolean.parseBoolean(skipRead.toString());\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthis.skipRead = false;\n+\t\t}\n+\t\tInteger chunkSize = (Integer)config.get(KEY_CHUNK_SIZE);\n+\t\tif(chunkSize != null && chunkSize>0){\n+\t\t\tthis.indexingChunkSize = chunkSize;\n+\t\t} //else use default value of 1000\n \n-    //vars for entity rankings\n-    private Map<String,Float> entityRankings = null;\n-    private boolean ignoreEntitiesWithoutRank = false;\n-    private float defaultEntityRanking = -1;\n-    private String entityRankingField = RdfResourceEnum.signRank.getUri();\n-    private float minimumRequiredEntityRanking = -1;\n-    private boolean rankingMode;\n-    private boolean resumeMode;\n+\t\tthis.modelLocation = new Location(modelDir.getAbsolutePath());\n+\t\tthis.indexingDataset =  TDBFactory.createDatasetGraph(modelLocation) ;\n+\t\t//this.provider = new IndexingModelProvider(this.indexingDir);\n+\t\t\n+\t\t//init entity Ranking\n+\t\ttry{\n+\t\t\tthis.entityRankings = (Map<String,Float>)config.get(KEY_ENTITY_RANKINGS);\n+\t\t}catch (RuntimeException e) {\n+\t\t\tlog.error(\"Parsed Entity Rankings MUST use the form Map<String,Float>\");\n+\t\t\tSystem.exit(0);\n+\t\t}\n+\t\tObject ignore = config.get(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING);\n+\t\tif(ignore != null){\n+\t\t\tif(ignore instanceof Boolean){\n+\t\t\t\tthis.ignoreEntitiesWithoutRank = (Boolean)ignore;\n+\t\t\t} else {\n+\t\t\t\tthis.ignoreEntitiesWithoutRank = Boolean.parseBoolean(ignore.toString());\n+\t\t\t}\n+\t\t}\n+\t\tObject defaultRankingObject = config.get(KEY_DEFAULT_ENTITY_RANKING);\n+\t\tif(defaultRankingObject != null){\n+\t\t\tfloat defaultranking = -1;\n+\t\t\tif(defaultRankingObject instanceof Float){\n+\t\t\t\tdefaultranking = (Float)defaultRankingObject;\n+\t\t\t} else {\n+\t\t\t\ttry {\n+\t\t\t\t\tdefaultranking = Float.parseFloat(defaultRankingObject.toString());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tlog.error(\"Unable to parse Float value for the Default Entity Ranking from the value parsed for the KEY_DEFAULT_ENTITY_RANKING key (value: \"+defaultRankingObject+\")\");\n+\t\t\t\t\tSystem.exit(0);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.defaultEntityRanking = defaultranking;\n+\t\t}\n+\t\tObject minimumRequiredRankingObject = config.get(KEY_REQUIRED_ENTITY_RANKING);\n+\t\tif(minimumRequiredRankingObject != null){\n+\t\t\tfloat minRanking = -1;\n+\t\t\tif(minimumRequiredRankingObject instanceof Float){\n+\t\t\t\tminRanking = (Float)minimumRequiredRankingObject;\n+\t\t\t} else {\n+\t\t\t\ttry {\n+\t\t\t\t\tminRanking = Float.parseFloat(minimumRequiredRankingObject.toString());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tlog.error(\"Unable to parse Float value for the Minimum Required Entity Ranking from the value parsed for the KEY_DEFAULT_ENTITY_RANKING key (value: \"+minimumRequiredRankingObject+\")\");\n+\t\t\t\t\tSystem.exit(0);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(minRanking>=0){ //setting a valid required ranking automatically\n+\t\t\t\t//means that entities without a rank should be ignored!\n+\t\t\t\tthis.ignoreEntitiesWithoutRank = true;\n+\t\t\t}\n+\t\t\tthis.minimumRequiredEntityRanking = minRanking;\n+\t\t}\n \n-\n-    public RdfIndexer(Dictionary<String, Object> config){\n-        this.yard = (Yard)config.get(KEY_YARD);\n-        if(yard == null){\n-            throw new IllegalArgumentException(\"Parsed config MUST CONTAIN a Yard. Use the key \"+KEY_YARD+\" to parse the YardInstance used to store the geonames.org index!\");\n-        } else {\n-            log.info(String.format(\"Using Yard %s (id=%s) to index parsed RDF data\",\n-                    yard.getName(),yard.getId()));\n-        }\n-        this.vf = yard.getValueFactory();\n-        Object rdfFiles = config.get(KEY_RDF_FILES);\n-        if(rdfFiles instanceof Iterable<?>){\n-            this.rdfFiles = new ArrayList<File>();\n-            for(Object value : (Iterable<?>)rdfFiles){\n-                this.rdfFiles.add(checkFile(value.toString()));\n-            }\n-        } else {\n-            this.rdfFiles = Collections.singletonList(checkFile(rdfFiles.toString()));\n-        }\n-        Object indexingDir = config.get(KEY_RDF_STORE_DIR);\n-        if(indexingDir == null){\n-            indexingDir = \"indexingData\";\n-            config.put(KEY_RDF_STORE_DIR, indexingDir);\n-        }\n-        this.indexingDir = checkFile(indexingDir.toString(), false, true);\n-        Object modelName = config.get(KEY_MODEL_NAME);\n-        if(modelName == null){\n-            modelName = \"indexingModel-\"+ModelUtils.randomUUID().toString();\n-            config.put(KEY_MODEL_NAME, modelName);\n-        }\n-        this.modelName = modelName.toString();\n-        //init the types!\n-        Iterable<?> types = (Iterable<?>)config.get(KEY_RDF_TYPES);\n-        if(types != null){\n-            Set<String> typeSet = new HashSet<String>();\n-            for(Object type : types){\n-                if(type != null){\n-                    typeSet.add(type.toString());\n-                    log.info(\"  - adding Resoures with rdf:type \"+type);\n-                }\n-            }\n-            if(typeSet.isEmpty()){\n-                log.info(\"  - adding all Types (no rdf:type based restriction for RDF Reseource present)\");\n-                this.types = null;\n-            } else {\n-                this.types = typeSet;\n-            }\n-        } else{\n-            log.info(\"  - adding all Types (no rdf:type based restriction for RDF Reseource present)\");\n-            this.types = null; //null or an iterable with one or more elements!\n-        }\n-        //init the indexing mode\n-        Object indexingMode = config.get(KEY_INDEXING_MODE);\n-        if(indexingMode == null){\n-            this.indexingMode = IndexingMode.REPLACE; //default to replace\n-        } else if(indexingMode instanceof IndexingMode){\n-            this.indexingMode = (IndexingMode)indexingMode;\n-        } else {\n-            try {\n-                this.indexingMode = IndexingMode.valueOf(indexingMode.toString());\n-            }catch (IllegalArgumentException e) {\n-                //catch and re-throw with a better message!\n-                throw new IllegalArgumentException(\n-                        String.format(\"Values of KEY \\\"%s\\\" MUST BE of Type %s or the toString() value MUST BE a member of this Enumeration. If the Key is missing %s is used!\",\n-                                KEY_INDEXING_MODE,IndexingMode.class,IndexingMode.REPLACE),e);\n-            }\n-        }\n-        //init the fieldMapper\n-        Iterable<?> mappings = (Iterable<?>)config.get(KEY_FIELD_MAPPINGS);\n-        List<FieldMapping> fieldMappings;\n-        if(mappings != null){\n-            fieldMappings = new ArrayList<FieldMapping>();\n-            for(Object mappingString : mappings){\n-                if(mappingString != null){\n-                    FieldMapping fieldMapping = FieldMappingUtils.parseFieldMapping(mappingString.toString());\n-                    if(fieldMapping != null){\n-                        fieldMappings.add(fieldMapping);\n-                    }\n-                }\n-            }\n-            if(!fieldMappings.isEmpty()){\n-                this.mapper = new DefaultFieldMapperImpl(ValueConverterFactory.getInstance(vf));\n-                for(FieldMapping mapping : fieldMappings){\n-                    mapper.addMapping(mapping);\n-                }\n-                //we need to add a mapping for the field rankings (if a mapper is present)\n-                mapper.addMapping(new FieldMapping(this.entityRankingField));\n-            } else {\n-                this.mapper = null;\n-            }\n-        } else {\n-            this.mapper = null;\n-        }\n-        File modelDir = new File(this.indexingDir,this.modelName);\n-        if(!modelDir.exists()){\n-            modelDir.mkdir();\n-        } else if(!modelDir.isDirectory()){\n-            throw new IllegalStateException(String.format(\"A directory for %s already exists but is not a directory!\",modelDir.getAbsoluteFile()));\n-        } //else exists and is a dir -> nothing to do\n-        Object skipRead = config.get(KEY_SKIP_READ);\n-        if(skipRead != null){\n-            if(skipRead instanceof Boolean){\n-                this.skipRead = ((Boolean)skipRead).booleanValue();\n-            } else {\n-                this.skipRead = Boolean.parseBoolean(skipRead.toString());\n-            }\n-        } else {\n-            this.skipRead = false;\n-        }\n-        Integer chunkSize = (Integer)config.get(KEY_CHUNK_SIZE);\n-        if(chunkSize != null && chunkSize>0){\n-            this.indexingChunkSize = chunkSize;\n-        } //else use default value of 1000\n-\n-        this.modelLocation = new Location(modelDir.getAbsolutePath());\n-        this.indexingDataset =  TDBFactory.createDatasetGraph(modelLocation) ;\n-        //this.provider = new IndexingModelProvider(this.indexingDir);\n-\n-        //init entity Ranking\n-        try{\n-            this.entityRankings = (Map<String,Float>)config.get(KEY_ENTITY_RANKINGS);\n-        }catch (RuntimeException e) {\n-            log.error(\"Parsed Entity Rankings MUST use the form Map<String,Float>\");\n-            System.exit(0);\n-        }\n-        Object ignore = config.get(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING);\n-        if(ignore != null){\n-            if(ignore instanceof Boolean){\n-                this.ignoreEntitiesWithoutRank = (Boolean)ignore;\n-            } else {\n-                this.ignoreEntitiesWithoutRank = Boolean.parseBoolean(ignore.toString());\n-            }\n-        }\n-        Object defaultRankingObject = config.get(KEY_DEFAULT_ENTITY_RANKING);\n-        if(defaultRankingObject != null){\n-            float defaultranking = -1;\n-            if(defaultRankingObject instanceof Float){\n-                defaultranking = (Float)defaultRankingObject;\n-            } else {\n-                try {\n-                    defaultranking = Float.parseFloat(defaultRankingObject.toString());\n-                } catch (Exception e) {\n-                    log.error(\"Unable to parse Float value for the Default Entity Ranking from the value parsed for the KEY_DEFAULT_ENTITY_RANKING key (value: \"+defaultRankingObject+\")\");\n-                    System.exit(0);\n-                }\n-            }\n-            this.defaultEntityRanking = defaultranking;\n-        }\n-        Object minimumRequiredRankingObject = config.get(KEY_REQUIRED_ENTITY_RANKING);\n-        if(minimumRequiredRankingObject != null){\n-            float minRanking = -1;\n-            if(minimumRequiredRankingObject instanceof Float){\n-                minRanking = (Float)minimumRequiredRankingObject;\n-            } else {\n-                try {\n-                    minRanking = Float.parseFloat(minimumRequiredRankingObject.toString());\n-                } catch (Exception e) {\n-                    log.error(\"Unable to parse Float value for the Minimum Required Entity Ranking from the value parsed for the KEY_DEFAULT_ENTITY_RANKING key (value: \"+minimumRequiredRankingObject+\")\");\n-                    System.exit(0);\n-                }\n-            }\n-            if(minRanking>=0){ //setting a valid required ranking automatically\n-                //means that entities without a rank should be ignored!\n-                this.ignoreEntitiesWithoutRank = true;\n-            }\n-            this.minimumRequiredEntityRanking = minRanking;\n-        }\n-        Object rankingMode = config.get(KEY_ENTITY_RANKING_BASED_INDEXING_MODE);\n-        if(rankingMode != null){\n-            if(rankingMode instanceof Boolean){\n-                this.rankingMode = (Boolean)rankingMode;\n-            } else {\n-                this.rankingMode = Boolean.parseBoolean(rankingMode.toString());\n-            }\n-        }\n-        if(this.rankingMode && this.entityRankings == null){\n-            log.warn(\"The Entity Ranking based Indexing Mode can not be activated if no EntityRankings are parsed! -> deactivate Ranking Mode (intertes over all Resources in the RDF Data)\");\n-            this.rankingMode = false;\n-        }\n-        Object resumeMode = config.get(KEY_RESUME_MODE);\n-        if(resumeMode != null) {\n-            if(resumeMode instanceof Boolean){\n-                this.resumeMode = (Boolean)resumeMode;\n-            } else {\n-                this.resumeMode = Boolean.parseBoolean(resumeMode.toString());\n-            }\n-        } else {\n-            this.resumeMode = false;\n-        }\n-    }\n-    public void index() throws YardException{\n-        log.info(\"initialize ...\");\n-        if(!skipRead){\n-            loadRdfFiles();\n-        } else {\n-            log.info(\" ... skiping loading of RDF data\");\n-        }\n-        if(rankingMode){\n-            indexRanked();\n-        } else {\n-            indexResources();\n-        }\n-        writeCacheBaseConfiguration();\n-    }\n-    /**\n-     * This Method is used to process the RDF Data if all Resource can be indexed,\n-     * because it provides the best performance. Mainly because it reads everything\n-     * from a single stream and therefore gives the OS the best opportunities to\n-     * optimise file access.\n-     * @throws YardException\n-     */\n-    private void indexResources() throws YardException{\n+\t\tObject resumeMode = config.get(KEY_RESUME_MODE);\n+\t\tif(resumeMode != null) {\n+\t\t\tif(resumeMode instanceof Boolean){\n+\t\t\t\tthis.resumeMode = (Boolean)resumeMode;\n+\t\t\t} else {\n+\t\t\t\tthis.resumeMode = Boolean.parseBoolean(resumeMode.toString());\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthis.resumeMode = false;\n+\t\t}\n+\t}\n+\tpublic void index() throws YardException{\n+\t\tlog.info(\"initialize ...\");\n+\t\tif(!skipRead){\n+\t\t\tloadRdfFiles();\n+\t\t} else {\n+\t\t\tlog.info(\" ... skiping loading of RDF data\");\n+\t\t}\n+\t\tif(indexingMode == IndexingMode.RANKING_MAP_BASED){\n+\t\t\tindexRanked();\n+\t\t} else {\n+\t\t\tindexResources();\n+\t\t}\n+\t\twriteCacheBaseConfiguration();\n+\t}\n+\t/**\n+\t * This Method is used to process the RDF Data if all Resource can be indexed,\n+\t * because it provides the best performance. Mainly because it reads everything\n+\t * from a single stream and therefore gives the OS the best opportunities to\n+\t * optimise file access.\n+\t * @throws YardException\n+\t */\n+\tprivate void indexResources() throws YardException{\n         StringBuilder qb = new StringBuilder();\n         /*\n          * NOTES:",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexer.java",
                "sha": "9d70a5f3fd95c99f99ef8fcd5a7b54a649f4bdf6",
                "status": "modified"
            },
            {
                "additions": 408,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexerConfig.java",
                "changes": 408,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexerConfig.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexerConfig.java",
                "patch": "@@ -0,0 +1,408 @@\n+package eu.iksproject.rick.indexing.rdf;\n+\n+import static eu.iksproject.rick.indexing.rdf.RdfIndexer.*;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Dictionary;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import eu.iksproject.rick.core.mapping.FieldMappingUtils;\n+import eu.iksproject.rick.servicesapi.mapping.FieldMapper;\n+import eu.iksproject.rick.servicesapi.mapping.FieldMapping;\n+import eu.iksproject.rick.servicesapi.model.Representation;\n+import eu.iksproject.rick.servicesapi.model.rdf.RdfResourceEnum;\n+import eu.iksproject.rick.servicesapi.yard.Yard;\n+\n+/**\n+ * API based Configuration for the {@link Dictionary} based configuration of the \n+ * {@link RdfIndexer} class.\n+ * \n+ * @author Rupert Westenthaler\n+ * \n+ */\n+public class RdfIndexerConfig {\n+    \n+    Logger log = LoggerFactory.getLogger(RdfIndexerConfig.class);\n+    Dictionary<String,Object> config = new Hashtable<String,Object>();\n+    \n+/**\n+     * Constructs a minimal configuration for a Yard and a list of RDF Files\n+     * to be indexed. Parsed files are checked for existences and read access.<p>\n+     * Note that:<ul>\n+     * <li><code>{@link Yard#getId()}+\"_indexingData\"</code> is used as the\n+     * directory for indexing (use {@link #setIndexingDir(File)} to change this\n+     * default).\n+     * <li><code>{@link Yard#getId()}+\"_model\"</code> is used as modelName for\n+     * the name of the Model (use {@link #setModelName(String)} to change this\n+     * default).\n+     * <li> if the list of the parsed files is <code>null</code> or empty, than\n+     * the {@link #setSkipRead(Boolean) is set to <code>true</code>. This means\n+     * that it is assumed that the RDF Model (name: #getModelName() and part of\n+     * the RDF triple store located at #getIndexingDir()) already contains all\n+     * the RDF data needed for the indexing. Otherwise the all parsed files are\n+     * checked for existence and read access and #setSkipRead(Boolean) is set to\n+     * <code>false</code>. This will trigger to read the RDF data of that files\n+     * to be stored in the RDF model with the configured name and the Triple\n+     * Store with the configured location.\n+     * </ul>\n+     * @param yard The {@link Yard} used to store the RDF data\n+     * @param rdfFiles the RDF files to index.\n+     */\n+    public RdfIndexerConfig(Yard yard, File... rdfFiles) {\n+        if (yard == null) {\n+            throw new IllegalArgumentException(\"The parsed Yard MUST NOT be NULL\");\n+        }\n+        config.put(KEY_YARD, yard);\n+        setIndexingDir(new File(yard.getId() + \"_indexingData\"));\n+        setModelName(yard.getId() + \"_model\");\n+        if (rdfFiles == null || rdfFiles.length < 1) {\n+            log.info(\"no RDF Files parsed -> set skipRead to TRUE\");\n+            setSkipRead(Boolean.TRUE);\n+        } else {\n+            addSourceFile(rdfFiles);\n+        }\n+    }\n+    \n+    /**\n+     * Adds the parsed source files. Checks for {@link File#exists()}, {@link File#isFile()} and\n+     * {@link File#canRead()}. Files that do not pase this test are ignored.\n+     * \n+     * @param sourceFiles\n+     *            the source files to add\n+     */\n+    public void addSourceFile(File... sourceFiles) {\n+        if (sourceFiles != null) {\n+            for (File sourceFile : sourceFiles) {\n+                checkAndAddSrouceFile(sourceFile);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Remove the parsed source files\n+     * \n+     * @param sourceFile\n+     *            the source files to remove\n+     */\n+    public void removeSourceFile(File... sourceFile) {\n+        if (sourceFile == null) {\n+            return;\n+        }\n+        Set<File> files = (Set<File>) config.get(KEY_RDF_FILES);\n+        if (files != null) {\n+            files.removeAll(Arrays.asList(sourceFile));\n+        }\n+    }\n+    \n+    /**\n+     * Getter for the list of RDF files used as source for indexing.\n+     * \n+     * @return the unmodifiable list of files or <code>null</code>if no source files are present.\n+     */\n+    public Collection<File> getSourceFiles() {\n+        Collection<File> sourceFiles = (Collection<File>) config.get(KEY_RDF_FILES);\n+        return sourceFiles == null ? null : Collections.unmodifiableCollection((Collection<File>) config\n+                .get(KEY_RDF_FILES));\n+    }\n+    \n+    /**\n+     * Setter for the directory used to store the data of the RDF triple store used for indexing.\n+     * \n+     * @param file\n+     *            the directory used to store the data (created if not exist)\n+     * @return <code>true</code> if the parsed file can be used as indexing\n+     *     directory (exists and is a directory or !exists) \n+     */\n+    public boolean setIndexingDir(File file) throws IllegalArgumentException {\n+        if (checkFile(file, false, null)) { // isDirectory or !exists\n+            config.put(KEY_RDF_STORE_DIR, file);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+    /**\n+     * Getter for the indexing directory\n+     * @return the directory used for indexing\n+     */\n+    public File getIndexingDir() {\n+        return (File) config.get(KEY_RDF_STORE_DIR);\n+    }\n+    /**\n+     * Setter for the RDF model name used to store/access the RDF data used\n+     * for indexing\n+     * @param modelName the RDF model name\n+     */\n+    public void setModelName(String modelName) {\n+        if (modelName != null && !modelName.isEmpty()) {\n+            config.put(KEY_MODEL_NAME, modelName);\n+        } else {\n+            log.warn(\"Unable to set modelName to NULL or an empty String\");\n+        }\n+    }\n+    /**\n+     * Getter for the RDF model name used to store/access the RDF data used\n+     * for indexing\n+     * @return the RDF model name\n+     */\n+    public String getModelName() {\n+        return (String) config.get(KEY_MODEL_NAME);\n+    }\n+    /**\n+     * Setter for the (optional) map that uses entity ids as key and there \n+     * ranking as value. see {@link RdfResourceEnum#signRank} for more information\n+     * about ranking of entities)\n+     * @param entityRankings the entity ranking map\n+     */\n+    public void setEntityRankings(Map<String,Float> entityRankings) {\n+        if (entityRankings == null) {\n+            config.remove(KEY_ENTITY_RANKINGS);\n+        } else {\n+            config.put(KEY_ENTITY_RANKINGS, entityRankings);\n+        }\n+    }\n+    /**\n+     * Getter for the (optional) map that uses entity ids as key and there \n+     * ranking as value. see {@link RdfResourceEnum#signRank} for more information\n+     * about ranking of entities)\n+     * @return the entity rankings or <code>null</code> if no entity rankings\n+     * are present\n+     */\n+    public Map<String,Float> getNetityRankings() {\n+        return (Map<String,Float>) config.get(KEY_ENTITY_RANKINGS);\n+    }\n+    /**\n+     * Setter for the indexing mode (expert use only). Please carefully read\n+     * {@link RdfIndexer#KEY_INDEXING_MODE} before setting this property.\n+     * @param mode the indexing mode\n+     */\n+    public void setIndexingMode(IndexingMode mode) {\n+        if (mode != null) {\n+            config.put(KEY_INDEXING_MODE, mode);\n+        } else {\n+            config.remove(KEY_INDEXING_MODE);\n+        }\n+    }\n+    /**\n+     * Getter for the Indexing Mode\n+     * @return the indexing mode or <code>null</code> if not set by this\n+     * configuration.\n+     */\n+    public IndexingMode getIndexingMode() {\n+        return (IndexingMode) config.get(KEY_INDEXING_MODE);\n+    }\n+    /**\n+     * Setter for the skip reading mode. If set to <code>true</code> no RDF\n+     * data are read. This can be useful if the RDF data are\n+     * already available as an Jena TDB store (e.g. when interrupting an\n+     * indexing session that has already completed with reading the RDF data.\n+     * @param state the state or <code>null</code> to remove any present config\n+     */\n+    public void setSkipRead(Boolean state) {\n+        if (state == null) {\n+            config.remove(KEY_SKIP_READ);\n+        } else {\n+            config.put(KEY_SKIP_READ, state);\n+        }\n+    }\n+    /**\n+     * Getter for the skip reading state.\n+     * @return the state or <code>null</code> if not set\n+     */\n+    public Boolean getSkipRead() {\n+        return (Boolean) config.get(KEY_SKIP_READ);\n+    }\n+    /**\n+     * This is the number of documents stored in the {@link Yard} at once. During\n+     * indexing {@link Representation} are created based on the RDF data of the\n+     * configured RDF source files. As soon as chink size Representations are\n+     * created they are stored by a single call to {@link Yard#store(Iterable)}.\n+     * @param size the number of {@link Representation} stored at in the {@link Yard}\n+     * at once. Parse <code>null</code> or a value smaller equals zero to remove\n+     * this optional configuration.\n+     */\n+    public void setChunkSize(Integer size) {\n+        if (size == null || size < 1) {\n+            config.remove(KEY_CHUNK_SIZE);\n+        } else {\n+            config.put(KEY_CHUNK_SIZE, size);\n+        }\n+    }\n+    /**\n+     * Getter for the chunk size (number of {@link Representation} sotred at once\n+     * in the {@link Yard}.\n+     * @return the chunk size or <code>null</code> if not present\n+     */\n+    public Integer getChunkSize() {\n+        return (Integer) config.get(KEY_CHUNK_SIZE);\n+    }\n+    /**\n+     * Allows to set the state if Entities without ranking information should be\n+     * ignored by the indexer.\n+     * @param state the state or <code>null</code> to remove the configuration\n+     * and go with the default.\n+     */\n+    public void setIgnoreEntitiesWithoutRanking(Boolean state) {\n+        if (state == null) {\n+            config.remove(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING);\n+        } else {\n+            config.put(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING, state);\n+        }\n+    }\n+    /**\n+     * Getter for the state if entities without available ranking should be\n+     * ignored.\n+     * @return the state or <code>null</code> if not present\n+     */\n+    public Boolean getIgnoreEntitiesWithoutRanking() {\n+        return (Boolean) config.get(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING);\n+    }\n+    /**\n+     * Setter for the minimal ranking required by an entity to be processed\n+     * by the indexer.\n+     * @param minRanking the minimum ranking. Parsed <code>null</code> or a\n+     * value smaller equals 0 to remove this configuration and go with the\n+     * default.\n+     */\n+    public void setMinEntityRanking(Float minRanking) {\n+        if (minRanking == null || minRanking <= 0) {\n+            config.remove(KEY_REQUIRED_ENTITY_RANKING);\n+        } else {\n+            config.put(KEY_REQUIRED_ENTITY_RANKING, minRanking);\n+        }\n+    }\n+    /**\n+     * The minimum required ranking required by an entity to be indexed.\n+     * @return the minimum required ranking or <code>null</code> if not defined\n+     * by this configuration\n+     */\n+    public Float getMinEntityRanking() {\n+        return (Float) config.get(KEY_REQUIRED_ENTITY_RANKING);\n+    }\n+    /**\n+     * Setter for the ranking used for entities for them no ranking is\n+     * available. The value need to be greater than zero to be accepted.\n+     * @param defaultRanking the ranking used for entities without ranking\n+     * information. Parse <code>null</code> or a value smaller equals zero to\n+     * remove this configuration.\n+     */\n+    public void setDefaultEntityRanking(Float defaultRanking) {\n+        if (defaultRanking == null || defaultRanking <= 0) {\n+            config.remove(defaultRanking);\n+        } else {\n+            config.put(KEY_DEFAULT_ENTITY_RANKING, defaultRanking);\n+        }\n+    }\n+    /**\n+     * Getter for the default ranking value that is used for entities no ranking\n+     * information are available.\n+     * @return the default ranking or <code>null</code> if not present within\n+     * this configuration.\n+     */\n+    public Float getDefaultEntityRanking() {\n+        return (Float) config.get(KEY_DEFAULT_ENTITY_RANKING);\n+    }\n+    \n+    /**\n+     * Tests if a RDF source file is valid (exists, isFile and canRead) and\n+     * if OK add them to the configuration.\n+     * @param sourceFile the file to add\n+     */\n+    private void checkAndAddSrouceFile(File sourceFile) {\n+        if (checkFile(sourceFile, true, true)) {\n+            Set<File> files = (Set<File>) config.get(KEY_RDF_FILES);\n+            if (files == null) {\n+                files = new HashSet<File>();\n+                config.put(KEY_RDF_FILES, files);\n+            }\n+            log.info(\"  > add source file \" + sourceFile);\n+            files.add(sourceFile);\n+        }\n+    }\n+    /**\n+     * Setter for the field mappings used by the indexer to create the\n+     * {@link Representation}s based on the RDF input.<br>\n+     * Parsd strings must represent valid field mappings.\n+     * @param mappings A collection field mappings in the string representation.\n+     * If <code>null</code> or an empty collection is parsed the configuration\n+     * is removed.\n+     */\n+    public void setMappings(Collection<String> mappings){\n+        if(mappings == null || mappings.isEmpty()){\n+            config.remove(KEY_FIELD_MAPPINGS);\n+        } else {\n+            config.put(KEY_FIELD_MAPPINGS, mappings);\n+        }\n+    }\n+    /**\n+     * Setter for the field mappings that allows to parse an existing\n+     * {@link FieldMapper} instance. Note that the string representation of all\n+     * the {@link FieldMapping}s part of the FieldMapper will be stored within\n+     * the configuration\n+     * @param mapper the FieldMapper instance with the FieldMappings to be used\n+     * for the configuration of the indexer.\n+     */\n+    public void setMappings(FieldMapper mapper){\n+        if(mapper != null){\n+            String[] mappingStrings = FieldMappingUtils.serialiseFieldMapper(mapper);\n+            setMappings(mappingStrings != null ? Arrays.asList(mappingStrings):null);\n+        } else {\n+            setMappings((Collection<String>)null);\n+        }\n+    }\n+    /**\n+     * Getter for the field mappings\n+     * @return the field mappings or <code>null</code> if no are defined for\n+     * this configuration.\n+     */\n+    public Collection<String> getMappings(){\n+        Collection<String> mappings = (Collection<String>)config.get(KEY_FIELD_MAPPINGS);\n+        return mappings == null ? null: Collections.unmodifiableCollection(mappings);\n+    }\n+    /**\n+     * checks a files against the parsed parameter\n+     * @param file the file to check\n+     * @param isFile if <code>true</code> than the parsed {@link File} is tested\n+     * to be a file, otherwise it is test to be a directory\n+     * @param exists if <code>null</code> it is indicated that the file/directory\n+     * can bee created if necessary. <code>true</code> indicated that the parsed\n+     * file must exist where <code>false</code> indicate that the file MUST NOT\n+     * exists.\n+     * @return <code>true</code> if the parsed {@link File} fulfils the stated\n+     * requirements.\n+     */\n+    private boolean checkFile(File file, boolean isFile, Boolean exists) {\n+        //exists null means that it will be created if not existence\n+        //therefore we need only to check the state if not null.\n+        if (exists != null) {\n+            if (file.exists() != exists) {\n+                log.warn(String.format(\"parsed File %s does %s exist, but the other state was requested\", file, file.exists() ? \"\" : \"not\"));\n+                return false;\n+            }\n+        } else if (!file.exists()) {\n+            //in case of exists == null && file does not exist we assume that\n+            //the File (or Directory) will be created. Therefore no further\n+            //checks are required\n+            return true;\n+        } //else the parsed file exists -> perform the other checks\n+        if (file.isFile() != isFile) {\n+            log.warn(String.format(\"parsed File %s is a %s but %s was requested!\", \n+                file, file.isFile() ? \"File\" : \"Directory\",isFile ? \"File\" : \"Directory\"));\n+            return false;\n+        }\n+        if (!file.canRead()) {\n+            log.warn(String.format(\"Unable to read parsed File %s\", file));\n+            return false;\n+        }\n+        return true;\n+    }\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/indexing/genericRdf/src/main/java/eu/iksproject/rick/indexing/rdf/RdfIndexerConfig.java",
                "sha": "0a192286d5fa0cb139a8613c0101ba3c347ee15e",
                "status": "added"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/pom.xml",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/pom.xml?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/model/clerezza/pom.xml",
                "patch": "@@ -122,6 +122,12 @@\n       <version>1.4.0</version>\n     </dependency> -->\n     <!-- for tests -->\n+    <dependency>\n+      <groupId>eu.iksproject</groupId>\n+      <artifactId>eu.iksproject.rick.test</artifactId>\n+      <version>0.1-SNAPSHOT</version>\n+      <scope>test</scope>\n+    </dependency>\n     <dependency>\n       <groupId>junit</groupId>\n       <artifactId>junit</artifactId>",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/pom.xml",
                "sha": "7e5097fd7934100ac95122e43de28ee9521c69b1",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfReference.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfReference.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 2,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfReference.java",
                "patch": "@@ -10,10 +10,22 @@\n public class RdfReference implements Reference,Cloneable {\n     private final UriRef uri;\n     protected RdfReference(String reference){\n-        this.uri = new UriRef(reference);\n+        if(reference == null){\n+            throw new NullPointerException(\"The parsed Reference MUST NOT be NULL!\");\n+        } else if(reference.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed Reference MUST NOT be Empty!\");\n+        } else {\n+            this.uri = new UriRef(reference);\n+        }\n     }\n     protected RdfReference(UriRef uri){\n-        this.uri = uri;\n+        if(uri == null){\n+            throw new NullPointerException(\"The parsed Reference MUST NOT be NULL!\");\n+        } else if(uri.getUnicodeString().isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed Reference MUST NOT be represent an empty string!\");\n+        } else {\n+            this.uri = uri;\n+        }\n     }\n     @Override\n     public String getReference() {",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfReference.java",
                "sha": "5b56da1ade9c0c73df187464d2e0af22040a54a2",
                "status": "modified"
            },
            {
                "additions": 158,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfRepresentation.java",
                "changes": 233,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfRepresentation.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 75,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfRepresentation.java",
                "patch": "@@ -16,13 +16,14 @@\n import org.slf4j.LoggerFactory;\n \n import eu.iksproject.rick.core.utils.AdaptingIterator;\n+import eu.iksproject.rick.core.utils.FilteringIterator;\n import eu.iksproject.rick.core.utils.ModelUtils;\n import eu.iksproject.rick.core.utils.TypeSaveIterator;\n import eu.iksproject.rick.model.clerezza.impl.Literal2TextAdapter;\n import eu.iksproject.rick.model.clerezza.impl.LiteralAdapter;\n-import eu.iksproject.rick.model.clerezza.impl.NaturalLanguageLiteralIterator;\n-import eu.iksproject.rick.model.clerezza.impl.ReferenceIterator;\n+import eu.iksproject.rick.model.clerezza.impl.NaturalTextFilter;\n import eu.iksproject.rick.model.clerezza.impl.Resource2ValueAdapter;\n+import eu.iksproject.rick.model.clerezza.impl.UriRef2ReferenceAdapter;\n import eu.iksproject.rick.model.clerezza.impl.UriRefAdapter;\n import eu.iksproject.rick.model.clerezza.utils.Resource2StringAdapter;\n import eu.iksproject.rick.servicesapi.model.Reference;\n@@ -64,13 +65,13 @@ protected UriRef getRepresentationType(){\n     }\n     @Override\n     public void add(String field, Object value) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         if(value == null){\n-            log.warn(\"NULL parsed as value in add method for symbol \"+getId()\n-                    +\" and field \"+field+\" -> call ignored\");\n-            return;\n+            throw new IllegalArgumentException(\"NULL values are not supported by Representations\");\n         }\n         UriRef fieldUriRef = new UriRef(field);\n         Collection<Object> values = new ArrayList<Object>();\n@@ -86,7 +87,6 @@ public void add(String field, Object value) {\n                 graphNode.addProperty(fieldUriRef, ((RdfReference) current).getUriRef());\n             } else if (current instanceof Reference){\n                 graphNode.addProperty(fieldUriRef, new UriRef(((Reference) current).getReference()));\n-                addReference(field,((Reference)current).getReference());\n             } else if (current instanceof RdfText){\n                 //treat RDF Implementations special to avoid creating new instances\n                 graphNode.addProperty(fieldUriRef,((RdfText) current).getLiteral());\n@@ -111,30 +111,32 @@ private void addTypedLiteral(UriRef field, Object literalValue){\n     }\n     @Override\n     public void addReference(String field, String reference) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         if(reference == null){\n-            log.warn(\"NULL parsed as value in add method for symbol \"+getId()\n-                    +\" and field \"+field+\" -> call ignored\");\n+            throw new IllegalArgumentException(\"NULL values are not supported by Representations\");\n+        } else if (reference.isEmpty()) {\n+            throw new IllegalArgumentException(\"References MUST NOT be empty!\");\n         }\n         graphNode.addProperty(new UriRef(field), new UriRef(reference));\n     }\n     @Override\n     public void addNaturalText(String field, String text, String...languages) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         if(text == null){\n-            log.warn(\"NULL parsed as value in add method for symbol \"+getId()\n-                    +\" and field \"+field+\" -> call ignored\");\n+            throw new IllegalArgumentException(\"NULL values are not supported by Representations\");\n         }\n         this.addNaturalText(new UriRef(field), text, languages);\n     }\n     private void addNaturalText(UriRef field, String text, String...languages) {\n-        if(languages == null){\n-            log.debug(\"NULL parsed as languages -> replacing with \\\"new String []{null}\\\"\" +\n-                    \" -> assuming a missing explicit cast to (Stirng) in the var arg\");\n+        if(languages == null || languages.length == 0){\n             languages = new String []{null};\n         }\n         for(String language : languages){\n@@ -145,22 +147,33 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Iterator<T> get(String field, final Class<T> type) throws UnsupportedTypeException {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         UriRef fieldUriRef = new UriRef(field);\n         if(Resource.class.isAssignableFrom(type)){ //native support for Clerezza types\n             return new TypeSaveIterator<T>(graphNode.getObjects(fieldUriRef), type);\n-        } else if(type.equals(String.class)){ //support to convert anything to String\n-            return (Iterator<T>) new AdaptingIterator<Resource,String>(\n-                    graphNode.getObjects(fieldUriRef),\n-                    new Resource2StringAdapter<Resource>(),\n-                    String.class);\n+// NOTE: (Rupert Westenthaler 12.01.2011)\n+//     Converting everything to String is not an intended functionality. When\n+//     someone parsed String.class he rather assumes that he gets only string\n+//     values and not also string representations for Dates, Integer ...\n+//       \n+//        } else if(type.equals(String.class)){ //support to convert anything to String\n+//            return (Iterator<T>) new AdaptingIterator<Resource,String>(\n+//                    graphNode.getObjects(fieldUriRef),\n+//                    new Resource2StringAdapter<Resource>(),\n+//                    String.class);\n         } else if(type.equals(URI.class) || type.equals(URL.class)){ //support for References\n             return new AdaptingIterator<UriRef, T>(\n                     graphNode.getUriRefObjects(fieldUriRef),\n                     new UriRefAdapter<T>(),\n                     type);\n         } else if(Reference.class.isAssignableFrom(type)){\n-            return (Iterator<T>) new ReferenceIterator(\n-                    graphNode.getUriRefObjects(fieldUriRef));\n+            return (Iterator<T>) new AdaptingIterator<UriRef,Reference>(\n+                    graphNode.getUriRefObjects(fieldUriRef),\n+                    new UriRef2ReferenceAdapter(),Reference.class);\n         } else if(Text.class.isAssignableFrom(type)){\n             return (Iterator<T>)new AdaptingIterator<Literal, Text>(\n                     graphNode.getLiterals(fieldUriRef),\n@@ -176,12 +189,23 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n \n     @Override\n     public Iterator<Reference> getReferences(String field) {\n-        Iterator<UriRef> it = graphNode.getUriRefObjects(new UriRef(field));\n-        return new ReferenceIterator(it);\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n+        return new AdaptingIterator<UriRef,Reference>(\n+                graphNode.getUriRefObjects(new UriRef(field)),\n+                new UriRef2ReferenceAdapter(),Reference.class);\n     }\n \n     @Override\n     public Iterator<Text> getText(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         return new AdaptingIterator<Literal, Text>(\n                 graphNode.getLiterals(new UriRef(field)),\n                 new Literal2TextAdapter<Literal>(),\n@@ -190,16 +214,21 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n \n     @Override\n     public Iterator<Object> get(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         return new AdaptingIterator<Resource, Object>(graphNode.getObjects(new UriRef(field)),\n                 new Resource2ValueAdapter<Resource>(),Object.class);\n     }\n \n     @Override\n     public Iterator<Text> get(String field, String...languages) {\n-        if(languages == null){\n-            log.debug(\"NULL parsed as languages -> replacing with \\\"new String []{null}\\\"\" +\n-                    \" -> assuming a missing explicit cast to (String) in the var arg\");\n-            languages = new String []{null};\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         return new AdaptingIterator<Literal, Text>(\n                 graphNode.getLiterals(new UriRef(field)),\n@@ -215,6 +244,11 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n \n     @Override\n     public <T> T getFirst(String field, Class<T> type) throws UnsupportedTypeException {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         Iterator<T> it = get(field,type);\n         if(it.hasNext()){\n             return it.next();\n@@ -225,6 +259,11 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n \n     @Override\n     public Object getFirst(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         Iterator<Object> it = get(field);\n         if(it.hasNext()){\n             return it.next();\n@@ -234,11 +273,21 @@ public Object getFirst(String field) {\n     }\n     @Override\n     public Reference getFirstReference(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         Iterator<Reference> it = getReferences(field);\n         return it.hasNext()?it.next():null;\n     }\n     @Override\n     public Text getFirst(String field, String...languages) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         if(languages == null){\n             log.debug(\"NULL parsed as languages -> replacing with \\\"new String []{null}\\\"\" +\n                     \" -> assuming a missing explicit cast to (String) in the var arg\");\n@@ -257,37 +306,47 @@ public String getId() {\n     }\n \n     @Override\n-    public void remove(String field, Object value) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n+    public void remove(String field, Object parsedValue) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n-        if(value == null){\n+        if(parsedValue == null){\n             log.warn(\"NULL parsed as value in remove method for symbol \"+getId()\n                     +\" and field \"+field+\" -> call ignored\");\n+            return;\n         }\n         UriRef fieldUriRef = new UriRef(field);\n-        if(value instanceof Resource){ //native support for Clerezza types!\n-            graphNode.deleteProperty(fieldUriRef, (Resource)value);\n-        } else if(value instanceof URI || value instanceof URL){\n-            removeReference(field, value.toString());\n-        } else if (value instanceof String[]){\n-            if(((String[])value).length>0){\n-                if(((String[])value).length>1){\n-                    removeNaturalText(field, ((String[])value)[0],((String[])value)[1]);\n-                } else {\n-                    removeNaturalText(field, ((String[])value)[0],(String)null);\n-                }\n+        Collection<Object> removeValues = new ArrayList<Object>();\n+        \n+        ModelUtils.checkValues(valueFactory, parsedValue, removeValues);\n+        //We still need to implement support for specific types supported by this implementation\n+        for (Object current : removeValues){\n+            if (current instanceof Resource){ //native support for Clerezza types!\n+                graphNode.deleteProperty(fieldUriRef, (Resource)current);\n+            } else if (current instanceof RdfReference){\n+                //treat RDF Implementations special to avoid creating new instances\n+                graphNode.deleteProperty(fieldUriRef, ((RdfReference) current).getUriRef());\n+            } else if (current instanceof Reference){\n+                graphNode.deleteProperty(fieldUriRef, new UriRef(((Reference) current).getReference()));\n+            } else if (current instanceof RdfText){\n+                //treat RDF Implementations special to avoid creating new instances\n+                graphNode.deleteProperty(fieldUriRef,((RdfText) current).getLiteral());\n+            } else if (current instanceof Text){\n+                removeNaturalText(field,((Text)current).getText(),((Text)current).getLanguage());\n+            } else { //else add an typed Literal!\n+                removeTypedLiteral(fieldUriRef, current);\n             }\n-        } else {\n-            removeTypedLiteral(fieldUriRef, value);\n         }\n-\n     }\n \n     @Override\n     public void removeReference(String field, String reference) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         if(reference == null){\n             log.warn(\"NULL parsed as value in remove method for symbol \"+getId()+\" and field \"+field+\" -> call ignored\");\n@@ -307,48 +366,59 @@ protected void removeTypedLiteral(UriRef field, Object object){\n     }\n     @Override\n     public void removeNaturalText(String field, String value, String... languages) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         if(value == null){\n             log.warn(\"NULL parsed as value in remove method for symbol \"+getId()+\" and field \"+field+\" -> call ignored\");\n         }\n-        if(languages == null){\n-            log.debug(\"NULL parsed as languages -> replacing with \\\"new String []{null}\\\"\" +\n-                    \" -> assuming a missing explicit cast to (Stirng) in the var arg\");\n+        if(languages == null || languages.length == 0){ //null or no language\n+            //need to be interpreted as default language\n             languages = new String []{null};\n         }\n         UriRef fieldUriRef = new UriRef(field);\n         for(String language : languages){\n             graphNode.deleteProperty(fieldUriRef,RdfResourceUtils.createLiteral(value, language));\n+            if(language == null){ //if the language is null\n+                //we need also try to remove a typed Literal with the data type\n+                //xsd:string and the parsed value!\n+                graphNode.deleteProperty(fieldUriRef,RdfResourceUtils.createLiteral(value));\n+            }\n         }\n     }\n     @Override\n     public void removeAll(String field) {\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n         graphNode.deleteProperties(new UriRef(field));\n     }\n     @Override\n     public void removeAllNaturalText(String field, String... languages) {\n-        if(field == null) {\n-            throw new IllegalArgumentException(\"Parameter \\\"String field\\\" MUST NOT be NULL!\");\n-        }\n-        if(languages == null){\n-            log.debug(\"NULL parsed as languages -> replacing with \\\"new String []{null}\\\"\" +\n-                    \" -> assuming a missing explicit cast to (Stirng) in the var arg\");\n-            languages = new String []{null};\n-        }\n+        if(field == null){\n+            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+        } else if(field.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n+        }\n+//        if(languages == null || languages.length == 0){\n+//            languages = new String []{null};\n+//        }\n         UriRef fieldUriRef = new UriRef(field);\n-        Collection<Literal> literals = new ArrayList<Literal>();\n         //get all the affected Literals\n-        for (Iterator<Literal> it =  new NaturalLanguageLiteralIterator(graphNode.getLiterals(fieldUriRef), languages);\n-            it.hasNext();\n-            literals.add(it.next())\n-        );\n-        //delete the found literals\n-        for(Literal literal:literals){\n-            graphNode.deleteProperty(fieldUriRef, literal);\n+        Collection<Literal> toRemove = new ArrayList<Literal>();\n+        Iterator<Literal> it =  new FilteringIterator<Literal>(\n+                graphNode.getLiterals(fieldUriRef),\n+                new NaturalTextFilter(languages),Literal.class);\n+        while(it.hasNext()){\n+            toRemove.add(it.next());\n+        }\n+        for(Literal l : toRemove){\n+            graphNode.deleteProperty(fieldUriRef, l);\n         }\n-\n     }\n \n     @Override\n@@ -361,7 +431,7 @@ public void set(String field, Object value) {\n \n     @Override\n     public void setReference(String field, String reference) {\n-        removeAll(reference);\n+        removeAll(field);\n         if(reference != null){\n             addReference(field, reference);\n         }\n@@ -374,5 +444,18 @@ public void setNaturalText(String field, String text, String...languages) {\n             addNaturalText(field, text, languages);\n         }\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return RdfRepresentation.class.getSimpleName()+getId();\n+    }\n+    @Override\n+    public int hashCode() {\n+        return getId().hashCode();\n+    }\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj != null && obj instanceof Representation && ((Representation)obj).getId().equals(getId());\n+    }\n \n }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfRepresentation.java",
                "sha": "589b484a3cbe97a4b0643b1bff8599a021bc58eb",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfText.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfText.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 1,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfText.java",
                "patch": "@@ -15,6 +15,14 @@\n     private final boolean isPlain;\n \n     protected RdfText(String text, String lang) {\n+        if(text == null){\n+            throw new NullPointerException(\"The parsed text MUST NOT be NULL\");\n+        } else if(text.isEmpty()){\n+            throw new IllegalArgumentException(\"Tha parsed Text MUST NOT be empty!\");\n+        }\n+        if(lang != null && lang.isEmpty()){ //we need to avoid empty languages, because Clerezza don't like them!\n+            lang = null;\n+        }\n         this.literal = new PlainLiteralImpl(text, lang != null ? new Language(lang) : null);\n         this.isPlain = true;\n     }\n@@ -26,7 +34,9 @@ protected RdfText(Literal literal) {\n \n     @Override\n     public String getLanguage() {\n-        return isPlain && ((PlainLiteral) literal).getLanguage() != null ? ((PlainLiteral) literal).getLanguage().toString() : null;\n+        return isPlain && \n+            ((PlainLiteral) literal).getLanguage() != null ? \n+                ((PlainLiteral) literal).getLanguage().toString() : null;\n     }\n \n     @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfText.java",
                "sha": "4f3b2e0f5bce004c9aef8ec4156913a95c4d0d1a",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfValueFactory.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfValueFactory.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 6,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfValueFactory.java",
                "patch": "@@ -40,7 +40,7 @@ private RdfValueFactory(){\n     @Override\n     public RdfReference createReference(Object value) {\n         if (value == null) {\n-            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n+            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n         } else if (value instanceof UriRef) {\n             return new RdfReference((UriRef) value);\n         } else {\n@@ -51,7 +51,7 @@ public RdfReference createReference(Object value) {\n     @Override\n     public RdfText createText(Object value) {\n         if (value == null) {\n-            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n+            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n         } else if (value instanceof Literal) {\n             return new RdfText((Literal) value);\n         } else {\n@@ -66,10 +66,13 @@ public RdfText createText(String text, String language) {\n \n     @Override\n     public RdfRepresentation createRepresentation(String id) {\n-        if (id == null || id.isEmpty()) {\n-            throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL nor empty!\");\n+        if (id == null){\n+           throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+        } else if(id.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed id MUST NOT be empty!\");\n+        } else {\n+            return createRdfRepresentation(new UriRef(id), new SimpleMGraph());\n         }\n-        return createRdfRepresentation(new UriRef(id), new SimpleMGraph());\n     }\n \n     /**\n@@ -84,7 +87,10 @@ public RdfRepresentation createRepresentation(String id) {\n      */\n     public RdfRepresentation createRdfRepresentation(UriRef node, TripleCollection graph) {\n         if (node == null) {\n-            throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL!\");\n+            throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+        }\n+        if(graph == null){\n+            throw new NullPointerException(\"The parsed graph MUST NOT be NULL!\");\n         }\n         return new RdfRepresentation(node, graph);\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/RdfValueFactory.java",
                "sha": "de24299492696ac517a6c3d71e0324cc2a456537",
                "status": "modified"
            },
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/Literal2TextAdapter.java",
                "changes": 38,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/Literal2TextAdapter.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 10,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/Literal2TextAdapter.java",
                "patch": "@@ -6,12 +6,17 @@\n import java.util.Set;\n \n import org.apache.clerezza.rdf.core.Literal;\n+import org.apache.clerezza.rdf.core.LiteralFactory;\n import org.apache.clerezza.rdf.core.PlainLiteral;\n import org.apache.clerezza.rdf.core.TypedLiteral;\n+import org.apache.clerezza.rdf.core.UriRef;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import eu.iksproject.rick.core.utils.AdaptingIterator.Adapter;\n import eu.iksproject.rick.model.clerezza.RdfResourceUtils;\n import eu.iksproject.rick.model.clerezza.RdfValueFactory;\n+import eu.iksproject.rick.servicesapi.defaults.DataTypeEnum;\n import eu.iksproject.rick.servicesapi.model.Text;\n /**\n  * This Adapter does two things:\n@@ -30,7 +35,13 @@\n  * @author Rupert Westenthaler\n  */\n public class Literal2TextAdapter<T extends Literal> implements Adapter<T,Text> {\n-\n+    \n+    private Logger log = LoggerFactory.getLogger(Literal2TextAdapter.class);\n+    /**\n+     * The xsd:string data type constant used for TypedLiterals to check if the\n+     * represent an string value!\n+     */\n+    private static UriRef xsdString = new UriRef(DataTypeEnum.String.getUri());\n     /**\n      * Unmodifiable set of the active languages\n      */\n@@ -60,17 +71,24 @@ public Literal2TextAdapter(String...lang){\n     @Override\n     public Text adapt(T value, Class<Text> type) {\n         if(value instanceof PlainLiteral){\n-            if(languages == null || languages.contains(((PlainLiteral) value).getLanguage())){\n+            String literalLang = ((PlainLiteral) value).getLanguage() == null ? \n+                    null : ((PlainLiteral) value).getLanguage().toString();\n+            if(languages == null || languages.contains(literalLang)){\n                 return valueFactory.createText(value);\n             } //else wrong language -> filter\n-        } else if(containsNull){\n-            /*\n-             * if the null language is active, than we can also return\n-             * \"normal\" literals (with no known language).\n-             * But first we need to check the Datatype!\n-             */\n-            return valueFactory.createText(value);\n-        } // else no language defined -> filter\n+        } else if(value instanceof TypedLiteral) {\n+            if(containsNull && ((TypedLiteral)value).getDataType().equals(xsdString)){\n+                /*\n+                 * if the null language is active, than we can also return\n+                 * \"normal\" literals (with no known language).\n+                 * But first we need to check the Datatype!\n+                 */\n+                return valueFactory.createText(value);\n+            } // else no xsd:string dataType and therefore not a text with default lang!\n+        } else {// unknown Literal type -> filter + warning\n+            log.warn(String.format(\"Unknown LiteralType %s (lexicalForm=\\\"%s\\\") -> ignored! Pleas adapt this implementation to support this type!\",\n+                value.getClass(),value.getLexicalForm()));\n+        }\n         return null;\n     }\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/Literal2TextAdapter.java",
                "sha": "f16899f2d2fa7eabc8a23880d5460d3172eb9e56",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/LiteralAdapter.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/LiteralAdapter.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 3,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/LiteralAdapter.java",
                "patch": "@@ -40,9 +40,16 @@\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public A adapt(T value, Class<A> type) {\n-        if(type.equals(String.class)){\n-            return (A) value.getLexicalForm();\n-        } else if(Text.class.isAssignableFrom(type)){\n+// NOTE: (Rupert Westenthaler 12.01.2011)\n+//      Converting everything to String is not an intended functionality. When\n+//      someone parsed String.class he rather assumes that he gets only string\n+//      values and not also string representations for Dates, Integer ...\n+//      If someone needs this kind of functionality he can anyway use the \n+//      the Resource2StringAdapter.\n+//        if(type.equals(String.class)){\n+//            return (A) value.getLexicalForm();\n+//        } else \n+        if(Text.class.isAssignableFrom(type)){\n             if(value instanceof PlainLiteral ||\n                     (value instanceof TypedLiteral &&\n                     RdfResourceUtils.STRING_DATATYPES.contains(((TypedLiteral)value).getDataType()))){",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/LiteralAdapter.java",
                "sha": "fdc84d0b047249d478cc9a5d43e79d51c5488365",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/c4b216b0b4c46b1083c8ef923a5094fd3273dad2/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalLanguageLiteralIterator.java",
                "changes": 79,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalLanguageLiteralIterator.java?ref=c4b216b0b4c46b1083c8ef923a5094fd3273dad2",
                "deletions": 79,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalLanguageLiteralIterator.java",
                "patch": "@@ -1,79 +0,0 @@\n-package eu.iksproject.rick.model.clerezza.impl;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Set;\n-\n-import org.apache.clerezza.rdf.core.Literal;\n-import org.apache.clerezza.rdf.core.PlainLiteral;\n-\n-import eu.iksproject.rick.core.utils.AdaptingIterator.Adapter;\n-\n-/**\n- * TODO: refactor to use the {@link Adapter} interface\n- * @author Rupert Westenthaler\n- *\n- */\n-public class NaturalLanguageLiteralIterator implements Iterator<Literal> {\n-\n-    /**\n-     * Unmodifiable set of the active languages\n-     */\n-    protected final Set<String> languages;\n-    private final boolean containsNull;\n-    protected final Iterator<Literal> it;\n-    protected Literal next;\n-\n-    public NaturalLanguageLiteralIterator(Iterator<Literal> it, String...lang){\n-        if(it == null){\n-            throw new IllegalArgumentException(\"Parameter Iterator<Literal> MUST NOT be NULL!\");\n-        }\n-        if(lang == null){\n-            throw new IllegalArgumentException(\"Parameter languages MUST NOT be NULL!\");\n-        }\n-        if(lang.length==0){\n-            throw new IllegalArgumentException(\"At least one language MUST be present\");\n-        }\n-        this.it = it;\n-        this.languages = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(lang)));\n-        containsNull = languages.contains(null);\n-        //init the first element\n-        next = prepareNext();\n-    }\n-    @Override\n-    public final boolean hasNext() {\n-        return next != null;\n-    }\n-\n-    @Override\n-    public Literal next() {\n-        Literal current  = next;\n-        next = prepareNext();\n-        return current;\n-    }\n-\n-    @Override\n-    public final void remove() {\n-        it.remove();\n-    }\n-\n-    protected final Literal prepareNext(){\n-        while (it.hasNext()){\n-            Literal current = it.next();\n-            if (current instanceof PlainLiteral){\n-                if (languages.contains(((PlainLiteral) current).getLanguage())){\n-                    return current;\n-                } //else wrong language -> filter\n-            } else if (containsNull){\n-                /*\n-                 * if the null language is active, than we can also return\n-                 * \"normal\" literals (with no known language)\n-                 */\n-                return current;\n-            } // else no language defined -> filter\n-        }\n-        return null; //no more elements -> return null\n-    }\n-}",
                "raw_url": "https://github.com/apache/stanbol/raw/c4b216b0b4c46b1083c8ef923a5094fd3273dad2/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalLanguageLiteralIterator.java",
                "sha": "68c91cb8574f566c69abcfe61baee721c9dabacc",
                "status": "removed"
            },
            {
                "additions": 86,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalTextFilter.java",
                "changes": 86,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalTextFilter.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalTextFilter.java",
                "patch": "@@ -0,0 +1,86 @@\n+package eu.iksproject.rick.model.clerezza.impl;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.clerezza.rdf.core.Literal;\n+import org.apache.clerezza.rdf.core.PlainLiteral;\n+import org.apache.clerezza.rdf.core.TypedLiteral;\n+import org.apache.clerezza.rdf.core.UriRef;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import eu.iksproject.rick.core.utils.FilteringIterator;\n+import eu.iksproject.rick.core.utils.FilteringIterator.Filter;\n+import eu.iksproject.rick.servicesapi.defaults.DataTypeEnum;\n+/**\n+ * Filter implementation to be used in combination with {@link FilteringIterator}\n+ * to return only {@link Literal} values (may be {@link PlainLiteral}s and/or\n+ * {@link TypedLiteral}s) that confirm to the parsed set of languages.<p>\n+ * Parsing <code>null</code>, an empty array is interpreted such that any\n+ * language is accepted. Parsing \"\" or <code>null</code> as one element of the\n+ * array indicated that Literals without any language tag are included. This also\n+ * includes {@link TypedLiteral}s with the data type <code>xsd:string</code>.<p>\n+ * Note that parsing:<ul>\n+ * <li> an empty array will result in all Literals (regardless of the language)\n+ *      are returned\n+ * <li> an array that contains only the <code>null</code> element will result in\n+ *      only Literals without any language tag are returned.\n+ * </ul>\n+ * \n+ * @author Rupert Westenthaler\n+ *\n+ */\n+public class NaturalTextFilter implements Filter<Literal> {\n+    Logger log = LoggerFactory.getLogger(NaturalTextFilter.class);\n+    /**\n+     * The xsd:string data type constant used for TypedLiterals to check if the\n+     * represent an string value!\n+     */\n+    private static UriRef xsdString = new UriRef(DataTypeEnum.String.getUri());\n+    protected final Set<String> languages;\n+    private final boolean containsNull;\n+\n+    public NaturalTextFilter(String...languages){\n+        if(languages == null || languages.length == 0){\n+            this.languages = null;\n+            this.containsNull = true; // if no language is parse accept any (also the default)\n+        } else {\n+            Set<String> languageSet = new HashSet<String>(Arrays.asList(languages));\n+            if(languageSet.remove(\"\")){\n+                /*\n+                 * Parsing \"\" as language needs to be interpreted as parsing\n+                 * null\n+                 */\n+                languageSet.add(null);\n+            }\n+            this.languages = Collections.unmodifiableSet(languageSet);\n+            this.containsNull = this.languages.contains(null);\n+        }\n+    }\n+    @Override\n+    public boolean isValid(Literal value) {\n+        if (value instanceof PlainLiteral){\n+           if(languages == null) { //no language restrictions\n+                return true; //return any Plain Literal\n+            } else {\n+                String literalLang = ((PlainLiteral) value).getLanguage() == null ?\n+                    null : ((PlainLiteral) value).getLanguage().toString();\n+                return languages.contains(literalLang);\n+            }\n+        } else if(value instanceof TypedLiteral){\n+            /*\n+             * if the null language is active, than we can also return\n+             * \"normal\" literals (with no known language). This includes\n+             * Types literals with the data type xsd:string\n+             */\n+            return containsNull && ((TypedLiteral)value).getDataType().equals(xsdString);\n+        } else {// unknown Literal type -> filter + warning\n+            log.warn(String.format(\"Unknown LiteralType %s (lexicalForm=\\\"%s\\\") -> ignored! Pleas adapt this implementation to support this type!\",\n+                value.getClass(),value.getLexicalForm()));\n+            return false;\n+        }\n+    }\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/NaturalTextFilter.java",
                "sha": "85598d66180c4b2178525f70adf4318333f9a3d0",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/c4b216b0b4c46b1083c8ef923a5094fd3273dad2/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/ReferenceIterator.java",
                "changes": 43,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/ReferenceIterator.java?ref=c4b216b0b4c46b1083c8ef923a5094fd3273dad2",
                "deletions": 43,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/ReferenceIterator.java",
                "patch": "@@ -1,43 +0,0 @@\n-package eu.iksproject.rick.model.clerezza.impl;\n-\n-import java.util.Iterator;\n-\n-import org.apache.clerezza.rdf.core.UriRef;\n-\n-import eu.iksproject.rick.core.utils.AdaptingIterator.Adapter;\n-import eu.iksproject.rick.model.clerezza.RdfValueFactory;\n-import eu.iksproject.rick.servicesapi.model.Reference;\n-/**\n- * TODO: Change implementation to {@link Adapter}!\n- * @author Rupert Westenthaler\n- *\n- */\n-public class ReferenceIterator implements Iterator<Reference> {\n-\n-    private final RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n-    private final Iterator<UriRef> it;\n-\n-    public ReferenceIterator(Iterator<UriRef> it){\n-        if(it == null){\n-            throw new IllegalArgumentException(\"The parent Iterator<UriRef> MUST NOT be NULL\");\n-        }\n-        this.it = it;\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-        return it.hasNext();\n-    }\n-\n-    @Override\n-    public Reference next() {\n-        UriRef next = it.next();\n-        return next!=null?valueFactory.createReference(next):null;\n-    }\n-\n-    @Override\n-    public void remove() {\n-        it.remove();\n-    }\n-\n-}",
                "raw_url": "https://github.com/apache/stanbol/raw/c4b216b0b4c46b1083c8ef923a5094fd3273dad2/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/ReferenceIterator.java",
                "sha": "45949c4007f3a6627233d0c08e6f5ea7584a6953",
                "status": "removed"
            },
            {
                "additions": 24,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/UriRef2ReferenceAdapter.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/UriRef2ReferenceAdapter.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/UriRef2ReferenceAdapter.java",
                "patch": "@@ -0,0 +1,24 @@\n+package eu.iksproject.rick.model.clerezza.impl;\n+\n+import org.apache.clerezza.rdf.core.UriRef;\n+\n+import eu.iksproject.rick.core.utils.AdaptingIterator.Adapter;\n+import eu.iksproject.rick.model.clerezza.RdfValueFactory;\n+import eu.iksproject.rick.servicesapi.model.Reference;\n+\n+/**\n+ * Adapter that converts Clerezza {@link UriRef} instances to {@link Reference}s.\n+ * The {@link RdfValueFactory} is used to create {@link Reference} instances.\n+ * @author Rupert Westenthaler\n+ *\n+ */\n+public class UriRef2ReferenceAdapter implements Adapter<UriRef,Reference> {\n+\n+    private final RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n+\n+    @Override\n+    public Reference adapt(UriRef value, Class<Reference> type) {\n+        return valueFactory.createReference(value);\n+    }\n+\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/main/java/eu/iksproject/rick/model/clerezza/impl/UriRef2ReferenceAdapter.java",
                "sha": "88046389dd106bbc31ec27c0cba2d1679811c0b3",
                "status": "added"
            },
            {
                "additions": 184,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfRepresentationTest.java",
                "changes": 184,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfRepresentationTest.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfRepresentationTest.java",
                "patch": "@@ -0,0 +1,184 @@\n+package eu.iksproject.rick.model.clerezza;\n+\n+import static junit.framework.Assert.*;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.clerezza.rdf.core.Language;\n+import org.apache.clerezza.rdf.core.LiteralFactory;\n+import org.apache.clerezza.rdf.core.PlainLiteral;\n+import org.apache.clerezza.rdf.core.TypedLiteral;\n+import org.apache.clerezza.rdf.core.impl.PlainLiteralImpl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import eu.iksproject.rick.servicesapi.model.Representation;\n+import eu.iksproject.rick.servicesapi.model.Text;\n+import eu.iksproject.rick.servicesapi.model.ValueFactory;\n+import eu.iksproject.rick.test.model.RepresentationTest;\n+\n+public class RdfRepresentationTest extends RepresentationTest {\n+\n+    protected ValueFactory valueFactory;\n+    protected LiteralFactory literalFactory;\n+    \n+    @Before\n+    public void init(){\n+        this.valueFactory = RdfValueFactory.getInstance();\n+        this.literalFactory = LiteralFactory.getInstance();\n+    }\n+\n+    @Override\n+    protected Object getUnsupportedValueInstance() {\n+        return null; //indicates that all kinds of Objects are supported!\n+    }\n+    \n+    @Override\n+    protected ValueFactory getValueFactory() {\n+        return valueFactory;\n+    }\n+    /*--------------------------------------------------------------------------\n+     * Additional Tests for special Features of the Clerezza based implementation\n+     * \n+     * This includes mainly support for additional types like PlainLiteral,\n+     * TypedLiteral, UriRefs. The conversion to such types as well as getter for\n+     * such types.\n+     *--------------------------------------------------------------------------\n+     */\n+    /**\n+     * {@link PlainLiteral} is used for natural language text in the Clerezza\n+     * RDF API. This tests if adding {@link PlainLiteral}s to the\n+     * {@link Representation#add(String, Object)} method makes them available\n+     * as {@link Text} instances via the {@link Representation} API (e.g. \n+     * {@link Representation#get(String, String...)}).\n+     */\n+    @Test\n+    public void testPlainLiteralToTextConversion(){\n+        String field = \"urn:test.RdfRepresentation:test.field\";\n+        PlainLiteral noLangLiteral = new PlainLiteralImpl(\"A plain literal without Language\");\n+        PlainLiteral enLiteral = new PlainLiteralImpl(\"An english literal\",new Language(\"en\"));\n+        PlainLiteral deLiteral = new PlainLiteralImpl(\"Ein Deutsches Literal\",new Language(\"de\"));\n+        PlainLiteral deATLiteral = new PlainLiteralImpl(\"Ein Topfen Verband hilft bei Zerrungen\",new Language(\"de-AT\"));\n+        Collection<PlainLiteral> plainLiterals = Arrays.asList(noLangLiteral,enLiteral,deLiteral,deATLiteral);\n+        Representation rep = createRepresentation(null);\n+        rep.add(field, plainLiterals);\n+        //now test, that the Plain Literals are available as natural language\n+        //tests via the Representation Interface!\n+        //1) one without a language\n+        Iterator<Text> noLangaugeTexts = rep.get(field, (String)null);\n+        assertTrue(noLangaugeTexts.hasNext());\n+        Text noLanguageText = noLangaugeTexts.next();\n+        assertEquals(noLangLiteral.getLexicalForm(), noLanguageText.getText());\n+        assertNull(noLanguageText.getLanguage());\n+        assertFalse(noLangaugeTexts.hasNext()); //only a single result\n+        //2) one with a language\n+        Iterator<Text> enLangaugeTexts = rep.get(field, \"en\");\n+        assertTrue(enLangaugeTexts.hasNext());\n+        Text enLangageText = enLangaugeTexts.next();\n+        assertEquals(enLiteral.getLexicalForm(), enLangageText.getText());\n+        assertEquals(enLiteral.getLanguage().toString(), enLangageText.getLanguage());\n+        assertFalse(enLangaugeTexts.hasNext());//only a single result\n+        //3) test to get all natural language values\n+        Set<String> stringValues = new HashSet<String>();\n+        for(PlainLiteral plainLiteral : plainLiterals){\n+            stringValues.add(plainLiteral.getLexicalForm());\n+        }\n+        Iterator<Text> texts = rep.getText(field);\n+        while(texts.hasNext()){\n+            assertTrue(stringValues.remove(texts.next().getText()));\n+        }\n+        assertTrue(stringValues.isEmpty());\n+    }\n+    /**\n+     * {@link TypedLiteral}s are used to represent literal values for different\n+     * xsd dataTypes within Clerezza. This method tests of {@link TypedLiteral}s\n+     * with the data type xsd:string are correctly treated like {@link String}\n+     * values. This tests especially if they are treated as natural language\n+     * texts without language.\n+     */\n+    @Test\n+    public void testTypedLiteralToTextConversion(){\n+        String field = \"urn:test.RdfRepresentation:test.field\";\n+        TypedLiteral stringLiteral = literalFactory.createTypedLiteral(\"This is a stirng value\");\n+        //also add an integer to test that other typed literals are not used as texts\n+        TypedLiteral integerLiteral = literalFactory.createTypedLiteral(new Integer(5));\n+        Representation rep = createRepresentation(null);\n+        rep.add(field, Arrays.asList(stringLiteral,integerLiteral));\n+        //test if the literal is returned when asking for natural language text without language\n+        Iterator<Text> noLangTexts = rep.get(field, (String)null);\n+        assertTrue(noLangTexts.hasNext());\n+        assertEquals(stringLiteral.getLexicalForm(), noLangTexts.next().getText());\n+        assertFalse(noLangTexts.hasNext());\n+        //test that string literals are returned when asking for all natural language text values\n+        Iterator<Text> texts = rep.getText(field);\n+        assertTrue(texts.hasNext());\n+        assertEquals(stringLiteral.getLexicalForm(), texts.next().getText());\n+        assertFalse(texts.hasNext());\n+    }\n+    /**\n+     * {@link TypedLiteral}s are used to represent literal values for different\n+     * xsd dataTypes within Clerezza. This method tests if xsd dataTypes are\n+     * converted to the corresponding java types. \n+     * This is dependent on the {@link LiteralFactory} implementation used by\n+     * the {@link RdfRepresentation} implementation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testTypedLiteralToValueConversion(){\n+        String field = \"urn:test.RdfRepresentation:test.field\";\n+        Integer integerValue = 5;\n+        TypedLiteral integerLiteral = literalFactory.createTypedLiteral(integerValue);\n+        Date dateValue = new Date();\n+        TypedLiteral dateLiteeral = literalFactory.createTypedLiteral(dateValue);\n+        Double doubleValue = Math.PI;\n+        TypedLiteral doubleLiteral = literalFactory.createTypedLiteral(doubleValue);\n+        String stringValue = \"This is a string literal value\";\n+        TypedLiteral stringLiteral = literalFactory.createTypedLiteral(stringValue);\n+        Representation rep = createRepresentation(null);\n+        Collection<TypedLiteral> typedLiterals = \n+            Arrays.asList(integerLiteral,doubleLiteral,stringLiteral,dateLiteeral);\n+        rep.add(field, typedLiterals);\n+        \n+        //now check that such values are available via TypedLiteral\n+        Iterator<TypedLiteral> typedLiteralValues = rep.get(field, TypedLiteral.class);\n+        int size = 0;\n+        while(typedLiteralValues.hasNext()){\n+            assertTrue(typedLiterals.contains(typedLiteralValues.next()));\n+            size++;\n+        }\n+        assertTrue(typedLiterals.size() == size);\n+        \n+        //now check that the values are available via the java object types\n+        //1) integer\n+        Iterator<Integer> intValues = rep.get(field, Integer.class);\n+        assertTrue(intValues.hasNext());\n+        assertEquals(integerValue, intValues.next());\n+        assertFalse(intValues.hasNext());\n+        //2) double\n+        Iterator<Double> doubleValues = rep.get(field, Double.class);\n+        assertTrue(doubleValues.hasNext());\n+        assertEquals(doubleValue, doubleValues.next());\n+        assertFalse(doubleValues.hasNext());\n+        //3) string\n+        Iterator<String> stringValues = rep.get(field, String.class);\n+        assertTrue(stringValues.hasNext());\n+        assertEquals(stringValue, stringValues.next());\n+        assertFalse(stringValues.hasNext());\n+        //4) date\n+        Iterator<Date> dateValues = rep.get(field,Date.class);\n+        assertTrue(dateValues.hasNext());\n+        assertEquals(dateValue, dateValues.next());\n+        assertFalse(dateValues.hasNext());\n+    }\n+    //TODO add tests for adding Integers, Doubles, ... and getting TypedLiterals\n+    public static void main(String[] args) {\n+        RdfRepresentationTest test = new RdfRepresentationTest();\n+        test.init();\n+        test.testTypedLiteralToValueConversion();\n+    }\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfRepresentationTest.java",
                "sha": "c1d0bb4299115847d1f0d3cbbc60cb24a347d3a6",
                "status": "added"
            },
            {
                "additions": 45,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfValueFactoryTest.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfValueFactoryTest.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 0,
                "filename": "rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfValueFactoryTest.java",
                "patch": "@@ -0,0 +1,45 @@\n+package eu.iksproject.rick.model.clerezza;\n+\n+import org.apache.clerezza.rdf.core.UriRef;\n+import org.apache.clerezza.rdf.core.impl.SimpleMGraph;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import eu.iksproject.rick.servicesapi.model.ValueFactory;\n+import eu.iksproject.rick.test.model.ValueFactoryTest;\n+\n+public class RdfValueFactoryTest extends ValueFactoryTest {\n+    \n+    protected RdfValueFactory valueFactory;\n+    \n+    @Before\n+    public void init(){\n+        this.valueFactory = RdfValueFactory.getInstance();\n+    }\n+    \n+    @Override\n+    protected Object getUnsupportedReferenceType() {\n+        return null; //all references are supported (no test for valid IRIs are done by Clerezza)\n+    }\n+    \n+    @Override\n+    protected Object getUnsupportedTextType() {\n+        return null; //all Types are supported\n+    }\n+    \n+    @Override\n+    protected ValueFactory getValueFactory() {\n+        return valueFactory;\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullNodeRepresentation() {\n+        SimpleMGraph graph = new SimpleMGraph();\n+        valueFactory.createRdfRepresentation(null, graph);\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testNullGraphRepresentation() {\n+        UriRef rootNode = new UriRef(\"urn:test.rootNode\");\n+        valueFactory.createRdfRepresentation(rootNode, null);\n+    }\n+    \n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/model/clerezza/src/test/java/eu/iksproject/rick/model/clerezza/RdfValueFactoryTest.java",
                "sha": "596dadc6aaf2938cb453da92ca29649c558d00b7",
                "status": "added"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/yard/solr/src/main/java/eu/iksproject/rick/yard/solr/impl/SolrYard.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/rick/yard/solr/src/main/java/eu/iksproject/rick/yard/solr/impl/SolrYard.java?ref=2175e9bc140fae59d0898c30056938b8dcc2c36d",
                "deletions": 4,
                "filename": "rick/yard/solr/src/main/java/eu/iksproject/rick/yard/solr/impl/SolrYard.java",
                "patch": "@@ -298,10 +298,10 @@ protected void deactivate(ComponentContext context) {\n         long queryGeneration = System.currentTimeMillis();\n         final Set<String> selected;\n         if(select == SELECT.QUERY){\n-            //if query set the fields to add to the result Representations\n-            selected = parsedQuery.getSelectedFields();\n-            //add the score to query results!\n-            selected.add(RdfResourceEnum.resultScore.getUri());\n+\t\t\t//if query set the fields to add to the result Representations\n+\t\t\tselected = new HashSet<String>(parsedQuery.getSelectedFields());\n+\t\t\t//add the score to query results!\n+\t\t\tselected.add(RdfResourceEnum.resultScore.getUri());\n         } else {\n             //otherwise add all fields\n             selected = null;",
                "raw_url": "https://github.com/apache/stanbol/raw/2175e9bc140fae59d0898c30056938b8dcc2c36d/rick/yard/solr/src/main/java/eu/iksproject/rick/yard/solr/impl/SolrYard.java",
                "sha": "ff34c9db13b58911ced052f82f05cf79e380cc3e",
                "status": "modified"
            }
        ],
        "message": "Short Summary:\n - Added Unit Tests for RICK Model implementations\n - Applied this tests to the two current implementations\n - Resolved several Bugs, improved code and documentation\n - Some added functionalities for indexing utilities\n \nDetailed Changes\n \nServices API\n - corrected xml,xmi and xsd namespace within the NamespaceEnum (used '/' instead of '#')\n - Improved Java Doc especially regarding what Exception MUST BE thrown in specific cases (e.g. when NULL is parsed for an parameter)\n - added missing RuntimeExceptions to the throws declaration of methods\n - generally NullPointerExceptions are now thrown instead of IllegalArgumentExeptions if null is parsed as a parameter that does not support it. IllegalArgumentExceptions are now only used if the parsed parameter is not valid.\n - UnsupportedTypeException now extends IllegalArgumentException\n\n\nTest Framework (eu.iksproject.rick.test)\nThis component is intended to define Unit Tests that can be used (and extended) by implementations of the Interfaces defined in the Services API.\n - added Unit Tests for Representation, ValueFactory, Text and Reference\n\nCore (eu.iksproject.rick.core)\n - added Unit Tests for Representation, ValueFactory, Text and Reference\n - adapted Exception handling to confirm with the changes described for the Services API\n - Changed all the different Iterator implementations within the utils package to use the generic AdaptingInterator implementation.\n - Introduced a FilteringIterator that can be used in case one needs only to filter values of an Iteration but does not need to adapt/convert values\n - Fixed a Bug with the remove() method of all the previous Iterator implementations.\n - Corrected several Bugs discovered by the added Unit Tests\n - Removed the unused EnumIterator\n - remove the createComponentInstance from OsgiUtils because it was no longer used\n\nClerezza based Model Implementation (eu.iksproject.rick.model.clerezza)\n - added Unit Tests for Representation, ValueFactory, Text and Reference\n - added additional tests for specific types supported by this implementation\n - remove specific Iterator implementations and replaced them by Adapters and Filters using the AdaptingIterator and FilteringIterator provided by the Core bundle.\n - adapted Exception handling to confirm with the changes described for the Services API\n - Corrected several bugs related to handling natural language texts.\n - Corrected several bugs related to adding/removing Clerezza model instances.\n - Corrected bug that prevented removing multiple values with RdfRepresentation.remove(Stirng,Object) method.\n - Corrected several other bugs discovered while adding the unit tests\n\nSolrYard\n - Corrected a bug where the SolrYard tried to modify the Collection returned by FieldQuery.getSelectedFields() in oder to add the Lucene Score.\n\nindexing/genericRdf\nStarted to add support for an API based configuration for the RdfIndexer. This should make it more easy to used this Utiliy.\n - renamed a Constant to make its meaning more clear\n - removed unused Clerezza dependencies (this indexer directly uses Jena and Jena TDB)\n\nindexing/dbPedia\n - An adaption needed to reflect the changes of the RdfIndexer\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/stanbol/trunk@1058959 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/c4b216b0b4c46b1083c8ef923a5094fd3273dad2",
        "patched_files": [
            "TypeSaveIterator.java",
            "TextIterator.java",
            "RdfIndexerConfig.java",
            "Literal2TextAdapter.java",
            "InMemoryRepresentation.java",
            "DataTypeEnum.java",
            "CacheImpl.java",
            "RdfRepresentation.java",
            "RdfValueFactory.java",
            "ReferenceIterator.java",
            "NaturalTextFilter.java",
            "RdfReference.java",
            "ToStringIterator.java",
            "EnumIterator.java",
            "AdaptingIterator.java",
            "OsgiUtils.java",
            "UnsupportedTypeException.java",
            "SolrYard.java",
            "CommandLineRunner.java",
            "UriRef2ReferenceAdapter.java",
            "RdfText.java",
            "RdfIndexer.java",
            "Reference.java",
            "ModelUtils.java",
            "pom.xml",
            "FilteringIterator.java",
            "Representation.java",
            "InMemoryValueFactory.java",
            "Text.java",
            "NamespaceEnum.java",
            "ValueFactory.java",
            "NaturalLanguageLiteralIterator.java",
            "LiteralAdapter.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "ValueFactoryTest.java",
            "InMemoryValueFactoryTest.java",
            "InMemoryRepresentationTest.java",
            "RdfRepresentationTest.java",
            "RdfValueFactoryTest.java",
            "RepresentationTest.java"
        ]
    },
    "stanbol_250d599": {
        "bug_id": "stanbol_250d599",
        "commit": "https://github.com/apache/stanbol/commit/250d599350b2fe0019bc470aba76f5addfbabb48",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/EnhancementRDFUtils.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/EnhancementRDFUtils.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 2,
                "filename": "enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/EnhancementRDFUtils.java",
                "patch": "@@ -61,17 +61,19 @@\n      *            enhancements this textAnnotation is related to\n      * @param entity\n      *            the related entity\n+     * @param nameField the field used to extract the name\n      */\n     public static UriRef writeEntityAnnotation(EnhancementEngine engine,\n                                                LiteralFactory literalFactory,\n                                                MGraph graph,\n                                                UriRef contentItemId,\n                                                Collection<NonLiteral> relatedEnhancements,\n-                                               Entity entity) {\n+                                               Entity entity,\n+                                               String nameField) {\n         // 1. check if the returned Entity does has a label -> if not return null\n         // add labels (set only a single label. Use \"en\" if available!\n         Text label = null;\n-        Iterator<Text> labels = entity.getRepresentation().getText(RDFS_LABEL.getUnicodeString());\n+        Iterator<Text> labels = entity.getRepresentation().getText(nameField);\n         while (labels.hasNext()) {\n             Text actLabel = labels.next();\n             if (label == null) {",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/EnhancementRDFUtils.java",
                "sha": "0d8849e67f1d03b665f0de225a94f36ec305af9f",
                "status": "modified"
            },
            {
                "additions": 36,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/LabelBasedEntityTaggingEngine.java",
                "changes": 36,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/LabelBasedEntityTaggingEngine.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 0,
                "filename": "enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/LabelBasedEntityTaggingEngine.java",
                "patch": "@@ -0,0 +1,36 @@\n+package org.apache.stanbol.enhancer.engines.entitytagging.impl;\n+\n+import java.util.Map;\n+\n+import org.apache.felix.scr.annotations.Component;\n+import org.apache.felix.scr.annotations.ConfigurationPolicy;\n+import org.apache.felix.scr.annotations.Service;\n+import org.apache.stanbol.enhancer.servicesapi.ContentItem;\n+import org.apache.stanbol.enhancer.servicesapi.EngineException;\n+import org.apache.stanbol.enhancer.servicesapi.EnhancementEngine;\n+import org.apache.stanbol.enhancer.servicesapi.ServiceProperties;\n+\n+@Component(configurationFactory = true, policy = ConfigurationPolicy.REQUIRE, // the baseUri is required!\n+    specVersion = \"1.1\", metatype = true, immediate = true)\n+@Service\n+public class LabelBasedEntityTaggingEngine implements EnhancementEngine, ServiceProperties {\n+\n+    @Override\n+    public int canEnhance(ContentItem ci) throws EngineException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public void computeEnhancements(ContentItem ci) throws EngineException {\n+    // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public Map<String,Object> getServiceProperties() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/LabelBasedEntityTaggingEngine.java",
                "sha": "6b5dd2faea92919449a237172a5cb7211f451110",
                "status": "added"
            },
            {
                "additions": 80,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/NamedEntityTaggingEngine.java",
                "changes": 118,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/NamedEntityTaggingEngine.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 38,
                "filename": "enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/NamedEntityTaggingEngine.java",
                "patch": "@@ -22,12 +22,15 @@\n import static org.apache.stanbol.enhancer.servicesapi.rdf.Properties.RDF_TYPE;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Dictionary;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n import org.apache.clerezza.rdf.core.LiteralFactory;\n import org.apache.clerezza.rdf.core.MGraph;\n@@ -54,6 +57,8 @@\n import org.apache.stanbol.enhancer.servicesapi.rdf.OntologicalClasses;\n import org.apache.stanbol.enhancer.servicesapi.rdf.Properties;\n import org.apache.stanbol.enhancer.servicesapi.rdf.TechnicalClasses;\n+import org.apache.stanbol.entityhub.servicesapi.Entityhub;\n+import org.apache.stanbol.entityhub.servicesapi.EntityhubException;\n import org.apache.stanbol.entityhub.servicesapi.defaults.NamespaceEnum;\n import org.apache.stanbol.entityhub.servicesapi.model.Entity;\n import org.apache.stanbol.entityhub.servicesapi.query.FieldQuery;\n@@ -77,45 +82,53 @@\n @Component(configurationFactory = true, policy = ConfigurationPolicy.REQUIRE, // the baseUri is required!\n specVersion = \"1.1\", metatype = true, immediate = true)\n @Service\n-public class ReferencedSiteEntityTaggingEnhancementEngine implements EnhancementEngine, ServiceProperties {\n+public class NamedEntityTaggingEngine implements EnhancementEngine, ServiceProperties {\n \n     private final Logger log = LoggerFactory.getLogger(getClass());\n \n-    @Property(value = \"dbpedia\")\n+    @Property//(value = \"dbpedia\")\n     public static final String REFERENCED_SITE_ID = \"org.apache.stanbol.enhancer.engines.entitytagging.referencedSiteId\";\n \n-    @Property(boolValue = true)\n+    @Property//(boolValue = true)\n     public static final String PERSON_STATE = \"org.apache.stanbol.enhancer.engines.entitytagging.personState\";\n \n-    @Property(value = \"dbp-ont:Person\")\n+    @Property//(value = \"dbp-ont:Person\")\n     public static final String PERSON_TYPE = \"org.apache.stanbol.enhancer.engines.entitytagging.personType\";\n \n-    @Property(boolValue = true)\n+    @Property//(boolValue = true)\n     public static final String ORG_STATE = \"org.apache.stanbol.enhancer.engines.entitytagging.organisationState\";\n \n-    @Property(value = \"dbp-ont:Organisation\")\n+    @Property//(value = \"dbp-ont:Organisation\")\n     public static final String ORG_TYPE = \"org.apache.stanbol.enhancer.engines.entitytagging.organisationType\";\n \n-    @Property(boolValue = true)\n+    @Property//(boolValue = true)\n     public static final String PLACE_STATE = \"org.apache.stanbol.enhancer.engines.entitytagging.placeState\";\n \n-    @Property(value = \"dbp-ont:Place\")\n+    @Property//(value = \"dbp-ont:Place\")\n     public static final String PLACE_TYPE = \"org.apache.stanbol.enhancer.engines.entitytagging.placeType\";\n-\n+    /**\n+     * Use the RDFS label as default\n+     */\n     @Property(value = \"rdfs:label\")\n     public static final String NAME_FIELD = \"org.apache.stanbol.enhancer.engines.entitytagging.nameField\";\n \n     /**\n-     * Service of the RICK that manages all the active referenced Site. This Service is used to lookup the\n+     * Service of the Entityhub that manages all the active referenced Site. This Service is used to lookup the\n      * configured Referenced Site when we need to enhance a content item.\n      */\n     @Reference\n     protected ReferencedSiteManager siteManager;\n \n     /**\n-     * This is the configured name of the referenced Site used to find entities. The\n-     * {@link ReferencedSiteManager} service of the RICK is used to get the actual {@link ReferencedSite}\n-     * instance for each request to this Engine.\n+     * Used to lookup Entities if the {@link #REFERENCED_SITE_ID} property is\n+     * set to \"entityhub\" or \"local\"\n+     */\n+    @Reference\n+    protected Entityhub entityhub;\n+    \n+    /**\n+     * This holds the id of the {@link ReferencedSite} used to lookup Entities\n+     * or <code>null</code> if the {@link Entityhub} is used. \n      */\n     protected String referencedSiteID;\n \n@@ -125,6 +138,7 @@\n      */\n     public static final Integer defaultOrder = ORDERING_EXTRACTION_ENHANCEMENT;\n \n+\n     /**\n      * State if text annotations of type {@link OntologicalClasses#DBPEDIA_PERSON} are enhanced by this engine\n      */\n@@ -222,6 +236,10 @@ protected void activate(ComponentContext context) throws ConfigurationException\n             throw new ConfigurationException(REFERENCED_SITE_ID,\n                     \"The ID of the Referenced Site is a required Parameter and MUST NOT be an empty String!\");\n         }\n+        if(Entityhub.ENTITYHUB_IDS.contains(this.referencedSiteID.toLowerCase())){\n+            log.info(\"Init NamedEntityTaggingEngine instance for the Entityhub\");\n+            this.referencedSiteID = null;\n+        }\n         Object state = config.get(PERSON_STATE);\n         personState = state == null ? true : Boolean.parseBoolean(state.toString());\n         state = config.get(ORG_STATE);\n@@ -252,21 +270,28 @@ protected void deactivate(ComponentContext context) {\n     }\n \n     public void computeEnhancements(ContentItem ci) throws EngineException {\n-        ReferencedSite site = siteManager.getReferencedSite(referencedSiteID);\n-        if (site == null) {\n-            String msg = String.format(\n-                \"Unable to enhance %s because Referenced Site %s is currently not active!\", ci.getId(),\n-                referencedSiteID);\n-            log.warn(msg);\n-            // TODO: throwing Exceptions is currently deactivated. We need a more clear\n-            // policy what do to in such situations\n-            // throw new EngineException(msg);\n-            return;\n-        }\n-        if (isOfflineMode() && !site.supportsLocalMode()) {\n-            log.warn(\"Unable to enhance ci {} because OfflineMode is not supported by ReferencedSite {}.\",\n-                ci.getId(), site.getId());\n-            return;\n+        final ReferencedSite site;\n+        if(referencedSiteID != null) { //lookup the referenced site\n+            site = siteManager.getReferencedSite(referencedSiteID);\n+            //ensure that it is present\n+            if (site == null) {\n+                String msg = String.format(\n+                    \"Unable to enhance %s because Referenced Site %s is currently not active!\", ci.getId(),\n+                    referencedSiteID);\n+                log.warn(msg);\n+                // TODO: throwing Exceptions is currently deactivated. We need a more clear\n+                // policy what do to in such situations\n+                // throw new EngineException(msg);\n+                return;\n+            }\n+            //and that it supports offline mode if required\n+            if (isOfflineMode() && !site.supportsLocalMode()) {\n+                log.warn(\"Unable to enhance ci {} because OfflineMode is not supported by ReferencedSite {}.\",\n+                    ci.getId(), site.getId());\n+                return;\n+            }\n+        } else { // null indicates to use the Entityhub to lookup Entities\n+            site = null;\n         }\n         UriRef contentItemId = new UriRef(ci.getId());\n \n@@ -292,20 +317,33 @@ public void computeEnhancements(ContentItem ci) throws EngineException {\n \n         for (Map.Entry<UriRef,List<UriRef>> entry : textAnnotations.entrySet()) {\n             try {\n-                computeEntityRecommentations(site, literalFactory, graph, contentItemId, entry.getKey(),\n+                computeEntityRecommentations(site,literalFactory, graph, contentItemId, entry.getKey(),\n                     entry.getValue());\n-            } catch (ReferencedSiteException e) {\n+            } catch (EntityhubException e) {\n                 throw new EngineException(this, ci, e);\n             }\n         }\n     }\n \n+    /**\n+     * Computes the Enhancements\n+     * @param site The {@link ReferencedSiteException} id or <code>null</code> to\n+     * use the {@link Entityhub}\n+     * @param literalFactory the {@link LiteralFactory} used to create RDF Literals\n+     * @param graph the graph to write the lined entities\n+     * @param contentItemId the id of the contentItem\n+     * @param textAnnotation the text annotation to enhance\n+     * @param subsumedAnnotations other text annotations for the same entity \n+     * @return the suggested {@link Entity entities}\n+     * @throws EntityhubException On any Error while looking up Entities via\n+     * the Entityhub\n+     */\n     protected final Iterable<Entity> computeEntityRecommentations(ReferencedSite site,\n-                                                                LiteralFactory literalFactory,\n-                                                                MGraph graph,\n-                                                                UriRef contentItemId,\n-                                                                UriRef textAnnotation,\n-                                                                List<UriRef> subsumedAnnotations) throws ReferencedSiteException {\n+            LiteralFactory literalFactory,\n+            MGraph graph,\n+            UriRef contentItemId,\n+            UriRef textAnnotation,\n+            List<UriRef> subsumedAnnotations) throws EntityhubException {\n         // First get the required properties for the parsed textAnnotation\n         // ... and check the values\n         String name = EnhancementEngineHelper.getString(graph, textAnnotation, ENHANCER_SELECTED_TEXT);\n@@ -325,7 +363,9 @@ public void computeEnhancements(ContentItem ci) throws EngineException {\n         name = cleanupKeywords(name);\n \n         log.debug(\"Process TextAnnotation \" + name + \" type=\" + type);\n-        FieldQuery query = site.getQueryFactory().createFieldQuery();\n+        FieldQuery query = site == null ? //if site is NULL use the Entityhub\n+                entityhub.getQueryFactory().createFieldQuery() : \n+                    site.getQueryFactory().createFieldQuery();\n         // replace spaces with plus to create an AND search for all words in the name!\n         query.setConstraint(nameField, new TextConstraint(name));// name.replace(' ', '+')));\n         if (OntologicalClasses.DBPEDIA_PERSON.equals(type)) {\n@@ -360,7 +400,9 @@ public void computeEnhancements(ContentItem ci) throws EngineException {\n             }\n         }\n         query.setLimit(this.numSuggestions);\n-        QueryResultList<Entity> results = site.findEntities(query);\n+        QueryResultList<Entity> results = site == null? //if site is NULL\n+                entityhub.findEntities(query) : //use the Entityhub\n+                    site.findEntities(query); //else the referenced site\n         log.debug(\"{} results returned by query {}\", results.size(), query);\n \n         List<NonLiteral> annotationsToRelate = new ArrayList<NonLiteral>();\n@@ -370,7 +412,7 @@ public void computeEnhancements(ContentItem ci) throws EngineException {\n         for (Entity guess : results) {\n             log.debug(\"Adding {} to ContentItem {}\", guess, contentItemId);\n             EnhancementRDFUtils.writeEntityAnnotation(this, literalFactory, graph, contentItemId,\n-                annotationsToRelate, guess);\n+                annotationsToRelate, guess, nameField);\n         }\n         return results;\n     }",
                "previous_filename": "enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/ReferencedSiteEntityTaggingEnhancementEngine.java",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/NamedEntityTaggingEngine.java",
                "sha": "71bdd5f2658712f7234e206e738936ea8c17a0ee",
                "status": "renamed"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/resources/OSGI-INF/metatype/metatype.properties",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancer/engines/entitytagging/src/main/resources/OSGI-INF/metatype/metatype.properties?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 2,
                "filename": "enhancer/engines/entitytagging/src/main/resources/OSGI-INF/metatype/metatype.properties",
                "patch": "@@ -1,8 +1,8 @@\n #===============================================================================\n #Properties and Options used to configure ReferencedSiteEntityTaggingEnhancementEngine\n #===============================================================================\n-org.apache.stanbol.enhancer.engines.entitytagging.impl.ReferencedSiteEntityTaggingEnhancementEngine.name=Entityhub Referenced Site based Entity-Tagging-Engine\n-org.apache.stanbol.enhancer.engines.entitytagging.impl.ReferencedSiteEntityTaggingEnhancementEngine.description=Enhancement Engine that uses Entities managed by a Entityhub Referenced Site for semantic lifting of TextAnnotations\n+org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine.name=Named Entity Tagging Engine\n+org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine.description=Links named entities (Persons, Organisations, Places) to Entities managed by an Entityhub Referenced Site\n \n org.apache.stanbol.enhancer.engines.entitytagging.referencedSiteId.name=Referenced Site\n org.apache.stanbol.enhancer.engines.entitytagging.referencedSiteId.description=The ID of the Entityhub Referenced Site used for semantic lifting of TextAnnotations",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/main/resources/OSGI-INF/metatype/metatype.properties",
                "sha": "ed47ddc55065caad538b9d4f97fba23a7fbf65c2",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/test/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/TestEntityLinkingEnhancementEngine.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancer/engines/entitytagging/src/test/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/TestEntityLinkingEnhancementEngine.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 2,
                "filename": "enhancer/engines/entitytagging/src/test/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/TestEntityLinkingEnhancementEngine.java",
                "patch": "@@ -63,8 +63,8 @@\n      */\n     public static final String PLACE = \"New Zealand\";\n \n-    static ReferencedSiteEntityTaggingEnhancementEngine entityLinkingEngine\n-            = new ReferencedSiteEntityTaggingEnhancementEngine();\n+    static NamedEntityTaggingEngine entityLinkingEngine\n+            = new NamedEntityTaggingEngine();\n \n     @BeforeClass\n     public static void setUpServices() throws IOException {",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/engines/entitytagging/src/test/java/org/apache/stanbol/enhancer/engines/entitytagging/impl/TestEntityLinkingEnhancementEngine.java",
                "sha": "d3c8f634cd4041db295d8d64c4e6907fd3a469db",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/jersey/src/main/java/org/apache/stanbol/enhancer/jersey/resource/ContentItemResource.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancer/jersey/src/main/java/org/apache/stanbol/enhancer/jersey/resource/ContentItemResource.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 1,
                "filename": "enhancer/jersey/src/main/java/org/apache/stanbol/enhancer/jersey/resource/ContentItemResource.java",
                "patch": "@@ -409,7 +409,7 @@ public String getSummary() {\n                 Resource object = abstracts.next().getObject();\n                 if (object instanceof PlainLiteral) {\n                     PlainLiteral abstract_ = (PlainLiteral) object;\n-                    if (abstract_.getLanguage().equals(new Language(\"en\"))) {\n+                    if (new Language(\"en\").equals(abstract_.getLanguage())) {\n                         return abstract_.getLexicalForm();\n                     }\n                 }",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/enhancer/jersey/src/main/java/org/apache/stanbol/enhancer/jersey/resource/ContentItemResource.java",
                "sha": "b01ad6b35c024ad1cee5c074f18be4240a22365b",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 5,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java",
                "patch": "@@ -402,7 +402,7 @@ private void deleteEntity(Yard yard,Entity entity) throws YardException {\n         }\n     }\n     private void deleteEntities(Yard yard, Collection<String> ids) throws YardException {\n-        FieldQuery fieldQuery = getQueryFavtory().createFieldQuery();\n+        FieldQuery fieldQuery = getQueryFactory().createFieldQuery();\n         Collection<String> toDelete = new HashSet<String>(ids);\n         for(String id : ids){\n             if(id != null && !id.isEmpty()){\n@@ -420,7 +420,7 @@ private void deleteEntities(Yard yard, Collection<String> ids) throws YardExcept\n \n     private void deleteMappingsbyTarget(Yard yard,String id) throws YardException {\n         if(id != null && !id.isEmpty()){\n-            FieldQuery fieldQuery = getQueryFavtory().createFieldQuery();\n+            FieldQuery fieldQuery = getQueryFactory().createFieldQuery();\n             fieldQuery.setConstraint(RdfResourceEnum.mappingTarget.getUri(), new ReferenceConstraint(id));\n             deleteEntities(yard, ModelUtils.asCollection(\n                 yard.findReferences(fieldQuery).iterator()));\n@@ -578,7 +578,7 @@ public Entity getMappingBySource(String reference) throws YardException{\n             log.warn(\"NULL parsed as Reference -> call to getMappingByEntity ignored (return null)\");\n             return null;\n         }\n-        FieldQuery fieldQuery = getQueryFavtory().createFieldQuery();\n+        FieldQuery fieldQuery = getQueryFactory().createFieldQuery();\n         fieldQuery.setConstraint(RdfResourceEnum.mappingSource.getUri(), new ReferenceConstraint(reference));\n         Yard entityhubYard = lookupYard();\n         QueryResultList<Representation> resultList = entityhubYard.findRepresentation(fieldQuery);\n@@ -609,7 +609,7 @@ public Entity getMappingBySource(String reference) throws YardException{\n             log.warn(\"NULL parsed as Reference -> call to getMappingsBySymbol ignored (return null)\");\n             return null;\n         }\n-        FieldQuery fieldQuery = getQueryFavtory().createFieldQuery();\n+        FieldQuery fieldQuery = getQueryFactory().createFieldQuery();\n         fieldQuery.setConstraint(RdfResourceEnum.mappingTarget.getUri(), new ReferenceConstraint(targetId));\n         Yard enttiyhubYard = lookupYard();\n         QueryResultList<Representation> resultList = enttiyhubYard.findRepresentation(fieldQuery);\n@@ -725,7 +725,7 @@ public Entity getMappingById(String id) throws IllegalArgumentException, Entityh\n         }\n     }\n     @Override\n-    public FieldQueryFactory getQueryFavtory() {\n+    public FieldQueryFactory getQueryFactory() {\n         Yard entityhubYard = getYard();\n         return entityhubYard==null? //if no yard available\n                 DefaultQueryFactory.getInstance(): //use the default",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java",
                "sha": "e03c0548b7ae3b448f255d60a9ab331f56e34650",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 0,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java",
                "patch": "@@ -612,6 +612,12 @@ protected void activate(final ComponentContext context) throws ConfigurationExce\n         }\n         //NOTE that the constructor also validation of the parsed configuration\n         siteConfiguration = new DefaultSiteConfiguration(config);\n+        if(PROHIBITED_SITE_IDS.contains(siteConfiguration.getId().toLowerCase())){\n+            throw new ConfigurationException(SiteConfiguration.ID, String.format(\n+                \"The ID '%s' of this Referenced Site is one of the following \" +\n+                \"prohibited IDs: {} (case insensitive)\",siteConfiguration.getId(),\n+                PROHIBITED_SITE_IDS));\n+        }\n         log.info(\" > initialise Referenced Site {}\",siteConfiguration.getName());\n         //if the accessUri is the same as the queryUri and both the dereferencer and\n         //the entitySearcher uses the same component, than we need only one component",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java",
                "sha": "140ecb100d00d73985542d6a19accbb92b78b367",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/Entityhub.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/Entityhub.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 1,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/Entityhub.java",
                "patch": "@@ -16,7 +16,11 @@\n  */\n package org.apache.stanbol.entityhub.servicesapi;\n \n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapper;\n import org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapping;\n@@ -46,6 +50,18 @@\n public interface Entityhub {\n \n     String DEFAUTL_ENTITYHUB_PREFIX = \"urn:org.apache.stanbol:entityhub\";\n+    /**\n+     * Protected keys to be used as name for the Entityhub. Such keys MUST NOT\n+     * be used as {@link ReferencedSite#getId() id}s for \n+     * {@link ReferencedSite}s. (case insensitive)<p>\n+     * The protected values are <ul>\n+     * <li><code>\"local\"</code>\n+     * <li><code>\"entityhub\"</code>\n+     * </ul>\n+     */\n+    Set<String> ENTITYHUB_IDS = Collections.unmodifiableSet(\n+        new HashSet<String>(Arrays.asList(\n+            \"local\",\"entityhub\")));\n \n     /**\n      * Getter for the Yard storing the Entities and Mappings managed by this\n@@ -150,7 +166,7 @@\n      * {@link Yard} used by the entity hub.\n      * @return the query factory\n      */\n-    FieldQueryFactory getQueryFavtory();\n+    FieldQueryFactory getQueryFactory();\n     /**\n      * Getter for the FieldMappings configured for this Site\n      * @return The {@link FieldMapping} present for this Site.",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/Entityhub.java",
                "sha": "e9a9c06f0726e0ff06bff3a3eceac2f7c02a2462",
                "status": "modified"
            },
            {
                "additions": 102,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java",
                "changes": 118,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 16,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java",
                "patch": "@@ -19,13 +19,17 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n /**\n  * Defines commonly used name spaces to prevent multiple definitions in several\n  * classes\n  * @author Rupert Westenthaler\n  *\n  */\n public enum NamespaceEnum {\n+    \n     //Namespaces defined by the entityhub\n     entityhubModel(\"entityhub\",\"http://www.iks-project.eu/ontology/rick/model/\"),\n     entityhubQuery(\"entityhub-query\",\"http://www.iks-project.eu/ontology/rick/query/\"),\n@@ -69,18 +73,76 @@\n     geonames(\"http://www.geonames.org/ontology#\"),\n     //copyright and license\n     cc(\"http://creativecommons.org/ns#\"),\n+    //Schema.org (see http://schema.org/docs/schemaorg.owl for the Ontology)\n+    schema(\"http://schema.org/\",true),\n     ;\n-    private String ns;\n-    private String prefix;\n+    /**\n+     * The logger\n+     */\n+    private static final Logger log = LoggerFactory.getLogger(NamespaceEnum.class);\n+\n+    private final String ns;\n+    private final String prefix;\n+    private final boolean defaultPrefix;\n+    /**\n+     * Defines a namespace that used the {@link #name()} as prefix.\n+     * @param ns the namespace. MUST NOT be NULL nor empty\n+     */\n     NamespaceEnum(String ns) {\n-        if(ns == null){\n-            throw new IllegalArgumentException(\"The namespace MUST NOT be NULL\");\n-        }\n-        this.ns = ns;\n+        this(null,ns,false);\n+    }\n+    /**\n+     * Defines a namespace by using the {@link #name()} as prefix. If\n+     * <code>true</code> is parsed a second parameter this namespace is marked\n+     * as the default<p>\n+     * <b>NOTE: </b> Only a single namespace can be defined as default. In case\n+     * multiple namespaces are marked as default the one with the lowest\n+     * {@link #ordinal()} will be used as default. This will be the topmost entry\n+     * in this enumeration.\n+     * @param ns the namespace. MUST NOT be <code>null</code> nor empty\n+     * @param defaultPrefix the default namespace indicator\n+     */\n+    NamespaceEnum(String ns,boolean defaultPrefix) {\n+        this(null,ns,defaultPrefix);\n     }\n+    /**\n+     * Defines a namespace with a customised prefix. This should be used if the\n+     * prefix needs to be different as the {@link #name()} of the enumeration\n+     * entry.\n+     * @param prefix the prefix. If <code>null</code> the {@link #name()} is\n+     * used. MUST NOT be an empty string\n+     * @param ns the namespace. MUST NOT be <code>null</code> nor empty\n+     */\n     NamespaceEnum(String prefix, String ns) {\n-        this(ns);\n-        this.prefix = prefix;\n+        this(prefix,ns,false);\n+    }\n+    /**\n+     * Defines a namespace with a customised prefix. This should be used if the\n+     * prefix needs to be different as the {@link #name()} of the enumeration\n+     * entry.<p>\n+     * <b>NOTE: </b> Only a single namespace can be defined as default. In case\n+     * multiple namespaces are marked as default the one with the lowest\n+     * {@link #ordinal()} will be used as default. This will be the topmost entry\n+     * in this enumeration.\n+     * @param prefix the prefix. If <code>null</code> the {@link #name()} is\n+     * used. MUST NOT be an empty string\n+     * @param ns the namespace. MUST NOT be <code>null</code> nor empty\n+     * @param defaultPrefix the default namespace indicator\n+     */\n+    NamespaceEnum(String prefix, String ns,boolean defaultPrefix) {\n+        if(ns == null || ns.isEmpty()){\n+            throw new IllegalArgumentException(\"The namespace MUST NOT be NULL nor empty\");\n+        }\n+        this.ns = ns;\n+        if(prefix == null){\n+            this.prefix = name();\n+        } else if(prefix.isEmpty()){\n+            throw new IllegalArgumentException(\"The prefix MUST NOT be emtpty.\" +\n+            \t\t\"Use NULL to use the name or parse the prefix to use\");\n+        } else {\n+            this.prefix = prefix;\n+        }\n+        this.defaultPrefix = defaultPrefix;\n     }\n     public String getNamespace(){\n         return ns;\n@@ -95,21 +157,35 @@ public String toString() {\n     /*\n      * ==== Code for Lookup Methods based on Prefix and Namespace ====\n      */\n-    private static Map<String, NamespaceEnum> prefix2Namespace;\n-    private static Map<String, NamespaceEnum> namespace2Prefix;\n+    private final static Map<String, NamespaceEnum> prefix2Namespace;\n+    private final static Map<String, NamespaceEnum> namespace2Prefix;\n+    private final static NamespaceEnum defaultNamespace;\n     static {\n         Map<String,NamespaceEnum> p2n = new HashMap<String, NamespaceEnum>();\n         Map<String,NamespaceEnum> n2p = new HashMap<String, NamespaceEnum>();\n         //The Exceptions are only thrown to check that this Enum is configured\n         //correctly!\n+        NamespaceEnum defaultNs = null;\n         for(NamespaceEnum entry : NamespaceEnum.values()){\n+            if(entry.isDefault()){\n+                if(defaultNs == null){\n+                    defaultNs = entry;\n+                } else {\n+                    log.warn(\"Found multiple default namespace definitions! Will use the one with the lowest ordinal value.\");\n+                    log.warn(\" > used default: prefix:{}, namespace:{}, ordinal:{}\",\n+                        new Object[]{defaultNs.getPrefix(),defaultNs.getNamespace(),defaultNs.ordinal()});\n+                    log.warn(\" > this one    : prefix:{}, namespace:{}, ordinal:{}\",\n+                        new Object[]{entry.getPrefix(),entry.getNamespace(),entry.ordinal()});\n+                }\n+            }\n             if(p2n.containsKey(entry.getPrefix())){\n                 throw new IllegalStateException(\n                         String.format(\"Prefix %s used for multiple namespaces: %s and %s\",\n                                 entry.getPrefix(),\n                                 p2n.get(entry.getPrefix()),\n                                 entry.getNamespace()));\n             } else {\n+                log.debug(\"add {} -> {} mapping\",entry.getPrefix(),entry.getNamespace());\n                 p2n.put(entry.getPrefix(), entry);\n             }\n             if(n2p.containsKey(entry.getNamespace())){\n@@ -119,11 +195,13 @@ public String toString() {\n                                 p2n.get(entry.getNamespace()),\n                                 entry.getNamespace()));\n             } else {\n+                log.debug(\"add {} -> {} mapping\",entry.getNamespace(),entry.getPrefix());\n                 n2p.put(entry.getNamespace(), entry);\n             }\n         }\n         prefix2Namespace = Collections.unmodifiableMap(p2n);\n         namespace2Prefix = Collections.unmodifiableMap(n2p);\n+        defaultNamespace = defaultNs;\n     }\n     /**\n      * Getter for the {@link NamespaceEnum} entry based on the string namespace\n@@ -136,18 +214,18 @@ public static NamespaceEnum forNamespace(String namespace){\n     }\n     /**\n      * Getter for the {@link NamespaceEnum} entry based on the prefix\n-     * @param prefix the prefix\n+     * @param prefix the prefix or <code>null</code> to get the default namespace\n      * @return the {@link NamespaceEnum} entry or <code>null</code> if the prased\n      *    prefix is not present\n      */\n     public static NamespaceEnum forPrefix(String prefix){\n-        return prefix2Namespace.get(prefix);\n+        return prefix == null ? defaultNamespace : prefix2Namespace.get(prefix);\n     }\n     /**\n-     * Lookup if the parsed URI uses one of the registered prefixes of this\n-     * Enumeration. If this is the case, the prefix is replaced by the namespace\n-     * and the full URI is returned. If no prefix is returned, the\n-     * parsed URI is returned\n+     * Lookup if the parsed short URI (e.g \"rdfs:label\") uses one of the \n+     * registered prefixes of this Enumeration of if the parsed short URI uses\n+     * the default namespace (e.g. \"name\"). In case the prefix could not be found\n+     * the parsed URI is returned unchanged\n      * @param shortUri the short URI\n      * @return the full URI if the parsed shortUri uses a prefix defined by this\n      * Enumeration. Otherwise the parsed value.\n@@ -162,7 +240,15 @@ public static String getFullName(String shortUri){\n             if(namespace!= null){\n                 shortUri = namespace.getNamespace()+shortUri.substring(index+1);\n             }\n+        } else if(defaultNamespace != null){\n+            shortUri = defaultNamespace.getNamespace()+shortUri;\n         }\n         return shortUri;\n     }\n+    /**\n+     * @return the defaultPrefix\n+     */\n+    public boolean isDefault() {\n+        return defaultPrefix;\n+    }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java",
                "sha": "c54d71b958162b73f7110e3e02b31f69a524e547",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/site/ReferencedSite.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/site/ReferencedSite.java?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 2,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/site/ReferencedSite.java",
                "patch": "@@ -17,7 +17,9 @@\n package org.apache.stanbol.entityhub.servicesapi.site;\n \n import java.io.InputStream;\n+import java.util.Set;\n \n+import org.apache.stanbol.entityhub.servicesapi.Entityhub;\n import org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapper;\n import org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapping;\n import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n@@ -30,10 +32,16 @@\n \n public interface ReferencedSite {\n \n+    /**\n+     * List of {@link #getId() ids} that are not allowed to be used (case\n+     * insensitive) for referenced sites.\n+     */\n+    Set<String> PROHIBITED_SITE_IDS = Entityhub.ENTITYHUB_IDS;\n     /**\n      * The Id of this site. This Method MUST return the same value as\n-     * <code>{@link #getConfiguration()}.getId()</code>. It is only there to\n-     * make it more easy to access the Id of the site\n+     * <code>{@link #getConfiguration()}.getId()</code>.\n+     * The configured ID MUST NOT be <code>null</code>, empty or one of the\n+     * {@link #PROHIBITED_SITE_IDS}.\n      * @return the ID of this site\n      */\n     String getId();",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/site/ReferencedSite.java",
                "sha": "1e4e46426bf38c05d4016da3b6165a588c16b7e8",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/indexing/dblp/src/main/resources/indexing/config/indexing.properties",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/dblp/src/main/resources/indexing/config/indexing.properties?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 2,
                "filename": "entityhub/indexing/dblp/src/main/resources/indexing/config/indexing.properties",
                "patch": "@@ -31,10 +31,10 @@ indexingDestination=org.apache.stanbol.entityhub.indexing.destination.solryard.S\n org.apache.stanbol.entityhub.site.entityPrefix=http://dblp.l3s.de/d2r/resource\n \n org.apache.stanbol.entityhub.site.accessUri=http://dblp.l3s.de/d2r/resource/\n-org.apache.stanbol.entityhub.site.dereferencerType=org.apache.stanbol.entityhub.site.CoolUriDereferencer\n+org.apache.stanbol.entityhub.site.dereferencerType=org.apache.stanbol.entityhub.dereferencer.CoolUriDereferencer\n # The SPARQL endpoint is a d2r server so use a standard sparql server\n org.apache.stanbol.entityhub.site.queryUri=http://dblp.l3s.de/d2r/sparql\n-org.apache.stanbol.entityhub.site.searcherType=org.apache.stanbol.entityhub.site.SparqlSearcher\n+org.apache.stanbol.entityhub.site.searcherType=org.apache.stanbol.entityhub.searcher.SparqlSearcher\n \n # The mappings used when importing an entity form this site to the Entityhub (optional)\n # The value need to point to the file with the mappings within the config directory",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/indexing/dblp/src/main/resources/indexing/config/indexing.properties",
                "sha": "ab74241978b61957de0aabcfd681638ffe59c14f",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/indexing/dbpedia/src/main/resources/indexing/config/indexing.properties",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/dbpedia/src/main/resources/indexing/config/indexing.properties?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 2,
                "filename": "entityhub/indexing/dbpedia/src/main/resources/indexing/config/indexing.properties",
                "patch": "@@ -49,9 +49,9 @@ org.apache.stanbol.entityhub.site.entityPrefix=http://dbpedia.org/resource/;http\n # Dereferencer should use SPARQL because Cool URI will omit statements for popular\n # Entities. \n org.apache.stanbol.entityhub.site.accessUri=http://dbpedia.org/sparql/\n-org.apache.stanbol.entityhub.site.dereferencerType=org.apache.stanbol.entityhub.site.SparqlDereferencer\n+org.apache.stanbol.entityhub.site.dereferencerType=org.apache.stanbol.entityhub.dereferencer.SparqlDereferencer\n # The SPARQL endpoint of DBpedia supports Virtuoso specific extensions\n-org.apache.stanbol.entityhub.site.searcherType=org.apache.stanbol.entityhub.site.VirtuosoSearcher\n+org.apache.stanbol.entityhub.site.searcherType=org.apache.stanbol.entityhub.searcher.VirtuosoSearcher\n org.apache.stanbol.entityhub.site.queryUri=http://dbpedia.org/sparql\n \n # The mappings used when importing an entity form this site to the Entityhub (optional)",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/indexing/dbpedia/src/main/resources/indexing/config/indexing.properties",
                "sha": "dbd8f4312bd41e166738d1e08cd760dd49d1eae5",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/indexing/genericrdf/src/main/resources/indexing/config/indexing.properties",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/genericrdf/src/main/resources/indexing/config/indexing.properties?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 5,
                "filename": "entityhub/indexing/genericrdf/src/main/resources/indexing/config/indexing.properties",
                "patch": "@@ -114,16 +114,16 @@ indexingDestination=org.apache.stanbol.entityhub.indexing.destination.solryard.S\n #org.apache.stanbol.entityhub.site.accessUri=http://example.org/resource\"\n #org.apache.stanbol.entityhub.site.dereferencerType=\n # available EntityDereferencer implementation\n-# - org.apache.stanbol.entityhub.site.CoolUriDereferencer\n-# - org.apache.stanbol.entityhub.site.SparqlDereferencer\n+# - org.apache.stanbol.entityhub.dereferencer.CoolUriDereferencer\n+# - org.apache.stanbol.entityhub.dereferencer.SparqlDereferencer\n \n # (b) search entities (queryUri and EntitySearcher implementation)\n #org.apache.stanbol.entityhub.site.queryUri=http://example.org/sparql\n #org.apache.stanbol.entityhub.site.searcherType=\n # available EntitySearcher implementation\n-# - org.apache.stanbol.entityhub.site.SparqlSearcher (generic SPARQL)\n-# - org.apache.stanbol.entityhub.site.LarqSearcher (Larq SPARQL extensions)\n-# - org.apache.stanbol.entityhub.site.VirtuosoSearcher (Virtuoso SPARQL extensions)\n+# - org.apache.stanbol.entityhub.searcher.SparqlSearcher (generic SPARQL)\n+# - org.apache.stanbol.entityhub.searcher.LarqSearcher (Larq SPARQL extensions)\n+# - org.apache.stanbol.entityhub.searcher.VirtuosoSearcher (Virtuoso SPARQL extensions)\n \n # The referenced site can also specify additional mappings to be used in the\n # case an entity of this site is imported to the Entityhub.",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/entityhub/indexing/genericrdf/src/main/resources/indexing/config/indexing.properties",
                "sha": "843399800347e7c10e91878896f8d713f4b4f537",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-dbpedia.config",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-dbpedia.config?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 0,
                "filename": "launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-dbpedia.config",
                "previous_filename": "launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.ReferencedSiteEntityTaggingEnhancementEngine-DBpedia.config",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-dbpedia.config",
                "sha": "7f7f03a2d797705e1ee3ecb1b6a350bc9a59faef",
                "status": "renamed"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/stanbol/blob/250d599350b2fe0019bc470aba76f5addfbabb48/launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-local.config",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-local.config?ref=250d599350b2fe0019bc470aba76f5addfbabb48",
                "deletions": 0,
                "filename": "launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-local.config",
                "patch": "@@ -0,0 +1,8 @@\n+org.apache.stanbol.enhancer.engines.entitytagging.nameField=\"name\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.personType=\"Person\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.personState=B\"true\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.referencedSiteId=\"local\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.placeState=B\"true\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.organisationState=B\"true\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.organisationType=\"Organization\"\r\n+org.apache.stanbol.enhancer.engines.entitytagging.placeType=\"Place\"\r",
                "raw_url": "https://github.com/apache/stanbol/raw/250d599350b2fe0019bc470aba76f5addfbabb48/launchers/full/src/main/resources/resources/config/org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-local.config",
                "sha": "a25d8f22b55dc314b2065a9f1aabccf6e6bb1b14",
                "status": "added"
            }
        ],
        "message": "STANBOL-230: Adds support for using the Entityhub for linking Entities for TextAnnotations\n\n* By configuring \"local\" or \"entityhub\" one can now use the Entityhub to suggest Entities for TextAnnotations\n* Because now it is no longer true that only ReferencedSites can be used for entity tagging the engine was renamed to NamedEntityTaggingEngine. All Configuration files (e.g. in the launcher) where adapted to the new name.\n* Added a second default configuration to the full launcher that uses the Entityhub for enhancing Entities. This Configuration uses \"http://schema.org\" types for \"Person\", \"Organization\" and \"Place\" as well as the \"name\" field for lookup.\n* The ids \"local\" and \"entityhub\" are now reserved for the Entityhub and MUST NOT be used as IDs for Referenced Sites.\n* added a list of IDs reserved for the Entityhub to the Entityhub Interface.\n* added a list of prohibited IDs for ReferencedSites to the ReferencedSite interface. Currently only the IDs assigned to the Entityhub are in that list\n\n### other changes\n\n* corrected a type in the Entityhub interface (getQueryFavtory -> getQueryFactory)\n* added \"http://schema.org\" to the NamespaceEnum (prefix is \"schema\")\n* added support for a default namespace to the NamespaceEnum.\n* the NamespaceEnum now uses schema.org as default namespace. This means that the property \"name\" in configurations would be mapped to \"http://schema.org/name\".\n* The \"indexing.properties\" files of all indexing utilities used wrong IDs for EntityDereferencer and EntitySearcher implementations. This is now corrected\n* \"rdfs:label\" was hard coded to retrieve the value for the entity-label property of TextAnnotations. Now the value of the property used to search for entities is used.\n* corrected a bug in ContentItemResource (enhancer.jersey) that caused NPEs in case a Clerezza PlainLiteral had no language defined.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/stanbol/trunk@1137617 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/7aa6b74caaca9fdb8ac467e4b229ada7b4732c38",
        "patched_files": [
            "Entityhub.java",
            "ContentItemResource.java",
            "ReferencedSite.java",
            "org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-dbpedia.config",
            "NamespaceEnum.java",
            "LabelBasedEntityTaggingEngine.java",
            "NamedEntityTaggingEngine.java",
            "metatype.properties",
            "ReferencedSiteImpl.java",
            "EnhancementRDFUtils.java",
            "org.apache.stanbol.enhancer.engines.entitytagging.impl.NamedEntityTaggingEngine-local.config",
            "EntityhubImpl.java",
            "indexing.properties"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "TestEntityLinkingEnhancementEngine.java"
        ]
    },
    "stanbol_2abf185": {
        "bug_id": "stanbol_2abf185",
        "commit": "https://github.com/apache/stanbol/commit/2abf185a28448d85b367fefe1dfa922b91a62b65",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/2abf185a28448d85b367fefe1dfa922b91a62b65/commons/namespaceprefix/service/src/main/java/org/apache/stanbol/commons/namespaceprefix/service/StanbolNamespacePrefixService.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/commons/namespaceprefix/service/src/main/java/org/apache/stanbol/commons/namespaceprefix/service/StanbolNamespacePrefixService.java?ref=2abf185a28448d85b367fefe1dfa922b91a62b65",
                "deletions": 1,
                "filename": "commons/namespaceprefix/service/src/main/java/org/apache/stanbol/commons/namespaceprefix/service/StanbolNamespacePrefixService.java",
                "patch": "@@ -309,12 +309,12 @@ protected NamespacePrefixProvider getService(ServiceReference ref){\n     \n     @Deactivate\n     protected void deactivate(ComponentContext ctx) {\n-        bundleContext = null;\n         if(providersTracker != null) {\n             providersTracker.close();\n             providersTracker = null;\n         }\n         mappingsFile = null;\n+        bundleContext = null;\n     }\n \n     @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/2abf185a28448d85b367fefe1dfa922b91a62b65/commons/namespaceprefix/service/src/main/java/org/apache/stanbol/commons/namespaceprefix/service/StanbolNamespacePrefixService.java",
                "sha": "442d18fb3a8e438b480e8814e0a7ff8d24694e60",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/2abf185a28448d85b367fefe1dfa922b91a62b65/entityhub/yard/sesame/src/main/java/org/apache/stanbol/entityhub/yard/sesame/impl/SesameYardComponent.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/sesame/src/main/java/org/apache/stanbol/entityhub/yard/sesame/impl/SesameYardComponent.java?ref=2abf185a28448d85b367fefe1dfa922b91a62b65",
                "deletions": 1,
                "filename": "entityhub/yard/sesame/src/main/java/org/apache/stanbol/entityhub/yard/sesame/impl/SesameYardComponent.java",
                "patch": "@@ -224,7 +224,9 @@ public void removedService(ServiceReference serviceReference, Object o) {\n         \tlog.info(\" - currently used Repository was removed (ref: {})\", serviceReference);\n             unregisterSesameYard();\n         }\n-        List<ServiceReference> others = Arrays.asList(repositoryTracker.getServiceReferences());\n+        ServiceReference[] serviceRefs = repositoryTracker.getServiceReferences();\n+        List<ServiceReference> others = serviceRefs == null ? Collections.<ServiceReference>emptyList() :\n+            Arrays.asList(serviceRefs);\n         if(others.size() > 1){\n         \tCollections.sort(others); //sort by priority\n         }",
                "raw_url": "https://github.com/apache/stanbol/raw/2abf185a28448d85b367fefe1dfa922b91a62b65/entityhub/yard/sesame/src/main/java/org/apache/stanbol/entityhub/yard/sesame/impl/SesameYardComponent.java",
                "sha": "17896144ae6c68ea23d5705b0b56ae564b1e7356",
                "status": "modified"
            }
        ],
        "message": "minor: fixed two NPE in deactivate methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/stanbol/trunk@1599974 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/22611633b89ad815b5f6cb1070939ce90f76286d",
        "patched_files": [
            "StanbolNamespacePrefixService.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "StanbolNamespacePrefixServiceTest.java"
        ]
    },
    "stanbol_35b19b9": {
        "bug_id": "stanbol_35b19b9",
        "commit": "https://github.com/apache/stanbol/commit/35b19b963b32803ee899ff093d9d7873eb65a11c",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/35b19b963b32803ee899ff093d9d7873eb65a11c/fise/engines/opencalais/src/test/java/eu/iksproject/fise/engines/opencalais/impl/TestOpenCalaisEngine.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/fise/engines/opencalais/src/test/java/eu/iksproject/fise/engines/opencalais/impl/TestOpenCalaisEngine.java?ref=35b19b963b32803ee899ff093d9d7873eb65a11c",
                "deletions": 2,
                "filename": "fise/engines/opencalais/src/test/java/eu/iksproject/fise/engines/opencalais/impl/TestOpenCalaisEngine.java",
                "patch": "@@ -43,7 +43,7 @@\n   public static void oneTimeSetup() {\r\n     calaisExtractor = new OpenCalaisEngine();\r\n     calaisExtractor.tcManager = TcManager.getInstance();\r\n-    if (TEST_LICENSE_KEY.matches(\"\\\\w+\")) {\r\n+    if (TEST_LICENSE_KEY != null && TEST_LICENSE_KEY.matches(\"\\\\w+\")) {\r\n       calaisExtractor.setLicenseKey(TEST_LICENSE_KEY);\r\n     }\r\n   }\r\n@@ -88,7 +88,7 @@ public void testEntityExtraction() {\n \r\n   @Test\r\n   public void testCalaisConnection() {\r\n-  \tAssume.assumeNotNull(TEST_LICENSE_KEY);\r\n+  \tAssume.assumeNotNull(calaisExtractor.getLicenseKey());\r\n   \ttry {\r\n   \t  ContentItem ci = wrapAsContentItem(TEST_TEXT);\r\n   \t  ci.getMetadata().add(new TripleImpl(new UriRef(ci.getId()), Properties.DC_LANGUAGE, LiteralFactory.getInstance().createTypedLiteral(\"en\")));\r",
                "raw_url": "https://github.com/apache/stanbol/raw/35b19b963b32803ee899ff093d9d7873eb65a11c/fise/engines/opencalais/src/test/java/eu/iksproject/fise/engines/opencalais/impl/TestOpenCalaisEngine.java",
                "sha": "18d3ca1533dd3aa1e01382a4fe9bd9174612efd9",
                "status": "modified"
            }
        ],
        "message": "STANBOL-17 - Fixed NullPointerException int test\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/stanbol/trunk@1049547 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/b238dd28be9eb48675398bc128847accbf478704",
        "patched_files": [
            "OpenCalaisEngine.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "TestOpenCalaisEngine.java"
        ]
    },
    "stanbol_596fc27": {
        "bug_id": "stanbol_596fc27",
        "commit": "https://github.com/apache/stanbol/commit/596fc271b9f615868102b02e8da5bf408732f69d",
        "file": [
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubConfigurationImpl.java",
                "changes": 28,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubConfigurationImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 14,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubConfigurationImpl.java",
                "patch": "@@ -51,15 +51,15 @@\n     private final Logger log = LoggerFactory.getLogger(EntityhubConfigurationImpl.class);\n \n     @Property(name=EntityhubConfiguration.ID,value=\"entityhub\")\n-    protected String entityhubID;\n+    private String entityhubID;\n     @Property(name=EntityhubConfiguration.NAME,value=\"<organisations> Entityhub\")\n-    protected String entityhubName;\n+    private String entityhubName;\n     @Property(name=EntityhubConfiguration.DESCRIPTION,value=\"The entityhub holding all entities of <organisation>\")\n-    protected String entityhubDescription;\n+    private String entityhubDescription;\n     @Property(name=EntityhubConfiguration.PREFIX,value=\"urn:org.apache.stanbol:entityhub:\")\n-    protected String entityhubPrefix;\n+    private String entityhubPrefix;\n     @Property(name=EntityhubConfiguration.ENTITYHUB_YARD_ID,value=EntityhubConfiguration.DEFAULT_ENTITYHUB_YARD_ID)\n-    protected String entityhubYardId;\n+    private String entityhubYardId;\n     @Property(\n             name=EntityhubConfiguration.FIELD_MAPPINGS,\n             value ={ //This is the default config for well known Ontologies\n@@ -111,7 +111,7 @@\n                 \"foaf:logo | d=xsd:anyURI\",\n                 \"foaf:page | d=xsd:anyURI\" //page about the entity\n             })\n-    protected String[] fieldMappingConfig;\n+    private String[] fieldMappingConfig;\n     //NOTE: there is no other way than hard coding the names there!\n     @Property(name=EntityhubConfiguration.DEFAULT_MAPPING_STATE,options={\n             @PropertyOption( //seems, that name and value are exchanged ...\n@@ -121,7 +121,7 @@\n                     value='%'+EntityhubConfiguration.DEFAULT_MAPPING_STATE+\".option.confirmed\",\n                     name=\"confirmed\")\n             },value=\"proposed\")\n-    protected String defaultMappingStateString;\n+    private String defaultMappingStateString;\n     @Property(name=EntityhubConfiguration.DEFAULT_SYMBOL_STATE,options={\n             @PropertyOption( //seems, that name and value are exchanged ...\n                     value='%'+EntityhubConfiguration.DEFAULT_SYMBOL_STATE+\".option.proposed\",\n@@ -130,7 +130,7 @@\n                     value='%'+EntityhubConfiguration.DEFAULT_SYMBOL_STATE+\".option.active\",\n                     name=\"active\")\n             },value=\"proposed\")\n-    protected String defaultSymblStateString;\n+    private String defaultSymblStateString;\n \n     @Activate\n     protected void activate(ComponentContext context) throws ConfigurationException {\n@@ -140,8 +140,8 @@ protected void activate(ComponentContext context) throws ConfigurationException\n         log.info(\"entityhubName:{}\",entityhubName);\n         this.entityhubID = OsgiUtils.checkProperty(properties, EntityhubConfiguration.ID).toString();\n         this.entityhubName = OsgiUtils.checkProperty(properties, EntityhubConfiguration.NAME, this.entityhubID).toString();\n-        Object entityhubDescription = properties.get(EntityhubConfiguration.DESCRIPTION);\n-        this.entityhubDescription = entityhubDescription==null?null:entityhubDescription.toString();\n+        Object entityhubDescriptionObject = properties.get(EntityhubConfiguration.DESCRIPTION);\n+        this.entityhubDescription = entityhubDescriptionObject==null?null:entityhubDescriptionObject.toString();\n         this.entityhubPrefix = OsgiUtils.checkProperty(properties, EntityhubConfiguration.PREFIX).toString();\n         this.entityhubYardId = OsgiUtils.checkProperty(properties, EntityhubConfiguration.ENTITYHUB_YARD_ID).toString();\n         Object defaultSymbolState = properties.get(EntityhubConfiguration.DEFAULT_SYMBOL_STATE);\n@@ -156,9 +156,9 @@ protected void activate(ComponentContext context) throws ConfigurationException\n         } else {\n             this.defaultMappingStateString = defaultMappingState.toString();\n         }\n-        Object fieldMappingConfig = OsgiUtils.checkProperty(properties, EntityhubConfiguration.FIELD_MAPPINGS);\n-        if(fieldMappingConfig instanceof String[]){\n-            this.fieldMappingConfig = (String[])fieldMappingConfig;\n+        Object fieldMappingConfigObject = OsgiUtils.checkProperty(properties, EntityhubConfiguration.FIELD_MAPPINGS);\n+        if(fieldMappingConfigObject instanceof String[]){\n+            this.fieldMappingConfig = (String[])fieldMappingConfigObject;\n         } else {\n             throw new ConfigurationException(EntityhubConfiguration.FIELD_MAPPINGS, \"Values for this property must be of type Stirng[]!\");\n         }\n@@ -180,7 +180,7 @@ public String getDescription() {\n \n     @Override\n     public String getEntityhubPrefix() {\n-        return entityhubID;\n+        return entityhubPrefix;\n     }\n \n     @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubConfigurationImpl.java",
                "sha": "e8bf9f17aaa0f9e8041cdc0dc6dec5a57edb133e",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 7,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java",
                "patch": "@@ -82,7 +82,7 @@\n      * The field mapper holding global mappings that are used for mapping\n      * representations of entities for any referenced sites\n      */\n-    protected FieldMapper fieldMapper;\n+    private FieldMapper fieldMapper;\n \n     /**\n      * The yard where this Entityhub instance stores its data\n@@ -101,27 +101,27 @@\n      *      on an component that is in the \"unsatisfied\" state.\n      * </ul>\n      */\n-    protected Yard entityhubYard; //reference initialised in the activate method\n+    private Yard entityhubYard; //reference initialised in the activate method\n     /*\n      * TODO: The YardManager is currently not used.\n      */\n     @Reference // 1..1, static\n-    protected YardManager yardManager;\n+    private YardManager yardManager;\n     /**\n      * The Configuration of the Entityhub\n      * TODO: Maybe refactor this implementation to implement this interface or\n      * to extend the {@link EntityhubConfigurationImpl}.\n      */\n     @Reference // 1..1, static\n-    protected EntityhubConfiguration config;\n+    private EntityhubConfiguration config;\n     /**\n      * The site manager is used to search for entities within the Entityhub framework\n      */\n     @Reference // 1..1, static\n-    protected ReferencedSiteManager siteManager;\n+    private ReferencedSiteManager siteManager;\n \n-    private String DEFAULT_SYMBOL_PREFIX = \"symbol\";\n-    private String DEFAULT_MAPPING_PREFIX = \"mapping\";\n+    private static final String DEFAULT_SYMBOL_PREFIX = \"symbol\";\n+    private static final String DEFAULT_MAPPING_PREFIX = \"mapping\";\n     /**\n      * Activates the Entityhub (OSGI Lifecycle method)\n      * @param context the OSGI component context (stored in {@link #context})",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/EntityhubImpl.java",
                "sha": "829d36d9e37e1e58bf1343f726c64cbc5d2c57e0",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferenceManagerImpl.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferenceManagerImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferenceManagerImpl.java",
                "patch": "@@ -58,9 +58,9 @@\n })\n public class ReferenceManagerImpl implements ReferencedSiteManager {\n \n-    protected final Logger log;\n+    private final Logger log;\n \n-    protected ComponentContext context;\n+//    private ComponentContext context;\n     public ReferenceManagerImpl(){\n         super();\n         log = LoggerFactory.getLogger(ReferenceManagerImpl.class);\n@@ -98,13 +98,13 @@ public ReferenceManagerImpl(){\n \n     @Activate\n     protected void activate(ComponentContext context) {\n-        this.context = context;\n+//        this.context = context;\n         log.info(\"Activate ReferenceManager with context\" + context);\n     }\n     @Deactivate\n     protected void deactivate(ComponentContext context) {\n         log.info(\"Deactivate ReferenceManager with context\" + context);\n-        this.context = null;\n+//        this.context = null;\n         synchronized (prefixMap) {\n             this.prefixList.clear();\n             this.prefixMap.clear();",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferenceManagerImpl.java",
                "sha": "e29a494b76aaf8a17466d935e7b16059c8efebcb",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 6,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java",
                "patch": "@@ -235,10 +235,10 @@\n         })\n public class ReferencedSiteImpl implements ReferencedSite {\n     static final int maxInt = Integer.MAX_VALUE;\n-    protected final Logger log;\n-    protected ComponentContext context;\n-    protected Dictionary<String,?> properties;\n-    protected FieldMapper fieldMappings;\n+    private final Logger log;\n+    private ComponentContext context;\n+    private Dictionary<String,?> properties;\n+    private FieldMapper fieldMappings;\n \n     private final Object searcherAndDereferencerLock = new Object();\n     private Boolean dereferencerEqualsEntitySearcherComponent;\n@@ -247,7 +247,7 @@\n \n     private String dereferencerComponentName;\n     private ComponentInstance dereferencerComponentInstance;\n-    protected EntityDereferencer dereferencer;\n+    private EntityDereferencer dereferencer;\n \n     private String entitySearcherComponentName;\n     private EntitySearcher entitySearcher;\n@@ -594,7 +594,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof ReferencedSite && ((ReferencedSite)obj).getId().equals(getId());\n+        return obj instanceof ReferencedSite && ((ReferencedSite)obj).getId().equals(getId());\n     }\n     @Override\n     public FieldMapper getFieldMapper() {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/ReferencedSiteImpl.java",
                "sha": "9a121c202600a92b20d138dae358bffa2085b068",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/YardManagerImpl.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/YardManagerImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/YardManagerImpl.java",
                "patch": "@@ -30,14 +30,12 @@\n import org.apache.stanbol.entityhub.servicesapi.yard.Cache;\n import org.apache.stanbol.entityhub.servicesapi.yard.Yard;\n import org.apache.stanbol.entityhub.servicesapi.yard.YardManager;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n @Component(immediate = true)\n @Service\n public class YardManagerImpl implements YardManager {\n \n-    Logger log = LoggerFactory.getLogger(YardManagerImpl.class);\n+//    private static final Logger log = LoggerFactory.getLogger(YardManagerImpl.class);\n     @Reference(\n             cardinality=ReferenceCardinality.OPTIONAL_MULTIPLE,\n             referenceInterface=Yard.class,\n@@ -113,8 +111,7 @@ public boolean isYard(String id) {\n     }\n     @Override\n     public Cache getCache(String id) {\n-        Cache cache = caches.get(id);\n-        return cache;\n+        return caches.get(id);\n     }\n     @Override\n     public Collection<String> getCacheIDs() {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/impl/YardManagerImpl.java",
                "sha": "f383024fe689e44bebbb287e47c836a76c834726",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/DefaultFieldMapperImpl.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/DefaultFieldMapperImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 10,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/DefaultFieldMapperImpl.java",
                "patch": "@@ -54,15 +54,15 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class DefaultFieldMapperImpl implements FieldMapper {\n+public class DefaultFieldMapperImpl implements FieldMapper, Cloneable {\n     private final Logger log = LoggerFactory.getLogger(DefaultFieldMapperImpl.class);\n     private final Set<FieldMapping> mappings;\n //    private final Map<String,Collection<FieldMapping>> ignoreFieldMap;\n //    private final Map<Pattern,Collection<FieldMapping>> ignoreWildcardMap;\n     private final Map<String,Set<FieldMapping>> fieldMap;\n     private final Map<Pattern,Set<FieldMapping>> wildcardMap;\n     private Collection<FieldMapping> unmodMappings;\n-    ValueConverterFactory valueConverter;\n+    private ValueConverterFactory valueConverter;\n     //private Map<String,FieldMapping> mappings = Collections.synchronizedMap(new HashMap<String, FieldMapping>());\n     public DefaultFieldMapperImpl(ValueConverterFactory valueConverter) {\n         super();\n@@ -94,20 +94,20 @@ private DefaultFieldMapperImpl(ValueConverterFactory valueConverter,Set<FieldMap\n      * @return all the active Mappings\n      */\n     protected List<FieldMapping> getMappings(String field){\n-        final List<FieldMapping> mappings = new ArrayList<FieldMapping>();\n+        final List<FieldMapping> fieldMappings = new ArrayList<FieldMapping>();\n         //first search the fieldMappings\n         Collection<FieldMapping> tmp = fieldMap.get(field);\n         if(tmp != null){\n-            mappings.addAll(tmp);\n+            fieldMappings.addAll(tmp);\n         }\n         //now iterate over the Wildcard Mappings\n         for(Entry<Pattern,Set<FieldMapping>> entry : wildcardMap.entrySet()){\n             if(entry.getKey().matcher(field).find()){\n-                mappings.addAll(entry.getValue());\n+                fieldMappings.addAll(entry.getValue());\n             }\n         }\n-        Collections.sort(mappings, FieldMappingUtils.FIELD_MAPPING_COMPARATOR);\n-        return mappings;\n+        Collections.sort(fieldMappings, FieldMappingUtils.FIELD_MAPPING_COMPARATOR);\n+        return fieldMappings;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapper#addMapping(org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapping)\n@@ -428,10 +428,11 @@ private void processMapping(FieldMapping mapping, String field,  Collection<Obje\n         Set<Object> needConversion = new HashSet<Object>();\n         for(Iterator<Object> it = values.iterator();it.hasNext();){\n             Object value = it.next();\n-            if(accepted.contains(value.getClass())){\n+//            if(accepted.contains(value.getClass())){\n //                log.info(String.format(\"   + value %s(type:%s) accepted by value filter\",value,value.getClass()));\n                 //nothing to do\n-            } else if(rejected.contains(value.getClass())){\n+//            } else \n+            if(rejected.contains(value.getClass())){\n                 it.remove(); //remove also the current value of that type\n                 needConversion.add(value); //save as value that need to be converted\n //                log.info(String.format(\"   - value %s(type:%s) rejected by value filter\",value,value.getClass()));\n@@ -479,7 +480,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object o) {\n-        return o != null && o instanceof DefaultFieldMapperImpl &&\n+        return o instanceof DefaultFieldMapperImpl &&\n             ((DefaultFieldMapperImpl)o).mappings.equals(mappings);\n     }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/DefaultFieldMapperImpl.java",
                "sha": "dc1676620715d649627223572dc7dc124a806ae9",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/FieldMappingUtils.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/FieldMappingUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/FieldMappingUtils.java",
                "patch": "@@ -39,7 +39,7 @@\n import org.slf4j.LoggerFactory;\n \n \n-public class FieldMappingUtils {\n+public final class FieldMappingUtils {\n     /**\n      * Comparator that sorts field mappings in a way that optimises the\n      * processing.",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/FieldMappingUtils.java",
                "sha": "7268867a4025ad9b54a6271e73287bb88a3c7e3e",
                "status": "modified"
            },
            {
                "additions": 37,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/ValueConverterFactory.java",
                "changes": 50,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/ValueConverterFactory.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 13,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/ValueConverterFactory.java",
                "patch": "@@ -92,7 +92,7 @@ public static ValueConverterFactory getInstance(ValueFactory valueFactory){\n      * The {@link ValueFactory} used by converters to create instances for converted\n      * values.\n      */\n-    protected final ValueFactory valueFactory;\n+    private final ValueFactory valueFactory;\n     private boolean readonly = false;\n     /**\n      * Creates a new factory instance that supports conversions for all\n@@ -229,7 +229,9 @@ public Object convert(Object value,String dataTypeUri) throws IllegalArgumentExc\n \n         @Override\n         public Boolean convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Boolean){\n                 return (Boolean)value;\n             } else {\n@@ -248,7 +250,9 @@ public Boolean convert(Object value) {\n     public class ByteConverter implements ValueConverter<Byte>{\n         @Override\n         public Byte convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Byte){\n                 return (Byte)value;\n             } else {\n@@ -264,7 +268,9 @@ public Byte convert(Object value) {\n     public class ShortConverter implements ValueConverter<Short>{\n         @Override\n         public Short convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Short){\n                 return (Short)value;\n             } else {\n@@ -280,7 +286,9 @@ public Short convert(Object value) {\n     public class IntConverter implements ValueConverter<Integer>{\n         @Override\n         public Integer convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Integer){\n                 return (Integer)value;\n             } else {\n@@ -296,7 +304,9 @@ public Integer convert(Object value) {\n     public class LongConverter implements ValueConverter<Long>{\n         @Override\n         public Long convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Long){\n                 return (Long)value;\n             } else {\n@@ -311,7 +321,9 @@ public Long convert(Object value) {\n     public class FloatConverter implements ValueConverter<Float>{\n         @Override\n         public Float convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Float){\n                 return (Float)value;\n             } else {\n@@ -326,7 +338,9 @@ public Float convert(Object value) {\n     public class DoubleConverter implements ValueConverter<Double>{\n         @Override\n         public Double convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Double){\n                 return (Double)value;\n             } else {\n@@ -341,7 +355,9 @@ public Double convert(Object value) {\n     public class IntegerConverter implements ValueConverter<BigInteger>{\n         @Override\n         public BigInteger convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof BigInteger){\n                 return (BigInteger)value;\n             } else {\n@@ -356,7 +372,9 @@ public BigInteger convert(Object value) {\n     public class DecimalConverter implements ValueConverter<BigDecimal>{\n         @Override\n         public BigDecimal convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof BigDecimal){\n                 return (BigDecimal)value;\n             } else {\n@@ -371,7 +389,9 @@ public BigDecimal convert(Object value) {\n     public class AnyUriConverter implements ValueConverter<Reference>{\n         @Override\n         public Reference convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Reference){\n                 return (Reference)value;\n             } else if(value instanceof URI || value instanceof URL){\n@@ -404,7 +424,9 @@ protected DateTimeConverter(DataTypeEnum dataType){\n         }\n         @Override\n         public Date convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Date){\n                 return (Date)value;\n             } else if(value instanceof XMLGregorianCalendar){\n@@ -433,7 +455,9 @@ public TimeConverter(){\n     public class TextConverter implements ValueConverter<Text> {\n         @Override\n         public Text convert(Object value) {\n-            if (value == null) return null;\n+            if (value == null) {\n+                return null;\n+            }\n             if(value instanceof Text){\n                 return (Text)value;\n             } else {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/mapping/ValueConverterFactory.java",
                "sha": "8c8ff62eeea900f850f50c14d6179dc3e8fa6a1e",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultEntityMappingImpl.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultEntityMappingImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 6,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultEntityMappingImpl.java",
                "patch": "@@ -101,18 +101,18 @@ public DefaultEntityMappingImpl(String siteId, Representation representation) {\n         }\n     }\n     @Override\n-    public String getEntityId() {\n+    public final String getEntityId() {\n         Object id = representation.getFirst(EntityMapping.ENTITY_ID);\n         return id != null?id.toString():null;\n     }\n \n     @Override\n-    public Date getExpires() {\n+    public final Date getExpires() {\n         return representation.getFirst(EntityMapping.EXPIRES, Date.class);\n     }\n \n     @Override\n-    public MappingState getState() {\n+    public final MappingState getState() {\n         Reference stateUri = representation.getFirstReference(EntityMapping.STATE);\n         MappingState state;\n         if(stateUri != null){\n@@ -129,18 +129,18 @@ public MappingState getState() {\n     }\n \n     @Override\n-    public String getSymbolId() {\n+    public final String getSymbolId() {\n         Object id =  representation.getFirst(EntityMapping.SYMBOL_ID);\n         return id != null?id.toString():null;\n     }\n \n     @Override\n-    public void setExpires(Date date) {\n+    public final void setExpires(Date date) {\n         representation.set(EntityMapping.EXPIRES, date);\n     }\n \n     @Override\n-    public void setState(MappingState state) throws IllegalArgumentException {\n+    public final void setState(MappingState state) throws IllegalArgumentException {\n         if(state != null){\n             representation.setReference(EntityMapping.STATE, state.getUri());\n         } else {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultEntityMappingImpl.java",
                "sha": "f961113feb33a2d87d14300a7f040f2323c33107",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSignImpl.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSignImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSignImpl.java",
                "patch": "@@ -18,17 +18,16 @@\n \n import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n import org.apache.stanbol.entityhub.servicesapi.model.Sign;\n-import org.apache.stanbol.entityhub.servicesapi.model.rdf.RdfResourceEnum;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class DefaultSignImpl implements Sign{\n \n     Logger log = LoggerFactory.getLogger(DefaultSignImpl.class);\n-\n+    \n     protected final Representation representation;\n-    protected final String TYPE = RdfResourceEnum.signType.getUri();\n-    protected final String signSite;\n+//    private final String TYPE = RdfResourceEnum.signType.getUri();\n+    private final String signSite;\n \n //    public DefaultSignImpl(Representation representation) {\n //        if(representation == null){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSignImpl.java",
                "sha": "84769809c90e1d3868eeb6f8d1371c3441543864",
                "status": "modified"
            },
            {
                "additions": 20,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSymbolImpl.java",
                "changes": 40,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSymbolImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 20,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSymbolImpl.java",
                "patch": "@@ -100,38 +100,38 @@ public DefaultSymbolImpl(String entityhubId,Representation representation,String\n         this.defaultLanguage = defaultLanguage;\n     }\n     @Override\n-    public void addDescription(String description) {\n+    public final void addDescription(String description) {\n         representation.addNaturalText(Symbol.DESCRIPTION, description,defaultLanguage);\n     }\n \n     @Override\n-    public void addDescription(String description, String lanugage) {\n+    public final void addDescription(String description, String lanugage) {\n         representation.addNaturalText(Symbol.DESCRIPTION, description,lanugage);\n     }\n \n     @Override\n-    public void addPredecessor(String predecessor) {\n+    public final void addPredecessor(String predecessor) {\n         representation.addReference(Symbol.PREDECESSOR, predecessor);\n     }\n \n     @Override\n-    public void addSuccessor(String successor) {\n+    public final void addSuccessor(String successor) {\n         representation.addReference(Symbol.SUCCESSOR, successor);\n \n     }\n \n     @Override\n-    public Iterator<Text> getDescriptions() {\n+    public final Iterator<Text> getDescriptions() {\n         return representation.getText(Symbol.DESCRIPTION);\n     }\n \n     @Override\n-    public Iterator<Text> getDescriptions(String lang) {\n+    public final Iterator<Text> getDescriptions(String lang) {\n         return representation.get(Symbol.DESCRIPTION, lang);\n     }\n \n     @Override\n-    public String getLabel() {\n+    public final String getLabel() {\n         String label = getLabel(defaultLanguage);\n         if(label == null){ //no label for the default language\n             //search labels in other languages\n@@ -149,18 +149,18 @@ public String getLabel() {\n     }\n \n     @Override\n-    public String getLabel(String lang) {\n+    public final String getLabel(String lang) {\n         Text label = representation.getFirst(Symbol.LABEL, lang);\n         return label!=null?label.getText():null;\n     }\n \n     @Override\n-    public Iterator<String> getPredecessors() {\n+    public final Iterator<String> getPredecessors() {\n         return new ToStringIterator(representation.get(Symbol.PREDECESSOR));\n     }\n \n     @Override\n-    public SymbolState getState() {\n+    public final SymbolState getState() {\n         Reference stateUri = representation.getFirstReference(Symbol.STATE);\n         SymbolState state;\n         if(stateUri != null){\n@@ -177,52 +177,52 @@ public SymbolState getState() {\n     }\n \n     @Override\n-    public Iterator<String> getSuccessors() {\n+    public final Iterator<String> getSuccessors() {\n         return new ToStringIterator(representation.get(Symbol.SUCCESSOR));\n     }\n \n     @Override\n-    public boolean isPredecessors() {\n+    public final boolean isPredecessors() {\n         return getPredecessors().hasNext();\n     }\n \n     @Override\n-    public boolean isSuccessor() {\n+    public final boolean isSuccessor() {\n         return getSuccessors().hasNext();\n     }\n \n     @Override\n-    public void removeDescription(String description) {\n+    public final void removeDescription(String description) {\n         representation.removeNaturalText(Symbol.DESCRIPTION,description,defaultLanguage);\n     }\n \n     @Override\n-    public void removeDescription(String description, String language) {\n+    public final void removeDescription(String description, String language) {\n         representation.removeNaturalText(Symbol.DESCRIPTION,description,language);\n     }\n \n     @Override\n-    public void removePredecessor(String predecessor) {\n+    public final void removePredecessor(String predecessor) {\n         representation.removeReference(Symbol.PREDECESSOR, predecessor);\n     }\n \n     @Override\n-    public void removeSuccessor(String successor) {\n+    public final void removeSuccessor(String successor) {\n         representation.removeReference(Symbol.SUCCESSOR, successor);\n     }\n \n     @Override\n-    public void setLabel(String label) {\n+    public final void setLabel(String label) {\n         representation.setNaturalText(Symbol.LABEL, label, defaultLanguage);\n     }\n \n     @Override\n-    public void setLabel(String label, String language) {\n+    public final void setLabel(String label, String language) {\n         representation.setNaturalText(Symbol.LABEL, label, language);\n     }\n \n     @Override\n-    public void setState(SymbolState state) throws IllegalArgumentException {\n+    public final void setState(SymbolState state) throws IllegalArgumentException {\n         representation.setReference(Symbol.STATE, state.getUri());\n     }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/DefaultSymbolImpl.java",
                "sha": "292be72bb5ecfb4911059fbfffb2e5605c8a6aee",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentation.java",
                "changes": 30,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentation.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 13,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentation.java",
                "patch": "@@ -44,8 +44,8 @@\n     //private final Logger log = LoggerFactory.getLogger(InMemoryRepresentation.class);\n     private static ValueFactory valueFactory = new InMemoryValueFactory();\n \n-    protected final Map<String,Object> representation;\n-    protected final Map<String,Object> unmodRepresentation;\n+    private final Map<String,Object> representation;\n+    private final Map<String,Object> unmodRepresentation;\n     private final String id;\n     /**\n      * creates a new InMemoryRepresentation for the parsed ID\n@@ -83,7 +83,7 @@ protected InMemoryRepresentation(String id, Map<String,Object> representation){\n     @Override\n     public void add(String field, Object parsedValue) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -143,7 +143,7 @@ public void addReference(String field, String reference) {\n     @SuppressWarnings(\"unchecked\")\n     private Collection<Object> getValuesAsCollection(String field){\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -165,7 +165,7 @@ public void addReference(String field, String reference) {\n     @Override\n     public Iterator<Object> get(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -215,7 +215,7 @@ public String getId() {\n     @Override\n     public void remove(String field, Object parsedValue) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -245,7 +245,7 @@ public void remove(String field, Object parsedValue) {\n     @Override\n     public void removeAll(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -256,12 +256,14 @@ public void removeAll(String field) {\n     @Override\n     public void removeAllNaturalText(String field, String... languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         Object values = representation.get(field);\n-        if(values == null) return;\n+        if(values == null) {\n+            return;\n+        }\n         if(values instanceof Collection<?>){\n             int removed = 0;\n             for(Iterator<Text> it = new TextIterator(valueFactory,\n@@ -289,12 +291,14 @@ public void removeAllNaturalText(String field, String... languages) {\n     @Override\n     public void removeNaturalText(String field, String text, String... languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n         Object values = representation.get(field);\n-        if(values == null) return;\n+        if(values == null) {\n+            return;\n+        }\n         if(values instanceof Collection<?>){\n             int removed = 0;\n             for(Iterator<Text> it = new TextIterator(valueFactory,\n@@ -333,7 +337,7 @@ public void removeReference(String field, String reference) {\n     @Override\n     public void set(String field, Object value) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -428,6 +432,6 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof Representation && ((Representation)obj).getId().equals(getId());\n+        return obj instanceof Representation && ((Representation)obj).getId().equals(getId());\n     }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentation.java",
                "sha": "c0f4c590b78de56b12b11eadd305961100c02a87",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactory.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactory.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 8,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactory.java",
                "patch": "@@ -40,15 +40,15 @@ protected InMemoryValueFactory(){\n     @Override\n     public Reference createReference(Object value) {\n         if(value == null){\n-            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n         }\n         return new ReferenceImpl(value.toString());\n     }\n \n     @Override\n     public Text createText(Object value) {\n         if(value == null){\n-            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n         }\n         return createText(value.toString(),null);\n     }\n@@ -87,7 +87,7 @@ public int hashCode() {\n \n         @Override\n         public boolean equals(Object obj) {\n-            return obj != null && obj instanceof ReferenceImpl && ((ReferenceImpl)obj).value.equals(value);\n+            return obj instanceof ReferenceImpl && ((ReferenceImpl)obj).value.equals(value);\n         }\n         @Override\n         public String toString() {\n@@ -107,13 +107,13 @@ public ReferenceImpl clone() throws CloneNotSupportedException {\n \n         private final String value;\n         private final String language;\n-        protected TextImpl(String value) throws NullPointerException {\n+        protected TextImpl(String value) throws IllegalArgumentException {\n             this(value,null);\n         }\n-        protected TextImpl(String value, String language) throws NullPointerException {\n+        protected TextImpl(String value, String language) throws IllegalArgumentException {\n             super();\n             if(value == null){\n-                throw new NullPointerException(\"The value of the Text MUST NOT be NULL!\");\n+                throw new IllegalArgumentException(\"The value of the Text MUST NOT be NULL!\");\n             }\n             this.value = value;\n             this.language = language;\n@@ -134,7 +134,7 @@ public String toString() {\n         }\n         @Override\n         public boolean equals(Object obj) {\n-            if(obj != null && obj instanceof TextImpl && ((TextImpl)obj).value.equals(value)){\n+            if(obj instanceof TextImpl && ((TextImpl)obj).value.equals(value)){\n                 if(((TextImpl)obj).language == null){\n                     return language == null;\n                 } else {\n@@ -152,7 +152,7 @@ protected Object clone() throws CloneNotSupportedException {\n     @Override\n     public Representation createRepresentation(String id) {\n         if (id == null){\n-            throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL!\");\n          } else if(id.isEmpty()){\n              throw new IllegalArgumentException(\"The parsed id MUST NOT be empty!\");\n          } else {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactory.java",
                "sha": "3f522a12855f348db6d7235f4f96b75d19ff7cd1",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/FieldQueryImpl.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/FieldQueryImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/FieldQueryImpl.java",
                "patch": "@@ -43,10 +43,10 @@\n     @SuppressWarnings(\"unused\")\n     private static final Logger log = LoggerFactory.getLogger(FieldQueryImpl.class);\n \n-    protected final Map<String,Constraint> queryConstraint = new HashMap<String, Constraint>();\n+    private final Map<String,Constraint> queryConstraint = new HashMap<String, Constraint>();\n     private final Map<String,Constraint> unmodQueryElements = Collections.unmodifiableMap(queryConstraint);\n \n-    protected final Set<String> selected = new HashSet<String>();\n+    private final Set<String> selected = new HashSet<String>();\n     private final Set<String> unmodSelected = Collections.unmodifiableSet(selected);\n \n     private Integer limit;\n@@ -190,4 +190,23 @@ public final void setOffset(int offset) {\n         }\n         this.offset = offset;\n     }\n+    @Override\n+    public int hashCode() {\n+        return queryConstraint.hashCode()+selected.hashCode()+offset+(limit!=null?limit:0);\n+    }\n+    @Override\n+    public boolean equals(Object obj) {\n+        if(obj instanceof FieldQuery && \n+            ((FieldQuery)obj).getConstraints().equals(getConstraints()) &&\n+            ((FieldQuery)obj).getSelectedFields().equals(getSelectedFields()) &&\n+            ((FieldQuery)obj).getOffset() == getOffset()){\n+            if(limit != null){\n+                return limit.equals(((FieldQuery)obj).getLimit());\n+            } else {\n+                return ((FieldQuery)obj).getLimit() == null;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/FieldQueryImpl.java",
                "sha": "b60164a012b6d4d153e9382763719c1c3c6ca767",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryResultListImpl.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryResultListImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 9,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryResultListImpl.java",
                "patch": "@@ -52,15 +52,15 @@ public QueryResultListImpl(FieldQuery query,Iterator<T> resultIterator,Class<T>\n         if(resultIterator == null || !resultIterator.hasNext()){\n             this.results = Collections.emptyList();\n         } else {\n-            List<T> results = new ArrayList<T>();\n+            List<T> resultList = new ArrayList<T>();\n             while(resultIterator.hasNext()){\n-                results.add(resultIterator.next());\n+                resultList.add(resultIterator.next());\n             }\n-            this.results = Collections.unmodifiableList(results);\n+            this.results = Collections.unmodifiableList(resultList);\n         }\n     }\n     @Override\n-    public Class<T> getType(){\n+    public final Class<T> getType(){\n         return type;\n     }\n     /**\n@@ -88,32 +88,34 @@ public QueryResultListImpl(FieldQuery query,Collection<T> results,Class<T> type)\n     /* (non-Javadoc)\n      * @see org.apache.stanbol.entityhub.core.query.ResultList#getQuery()\n      */\n-    public FieldQuery getQuery(){\n+    @Override\n+    public final FieldQuery getQuery(){\n         return query;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.stanbol.entityhub.core.query.ResultList#getSelectedFields()\n      */\n-    public Set<String> getSelectedFields(){\n+    @Override\n+    public final Set<String> getSelectedFields(){\n         return query.getSelectedFields();\n     }\n     /* (non-Javadoc)\n      * @see org.apache.stanbol.entityhub.core.query.ResultList#iterator()\n      */\n     @Override\n-    public Iterator<T> iterator() {\n+    public final Iterator<T> iterator() {\n         return results.iterator();\n     }\n     /* (non-Javadoc)\n      * @see org.apache.stanbol.entityhub.core.query.ResultList#isEmpty()\n      */\n-    public boolean isEmpty() {\n+    public final boolean isEmpty() {\n         return results.isEmpty();\n     }\n     /* (non-Javadoc)\n      * @see org.apache.stanbol.entityhub.core.query.ResultList#size()\n      */\n-    public int size() {\n+    public final int size() {\n         return results.size(); //not supported :(\n     }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryResultListImpl.java",
                "sha": "4792dd25090e31f1504ba90691c5df2fbd6166fb",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryUtils.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryUtils.java",
                "patch": "@@ -24,8 +24,8 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class QueryUtils {\n-\n+public final class QueryUtils {\n+    private QueryUtils(){}\n     /**\n      * Getter for the Limit calculated bye on the limit defined by the query\n      * and the configuration of the default results (for queries that do not",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/query/QueryUtils.java",
                "sha": "47fcbe30ac386091c5874b83e604843e37442542",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntityDereferencer.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntityDereferencer.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 10,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntityDereferencer.java",
                "patch": "@@ -61,9 +61,9 @@ protected void activate(ComponentContext context) {\n         if (context != null && context.getProperties() != null) {\n             this.context = context;\n             Dictionary<String, ?> properties = context.getProperties();\n-            Object baseUri = properties.get(EntityDereferencer.ACCESS_URI);\n-            if (baseUri != null) {\n-                this.baseUri = baseUri.toString();\n+            Object baseUriObject = properties.get(EntityDereferencer.ACCESS_URI);\n+            if (baseUriObject != null) {\n+                this.baseUri = baseUriObject.toString();\n                 //now set the new config\n                 this.config = properties;\n             } else {\n@@ -72,18 +72,18 @@ protected void activate(ComponentContext context) {\n             //TODO: I am sure, there is some Utility, that supports getting multiple\n             //      values from a OSGI Dictionary\n             Object prefixObject = properties.get(ConfiguredSite.ENTITY_PREFIX);\n-            ArrayList<String> prefixes = new ArrayList<String>();\n+            ArrayList<String> prefixList = new ArrayList<String>();\n             if (prefixObject == null) {\n-                prefixes = null;\n+                prefixList = null;\n             } else if (prefixObject.getClass().isArray()) {\n-                prefixes.addAll(Arrays.asList((String[]) prefixObject));\n+                prefixList.addAll(Arrays.asList((String[]) prefixObject));\n             } else if (prefixObject instanceof Collection<?>) {\n-                prefixes.addAll((Collection<String>) prefixObject);\n+                prefixList.addAll((Collection<String>) prefixObject);\n             } else { //assuming a single value\n-                prefixes.add(prefixObject.toString());\n+                prefixList.add(prefixObject.toString());\n             }\n-            Collections.sort(prefixes); //sort the prefixes List\n-            this.prefixes = Collections.unmodifiableList(prefixes); //use an unmodifiable wrapper for the member variable\n+            Collections.sort(prefixList); //sort the prefixes List\n+            this.prefixes = Collections.unmodifiableList(prefixList); //use an unmodifiable wrapper for the member variable\n         } else {\n             throw new IllegalArgumentException(\"The property \" + EntityDereferencer.ACCESS_URI + \" must be defined\");\n         }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntityDereferencer.java",
                "sha": "a87c439689bddfdd1d3e1a14912b88619f5d0b97",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntitySearcher.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntitySearcher.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 7,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntitySearcher.java",
                "patch": "@@ -53,14 +53,14 @@ protected void activate(ComponentContext context) {\n         if(context != null && context.getProperties() != null){\n             this.context = context;\n             Dictionary<String,?> properties = context.getProperties();\n-            Object queryUri = properties.get(EntitySearcher.QUERY_URI);\n-            Object accessUri = properties.get(ConfiguredSite.ACCESS_URI); //use as an fallback\n-            if(queryUri != null){\n-                this.queryUri = queryUri.toString();\n+            Object queryUriObject = properties.get(EntitySearcher.QUERY_URI);\n+            Object accessUriObject = properties.get(ConfiguredSite.ACCESS_URI); //use as an fallback\n+            if(queryUriObject != null){\n+                this.queryUri = queryUriObject.toString();\n                 //now set the new config\n-            } else if(accessUri != null){\n-                log.info(\"Using AccessUri as fallback for missing QueryUri Proerty (accessUri=\"+accessUri);\n-                this.queryUri = accessUri.toString();\n+            } else if(accessUriObject != null){\n+                log.info(\"Using AccessUri as fallback for missing QueryUri Proerty (accessUri=\"+accessUriObject);\n+                this.queryUri = accessUriObject.toString();\n             } else {\n                 throw new IllegalArgumentException(\"The property \"+EntitySearcher.QUERY_URI+\" must be defined\");\n             }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/AbstractEntitySearcher.java",
                "sha": "4c0146031f5fb516899965a68398ff7b97525877",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java",
                "patch": "@@ -84,11 +84,11 @@\n     //private Yard yard;\n \n     private String yardId;\n-    boolean initWithYard = false;\n+    private boolean initWithYard = false;\n \n     private FieldMapper baseMapper;\n     private FieldMapper additionalMapper;\n-    protected ComponentContext context;\n+    private ComponentContext context;\n \n     @Activate\n     protected void activate(ComponentContext context) throws ConfigurationException, YardException, IllegalStateException, InvalidSyntaxException {\n@@ -116,7 +116,7 @@ protected void initWithCacheYard(Yard yard) throws YardException {\n         //(2) Init the additional mappings based on the configuration\n         Object mappings = context.getProperties().get(Cache.ADDITIONAL_MAPPINGS);\n         FieldMapper configuredMappings = null;\n-        if (mappings != null && mappings instanceof String[] && ((String[]) mappings).length > 0) {\n+        if (mappings instanceof String[] && ((String[]) mappings).length > 0) {\n             configuredMappings = new DefaultFieldMapperImpl(ValueConverterFactory.getInstance(yard.getValueFactory()));\n             for (String mappingString : (String[]) mappings) {\n                 FieldMapping fieldMapping = FieldMappingUtils.parseFieldMapping(mappingString);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java",
                "sha": "aa664a55c1c9f12fecd191f58e617f1afce1023f",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheUtils.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheUtils.java",
                "patch": "@@ -32,7 +32,8 @@\n import org.slf4j.LoggerFactory;\n \n \n-public class CacheUtils {\n+public final class CacheUtils {\n+    private CacheUtils(){}\n \n     private static Logger log = LoggerFactory.getLogger(CacheUtils.class);\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheUtils.java",
                "sha": "052f7db483bced37524707015a3c04b89edbeb49",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/AdaptingIterator.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/AdaptingIterator.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/AdaptingIterator.java",
                "patch": "@@ -65,9 +65,9 @@\n         A adapt(T value, Class<A> type);\n     }\n     \n-    protected final Adapter<T, A> adapter;\n-    protected final Iterator<T> it;\n-    protected final Class<A> type;\n+    private final Adapter<T, A> adapter;\n+    private final Iterator<T> it;\n+    private final Class<A> type;\n     private A next;\n     private Boolean hasNext;\n     /**",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/AdaptingIterator.java",
                "sha": "d45f9fbe5a74ae1e6c2ee617b05520408cb93709",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/FilteringIterator.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/FilteringIterator.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/FilteringIterator.java",
                "patch": "@@ -63,7 +63,7 @@ public FilteringIterator(Iterator<T> iterator,Filter<T> filter,Class<T> type) {\n         private Filter<A> filter;\n         public FilterAdapter(Filter<A> filter) {\n             if(filter == null){\n-                throw new NullPointerException(\"The parsed Filter MUST NOT be NULL!\");\n+                throw new IllegalArgumentException(\"The parsed Filter MUST NOT be NULL!\");\n             }\n             this.filter = filter;\n         }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/FilteringIterator.java",
                "sha": "389376d4f3ea07b6b11f3e6e391b78a794266a67",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ModelUtils.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ModelUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 9,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ModelUtils.java",
                "patch": "@@ -88,7 +88,7 @@ public static SignTypeEnum getSignType(String uri){\n      *\n      * @return a new Random UUID\n      */\n-    protected static Random rng = new Random();\n+    private static Random rng = new Random();\n \n     /**\n      * Do not allow instances of this class\n@@ -203,18 +203,18 @@ public static String getRepresentationInfo(Representation rep) {\n         String[] parts = new String[2];\n         if(uri.startsWith(\"urn:\")){\n             if(uri.lastIndexOf(':')>3){\n-                parts[1] = uri.substring(uri.lastIndexOf(\":\")+1);\n-                parts[0] = uri.substring(0, uri.lastIndexOf(\":\")+1);\n+                parts[1] = uri.substring(uri.lastIndexOf(':')+1);\n+                parts[0] = uri.substring(0, uri.lastIndexOf(':')+1);\n             } else {\n                 parts[1] = uri;\n                 parts[0] = null;\n             }\n-        } else if(uri.lastIndexOf(\"#\")>=0){\n-            parts[1] = uri.substring(uri.lastIndexOf(\"#\")+1);\n-            parts[0] = uri.substring(0, uri.lastIndexOf(\"#\")+1);\n-        } else if(uri.lastIndexOf(\"/\")>=0){\n-            parts[1] = uri.substring(uri.lastIndexOf(\"/\")+1);\n-            parts[0] = uri.substring(0, uri.lastIndexOf(\"/\")+1);\n+        } else if(uri.lastIndexOf('#')>=0){\n+            parts[1] = uri.substring(uri.lastIndexOf('#')+1);\n+            parts[0] = uri.substring(0, uri.lastIndexOf('#')+1);\n+        } else if(uri.lastIndexOf('/')>=0){\n+            parts[1] = uri.substring(uri.lastIndexOf('/')+1);\n+            parts[0] = uri.substring(0, uri.lastIndexOf('/')+1);\n         } else {\n             parts[0] = null;\n             parts[1] = uri;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ModelUtils.java",
                "sha": "c3505436155e54e96cbff067fc7d8d60f042157c",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/OsgiUtils.java",
                "changes": 64,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/OsgiUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 64,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/OsgiUtils.java",
                "patch": "@@ -118,67 +118,6 @@ public final static URL checkUrlProperty(Dictionary<?, ?> properties,String prop\n             throw new ConfigurationException(propertyName,String.format(\"Property value %s is not a member of Enumeration %s!\",value,enumeration.getName()), e);\n         }\n     }\n-//    /**\n-//     * search for a {@link ComponentFactory} that has the component.name property\n-//     * as configured by {@link ConfiguredSite#DEREFERENCER_TYPE}. Than creates\n-//     * an new instance of an {@link EntityDereferencer} and configures it with\n-//     * all the properties present for this instance of {@link ReferencedSite} (\n-//     * only component.* and service.* properties are ignored).<br>\n-//     * The {@link ComponentInstance} and the {@link EntityDereferencer} are\n-//     * stored in the according memeber variables.\n-//     * @return the ComponentInstance of <code>null</code> if no ComponentFactory\n-//     *    was found for the parsed componentService\n-//     * @throws ConfigurationException if the {@link ConfiguredSite#DEREFERENCER_TYPE}\n-//     * is not present or it's value does not allow to create a {@link EntityDereferencer}\n-//     * instance.\n-//     */\n-//    public static ComponentInstance createComonentInstance(ComponentContext context, String property,Object componentName,Class<?> componentService) throws ConfigurationException {\n-//        //Object value = checkProperty(DEREFERENCER_TYPE);\n-//        final ServiceReference[] refs;\n-//        try {\n-//            refs = context.getBundleContext().getServiceReferences(\n-//                    ComponentFactory.class.getName(),\n-//                    \"(component.name=\"+componentName+\")\");\n-//\n-//        } catch (InvalidSyntaxException e) {\n-//            throw new ConfigurationException(property, \"Unable to get ComponentFactory for parsed value \"+componentName.toString(),e);\n-//        }\n-//        if(refs != null && refs.length>0){\n-//            if(refs.length>1){ //log some warning if more than one Service Reference was found by the query!\n-//                log.warn(\"Multiple ComponentFactories found for the property \"+property+\"=\"+componentName+\"! -> First one was used to instantiate the \"+componentService+\" Service\");\n-//            }\n-//            Object dereferencerFactorySerivceObject = context.getBundleContext().getService(refs[0]);\n-//            if(dereferencerFactorySerivceObject != null){\n-//                try {\n-//                    // I trust the OSGI framework, that the returned service implements the requested Interface\n-//                    ComponentFactory dereferencerFactory = (ComponentFactory)dereferencerFactorySerivceObject;\n-//                    //log.debug(\"build configuration for \"+EntityDereferencer.class.getSimpleName()+\" \"+componentName.toString());\n-//                    Dictionary<String, Object> config = copyConfig(context.getProperties());\n-//                    ComponentInstance dereferencerComponentInstance = dereferencerFactory.newInstance(config);\n-//                    dereferencerFactory = null;\n-//                    //now\n-//                    if(dereferencerComponentInstance == null){\n-//                        throw new IllegalStateException(\"Unable to create ComponentInstance for Property value \"+componentName+\"!\");\n-//                    }\n-//                    if(componentService.isAssignableFrom(dereferencerComponentInstance.getInstance().getClass())){\n-//                        return dereferencerComponentInstance;\n-//                    } else {\n-//                        dereferencerComponentInstance.dispose(); //we can not use it -> so dispose it!\n-//                        dereferencerComponentInstance = null;\n-//                        throw new IllegalStateException(\"ComponentInstance created for Property value \"+componentName+\" does not provide the \"+componentService+\" Service!\");\n-//                    }\n-//                } finally {\n-//                    //we need to unget the ComponentFactory!\n-//                    context.getBundleContext().ungetService(refs[0]);\n-//                    dereferencerFactorySerivceObject=null;\n-//                }\n-//            } else {\n-//                return null;\n-//            }\n-//        } else {\n-//            return null;\n-//        }\n-//    }\n \n     /**\n      * Copy all properties excluding \"{@value Constants#OBJECTCLASS}\",\n@@ -193,10 +132,7 @@ public final static URL checkUrlProperty(Dictionary<?, ?> properties,String prop\n             if(!key.startsWith(\"component.\") &&\n                     !key.startsWith(\"service.\") &&\n                     !key.equals(Constants.OBJECTCLASS)){\n-                //log.debug(\" > copy key\" + key);\n                 config.put(key, source.get(key));\n-            } else {\n-                //log.debug(\" > ignore key\" + key);\n             }\n         }\n         return config;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/OsgiUtils.java",
                "sha": "43d2a17e39381f677c7bd277fcd51d7b0b8c9c43",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TextIterator.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TextIterator.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 23,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TextIterator.java",
                "patch": "@@ -26,12 +26,6 @@\n import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;\n \n public class TextIterator extends AdaptingIterator<Object,Text> implements Iterator<Text> {\n-//    protected final Iterator<?> it;\n-//    private Text next;\n-//    private Boolean hasNext;\n-//    protected final Set<String> languages;\n-//    private final boolean isNullLanguage;\n-//    protected final ValueFactory valueFactory;\n     /**\n      * Creates an instance that iterates over values and returns {@link Text}\n      * instances that confirm to the active languages. If no languages are parsed\n@@ -43,26 +37,11 @@\n      */\n     public TextIterator(ValueFactory valueFactory,Iterator<Object> it,String...languages){\n         super(it,new TextAdapter(valueFactory, languages),Text.class);\n-//        if(it == null){\n-//            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n-//        }\n-//        this.it = it;\n-//        if(valueFactory == null){\n-//            throw new IllegalArgumentException(\"Parsed ValueFactory MUST NOT be NULL!\");\n-//        }\n-//        this.valueFactory = valueFactory;\n-//        if(languages != null && languages.length>0){\n-//            this.languages = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(languages)));\n-//            isNullLanguage = this.languages.contains(null);\n-//        } else {\n-//            this.languages = null;\n-//            isNullLanguage = true;\n-//        }\n     }\n     private static class TextAdapter implements Adapter<Object,Text>{\n-        protected final Set<String> languages;\n+        private final Set<String> languages;\n         private final boolean isNullLanguage;\n-        protected final ValueFactory valueFactory;\n+        private final ValueFactory valueFactory;\n         \n         public TextAdapter(ValueFactory valueFactory,String...languages) {\n             if(valueFactory == null){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TextIterator.java",
                "sha": "0185db2c6c201e31fd53364a006973ebdc7cc06a",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TimeUtils.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TimeUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 6,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TimeUtils.java",
                "patch": "@@ -45,7 +45,9 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class TimeUtils {\n+public final class TimeUtils {\n+    private TimeUtils(){}\n+\n     protected static final Logger log = LoggerFactory.getLogger(TimeUtils.class);\n     /**\n      * Holds all the data types that represent a date or a time!\n@@ -154,23 +156,24 @@\n     /**\n      * Lazy initialisation to avoid Exceptions if {@link DatatypeConfigurationException}\n      * is thrown during initialisation of the Utility class.<p>\n+     * Do not access directly! Use {@link #getXmlDataTypeFactory()} instead.\n      */\n-    private static DatatypeFactory __xmlDatatypeFactory;\n+    private static DatatypeFactory xmlDatatypeFactory;\n     /**\n-     * Inits the {@link #__xmlDatatypeFactory} if not already done.<p>\n+     * Inits the {@link #xmlDatatypeFactory} if not already done.<p>\n      * @return the XML datatype factory\n      * @throws IllegalStateException if a {@link DatatypeConfigurationException}\n      * is encountered during {@link DatatypeFactory#newInstance()}\n      */\n     private static DatatypeFactory getXmlDataTypeFactory() throws IllegalStateException {\n-        if(__xmlDatatypeFactory == null){\n+        if(xmlDatatypeFactory == null){\n             try {\n-                __xmlDatatypeFactory = DatatypeFactory.newInstance();\n+                xmlDatatypeFactory = DatatypeFactory.newInstance();\n             } catch (DatatypeConfigurationException e) {\n                 throw new IllegalStateException(\"Unable to instantiate XML Datatype Factory!\",e);\n             }\n         }\n-        return __xmlDatatypeFactory;\n+        return xmlDatatypeFactory;\n     }\n \n     public static String toString(String dataTypeUri,Date value){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TimeUtils.java",
                "sha": "29f86e1db61efcd4d3e1505961cc3dc06670fbfc",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ToStringIterator.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ToStringIterator.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ToStringIterator.java",
                "patch": "@@ -31,7 +31,7 @@\n  */\n public class ToStringIterator implements Iterator<String> {\n \n-    protected final Iterator<?> it;\n+    private final Iterator<?> it;\n     /**\n      * Creates an string iterator over parsed parent\n      * @param it the parent iterator\n@@ -40,7 +40,7 @@\n      */\n     public ToStringIterator(Iterator<?> it) throws NullPointerException{\n         if(it == null){\n-            throw new NullPointerException(\"Parsed iterator MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n         }\n         this.it = it;\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/ToStringIterator.java",
                "sha": "14f5f68fb7147fb9f38a7ad0db02508ced41c903",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TypeSaveIterator.java",
                "changes": 74,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TypeSaveIterator.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 73,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TypeSaveIterator.java",
                "patch": "@@ -26,10 +26,6 @@\n  */\n public class TypeSaveIterator<T> extends AdaptingIterator<Object,T> implements Iterator<T> {\n \n-//    protected final Iterator<?> it;\n-//    protected final Class<T> type;\n-//    private T next;\n-//    private Boolean hasNext;\n     /**\n      * Constructs an iterator that selects only elements of the parsed iterator\n      * that are assignable to the parse type\n@@ -39,76 +35,8 @@\n     @SuppressWarnings(\"unchecked\")\n     public TypeSaveIterator(Iterator<?> it,Class<T> type){\n         super((Iterator<Object>)it,new AssignableFormAdapter<T>(),type);\n-//        if(it == null){\n-//            throw new IllegalArgumentException(\"Parsed iterator MUST NOT be NULL!\");\n-//        }\n-//        if(type == null){\n-//            throw new IllegalArgumentException(\"Parsed type MUST NOT be NULL!\");\n-//        }\n-//        this.it = it;\n-//        this.type = type;\n     }\n-//    @Override\n-//    public final void remove() {\n-//        /*\n-//         * TODO: Any Iterator that filters elements of the underlying Iterator\n-//         * needs to call Iterator#next() in the underlying Iterator to get the\n-//         * next element that confirms with the filter.\n-//         * However the Iterator#remove() is defined as removing the last element\n-//         * to be returned by Iterator#next(). Therefore calling hasNext would\n-//         * change the element to be removed by this method.\n-//         * Currently I do not know a way around that but I would also like to\n-//         * keep the remove functionality for Iterator that filter elements of an\n-//         * underlying Iterator. To prevent unpredictable behaviour in such cases \n-//         * I throw an IllegalStateException in such cases.\n-//         * This decision assumes, that in most usage scenarios hasNext will not\n-//         * likely be called before calling remove and even in such cases\n-//         * it will be most likely be possible to refactor the code to confirm\n-//         * with this restriction.\n-//         * I hope this will help developers that encounter this exception to\n-//         * modify there code!\n-//         * If someone has a better Idea how to solve this please let me know!\n-//         * best \n-//         * Rupert Westenthaler\n-//         */\n-//        if(hasNext!= null){\n-//            throw new IllegalStateException(\"Remove can not be called after calling hasNext() because this Method needs to call next() on the underlying Interator and therefore would change the element to be removed :(\");\n-//        }\n-//        it.remove();\n-//    }\n-//\n-//    @Override\n-//    public final T next() {\n-//        hasNext(); //call hasNext (to init next Element if not already done)\n-//        if(!hasNext){\n-//            throw new NoSuchElementException();\n-//        } else {\n-//            T current = next;\n-//            next = null;\n-//            hasNext = null;\n-//            return current;\n-//        }\n-//    }\n-//\n-//    @Override\n-//    public final boolean hasNext() {\n-//        if(hasNext == null){ // only once even with multiple calls\n-//            next = prepareNext();\n-//            hasNext = next != null;\n-//        }\n-//        return hasNext;\n-//    }\n-//    @SuppressWarnings(\"unchecked\")\n-//    protected T prepareNext(){\n-//        Object check;\n-//        while(it.hasNext()){\n-//            check = it.next();\n-//            if(type.isAssignableFrom(check.getClass())){\n-//                return (T)check;\n-//            }\n-//        }\n-//        return null;\n-//    }\n+\n     /**\n      * Adapter implementation that uses {@link Class#isAssignableFrom(Class)}\n      * to check whether a value can be casted to the requested type",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/utils/TypeSaveIterator.java",
                "sha": "c8b92f5b2ef11783ad20a4e59714fed13755130e",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java",
                "changes": 44,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 18,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java",
                "patch": "@@ -58,17 +58,17 @@\n     /**\n      * This Yard uses the default in-memory implementation of the Entityhub model.\n      */\n-    protected ValueFactory valueFactory;\n+    private ValueFactory valueFactory;\n     /**\n      * The QueryFactory as required by {@link Yard#getQueryFactory()}. This\n      * Yard uses the default implementation as provided by the\n      * {@link DefaultQueryFactory}.\n      */\n-    protected FieldQueryFactory queryFactory;\n+    private FieldQueryFactory queryFactory;\n     /**\n      * Holds the configuration of the Yard.\n      */\n-    protected YardConfig config;\n+    private YardConfig config;\n     \n     /**\n      * The default prefix used for created URIs.\n@@ -104,13 +104,13 @@ protected AbstractYard(){}\n      */\n     protected final void activate(ValueFactory valueFactory,FieldQueryFactory queryFactory, YardConfig config) {\n         if(valueFactory == null){\n-            throw new NullPointerException(\"Unable to activate: The ValueFactory MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"Unable to activate: The ValueFactory MUST NOT be NULL!\");\n         }\n         if(queryFactory == null){\n-            throw new NullPointerException(\"Unable to activate: The QueryFactory MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"Unable to activate: The QueryFactory MUST NOT be NULL!\");\n         }\n         if(config == null){\n-            throw new NullPointerException(\"Unable to activate: The YardConfig MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"Unable to activate: The YardConfig MUST NOT be NULL!\");\n         }\n         this.queryFactory = queryFactory;\n         this.valueFactory = valueFactory;\n@@ -220,6 +220,14 @@ public final ValueFactory getValueFactory() {\n     protected String getUriPrefix(){\n         return defaultPrefix;\n     }\n+    protected final YardConfig getConfig() {\n+        return config;\n+    }\n+\n+    protected final void setConfig(YardConfig config) {\n+        this.config = config;\n+    }\n+\n     /**\n      * Creates an unique ID by using the {@link #getUriPrefix()} the parsed\n      * separator (non if <code>null</code>) and an uuid created by using \n@@ -297,7 +305,7 @@ protected YardConfig(Dictionary<String, Object> config) throws ConfigurationExce\n          * Representations of this Yard within the SolrIndex.\n          * @param the id of the yard. Required, not null, not empty!\n          */\n-        public void setId(String id) {\n+        public final void setId(String id) {\n             if(id != null){\n                 config.put(Yard.ID, id);\n             } else {\n@@ -309,7 +317,7 @@ public void setId(String id) {\n          * Getter for the ID of the yard\n          * @return the id of the yard\n          */\n-        public String getId() {\n+        public final String getId() {\n             Object value = config.get(Yard.ID);\n             return value==null?null:value.toString();\n         }\n@@ -319,7 +327,7 @@ public String getId() {\n          * is used as default\n          * @param name The name or <code>null</code> to use {@link #getId()}.\n          */\n-        public void setName(String name) {\n+        public final void setName(String name) {\n             if(name != null){\n                 config.put(Yard.NAME, name);\n             } else {\n@@ -331,7 +339,7 @@ public void setName(String name) {\n          * Getter for the human readable name of the Yard\n          * @return the name\n          */\n-        public String getName() {\n+        public final String getName() {\n             Object value = config.get(Yard.NAME);\n             return value==null?getId():value.toString();\n         }\n@@ -340,7 +348,7 @@ public String getName() {\n          * Setter for the description of this Yard\n          * @param description the description. Optional parameter\n          */\n-        public void setDescription(String description) {\n+        public final void setDescription(String description) {\n             if(description != null){\n                 config.put(Yard.DESCRIPTION, description);\n             } else {\n@@ -352,7 +360,7 @@ public void setDescription(String description) {\n          * Getter for the description\n          * @return description The description or <code>null</code> if not defined\n          */\n-        public String getDescription() {\n+        public final String getDescription() {\n             Object value = config.get(Yard.DESCRIPTION);\n             return value==null?null:value.toString();\n         }\n@@ -364,7 +372,7 @@ public String getDescription() {\n          * <code>null</code> or a negative number to use the default value defined\n          * by the Yard.\n          */\n-        public void setDefaultQueryResultNumber(Integer defaultQueryResults) {\n+        public final void setDefaultQueryResultNumber(Integer defaultQueryResults) {\n             if(defaultQueryResults != null){\n                 config.put(DEFAULT_QUERY_RESULT_NUMBER, defaultQueryResults);\n             } else {\n@@ -382,15 +390,15 @@ public void setDefaultQueryResultNumber(Integer defaultQueryResults) {\n          * if the value was set to a number lower or equals 0 and -1 if the\n          * value is not configured at all.\n          */\n-        public int getDefaultQueryResultNumber() throws NumberFormatException {\n+        public final int getDefaultQueryResultNumber() throws NumberFormatException {\n             Object value = config.get(DEFAULT_QUERY_RESULT_NUMBER);\n             Integer number;\n             if(value != null){\n                 if(value instanceof Integer){\n                     number = (Integer) value;\n                 } else {\n                     try {\n-                        number = new Integer(value.toString());\n+                        number = Integer.valueOf(value.toString());\n                     } catch (NumberFormatException e){\n                         return -1;\n                     }\n@@ -417,7 +425,7 @@ public int getDefaultQueryResultNumber() throws NumberFormatException {\n          * <code>null</code> or a negative number to use the default as defined by\n          * the Yard implementation.\n          */\n-        public void setMaxQueryResultNumber(Integer maxQueryResults) {\n+        public final void setMaxQueryResultNumber(Integer maxQueryResults) {\n             if(maxQueryResults != null){\n                 config.put(MAX_QUERY_RESULT_NUMBER, maxQueryResults);\n             } else {\n@@ -433,15 +441,15 @@ public void setMaxQueryResultNumber(Integer maxQueryResults) {\n          * if the value was set to a number lower or equals 0 and -1 if the\n          * value is not configured at all.\n          */\n-        public int getMaxQueryResultNumber() {\n+        public final int getMaxQueryResultNumber() {\n             Object value = config.get(MAX_QUERY_RESULT_NUMBER);\n             Integer number;\n             if(value != null){\n                 if(value instanceof Integer){\n                     number = (Integer) value;\n                 } else {\n                     try {\n-                        number = new Integer(value.toString());\n+                        number = Integer.valueOf(value.toString());\n                     }catch (NumberFormatException e) {\n                         return -1;\n                     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java",
                "sha": "763068effc9dc9007ca0f8c775853f0d506f4784",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentationTest.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentationTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentationTest.java",
                "patch": "@@ -16,7 +16,6 @@\n  */\n package org.apache.stanbol.entityhub.core.model;\n \n-import org.apache.stanbol.entityhub.core.model.InMemoryValueFactory;\n import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;\n import org.apache.stanbol.entityhub.test.model.RepresentationTest;\n import org.junit.Before;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryRepresentationTest.java",
                "sha": "8e87f9916bec76e9eed438a00c9724503daff31a",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactoryTest.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactoryTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactoryTest.java",
                "patch": "@@ -16,7 +16,6 @@\n  */\n package org.apache.stanbol.entityhub.core.model;\n \n-import org.apache.stanbol.entityhub.core.model.InMemoryValueFactory;\n import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;\n import org.apache.stanbol.entityhub.test.model.ValueFactoryTest;\n import org.junit.Before;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/core/src/test/java/org/apache/stanbol/entityhub/core/model/InMemoryValueFactoryTest.java",
                "sha": "90ab87543b89f05ce1cc0560bf5c60e14978d63e",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/DataTypeEnum.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/DataTypeEnum.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/DataTypeEnum.java",
                "patch": "@@ -86,11 +86,11 @@\n     DateTime(\"dateTime\",Date.class),\n     Duration(\"duration\",Duration.class),\n     ;\n-    final Class<?> javaType;\n-    final QName qName;\n-    final String shortName;\n-    final String uri;\n-    final Set<Class<?>> additional;\n+    private final Class<?> javaType;\n+    private final QName qName;\n+    private final String shortName;\n+    private final String uri;\n+    private final Set<Class<?>> additional;\n     private DataTypeEnum(Class<?> javaType,Class<?>...additional){\n         this(null,null,javaType,additional);\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/DataTypeEnum.java",
                "sha": "731fab1c818867cc90fb2527d74950b792c06556",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java",
                "patch": "@@ -68,8 +68,8 @@\n     dbpediaProp(\"dbp-prop\",\"http://dbpedia.org/property/\"),\n     geonames(\"http://www.geonames.org/ontology#\"),\n     ;\n-    String ns;\n-    String prefix;\n+    private String ns;\n+    private String prefix;\n     private NamespaceEnum(String ns) {\n         if(ns == null){\n             throw new IllegalArgumentException(\"The namespace MUST NOT be NULL\");\n@@ -151,7 +151,9 @@ public static NamespaceEnum forPrefix(String prefix){\n      * Enumeration. Otherwise the parsed value.\n      */\n     public static String getFullName(String shortUri){\n-        if(shortUri == null) return null;\n+        if(shortUri == null) {\n+            return null;\n+        }\n         int index = shortUri.indexOf(':');\n         if(index>0){\n             NamespaceEnum namespace = NamespaceEnum.forPrefix(shortUri.substring(0, index));",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/defaults/NamespaceEnum.java",
                "sha": "f5e31d15504cf52eab03f7b414c8186b4ce810e2",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/mapping/FieldMapping.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/mapping/FieldMapping.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 8,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/mapping/FieldMapping.java",
                "patch": "@@ -44,12 +44,12 @@\n  */\n public class FieldMapping {\n \n-    protected final String pattern;\n-    protected final Pattern regex;\n-    protected final boolean usesWildcard;\n-    protected Set<String> mappings;\n-    protected Constraint filter;\n-    protected final boolean inverse;\n+    private final String pattern;\n+    private final Pattern regex;\n+    private final boolean usesWildcard;\n+    private Set<String> mappings;\n+    private Constraint filter;\n+    private final boolean inverse;\n     private final boolean global;\n     /**\n      * Returns <code>true</code> if fields that match the pattern are ignored.\n@@ -237,8 +237,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && //not null\n-            obj instanceof FieldMapping && // check type\n+        return obj instanceof FieldMapping && // check type\n             ((FieldMapping)obj).pattern.equals(pattern) && //check field pattern\n             ((FieldMapping)obj).inverse == inverse && //check inverse\n             ((FieldMapping)obj).mappings.equals(mappings) && //check mappings",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/mapping/FieldMapping.java",
                "sha": "6f25dd7d6d4df119d2ae4047c10b9f45df11fe4d",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/EntityMapping.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/EntityMapping.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/EntityMapping.java",
                "patch": "@@ -61,7 +61,7 @@\n          */\n         confirmed(RdfResourceEnum.mappingStateConfirmed.getUri()),\n         ;\n-        String uri;\n+        private String uri;\n         MappingState(String uri){\n             this.uri = uri;\n         }\n@@ -73,7 +73,7 @@ public String toString() {\n             return uri;\n         }\n         // ---- reverse Mapping based on URI ----\n-        static Map<String,MappingState> uri2state;\n+        private static Map<String,MappingState> uri2state;\n         static {\n             Map<String, MappingState> mappings = new HashMap<String, MappingState>();\n             for(MappingState state : MappingState.values()){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/EntityMapping.java",
                "sha": "115dc4000f261c747778e365801621e0745e6ca9",
                "status": "modified"
            },
            {
                "additions": 62,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Representation.java",
                "changes": 124,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Representation.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 62,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Representation.java",
                "patch": "@@ -54,10 +54,10 @@\n      * @param type the type of the values\n      * @return the (first) value of that field\n      * @throws IllegalArgumentException if the type is not supported\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    <T> T getFirst(String field,Class<T> type) throws UnsupportedTypeException, NullPointerException, IllegalArgumentException;\n+    <T> T getFirst(String field,Class<T> type) throws UnsupportedTypeException, IllegalArgumentException;\n \n     /**\n      * Getter for all values of a field\n@@ -66,53 +66,53 @@\n      * @param type the type\n      * @return the values of the field\n      * @throws UnsupportedTypeException if the parsed type is not supported\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    <T> Iterator<T> get(String field,Class<T> type) throws UnsupportedTypeException, NullPointerException, IllegalArgumentException;\n+    <T> Iterator<T> get(String field,Class<T> type) throws UnsupportedTypeException, IllegalArgumentException;\n     /**\n      * Getter for the (first) value for a field\n      * @param field the field\n      * @return the first value of a field\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    Object getFirst(String field) throws NullPointerException, IllegalArgumentException;\n+    Object getFirst(String field) throws IllegalArgumentException;\n     /**\n      * Getter for the first reference value for a field\n      * @param field the field\n      * @return the reference or null of the field has no reference as value\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    Reference getFirstReference(String field) throws NullPointerException, IllegalArgumentException;\n+    Reference getFirstReference(String field) throws IllegalArgumentException;\n     /**\n      * Getter for the first natural language text value of a specific language\n      * @param field the field\n      * @param language the language(s) of the natural language text value\n      *             (If <code>null</code> is parsed as language, than also labels\n      *             without language tag are included in the Result)\n      * @return the first natural language text found for the parsed field\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n     */\n-    Text getFirst(String field, String...language) throws NullPointerException, IllegalArgumentException;\n+    Text getFirst(String field, String...language) throws IllegalArgumentException;\n     /**\n      * Getter for all values for the requested field\n      * @param field the field\n      * @return the values of the field\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    Iterator<Object> get(String field) throws NullPointerException, IllegalArgumentException;\n+    Iterator<Object> get(String field) throws IllegalArgumentException;\n     /**\n      * Getter for all natural language text values of a field\n      * @param field the field\n      * @return the natural text values\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    Iterator<Text> getText(String field) throws NullPointerException, IllegalArgumentException;\n+    Iterator<Text> getText(String field) throws IllegalArgumentException;\n     /**\n      * Getter for all natural language text values of a field\n      * @param field the field\n@@ -121,18 +121,18 @@\n      *             without language tag are included in the Result)\n      * @return iterator over all natural language text values in the requested\n      *             language.\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    Iterator<Text> get(String field,String...language) throws NullPointerException, IllegalArgumentException;\n+    Iterator<Text> get(String field,String...language) throws IllegalArgumentException;\n     /**\n      * Getter for all reference values of a field\n      * @param field the field\n      * @return Iterator over all reference values of a field\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    Iterator<Reference> getReferences(String field) throws NullPointerException, IllegalArgumentException;\n+    Iterator<Reference> getReferences(String field) throws IllegalArgumentException;\n     /**\n      * Adds the object as value to the field.\n      * <p>The type of the value is inferred based on the type of the Object.<br>\n@@ -153,37 +153,36 @@\n      * </ul> \n      * @param field the field\n      * @param value the value to add\n-     * @throws NullPointerException if <code>null</code> is parsed as field or\n-     * value\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws NullPointerException \n+     * @throws IllegalArgumentException if <code>null</code> is parsed as field or\n+     * value and/or if an empty string is parsed as field\n      */\n-    void add(String field, Object value) throws NullPointerException, IllegalArgumentException;\n+    void add(String field, Object value) throws IllegalArgumentException;\n     /**\n      * Adds an reference to the field.\n      * @param field the field\n      * @param reference the string representation of the reference. Note that\n      * the value will be interpreted as a \"reference\" so there might apply\n      * some rules about the format of the string. Regardless of the implementation\n      * any valid URI and URL need to be accepted as a valid reference value\n-     * @throws NullPointerException if <code>null</code> is parsed as field or\n-     * reference\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n-     * or reference and/or <code>null</code> is parsed as value.\n+     * @throws NullPointerException \n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field or reference\n      */\n-    void addReference(String field, String reference) throws NullPointerException,IllegalArgumentException;\n+    void addReference(String field, String reference) throws IllegalArgumentException;\n     /**\n      * Adds a natural language text as value for one or more languages\n      * @param field the field to add the text as value\n      * @param text the natural language text\n      * @param language the text is set for all the parsed languages. Parse\n      *             <code>null</code> to set the text also without any language\n      *             information.\n-     * @throws NullPointerException if <code>null</code> is parsed as field.\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n-     * and/or <code>null</code> is parsed as text. NOTE that <code>null</code> \n-     * is supported for languages.\n+     * @throws NullPointerException \n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field; if <code>null</code> is parsed as text. \n+     * NOTE that <code>null</code> is supported for languages.\n      */\n-    void addNaturalText(String field,String text, String...languages) throws NullPointerException,IllegalArgumentException;\n+    void addNaturalText(String field,String text, String...languages) throws IllegalArgumentException;\n     /**\n      * Sets the value of the field to the parsed object. If the parsed value\n      * is <code>null</code> than this method removes all values for the given\n@@ -193,10 +192,11 @@\n      * details.\n      * @param field the field\n      * @param value the new value for the field\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws NullPointerException \n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as field\n      */\n-    void set(String field, Object value) throws NullPointerException, IllegalArgumentException;\n+    void set(String field, Object value) throws IllegalArgumentException;\n     /**\n      * Setter for the reference of a field. If the parsed value\n      * is <code>null</code> than this method removes all values for the given\n@@ -206,10 +206,10 @@\n      * the value will be interpreted as a \"reference\" so there might apply\n      * some rules about the format of the string. Regardless of the implementation\n      * any valid URI and URL need to be accepted as a valid reference value\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code>or an emtpy string is\n+     * parsed as field\n      */\n-    void setReference(String field, String reference) throws NullPointerException, IllegalArgumentException;\n+    void setReference(String field, String reference) throws IllegalArgumentException;\n     /**\n      * Setter for the natural language text value of a field in the given\n      * languages. If <code>null</code> is parsed as text, all present values\n@@ -220,10 +220,10 @@\n      * @param language the languages of the parsed text. Parse\n      *             <code>null</code> to set the text also without any language\n      *             information.\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code>or an emtpy string is\n+     * parsed as field\n      */\n-    void setNaturalText(String field,String text, String...language) throws NullPointerException, IllegalArgumentException;\n+    void setNaturalText(String field,String text, String...language) throws IllegalArgumentException;\n     /**\n      * Removes the parsed value form the field. If <code>null</code> is parsed\n      * as value than the call is ignored.<p>\n@@ -233,10 +233,10 @@\n      * for details.\n      * @param field the field\n      * @param value the value to remove\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code>or an emtpy string is\n+     * parsed as field\n      */\n-    void remove(String field, Object value) throws NullPointerException, IllegalArgumentException; \n+    void remove(String field, Object value) throws IllegalArgumentException; \n     /**\n      * Removes to parsed reference as value for the given field. If <code>null</code>\n      * is parsed as reference, that the call is ignored.\n@@ -256,17 +256,17 @@\n      * @param language the language(s) of the natural language text\n      *             (If <code>null</code> is parsed as language, than also labels\n      *             without language tag might be removed)\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code>or an emtpy string is\n+     * parsed as field\n      */\n-    void removeNaturalText(String field,String text,String...languages) throws NullPointerException, IllegalArgumentException;\n+    void removeNaturalText(String field,String text,String...languages) throws IllegalArgumentException;\n     /**\n      * Removes all values of the field\n      * @param field the field\n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code>or an emtpy string is\n+     * parsed as field\n      */\n-    void removeAll(String field) throws NullPointerException, IllegalArgumentException;\n+    void removeAll(String field) throws IllegalArgumentException;\n     /**\n      * Removes all natural language texts for the given languages or all natural\n      * language labels of no language or an empty array is parsed as language.\n@@ -278,10 +278,10 @@\n      *             natural language label are removed. To remove only labels with\n      *             no language, <code>null</code> needs to be parsed as entry of\n      *             this array. \n-     * @throws NullPointerException if <code>null</code> is parsed as field\n-     * @throws IllegalArgumentException if an empty string is parsed as field\n+     * @throws IllegalArgumentException if <code>null</code>or an emtpy string is\n+     * parsed as field\n      */\n-    void removeAllNaturalText(String field,String...languages) throws NullPointerException, IllegalArgumentException;\n+    void removeAllNaturalText(String field,String...languages) throws IllegalArgumentException;\n     /**\n      * Getter for all the present fields\n      * @return the fields",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Representation.java",
                "sha": "1eb89f56a379dca4cec862a15e0d382c16aadf6d",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Symbol.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Symbol.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Symbol.java",
                "patch": "@@ -52,7 +52,7 @@\n          */\n         active(RdfResourceEnum.symbolStateActive.getUri()),\n         ;\n-        String uri;\n+        private String uri;\n         SymbolState(String uri){\n             this.uri = uri;\n         }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/Symbol.java",
                "sha": "f63b972ec6fb99a71198f501934c92d3c3dd2d5b",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/ValueFactory.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/ValueFactory.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 12,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/ValueFactory.java",
                "patch": "@@ -36,20 +36,20 @@\n      * @return the Text instance for the parsed object\n      * @throws UnsupportedTypeException if the type of the parsed object is not\n      * can not be used to create Text instances\n-     * @throws IllegalArgumentException If the parsed instance type is supported, but\n+     * @throws IllegalArgumentException If <code>null</code> is parsed or if the \n+     * parsed instance type is supported, but\n      * the parsed instance can not be used to create a text instance\n-     * @throws NullPointerException If <code>null</code> is parsed\n      */\n-    Text createText(Object value) throws UnsupportedTypeException, IllegalArgumentException,NullPointerException;\n+    Text createText(Object value) throws UnsupportedTypeException, IllegalArgumentException;\n     /**\n      * Creates a Text instance for a language\n      * @param text the text\n      * @param language the language or <code>null</code>.\n      * @return the Text instance\n-     * @throws IllegalArgumentException if the parsed parameter can not be used to create a Text instance\n-     * @throws NullPointerException if <code>null</code> is parsed as text.\n+     * @throws IllegalArgumentException if <code>null</code> is parsed as text or\n+     * if the parsed parameter can not be used to create a Text instance\n      */\n-    Text createText(String text,String language) throws IllegalArgumentException, NullPointerException;\n+    Text createText(String text,String language) throws IllegalArgumentException;\n     /**\n      * Creates a reference instance for the parsed value. Implementations might\n      * support special support for specific classes. As an default the\n@@ -66,20 +66,20 @@\n      * @return the reference instance\n      * @throws UnsupportedTypeException if the type of the parsed object can\n      * not be converted to a Reference.\n-     * @throws IllegalArgumentException if the parsed value can not be used to\n+     * @throws IllegalArgumentException if the parsed value is <code>null</code> \n+     * or if the parsed value can not be used to\n      * create a valid Reference (e.g. when parsing an empty String)\n-     * @throws NullPointerException if the parsed value is <code>null</code>\n      */\n-    Reference createReference(Object value) throws UnsupportedTypeException, IllegalArgumentException, NullPointerException;\n+    Reference createReference(Object value) throws UnsupportedTypeException, IllegalArgumentException;\n     /**\n      * Creates an empty representation instance of with the type {@link SignTypeEnum#Sign}\n      * for the parsed ID. The id MUST not be <code>null</code> nor empty\n      * @param id The id of the representation\n      * @return the representation\n-     * @throws NullPointerException If <code>null</code> is parsed as ID\n-     * @throws IllegalArgumentException if an empty string is parsed as ID\n+     * @throws IllegalArgumentException if <code>null</code> or an empty string \n+     * is parsed as ID\n      */\n-    Representation createRepresentation(String id) throws NullPointerException, IllegalArgumentException;\n+    Representation createRepresentation(String id) throws IllegalArgumentException;\n //    /**\n //     * Creates a value of the parsed data type for the parsed object\n //     * @param dataTypeUri the data type of the created object",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/ValueFactory.java",
                "sha": "e77a54f015a360b2742ccbc8422d2191dc340495",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/rdf/RdfResourceEnum.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/rdf/RdfResourceEnum.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/rdf/RdfResourceEnum.java",
                "patch": "@@ -163,7 +163,7 @@\n      */\n     TextDataType(null,\"text\"),\n     ;\n-    String uri;\n+    private String uri;\n     /**\n      * Initialise a new property by using the parse URI. If <code>null</code> is\n      * parsed, the URI is generated by using the Entityhub model namespace (\n@@ -222,7 +222,7 @@ public String getUri(){\n     }\n     @Override\n     public String toString() {\n-        return uri.toString();\n+        return uri;\n     }\n \n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/model/rdf/RdfResourceEnum.java",
                "sha": "be6dc1358b0bae072af3eca220881c21807bb48e",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/query/ValueConstraint.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/query/ValueConstraint.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/query/ValueConstraint.java",
                "patch": "@@ -32,8 +32,8 @@\n public class ValueConstraint extends Constraint {\n \n \n-    protected final Object value;\n-    protected final Collection<String> dataTypeUris;\n+    private final Object value;\n+    private final Collection<String> dataTypeUris;\n \n     public ValueConstraint(Object value) {\n         this(value,null);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/query/ValueConstraint.java",
                "sha": "5647e89e7992a425dae64d72307f2f02478228aa",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/util/PatternUtils.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/util/PatternUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/util/PatternUtils.java",
                "patch": "@@ -18,7 +18,8 @@\n \n import java.util.regex.Pattern;\n \n-public class PatternUtils {\n+public final class PatternUtils {\n+    private PatternUtils(){}\n     /**\n      * Converts a Wildcard search string to REGEX. If strict is enabled, than\n      * the REGEX pattern searches only full labels (\"^Patt?er.*$\") otherwise",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/util/PatternUtils.java",
                "sha": "c5b80813a5cadaf3116f5012c478ae3a213baa14",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java",
                "patch": "@@ -20,7 +20,8 @@\n import java.util.Collection;\n import java.util.Iterator;\n \n-public class Utils {\n+public final class Utils {\n+    private Utils(){}\n     /**\n      * Converts an Iterator to a Collection by iterating over all elements and\n      * adding them to a List.",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java",
                "sha": "398bbd428f320697fbdef801aa145cbed0e4a2a7",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 24,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java",
                "patch": "@@ -21,14 +21,12 @@\n import static junit.framework.Assert.assertNotNull;\n import static junit.framework.Assert.assertNull;\n import static junit.framework.Assert.assertTrue;\n-\n import static org.apache.stanbol.entityhub.test.Utils.asCollection;\n \n import java.net.MalformedURLException;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashSet;\n@@ -66,107 +64,107 @@\n     protected abstract Object getUnsupportedValueInstance();\n     \n     /*--------------------------------------------------------------------------\n-     * Set of Tests that check if all Methods correctly throw a NullPointerException\n+     * Set of Tests that check if all Methods correctly throw an IllegalArgumentException\n      * when parsing null as field!\n      *  - important to prevent NULL fields within the Entityhub\n      *--------------------------------------------------------------------------\n      */\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldAdd(){\n         Representation rep = createRepresentation(null);\n         rep.add(null, \"test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldAddNaturalText(){\n         Representation rep = createRepresentation(null);\n         rep.addNaturalText(null, \"test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldAddReference(){\n         Representation rep = createRepresentation(null);\n         rep.addReference(null, \"urn:test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGet(){\n         Representation rep = createRepresentation(null);\n         rep.get(null);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetDataType(){\n         Representation rep = createRepresentation(null);\n         rep.get(null, Integer.class);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetNaturalLanguateText(){\n         Representation rep = createRepresentation(null);\n         rep.get(null,\"en\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetFirst(){\n         Representation rep = createRepresentation(null);\n         rep.getFirst(null);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetFirstReference(){\n         Representation rep = createRepresentation(null);\n         rep.getFirstReference(null);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetFirstDataType(){\n         Representation rep = createRepresentation(null);\n         rep.getFirst(null, Integer.class);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetFirstNaturalLanguage(){\n         Representation rep = createRepresentation(null);\n         rep.getFirst(null, \"en\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetReferences(){\n         Representation rep = createRepresentation(null);\n         rep.getReferences(null);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldGetText(){\n         Representation rep = createRepresentation(null);\n         rep.getText(null);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldRemove(){\n         Representation rep = createRepresentation(null);\n         rep.remove(null, \"test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldRemoveAll(){\n         Representation rep = createRepresentation(null);\n         rep.removeAll(null);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldRemoveAllNaturalText(){\n         Representation rep = createRepresentation(null);\n         rep.removeAllNaturalText(null, \"de\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldRemoveNaturalText(){\n         Representation rep = createRepresentation(null);\n         rep.removeNaturalText(null, \"test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldRemoveReference(){\n         Representation rep = createRepresentation(null);\n         rep.removeReference(null, \"urn:test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldSet(){\n         Representation rep = createRepresentation(null);\n         rep.set(null, \"test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldSetNaturalText(){\n         Representation rep = createRepresentation(null);\n         rep.setNaturalText(null, \"test\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullFieldSetReference(){\n         Representation rep = createRepresentation(null);\n         rep.setReference(null, \"urn:test\");\n@@ -848,7 +846,6 @@ public void testRemoveNaturalTextWithCorrectAndWrongLanguage(){\n         for(Iterator<Text> texts = rep.getText(field);texts.hasNext();textSet.remove(texts.next().getText()));\n         //and check that the value we expect to be removed is still in the set\n         assertTrue(textSet.size() == 1);\n-        System.out.println(\"TextSet: \"+textSet);\n         assertTrue(textSet.contains(NL_TEST_en2));\n     }\n     /**",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java",
                "sha": "59e89444cd62b47d03bc899ad2b79d2c35541afe",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/ValueFactoryTest.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/ValueFactoryTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/ValueFactoryTest.java",
                "patch": "@@ -69,7 +69,7 @@\n      */\n     protected abstract Object getUnsupportedTextType();\n     \n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullReference(){\n         testRef(null);\n     }\n@@ -108,7 +108,7 @@ public void testURLReference() throws MalformedURLException {\n         Reference ref = testRef(refObject);\n         assertEquals(ref.getReference(), refObject.toString());\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullText(){\n         testText(null, \"en\");\n     }\n@@ -154,7 +154,7 @@ public void testEmptyLanguageText(){\n      * NOTE: automatic generation of IDs is supported by the {@link Yard#create()}\n      * but not by the {@link Representation} itself.\n      */\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullIdRepresentation(){\n         testRepresentation(null);\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/ValueFactoryTest.java",
                "sha": "56ed0811fae97ee10e5dfa1f8002217b22bc995b",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 11,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java",
                "patch": "@@ -16,7 +16,12 @@\n  */\n package org.apache.stanbol.entityhub.test.yard;\n \n-import static junit.framework.Assert.*;\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertFalse;\n+import static junit.framework.Assert.assertNotNull;\n+import static junit.framework.Assert.assertNotSame;\n+import static junit.framework.Assert.assertNull;\n+import static junit.framework.Assert.assertTrue;\n import static org.apache.stanbol.entityhub.test.Utils.asCollection;\n \n import java.util.Arrays;\n@@ -27,8 +32,6 @@\n import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n import org.apache.stanbol.entityhub.servicesapi.yard.Yard;\n import org.apache.stanbol.entityhub.servicesapi.yard.YardException;\n-import org.junit.After;\n-import org.junit.AfterClass;\n import org.junit.Test;\n \n \n@@ -123,7 +126,7 @@ public void testCreateWithExistingId() throws YardException{\n         yard.create(test.getId()); //throws an IllegalArgumentException\n     }\n \n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testIsRepresentationWithNull() throws YardException {\n         getYard().isRepresentation(null);\n     }\n@@ -132,12 +135,12 @@ public void testIsRepresentationWithNull() throws YardException {\n     public void testIsRepresentationWithEmptyString() throws YardException{\n         getYard().isRepresentation(\"\");\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testStoreRepresentationWithNull() throws YardException {\n         getYard().store((Representation)null);\n     }\n \n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testStoreRepresentationsWithNull() throws YardException {\n         getYard().store((Iterable<Representation>)null);\n     }\n@@ -200,7 +203,7 @@ public void testStoreRepresentationsWithNullElement() throws YardException {\n         assertEquals(test, addedIt.next());\n         assertFalse(addedIt.hasNext());\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testGetRepresentationWithNull() throws YardException {\n         getYard().getRepresentation(null);\n     }\n@@ -288,7 +291,7 @@ public void testIsRepresentation() throws YardException {\n         yard.remove(test2.getId());\n         assertFalse(yard.isRepresentation(test2.getId()));\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testUpdateRepresentationWithNull() throws YardException {\n         getYard().update((Representation)null);\n     }\n@@ -298,7 +301,7 @@ public void testUpdateRepresentationWithNonPresent() throws YardException {\n         Representation test = create(id,false);\n         getYard().update(test); //throws an Exception because test is not part of the yard\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testUpdateRepresentationsWithNull() throws YardException {\n         getYard().update((Iterable<Representation>)null);\n     }\n@@ -375,7 +378,7 @@ public void testUpdateRepresentationsWithNonPresent() throws YardException {\n         assertFalse(updatedIt.hasNext());\n     }\n     \n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testRemoveRepresentationWithNull() throws YardException {\n         getYard().remove((String)null);\n     }\n@@ -412,7 +415,7 @@ public void testRemoveRepresentation() throws YardException {\n         //it represents form the store (2)\n         assertEquals(testValue, test.getFirst(field));\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testRemoveRepresentationsWithNull() throws YardException {\n         getYard().remove((Iterable<String>)null);\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java",
                "sha": "6612ac6ad72716362d882709bbb47279af5d8f18",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/dbPedia/src/main/java/org/apache/stanbol/entityhub/indexing/dbPedia/cli/CommandLineRunner.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/dbPedia/src/main/java/org/apache/stanbol/entityhub/indexing/dbPedia/cli/CommandLineRunner.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/indexing/dbPedia/src/main/java/org/apache/stanbol/entityhub/indexing/dbPedia/cli/CommandLineRunner.java",
                "patch": "@@ -31,7 +31,6 @@\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n-import java.net.URL;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Dictionary;\n@@ -59,7 +58,9 @@\n import org.slf4j.LoggerFactory;\n \n \n-public class CommandLineRunner {\n+public final class CommandLineRunner {\n+    private CommandLineRunner(){}\n+\n     public static final String[] defaultFieldMappings = new String [] {\n         // --- Define the Languages for all fields ---\n         //NOTE: the leading space is required for the global filter!",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/dbPedia/src/main/java/org/apache/stanbol/entityhub/indexing/dbPedia/cli/CommandLineRunner.java",
                "sha": "88479e08b3bc55ca6a5dc0b26eeda304caec59ed",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/dblp/src/main/java/org/apache/stanbol/entityhub/indexing/dblp/cli/CommandLineRunner.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/dblp/src/main/java/org/apache/stanbol/entityhub/indexing/dblp/cli/CommandLineRunner.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/indexing/dblp/src/main/java/org/apache/stanbol/entityhub/indexing/dblp/cli/CommandLineRunner.java",
                "patch": "@@ -31,7 +31,6 @@\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n-import java.net.URL;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Dictionary;\n@@ -59,7 +58,10 @@\n import org.slf4j.LoggerFactory;\n \n \n-public class CommandLineRunner {\n+public final class CommandLineRunner {\n+    private CommandLineRunner(){}\n+\n+    \n     public static final String[] defaultFieldMappings = new String [] {\n         // --- Define the Languages for all fields ---\n         //NOTE: the leading space is required for the global filter!",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/dblp/src/main/java/org/apache/stanbol/entityhub/indexing/dblp/cli/CommandLineRunner.java",
                "sha": "cff78fad4e94b2972079233ecec4910e19ab3ef6",
                "status": "modified"
            },
            {
                "additions": 46,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexer.java",
                "changes": 89,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexer.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 43,
                "filename": "entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexer.java",
                "patch": "@@ -269,7 +269,9 @@\n //\tprivate final ParsingProvider parser = new JenaParserProvider();\n \t//private final WeightedTcProvider provider;\n \tprivate final FieldMapper mapper;\n-\tprivate final Set<String> types;\n+\t\n+\t@SuppressWarnings(\"unused\") //TODO: Implement filtering based on rdf:type\n+    private final Set<String> types;\n \t//private MGraph indexingGraph;\n \tprivate final DatasetGraphTDB indexingDataset;\n \tprivate final boolean skipRead;\n@@ -285,7 +287,7 @@\n \tprivate boolean resumeMode;\n \t\n \t\n-\tpublic RdfIndexer(Dictionary<String, Object> config){\n+    public RdfIndexer(Dictionary<String, Object> config){\n \t\tthis.yard = (Yard)config.get(KEY_YARD);\n \t\tif(yard == null){\n \t\t\tthrow new IllegalArgumentException(\"Parsed config MUST CONTAIN a Yard. Use the key \"+KEY_YARD+\" to parse the YardInstance used to store the geonames.org index!\");\n@@ -294,35 +296,35 @@ public RdfIndexer(Dictionary<String, Object> config){\n \t\t\t\t\tyard.getName(),yard.getId()));\n \t\t}\n \t\tthis.vf = yard.getValueFactory();\n-\t\tObject rdfFiles = config.get(KEY_RDF_FILES);\n-\t\tif(rdfFiles instanceof Iterable<?>){\n+\t\tObject rdfFilesObject = config.get(KEY_RDF_FILES);\n+\t\tif(rdfFilesObject instanceof Iterable<?>){\n \t\t\tthis.rdfFiles = new ArrayList<File>();\n-\t\t\tfor(Object value : (Iterable<?>)rdfFiles){\n+\t\t\tfor(Object value : (Iterable<?>)rdfFilesObject){\n \t\t\t\tthis.rdfFiles.add(checkFile(value.toString()));\n \t\t\t}\n \t\t} else {\n-\t\t\tthis.rdfFiles = Collections.singletonList(checkFile(rdfFiles.toString()));\n+\t\t\tthis.rdfFiles = Collections.singletonList(checkFile(rdfFilesObject.toString()));\n \t\t}\n-\t\tObject indexingDir = config.get(KEY_RDF_STORE_DIR);\n-\t\tif(indexingDir == null){\n-\t\t\tindexingDir = \"indexingData\";\n-\t\t\tconfig.put(KEY_RDF_STORE_DIR, indexingDir);\n+\t\tObject indexingDirObject = config.get(KEY_RDF_STORE_DIR);\n+\t\tif(indexingDirObject == null){\n+\t\t\tindexingDirObject = \"indexingData\";\n+\t\t\tconfig.put(KEY_RDF_STORE_DIR, indexingDirObject);\n \t\t}\n-\t\tthis.indexingDir = checkFile(indexingDir.toString(), false, true);\n-\t\tObject modelName = config.get(KEY_MODEL_NAME);\n-\t\tif(modelName == null){\n-\t\t\tmodelName = \"indexingModel-\"+ModelUtils.randomUUID().toString();\n-\t\t\tconfig.put(KEY_MODEL_NAME, modelName);\n+\t\tthis.indexingDir = checkFile(indexingDirObject.toString(), false, true);\n+\t\tObject modelNameObject = config.get(KEY_MODEL_NAME);\n+\t\tif(modelNameObject == null){\n+\t\t\tmodelNameObject = \"indexingModel-\"+ModelUtils.randomUUID().toString();\n+\t\t\tconfig.put(KEY_MODEL_NAME, modelNameObject);\n \t\t}\n-\t\tthis.modelName = modelName.toString();\n+\t\tthis.modelName = modelNameObject.toString();\n \t\t//init the types!\n-\t\tIterable<?> types = (Iterable<?>)config.get(KEY_RDF_TYPES);\n-\t\tif(types != null){\n+\t\tIterable<?> typeIterator = (Iterable<?>)config.get(KEY_RDF_TYPES);\n+\t\tif(typeIterator != null){\n \t\t\tSet<String> typeSet = new HashSet<String>();\n-\t\t\tfor(Object type : types){\n-\t\t\t\tif(type != null){\n-\t\t\t\t\ttypeSet.add(type.toString());\n-\t\t\t\t\tlog.info(\"  - adding Resoures with rdf:type \"+type);\n+\t\t\tfor(Object typeObject : typeIterator){\n+\t\t\t\tif(typeObject != null){\n+\t\t\t\t\ttypeSet.add(typeObject.toString());\n+\t\t\t\t\tlog.info(\"  - adding Resoures with rdf:type \"+typeObject);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(typeSet.isEmpty()){\n@@ -336,14 +338,14 @@ public RdfIndexer(Dictionary<String, Object> config){\n \t\t\tthis.types = null; //null or an iterable with one or more elements!\n \t\t}\n \t\t//init the indexing mode\n-\t\tObject indexingMode = config.get(KEY_INDEXING_MODE);\n-\t\tif(indexingMode == null){\n+\t\tObject indexingModeObject = config.get(KEY_INDEXING_MODE);\n+\t\tif(indexingModeObject == null){\n \t\t\tthis.indexingMode = IndexingMode.NORMAL; //default to replace\n-\t\t} else if(indexingMode instanceof IndexingMode){\n-\t\t\tthis.indexingMode = (IndexingMode)indexingMode;\n+\t\t} else if(indexingModeObject instanceof IndexingMode){\n+\t\t\tthis.indexingMode = (IndexingMode)indexingModeObject;\n \t\t} else {\n \t\t\ttry {\n-\t\t\t\tthis.indexingMode = IndexingMode.valueOf(indexingMode.toString());\n+\t\t\t\tthis.indexingMode = IndexingMode.valueOf(indexingModeObject.toString());\n \t\t\t}catch (IllegalArgumentException e) {\n \t\t\t\t//catch and re-throw with a better message!\n \t\t\t\tthrow new IllegalArgumentException(\n@@ -352,11 +354,11 @@ public RdfIndexer(Dictionary<String, Object> config){\n \t\t\t}\n \t\t}\n \t\t//init the fieldMapper\n-\t\tIterable<?> mappings = (Iterable<?>)config.get(KEY_FIELD_MAPPINGS);\n+\t\tIterable<?> mappingIterator = (Iterable<?>)config.get(KEY_FIELD_MAPPINGS);\n \t\tList<FieldMapping> fieldMappings;\n-\t\tif(mappings != null){\n+\t\tif(mappingIterator != null){\n \t\t\tfieldMappings = new ArrayList<FieldMapping>();\n-\t\t\tfor(Object mappingString : mappings){\n+\t\t\tfor(Object mappingString : mappingIterator){\n \t\t\t\tif(mappingString != null){\n \t\t\t\t\tFieldMapping fieldMapping = FieldMappingUtils.parseFieldMapping(mappingString.toString());\n \t\t\t\t\tif(fieldMapping != null){\n@@ -383,12 +385,12 @@ public RdfIndexer(Dictionary<String, Object> config){\n \t\t} else if(!modelDir.isDirectory()){\n \t\t\tthrow new IllegalStateException(String.format(\"A directory for %s already exists but is not a directory!\",modelDir.getAbsoluteFile()));\n \t\t} //else exists and is a dir -> nothing to do\n-\t\tObject skipRead = config.get(KEY_SKIP_READ);\n-\t\tif(skipRead != null){\n-\t\t\tif(skipRead instanceof Boolean){\n-\t\t\t\tthis.skipRead = ((Boolean)skipRead).booleanValue();\n+\t\tObject skipReadObject = config.get(KEY_SKIP_READ);\n+\t\tif(skipReadObject != null){\n+\t\t\tif(skipReadObject instanceof Boolean){\n+\t\t\t\tthis.skipRead = ((Boolean)skipReadObject).booleanValue();\n \t\t\t} else {\n-\t\t\t\tthis.skipRead = Boolean.parseBoolean(skipRead.toString());\n+\t\t\t\tthis.skipRead = Boolean.parseBoolean(skipReadObject.toString());\n \t\t\t}\n \t\t} else {\n \t\t\tthis.skipRead = false;\n@@ -452,12 +454,12 @@ public RdfIndexer(Dictionary<String, Object> config){\n \t\t\tthis.minimumRequiredEntityRanking = minRanking;\n \t\t}\n \n-\t\tObject resumeMode = config.get(KEY_RESUME_MODE);\n-\t\tif(resumeMode != null) {\n-\t\t\tif(resumeMode instanceof Boolean){\n-\t\t\t\tthis.resumeMode = (Boolean)resumeMode;\n+\t\tObject resumeModeObject = config.get(KEY_RESUME_MODE);\n+\t\tif(resumeModeObject != null) {\n+\t\t\tif(resumeModeObject instanceof Boolean){\n+\t\t\t\tthis.resumeMode = (Boolean)resumeModeObject;\n \t\t\t} else {\n-\t\t\t\tthis.resumeMode = Boolean.parseBoolean(resumeMode.toString());\n+\t\t\t\tthis.resumeMode = Boolean.parseBoolean(resumeModeObject.toString());\n \t\t\t}\n \t\t} else {\n \t\t\tthis.resumeMode = false;\n@@ -594,8 +596,9 @@ private void indexResources() throws YardException{\n                                     }\n                                 } else {\n                                     if(literalValue instanceof String){\n-                                        if(!((String)literalValue).isEmpty())\n-                                        source.add(field, literalValue);\n+                                        if(!((String)literalValue).isEmpty()){\n+                                            source.add(field, literalValue);\n+                                        }\n                                     } else {\n                                         source.add(field, literalValue);\n                                     }\n@@ -674,7 +677,7 @@ private File checkFile(String value,boolean file, boolean create) {\n             //remove leading path separators!\n             value = value.substring(File.pathSeparator.length());\n         }\n-        File testFile = new File(value.toString());\n+        File testFile = new File(value);\n \n         if(!testFile.exists()){\n             if(create){ //create",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexer.java",
                "sha": "8f96b0c9526f3482bed86f0181d5f7164c203d5c",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexerConfig.java",
                "changes": 52,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexerConfig.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 26,
                "filename": "entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexerConfig.java",
                "patch": "@@ -107,7 +107,7 @@ public RdfIndexerConfig(Yard yard, File... rdfFiles) {\n      * @param sourceFiles\n      *            the source files to add\n      */\n-    public void addSourceFile(File... sourceFiles) {\n+    public final void addSourceFile(File... sourceFiles) {\n         if (sourceFiles != null) {\n             for (File sourceFile : sourceFiles) {\n                 checkAndAddSrouceFile(sourceFile);\n@@ -121,7 +121,7 @@ public void addSourceFile(File... sourceFiles) {\n      * @param sourceFile\n      *            the source files to remove\n      */\n-    public void removeSourceFile(File... sourceFile) {\n+    public final void removeSourceFile(File... sourceFile) {\n         if (sourceFile == null) {\n             return;\n         }\n@@ -136,7 +136,7 @@ public void removeSourceFile(File... sourceFile) {\n      * \n      * @return the unmodifiable list of files or <code>null</code>if no source files are present.\n      */\n-    public Collection<File> getSourceFiles() {\n+    public final Collection<File> getSourceFiles() {\n         Collection<File> sourceFiles = (Collection<File>) config.get(KEY_RDF_FILES);\n         return sourceFiles == null ? null : Collections.unmodifiableCollection((Collection<File>) config\n                 .get(KEY_RDF_FILES));\n@@ -150,7 +150,7 @@ public void removeSourceFile(File... sourceFile) {\n      * @return <code>true</code> if the parsed file can be used as indexing\n      *     directory (exists and is a directory or !exists) \n      */\n-    public boolean setIndexingDir(File file) throws IllegalArgumentException {\n+    public final boolean setIndexingDir(File file) throws IllegalArgumentException {\n         if (checkFile(file, false, null)) { // isDirectory or !exists\n             config.put(KEY_RDF_STORE_DIR, file);\n             return true;\n@@ -162,15 +162,15 @@ public boolean setIndexingDir(File file) throws IllegalArgumentException {\n      * Getter for the indexing directory\n      * @return the directory used for indexing\n      */\n-    public File getIndexingDir() {\n+    public final File getIndexingDir() {\n         return (File) config.get(KEY_RDF_STORE_DIR);\n     }\n     /**\n      * Setter for the RDF model name used to store/access the RDF data used\n      * for indexing\n      * @param modelName the RDF model name\n      */\n-    public void setModelName(String modelName) {\n+    public final void setModelName(String modelName) {\n         if (modelName != null && !modelName.isEmpty()) {\n             config.put(KEY_MODEL_NAME, modelName);\n         } else {\n@@ -182,7 +182,7 @@ public void setModelName(String modelName) {\n      * for indexing\n      * @return the RDF model name\n      */\n-    public String getModelName() {\n+    public final String getModelName() {\n         return (String) config.get(KEY_MODEL_NAME);\n     }\n     /**\n@@ -191,7 +191,7 @@ public String getModelName() {\n      * about ranking of entities)\n      * @param entityRankings the entity ranking map\n      */\n-    public void setEntityRankings(Map<String,Float> entityRankings) {\n+    public final void setEntityRankings(Map<String,Float> entityRankings) {\n         if (entityRankings == null) {\n             config.remove(KEY_ENTITY_RANKINGS);\n         } else {\n@@ -205,15 +205,15 @@ public void setEntityRankings(Map<String,Float> entityRankings) {\n      * @return the entity rankings or <code>null</code> if no entity rankings\n      * are present\n      */\n-    public Map<String,Float> getNetityRankings() {\n+    public final Map<String,Float> getNetityRankings() {\n         return (Map<String,Float>) config.get(KEY_ENTITY_RANKINGS);\n     }\n     /**\n      * Setter for the indexing mode (expert use only). Please carefully read\n      * {@link RdfIndexer#KEY_INDEXING_MODE} before setting this property.\n      * @param mode the indexing mode\n      */\n-    public void setIndexingMode(IndexingMode mode) {\n+    public final void setIndexingMode(IndexingMode mode) {\n         if (mode != null) {\n             config.put(KEY_INDEXING_MODE, mode);\n         } else {\n@@ -225,7 +225,7 @@ public void setIndexingMode(IndexingMode mode) {\n      * @return the indexing mode or <code>null</code> if not set by this\n      * configuration.\n      */\n-    public IndexingMode getIndexingMode() {\n+    public final IndexingMode getIndexingMode() {\n         return (IndexingMode) config.get(KEY_INDEXING_MODE);\n     }\n     /**\n@@ -235,7 +235,7 @@ public IndexingMode getIndexingMode() {\n      * indexing session that has already completed with reading the RDF data.\n      * @param state the state or <code>null</code> to remove any present config\n      */\n-    public void setSkipRead(Boolean state) {\n+    public final void setSkipRead(Boolean state) {\n         if (state == null) {\n             config.remove(KEY_SKIP_READ);\n         } else {\n@@ -246,7 +246,7 @@ public void setSkipRead(Boolean state) {\n      * Getter for the skip reading state.\n      * @return the state or <code>null</code> if not set\n      */\n-    public Boolean getSkipRead() {\n+    public final Boolean getSkipRead() {\n         return (Boolean) config.get(KEY_SKIP_READ);\n     }\n     /**\n@@ -258,7 +258,7 @@ public Boolean getSkipRead() {\n      * at once. Parse <code>null</code> or a value smaller equals zero to remove\n      * this optional configuration.\n      */\n-    public void setChunkSize(Integer size) {\n+    public final void setChunkSize(Integer size) {\n         if (size == null || size < 1) {\n             config.remove(KEY_CHUNK_SIZE);\n         } else {\n@@ -270,7 +270,7 @@ public void setChunkSize(Integer size) {\n      * in the {@link Yard}.\n      * @return the chunk size or <code>null</code> if not present\n      */\n-    public Integer getChunkSize() {\n+    public final Integer getChunkSize() {\n         return (Integer) config.get(KEY_CHUNK_SIZE);\n     }\n     /**\n@@ -279,7 +279,7 @@ public Integer getChunkSize() {\n      * @param state the state or <code>null</code> to remove the configuration\n      * and go with the default.\n      */\n-    public void setIgnoreEntitiesWithoutRanking(Boolean state) {\n+    public final void setIgnoreEntitiesWithoutRanking(Boolean state) {\n         if (state == null) {\n             config.remove(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING);\n         } else {\n@@ -291,7 +291,7 @@ public void setIgnoreEntitiesWithoutRanking(Boolean state) {\n      * ignored.\n      * @return the state or <code>null</code> if not present\n      */\n-    public Boolean getIgnoreEntitiesWithoutRanking() {\n+    public final Boolean getIgnoreEntitiesWithoutRanking() {\n         return (Boolean) config.get(KEY_IGNORE_ENTITIES_WITHOUT_ENTITY_RANKING);\n     }\n     /**\n@@ -301,7 +301,7 @@ public Boolean getIgnoreEntitiesWithoutRanking() {\n      * value smaller equals 0 to remove this configuration and go with the\n      * default.\n      */\n-    public void setMinEntityRanking(Float minRanking) {\n+    public final void setMinEntityRanking(Float minRanking) {\n         if (minRanking == null || minRanking <= 0) {\n             config.remove(KEY_REQUIRED_ENTITY_RANKING);\n         } else {\n@@ -313,7 +313,7 @@ public void setMinEntityRanking(Float minRanking) {\n      * @return the minimum required ranking or <code>null</code> if not defined\n      * by this configuration\n      */\n-    public Float getMinEntityRanking() {\n+    public final Float getMinEntityRanking() {\n         return (Float) config.get(KEY_REQUIRED_ENTITY_RANKING);\n     }\n     /**\n@@ -323,7 +323,7 @@ public Float getMinEntityRanking() {\n      * information. Parse <code>null</code> or a value smaller equals zero to\n      * remove this configuration.\n      */\n-    public void setDefaultEntityRanking(Float defaultRanking) {\n+    public final void setDefaultEntityRanking(Float defaultRanking) {\n         if (defaultRanking == null || defaultRanking <= 0) {\n             config.remove(defaultRanking);\n         } else {\n@@ -336,7 +336,7 @@ public void setDefaultEntityRanking(Float defaultRanking) {\n      * @return the default ranking or <code>null</code> if not present within\n      * this configuration.\n      */\n-    public Float getDefaultEntityRanking() {\n+    public final Float getDefaultEntityRanking() {\n         return (Float) config.get(KEY_DEFAULT_ENTITY_RANKING);\n     }\n     \n@@ -345,7 +345,7 @@ public Float getDefaultEntityRanking() {\n      * if OK add them to the configuration.\n      * @param sourceFile the file to add\n      */\n-    private void checkAndAddSrouceFile(File sourceFile) {\n+    private final void checkAndAddSrouceFile(File sourceFile) {\n         if (checkFile(sourceFile, true, true)) {\n             Set<File> files = (Set<File>) config.get(KEY_RDF_FILES);\n             if (files == null) {\n@@ -364,7 +364,7 @@ private void checkAndAddSrouceFile(File sourceFile) {\n      * If <code>null</code> or an empty collection is parsed the configuration\n      * is removed.\n      */\n-    public void setMappings(Collection<String> mappings){\n+    public final void setMappings(Collection<String> mappings){\n         if(mappings == null || mappings.isEmpty()){\n             config.remove(KEY_FIELD_MAPPINGS);\n         } else {\n@@ -379,7 +379,7 @@ public void setMappings(Collection<String> mappings){\n      * @param mapper the FieldMapper instance with the FieldMappings to be used\n      * for the configuration of the indexer.\n      */\n-    public void setMappings(FieldMapper mapper){\n+    public final void setMappings(FieldMapper mapper){\n         if(mapper != null){\n             String[] mappingStrings = FieldMappingUtils.serialiseFieldMapper(mapper);\n             setMappings(mappingStrings != null ? Arrays.asList(mappingStrings):null);\n@@ -392,7 +392,7 @@ public void setMappings(FieldMapper mapper){\n      * @return the field mappings or <code>null</code> if no are defined for\n      * this configuration.\n      */\n-    public Collection<String> getMappings(){\n+    public final Collection<String> getMappings(){\n         Collection<String> mappings = (Collection<String>)config.get(KEY_FIELD_MAPPINGS);\n         return mappings == null ? null: Collections.unmodifiableCollection(mappings);\n     }\n@@ -408,7 +408,7 @@ public void setMappings(FieldMapper mapper){\n      * @return <code>true</code> if the parsed {@link File} fulfils the stated\n      * requirements.\n      */\n-    private boolean checkFile(File file, boolean isFile, Boolean exists) {\n+    private final boolean checkFile(File file, boolean isFile, Boolean exists) {\n         //exists null means that it will be created if not existence\n         //therefore we need only to check the state if not null.\n         if (exists != null) {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/genericRdf/src/main/java/org/apache/stanbol/entityhub/indexing/rdf/RdfIndexerConfig.java",
                "sha": "cd1ebbef733cb8c0068eda4098b416f237674e35",
                "status": "modified"
            },
            {
                "additions": 63,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java",
                "changes": 122,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 59,
                "filename": "entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java",
                "patch": "@@ -33,6 +33,7 @@\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -101,7 +102,7 @@\n         mappings.add(Properties.rdf_type.toString());\n         fieldMappings = mappings.toArray(new String[mappings.size()]);\n     }\n-    Logger log = LoggerFactory.getLogger(GeoNamesIndexer.class);\n+    private static final Logger log = LoggerFactory.getLogger(GeoNamesIndexer.class);\n \n     private Yard yard;\n     private ValueFactory vf;\n@@ -110,16 +111,17 @@\n     private int indexingChunkSize = 1000;\n \n     private File dataDir;\n+    @SuppressWarnings(\"unused\") //TODO implement indexing of Ontology\n     private File geonamesOntFile;\n     private File alternateNamesFile;\n     private File hierarchyFile;\n     private List<File> adminCodesFiles;\n     private File countryInfoFile;\n     private final int countryGeonamesIdPos = 17;\n     private File geonamesArchiveFile;\n-    private final String geonamesOntBase = \"http://www.geonames.org/ontology/\";\n+    //private final String geonamesOntBase = \"http://www.geonames.org/ontology/\";\n     private final String geonamesFeatureBase = \"http://sws.geonames.org/\";\n-    private final String geonamesCountryBase = \"http://www.geonames.org/countries/\";\n+    //private final String geonamesCountryBase = \"http://www.geonames.org/countries/\";\n     //for date processing we use joda time!\n     private final Map<Integer,List<FeatureName>> featureNames = new TreeMap<Integer,List<FeatureName>>();\n     private final Map<String, Integer> adminCode2featureId = new TreeMap<String, Integer>();\n@@ -233,7 +235,7 @@\n         skos_narrower(NamespaceEnum.skos.getNamespace(),\"narrower\"),\n         skos_related(NamespaceEnum.skos.getNamespace(),\"related\"),\n         ;\n-        String uri;\n+        private String uri;\n         Properties(String namespace,String name){\n             uri = namespace+name;\n         }\n@@ -262,13 +264,13 @@ public GeoNamesIndexer(Dictionary<String, Object> config) throws IllegalArgument\n             this.indexingChunkSize = chunkSize;\n         } //else use default value of 1000\n         log.info(\" ... start indexing at position \"+startPosition);\n-        Boolean indexOntology = (Boolean)config.get(KEY_INDEX_ONTOLOGY_STATE);\n-        if(indexOntology != null){\n-            this.indexOntology = indexOntology;\n+        Boolean indexOntologyState = (Boolean)config.get(KEY_INDEX_ONTOLOGY_STATE);\n+        if(indexOntologyState != null){\n+            this.indexOntology = indexOntologyState;\n         } else {\n             this.indexOntology = false;\n         }\n-        log.info(\" ... indexing geonames.org thesaurus=\"+indexOntology);\n+        log.info(\" ... indexing geonames.org thesaurus=\"+indexOntologyState);\n         this.dataDir = checkFile(KEY_DATA_DIR, config, \"/data\");\n         this.geonamesArchiveFile = checkFile(KEY_GEONAMES_ARCHIVE, dataDir, config,\"allCountries.zip\");\n         this.countryInfoFile = checkFile(KEY_COUNTRY_INFOS, dataDir,config,\"countryInfo.txt\");\n@@ -396,7 +398,7 @@ private void indexGeonames() throws YardException, IOException {\n                         }\n                     } else {\n                         //remove alternate labels from the inMemoryMap for the ID to save memory\n-                        Integer id = new Integer(line.substring(0, line.indexOf('\\t')));\n+                        Integer id = Integer.valueOf(line.substring(0, line.indexOf('\\t')));\n                         featureNames.remove(id);\n                     }\n                 }\n@@ -430,23 +432,23 @@ private Reference getDocRef(String refString){\n     }\n     private Representation importFeature(String line){\n         Tokenizer t = new Tokenizer(line);\n-        String id = t.nextElement();\n+        String id = t.next();\n         Integer geoNamesId = Integer.parseInt(id);\n         //create a new Doc based on the first Element (geonamesID)\n         Representation doc = this.yard.getValueFactory().createRepresentation(String.format(\"%s%s/\", geonamesFeatureBase,id));\n         //add the geonames:Feature type\n         doc.add(Properties.rdf_type.toString(), getDocRef(Properties.gn_Feature.toString()));\n         //add the UTF-8name\n-        String utf8Label = t.nextElement();\n+        String utf8Label = t.next();\n         doc.addNaturalText(Properties.gn_name.toString(),utf8Label);\n         //add the ASKII Name as rdfs:label\n-        String askiiLabel = t.nextElement();\n+        String askiiLabel = t.next();\n         if(utf8Label == null){\n             utf8Label = askiiLabel; //use ASKII label as fallback for the utf8 version\n         }\n         doc.addNaturalText(Properties.rdfs_label.toString(),utf8Label);\n         //alternate Names (alternate names also include Airport codes, postal codes and Wikipedia links!\n-        t.nextElement(); //consume this Element and use the alternateNames Map instead\n+        t.next(); //consume this Element and use the alternateNames Map instead\n         List<FeatureName> alternateNames = featureNames.remove(geoNamesId); //use remove, because we need not need it a 2nd time!\n         if(alternateNames != null){\n             List<Text> altList = new ArrayList<Text>(alternateNames.size());\n@@ -495,28 +497,28 @@ private Representation importFeature(String line){\n             }\n         }\n         //lat\n-        doc.add(Properties.geo_lat.toString(),new BigDecimal(t.nextElement()));\n+        doc.add(Properties.geo_lat.toString(),new BigDecimal(t.next()));\n         //lon\n-        doc.add(Properties.geo_long.toString(),new BigDecimal(t.nextElement()));\n+        doc.add(Properties.geo_long.toString(),new BigDecimal(t.next()));\n         //featureClass\n-        String featureClass = String.format(\"%s%s\",NamespaceEnum.geonames,t.nextElement());\n+        String featureClass = String.format(\"%s%s\",NamespaceEnum.geonames,t.next());\n         doc.add(Properties.gn_featureClass.toString(),getDocRef(featureClass));\n         //featureCode (-> need to use <featureClass>.<featureCode>!!)\n-        doc.add(Properties.gn_featureCode.toString(),getDocRef(String.format(\"%s.%s\",featureClass,t.nextElement())));\n+        doc.add(Properties.gn_featureCode.toString(),getDocRef(String.format(\"%s.%s\",featureClass,t.next())));\n         //countryCode\n         //  -> geonames uses here the link to an HTML Page showing the Country\n         //     We would like to use an Link to a SKOS:Concept representing the Country\n         // ... But luckily here we need only to add the URI!\n         Set<String> ccs = new HashSet<String>();\n-        String countryCode = t.nextElement();\n+        String countryCode = t.next();\n         if(countryCode != null){\n             countryCode = countryCode.trim(); //need to trim because some country codes use '  ' to indicate null!\n             if(countryCode.length() == 2){ //Yes there are some features that are in no country!\n                 ccs.add(countryCode);\n             }\n         }\n         //alternate countryCodes\n-        String altCc = t.nextElement();\n+        String altCc = t.next();\n         if(altCc != null){\n             StringTokenizer altCcT = new StringTokenizer(altCc,\",\");\n             while(altCcT.hasMoreElements()){\n@@ -533,18 +535,18 @@ private Representation importFeature(String line){\n         //first read them -> we need to consume the tokens anyway\n         String[] adminCodes = new String[] {\n             countryCode, //country\n-            t.nextElement(), //ADM1\n-            t.nextElement(), //ADM2\n-            t.nextElement(), //ADM3\n-            t.nextElement()};//ADM4\n+            t.next(), //ADM1\n+            t.next(), //ADM2\n+            t.next(), //ADM3\n+            t.next()};//ADM4\n         //Workaround for Admin1 -> add leading '0' for single Value\n         if(adminCodes[1] != null && adminCodes[1].length() < 2){\n             adminCodes[1] = '0'+adminCodes[1];\n         }\n         addParents(doc,geoNamesId,adminCodes);\n \n         //population\n-        String populationString = t.nextElement();\n+        String populationString = t.next();\n         if(populationString != null){\n             //NOTE: we need to used Long, because of Asia (3.800.000)\n             Long population = new Long(populationString);\n@@ -553,20 +555,20 @@ private Representation importFeature(String line){\n             }\n         }\n         //elevation\n-        String latString = t.nextElement();\n-        if(latString == null){\n-            latString = t.nextElement(); //if no elevation than use the gtopo30\n+        String altString = t.next();\n+        if(altString == null){\n+            altString = t.next(); //if no elevation than use the gtopo30\n         } else {\n-            t.nextElement(); //if there is already en elevation, than consume these entry\n+            t.next(); //if there is already en elevation, than consume these entry\n         }\n-        Integer alt = new Integer(latString);\n+        Integer alt = Integer.valueOf(altString);\n         if(alt.intValue() > -9999){ //it looks like that -9999 is sometimes used as not known!\n             doc.add(Properties.geo_alt.toString(),alt);\n         }\n         //time zone\n-        t.nextElement(); //not used\n+        t.next(); //not used\n         //mod-date\n-        String modDateString = t.nextElement();\n+        String modDateString = t.next();\n         if(modDateString != null){\n             try {\n                 doc.add(Properties.dc_date.toString(),TimeUtils.toDate(DataTypeEnum.DateTime, modDateString));\n@@ -696,13 +698,13 @@ private int readCountryInfos() throws IOException{\n                 String code = null;\n                 Integer geonamesId = null;\n                 int i=1;\n-                for(;t.hasMoreElements();i++){\n-                    String actToken = t.nextElement();\n+                for(;t.hasNext();i++){\n+                    String actToken = t.next();\n                     if(i==1){\n                         code = actToken;\n                     }\n                     if(i==countryGeonamesIdPos){\n-                        geonamesId = new Integer(actToken);\n+                        geonamesId = Integer.valueOf(actToken);\n                         break;\n                     }\n                 }\n@@ -742,7 +744,7 @@ private void readAdminCodes() throws IOException{\n                     lineCount++;\n                     //no tokenizer this time ... need only first and last column!\n                     String code = line.substring(0, line.indexOf('\\t'));\n-                    Integer geonamesId = new Integer(line.substring(line.lastIndexOf('\\t')+1));\n+                    Integer geonamesId = Integer.valueOf(line.substring(line.lastIndexOf('\\t')+1));\n                     adminCode2featureId.put(code, geonamesId);\n                 }\n             }\n@@ -875,11 +877,11 @@ private void readHierarchy() throws IOException{\n         while((line = reader.readLine()) != null){\n             lineCount++;\n             Tokenizer t = new Tokenizer(line);\n-            Integer parent = new Integer(t.nextElement());\n-            Integer child = new Integer(t.nextElement());\n+            Integer parent = Integer.valueOf(t.next());\n+            Integer child = Integer.valueOf(t.next());\n             String type;\n-            if(t.hasMoreElements()){\n-                type = t.nextElement();\n+            if(t.hasNext()){\n+                type = t.next();\n             } else {\n                 type = null;\n             }\n@@ -964,34 +966,34 @@ private void readHierarchy() throws IOException{\n         private final static String TRUE = \"1\";\n         protected FeatureName(String line){\n             Tokenizer t = new Tokenizer(line);\n-            labelID = Integer.parseInt(t.nextElement()); //first Elem the labelID\n-            geonameID = Integer.parseInt(t.nextElement());\n-            String lang = t.nextElement();\n-            if(lang != null && (lang.length() == 2 || lang.length() == 3)){\n-                this.lang = lang;\n+            labelID = Integer.parseInt(t.next()); //first Elem the labelID\n+            geonameID = Integer.parseInt(t.next());\n+            String language = t.next();\n+            if(language != null && (language.length() == 2 || language.length() == 3)){\n+                this.lang = language;\n             } else {\n                 this.lang = null; //no valied lang Code\n             }\n-            if(lang == null || lang.length()<=3){\n+            if(language == null || language.length()<=3){\n                 type = NameType.naturalLanguage;\n-            } else if(\"post\".equals(lang)){\n+            } else if(\"post\".equals(language)){\n                 type = NameType.postal;\n-            } else if(\"link\".equals(lang)) {\n+            } else if(\"link\".equals(language)) {\n                 type = NameType.link;\n-            } else if(\"abbr\".equals(lang)) {\n+            } else if(\"abbr\".equals(language)) {\n                 type = NameType.abbreviation;\n-            } else if(\"iata\".equals(lang) || \"icao\".equals(lang) || \"faac\".equals(lang)){\n+            } else if(\"iata\".equals(language) || \"icao\".equals(language) || \"faac\".equals(language)){\n                 type = NameType.airportCode;\n             } else {\n                 type = NameType.unknown; // e.g. fr_1793 for French Revolution names\n             }\n-            name = t.nextElement();\n+            name = t.next();\n             if(name == null){\n                 throw new IllegalStateException(\" Unable to parse name from line:\" + line);\n             }\n-            String act = t.nextElement();\n+            String act = t.next();\n             this.preferred = act != null && act.equals(TRUE);\n-            act = t.nextElement();\n+            act = t.next();\n             this.shortName = act != null && act.equals(TRUE);\n         }\n         public final Integer getGeonameID() {\n@@ -1017,9 +1019,7 @@ public final NameType getLabelType(){\n         }\n         @Override\n         public final boolean equals(Object obj) {\n-            return obj != null &&\n-                    obj instanceof FeatureName &&\n-                    ((FeatureName)obj).labelID == labelID;\n+            return obj instanceof FeatureName && ((FeatureName)obj).labelID == labelID;\n         }\n         @Override\n         public final int hashCode() {\n@@ -1029,20 +1029,20 @@ public final String toString(){\n             return name+(lang!=null?('@'+lang):\"\");\n         }\n     }\n-    public static class Tokenizer implements Enumeration<String>{\n+    public static class Tokenizer implements Iterator<String>{\n         private static final String DELIM =\"\\t\";\n         private final StringTokenizer t;\n-        boolean prevElementWasNull = true;\n+        private boolean prevElementWasNull = true;\n         public Tokenizer(String data){\n             t = new StringTokenizer(data, DELIM, true);\n         }\n         @Override\n-        public boolean hasMoreElements() {\n+       public boolean hasNext() {\n             return t.hasMoreTokens();\n         }\n \n         @Override\n-        public String nextElement() {\n+        public String next() {\n             if(!prevElementWasNull){\n                 t.nextElement();//dump the delim\n             }\n@@ -1063,5 +1063,9 @@ public String nextElement() {\n                 }\n             }\n         }\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n     }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java",
                "sha": "169bf6cf9ccc4fb324f1cfe249d8fa527de0ee6a",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/cli/CommandLineRunner.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/cli/CommandLineRunner.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/cli/CommandLineRunner.java",
                "patch": "@@ -25,7 +25,6 @@\n import static org.apache.stanbol.entityhub.indexing.geonames.GeoNamesIndexer.KEY_YARD;\n \n import java.io.IOException;\n-import java.net.URL;\n import java.util.Dictionary;\n import java.util.Hashtable;\n \n@@ -43,7 +42,8 @@\n import org.slf4j.LoggerFactory;\n \n \n-public class CommandLineRunner {\n+public final class CommandLineRunner {\n+    private CommandLineRunner(){}\n \n     protected static final Logger log = LoggerFactory.getLogger(CommandLineRunner.class);\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/cli/CommandLineRunner.java",
                "sha": "743b591c9cc7dd063773d195aef2d7c99aa2532f",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpoint.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpoint.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpoint.java",
                "patch": "@@ -67,20 +67,20 @@\n     //public static final String FREEMARKER_TEMPLATE_CLASSPATH_PROPERTY = \"org.apache.stanbol.entityhub.jersey.templates.classpath\";\n \n     @Reference\n-    TcManager tcManager;\n+    private TcManager tcManager;\n \n     @Reference\n-    Entityhub entityhub;\n+    private Entityhub entityhub;\n \n     @Reference\n-    ReferencedSiteManager referencedSiteManager;\n+    private ReferencedSiteManager referencedSiteManager;\n \n \n     @Reference\n-    HttpService httpService;\n+    private HttpService httpService;\n \n     @Reference\n-    Serializer serializer;\n+    private Serializer serializer;\n \n \n     protected ServletContext servletContext;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpoint.java",
                "sha": "186c98d1f1b789a1d172f6e1c559d377ec61b8b3",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpointApplication.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpointApplication.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpointApplication.java",
                "patch": "@@ -21,11 +21,11 @@\n \n import javax.ws.rs.core.Application;\n \n-import org.apache.stanbol.entityhub.jersey.resource.ReferencedSiteRootResource;\n import org.apache.stanbol.entityhub.jersey.resource.EntityMappingResource;\n import org.apache.stanbol.entityhub.jersey.resource.EntityhubRootResource;\n-import org.apache.stanbol.entityhub.jersey.resource.SymbolResource;\n+import org.apache.stanbol.entityhub.jersey.resource.ReferencedSiteRootResource;\n import org.apache.stanbol.entityhub.jersey.resource.SiteManagerRootResource;\n+import org.apache.stanbol.entityhub.jersey.resource.SymbolResource;\n import org.apache.stanbol.entityhub.jersey.writers.JettisonWriter;\n import org.apache.stanbol.entityhub.jersey.writers.QueryResultListWriter;\n import org.apache.stanbol.entityhub.jersey.writers.SignWriter;\n@@ -46,7 +46,7 @@\n  */\n public class JerseyEndpointApplication extends Application {\n \n-    Logger log = LoggerFactory.getLogger(getClass());\n+    private static Logger log = LoggerFactory.getLogger(JerseyEndpointApplication.class);\n     public JerseyEndpointApplication() {\n         log.info(\"JerseyEndpointApplication instanceiated\");\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/JerseyEndpointApplication.java",
                "sha": "16dc95f24a701ebc58a9b57107a6906bf0a23474",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/parsers/JSONToFieldQuery.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/parsers/JSONToFieldQuery.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/parsers/JSONToFieldQuery.java",
                "patch": "@@ -40,12 +40,14 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class JSONToFieldQuery {\n+public final class JSONToFieldQuery {\n+    private JSONToFieldQuery(){}\n+    \n     private static final Logger log = LoggerFactory.getLogger(JSONToFieldQuery.class);\n     \n     public static FieldQuery fromJSON(FieldQueryFactory queryFactory, String jsonQueryString) throws JSONException{\n         if(jsonQueryString == null){\n-            throw new NullPointerException(\"The parsed JSON object MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed JSON object MUST NOT be NULL!\");\n         }\n         JSONObject jQuery = new JSONObject(jsonQueryString);\n         FieldQuery query = queryFactory.createFieldQuery();",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/parsers/JSONToFieldQuery.java",
                "sha": "6c2af7929633308e79f6f1890d77a477c0b2048a",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/EntityMappingResource.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/EntityMappingResource.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 12,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/EntityMappingResource.java",
                "patch": "@@ -40,9 +40,6 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n \n-import org.apache.clerezza.rdf.core.TripleCollection;\n-import org.apache.clerezza.rdf.core.access.TcManager;\n-import org.apache.clerezza.rdf.core.serializedform.Serializer;\n import org.apache.stanbol.entityhub.core.query.QueryResultListImpl;\n import org.apache.stanbol.entityhub.jersey.utils.JerseyUtils;\n import org.apache.stanbol.entityhub.servicesapi.Entityhub;\n@@ -74,20 +71,12 @@\n \n     private final Logger log = LoggerFactory.getLogger(getClass());\n \n-    protected Entityhub entityhub;\n-\n-    protected TcManager tcManager;\n-\n-    protected Serializer serializer;\n-\n-    protected TripleCollection entityCache;\n+    private Entityhub entityhub;\n \n     // bind the job manager by looking it up from the servlet request context\n     public EntityMappingResource(@Context ServletContext context) {\n         super();\n         entityhub = (Entityhub) context.getAttribute(Entityhub.class.getName());\n-        tcManager = (TcManager) context.getAttribute(TcManager.class.getName());\n-        serializer = (Serializer) context.getAttribute(Serializer.class.getName());\n     }\n \n     @GET",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/EntityMappingResource.java",
                "sha": "579a75ba2ac58d67f4af9bc99f90ecdf9056a8a7",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/NavigationMixin.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/NavigationMixin.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/NavigationMixin.java",
                "patch": "@@ -42,7 +42,7 @@ protected NavigationMixin(UriInfo uriInfo) {\n     }\n \n     @Context\n-    protected UriInfo uriInfo;\n+    private UriInfo uriInfo;\n \n     public URI getPublicBaseUri() {\n         return uriInfo.getBaseUri();\n@@ -61,11 +61,11 @@ public MenuItem(String label, String link, UriInfo uriInfo) {\n             cssClass = uriInfo.getPath().startsWith(link.substring(1)) ? \"selected\" : \"unselected\";\n         }\n \n-        protected final String label;\n+        private final String label;\n \n-        protected final String link;\n+        private final String link;\n \n-        protected final String cssClass;\n+        private final String cssClass;\n \n         public String getLabel() {\n             return label;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/NavigationMixin.java",
                "sha": "7b78442528bc0b02f6ece608efa88ae74ef3177d",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/ReferencedSiteRootResource.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/ReferencedSiteRootResource.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 7,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/ReferencedSiteRootResource.java",
                "patch": "@@ -21,7 +21,6 @@\n \n import java.io.File;\n import java.util.Arrays;\n-import java.util.Collection;\n import java.util.Set;\n import java.util.TreeSet;\n \n@@ -41,13 +40,11 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n \n-import org.apache.clerezza.rdf.core.serializedform.Serializer;\n import org.apache.clerezza.rdf.core.serializedform.SupportedFormat;\n import org.apache.clerezza.rdf.ontologies.RDFS;\n import org.apache.stanbol.entityhub.jersey.utils.JerseyUtils;\n import org.apache.stanbol.entityhub.servicesapi.model.Sign;\n import org.apache.stanbol.entityhub.servicesapi.query.FieldQuery;\n-import org.apache.stanbol.entityhub.servicesapi.site.ConfiguredSite;\n import org.apache.stanbol.entityhub.servicesapi.site.ReferencedSite;\n import org.apache.stanbol.entityhub.servicesapi.site.ReferencedSiteException;\n import org.apache.stanbol.entityhub.servicesapi.site.ReferencedSiteManager;\n@@ -77,21 +74,21 @@\n     /**\n      * The Field used as default as selected fields for find requests\n      * TODO: Make configurable via the {@link ConfiguredSite} interface!\n+     * NOTE: This feature is deactivated, because OPTIONAL selects do have very\n+     * weak performance when using SPARQL endpoints\n      */\n-    private static final Collection<String> DEFAULT_FIND_SELECTED_FIELDS = Arrays.asList(RDFS.comment.getUnicodeString());\n+//    private static final Collection<String> DEFAULT_FIND_SELECTED_FIELDS = Arrays.asList(RDFS.comment.getUnicodeString());\n     /**\n      * The default number of maximal results.\n      */\n     private static final int DEFAULT_FIND_RESULT_LIMIT = 5;\n-    protected Serializer serializer;\n \n-    protected ReferencedSite site;\n+    private ReferencedSite site;\n \n     public ReferencedSiteRootResource(@Context ServletContext context, @PathParam(value = \"site\") String siteId) {\n         super();\n         log.info(\"... init ReferencedSiteRootResource for Site {}\", siteId);\n         ReferencedSiteManager referencedSiteManager = (ReferencedSiteManager) context.getAttribute(ReferencedSiteManager.class.getName());\n-        serializer = (Serializer) context.getAttribute(Serializer.class.getName());\n         if (referencedSiteManager == null) {\n             log.error(\"Missing referencedSiteManager={}\", referencedSiteManager);\n             throw new WebApplicationException(Response.Status.NOT_FOUND);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/ReferencedSiteRootResource.java",
                "sha": "c1ebf8d87aeb687f2209362646c8f61ee1a39256",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SiteManagerRootResource.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SiteManagerRootResource.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SiteManagerRootResource.java",
                "patch": "@@ -50,7 +50,6 @@\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.UriInfo;\n \n-import org.apache.clerezza.rdf.core.serializedform.Serializer;\n import org.apache.clerezza.rdf.ontologies.RDFS;\n import org.apache.stanbol.entityhub.jersey.utils.JerseyUtils;\n import org.apache.stanbol.entityhub.servicesapi.model.Sign;\n@@ -85,15 +84,12 @@\n      */\n     private static final int DEFAULT_FIND_RESULT_LIMIT = 5;\n \n-    protected Serializer serializer;\n-\n     private ReferencedSiteManager referencedSiteManager;\n \n     public SiteManagerRootResource(@Context ServletContext context) {\n         super();\n         log.info(\"... init SiteManagerRootResource\");\n         referencedSiteManager = (ReferencedSiteManager) context.getAttribute(ReferencedSiteManager.class.getName());\n-        serializer = (Serializer) context.getAttribute(Serializer.class.getName());\n         if (referencedSiteManager == null) {\n             log.error(\"Missing referencedSiteManager={}\", referencedSiteManager);\n             throw new WebApplicationException(NOT_FOUND);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SiteManagerRootResource.java",
                "sha": "371714b1957e682bbb92694bcbd876f345c67bb5",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SymbolResource.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SymbolResource.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 12,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SymbolResource.java",
                "patch": "@@ -50,9 +50,6 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n \n-import org.apache.clerezza.rdf.core.TripleCollection;\n-import org.apache.clerezza.rdf.core.access.TcManager;\n-import org.apache.clerezza.rdf.core.serializedform.Serializer;\n import org.apache.stanbol.entityhub.jersey.utils.JerseyUtils;\n import org.apache.stanbol.entityhub.servicesapi.Entityhub;\n import org.apache.stanbol.entityhub.servicesapi.EntityhubException;\n@@ -87,20 +84,12 @@\n \n     private final Logger log = LoggerFactory.getLogger(getClass());\n \n-    protected Entityhub entityhub;\n-\n-    protected TcManager tcManager;\n-\n-    protected Serializer serializer;\n-\n-    protected TripleCollection entityCache;\n+    private Entityhub entityhub;\n \n     // bind the job manager by looking it up from the servlet request context\n     public SymbolResource(@Context ServletContext context) {\n         super();\n         entityhub = (Entityhub) context.getAttribute(Entityhub.class.getName());\n-        tcManager = (TcManager) context.getAttribute(TcManager.class.getName());\n-        serializer = (Serializer) context.getAttribute(Serializer.class.getName());\n     }\n \n     @GET",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/resource/SymbolResource.java",
                "sha": "38c79e9c335ea1327de8f1949200f9a132f9b8a7",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/JettisonWriter.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/JettisonWriter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/JettisonWriter.java",
                "patch": "@@ -44,7 +44,7 @@ public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotat\n     }\n \n     @Override\n-    public void writeTo(Object value, Class<?> __doNotUse, Type genericType,\n+    public void writeTo(Object value, Class<?> doNotUse, Type genericType,\n             Annotation[] annotations, MediaType mediaType,\n             MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\n             throws IOException, WebApplicationException {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/JettisonWriter.java",
                "sha": "7f9eed9b1c57591b9a09939a1751e041b6ab73eb",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/QueryResultListWriter.java",
                "changes": 29,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/QueryResultListWriter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 25,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/QueryResultListWriter.java",
                "patch": "@@ -44,8 +44,6 @@\n import org.apache.commons.io.IOUtils;\n import org.apache.stanbol.entityhub.servicesapi.query.QueryResultList;\n import org.codehaus.jettison.json.JSONException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  * TODO: Replace with Serializer infrastructure similar to {@link Serializer}\n@@ -54,9 +52,9 @@\n @Produces({APPLICATION_JSON, N3, N_TRIPLE, RDF_XML, TURTLE, X_TURTLE, RDF_JSON})\n public class QueryResultListWriter implements MessageBodyWriter<QueryResultList<?>> {\n \n-    private final Logger log = LoggerFactory.getLogger(QueryResultListWriter.class);\n+//    private final Logger log = LoggerFactory.getLogger(QueryResultListWriter.class);\n     @Context\n-    protected ServletContext servletContext;\n+    private ServletContext servletContext;\n \n     protected Serializer getSerializer() {\n         return (Serializer) servletContext.getAttribute(Serializer.class.getName());\n@@ -69,33 +67,14 @@ public long getSize(QueryResultList<?> result, Class<?> type, Type genericType,\n \n     @Override\n     public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n-        //TODO: The type is also parsed as genericType ... so we can only check\n-        //for the type :(\n         return QueryResultList.class.isAssignableFrom(type);\n-//       if(QueryResultList.class.isAssignableFrom(type) &&\n-//               genericType != null &&  //QueryResult is always a generic Type\n-//               genericType instanceof Class<?>){ //and such types do not use generics\n-//           //This writer supports String, Representation and all types of Signs\n-//           Class<?> genericClass  = (Class<?>) genericType;\n-//\n-//           if(String.class.isAssignableFrom(genericClass) ||\n-//                   Representation.class.isAssignableFrom(genericClass) ||\n-//                   Sign.class.isAssignableFrom(genericClass)){\n-//               //maybe we need further checks if we do not support all data types\n-//               //for all generic types! But currently all different types of\n-//               //QueryResultList support all the different MediaTypes!\n-//               return true;\n-//           }\n-//       }\n-//       log.info(\"Request for not writeable combination: type=\"+type+\"|genericType=\"+genericType+\"|mediaType=\"+mediaType);\n-//       return false;\n     }\n \n     @Override\n-    public void writeTo(QueryResultList<?> resultList, Class<?> __doNotUse, Type genericType,\n+    public void writeTo(QueryResultList<?> resultList, Class<?> doNotUse, Type genericType,\n             Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders,\n             OutputStream entityStream) throws IOException, WebApplicationException {\n-        Class<?> genericClass = (Class<?>) genericType;\n+//        Class<?> genericClass = (Class<?>) genericType;\n         if (APPLICATION_JSON.equals(mediaType.toString())) {\n             try {\n                 IOUtils.write(QueryResultsToJSON.toJSON(resultList).toString(4), entityStream,\"UTF-8\");",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/QueryResultListWriter.java",
                "sha": "79c9eedf77450de3d59d2465a65e0dde0a394645",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignToRDF.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignToRDF.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 7,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignToRDF.java",
                "patch": "@@ -35,13 +35,13 @@\n final class SignToRDF {\n     private SignToRDF() { /* do not create instances of utility classes */}\n \n-    static UriRef signRepresentation = new UriRef(RdfResourceEnum.signRepresentation.getUri());\n-    static UriRef signSite = new UriRef(RdfResourceEnum.signSite.getUri());\n-    static UriRef sign = new UriRef(RdfResourceEnum.Sign.getUri());\n-    static UriRef entityMapping = new UriRef(RdfResourceEnum.EntityMapping.getUri());\n-    static UriRef symbol = new UriRef(RdfResourceEnum.Symbol.getUri());\n-    static RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n-    static LiteralFactory literalFactory = LiteralFactory.getInstance();\n+    private static UriRef signRepresentation = new UriRef(RdfResourceEnum.signRepresentation.getUri());\n+    private static UriRef signSite = new UriRef(RdfResourceEnum.signSite.getUri());\n+    private static UriRef sign = new UriRef(RdfResourceEnum.Sign.getUri());\n+    private static UriRef entityMapping = new UriRef(RdfResourceEnum.EntityMapping.getUri());\n+    private static UriRef symbol = new UriRef(RdfResourceEnum.Symbol.getUri());\n+    private static RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n+    private static LiteralFactory literalFactory = LiteralFactory.getInstance();\n \n     static MGraph toRDF(Representation representation) {\n         MGraph graph = new SimpleMGraph();",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignToRDF.java",
                "sha": "5dd075fc1d0cb2ee4c3c9269cc3f04c7dbee7769",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignWriter.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignWriter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignWriter.java",
                "patch": "@@ -70,13 +70,13 @@\n         supportedMediaTypes = Collections.unmodifiableSet(types);\n     }\n     @Context\n-    protected ServletContext servletContext;\n+    private ServletContext servletContext;\n \n     protected Serializer getSerializer() {\n         return (Serializer) servletContext.getAttribute(Serializer.class.getName());\n     }\n     @Override\n-    public long getSize(Sign Sign, Class<?> type, Type genericType,\n+    public long getSize(Sign sign, Class<?> type, Type genericType,\n             Annotation[] annotations, MediaType mediaType) {\n         return -1; //to hard to calculate\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/jersey/src/main/java/org/apache/stanbol/entityhub/jersey/writers/SignWriter.java",
                "sha": "5cad9757f81cd8a6daafe3efbf700f03cb6838ab",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/launchers/sling/src/main/bundles/list.xml",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/launchers/sling/src/main/bundles/list.xml?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/launchers/sling/src/main/bundles/list.xml",
                "patch": "@@ -109,12 +109,11 @@\n         <artifactId>joda-time</artifactId>\n         <version>1.6.2</version>\n     </bundle>\n-    <!-- TODO: currently embedded in linkedData Bundle because of error\n     <bundle>\n-\t    <groupId>org.json</groupId>\n-\t    <artifactId>json</artifactId>\n-\t    <version>20090211</version>\n-    </bundle>  -->\n+        <groupId>org.codehaus.jettison</groupId>\n+        <artifactId>jettison</artifactId>\n+        <version>1.2</version>    \n+    </bundle>\n   </startLevel>\n \n   <!-- RICK infrastructure and required libraries-->",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/launchers/sling/src/main/bundles/list.xml",
                "sha": "b405aa94e7e15a3bd3726a2affc518167b4bca69",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/pom.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/pom.xml?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/model/clerezza/pom.xml",
                "patch": "@@ -58,7 +58,6 @@\n           <instructions>\n             <Export-Package>\n               org.apache.stanbol.entityhub.model.clerezza;version=${pom.version},\n-              org.apache.stanbol.entityhub.model.clerezza.utils;version=${pom.version},\n             </Export-Package>\n            <Private-Package>\n               org.apache.stanbol.entityhub.model.clerezza.impl;version=${pom.version}",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/pom.xml",
                "sha": "dc8cdde5c6584b675a53bd36fb0593bc96ab40c9",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfReference.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfReference.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfReference.java",
                "patch": "@@ -23,7 +23,7 @@\n     private final UriRef uri;\n     protected RdfReference(String reference){\n         if(reference == null){\n-            throw new NullPointerException(\"The parsed Reference MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Reference MUST NOT be NULL!\");\n         } else if(reference.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed Reference MUST NOT be Empty!\");\n         } else {\n@@ -32,7 +32,7 @@ protected RdfReference(String reference){\n     }\n     protected RdfReference(UriRef uri){\n         if(uri == null){\n-            throw new NullPointerException(\"The parsed Reference MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Reference MUST NOT be NULL!\");\n         } else if(uri.getUnicodeString().isEmpty()){\n             throw new IllegalArgumentException(\"The parsed Reference MUST NOT be represent an empty string!\");\n         } else {\n@@ -56,7 +56,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null &&obj instanceof Reference && uri.getUnicodeString().equals(((Reference)obj).getReference());\n+        return obj instanceof Reference && uri.getUnicodeString().equals(((Reference)obj).getReference());\n     }\n     @Override\n     public String toString() {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfReference.java",
                "sha": "1998c79a0e74a6449a1997f896ddb7173bbef4da",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java",
                "changes": 38,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 19,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java",
                "patch": "@@ -35,10 +35,10 @@\n import org.apache.stanbol.entityhub.model.clerezza.impl.Literal2TextAdapter;\n import org.apache.stanbol.entityhub.model.clerezza.impl.LiteralAdapter;\n import org.apache.stanbol.entityhub.model.clerezza.impl.NaturalTextFilter;\n+import org.apache.stanbol.entityhub.model.clerezza.impl.Resource2StringAdapter;\n import org.apache.stanbol.entityhub.model.clerezza.impl.Resource2ValueAdapter;\n import org.apache.stanbol.entityhub.model.clerezza.impl.UriRef2ReferenceAdapter;\n import org.apache.stanbol.entityhub.model.clerezza.impl.UriRefAdapter;\n-import org.apache.stanbol.entityhub.model.clerezza.utils.Resource2StringAdapter;\n import org.apache.stanbol.entityhub.servicesapi.model.Reference;\n import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n import org.apache.stanbol.entityhub.servicesapi.model.Text;\n@@ -82,7 +82,7 @@ protected UriRef getRepresentationType(){\n     @Override\n     public void add(String field, Object value) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -128,7 +128,7 @@ private void addTypedLiteral(UriRef field, Object literalValue){\n     @Override\n     public void addReference(String field, String reference) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -142,7 +142,7 @@ public void addReference(String field, String reference) {\n     @Override\n     public void addNaturalText(String field, String text, String...languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -164,7 +164,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public <T> Iterator<T> get(String field, final Class<T> type) throws UnsupportedTypeException {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -206,7 +206,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public Iterator<Reference> getReferences(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -218,7 +218,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public Iterator<Text> getText(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -231,7 +231,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public Iterator<Object> get(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -242,7 +242,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public Iterator<Text> get(String field, String...languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -261,7 +261,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public <T> T getFirst(String field, Class<T> type) throws UnsupportedTypeException {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -276,7 +276,7 @@ private void addNaturalText(UriRef field, String text, String...languages) {\n     @Override\n     public Object getFirst(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -290,7 +290,7 @@ public Object getFirst(String field) {\n     @Override\n     public Reference getFirstReference(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -300,7 +300,7 @@ public Reference getFirstReference(String field) {\n     @Override\n     public Text getFirst(String field, String...languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -331,7 +331,7 @@ public UriRef getNode(){\n     @Override\n     public void remove(String field, Object parsedValue) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -367,7 +367,7 @@ public void remove(String field, Object parsedValue) {\n     @Override\n     public void removeReference(String field, String reference) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -390,7 +390,7 @@ protected void removeTypedLiteral(UriRef field, Object object){\n     @Override\n     public void removeNaturalText(String field, String value, String... languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -414,7 +414,7 @@ public void removeNaturalText(String field, String value, String... languages) {\n     @Override\n     public void removeAll(String field) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -423,7 +423,7 @@ public void removeAll(String field) {\n     @Override\n     public void removeAllNaturalText(String field, String... languages) {\n         if(field == null){\n-            throw new NullPointerException(\"The parsed field MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed field MUST NOT be NULL\");\n         } else if(field.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed field MUST NOT be Empty\");\n         }\n@@ -478,7 +478,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof Representation && ((Representation)obj).getId().equals(getId());\n+        return obj instanceof Representation && ((Representation)obj).getId().equals(getId());\n     }\n \n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java",
                "sha": "b7e05f7be130d054fb25117eaa1a61f3a419b912",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfResourceUtils.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfResourceUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfResourceUtils.java",
                "patch": "@@ -37,15 +37,13 @@\n import org.apache.clerezza.rdf.core.impl.PlainLiteralImpl;\n import org.apache.clerezza.rdf.core.impl.SimpleLiteralFactory;\n import org.apache.stanbol.entityhub.servicesapi.defaults.DataTypeEnum;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  * Utilities to create {@link Resource} instances for Java Objects.\n  * @author Rupert Westenthaler\n  *\n  */\n-public class RdfResourceUtils {\n+public final class RdfResourceUtils {\n \n     private RdfResourceUtils(){/*do not create instances of Util Classes*/}\n     /**\n@@ -136,7 +134,7 @@ public String toString() {\n         JAVA_OBJECT_XSD_DATATYPE_MAPPING = Collections.unmodifiableMap(objectMappings);\n     }\n \n-    private static final Logger log = LoggerFactory.getLogger(RdfResourceUtils.class);\n+//    private static final Logger log = LoggerFactory.getLogger(RdfResourceUtils.class);\n \n     private static final LiteralFactory literalFactory = LiteralFactory.getInstance();\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfResourceUtils.java",
                "sha": "5324ca00cf526b6ab67a99730b82db7f970fa8c5",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfText.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfText.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfText.java",
                "patch": "@@ -28,7 +28,7 @@\n \n     protected RdfText(String text, String lang) {\n         if(text == null){\n-            throw new NullPointerException(\"The parsed text MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed text MUST NOT be NULL\");\n         } else if(text.isEmpty()){\n             throw new IllegalArgumentException(\"Tha parsed Text MUST NOT be empty!\");\n         }\n@@ -61,7 +61,7 @@ public Literal getLiteral() {\n     }\n \n     @Override\n-    public Object clone() {\n+    public RdfText clone() {\n         Language language = isPlain ? ((PlainLiteral) literal).getLanguage() : null;\n         return new RdfText(new PlainLiteralImpl(literal.getLexicalForm(), language));\n     }\n@@ -73,7 +73,7 @@ public int hashCode() {\n \n     @Override\n     public boolean equals(Object obj) {\n-        if (obj != null && obj instanceof Text && ((Text) obj).getText().equals(getText())) {\n+        if (obj instanceof Text && ((Text) obj).getText().equals(getText())) {\n             return (getLanguage() == null && ((Text) obj).getLanguage() == null)\n                     || (getLanguage() != null && getLanguage().equals(((Text) obj).getLanguage()));\n         } else {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfText.java",
                "sha": "cb4fe4ea842898e7ac645b773cf122a0421a9f7a",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactory.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactory.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 6,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactory.java",
                "patch": "@@ -33,7 +33,7 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class RdfValueFactory implements ValueFactory {\n+public final class RdfValueFactory implements ValueFactory {\n \n     private static RdfValueFactory instance;\n     /**\n@@ -55,7 +55,7 @@ private RdfValueFactory(){\n     @Override\n     public RdfReference createReference(Object value) {\n         if (value == null) {\n-            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n         } else if (value instanceof UriRef) {\n             return new RdfReference((UriRef) value);\n         } else {\n@@ -66,7 +66,7 @@ public RdfReference createReference(Object value) {\n     @Override\n     public RdfText createText(Object value) {\n         if (value == null) {\n-            throw new NullPointerException(\"The parsed value MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed value MUST NOT be NULL\");\n         } else if (value instanceof Literal) {\n             return new RdfText((Literal) value);\n         } else {\n@@ -82,7 +82,7 @@ public RdfText createText(String text, String language) {\n     @Override\n     public RdfRepresentation createRepresentation(String id) {\n         if (id == null){\n-           throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+           throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL!\");\n         } else if(id.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed id MUST NOT be empty!\");\n         } else {\n@@ -102,10 +102,10 @@ public RdfRepresentation createRepresentation(String id) {\n      */\n     public RdfRepresentation createRdfRepresentation(UriRef node, TripleCollection graph) {\n         if (node == null) {\n-            throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL!\");\n         }\n         if(graph == null){\n-            throw new NullPointerException(\"The parsed graph MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed graph MUST NOT be NULL!\");\n         }\n         return new RdfRepresentation(node, graph);\n     }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactory.java",
                "sha": "6e596f28e5943169ae4c640cc3920a19b9ddf4df",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Literal2TextAdapter.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Literal2TextAdapter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Literal2TextAdapter.java",
                "patch": "@@ -60,9 +60,9 @@\n     /**\n      * Unmodifiable set of the active languages\n      */\n-    protected final Set<String> languages;\n+    private final Set<String> languages;\n     private final boolean containsNull;\n-    protected final RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n+    private final RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n \n     /**\n      * Filters Literals in the parsed Iterator based on the parsed languages and\n@@ -84,7 +84,7 @@ public Literal2TextAdapter(String...lang){\n     }\n \n     @Override\n-    public Text adapt(T value, Class<Text> type) {\n+    public final Text adapt(T value, Class<Text> type) {\n         if(value instanceof PlainLiteral){\n             String literalLang = ((PlainLiteral) value).getLanguage() == null ? \n                     null : ((PlainLiteral) value).getLanguage().toString();",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Literal2TextAdapter.java",
                "sha": "e166efe90f4286e6ea8c8c0d805558cdef316aea",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/LiteralAdapter.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/LiteralAdapter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/LiteralAdapter.java",
                "patch": "@@ -48,14 +48,14 @@\n  */\n public class LiteralAdapter<T extends Literal,A> implements Adapter<T, A> {\n \n-    static Logger log = LoggerFactory.getLogger(LiteralAdapter.class);\n+    private static Logger log = LoggerFactory.getLogger(LiteralAdapter.class);\n \n-    LiteralFactory lf = LiteralFactory.getInstance();\n-    RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n+    private LiteralFactory lf = LiteralFactory.getInstance();\n+    private RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public A adapt(T value, Class<A> type) {\n+    public final A adapt(T value, Class<A> type) {\n // NOTE: (Rupert Westenthaler 12.01.2011)\n //      Converting everything to String is not an intended functionality. When\n //      someone parsed String.class he rather assumes that he gets only string",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/LiteralAdapter.java",
                "sha": "bac8d09acd96409316dd7766958f12ef48586ad3",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/NaturalTextFilter.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/NaturalTextFilter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/NaturalTextFilter.java",
                "patch": "@@ -50,13 +50,13 @@\n  *\n  */\n public class NaturalTextFilter implements Filter<Literal> {\n-    Logger log = LoggerFactory.getLogger(NaturalTextFilter.class);\n+    private Logger log = LoggerFactory.getLogger(NaturalTextFilter.class);\n     /**\n      * The xsd:string data type constant used for TypedLiterals to check if the\n      * represent an string value!\n      */\n     private static UriRef xsdString = new UriRef(DataTypeEnum.String.getUri());\n-    protected final Set<String> languages;\n+    private final Set<String> languages;\n     private final boolean containsNull;\n \n     public NaturalTextFilter(String...languages){\n@@ -77,7 +77,7 @@ public NaturalTextFilter(String...languages){\n         }\n     }\n     @Override\n-    public boolean isValid(Literal value) {\n+    public final boolean isValid(Literal value) {\n         if (value instanceof PlainLiteral){\n            if(languages == null) { //no language restrictions\n                 return true; //return any Plain Literal",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/NaturalTextFilter.java",
                "sha": "52cfeccc511ed2bf1124c124cdccf9625a0fee18",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2StringAdapter.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2StringAdapter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2StringAdapter.java",
                "patch": "@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.stanbol.entityhub.model.clerezza.utils;\n+package org.apache.stanbol.entityhub.model.clerezza.impl;\n \n import org.apache.clerezza.rdf.core.Literal;\n import org.apache.clerezza.rdf.core.Resource;\n@@ -32,7 +32,7 @@\n public class Resource2StringAdapter<T extends Resource> implements Adapter<T, String> {\n \n     @Override\n-    public String adapt(T value, Class<String> type) {\n+    public final String adapt(T value, Class<String> type) {\n         if (value == null) {\n             return null;\n         } else if (value instanceof UriRef) {",
                "previous_filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/utils/Resource2StringAdapter.java",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2StringAdapter.java",
                "sha": "49f90b1d9ce1c442c55125763a728c5a170f104b",
                "status": "renamed"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2ValueAdapter.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2ValueAdapter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2ValueAdapter.java",
                "patch": "@@ -39,15 +39,15 @@\n  */\n public class Resource2ValueAdapter<T extends Resource> implements Adapter<T, Object> {\n \n-    Logger log = LoggerFactory.getLogger(Resource2ValueAdapter.class);\n+    private static Logger log = LoggerFactory.getLogger(Resource2ValueAdapter.class);\n \n \n-    protected final LiteralFactory literalFactory = LiteralFactory.getInstance();\n+    private final LiteralFactory literalFactory = LiteralFactory.getInstance();\n \n-    RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n+    private RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n \n     @Override\n-    public Object adapt(T value, Class<Object> type) {\n+    public final Object adapt(T value, Class<Object> type) {\n         if(value instanceof UriRef){\n             return valueFactory.createReference((UriRef)value);\n         } else if(value instanceof PlainLiteral){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/Resource2ValueAdapter.java",
                "sha": "c8e029603990b036ba9caa9a709fd71d4b43c8f3",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRef2ReferenceAdapter.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRef2ReferenceAdapter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRef2ReferenceAdapter.java",
                "patch": "@@ -33,7 +33,7 @@\n     private final RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n \n     @Override\n-    public Reference adapt(UriRef value, Class<Reference> type) {\n+    public final Reference adapt(UriRef value, Class<Reference> type) {\n         return valueFactory.createReference(value);\n     }\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRef2ReferenceAdapter.java",
                "sha": "2223cd2ed25d8acdf7dab077e7b91e4c959a1980",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRefAdapter.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRefAdapter.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRefAdapter.java",
                "patch": "@@ -29,11 +29,11 @@\n \n public class UriRefAdapter<A> implements Adapter<UriRef, A> {\n \n-    static Logger log = LoggerFactory.getLogger(UriRefAdapter.class);\n+    private static Logger log = LoggerFactory.getLogger(UriRefAdapter.class);\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public A adapt(UriRef value, Class<A> type) {\n+    public final A adapt(UriRef value, Class<A> type) {\n         if(type.equals(URI.class)){\n             try {\n                 return (A) new URI(value.getUnicodeString());",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/impl/UriRefAdapter.java",
                "sha": "e84b9d8b3a6d2faceec745b51074b2ea4d5f98d8",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentationTest.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentationTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentationTest.java",
                "patch": "@@ -33,8 +33,6 @@\n import org.apache.clerezza.rdf.core.PlainLiteral;\n import org.apache.clerezza.rdf.core.TypedLiteral;\n import org.apache.clerezza.rdf.core.impl.PlainLiteralImpl;\n-import org.apache.stanbol.entityhub.model.clerezza.RdfRepresentation;\n-import org.apache.stanbol.entityhub.model.clerezza.RdfValueFactory;\n import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n import org.apache.stanbol.entityhub.servicesapi.model.Text;\n import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentationTest.java",
                "sha": "9e2be188694aedbe6041910c6142603ceacfbec3",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactoryTest.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactoryTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactoryTest.java",
                "patch": "@@ -18,7 +18,6 @@\n \n import org.apache.clerezza.rdf.core.UriRef;\n import org.apache.clerezza.rdf.core.impl.SimpleMGraph;\n-import org.apache.stanbol.entityhub.model.clerezza.RdfValueFactory;\n import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;\n import org.apache.stanbol.entityhub.test.model.ValueFactoryTest;\n import org.junit.Before;\n@@ -48,12 +47,12 @@ protected Object getUnsupportedTextType() {\n     protected ValueFactory getValueFactory() {\n         return valueFactory;\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullNodeRepresentation() {\n         SimpleMGraph graph = new SimpleMGraph();\n         valueFactory.createRdfRepresentation(null, graph);\n     }\n-    @Test(expected=NullPointerException.class)\n+    @Test(expected=IllegalArgumentException.class)\n     public void testNullGraphRepresentation() {\n         UriRef rootNode = new UriRef(\"urn:test.rootNode\");\n         valueFactory.createRdfRepresentation(rootNode, null);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/model/clerezza/src/test/java/org/apache/stanbol/entityhub/model/clerezza/RdfValueFactoryTest.java",
                "sha": "5800660cea1d2f3531a5ec20e11de4d617365c53",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/RdfQueryResultList.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/RdfQueryResultList.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 8,
                "filename": "entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/RdfQueryResultList.java",
                "patch": "@@ -49,24 +49,24 @@ public RdfQueryResultList(FieldQuery query,MGraph resultGraph) {\n                         SparqlQueryUtils.parseQueryResultsFromMGraph(resultGraph)));\n     }\n     @Override\n-    public FieldQuery getQuery() {\n+    public final FieldQuery getQuery() {\n         return query;\n     }\n \n     @Override\n-    public Set<String> getSelectedFields() {\n+    public final Set<String> getSelectedFields() {\n         return query.getSelectedFields();\n     }\n \n     @Override\n-    public boolean isEmpty() {\n+    public final boolean isEmpty() {\n         return results.isEmpty();\n     }\n \n     @Override\n-    public Iterator<Representation> iterator() {\n+    public final Iterator<Representation> iterator() {\n         return new Iterator<Representation>() {\n-            Iterator<RdfRepresentation> it = results.iterator();\n+            private Iterator<RdfRepresentation> it = results.iterator();\n             @Override\n             public boolean hasNext() { return it.hasNext(); }\n             @Override\n@@ -77,18 +77,18 @@ public boolean isEmpty() {\n     }\n \n     @Override\n-    public int size() {\n+    public final int size() {\n         return results.size();\n     }\n     /**\n      * Getter for the RDF Graph holding the Results of the Query\n      * @return the RDF Graph with the Results\n      */\n-    public MGraph getResultGraph() {\n+    public final MGraph getResultGraph() {\n         return resultGraph;\n     }\n     @Override\n-    public Class<Representation> getType() {\n+    public final Class<Representation> getType() {\n         return Representation.class;\n     }\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/RdfQueryResultList.java",
                "sha": "0a7edf51004e3e2c1df7bae2a056b2017bc18926",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlFieldQuery.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlFieldQuery.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlFieldQuery.java",
                "patch": "@@ -37,9 +37,9 @@\n     private static final String FIELD_VAR_PREFIX = \"v_\";\n     private static final String ROOT_VAR_NAME = \"id\";\n     private int varNum;\n-    protected final Map<String,String> field2VarMappings;\n+    private final Map<String,String> field2VarMappings;\n     private final Map<String, String> unmodField2VarMappings;\n-    protected EndpointTypeEnum endpointType;\n+    private EndpointTypeEnum endpointType;\n     protected SparqlFieldQuery() {\n         this(null);\n     }\n@@ -135,7 +135,7 @@ public SparqlFieldQuery clone() {\n     }\n     @Override\n     public int hashCode() {\n-        return super.hashCode();\n+        return super.hashCode()+field2VarMappings.hashCode()+varNum+endpointType.ordinal();\n     }\n \n     /**\n@@ -152,7 +152,8 @@ public void removeAllSelectedFields() {\n     public boolean equals(Object obj) {\n         return super.equals(obj) && obj instanceof SparqlFieldQuery &&\n             ((SparqlFieldQuery)obj).field2VarMappings.equals(field2VarMappings) &&\n-            ((SparqlFieldQuery)obj).varNum == varNum;\n+            ((SparqlFieldQuery)obj).varNum == varNum &&\n+            ((SparqlFieldQuery)obj).endpointType == endpointType;\n     }\n     /**\n      * Getter for the SPARQL SELECT representation of this FieldQuery",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlFieldQuery.java",
                "sha": "b58ab8093786c8f85fa9f5b79f46221e235314b8",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlQueryUtils.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlQueryUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlQueryUtils.java",
                "patch": "@@ -39,7 +39,6 @@\n import org.apache.stanbol.entityhub.servicesapi.model.rdf.RdfResourceEnum;\n import org.apache.stanbol.entityhub.servicesapi.query.Constraint;\n import org.apache.stanbol.entityhub.servicesapi.query.RangeConstraint;\n-import org.apache.stanbol.entityhub.servicesapi.query.ReferenceConstraint;\n import org.apache.stanbol.entityhub.servicesapi.query.TextConstraint;\n import org.apache.stanbol.entityhub.servicesapi.query.ValueConstraint;\n import org.apache.stanbol.entityhub.servicesapi.query.TextConstraint.PatternType;\n@@ -57,6 +56,9 @@\n  *\n  */\n public final class SparqlQueryUtils {\n+    \n+    private static final Logger log = LoggerFactory.getLogger(SparqlQueryUtils.class);\n+    \n     public static enum EndpointTypeEnum {\n         Standard,\n         Virtuoso,\n@@ -66,7 +68,6 @@\n \n     private static final String XSD_DATE_TIME = \"http://www.w3.org/2001/XMLSchema#dateTime\";\n     private static final DateFormat DATE_FORMAT = new W3CDateFormat();\n-    private static final Logger log = LoggerFactory.getLogger(SparqlQueryUtils.class);\n     private static final RdfValueFactory valueFavtory = RdfValueFactory.getInstance();\n     /**\n      * {@link UriRef} constant for {@link RdfResourceEnum#queryResult}\n@@ -650,7 +651,7 @@ private static void writeLanguagesFilter(StringBuilder queryString, Collection<S\n     }\n \n \n-    public static void main(String[] args) {\n+/*    public static void main(String[] args) {\n         SparqlFieldQuery query = SparqlFieldQueryFactory.getInstance().createFieldQuery();\n         query.setConstraint(\"urn:field1\", new ReferenceConstraint(\"urn:testReference\"));\n         query.setConstraint(\"urn:field1a\", new ValueConstraint(null, Arrays.asList(\n@@ -686,7 +687,7 @@ public static void main(String[] args) {\n         System.out.println(createSparqlSelectQuery(query,true,0,EndpointTypeEnum.Standard));\n         System.out.println();\n         System.out.println(createSparqlConstructQuery(query,0,EndpointTypeEnum.Virtuoso));\n-    }\n+    }*/\n \n     /**\n      * @param query",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/query/clerezza/src/main/java/org/apache/stanbol/entityhub/query/clerezza/SparqlQueryUtils.java",
                "sha": "db61f4832d7e761e1971844aacdab1fb6c9f4b93",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/pom.xml",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/pom.xml?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 8,
                "filename": "entityhub/site/linkedData/pom.xml",
                "patch": "@@ -63,9 +63,6 @@\n            <Private-Package>\n               org.apache.stanbol.entityhub.site.linkedData.impl;version=${pom.version},\n             </Private-Package>\n-             <Embed-Dependency> <!-- TODO: remove as soon as possible -->\n-              json\n-            </Embed-Dependency>\n            </instructions>\n         </configuration>\n       </plugin>\n@@ -121,11 +118,11 @@\n       <scope>provided</scope>\n     </dependency>\n     <dependency>\n-      <groupId>org.json</groupId>\n-      <artifactId>json</artifactId>\n-      <version>20090211</version>\n-    </dependency>    \n-     <dependency>\n+      <groupId>org.codehaus.jettison</groupId>\n+      <artifactId>jettison</artifactId>\n+      <version>1.2</version>\n+    </dependency>\n+    <dependency>\n       <groupId>commons-io</groupId>\n       <artifactId>commons-io</artifactId>\n       <version>1.4</version>",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/pom.xml",
                "sha": "ed3e1c887bed742ddec8cd978c73d59cc36cbab7",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/CoolUriDereferencer.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/CoolUriDereferencer.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/CoolUriDereferencer.java",
                "patch": "@@ -45,7 +45,7 @@\n         )\n public class CoolUriDereferencer extends AbstractEntityDereferencer implements EntityDereferencer{\n     @Reference\n-    protected Parser parser;\n+    private Parser parser;\n \n     private final RdfValueFactory valueFactory = RdfValueFactory.getInstance();\n \n@@ -55,7 +55,7 @@ public CoolUriDereferencer(){\n     }\n \n     @Override\n-    public InputStream dereference(String uri, String contentType) throws IOException{\n+    public final InputStream dereference(String uri, String contentType) throws IOException{\n         if(uri!=null){\n             final URL url = new URL(uri);\n             final URLConnection con = url.openConnection();\n@@ -67,7 +67,7 @@ public InputStream dereference(String uri, String contentType) throws IOExceptio\n     }\n \n     @Override\n-    public Representation dereference(String uri) throws IOException{\n+    public final Representation dereference(String uri) throws IOException{\n         long start = System.currentTimeMillis();\n         String format = SupportedFormat.RDF_XML;\n         InputStream in = dereference(uri, format);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/CoolUriDereferencer.java",
                "sha": "0722faacd8544f9cdd421cecf89620b55e3fd1ac",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/LarqSearcher.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/LarqSearcher.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/LarqSearcher.java",
                "patch": "@@ -52,10 +52,10 @@ public LarqSearcher() {\n         super(LoggerFactory.getLogger(LarqSearcher.class));\n     }\n     @Reference\n-    protected Parser parser;\n+    private Parser parser;\n \n     @Override\n-    public QueryResultList<Representation> find(FieldQuery parsedQuery) throws IOException {\n+    public final QueryResultList<Representation> find(FieldQuery parsedQuery) throws IOException {\n         long start = System.currentTimeMillis();\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n         query.setEndpointType(EndpointTypeEnum.LARQ);\n@@ -83,7 +83,7 @@ public LarqSearcher() {\n     }\n \n     @Override\n-    public QueryResultList<String> findEntities(FieldQuery parsedQuery) throws IOException {\n+    public final QueryResultList<String> findEntities(FieldQuery parsedQuery) throws IOException {\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n         query.setEndpointType(EndpointTypeEnum.LARQ);\n         String sparqlQuery = query.toSparqlSelect(false);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/LarqSearcher.java",
                "sha": "5df530eb8602bdd90911096aed4de06d466a5a20",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlDereferencer.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlDereferencer.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlDereferencer.java",
                "patch": "@@ -55,7 +55,7 @@ public SparqlDereferencer(){\n     }\n \n     @Reference\n-    protected Parser parser;\n+    private Parser parser;\n \n \n     /*\n@@ -65,7 +65,7 @@ public SparqlDereferencer(){\n      * However it is not clear if such a functionality is needed.\n      */\n     @Override\n-    public InputStream dereference(String uri, String contentType) throws IOException {\n+    public final InputStream dereference(String uri, String contentType) throws IOException {\n         if(uri==null){\n             return null;\n         }\n@@ -81,7 +81,7 @@ public InputStream dereference(String uri, String contentType) throws IOExceptio\n         return SparqlEndpointUtils.sendSparqlRequest(getAccessUri(),query.toString(),contentType);\n     }\n \n-    public Representation dereference(String uri) throws IOException {\n+    public final Representation dereference(String uri) throws IOException {\n         long start = System.currentTimeMillis();\n         String format = SupportedFormat.RDF_XML;\n         InputStream in = dereference(uri, format);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlDereferencer.java",
                "sha": "28a1bb5ffa58186e4be6806b01a1f5fbc103a628",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlEndpointUtils.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlEndpointUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlEndpointUtils.java",
                "patch": "@@ -24,10 +24,10 @@\n \n import javax.ws.rs.core.UriBuilder;\n \n-public class SparqlEndpointUtils {\n+public final class SparqlEndpointUtils {\n+    private SparqlEndpointUtils() {/* Do not create instances of utility classes*/}\n \n     public static final String SPARQL_RESULT_JSON = \"application/sparql-results+json\";\n-    public SparqlEndpointUtils() {/* Do not create instances of utility classes*/}\n \n     /**\n      * Sends an SPARQL Request to the accessUri. Please note that based on the\n@@ -43,7 +43,7 @@ public static InputStream sendSparqlRequest(String accessUri, String query, Stri\n         final URI dereferenceUri = UriBuilder.fromUri(accessUri)\n             .queryParam(\"query\", \"{query}\")\n             .queryParam(\"format\", \"{format}\")\n-            .build(query.toString(), contentType);\n+            .build(query, contentType);\n         final URLConnection con = dereferenceUri.toURL().openConnection();\n         con.addRequestProperty(\"Accept\", contentType);\n         return con.getInputStream();",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlEndpointUtils.java",
                "sha": "8fb5bcb8521a76793d6a18ca0eb7e38af3aecb7d",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlSearcher.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlSearcher.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 6,
                "filename": "entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlSearcher.java",
                "patch": "@@ -40,9 +40,9 @@\n import org.apache.stanbol.entityhub.servicesapi.query.FieldQuery;\n import org.apache.stanbol.entityhub.servicesapi.query.QueryResultList;\n import org.apache.stanbol.entityhub.servicesapi.site.EntitySearcher;\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n+import org.codehaus.jettison.json.JSONArray;\n+import org.codehaus.jettison.json.JSONException;\n+import org.codehaus.jettison.json.JSONObject;\n import org.slf4j.LoggerFactory;\n \n \n@@ -59,12 +59,12 @@ public SparqlSearcher() {\n     }\n \n     @Reference\n-    protected Parser parser;\n+    private Parser parser;\n \n     protected static final String DEFAULT_RDF_CONTENT_TYPE = SupportedFormat.N3;\n     protected static final String DEFAULT_SPARQL_RESULT_CONTENT_TYPE = SparqlEndpointUtils.SPARQL_RESULT_JSON;\n     @Override\n-    public QueryResultList<String> findEntities(FieldQuery parsedQuery)  throws IOException {\n+    public final QueryResultList<String> findEntities(FieldQuery parsedQuery)  throws IOException {\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n         String sparqlQuery = query.toSparqlSelect(false);\n         InputStream in = SparqlEndpointUtils.sendSparqlRequest(getQueryUri(), sparqlQuery, DEFAULT_SPARQL_RESULT_CONTENT_TYPE);\n@@ -116,7 +116,7 @@ public SparqlSearcher() {\n     }\n \n     @Override\n-    public QueryResultList<Representation> find(FieldQuery parsedQuery) throws IOException{\n+    public final QueryResultList<Representation> find(FieldQuery parsedQuery) throws IOException{\n         long start = System.currentTimeMillis();\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n         String sparqlQuery = query.toSparqlConstruct();",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/SparqlSearcher.java",
                "sha": "368173e177e374900b1d3273978c10a4af518cd2",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/VirtuosoSearcher.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/VirtuosoSearcher.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/VirtuosoSearcher.java",
                "patch": "@@ -48,14 +48,14 @@\n         )\n public class VirtuosoSearcher extends AbstractEntitySearcher implements EntitySearcher{\n     @Reference\n-    protected Parser parser;\n+    private Parser parser;\n \n     public VirtuosoSearcher() {\n         super(LoggerFactory.getLogger(VirtuosoSearcher.class));\n     }\n \n     @Override\n-    public QueryResultList<Representation> find(FieldQuery parsedQuery) throws IOException {\n+    public final QueryResultList<Representation> find(FieldQuery parsedQuery) throws IOException {\n         long start = System.currentTimeMillis();\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n         query.setEndpointType(EndpointTypeEnum.Virtuoso);\n@@ -83,7 +83,7 @@ public VirtuosoSearcher() {\n     }\n \n     @Override\n-    public QueryResultList<String> findEntities(FieldQuery parsedQuery) throws IOException {\n+    public final QueryResultList<String> findEntities(FieldQuery parsedQuery) throws IOException {\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n         query.setEndpointType(EndpointTypeEnum.Virtuoso);\n         String sparqlQuery = query.toSparqlSelect(false);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/site/linkedData/src/main/java/org/apache/stanbol/entityhub/site/linkedData/impl/VirtuosoSearcher.java",
                "sha": "08ee94c08b80f9a4e0f11d2927866f6d388d26a8",
                "status": "modified"
            },
            {
                "additions": 57,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "changes": 111,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 54,
                "filename": "entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "patch": "@@ -56,7 +56,7 @@\n import org.apache.stanbol.entityhub.core.yard.SimpleYardConfig;\n import org.apache.stanbol.entityhub.model.clerezza.RdfRepresentation;\n import org.apache.stanbol.entityhub.model.clerezza.RdfValueFactory;\n-import org.apache.stanbol.entityhub.model.clerezza.utils.Resource2StringAdapter;\n+import org.apache.stanbol.entityhub.model.clerezza.impl.Resource2StringAdapter;\n import org.apache.stanbol.entityhub.query.clerezza.RdfQueryResultList;\n import org.apache.stanbol.entityhub.query.clerezza.SparqlFieldQuery;\n import org.apache.stanbol.entityhub.query.clerezza.SparqlFieldQueryFactory;\n@@ -99,7 +99,7 @@\n //        @Property(name=Yard.DESCRIPTION,value=\"Default values for configuring the Entityhub Yard without editing\")\n //})\n public class ClerezzaYard extends AbstractYard implements Yard {\n-    Logger log = LoggerFactory.getLogger(ClerezzaYard.class);\n+    private static Logger log = LoggerFactory.getLogger(ClerezzaYard.class);\n     /**\n      * Property used to mark empty Representations managed by this Graph. This is\n      * needed to workaround the fact, that the Entityhub supports the storage of\n@@ -113,11 +113,11 @@\n      * <code> ?representationId <{@value #MANAGED_REPRESENTATION}> true^^xsd:boolean </code>\n      * <br> for any empty Representation avoids this unwanted behaviour.\n      */\n-    public static UriRef MANAGED_REPRESENTATION = new UriRef(\"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:managesRepresentation\");\n+    public static final UriRef MANAGED_REPRESENTATION = new UriRef(\"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:managesRepresentation\");\n     /**\n      * The TRUE value used as object for the property {@link #MANAGED_REPRESENTATION}.\n      */\n-    private static Literal TRUE_LITERAL = LiteralFactory.getInstance().createTypedLiteral(Boolean.FALSE);\n+    private static final Literal TRUE_LITERAL = LiteralFactory.getInstance().createTypedLiteral(Boolean.FALSE);\n     //public static final String YARD_URI_PREFIX = \"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:\";\n //    public static final UriRef REPRESENTATION = new UriRef(RdfResourceEnum.Representation.getUri());\n //    protected ComponentContext context;\n@@ -136,7 +136,7 @@ public ClerezzaYard(YardConfig config) {\n     }\n     @SuppressWarnings(\"unchecked\")\n     @Activate\n-    protected void activate(ComponentContext context) throws ConfigurationException {\n+    protected final void activate(ComponentContext context) throws ConfigurationException {\n         log.info(\"in \"+ClerezzaYard.class+\" activate with context \"+context);\n         if(context == null || context.getProperties() == null){\n             throw new IllegalStateException(\"No valid\"+ComponentContext.class+\" parsed in activate!\");\n@@ -149,10 +149,10 @@ protected void activate(ComponentContext context) throws ConfigurationException\n      * Method. In case the Yard runs outside of an OSGI Container it is called\n      * by the Constructor taking the {@link YardConfig} as parameter\n      * @param config The configuration for the new Yard instance\n-     * @throws NullPointerException In case <code>null</code> is parsed as configuration\n-     * @throws IllegalArgumentException In case the configuration is invalid\n+     * @throws IllegalArgumentException In case <code>null</code> is parsed as \n+     * configuration or the configuration is invalid\n      */\n-    private final void activate(YardConfig config) throws IllegalArgumentException, NullPointerException {\n+    private final void activate(YardConfig config) throws IllegalArgumentException {\n         super.activate(RdfValueFactory.getInstance(), SparqlFieldQueryFactory.getInstance(), config);\n         if(tcManager == null){ //this will be the case if we are not in an OSGI environment\n           //use the getInstance() method!\n@@ -171,7 +171,7 @@ private final void activate(YardConfig config) throws IllegalArgumentException,\n \n     }\n     @Deactivate\n-    protected void deactivate(ComponentContext context) {\n+    protected final void deactivate(ComponentContext context) {\n         log.info(\"in \"+ClerezzaYard.class.getSimpleName()+\" deactivate with context \"+context);\n         this.yardGraphUri = null;\n         this.graph = null;\n@@ -183,14 +183,14 @@ protected void deactivate(ComponentContext context) {\n      * @return the URI used for the RDF graph that stores all the data of this\n      * yard.\n      */\n-    public String getYardGraphUri(){\n+    public final String getYardGraphUri(){\n         return yardGraphUri.getUnicodeString();\n     }\n \n     @Override\n     public Representation getRepresentation(String id) {\n         if(id == null){\n-            throw new NullPointerException(\"The parsed representation id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed representation id MUST NOT be NULL!\");\n         }\n         if(id.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed representation id MUST NOT be EMTPY!\");\n@@ -204,7 +204,7 @@ public Representation getRepresentation(String id) {\n      *     refers to a Resource in the graph that is of type {@link #REPRESENTATION}\n      * @return the Representation\n      */\n-    protected Representation getRepresentation(UriRef uri, boolean check) {\n+    protected final Representation getRepresentation(UriRef uri, boolean check) {\n         Lock readLock = graph.getLock().readLock();\n         readLock.lock();\n         try {\n@@ -214,7 +214,7 @@ protected Representation getRepresentation(UriRef uri, boolean check) {\n                 // ... this will only remove the triple if the Representation is empty\n                 //     but a check would take longer than the this call\n                 nodeGraph.remove(new TripleImpl(uri,MANAGED_REPRESENTATION,TRUE_LITERAL));\n-                return ((RdfValueFactory)valueFactory).createRdfRepresentation(uri, nodeGraph);\n+                return ((RdfValueFactory)getValueFactory()).createRdfRepresentation(uri, nodeGraph);\n             } else {\n                 return null; //not found\n             }\n@@ -265,7 +265,7 @@ private MGraph extractRepresentation(TripleCollection source,MGraph target, NonL\n     @Override\n     public boolean isRepresentation(String id) {\n         if(id == null) {\n-            throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed id MUST NOT be NULL!\");\n         }\n         if(id.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed id MUST NOT be EMPTY!\");\n@@ -278,14 +278,14 @@ public boolean isRepresentation(String id) {\n      * @param resource the resource to check\n      * @return the state\n      */\n-    protected boolean isRepresentation(UriRef resource){\n+    protected final boolean isRepresentation(UriRef resource){\n         return graph.filter(resource, null, null).hasNext();\n     }\n \n     @Override\n     public void remove(String id) throws IllegalArgumentException {\n         if(id == null) {\n-            throw new NullPointerException(\"The parsed Representation id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be NULL!\");\n         }\n         UriRef resource = new UriRef(id);\n         Lock writeLock = graph.getLock().writeLock();\n@@ -299,9 +299,9 @@ public void remove(String id) throws IllegalArgumentException {\n         }\n     }\n     @Override\n-    public void remove(Iterable<String> ids) throws IllegalArgumentException, YardException {\n+    public final void remove(Iterable<String> ids) throws IllegalArgumentException, YardException {\n         if(ids == null){\n-            throw new NullPointerException(\"The parsed Iterable over the IDs to remove MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Iterable over the IDs to remove MUST NOT be NULL!\");\n         }\n         for(String id : ids){\n             if(id != null){\n@@ -310,24 +310,30 @@ public void remove(Iterable<String> ids) throws IllegalArgumentException, YardEx\n         }\n     }\n     @Override\n-    public Representation store(Representation representation) throws IllegalArgumentException, YardException {\n+    public final Representation store(Representation representation) throws IllegalArgumentException, YardException {\n+        if(representation == null){\n+            throw new IllegalArgumentException(\"The parsed Representation MUST NOT be NULL!\");\n+        }\n         return store(representation,true,true);\n     }\n     @Override\n-    public Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException {\n+    public final Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException {\n         if(representations == null){\n-            throw new NullPointerException(\"The parsed Iterable over the Representations to store MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Iterable over the Representations to store MUST NOT be NULL!\");\n         }\n         return store(representations, true);\n     }\n     @Override\n-    public Representation update(Representation representation) throws IllegalArgumentException, YardException {\n+    public final Representation update(Representation representation) throws IllegalArgumentException, YardException {\n+        if(representation == null){\n+            throw new IllegalArgumentException(\"The parsed Representation MUST NOT be NULL!\");\n+        }\n         return store(representation,false,true);\n     }\n     @Override\n-    public Iterable<Representation> update(Iterable<Representation> representations) throws YardException, IllegalArgumentException {\n+    public final Iterable<Representation> update(Iterable<Representation> representations) throws YardException, IllegalArgumentException {\n         if(representations == null){\n-            throw new NullPointerException(\"The parsed Iterable over the Representations to update MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Iterable over the Representations to update MUST NOT be NULL!\");\n         }\n         return store(representations,false);\n     }\n@@ -350,7 +356,9 @@ public Representation update(Representation representation) throws IllegalArgume\n     protected final Representation store(Representation representation,boolean allowCreate,boolean canNotCreateIsError) throws IllegalArgumentException, YardException{\n         log.info(\"store Representation \"+representation.getId());\n //        log.info(\"  > entityhub size: \"+graph.size());\n-        if(representation == null) return null;\n+        if(representation == null) {\n+            return null;\n+        }\n         if(isRepresentation(representation.getId())){\n //            log.info(\"  > remove previous version\");\n             remove(representation.getId());\n@@ -363,7 +371,7 @@ protected final Representation store(Representation representation,boolean allow\n             }\n         }\n         //get the graph for the Representation and add it to the store\n-        RdfRepresentation toAdd = ((RdfValueFactory)valueFactory).toRdfRepresentation(representation);\n+        RdfRepresentation toAdd = ((RdfValueFactory)getValueFactory()).toRdfRepresentation(representation);\n //        log.info(\"  > add \"+toAdd.size()+\" triples to Yard \"+getId());\n         Lock writeLock = graph.getLock().writeLock();\n         writeLock.lock();\n@@ -388,23 +396,7 @@ protected final Representation store(Representation representation,boolean allow\n             throw new IllegalArgumentException(\"The parsed query MUST NOT be NULL!\");\n         }\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n-        int limit = QueryUtils.getLimit(query, config.getDefaultQueryResultNumber(), config.getMaxQueryResultNumber());\n-        SelectQuery sparqlQuery;\n-        String sparqlQueryString = SparqlQueryUtils.createSparqlSelectQuery(query, false,limit,EndpointTypeEnum.Standard);\n-        try {\n-            sparqlQuery = (SelectQuery)QueryParser.getInstance().parse(sparqlQueryString);\n-        } catch (ParseException e) {\n-            log.error(\"ParseException for SPARQL Query in findRepresentation\");\n-            log.error(\"FieldQuery: \"+query);\n-            log.error(\"SPARQL Query: \"+sparqlQueryString);\n-            throw new YardException(\"Unable to parse SPARQL query generated for the parse FieldQuery\",e);\n-        } catch (ClassCastException e){\n-            log.error(\"ClassCastExeption because parsed SPARQL Query is not of Type \"+SelectQuery.class);\n-            log.error(\"FieldQuery: \"+query);\n-            log.error(\"SPARQL Query: \"+sparqlQueryString);\n-            throw new YardException(\"Unable to parse SPARQL SELECT query generated for the parse FieldQuery\",e);\n-        }\n-        final ResultSet result = tcManager.executeSparqlQuery((SelectQuery)sparqlQuery, graph);\n+        final ResultSet result = executeSparqlFieldQuery(query);\n         //A little bit complex construct ...\n         // first we use the adaptingIterator to convert reseource to string\n         // to get the resources we have to retrieve the root-variable of the\n@@ -419,13 +411,16 @@ protected final Representation store(Representation representation,boolean allow\n                 new Resource2StringAdapter<Resource>(), String.class);\n         return new QueryResultListImpl<String>(query,representationIdIterator,String.class);\n     }\n-    @Override\n-    public QueryResultList<Representation> findRepresentation(FieldQuery parsedQuery) throws YardException, IllegalArgumentException {\n-        if(parsedQuery == null){\n-            throw new IllegalArgumentException(\"The parsed query MUST NOT be NULL!\");\n-        }\n-        final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n-        int limit = QueryUtils.getLimit(query, config.getDefaultQueryResultNumber(), config.getMaxQueryResultNumber());\n+    /**\n+     * Returns the SPARQL result set for a given {@link SparqlFieldQuery} that\n+     * was executed on this yard\n+     * @param query the SparqlFieldQuery instance\n+     * @return the results of the SPARQL query in the yard\n+     * @throws YardException in case the generated SPARQL query could not be parsed\n+     * or the generated Query is not an SPARQL SELECT query.\n+     */\n+    private ResultSet executeSparqlFieldQuery(final SparqlFieldQuery query) throws YardException {\n+        int limit = QueryUtils.getLimit(query, getConfig().getDefaultQueryResultNumber(), getConfig().getMaxQueryResultNumber());\n         SelectQuery sparqlQuery;\n         String sparqlQueryString = SparqlQueryUtils.createSparqlSelectQuery(query, false,limit,EndpointTypeEnum.Standard);\n         try {\n@@ -441,7 +436,15 @@ protected final Representation store(Representation representation,boolean allow\n             log.error(\"SPARQL Query: \"+sparqlQueryString);\n             throw new YardException(\"Unable to parse SPARQL SELECT query generated for the parse FieldQuery\",e);\n         }\n-        final ResultSet result = tcManager.executeSparqlQuery((SelectQuery)sparqlQuery, graph);\n+        return tcManager.executeSparqlQuery((SelectQuery)sparqlQuery, graph);\n+    }\n+    @Override\n+    public QueryResultList<Representation> findRepresentation(FieldQuery parsedQuery) throws YardException, IllegalArgumentException {\n+        if(parsedQuery == null){\n+            throw new IllegalArgumentException(\"The parsed query MUST NOT be NULL!\");\n+        }\n+        final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n+        final ResultSet result = executeSparqlFieldQuery(query);\n         //Note: An other possibility would be to first iterate over all results and add it to\n         //      a list and create this Iterator than based on the List. This would\n         //      be the preferenced way if changes in the graph could affect the\n@@ -459,7 +462,7 @@ protected final Representation store(Representation representation,boolean allow\n                     @Override\n                     public Representation adapt(SolutionMapping solution, Class<Representation> type) {\n                         Resource resource = solution.get(query.getRootVariableName());\n-                        if(resource != null && resource instanceof UriRef){\n+                        if(resource instanceof UriRef){\n                             try {\n                                 return getRepresentation((UriRef)resource,false);\n                             } catch (IllegalArgumentException e) {\n@@ -477,12 +480,12 @@ public Representation adapt(SolutionMapping solution, Class<Representation> type\n         return new QueryResultListImpl<Representation>(query,representationIterator,Representation.class);\n     }\n     @Override\n-    public QueryResultList<Representation> find(FieldQuery parsedQuery) throws YardException, IllegalArgumentException {\n+    public final QueryResultList<Representation> find(FieldQuery parsedQuery) throws YardException, IllegalArgumentException {\n         if(parsedQuery == null){\n             throw new IllegalArgumentException(\"The parsed query MUST NOT be NULL!\");\n         }\n         final SparqlFieldQuery query = SparqlFieldQueryFactory.getSparqlFieldQuery(parsedQuery);\n-        int limit = QueryUtils.getLimit(query, config.getDefaultQueryResultNumber(), config.getMaxQueryResultNumber());\n+        int limit = QueryUtils.getLimit(query, getConfig().getDefaultQueryResultNumber(), getConfig().getMaxQueryResultNumber());\n         Query sparqlQuery;\n         //NOTE(s):\n         // - parse RdfResourceEnum.representationType as additional field, because",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "sha": "9d12eacde39d8f155d86a00553d4b0b6f05cbe4c",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java",
                "patch": "@@ -29,7 +29,6 @@\n import org.apache.stanbol.entityhub.servicesapi.yard.YardException;\n import org.apache.stanbol.entityhub.test.yard.YardTest;\n import org.junit.AfterClass;\n-import org.junit.Before;\n import org.junit.BeforeClass;\n import org.junit.Test;\n ",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java",
                "sha": "87e68b9f2703a801cf7b8dc3436029d80f64bff8",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/defaults/SolrConst.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/defaults/SolrConst.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/defaults/SolrConst.java",
                "patch": "@@ -24,7 +24,8 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class SolrConst {\n+public final class SolrConst {\n+    private SolrConst(){}\n     /**\n      * Char used to mark special fields. Special fields are internally used\n      * fields that do not represent a value that was present in the original",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/defaults/SolrConst.java",
                "sha": "d64602c243107af7f758f701082e875724ee8a90",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/embedded/EmbeddedSolrPorovider.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/embedded/EmbeddedSolrPorovider.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/embedded/EmbeddedSolrPorovider.java",
                "patch": "@@ -81,7 +81,7 @@\n      * requested paths.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected Map<String, CoreContainer> coreContainers = new ReferenceMap(); \n+    private Map<String, CoreContainer> coreContainers = new ReferenceMap(); \n     \n     @Property\n     public static final String SOLR_HOME = \"solr.solr.home\";\n@@ -101,7 +101,7 @@ public EmbeddedSolrPorovider() {\n     public SolrServer getSolrServer(Type type, String uriOrPath, String... additional) throws NullPointerException, IllegalArgumentException {\n         log.debug(String.format(\"getSolrServer Request for %s and path %s\",type,uriOrPath));\n         if(uriOrPath == null){\n-            throw new NullPointerException(\"The Path to the Index MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The Path to the Index MUST NOT be NULL!\");\n         }\n         File index = new File(uriOrPath);\n         if(!index.exists()){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/embedded/EmbeddedSolrPorovider.java",
                "sha": "fa1820d9f0c3c43a759291e2f8fd960d34ea5d00",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/DefaultSolrServerProvider.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/DefaultSolrServerProvider.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/DefaultSolrServerProvider.java",
                "patch": "@@ -50,7 +50,7 @@\n     @Override\n     public SolrServer getSolrServer(Type type, String uriOrPath, String... additional) throws NullPointerException, IllegalArgumentException {\n         if(uriOrPath == null){\n-            throw new NullPointerException(\"The parsed SolrServer URI MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed SolrServer URI MUST NOT be NULL!\");\n         }\n         if(type == null){\n             type = Type.HTTP;",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/DefaultSolrServerProvider.java",
                "sha": "ea85ef24640964e5bb9c97a69484ac86b149bf67",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrFieldMapper.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrFieldMapper.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrFieldMapper.java",
                "patch": "@@ -19,7 +19,6 @@\n import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.DEPENDENT_DOCUMENT_FIELD;\n import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.DOCUMENT_ID_FIELD;\n import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.DOMAIN_FIELD;\n-import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.LANG_MERGER_FIELD;\n import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.PATH_SEPERATOR;\n import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.REFERRED_DOCUMENT_FIELD;\n import static org.apache.stanbol.entityhub.yard.solr.defaults.SolrConst.SPECIAL_CONFIG_FIELD;\n@@ -65,7 +64,7 @@\n  */\n public class SolrFieldMapper implements FieldMapper {\n \n-    Logger log = LoggerFactory.getLogger(SolrFieldMapper.class);\n+    private static Logger log = LoggerFactory.getLogger(SolrFieldMapper.class);\n     /**\n      * Char used to separate the prefix from the local name of uri's\n      */\n@@ -85,6 +84,10 @@\n     private static final IndexField scoreField = new IndexField(\n             Collections.singletonList(RdfResourceEnum.resultScore.getUri()),\n             IndexDataTypeEnum.FLOAT.getIndexType());\n+    /**\n+     * The Solr Server of this FieldMapper\n+     */\n+    protected final SolrServer server;\n     /**\n      * Internally used as LRU Cache with {@link SolrFieldMapper#LRU_MAPPINGS_CACHE_SIZE}\n      * elements. This subclass of {@link LinkedHashMap} overrides the\n@@ -115,17 +118,16 @@ protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n      * them again and again.\n      * @see LinkedHashMap#\n      */\n-    private final LinkedHashMap<IndexField, Collection<String>> indexFieldMappings =\n+    private final LRU<IndexField, Collection<String>> indexFieldMappings =\n         new LRU<IndexField, Collection<String>>();\n     /**\n      * The assumption is, that only a handful of fields appear in index documents.\n      * So it makes sense to keep some mappings within a cache rather than calculating\n      * them again and again.\n      */\n-    private final LinkedHashMap<String, IndexField> fieldMappings =\n+    private final LRU<String, IndexField> fieldMappings =\n         new LRU<String, IndexField>();\n \n-    protected final SolrServer server;\n     public SolrFieldMapper(SolrServer server){\n         if(server == null){\n             throw new IllegalArgumentException(\"The parsed SolrServer MUST NOT be NULL\");",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrFieldMapper.java",
                "sha": "ccf34c3ca7c365e8083f56c9651b43c41138f63d",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrQueryFactory.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrQueryFactory.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 6,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrQueryFactory.java",
                "patch": "@@ -96,15 +96,15 @@\n      * The default limit of results for queries\n      */\n     public static final Integer DEFAULT_QUERY_RESULTS = 10;\n-    protected final Logger log = LoggerFactory.getLogger(SolrQueryFactory.class);\n+    private final Logger log = LoggerFactory.getLogger(SolrQueryFactory.class);\n     private final FieldMapper fieldMapper;\n     private final IndexValueFactory indexValueFactory;\n     private final ValueFactory valueFactory;\n-    protected final Map<IndexConstraintTypeEnum, IndexConstraintTypeEncoder<?>> constraintEncoders;\n+    private final Map<IndexConstraintTypeEnum, IndexConstraintTypeEncoder<?>> constraintEncoders;\n \n-    protected String domain;\n-    protected Integer maxQueryResults = MAX_QUERY_RESULTS;\n-    protected Integer defaultQueryResults = DEFAULT_QUERY_RESULTS;\n+    private String domain;\n+    private Integer maxQueryResults = MAX_QUERY_RESULTS;\n+    private Integer defaultQueryResults = DEFAULT_QUERY_RESULTS;\n \n     public SolrQueryFactory(ValueFactory valueFactory, IndexValueFactory indexValueFactory, FieldMapper fieldMapper){\n         if(fieldMapper == null){\n@@ -230,7 +230,7 @@ private void initIndexConstraint(IndexConstraint indexConstraint, RangeConstrain\n             if(dataType == null){\n                 dataType = upperDataType;\n             } else {\n-                if(dataType != upperDataType){\n+                if(!dataType.equals(upperDataType)){\n                     indexConstraint.setInvalied(String.format(\"A Range Query MUST use the same data type for the upper and lover Bound! (lower:[value=%s|datatype=%s] | upper:[value=%s|datatype=%s])\",\n                             rangeConstraint.getLowerBound(),dataType,rangeConstraint.getUpperBound(),upperDataType));\n                 }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrQueryFactory.java",
                "sha": "a4434e8c02c0b1475eb9be301b1ee07cc9d97d01",
                "status": "modified"
            },
            {
                "additions": 47,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrYard.java",
                "changes": 89,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrYard.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 42,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrYard.java",
                "patch": "@@ -190,7 +190,7 @@\n      * {@link Representation} to fields in the {@link SolrInputDocument} and\n      * vice versa\n      */\n-    protected FieldMapper fieldMapper;\n+    private FieldMapper fieldMapper;\n     /**\n      * The {@link IndexValueFactory} is responsible for converting values of\n      * fields in the {@link Representation} to the according {@link IndexValue}.\n@@ -200,7 +200,7 @@\n      * the {@link SolrInputDocument} and {@link SolrDocument}. This is done by\n      * the configured {@link FieldMapper}.\n      */\n-    protected IndexValueFactory indexValueFactory;\n+    private IndexValueFactory indexValueFactory;\n     /**\n      * The {@link SolrQueryFactory} is responsible for converting the\n      * {@link Constraint}s of a query to constraints in the index. This requires\n@@ -264,7 +264,7 @@ public SolrYard(SolrYardConfig config) throws IllegalArgumentException, YardExce\n     }\n     @SuppressWarnings(\"unchecked\")\n     @Activate\n-    protected void activate(ComponentContext context) throws ConfigurationException,IOException,SolrServerException {\n+    protected final void activate(ComponentContext context) throws ConfigurationException,IOException,SolrServerException {\n         log.info(\"in \"+SolrYard.class+\" activate with context \"+context);\n         if(context == null){\n             throw new IllegalStateException(\"No valid\"+ComponentContext.class+\" parsed in activate!\");\n@@ -282,36 +282,39 @@ protected void activate(ComponentContext context) throws ConfigurationException,\n     private void activate(SolrYardConfig config) throws ConfigurationException,IOException,SolrServerException {\n         //init with the default implementations of the ValueFactory and the QueryFactory\n         super.activate(InMemoryValueFactory.getInstance(), DefaultQueryFactory.getInstance(), config);\n+        //mayby the super activate has updated the configuration\n+        config = (SolrYardConfig) this.getConfig();\n         if(solrServerProviderManager == null){ //not within an OSGI environment\n             solrServerProviderManager = SolrServerProviderManager.getInstance();\n         }\n         server = solrServerProviderManager.getSolrServer(\n-            ((SolrYardConfig)this.config).getSolrServerType(), \n-            ((SolrYardConfig)this.config).getSolrServerLocation().toString());\n+            config.getSolrServerType(), \n+            config.getSolrServerLocation().toString());\n         //test the server\n         SolrPingResponse pingResponse = server.ping();\n         log.info(String.format(\"Successful ping for SolrServer %s ( %d ms) Details: %s\",config.getSolrServerLocation(),pingResponse.getElapsedTime(),pingResponse));\n         //the fieldMapper need the Server to store it's namespace prefix configuration\n         this.fieldMapper = new SolrFieldMapper(server);\n         this.indexValueFactory = IndexValueFactory.getInstance();\n-        this.solrQueryFactoy = new SolrQueryFactory(valueFactory, indexValueFactory, fieldMapper);\n-        if(((SolrYardConfig)this.config).isMultiYardIndexLayout()){ // set the yardID as domain if multiYardLayout is activated\n+        this.solrQueryFactoy = new SolrQueryFactory(getValueFactory(), indexValueFactory, fieldMapper);\n+        if(config.isMultiYardIndexLayout()){ // set the yardID as domain if multiYardLayout is activated\n             solrQueryFactoy.setDomain(config.getId());\n         }\n-        solrQueryFactoy.setDefaultQueryResults(this.config.getDefaultQueryResultNumber());\n-        solrQueryFactoy.setMaxQueryResults(this.config.getMaxQueryResultNumber());\n+        solrQueryFactoy.setDefaultQueryResults(config.getDefaultQueryResultNumber());\n+        solrQueryFactoy.setMaxQueryResults(config.getMaxQueryResultNumber());\n         this.documentBoostFieldName = config.getDocumentBoostFieldName();\n         this.fieldBoostMap = config.getFieldBoosts();\n     }\n     @Deactivate\n-    protected void deactivate(ComponentContext context) {\n+    protected final void deactivate(ComponentContext context) {\n         log.info(\"in \"+SolrYard.class+\" deactivate with context \"+context);\n+        SolrYardConfig config = (SolrYardConfig)getConfig();\n         try {\n             this.server.commit();\n         } catch (SolrServerException e) {\n-            log.error(String.format(\"Unable to commit unsaved changes to SolrServer %s during deactivate!\",((SolrYardConfig)this.config).getSolrServerLocation()),e);\n+            log.error(String.format(\"Unable to commit unsaved changes to SolrServer %s during deactivate!\",config.getSolrServerLocation()),e);\n         } catch (IOException e) {\n-            log.error(String.format(\"Unable to commit unsaved changes to SolrServer %s during deactivate!\",((SolrYardConfig)this.config).getSolrServerLocation()),e);\n+            log.error(String.format(\"Unable to commit unsaved changes to SolrServer %s during deactivate!\",config.getSolrServerLocation()),e);\n         }\n         this.server = null;\n         this.fieldMapper = null;\n@@ -324,7 +327,7 @@ protected void deactivate(ComponentContext context) {\n \n \n     @Override\n-    public QueryResultList<Representation> find(final FieldQuery parsedQuery) throws YardException{\n+    public final QueryResultList<Representation> find(final FieldQuery parsedQuery) throws YardException{\n         return find(parsedQuery,SELECT.QUERY);\n     }\n     private QueryResultList<Representation> find(final FieldQuery parsedQuery,SELECT select) throws YardException {\n@@ -368,7 +371,7 @@ public Representation adapt(SolrDocument doc, Class<Representation> type) {\n     }\n \n     @Override\n-    public QueryResultList<String> findReferences(FieldQuery parsedQuery) throws YardException {\n+    public final QueryResultList<String> findReferences(FieldQuery parsedQuery) throws YardException {\n         SolrQuery query = solrQueryFactoy.parseFieldQuery(parsedQuery,SELECT.ID);\n         QueryResponse respone;\n         try {\n@@ -391,14 +394,14 @@ public String adapt(SolrDocument doc, Class<String> type) {\n     }\n \n     @Override\n-    public QueryResultList<Representation> findRepresentation(FieldQuery parsedQuery) throws YardException {\n+    public final QueryResultList<Representation> findRepresentation(FieldQuery parsedQuery) throws YardException {\n         return find(parsedQuery,SELECT.ALL);\n     }\n \n     @Override\n-    public Representation getRepresentation(String id) throws YardException {\n+    public final Representation getRepresentation(String id) throws YardException {\n         if(id == null){\n-            throw new NullPointerException(\"The parsed Representation id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be NULL!\");\n         }\n         if(id.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be empty!\");\n@@ -432,14 +435,14 @@ public Representation getRepresentation(String id) throws YardException {\n      * @param fields if NOT NULL only this fields are added to the Representation\n      * @return the Representation\n      */\n-    protected Representation createRepresentation(SolrDocument doc, Set<String> fields) {\n+    protected final Representation createRepresentation(SolrDocument doc, Set<String> fields) {\n         Object id = doc.getFirstValue(fieldMapper.getDocumentIdField());\n         if(id == null){\n             throw new IllegalStateException(\n                     String.format(\"The parsed Solr Document does not contain a value for the %s Field!\",\n                             fieldMapper.getDocumentIdField()));\n         }\n-        Representation rep = valueFactory.createRepresentation(id.toString());\n+        Representation rep = getValueFactory().createRepresentation(id.toString());\n         for(String fieldName : doc.getFieldNames()){\n //            log.debug(String.format(\" > process SolrDocument.field: %s\",fieldName));\n             IndexField indexField = fieldMapper.getField(fieldName);\n@@ -480,9 +483,9 @@ protected Representation createRepresentation(SolrDocument doc, Set<String> fiel\n \n \n     @Override\n-    public boolean isRepresentation(String id) throws YardException {\n+    public final boolean isRepresentation(String id) throws YardException {\n         if(id == null){\n-            throw new NullPointerException(\"The parsed Representation id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be NULL!\");\n         }\n         if(id.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be empty!\");\n@@ -503,7 +506,7 @@ public boolean isRepresentation(String id) throws YardException {\n      * @throws SolrServerException on any exception of the SolrServer\n      * @throws IOException an any IO exception while accessing the SolrServer\n      */\n-    protected Set<String> checkRepresentations(Set<String> ids) throws SolrServerException, IOException{\n+    protected final Set<String> checkRepresentations(Set<String> ids) throws SolrServerException, IOException{\n         Set<String> found = new HashSet<String>();\n         String field = fieldMapper.getDocumentIdField();\n         for(SolrDocument foundDoc : getSolrDocuments(ids,Arrays.asList(field))){\n@@ -516,9 +519,9 @@ public boolean isRepresentation(String id) throws YardException {\n     }\n \n     @Override\n-    public void remove(String id) throws YardException, IllegalArgumentException {\n+    public final void remove(String id) throws YardException, IllegalArgumentException {\n         if(id == null){\n-            throw new NullPointerException(\"The parsed Representation id MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be NULL!\");\n         }\n         if(id.isEmpty()){\n             throw new IllegalArgumentException(\"The parsed Representation id MUST NOT be empty!\");\n@@ -537,9 +540,9 @@ public void remove(String id) throws YardException, IllegalArgumentException {\n         //      the entity still exists and might be referenced by others!\n     }\n     @Override\n-    public void remove(Iterable<String> ids) throws IllegalArgumentException, YardException {\n+    public final void remove(Iterable<String> ids) throws IllegalArgumentException, YardException {\n         if(ids == null){\n-            throw new NullPointerException(\"The parsed IDs MUST NOT be NULL\");\n+            throw new IllegalArgumentException(\"The parsed IDs MUST NOT be NULL\");\n         }\n         List<String> toRemove = new ArrayList<String>();\n         for(String id :ids){\n@@ -561,10 +564,10 @@ public void remove(Iterable<String> ids) throws IllegalArgumentException, YardEx\n         //      the entity still exists and might be referenced by others!\n     }\n     @Override\n-    public Representation store(Representation representation) throws YardException,IllegalArgumentException {\n+    public final Representation store(Representation representation) throws YardException,IllegalArgumentException {\n         log.debug(String.format(\"Store %s\",representation!= null?representation.getId():null));\n         if(representation == null){\n-            throw new NullPointerException(\"The parsed Representation MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representation MUST NOT be NULL!\");\n         }\n         long start = System.currentTimeMillis();\n         SolrInputDocument inputDocument = createSolrInputDocument(representation);\n@@ -583,9 +586,9 @@ public Representation store(Representation representation) throws YardException,\n         return representation;\n     }\n     @Override\n-    public Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException {\n+    public final Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException {\n         if(representations == null){\n-            throw new NullPointerException(\"The parsed Representations MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representations MUST NOT be NULL!\");\n         }\n         Collection<Representation> added = new HashSet<Representation>();\n         long start = System.currentTimeMillis();\n@@ -615,11 +618,12 @@ public Representation store(Representation representation) throws YardException,\n      * @param representation\n      * @return\n      */\n-    protected SolrInputDocument createSolrInputDocument(Representation representation) {\n+    protected final SolrInputDocument createSolrInputDocument(Representation representation) {\n+        SolrYardConfig config = (SolrYardConfig)getConfig();\n         SolrInputDocument inputDocument = new SolrInputDocument();\n         // If multiYardLayout is active, than we need to add the YardId as\n         // domain for all added documents!\n-        if(((SolrYardConfig)this.config).isMultiYardIndexLayout()){\n+        if(config.isMultiYardIndexLayout()){\n             inputDocument.addField(fieldMapper.getDocumentDomainField(), config.getId());\n         } // else we need to do nothing\n         inputDocument.addField(fieldMapper.getDocumentIdField(), representation.getId());\n@@ -675,9 +679,9 @@ private float getDocumentBoost(Representation representation) {\n     }\n \n     @Override\n-    public Representation update(Representation representation) throws IllegalArgumentException, NullPointerException, YardException {\n+    public final Representation update(Representation representation) throws IllegalArgumentException, NullPointerException, YardException {\n         if(representation == null){\n-            throw new NullPointerException(\"The parsed Representation MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Representation MUST NOT be NULL!\");\n         }\n         boolean found  = isRepresentation(representation.getId());\n         if(found) {\n@@ -687,9 +691,9 @@ public Representation update(Representation representation) throws IllegalArgume\n         }\n     }\n     @Override\n-    public Iterable<Representation> update(Iterable<Representation> representations) throws YardException, IllegalArgumentException, NullPointerException {\n+    public final Iterable<Representation> update(Iterable<Representation> representations) throws YardException, IllegalArgumentException, NullPointerException {\n         if(representations == null){\n-            throw new NullPointerException(\"The parsed Iterable over Representations MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Iterable over Representations MUST NOT be NULL!\");\n         }\n         long start = System.currentTimeMillis();\n         Set<String> ids = new HashSet<String>();\n@@ -738,7 +742,7 @@ public Representation update(Representation representation) throws IllegalArgume\n      * the index\n      * @param inputDoc the document to store\n      */\n-    protected void storeSolrDocument(SolrInputDocument inputDoc) throws SolrServerException, IOException{\n+    protected final void storeSolrDocument(SolrInputDocument inputDoc) throws SolrServerException, IOException{\n         server.add(inputDoc);\n     }\n     /**\n@@ -747,10 +751,11 @@ protected void storeSolrDocument(SolrInputDocument inputDoc) throws SolrServerEx\n      * the index\n      * @param inputDoc the document to store\n      */\n-    public SolrDocument getSolrDocument(String uri) throws SolrServerException, IOException {\n+    public final SolrDocument getSolrDocument(String uri) throws SolrServerException, IOException {\n         return getSolrDocument(uri, null);\n     }\n-    protected Collection<SolrDocument> getSolrDocuments(Collection<String> uris,Collection<String> fields) throws SolrServerException, IOException {\n+    protected final Collection<SolrDocument> getSolrDocuments(Collection<String> uris,Collection<String> fields) throws SolrServerException, IOException {\n+        SolrYardConfig config = (SolrYardConfig)getConfig();\n         SolrQuery solrQuery = new SolrQuery();\n         if(fields == null || fields.isEmpty()){\n             solrQuery.addField(\"*\"); //select all fields\n@@ -765,7 +770,7 @@ public SolrDocument getSolrDocument(String uri) throws SolrServerException, IOEx\n         //      clauses in one query, than we need to send several requests!\n         Iterator<String> uriIterator = uris.iterator();\n         int maxClauses;\n-        Integer configuredMaxClauses = ((SolrYardConfig)config).getMaxBooleanClauses();\n+        Integer configuredMaxClauses = config.getMaxBooleanClauses();\n         if(configuredMaxClauses != null && configuredMaxClauses > 0){\n             maxClauses = configuredMaxClauses;\n         } else {\n@@ -802,7 +807,7 @@ public SolrDocument getSolrDocument(String uri) throws SolrServerException, IOEx\n             if(resultDocs == null){\n                 resultDocs = queryResponse.getResults();\n             } else {\n-                if(myList == false){\n+                if(!myList){\n                     //most of the time there will be only one request, so only\n                     //create my own list when the second response is processed\n                     resultDocs = new ArrayList<SolrDocument>(resultDocs);\n@@ -813,7 +818,7 @@ public SolrDocument getSolrDocument(String uri) throws SolrServerException, IOEx\n         } //end while more uris\n         return resultDocs;\n     }\n-    protected SolrDocument getSolrDocument(String uri,Collection<String> fields) throws SolrServerException, IOException {\n+    protected final SolrDocument getSolrDocument(String uri,Collection<String> fields) throws SolrServerException, IOException {\n         SolrQuery solrQuery = new SolrQuery();\n         if(fields == null || fields.isEmpty()){\n             solrQuery.addField(\"*\"); //select all fields",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/SolrYard.java",
                "sha": "538ef41fdc488ebe405c469b88e586e92a26db6a",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/DataTypeEncoder.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/DataTypeEncoder.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/DataTypeEncoder.java",
                "patch": "@@ -40,8 +40,8 @@\n \n     private static final ConstraintTypePosition PREFIX = new ConstraintTypePosition(PositionType.prefix);\n     private static final ConstraintTypePosition SUFFIX = new ConstraintTypePosition(PositionType.suffux);\n-    protected final FieldMapper fieldMapper;\n-    protected final IndexValueFactory indexValueFactory;\n+    private final FieldMapper fieldMapper;\n+    private final IndexValueFactory indexValueFactory;\n     public DataTypeEncoder(IndexValueFactory indexValueFactory, FieldMapper fieldMapper) {\n         if(fieldMapper == null){\n             throw new IllegalArgumentException(\"The FieldMapper MUST NOT be NULL!\");",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/DataTypeEncoder.java",
                "sha": "e91c89a3c23c39eb03302ad75c305729d2ab3332",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/LangEncoder.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/LangEncoder.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 3,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/LangEncoder.java",
                "patch": "@@ -19,9 +19,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n \n-import org.apache.stanbol.entityhub.servicesapi.defaults.NamespaceEnum;\n import org.apache.stanbol.entityhub.yard.solr.model.FieldMapper;\n-import org.apache.stanbol.entityhub.yard.solr.model.IndexDataType;\n import org.apache.stanbol.entityhub.yard.solr.query.ConstraintTypePosition;\n import org.apache.stanbol.entityhub.yard.solr.query.EncodedConstraintParts;\n import org.apache.stanbol.entityhub.yard.solr.query.IndexConstraintTypeEncoder;\n@@ -33,7 +31,7 @@\n public class LangEncoder implements IndexConstraintTypeEncoder<Collection<String>> {\n \n     private static final ConstraintTypePosition PREFIX = new ConstraintTypePosition(PositionType.prefix);\n-    private static final ConstraintTypePosition SUFFIX = new ConstraintTypePosition(PositionType.suffux);\n+//    private static final ConstraintTypePosition SUFFIX = new ConstraintTypePosition(PositionType.suffux);\n     //deactivated, because xsd:string values are now also included in the language\n     //merger field (the name returned by fieldMapper.getLanguageMergerField(null)).\n     //private static final IndexDataType STRING_DATATYPE =  new IndexDataType(NamespaceEnum.xsd+\"string\");",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/impl/queryencoders/LangEncoder.java",
                "sha": "6bbfcca7ca3249d7bc271540cda847575541a10d",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/FieldMapper.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/FieldMapper.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/FieldMapper.java",
                "patch": "@@ -35,7 +35,7 @@\n  * while indexing data.<p>\n  * The three encode** methods are used to encode query constraints.<p>\n  * Implementations are encouraged to cache mappings, because typically there will\n- * be manny request with similar parameters.\n+ * be many request with similar parameters.\n  * @author Rupert Westenthaler.\n  */\n public interface FieldMapper {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/FieldMapper.java",
                "sha": "dca9eee75dfc513d4424f5e5a9328c242dba8822",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexDataType.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexDataType.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 10,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexDataType.java",
                "patch": "@@ -64,19 +64,21 @@ public IndexDataType(String id) {\n     public IndexDataType(String id,String name) {\n         this.id = id;\n         if(name == null){\n-            if(id.lastIndexOf(\"#\")>=0){\n-                name = id.substring(id.lastIndexOf(\"#\")+1);\n-            } else if(id.lastIndexOf(\"/\")>=0){\n-                name = id.substring(id.lastIndexOf(\"/\")+1);\n-            } else if(id.lastIndexOf(\":\")>=0){\n-                name = id.substring(id.lastIndexOf(\":\")+1);\n+            String defaultName;\n+            if(id.lastIndexOf('#')>=0){\n+                defaultName = id.substring(id.lastIndexOf('#')+1);\n+            } else if(id.lastIndexOf('/')>=0){\n+                defaultName = id.substring(id.lastIndexOf('/')+1);\n+            } else if(id.lastIndexOf(':')>=0){\n+                defaultName = id.substring(id.lastIndexOf(':')+1);\n             } else {\n-                name = id;\n+                defaultName = id;\n             }\n             //convert first char to lower case\n-            name = name.substring(0,1).toLowerCase()+name.substring(1);\n+            this.name = defaultName.substring(0,1).toLowerCase()+defaultName.substring(1);\n+        } else {\n+            this.name = name;\n         }\n-        this.name = name;\n     }\n     /**\n      * Getter for the prefix\n@@ -99,7 +101,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof IndexDataType && ((IndexDataType)obj).id.equals(id);\n+        return obj instanceof IndexDataType && ((IndexDataType)obj).id.equals(id);\n     }\n     /**\n      * Returns the id of the dataType. Use {@link #getName()} if you need a",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexDataType.java",
                "sha": "17277ab79b59be257334ffcee7e83c4270e35da4",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexField.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexField.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 4,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexField.java",
                "patch": "@@ -44,7 +44,7 @@\n     private final List<String> path;\n     private final IndexDataType indexType;\n     private final Set<String> languages;\n-    private final int _hash;\n+    private final int hash;\n     /**\n      * Constructs a new IndexField\n      * @param path\n@@ -76,7 +76,7 @@ public IndexField(List<String> path, IndexDataType indexType, String...languages\n             this.languages = Collections.unmodifiableSet(languageSet);\n         }\n         //calculate the hash of is immutable class only once\n-        _hash = this.path.hashCode()+this.indexType.hashCode()+this.languages.hashCode();\n+        hash = this.path.hashCode()+this.indexType.hashCode()+this.languages.hashCode();\n     }\n     /**\n      * Checks if the path is not <code>null</code>, empty and does not contain\n@@ -127,14 +127,14 @@ public final boolean hasLanguage(){\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof IndexField &&\n+        return obj instanceof IndexField &&\n             ((IndexField)obj).path.equals(path) &&\n             ((IndexField)obj).indexType.equals(indexType) &&\n             ((IndexField)obj).languages.equals(languages);\n     }\n     @Override\n     public int hashCode() {\n-        return _hash;\n+        return hash;\n     }\n     @Override\n     public String toString() {",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexField.java",
                "sha": "4fc6a462af45104834d0fdbf98c547c1905be3db",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValue.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValue.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValue.java",
                "patch": "@@ -25,7 +25,7 @@\n     /**\n      * Calculate the hash only once\n      */\n-    private final int _hash;\n+    private final int hash;\n \n     public IndexValue(String value,IndexDataType type){\n         this(value,type,null,false);\n@@ -49,7 +49,7 @@ private IndexValue(String value,IndexDataType type,String language,boolean hasLa\n         } else {\n             this.language = null;\n         }\n-        this._hash= type.hashCode()+value.hashCode()+(language!=null?language.hashCode():0);\n+        this.hash = type.hashCode()+value.hashCode()+(language!=null?language.hashCode():0);\n     }\n     public final String getValue(){\n         return value;\n@@ -65,12 +65,11 @@ public final boolean hasLanguage(){\n     }\n     @Override\n     public int hashCode() {\n-        return _hash;\n+        return hash;\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null &&\n-            obj instanceof IndexValue &&\n+        return obj instanceof IndexValue &&\n             ((IndexValue)obj).value.equals(value) &&\n             ((IndexValue)obj).type.equals(type) &&\n             ((IndexValue)obj).hasLanguage == hasLanguage && (",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValue.java",
                "sha": "373bf45cc90f037b667e1bad6c67d57acf8b71e0",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValueFactory.java",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValueFactory.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 23,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValueFactory.java",
                "patch": "@@ -115,11 +115,11 @@ public void registerConverter(TypeConverter<?> converter){\n             //NOTE: To ensure thread save iterations over Entries of this Map\n             //create new map instance, add to the new instance and replace reference\n             // ... i know this is slow, but such calls are very uncommon\n-            Map<Class<?>,TypeConverter<?>> javaInterfaceConverters =\n+            Map<Class<?>,TypeConverter<?>> javaInterfaceConverterMap =\n                 new HashMap<Class<?>,TypeConverter<?>>(this.javaInterfaceConverters);\n-            javaInterfaceConverters.put(javaType,converter);\n+            javaInterfaceConverterMap.put(javaType,converter);\n             //TODO: add support for IndexTypeConverter\n-            this.javaInterfaceConverters = javaInterfaceConverters;\n+            this.javaInterfaceConverters = javaInterfaceConverterMap;\n         } else {\n             //there are no Iterations over this Map!\n             javaClassConverters.put(javaType,converter);\n@@ -139,10 +139,10 @@ public void registerConverter(TypeConverter<?> converter){\n             if(javaInterfaceConverters.containsKey(type)){\n                 //create new map instance, remove to the converter and replace reference\n                 // ... i know this is slow, but such calls are very uncommon\n-                Map<Class<?>,TypeConverter<?>> javaInterfaceConverters =\n+                Map<Class<?>,TypeConverter<?>> javaInterfaceConverterMap =\n                     new HashMap<Class<?>,TypeConverter<?>>(this.javaInterfaceConverters);\n-                converter = (TypeConverter<T>)javaInterfaceConverters.remove(type);\n-                this.javaInterfaceConverters = javaInterfaceConverters;\n+                converter = (TypeConverter<T>)javaInterfaceConverterMap.remove(type);\n+                this.javaInterfaceConverters = javaInterfaceConverterMap;\n             } else {\n                 converter = null;\n             }\n@@ -271,7 +271,7 @@ public IndexDataType getIndexType(){\n         @Override\n         public Date createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(!type.equals(INDEX_TYPE)) {\n                 throw new UnsupportedIndexTypeException(this,type);\n@@ -333,7 +333,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Boolean createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(!type.equals(INDEX_TYPE)){\n                 throw new UnsupportedIndexTypeException(this,type);\n@@ -394,7 +394,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public String createObject(IndexDataType type, Object value, String lang) throws NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             return value!=null?value.toString():null;\n         }\n@@ -442,7 +442,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Integer createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(type.equals(INDEX_TYPE)){\n                 if(value == null){ //move in here to ensure returning UnsupportedIndexTypeException on wrong types\n@@ -452,7 +452,7 @@ public Integer createObject(IndexDataType type, Object value, String lang) throw\n                     return (Integer)value;\n                 } else {\n                     try {\n-                        return new Integer(value.toString());\n+                        return Integer.valueOf(value.toString());\n                     } catch (NumberFormatException e) {\n                         throw new UnsupportedValueException(this, type, value, e);\n                     }\n@@ -516,7 +516,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Long createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException,NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(type.equals(LONG_TYPE) || type.equals(INT_TYPE)){\n                 if(value == null){\n@@ -542,7 +542,7 @@ public Long createObject(IndexDataType type, Object value, String lang) throws U\n     public static class DoubleConverter implements TypeConverter<Double> {\n \n         public static final IndexDataType INDEX_TYPE = IndexDataTypeEnum.DOUBLE.getIndexType();\n-        private static Set<IndexDataType> SUPPORTED = new HashSet<IndexDataType>(\n+        private static final Set<IndexDataType> SUPPORTED = new HashSet<IndexDataType>(\n                 Arrays.asList(\n                         IndexDataTypeEnum.FLOAT.getIndexType(),\n                         IndexDataTypeEnum.INT.getIndexType(),\n@@ -576,7 +576,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Double createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(SUPPORTED.contains(type)){\n                 if(value == null){\n@@ -616,7 +616,7 @@ public FloatConverter(boolean acceptDoubleAndLongIndexType){\n         public boolean isAcceptDoubleAndLongIndexTypes(){\n             return supported.containsAll(DOUBLE_LONG_TYPES);\n         }\n-        public void setAcceptDoubleAndLongIndexTypes(boolean state){\n+        public final void setAcceptDoubleAndLongIndexTypes(boolean state){\n             if(state){\n                 supported.addAll(DOUBLE_LONG_TYPES);\n             } else {\n@@ -649,7 +649,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Float createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null) {\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(supported.contains(type)){\n                 if(value == null){\n@@ -703,7 +703,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public BigInteger createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(type.equals(INDEX_TYPE) || type.equals(INT_TYPE)){\n                 if(value == null){\n@@ -722,7 +722,7 @@ public BigInteger createObject(IndexDataType type, Object value, String lang) th\n     public static class BigDecimalConverter implements TypeConverter<BigDecimal> {\n \n         public static final IndexDataType INDEX_TYPE = IndexDataTypeEnum.DOUBLE.getIndexType();\n-        private static Set<IndexDataType> SUPPORTED = new HashSet<IndexDataType>(\n+        private static final Set<IndexDataType> SUPPORTED = new HashSet<IndexDataType>(\n                 Arrays.asList(\n                         IndexDataTypeEnum.FLOAT.getIndexType(),\n                         IndexDataTypeEnum.INT.getIndexType(),\n@@ -744,7 +744,7 @@ public BigDecimal createObject(IndexValue value) {\n         @Override\n         public BigDecimal createObject(IndexDataType type,Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(SUPPORTED.contains(type)){\n                 if(value == null){\n@@ -773,7 +773,7 @@ public IndexDataType getIndexType() {\n \n         public static final IndexDataType INDEX_TYPE = IndexDataTypeEnum.TXT.getIndexType();\n         private static final IndexDataType STRING_TYPE = IndexDataTypeEnum.STR.getIndexType();\n-        protected final ValueFactory valueFactory;\n+        private final ValueFactory valueFactory;\n         public TextConverter(ValueFactory valueFactory) {\n             if(valueFactory == null){\n                 throw new IllegalArgumentException(\"Parameter ValueFactory MUST NOT be NULL!\");\n@@ -805,7 +805,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Text createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null){\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(type.equals(INDEX_TYPE) || type.equals(STRING_TYPE)){\n                 if(value == null){\n@@ -819,7 +819,7 @@ public Text createObject(IndexDataType type, Object value, String lang) throws U\n     }\n     public static class ReferenceConverter implements TypeConverter<Reference> {\n         public static final IndexDataType INDEX_TYPE = IndexDataTypeEnum.REF.getIndexType();\n-        protected final ValueFactory valueFactory;\n+        private final ValueFactory valueFactory;\n         public ReferenceConverter(ValueFactory valueFactory) {\n             if(valueFactory == null){\n                 throw new IllegalArgumentException(\"Parameter ValueFactory MUST NOT be NULL!\");\n@@ -851,7 +851,7 @@ public IndexDataType getIndexType() {\n         @Override\n         public Reference createObject(IndexDataType type, Object value, String lang) throws UnsupportedIndexTypeException, UnsupportedValueException, NullPointerException {\n             if(type == null) {\n-                throw new NullPointerException(\"The parsed IndexDataType MUST NOT be null\");\n+                throw new IllegalArgumentException(\"The parsed IndexDataType MUST NOT be null\");\n             }\n             if(type.equals(INDEX_TYPE)){\n                 if(value == null){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/model/IndexValueFactory.java",
                "sha": "92dd89482ac2453afaff08c8264cedfc98b20471",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProvider.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProvider.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 5,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProvider.java",
                "patch": "@@ -77,10 +77,10 @@\n      * ignored if the requested type does not support the usage of multiple\n      * servers.\n      * @return the configured SolrServer client for the parsed parameter\n-     * @throws NullPointerException if <code>null</code> is parsed as uriOrPath.\n-     * @throws IllegalArgumentException if the parsed URI or path is not valid\n-     * for the requested {@link Type} or the parsed type is not supported by\n-     * this provider\n+     * @throws NullPointerException \n+     * @throws IllegalArgumentException if <code>null</code> is parsed as uriOrPath\n+     * or if the parsed URI or path is not valid for the requested {@link Type} \n+     * or the parsed type is not supported by this provider\n      */\n-    SolrServer getSolrServer(Type type,String uriOrPath,String...additional) throws NullPointerException,IllegalArgumentException;\n+    SolrServer getSolrServer(Type type,String uriOrPath,String...additional) throws IllegalArgumentException;\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProvider.java",
                "sha": "f3ed526d8a2ab18f6e40089ad7aa62665d0ee15c",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProviderManager.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProviderManager.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProviderManager.java",
                "patch": "@@ -64,7 +64,7 @@\n         policy=ReferencePolicy.DYNAMIC,\n         cardinality=ReferenceCardinality.MANDATORY_MULTIPLE,\n         bind=\"addSolrProvider\",unbind=\"removeSolrProvider\")\n-    protected Map<Type,List<SolrServerProvider>> solrServerProviders = Collections.synchronizedMap(new EnumMap<Type,List<SolrServerProvider>>(Type.class));\n+    private Map<Type,List<SolrServerProvider>> solrServerProviders = Collections.synchronizedMap(new EnumMap<Type,List<SolrServerProvider>>(Type.class));\n \n     public static SolrServerProviderManager getInstance(){\n         if(solrServerProviderManager == null){",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/provider/SolrServerProviderManager.java",
                "sha": "fca206b2c747cfc05ee1ccf938dc291ee2de3f32",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/ConstraintTypePosition.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/ConstraintTypePosition.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/ConstraintTypePosition.java",
                "patch": "@@ -71,7 +71,7 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof ConstraintTypePosition\n+        return obj instanceof ConstraintTypePosition\n             && ((ConstraintTypePosition)obj).type == type && ((ConstraintTypePosition)obj).pos == pos;\n     }\n     @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/ConstraintTypePosition.java",
                "sha": "0088f5c8725ebd17d9564893cada6c4147994660",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/EncodedConstraintParts.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/EncodedConstraintParts.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 1,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/EncodedConstraintParts.java",
                "patch": "@@ -87,6 +87,6 @@ public int hashCode() {\n     }\n     @Override\n     public boolean equals(Object obj) {\n-        return obj != null && obj instanceof EncodedConstraintParts && ((EncodedConstraintParts)obj).constraintMap.equals(constraintMap);\n+        return obj instanceof EncodedConstraintParts && ((EncodedConstraintParts)obj).constraintMap.equals(constraintMap);\n     }\n }",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/query/EncodedConstraintParts.java",
                "sha": "bbedd1db90c25ac55638dd5aef9a4ade77132c23",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/ConfigUtils.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/ConfigUtils.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 9,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/ConfigUtils.java",
                "patch": "@@ -19,14 +19,10 @@\n import java.io.File;\n import java.io.IOException;\n import java.net.URL;\n-import java.util.Arrays;\n import java.util.Enumeration;\n \n import org.apache.commons.io.FileUtils;\n-import org.apache.solr.client.solrj.SolrServer;\n-import org.apache.solr.client.solrj.SolrServerException;\n import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;\n-import org.apache.solr.client.solrj.request.CoreAdminRequest;\n import org.apache.stanbol.entityhub.yard.solr.embedded.EmbeddedSolrPorovider;\n import org.osgi.framework.Bundle;\n import org.slf4j.Logger;\n@@ -42,7 +38,8 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public class ConfigUtils {\n+public final class ConfigUtils {\n+    private ConfigUtils(){}\n     /**\n      * The logger\n      */\n@@ -75,10 +72,10 @@\n     @SuppressWarnings(\"unchecked\") //Enumeration<URL> required by OSGI specification\n     public static File copyDefaultConfig(Bundle bundle, File rootDir,boolean override) throws IOException, NullPointerException, IllegalStateException, IllegalArgumentException {\n         if(bundle == null){\n-            throw new NullPointerException(\"The parsed Bundle MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Bundle MUST NOT be NULL!\");\n         }\n         if(rootDir == null){\n-            throw new NullPointerException(\"The parsed root directory MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed root directory MUST NOT be NULL!\");\n         }\n         if(rootDir.exists() && !rootDir.isDirectory()){\n             throw new IllegalStateException(\"The parsed root directory \"+rootDir.getAbsolutePath()+\" extists but is not a directory!\");\n@@ -156,10 +153,10 @@ private static void copyResource(File rootDir, URL resource, String context, boo\n     @SuppressWarnings(\"unchecked\") //Enumeration<URL> required by OSGI specification\n     public static void copyCore(Bundle bundle, File coreDir, String coreName, boolean override) throws IOException,NullPointerException,IllegalStateException,IllegalArgumentException{\n         if(bundle == null){\n-            throw new NullPointerException(\"The parsed Bundle MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed Bundle MUST NOT be NULL!\");\n         }\n         if(coreDir == null){\n-            throw new NullPointerException(\"The parsed core directory MUST NOT be NULL!\");\n+            throw new IllegalArgumentException(\"The parsed core directory MUST NOT be NULL!\");\n         }\n         if(coreDir.exists() && !coreDir.isDirectory()){\n             throw new IllegalStateException(\"The parsed core directory \"+coreDir.getAbsolutePath()+\" extists but is not a directory!\");",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/ConfigUtils.java",
                "sha": "aa3dcd858811a055face8bfa7d277fb247ecab5a",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/SolrUtil.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/SolrUtil.java?ref=596fc271b9f615868102b02e8da5bf408732f69d",
                "deletions": 2,
                "filename": "entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/SolrUtil.java",
                "patch": "@@ -19,8 +19,8 @@\n import java.util.regex.Pattern;\n \n \n-public class SolrUtil {\n-\n+public final class SolrUtil {\n+    private SolrUtil(){}\n \n     private static final String LUCENE_ESCAPE_CHARS = \"[\\\\\\\\+\\\\-\\\\!\\\\(\\\\)\\\\:\\\\^\\\\[\\\\]\\\\{\\\\}\\\\~\\\\*\\\\?]\";\n     private static final Pattern LUCENE_PATTERN = Pattern.compile(LUCENE_ESCAPE_CHARS);",
                "raw_url": "https://github.com/apache/stanbol/raw/596fc271b9f615868102b02e8da5bf408732f69d/entityhub/yard/solr/src/main/java/org/apache/stanbol/entityhub/yard/solr/utils/SolrUtil.java",
                "sha": "da24ddd9a98ec4d6fc71ca350deb8004a066daa7",
                "status": "modified"
            }
        ],
        "message": "Code cleanups base on Sonar violation drilldown and hotspots. \nAlso organised imports and replaced different used JSON libs with Jettison.\n\nThere are several changes in unit tests because of switching to throw IllegalArgumentException instead of NullPointerExceptions in cases where NULL is parsed for parameters that do not allow null values. Such changes are also reflected in the Java doc of the affected Interfaces.\n\nExcluded form this cleanups are:\n - \"Cyclomatic Complexity\" because it is not good to mix cleanups with refactoring and because dealing with this would require a lot more time.\n - Test coverage\n - Documentation\n \n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/stanbol/trunk@1082257 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/75af86ab274362baa8112195ec642165338fca59",
        "patched_files": [
            "PatternUtils.java",
            "SymbolResource.java",
            "TypeSaveIterator.java",
            "RdfIndexerConfig.java",
            "EntityhubConfigurationImpl.java",
            "DefaultEntityMappingImpl.java",
            "Literal2TextAdapter.java",
            "InMemoryRepresentation.java",
            "SparqlSearcher.java",
            "ConfigUtils.java",
            "Resource2StringAdapter.java",
            "RdfQueryResultList.java",
            "CacheUtils.java",
            "SolrFieldMapper.java",
            "RdfValueFactory.java",
            "SolrServerProviderManager.java",
            "EntityMappingResource.java",
            "Yard.java",
            "DataTypeEncoder.java",
            "IndexField.java",
            "AbstractEntityDereferencer.java",
            "RdfReference.java",
            "ToStringIterator.java",
            "AdaptingIterator.java",
            "OsgiUtils.java",
            "ValueConstraint.java",
            "SparqlDereferencer.java",
            "FieldMapper.java",
            "FieldMapping.java",
            "JerseyEndpoint.java",
            "UriRef2ReferenceAdapter.java",
            "LangEncoder.java",
            "IndexValueFactory.java",
            "GeoNamesIndexer.java",
            "TimeUtils.java",
            "JettisonWriter.java",
            "Utils.java",
            "FilteringIterator.java",
            "FieldQueryImpl.java",
            "InMemoryValueFactory.java",
            "FieldMappingUtils.java",
            "NamespaceEnum.java",
            "RdfResourceEnum.java",
            "ReferencedSiteRootResource.java",
            "AbstractYard.java",
            "SignToRDF.java",
            "QueryResultListImpl.java",
            "list.xml",
            "SparqlEndpointUtils.java",
            "EntityMapping.java",
            "LiteralAdapter.java",
            "SolrConst.java",
            "SolrUtil.java",
            "IndexValue.java",
            "YardManagerImpl.java",
            "ConstraintTypePosition.java",
            "SolrServerProvider.java",
            "ReferenceManagerImpl.java",
            "SiteManagerRootResource.java",
            "TextIterator.java",
            "DataTypeEnum.java",
            "CacheImpl.java",
            "RdfRepresentation.java",
            "DefaultSignImpl.java",
            "JSONToFieldQuery.java",
            "QueryUtils.java",
            "SparqlFieldQuery.java",
            "VirtuosoSearcher.java",
            "NavigationMixin.java",
            "NaturalTextFilter.java",
            "EncodedConstraintParts.java",
            "ReferencedSiteImpl.java",
            "UriRefAdapter.java",
            "LarqSearcher.java",
            "CoolUriDereferencer.java",
            "SolrYard.java",
            "ValueConverterFactory.java",
            "CommandLineRunner.java",
            "SolrQueryFactory.java",
            "RdfResourceUtils.java",
            "QueryResultListWriter.java",
            "Symbol.java",
            "RdfText.java",
            "DefaultSolrServerProvider.java",
            "RdfIndexer.java",
            "EntityhubImpl.java",
            "ModelUtils.java",
            "pom.xml",
            "IndexDataType.java",
            "Representation.java",
            "JerseyEndpointApplication.java",
            "AbstractEntitySearcher.java",
            "SparqlQueryUtils.java",
            "Resource2ValueAdapter.java",
            "EmbeddedSolrPorovider.java",
            "ClerezzaYard.java",
            "ValueFactory.java",
            "DefaultFieldMapperImpl.java",
            "DefaultSymbolImpl.java",
            "SignWriter.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "ValueFactoryTest.java",
            "InMemoryValueFactoryTest.java",
            "InMemoryRepresentationTest.java",
            "RdfRepresentationTest.java",
            "RdfValueFactoryTest.java",
            "ClerezzaYardTest.java",
            "SolrYardTest.java",
            "RepresentationTest.java",
            "YardTest.java"
        ]
    },
    "stanbol_6ccd695": {
        "bug_id": "stanbol_6ccd695",
        "commit": "https://github.com/apache/stanbol/commit/6ccd695abf41d9648f643779464f03912a2f46f7",
        "file": [
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/stanbol/blob/6ccd695abf41d9648f643779464f03912a2f46f7/enhancement-engines/topic/engine/src/main/java/org/apache/stanbol/enhancer/engine/topic/TopicClassificationEngine.java",
                "changes": 31,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancement-engines/topic/engine/src/main/java/org/apache/stanbol/enhancer/engine/topic/TopicClassificationEngine.java?ref=6ccd695abf41d9648f643779464f03912a2f46f7",
                "deletions": 10,
                "filename": "enhancement-engines/topic/engine/src/main/java/org/apache/stanbol/enhancer/engine/topic/TopicClassificationEngine.java",
                "patch": "@@ -306,6 +306,17 @@\n     @Reference(cardinality = ReferenceCardinality.OPTIONAL_UNARY, bind = \"bindManagedSolrServer\", unbind = \"unbindManagedSolrServer\", strategy = ReferenceStrategy.EVENT, policy = ReferencePolicy.DYNAMIC)\n     protected ManagedSolrServer managedSolrServerDummy; // trick to call the super class binders\n \n+    /**\n+     * Only used for testing outside an OSGI environment (see STANBOL-811: \n+     * the previously used {@link File#createTempFile(String, String)} does not\n+     * work on some Windows versions.\n+     */\n+    private File embeddedSolrServerDir;\n+\n+    void configureEmbeddedSolrServerDir(File directory){\n+        embeddedSolrServerDir = directory;\n+    }\n+    \n     @Activate\n     protected void activate(ComponentContext context) throws ConfigurationException, InvalidSyntaxException {\n         @SuppressWarnings(\"unchecked\")\n@@ -1025,11 +1036,7 @@ synchronized public int updatePerformanceEstimates(boolean incremental) throws C\n             throw new ClassifierException(\"Another evaluation is already running\");\n         }\n         int updatedTopics = 0;\n-        File tmpfolder = null;\n         try {\n-            tmpfolder = File.createTempFile(\"stanbol-evaluation-folder-\", \".tmp\");\n-            tmpfolder.delete();\n-            tmpfolder.mkdir();\n             evaluationRunning = true;\n             int cvFoldCount = 3; // 3-folds CV is hardcoded for now\n             int cvIterationCount = 3; // make it possible to limit the number of folds to use\n@@ -1038,9 +1045,10 @@ synchronized public int updatePerformanceEstimates(boolean incremental) throws C\n             // statistics are up to date\n             getTrainingSet().optimize();\n \n-            // TODO: make the temporary folder path configurable with a property\n+            // NOTE: The folder used to create the SolrServer used for CVFold\n+            //       is now created within the #embeddedSolrServerDir\n             for (int cvFoldIndex = 0; cvFoldIndex < cvIterationCount; cvFoldIndex++) {\n-                updatedTopics = performCVFold(tmpfolder, cvFoldIndex, cvFoldCount, cvIterationCount,\n+                updatedTopics = performCVFold(cvFoldIndex, cvFoldCount, cvIterationCount,\n                     incremental);\n             }\n             SolrServer solrServer = getActiveSolrServer();\n@@ -1052,14 +1060,12 @@ synchronized public int updatePerformanceEstimates(boolean incremental) throws C\n         } catch (SolrServerException e) {\n             throw new ClassifierException(e);\n         } finally {\n-            FileUtils.deleteQuietly(tmpfolder);\n             evaluationRunning = false;\n         }\n         return updatedTopics;\n     }\n \n-    protected int performCVFold(File tmpfolder,\n-                                int cvFoldIndex,\n+    protected int performCVFold(int cvFoldIndex,\n                                 int cvFoldCount,\n                                 int cvIterations,\n                                 boolean incremental) throws ConfigurationException,\n@@ -1079,7 +1085,12 @@ protected int performCVFold(File tmpfolder,\n                 classifier.activate(context, getCanonicalConfiguration(engineName + \"-evaluation\"));\n             } else {\n                 // non-OSGi runtime, need to do the setup manually\n-                EmbeddedSolrServer evaluationServer = EmbeddedSolrHelper.makeEmbeddedSolrServer(tmpfolder,\n+                File solrServerDir = new File(embeddedSolrServerDir,engineName + \"-evaluation\");\n+                if(solrServerDir.isDirectory()){\n+                    FileUtils.forceDelete(solrServerDir);\n+                }\n+                FileUtils.forceMkdir(solrServerDir);\n+                EmbeddedSolrServer evaluationServer = EmbeddedSolrHelper.makeEmbeddedSolrServer(solrServerDir,\n                     \"evaluationclassifierserver\", \"default-topic-model\", \"default-topic-model\");\n                 classifier.configure(getCanonicalConfiguration(evaluationServer));\n             }",
                "raw_url": "https://github.com/apache/stanbol/raw/6ccd695abf41d9648f643779464f03912a2f46f7/enhancement-engines/topic/engine/src/main/java/org/apache/stanbol/enhancer/engine/topic/TopicClassificationEngine.java",
                "sha": "949588d4acefc6b5689774b9f2bd76a546a7a42b",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/stanbol/blob/6ccd695abf41d9648f643779464f03912a2f46f7/enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TopicEngineTest.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TopicEngineTest.java?ref=6ccd695abf41d9648f643779464f03912a2f46f7",
                "deletions": 2,
                "filename": "enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TopicEngineTest.java",
                "patch": "@@ -122,7 +122,8 @@ public void setup() throws Exception {\n         classifierSolrServer = makeEmbeddedSolrServer(solrHome, \"classifierserver\", \"test-topic-model\",\n             \"default-topic-model\");\n         classifier = TopicClassificationEngine.fromParameters(getDefaultClassifierConfigParams());\n-\n+        //configure the directory used to create Embedded SolrServers for CVFold\n+        classifier.configureEmbeddedSolrServerDir(solrHome);\n         trainingSetSolrServer = makeEmbeddedSolrServer(solrHome, \"trainingsetserver\",\n             \"test-topic-trainingset\", \"default-topic-trainingset\");\n         trainingSet = new SolrTrainingSet();\n@@ -162,6 +163,7 @@ protected void loadSampleTopicsFromTSV() throws IOException, SolrServerException\n \n     @Test\n     public void testEngineConfiguration() throws ConfigurationException {\n+        log.info(\" --- testEngineConfiguration --- \");\n         Hashtable<String,Object> config = getDefaultClassifierConfigParams();\n         TopicClassificationEngine classifier = TopicClassificationEngine.fromParameters(config);\n         assertNotNull(classifier);\n@@ -199,6 +201,7 @@ public void testEngineConfiguration() throws ConfigurationException {\n \n     @Test\n     public void testImportModelFromSKOS() throws Exception {\n+        log.info(\" --- testImportModelFromSKOS --- \");\n         Parser parser = Parser.getInstance();\n         parser.bindParsingProvider(new JenaParserProvider());\n         Graph graph = parser.parse(getClass().getResourceAsStream(\"/sample-scheme.skos.rdf.xml\"),\n@@ -215,6 +218,7 @@ public void testImportModelFromSKOS() throws Exception {\n \n     @Test\n     public void testProgrammaticThesaurusConstruction() throws Exception {\n+        log.info(\" --- testProgrammaticThesaurusConstruction --- \");\n         // Register the roots of the taxonomy\n         classifier.addConcept(\"http://example.com/topics/root1\", null);\n         classifier.addConcept(\"http://example.com/topics/root2\", null);\n@@ -254,6 +258,7 @@ public void testProgrammaticThesaurusConstruction() throws Exception {\n \n     @Test\n     public void testEmptyIndexTopicClassification() throws Exception {\n+        log.info(\" --- testEmptyIndexTopicClassification --- \");\n         TopicClassificationEngine engine = TopicClassificationEngine\n                 .fromParameters(getDefaultClassifierConfigParams());\n         List<TopicSuggestion> suggestedTopics = engine.suggestTopics(\"This is a test.\");\n@@ -265,6 +270,7 @@ public void testEmptyIndexTopicClassification() throws Exception {\n     // to get updated to work with the new Solr schema + move the CSV import directly to the classifier or\n     // training set API\n     public void testTopicClassification() throws Exception {\n+        log.info(\" --- testTopicClassification --- \");\n         loadSampleTopicsFromTSV();\n         List<TopicSuggestion> suggestedTopics = classifier\n                 .suggestTopics(\"The Man Who Shot Liberty Valance is a 1962\"\n@@ -279,7 +285,7 @@ public void testTopicClassification() throws Exception {\n \n     @Test\n     public void testTrainClassifierFromExamples() throws Exception {\n-\n+        log.info(\" --- testTrainClassifierFromExamples --- \");\n         // mini taxonomy for news articles\n         String[] business = {\"urn:topics/business\", \"http://dbpedia.org/resource/Business\"};\n         String[] technology = {\"urn:topics/technology\", \"http://dbpedia.org/resource/Technology\"};\n@@ -410,6 +416,7 @@ public void testTrainClassifierFromExamples() throws Exception {\n \n     @Test\n     public void testUpdatePerformanceEstimates() throws Exception {\n+        log.info(\" --- testUpdatePerformanceEstimates --- \");\n         ClassificationReport performanceEstimates;\n         // no registered topic\n         try {\n@@ -453,6 +460,7 @@ public void testUpdatePerformanceEstimates() throws Exception {\n \n     @Test\n     public void testCrossValidation() throws Exception {\n+        log.info(\" --- testCrossValidation --- \");\n         // seed a pseudo random number generator for reproducible tests\n         Random rng = new Random(0);\n         ClassificationReport performanceEstimates;",
                "raw_url": "https://github.com/apache/stanbol/raw/6ccd695abf41d9648f643779464f03912a2f46f7/enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TopicEngineTest.java",
                "sha": "6b2127d152dc39c5523a540f61b402853b498d3e",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/stanbol/blob/6ccd695abf41d9648f643779464f03912a2f46f7/enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TrainingSetTest.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TrainingSetTest.java?ref=6ccd695abf41d9648f643779464f03912a2f46f7",
                "deletions": 0,
                "filename": "enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TrainingSetTest.java",
                "patch": "@@ -125,6 +125,7 @@ public void cleanupEmbeddedSolrServer() {\n \n     @Test\n     public void testDateSerialization() throws Exception {\n+        log.info(\" --- testDateSerialization --- \");\n         GregorianCalendar timeUtc = new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"));\n         timeUtc.set(2012, 23, 12, 06, 43, 00);\n         timeUtc.set(Calendar.MILLISECOND, 0);\n@@ -138,6 +139,7 @@ public void testDateSerialization() throws Exception {\n \n     @Test\n     public void testEmptyTrainingSet() throws TrainingSetException {\n+        log.info(\" --- testEmptyTrainingSet --- \");\n         Batch<Example> examples = trainingSet.getPositiveExamples(new ArrayList<String>(), null);\n         assertEquals(examples.items.size(), 0);\n         assertFalse(examples.hasMore);\n@@ -157,6 +159,7 @@ public void testEmptyTrainingSet() throws TrainingSetException {\n \n     @Test\n     public void testStoringExamples() throws ConfigurationException, TrainingSetException {\n+        log.info(\" --- testStoringExamples --- \");\n         trainingSet.registerExample(\"example1\", \"Text of example1.\", Arrays.asList(TOPIC_1));\n         trainingSet.registerExample(\"example2\", \"Text of example2.\", Arrays.asList(TOPIC_1, TOPIC_2));\n         trainingSet.registerExample(\"example3\", \"Text of example3.\", new ArrayList<String>());\n@@ -201,6 +204,7 @@ public void testStoringExamples() throws ConfigurationException, TrainingSetExce\n \n     @Test\n     public void testBatchingPositiveExamples() throws ConfigurationException, TrainingSetException {\n+        log.info(\" --- testBatchingPositiveExamples --- \");\n         Set<String> expectedCollectedIds = new HashSet<String>();\n         Set<String> expectedCollectedText = new HashSet<String>();\n         Set<String> collectedIds = new HashSet<String>();\n@@ -243,6 +247,7 @@ public void testBatchingPositiveExamples() throws ConfigurationException, Traini\n \n     @Test\n     public void testBatchingNegativeExamplesAndAutoId() throws ConfigurationException, TrainingSetException {\n+        log.info(\" --- testBatchingNegativeExamplesAndAutoId --- \");\n         Set<String> expectedCollectedIds = new HashSet<String>();\n         Set<String> expectedCollectedText = new HashSet<String>();\n         Set<String> collectedIds = new HashSet<String>();\n@@ -276,6 +281,7 @@ public void testBatchingNegativeExamplesAndAutoId() throws ConfigurationExceptio\n \n     @Test\n     public void testHasChangedSince() throws Exception {\n+        log.info(\" --- testHasChangedSince --- \");\n         Date date0 = new Date();\n         assertFalse(trainingSet.hasChangedSince(Arrays.asList(TOPIC_1), date0));\n         assertFalse(trainingSet.hasChangedSince(Arrays.asList(TOPIC_2), date0));",
                "raw_url": "https://github.com/apache/stanbol/raw/6ccd695abf41d9648f643779464f03912a2f46f7/enhancement-engines/topic/engine/src/test/java/org/apache/stanbol/enhancer/engine/topic/TrainingSetTest.java",
                "sha": "e01fe60188cd379ade8e13df2daadd63d789b093",
                "status": "modified"
            }
        ],
        "message": "STANBOL-811: The TopicClassificationEngine does no longer use File#tempFile(..) to create the folder for performing CVFold's. The root folder is now configured by the unit tests. Within OSGI the property is not set and would cause a NPE if no ManagedSolrServer is present (This should be reviewed by ogrisel); Minor: also added some loggings to the unit tests.\n\ngit-svn-id: https://svn.apache.org/repos/asf/stanbol/trunk@1450615 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/4dd4de53aa60e8c7a3106b2b1b69b050a2aafb08",
        "patched_files": [
            "TrainingSet.java",
            "TopicClassificationEngine.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "TrainingSetTest.java",
            "TopicEngineTest.java"
        ]
    },
    "stanbol_89a09e9": {
        "bug_id": "stanbol_89a09e9",
        "commit": "https://github.com/apache/stanbol/commit/89a09e92746f5ff9b1879a3cdcdfd84543634f77",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 2,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java",
                "patch": "@@ -258,7 +258,7 @@ private Representation applyCacheMappings(Yard yard, Representation representati\n      * --------------------------------------------------------------------------\n      */\n     @Override\n-    public Representation create() throws IllegalArgumentException {\n+    public Representation create() throws YardException {\n         Yard yard = getCacheYard();\n         if (yard == null) {\n             return createRepresentation(null);\n@@ -268,7 +268,7 @@ public Representation create() throws IllegalArgumentException {\n     }\n \n     @Override\n-    public Representation create(String id) throws IllegalArgumentException {\n+    public Representation create(String id) throws IllegalArgumentException, YardException {\n         Yard yard = getCacheYard();\n         if (yard == null) {\n             return createRepresentation(id);",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/site/CacheImpl.java",
                "sha": "9c584737d4a3f33e777a577c92d7830c6f3d0208",
                "status": "modified"
            },
            {
                "additions": 59,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java",
                "changes": 72,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 13,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java",
                "patch": "@@ -12,6 +12,7 @@\n import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;\n import org.apache.stanbol.entityhub.servicesapi.query.FieldQueryFactory;\n import org.apache.stanbol.entityhub.servicesapi.yard.Yard;\n+import org.apache.stanbol.entityhub.servicesapi.yard.YardException;\n import org.osgi.service.cm.ConfigurationException;\n \n @Component(componentAbstract=true)\n@@ -52,6 +53,12 @@\n      * Holds the configuration of the Yard.\n      */\n     protected YardConfig config;\n+    \n+    /**\n+     * The default prefix used for created URIs.\n+     * @see #getUriPrefix()\n+     */\n+    private String defaultPrefix;\n \n     /**\n      * Default constructor to create an uninitialised Yard. Typically used\n@@ -81,17 +88,20 @@ protected AbstractYard(){}\n      */\n     protected final void activate(ValueFactory valueFactory,FieldQueryFactory queryFactory, YardConfig config) {\n         if(valueFactory == null){\n-            throw new IllegalArgumentException(\"Unable to activate: The ValueFactory MUST NOT be NULL!\");\n+            throw new NullPointerException(\"Unable to activate: The ValueFactory MUST NOT be NULL!\");\n         }\n         if(queryFactory == null){\n-            throw new IllegalArgumentException(\"Unable to activate: The QueryFactory MUST NOT be NULL!\");\n+            throw new NullPointerException(\"Unable to activate: The QueryFactory MUST NOT be NULL!\");\n         }\n         if(config == null){\n-            throw new IllegalArgumentException(\"Unable to activate: The YardConfig MUST NOT be NULL!\");\n+            throw new NullPointerException(\"Unable to activate: The YardConfig MUST NOT be NULL!\");\n         }\n         this.queryFactory = queryFactory;\n         this.valueFactory = valueFactory;\n         this.config = config;\n+        this.defaultPrefix = String.format(\"urn:org.apache.stanbol:entityhub.yard.%s:%s.\",\n+            getClass().getSimpleName(),\n+            config.getId());\n     }\n     /**\n      * Deactivates this yard instance. Typically called within an OSGI environment\n@@ -102,6 +112,7 @@ protected final void deactivate(){\n         this.queryFactory = null;\n         this.valueFactory = null;\n         this.config = null;\n+        this.defaultPrefix = null;\n     }\n \n     /**\n@@ -112,27 +123,33 @@ protected final void deactivate(){\n      * @see Yard#create()\n      */\n     @Override\n-    public final Representation create() {\n+    public final Representation create() throws IllegalArgumentException, YardException{\n         return create(null);\n     }\n     /**\n      * Creates a representation with the parsed ID. If <code>null</code> is\n-     * parsed a random UUID is generated as describe in {@link #create()}.\n-     * @param id The id or <code>null</code> to create a random uuid\n+     * parsed a random UUID is generated as describe in {@link #create()}.<p>\n+     * Note that {@link #store(Representation)} is called for the newly created\n+     * representation and the Representation returned by this Method is returned.\n+     * @param id The id or <code>null</code> to create a random uuid.\n+     * @return The newly created, empty and stored representation\n      * @see Yard#create(String)\n+     * @see Yard#store(Representation)\n      */\n     @Override\n-    public final Representation create(String id) throws IllegalArgumentException {\n+    public final Representation create(String id) throws IllegalArgumentException,YardException {\n         if(config == null){\n             throw new IllegalStateException(\"This Yard is not activated\");\n         }\n-        if(id == null){\n-            id = String.format(\"urn:org.apache.stanbol:entityhub.yard.%s:%s.%s\",\n-                    getClass().getSimpleName(),\n-                    config.getId(),\n-                    ModelUtils.randomUUID().toString());\n+        if(id == null){ //create a new ID\n+            do {\n+                id = createRandomEntityUri();\n+            } while(isRepresentation(id));\n+        } else if(isRepresentation(id)){\n+            throw new IllegalArgumentException(\n+                String.format(\"An representation with the parsed ID %s is already present in this Yard\",id));\n         }\n-        return valueFactory.createRepresentation(id);\n+        return store(valueFactory.createRepresentation(id));\n     }\n \n \n@@ -174,6 +191,35 @@ public final ValueFactory getValueFactory() {\n         }\n         return valueFactory;\n     }\n+    /**\n+     * This provides the prefix for URIs created by this Yard. This is used for\n+     * creating new unique URIs for Representation if {@link #create()} is\n+     * called. <p>\n+     * By default this implementation uses:<br>\n+     * <code>\"urn:org.apache.stanbol:entityhub.yard.\"+this.getClass.getSimpleName()+\":\"+getId()+\".\"</code>\n+     * <p>\n+     * Subclasses can override this Method to use a different namespace for entities.\n+     * @return The UriPrefix used by this Yard instance for creating URIs\n+     */\n+    protected String getUriPrefix(){\n+        return defaultPrefix;\n+    }\n+    /**\n+     * Creates an unique ID by using the {@link #getUriPrefix()} the parsed\n+     * separator (non if <code>null</code>) and an uuid created by using \n+     * {@link ModelUtils#randomUUID()}.\n+     * <p>\n+     * This Method is used for the {@link #create()} and the {@link #create(String)}\n+     * - if <code>null</code> is parsed - to generate an unique URI for the\n+     * created Representation.\n+     * <p>\n+     * Subclasses can override this Method to use other algorithms for generating\n+     * URIs for entities.\n+     * @return the created URI as string.\n+     */\n+    protected final String createRandomEntityUri(){\n+        return getUriPrefix()+ModelUtils.randomUUID().toString();\n+    }\n \n     /** ------------------------------------------------------------------------\n      *    Methods that need to be implemented by Sub-Classes",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/AbstractYard.java",
                "sha": "7e88e5ce8791d28a9d1ca5f47a865adac80bdc1d",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/SimpleYardConfig.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/SimpleYardConfig.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 3,
                "filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/SimpleYardConfig.java",
                "patch": "@@ -15,15 +15,15 @@\n  * @author Rupert Westenthaler\n  *\n  */\n-public final class DefaultYardConfig extends YardConfig {\n+public final class SimpleYardConfig extends YardConfig {\n \n     /**\n      * Creates a new configuration with the minimal set of required properties\n      * @param id the ID of the Yard\n      * @throws IllegalArgumentException if the parsed valued do not fulfil the\n      * requirements.\n      */\n-    public DefaultYardConfig(String id) throws IllegalArgumentException {\n+    public SimpleYardConfig(String id) throws IllegalArgumentException {\n         super(id);\n         try {\n             isValid();\n@@ -41,7 +41,7 @@ public DefaultYardConfig(String id) throws IllegalArgumentException {\n      * @throws IllegalArgumentException if <code>null</code> is parsed as\n      * configuration\n      */\n-    public DefaultYardConfig(Dictionary<String, Object> config) throws ConfigurationException, IllegalArgumentException {\n+    public SimpleYardConfig(Dictionary<String, Object> config) throws ConfigurationException, IllegalArgumentException {\n         super(config);\n     }\n ",
                "previous_filename": "entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/DefaultYardConfig.java",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/core/src/main/java/org/apache/stanbol/entityhub/core/yard/SimpleYardConfig.java",
                "sha": "d5d5a1b62799ad572a0be73852203d3552f68e85",
                "status": "renamed"
            },
            {
                "additions": 27,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/yard/Yard.java",
                "changes": 43,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/yard/Yard.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 16,
                "filename": "entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/yard/Yard.java",
                "patch": "@@ -65,35 +65,39 @@\n     String getDescription();\n \n     /**\n-     * Creates a new representation. The Yard is responsible to assign a valid\n-     * ID.\n+     * Creates a new empty representation and stores it in the Yard. \n+     * The Yard is responsible to assign a valid ID.\n      *\n      * @return the created Representation initialised with a valid ID\n+     * @throws YardException On any error while creating or storing the \n+     * representation\n      */\n-    Representation create();\n+    Representation create() throws YardException;\n \n     /**\n      * Creates a new representation for the given id\n      *\n      * @param id the id for the new representation or <code>null</code> to\n      * indicate that the Yard should assign an id.\n      * @return the created Representation\n-     * @throws IllegalArgumentException if the parsed id is not valid or there\n+     * @throws IllegalArgumentException if the parsed id is not valid (especially\n+     * if an empty string is parsed as ID) or there\n      * exists already a representation with the parsed id.\n+     * @throws YardException On any error while creating or storing the \n+     * representation\n      */\n-    Representation create(String id) throws IllegalArgumentException;\n+    Representation create(String id) throws IllegalArgumentException, YardException;\n \n     /**\n      * Stores the representation in the Yard. if the parsed representation is\n      * not present in the Yard it will add it to the Yard.\n      *\n      * @param representation the representation\n      * @return the representation as stored\n-     * @throws IllegalArgumentException if <code>null</code> is parsed as argument or\n-     * the representation is not managed (e.g was not created by using this yard).\n+     * @throws NullPointerException if <code>null</code> is parsed as argument.\n      * @throws YardException On any error related to the Yard\n      */\n-    Representation store(Representation representation) throws IllegalArgumentException, YardException;\n+    Representation store(Representation representation) throws NullPointerException, YardException;\n \n     /**\n      * Stores all the parsed representation in a single chunk in the Yard. This\n@@ -102,12 +106,16 @@\n      * the returned Iterable.\n      * Otherwise same as {@link #store(Representation)}.\n      *\n-     * @param representations all the representations to store\n+     * @param representations all the representations to store. <code>null</code>\n+     * values are ignored and MUST NOT throw any exceptions. Parsing an {@link Iterable}\n+     * without any element will have none effect but also MUST NOT throw an exception.\n      * @return the stored representations in the same iteration order\n-     * @throws IllegalArgumentException if <code>null</code> is parsed as Iterable\n+     * @throws NullPointerException if <code>null</code> is parsed as Iterable,\n+     * but NOT if the parsed Iterable does not contain any Elements or the\n+     * <code>null</code> value.\n      * @throws YardException On any error related to the Yard\n      */\n-    Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException;\n+    Iterable<Representation> store(Iterable<Representation> representations) throws NullPointerException, YardException;\n \n     /**\n      * Removes the {@link Representation} with the given id\n@@ -135,8 +143,9 @@\n      * @param id the id. Calls with <code>null</code> are ignored\n      * @return <code>true</code> if a representation with the id is present in\n      *         the Yard. Otherwise <code>false</code>.\n+     * @throws NullPointerException if <code>null</code> is parsed as ID\n      * @throws IllegalArgumentException if the parsed ID is not valid\n-     * formatted\n+     * formatted (especially if an empty String is parsed as ID\n      * @throws YardException On any error related to the Yard\n      */\n     boolean isRepresentation(String id) throws YardException, IllegalArgumentException;\n@@ -148,8 +157,8 @@\n      * @param id the id.\n      * @return The representation with the parsed id or <code>null</code> if\n      *         no representation with this id is present in the Yard\n-     * @throws IllegalArgumentException if the parsed ID is not valid\n-     * formatted\n+     * @throws NullPointerException if <code>null</code> is parsed as id\n+     * @throws IllegalArgumentException if the parsed ID is not valid formatted\n      * @throws YardException On any error related to the Yard\n      */\n     Representation getRepresentation(String id) throws YardException, IllegalArgumentException;\n@@ -159,8 +168,10 @@\n      *\n      * @param represnetation the representation\n      * @return the representation as stored\n-     * @throws IllegalArgumentException if the parsed representation <code>null</code>\n-     * or not present in the Yard\n+     * @throws NullPointerException If <code>null</code> is parsed as representation\n+     * @throws IllegalArgumentException if the parsed representation is not present \n+     * in the Yard (and can not be updated therefore). TODO: evaluate if this should\n+     * really throw only a {@link RuntimeException}.\n      * @throws YardException On any error related to the Yard\n      */\n     Representation update(Representation represnetation) throws YardException, IllegalArgumentException;",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/servicesapi/src/main/java/org/apache/stanbol/entityhub/servicesapi/yard/Yard.java",
                "sha": "ffd9aab26bbda20d9d3481e6fde581016e321e2c",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 0,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java",
                "patch": "@@ -0,0 +1,22 @@\n+package org.apache.stanbol.entityhub.test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class Utils {\n+    /**\n+     * Converts an Iterator to a Collection by iterating over all elements and\n+     * adding them to a List.\n+     * @param <T>\n+     * @param it the iterator\n+     * @return the collection containing all elements of the iterator\n+     */\n+    public static <T> Collection<T> asCollection(Iterator<T> it){\n+        Collection<T> c = new ArrayList<T>();\n+        while(it.hasNext()){\n+            c.add(it.next());\n+        }\n+        return c;\n+    };\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/Utils.java",
                "sha": "9feb6e3b001c2e10d1f05931dbfc97eeb371edc3",
                "status": "added"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 14,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java",
                "patch": "@@ -6,6 +6,8 @@\n import static junit.framework.Assert.assertNull;\n import static junit.framework.Assert.assertTrue;\n \n+import static org.apache.stanbol.entityhub.test.Utils.asCollection;\n+\n import java.net.MalformedURLException;\n import java.net.URI;\n import java.net.URISyntaxException;\n@@ -1017,19 +1019,6 @@ protected Representation createRepresentation(String id){\n         }\n         return getValueFactory().createRepresentation(id);\n     }\n-    /**\n-     * Converts an Iterator to a Collection by iterating over all elements and\n-     * adding them to a List.\n-     * @param <T>\n-     * @param it the iterator\n-     * @return the collection containing all elements of the iterator\n-     */\n-    protected static <T> Collection<T> asCollection(Iterator<T> it){\n-        Collection<T> c = new ArrayList<T>();\n-        while(it.hasNext()){\n-            c.add(it.next());\n-        }\n-        return c;\n-    };\n+\n \n }",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/model/RepresentationTest.java",
                "sha": "0448b229bb7fc9b498ec27cd36365d03e9ccbfb0",
                "status": "modified"
            },
            {
                "additions": 530,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java",
                "changes": 530,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 0,
                "filename": "entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java",
                "patch": "@@ -0,0 +1,530 @@\n+package org.apache.stanbol.entityhub.test.yard;\n+\n+import static junit.framework.Assert.*;\n+import static org.apache.stanbol.entityhub.test.Utils.asCollection;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+\n+import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n+import org.apache.stanbol.entityhub.servicesapi.yard.Yard;\n+import org.apache.stanbol.entityhub.servicesapi.yard.YardException;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+\n+public abstract class YardTest {\n+    \n+    /**\n+     * Getter for the {@link Yard} instance to be tested\n+     * @return the {@link Yard} instance to be tested\n+     */\n+    protected abstract Yard getYard();\n+    \n+    /**\n+     * Stores all the IDs of Representations created by the create(..) methods.\n+     * This collection is used to clean up the store after all the unit tests \n+     * are executed.\n+     */\n+    protected Collection<String> representationIds = new HashSet<String>();\n+    \n+    protected Representation create() throws YardException{\n+        Representation r = getYard().create();\n+        representationIds.add(r.getId());\n+        return r;\n+    }\n+    \n+    protected Representation create(String id,boolean store) throws YardException{\n+        Representation r;\n+        if(store){\n+            r = getYard().create(id);\n+        } else if(id != null && !id.isEmpty()){\n+           r = getYard().getValueFactory().createRepresentation(id);\n+        } else {\n+            throw new IllegalArgumentException(\"If store is FALSE the id MUST NOT be NULL nor EMPTY!\");\n+        }\n+        representationIds.add(r.getId());\n+        return r;\n+    }\n+    \n+    @Test\n+    public void testGetValueFactory() {\n+        assertNotNull(\"The ValueFactory MUST NOT be NULL\", getYard().getValueFactory());\n+    }\n+    @Test\n+    public void testGetQueryFactory(){\n+        assertNotNull(\"The QueryFactory MUST NOT be NULL\",getYard().getQueryFactory());\n+    }\n+    \n+    @Test\n+    public void testYardId(){\n+        assertNotNull(\"The ID of the Yard MUST NOT be NULL\",getYard().getId());\n+    }\n+    \n+    @Test\n+    public void testYardName(){\n+        assertNotNull(\"The Name of the Yard MUST NOT be NULL\",getYard().getName());\n+        assertFalse(\"The Name of the Yard MUST NOT be an empty String\", getYard().getName().isEmpty());\n+    }\n+    \n+    @Test\n+    public void testDefaultCreate() throws YardException{\n+        Yard yard = getYard();\n+        Representation test = yard.create();\n+        assertNotNull(test);\n+        Representation test2 = yard.create();\n+        assertNotNull(test2);\n+        assertNotSame(test, test2);\n+        assertFalse(\"Two Representation created with create() MUST NOT be equals\",test.equals(test2));\n+    }\n+\n+    @Test\n+    public void testCreateWithNull() throws YardException{\n+        Yard yard = getYard();\n+        Representation test = yard.create(null);\n+        assertNotNull(\"Parsing NULL to create(String) MUST create a valid Representation\",test);\n+        representationIds.add(test.getId()); //add id to cleanup list\n+        Representation test2 = yard.create(null);\n+        assertNotNull(\"Parsing NULL to create(String) MUST create a valid Representation\",test2);\n+        representationIds.add(test2.getId()); //add id to cleanup list\n+        assertNotSame(test, test2);\n+        assertFalse(\"Two Representation created with create(null) MUST NOT be equals\",test.equals(test2));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testCreateWithEmptyString() throws YardException{\n+        getYard().create(\"\");//throws an IllegalArgumentException\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testCreateWithExistingId() throws YardException{\n+        Yard yard = getYard();\n+        Representation test = create();\n+        assertNotNull(test);\n+        yard.create(test.getId()); //throws an IllegalArgumentException\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void testIsRepresentationWithNull() throws YardException {\n+        getYard().isRepresentation(null);\n+    }\n+ \n+    @Test(expected=IllegalArgumentException.class)\n+    public void testIsRepresentationWithEmptyString() throws YardException{\n+        getYard().isRepresentation(\"\");\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testStoreRepresentationWithNull() throws YardException {\n+        getYard().store((Representation)null);\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void testStoreRepresentationsWithNull() throws YardException {\n+        getYard().store((Iterable<Representation>)null);\n+    }\n+    @Test\n+    public void testStoreRepresentation() throws YardException {\n+        //NOTE: this does not test if the updated view of the representation is\n+        //      stored, but only that the store method works for representations\n+        //      that are already in the Yard AND representations that are not yet\n+        //      present within the yard\n+        String testId = \"urn:yard.test.testStoreRepresentation:representation.id1\";\n+        String testId2 = \"urn:yard.test.testStoreRepresentation:representation.id2\";\n+        Yard yard = getYard();\n+        Representation test = create(testId,false);\n+        Representation added = yard.store(test); // this adds the representation\n+        assertEquals(test, added);\n+        Representation test2 = create(testId2,true); //this creates and adds the representation\n+        //now test that the representation can also be updated\n+        added = yard.store(test2);\n+        assertEquals(test2, added);\n+    }\n+    @Test\n+    public void testStoreRepresentations() throws YardException {\n+        //NOTE: this does not test if the updated view of the representation is\n+        //      stored, but only that the store method works for representations\n+        //      that are already in the Yard AND representations that are not yet\n+        //      present within the yard\n+        String testId = \"urn:yard.test.testStoreRepresentations:representation.id1\";\n+        String testId2 = \"urn:yard.test.testStoreRepresentations:representation.id2\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Yard yard = getYard();\n+        Representation test = create(testId,false);\n+        Representation test2 = create(testId2,true); //this creates and adds the representation\n+        //now add both and mix Representations that are already present in the yard\n+        //with an other that is not yet present in the yard\n+\n+        //change the representations to be sure to force an update even if the\n+        //implementation checks for changes before updating a representation\n+        test2.add(field, \"test value 2\");\n+        Iterable<Representation> addedIterable = yard.store(Arrays.asList(test,test2));\n+        assertNotNull(addedIterable);\n+        Collection<Representation>  added = asCollection(addedIterable.iterator());\n+        //test that both the parsed Representations where stored (updated & created)\n+        assertTrue(added.remove(test));\n+        assertTrue(added.remove(test2));\n+        assertTrue(added.isEmpty());\n+    }\n+    @Test\n+    public void testStoreRepresentationsWithNullElement() throws YardException {\n+        String testId = \"urn:yard.test.testStoreRepresentationsWithNullElement:representation.id\";\n+        Yard yard = getYard();\n+        Representation test = create(testId,false);\n+        Iterable<Representation> added = yard.store(Arrays.asList(\n+            test,\n+            null));\n+        //now test that only the valid representation was added and the null\n+        //value was ignored\n+        assertNotNull(added);\n+        Iterator<Representation> addedIt = added.iterator();\n+        assertTrue(addedIt.hasNext());\n+        assertEquals(test, addedIt.next());\n+        assertFalse(addedIt.hasNext());\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testGetRepresentationWithNull() throws YardException {\n+        getYard().getRepresentation(null);\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testGetRepresentationWithEmptyString() throws YardException {\n+        getYard().getRepresentation(\"\");\n+    }\n+    @Test\n+    public void testGetNonExistantRepresentation() throws YardException {\n+        String id = \"urn:yard.test.testGetNonExistantRepresentation:representation.id\";\n+        assertNull(getYard().getRepresentation(id));\n+    }\n+    /**\n+     * This tests that {@link Representation} retrieved from the Yard do not\n+     * influence other {@link Representation} instances for the same ID. It is\n+     * important, that when different {@link Representation} instances are\n+     * returned to different caller, that these do not influence each other.<p>\n+     * It also tests, that any update to the {@link Representation} as managed\n+     * by the {@link Yard} does also not influence {@link Representation}\n+     * instances that where created before the change.\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testGetRepresentation() throws YardException {\n+        String id = \"urn:yard.test.testGetRepresentation.id\";\n+        Yard yard = getYard();\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        String value1 = \"this is a test\";\n+        //Representations created via the yard need to be created (as empty\n+        //representation within the yard\n+        Representation test = create(id,true);\n+        //retrieve the representation from the store\n+        Representation retrieved = yard.getRepresentation(id);\n+        assertNotNull(retrieved);\n+        //they MUST NOT be the same, but the MUST be equals\n+        //Note:\n+        //the fact that two representations with the same id are equals is tested \n+        //by the unit tests for the representation interface\n+        assertEquals(test, retrieved); \n+        assertNotSame(\"getRepresentation MUST return an new instance for each \" +\n+        \t\t\"call, so that changes in one return instance do not influence \" +\n+        \t\t\"an other returned instance!\",test, retrieved);\n+        //now add a property to the original one\n+        test.add(field, value1);\n+        //and check that the retrieved does not have the value\n+        assertFalse(retrieved.get(field).hasNext());\n+        //now store the representation and check that updated are not reflected\n+        //within the retrieved one\n+        yard.store(test);\n+        assertFalse(retrieved.get(field).hasNext());\n+        //now retrieve again an representation\n+        retrieved = null;\n+        retrieved = yard.getRepresentation(id);\n+        //now the Representation MUST HAVE the new field\n+        assertTrue(retrieved.get(field).hasNext());\n+        assertEquals(value1, retrieved.getFirst(field));\n+        \n+        //finally retrieve a second and perform the change test again\n+        Representation retrieved2 = yard.getRepresentation(id);\n+        retrieved.removeAll(field);\n+        //check the value is still in retrieved2\n+        assertTrue(retrieved2.get(field).hasNext());\n+        assertEquals(value1, retrieved2.getFirst(field));\n+        \n+    }\n+    \n+    @Test\n+    public void testIsRepresentation() throws YardException {\n+        String id = \"urn:yard.test.testIsRepresentation:representation.id\";\n+        Yard yard = getYard();\n+        //Representations created via the yard need to be created (as empty\n+        //representation within the yard\n+        Representation test = create();\n+        assertTrue(yard.isRepresentation(test.getId()));\n+        //Representations created via the ValueFactory MUST NOT be added to the\n+        //Yard\n+        Representation test2 = create(id,false);\n+        assertFalse(yard.isRepresentation(test2.getId()));\n+        //now store test2 and test again\n+        yard.store(test2);\n+        assertTrue(yard.isRepresentation(test2.getId()));\n+        //now remove test and test again\n+        yard.remove(test.getId());\n+        assertFalse(yard.isRepresentation(test.getId()));\n+        yard.remove(test2.getId());\n+        assertFalse(yard.isRepresentation(test2.getId()));\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testUpdateRepresentationWithNull() throws YardException {\n+        getYard().update((Representation)null);\n+    }\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testUpdateRepresentationWithNonPresent() throws YardException {\n+        String id = \"urn:yard.test.testUpdateRepresentationWithNonPresent:representation.id\";\n+        Representation test = create(id,false);\n+        getYard().update(test); //throws an Exception because test is not part of the yard\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testUpdateRepresentationsWithNull() throws YardException {\n+        getYard().update((Iterable<Representation>)null);\n+    }\n+    @Test\n+    public void testUpdateRepresentations() throws YardException {\n+        //NOTE: this does not test if the updated view of the representation is\n+        //      stored, but only that the update method works correctly\n+        Yard yard = getYard();\n+        String id1 = \"urn:yard.test.testUpdateRepresentations:representation.id1\";\n+        String id2 = \"urn:yard.test.testUpdateRepresentations:representation.id2\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation test1 = create(id1,true);\n+        Representation test2 = create(id2,true);\n+        //change the representations to be sure to force an update even if the\n+        //implementation checks for changes before updating a representation\n+        test1.add(field, \"test value 1\");  \n+        test2.add(field, \"test value 2\");\n+        Iterable<Representation> updatedIterable = yard.update(Arrays.asList(test1,test2));\n+        assertNotNull(updatedIterable);\n+        Collection<Representation>  updated = asCollection(updatedIterable.iterator());\n+        //test that both the parsed Representations where stored (updated & created)\n+        assertTrue(updated.remove(test1));\n+        assertTrue(updated.remove(test2));\n+        assertTrue(updated.isEmpty());\n+    }\n+    /**\n+     * When updating multiple null values need to be ignored.\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testUpdateRepresentationsWithNullElement() throws YardException {\n+        //NOTE: this does not test if the updated view of the representation is\n+        //      stored, but only that the update method works correctly\n+        Yard yard = getYard();\n+        String id1 = \"urn:yard.test.testUpdateRepresentationsWithNullElement:representation.id\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation test1 = create(id1,true);\n+        //change the representations to be sure to force an update even if the\n+        //implementation checks for changes before updating a representation\n+        test1.add(field, \"test value 1\");  \n+        Iterable<Representation> updated = yard.update(Arrays.asList(test1,null));\n+        assertNotNull(updated);\n+        Iterator<Representation> updatedIt = updated.iterator();\n+        assertTrue(updatedIt.hasNext());\n+        assertEquals(test1, updatedIt.next());\n+        assertFalse(updatedIt.hasNext());\n+    }\n+    /**\n+     * When updating multiple non present representations need to be ignored.\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testUpdateRepresentationsWithNonPresent() throws YardException {\n+        //NOTE: this does not test if the updated view of the representation is\n+        //      stored, but only that the update method works correctly\n+        Yard yard = getYard();\n+        String id1 = \"urn:yard.test.testUpdateRepresentationsWithNonPresent:representation.id1\";\n+        String id2 = \"urn:yard.test.testUpdateRepresentationsWithNonPresent:representation.id2\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        Representation test1 = create(id1,true);\n+        //change the representations to be sure to force an update even if the\n+        //implementation checks for changes before updating a representation\n+        test1.add(field, \"test value 1\");\n+        //create a 2nd Representation by using the ValueFactory (will not add it\n+        //to the yard!)\n+        Representation test2 = create(id2,false);\n+        //now test1 is present and test2 is not.\n+        Iterable<Representation> updated = yard.update(Arrays.asList(test1,test2));\n+        //We expect that only test1 is updated and test2 is ignored\n+        assertNotNull(updated);\n+        Iterator<Representation> updatedIt = updated.iterator();\n+        assertTrue(updatedIt.hasNext());\n+        assertEquals(test1, updatedIt.next());\n+        assertFalse(updatedIt.hasNext());\n+    }\n+    \n+    @Test(expected=NullPointerException.class)\n+    public void testRemoveRepresentationWithNull() throws YardException {\n+        getYard().remove((String)null);\n+    }\n+    /**\n+     * Tests two things:<ol>\n+     * <li> if representations are removed form the yard\n+     * <li> if the representation instance is still valid after it is removed\n+     * </ol>\n+     * The second is very important, because Representations might still be\n+     * used by other components after they are remove from the store they\n+     * where created in\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testRemoveRepresentation() throws YardException {\n+        //NOTE: This test needs not to use the create(..) method, because we \n+        //remove the created representation form the store anyway as part of the \n+        //test\n+        String id = \"urn:yard.test.tesrRemoveRepresentation:representation.id\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        String testValue = \"This is a test\";\n+        Yard yard = getYard();\n+        Representation test =  yard.getValueFactory().createRepresentation(id);\n+        test.add(field, testValue);\n+        yard.store(test); //store the representation\n+        assertTrue(yard.isRepresentation(test.getId())); //test if stored\n+        test = null; //free the initial\n+        //create the instance form the store to test (2)\n+        test = yard.getRepresentation(id);\n+        assertEquals(id, test.getId()); //only to be sure ...\n+        yard.remove(test.getId()); //test (1) - the remove \n+        assertFalse(yard.isRepresentation(test.getId()));//test if removed\n+        //test if the test object is not destroyed by removing the representation\n+        //it represents form the store (2)\n+        assertEquals(testValue, test.getFirst(field));\n+    }\n+    @Test(expected=NullPointerException.class)\n+    public void testRemoveRepresentationsWithNull() throws YardException {\n+        getYard().remove((Iterable<String>)null);\n+    }\n+    /**\n+     * Tests that multiple Representations are removed. \n+     * @throws YardException\n+     */\n+    @Test\n+    public void testRemoveRepresentations() throws YardException {\n+        //NOTE: This test needs not to use the create(..) method, because we \n+        //remove the created representation form the store anyway as part of the \n+        //test\n+        String id = \"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.id1\";\n+        String id2 = \"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.id2\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        String testValue = \"This is a test\";\n+        Yard yard = getYard();\n+        //use both ways to add the two Representations (should make no differences,\n+        //but one never can know ...\n+        Representation test1 =  yard.create(id); //create and add\n+        Representation test2 = yard.getValueFactory().createRepresentation(id2); //create\n+        test2.add(field, testValue); //add value\n+        yard.store(test2);//store\n+        assertTrue(yard.isRepresentation(test1.getId())); //test if stored\n+        assertTrue(yard.isRepresentation(test2.getId()));\n+        yard.remove(Arrays.asList(test1.getId(),test2.getId())); //remove\n+        assertFalse(yard.isRepresentation(test1.getId())); //test if removed\n+        assertFalse(yard.isRepresentation(test2.getId()));        \n+    }\n+    /**\n+     * Tests if <code>null</code> values within the Iterable are ignored and do\n+     * not cause an Exception\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testRemoveRepresentationsWithNullValue() throws YardException {\n+        //NOTE: This test needs not to use the create(..) method, because we \n+        //remove the created representation form the store anyway as part of the \n+        //test\n+        String id = \"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.id\";\n+        Yard yard = getYard();\n+        Representation test =  yard.create(id); //create and add\n+        assertTrue(yard.isRepresentation(test.getId()));\n+        yard.remove(Arrays.asList(test.getId(),null));\n+        assertFalse(yard.isRepresentation(test.getId()));\n+    }\n+    /**\n+     * Tests that {@link Representation} IDs that are not stored by the yard are\n+     * ignored by the multiple remove method\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testRemoveRepresentationsWithNonStoredValue() throws YardException {\n+        //NOTE: This test needs not to use the create(..) method, because we \n+        //remove the created representation form the store anyway as part of the \n+        //test\n+        String id = \"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.stored\";\n+        String id2 = \"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.notStored\";\n+        Yard yard = getYard();\n+        Representation test =  yard.create(id); //create and add\n+        assertTrue(yard.isRepresentation(test.getId()));\n+        yard.remove(Arrays.asList(test.getId(),id2));\n+        assertFalse(yard.isRepresentation(test.getId()));\n+        assertFalse(yard.isRepresentation(id2));\n+    }\n+    /**\n+     * The {@link Representation} as stored in the Yard MUST NOT change if the\n+     * source {@link Representation} stored to the {@link Yard} or an\n+     * Representation retrieved from the Yard is changed. Only the\n+     * {@link Yard#store(Representation))} and the {@link Yard#update(Representation)}\n+     * methods are allowed to synchronised the Representation within the Yard with\n+     * the state (changes) of the parsed value.\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testChangeRepresentation() throws YardException {\n+        String id = \"urn:yard.test.testChangeRepresentation:representation.id\";\n+        String field = \"urn:the.field:used.for.this.Test\";\n+        String testValue = \"This is a test\";\n+        Yard yard = getYard();\n+        //use the ValueFactory to create the representation to ensure that this\n+        //instance has nothing to do with the store\n+        Representation test = create(id,false);\n+        //now store the empty Representation\n+        yard.store(test);\n+        //now add a values\n+        test.add(field, testValue);\n+        //now get the representation from the yard\n+        Representation stored = yard.getRepresentation(id);\n+        //test if the stored version does not contain the value\n+        assertFalse(stored.get(field).hasNext());\n+        stored = null;\n+        //now store the updated version\n+        yard.store(test);\n+        //now check that the updated value is stored\n+        stored = yard.getRepresentation(id);\n+        assertEquals(testValue, stored.getFirst(field));\n+        \n+        //now we need to test if modifications of an Representation returned\n+        test = stored;\n+        stored = null;\n+        String testValue2 = \"This is an ohter test value\";\n+        test.add(field, testValue2);\n+        \n+        //now get the representation from the yard and check that it still has\n+        //only one value\n+        stored = yard.getRepresentation(id);\n+        Collection<Object> values = asCollection(stored.get(field));\n+        assertTrue(values.remove(testValue)); //test that it contains the value\n+        assertTrue(values.isEmpty()); //and that there is only this value\n+        values = null;\n+        //now update the stored version with the new state\n+        stored = null;\n+        stored = yard.update(test);\n+        values = asCollection(stored.get(field));\n+        assertTrue(values.remove(testValue)); //test that it contains the original\n+        assertTrue(values.remove(testValue2)); //test that it contains the 2nd value\n+        assertTrue(values.isEmpty()); //and that there are only these two values\n+        values = null;\n+    }\n+    \n+    /**\n+     * This Method removes all Representations create via {@link #create()} or\n+     * {@link #create(String, boolean)} from the tested {@link Yard}.\n+     * It also removes all Representations there ID was manually added to the\n+     * {@link #representationIds} list.\n+     */\n+    @After\n+    public final void clearUpRepresentations() throws YardException {\n+        getYard().remove(representationIds);\n+    }\n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/generic/test/src/main/java/org/apache/stanbol/entityhub/test/yard/YardTest.java",
                "sha": "4b257f467c9dd8b4bed92ae837586b1bfeb09d0a",
                "status": "added"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 1,
                "filename": "entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java",
                "patch": "@@ -417,7 +417,7 @@ private Representation importFeature(String line){\n         String id = t.nextElement();\n         Integer geoNamesId = Integer.parseInt(id);\n         //create a new Doc based on the first Element (geonamesID)\n-        Representation doc = this.yard.create(String.format(\"%s%s/\", geonamesFeatureBase,id));\n+        Representation doc = this.yard.getValueFactory().createRepresentation(String.format(\"%s%s/\", geonamesFeatureBase,id));\n         //add the geonames:Feature type\n         doc.add(Properties.rdf_type.toString(), getDocRef(Properties.gn_Feature.toString()));\n         //add the UTF-8name",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/indexing/geonames/src/main/java/org/apache/stanbol/entityhub/indexing/geonames/GeoNamesIndexer.java",
                "sha": "9f5f1069baebab031403e8d339117acaacf877f6",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 1,
                "filename": "entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java",
                "patch": "@@ -302,7 +302,14 @@ public Text getFirst(String field, String...languages) {\n     }\n     @Override\n     public String getId() {\n-        return ((UriRef)graphNode.getNode()).getUnicodeString();\n+        return getNode().getUnicodeString();\n+    }\n+    /**\n+     * Getter for the UriRef representing the ID of this Representation.\n+     * @return The UriRef representing the ID of this Representation.\n+     */\n+    public UriRef getNode(){\n+        return (UriRef)graphNode.getNode();\n     }\n \n     @Override",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/model/clerezza/src/main/java/org/apache/stanbol/entityhub/model/clerezza/RdfRepresentation.java",
                "sha": "bdf3b211be9808b7ccb2aa81921936383e53e791",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/yard/clerezza/pom.xml",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/clerezza/pom.xml?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 0,
                "filename": "entityhub/yard/clerezza/pom.xml",
                "patch": "@@ -107,6 +107,23 @@\n     </dependency>\n     \n     <!-- for tests -->\n+    <dependency>\n+      <groupId>org.apache.stanbol</groupId>\n+      <artifactId>org.apache.stanbol.entityhub.test</artifactId>\n+      <version>0.1-SNAPSHOT</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- A TC Provider is needed to run the Unit Tests of the Yard Interface.\n+         Currently the Simple Storage Provider (in memory) is used.\n+         As alternative one could also run the tests against Jena TDB but that\n+         would require a lot of additional bundles to be added as test\n+         dependencies -->\n+    <dependency>\n+      <groupId>org.apache.clerezza</groupId>\n+      <artifactId>org.apache.clerezza.rdf.simple.storage</artifactId>\n+      <version>0.7-incubating-SNAPSHOT</version>\n+      <scope>test</scope>\n+    </dependency>\n     <dependency>\n       <groupId>junit</groupId>\n       <artifactId>junit</artifactId>",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/yard/clerezza/pom.xml",
                "sha": "d1ee00cefc47ad8a00b73141107c10e50a0b42d1",
                "status": "modified"
            },
            {
                "additions": 149,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "changes": 199,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 50,
                "filename": "entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "patch": "@@ -1,26 +1,32 @@\n package org.apache.stanbol.entityhub.yard.clerezza.impl;\n \n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.Set;\n import java.util.concurrent.locks.Lock;\n \n+import org.apache.clerezza.rdf.core.BNode;\n import org.apache.clerezza.rdf.core.Graph;\n+import org.apache.clerezza.rdf.core.Literal;\n+import org.apache.clerezza.rdf.core.LiteralFactory;\n import org.apache.clerezza.rdf.core.MGraph;\n+import org.apache.clerezza.rdf.core.NonLiteral;\n import org.apache.clerezza.rdf.core.Resource;\n+import org.apache.clerezza.rdf.core.Triple;\n import org.apache.clerezza.rdf.core.TripleCollection;\n import org.apache.clerezza.rdf.core.UriRef;\n import org.apache.clerezza.rdf.core.access.LockableMGraph;\n import org.apache.clerezza.rdf.core.access.NoSuchEntityException;\n import org.apache.clerezza.rdf.core.access.TcManager;\n import org.apache.clerezza.rdf.core.impl.SimpleMGraph;\n+import org.apache.clerezza.rdf.core.impl.TripleImpl;\n import org.apache.clerezza.rdf.core.sparql.ParseException;\n import org.apache.clerezza.rdf.core.sparql.QueryParser;\n import org.apache.clerezza.rdf.core.sparql.ResultSet;\n import org.apache.clerezza.rdf.core.sparql.SolutionMapping;\n import org.apache.clerezza.rdf.core.sparql.query.Query;\n import org.apache.clerezza.rdf.core.sparql.query.SelectQuery;\n-import org.apache.clerezza.rdf.ontologies.RDF;\n-import org.apache.clerezza.rdf.utils.GraphNode;\n import org.apache.felix.scr.annotations.Activate;\n import org.apache.felix.scr.annotations.Component;\n import org.apache.felix.scr.annotations.ConfigurationPolicy;\n@@ -31,7 +37,7 @@\n import org.apache.stanbol.entityhub.core.query.QueryUtils;\n import org.apache.stanbol.entityhub.core.utils.AdaptingIterator;\n import org.apache.stanbol.entityhub.core.yard.AbstractYard;\n-import org.apache.stanbol.entityhub.core.yard.DefaultYardConfig;\n+import org.apache.stanbol.entityhub.core.yard.SimpleYardConfig;\n import org.apache.stanbol.entityhub.model.clerezza.RdfRepresentation;\n import org.apache.stanbol.entityhub.model.clerezza.RdfValueFactory;\n import org.apache.stanbol.entityhub.model.clerezza.utils.Resource2StringAdapter;\n@@ -78,18 +84,26 @@\n //})\n public class ClerezzaYard extends AbstractYard implements Yard {\n     Logger log = LoggerFactory.getLogger(ClerezzaYard.class);\n-    public static final String YARD_URI_PREFIX = \"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:\";\n-    public static final UriRef REPRESENTATION = new UriRef(RdfResourceEnum.Representation.getUri());\n     /**\n-     * This property is used to check if a URI in the graph represents a representation by\n-     * calling {@link TripleCollection#filter(org.apache.clerezza.rdf.core.NonLiteral, UriRef, Resource)}\n-     * with the reuqested ID as subject, this {@link UriRef} as property and\n-     * <code>null</code> as value.<p>\n-     * This is the easiest way to do that, because each representation MUST HAVE\n-     * a entityhub:label. If this is requirements is changed in future, than the code\n-     * using this property MUST BE changed accordingly!\n+     * Property used to mark empty Representations managed by this Graph. This is\n+     * needed to workaround the fact, that the Entityhub supports the storage of\n+     * empty Representations but this Yard uses the search for any outgoing\n+     * relation (triple with the id of the representation as Subject) for the \n+     * implementation of {@link #isRepresentation(String)}. Therefore for an\n+     * empty Representation {@link #isRepresentation(String)} would return false\n+     * even if the representation was {@link #store(Representation)} previously.\n+     * <p>\n+     * Adding the Triple<br>\n+     * <code> ?representationId <{@value #MANAGED_REPRESENTATION}> true^^xsd:boolean </code>\n+     * <br> for any empty Representation avoids this unwanted behaviour.\n      */\n-    private static UriRef ENTITYHUB_LABEL_URIREF = new UriRef(RdfResourceEnum.label.getUri());\n+    public static UriRef MANAGED_REPRESENTATION = new UriRef(\"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:managesRepresentation\");\n+    /**\n+     * The TRUE value used as object for the property {@link #MANAGED_REPRESENTATION}.\n+     */\n+    private static Literal TRUE_LITERAL = LiteralFactory.getInstance().createTypedLiteral(Boolean.FALSE);\n+    //public static final String YARD_URI_PREFIX = \"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:\";\n+//    public static final UriRef REPRESENTATION = new UriRef(RdfResourceEnum.Representation.getUri());\n //    protected ComponentContext context;\n //    protected Dictionary<String,?> properties;\n     @Reference\n@@ -100,8 +114,9 @@\n     public ClerezzaYard() {\n         super();\n     }\n-    public ClerezzaYard(String yardId) {\n+    public ClerezzaYard(YardConfig config) {\n         super();\n+        activate(config);\n     }\n     @SuppressWarnings(\"unchecked\")\n     @Activate\n@@ -110,11 +125,26 @@ protected void activate(ComponentContext context) throws ConfigurationException\n         if(context == null || context.getProperties() == null){\n             throw new IllegalStateException(\"No valid\"+ComponentContext.class+\" parsed in activate!\");\n         }\n-        activate(new DefaultYardConfig(context.getProperties()));\n+        activate(new SimpleYardConfig(context.getProperties()));\n     }\n-    protected final void activate(YardConfig config) throws ConfigurationException,IllegalArgumentException {\n+    /**\n+     * Internally used to activate the Yard. In case the Yard runs within a\n+     * OSGI container it is called by the {@link #activate(ComponentContext)}\n+     * Method. In case the Yard runs outside of an OSGI Container it is called\n+     * by the Constructor taking the {@link YardConfig} as parameter\n+     * @param config The configuration for the new Yard instance\n+     * @throws NullPointerException In case <code>null</code> is parsed as configuration\n+     * @throws IllegalArgumentException In case the configuration is invalid\n+     */\n+    private final void activate(YardConfig config) throws IllegalArgumentException, NullPointerException {\n         super.activate(RdfValueFactory.getInstance(), SparqlFieldQueryFactory.getInstance(), config);\n-        this.yardGraphUri = new UriRef(YARD_URI_PREFIX+config.getId());\n+        if(tcManager == null){ //this will be the case if we are not in an OSGI environment\n+          //use the getInstance() method!\n+            tcManager = TcManager.getInstance(); \n+        }\n+        String yardUri = getUriPrefix();\n+        //remove the \".\" at the last position of the prefix\n+        this.yardGraphUri = new UriRef(yardUri.substring(0, yardUri.length()-2));\n         try {\n             this.graph = tcManager.getMGraph(yardGraphUri);\n             log.info(\"  ... (re)use existing Graph \"+yardGraphUri+\" for Yard \"+config.getName());\n@@ -144,7 +174,10 @@ public String getYardGraphUri(){\n     @Override\n     public Representation getRepresentation(String id) {\n         if(id == null){\n-            return null;\n+            throw new NullPointerException(\"The parsed representation id MUST NOT be NULL!\");\n+        }\n+        if(id.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed representation id MUST NOT be EMTPY!\");\n         }\n         return getRepresentation(new UriRef(id),true);\n     }\n@@ -156,45 +189,94 @@ public Representation getRepresentation(String id) {\n      * @return the Representation\n      */\n     protected Representation getRepresentation(UriRef uri, boolean check) {\n-        if(!check || graph.filter(uri, ENTITYHUB_LABEL_URIREF, null).hasNext()){\n-            /*\n-             * We need to use an own graph for the Representation, because\n-             * changes to the Representation should not be reflected in the\n-             * Yard until a store() or update().\n-             * Currently the GraphNode.getNodeContext() functionality is used\n-             * to calculate the graph included for the Representation.\n-             */\n-            GraphNode node = new GraphNode(uri, graph);\n-            //create a changeable graph for the representation, because\n-            //node.getNodeContext returns an immutable Graph!\n-            MGraph nodeGraph = new SimpleMGraph(node.getNodeContext());\n-            return ((RdfValueFactory)valueFactory).createRdfRepresentation(uri, nodeGraph);\n-        } else {\n-            return null; //not found\n+        Lock readLock = graph.getLock().readLock();\n+        readLock.lock();\n+        try {\n+            if(!check || isRepresentation(uri)){\n+                MGraph nodeGraph = createRepresentationGraph(uri, graph);\n+                //Remove the triple internally used to represent an empty Representation\n+                // ... this will only remove the triple if the Representation is empty\n+                //     but a check would take longer than the this call\n+                nodeGraph.remove(new TripleImpl(uri,MANAGED_REPRESENTATION,TRUE_LITERAL));\n+                return ((RdfValueFactory)valueFactory).createRdfRepresentation(uri, nodeGraph);\n+            } else {\n+                return null; //not found\n+            }\n+        } finally {\n+            readLock.unlock();\n+        }\n+    }\n+    /**\n+     * Extracts the triples that belong to the {@link Representation} with the\n+     * parsed id from the parsed graph. The graph is not modified and changes\n+     * in the returned graph will not affect the parsed graph.\n+     * @param id the {@link UriRef} node representing the id of the Representation.\n+     * @param graph the Graph to extract the representation from\n+     * @return the extracted graph.\n+     */\n+    protected MGraph createRepresentationGraph(UriRef id, TripleCollection graph){\n+        return extractRepresentation(graph, new SimpleMGraph(), id, new HashSet<BNode>());\n+    }\n+    /**\n+     * Recursive Method internally doing all the work for \n+     * {@link #createRepresentationGraph(UriRef, TripleCollection)}\n+     * @param source The graph to extract the Representation (source)\n+     * @param target The graph to store the extracted triples (target)\n+     * @param node the current node. Changes in recursive calls as it follows\n+     * @param visited holding all the visited BNodes to avoid cycles. Other nodes \n+     * need not be added because this implementation would not follow it anyway\n+     * outgoing relations if the object is a {@link BNode} instance.\n+     * @return the target graph (for convenience)\n+     */\n+    private MGraph extractRepresentation(TripleCollection source,MGraph target, NonLiteral node, Set<BNode> visited){\n+        //we need all the outgoing relations and also want to follow bNodes until\n+        //the next UriRef. However we are not interested in incoming relations!\n+        Iterator<Triple> outgoing = source.filter((NonLiteral) node, null, null);\n+        while (outgoing.hasNext()) {\n+            Triple triple = outgoing.next();\n+            target.add(triple);\n+            Resource object = triple.getObject();\n+            if(object instanceof BNode){\n+                //add first and than follow because there might be a triple such as\n+                // bnode1 <urn:someProperty> bnode1\n+                visited.add((BNode)object);\n+                extractRepresentation(source, target, (NonLiteral)object, visited);\n+            }\n         }\n+        return target;\n     }\n \n     @Override\n     public boolean isRepresentation(String id) {\n-        return id!=null?graph.filter(new UriRef(id), ENTITYHUB_LABEL_URIREF , null).hasNext():null;\n+        if(id == null) {\n+            throw new NullPointerException(\"The parsed id MUST NOT be NULL!\");\n+        }\n+        if(id.isEmpty()){\n+            throw new IllegalArgumentException(\"The parsed id MUST NOT be EMPTY!\");\n+        }\n+        //search for any outgoing triple\n+        return isRepresentation(new UriRef(id));\n+    }\n+    /**\n+     * Internally used to check if a URI resource represents an representation\n+     * @param resource the resource to check\n+     * @return the state\n+     */\n+    protected boolean isRepresentation(UriRef resource){\n+        return graph.filter(resource, null, null).hasNext();\n     }\n \n     @Override\n     public void remove(String id) throws IllegalArgumentException {\n-        if(id == null) return;\n+        if(id == null) {\n+            throw new NullPointerException(\"The parsed Representation id MUST NOT be NULL!\");\n+        }\n         UriRef resource = new UriRef(id);\n         Lock writeLock = graph.getLock().writeLock();\n         writeLock.lock();\n         try {\n-            if(graph.filter(resource, RDF.type, REPRESENTATION).hasNext()){\n-                GraphNode node = new GraphNode(resource, graph);\n-                /*\n-                 * Currently the \"context\" of the Clerezza GraphNode implementation\n-                 * is used for CRUD operations on Representations.\n-                 * This includes incoming and outgoing relations the resource and\n-                 * recursively bNodes.\n-                 */\n-                node.deleteNodeContext();\n+            if(isRepresentation(resource)){\n+                graph.removeAll(createRepresentationGraph(resource, graph));\n             } //else not found  -> nothing to do\n         }finally {\n             writeLock.unlock();\n@@ -203,10 +285,12 @@ public void remove(String id) throws IllegalArgumentException {\n     @Override\n     public void remove(Iterable<String> ids) throws IllegalArgumentException, YardException {\n         if(ids == null){\n-            throw new IllegalArgumentException(\"The parsed Iterable over the IDs to remove MUST NOT be NULL!\");\n+            throw new NullPointerException(\"The parsed Iterable over the IDs to remove MUST NOT be NULL!\");\n         }\n         for(String id : ids){\n-            remove(id);\n+            if(id != null){\n+                remove(id);\n+            } //else ignore null values within the parsed Iterable\n         }\n     }\n     @Override\n@@ -216,7 +300,7 @@ public Representation store(Representation representation) throws IllegalArgumen\n     @Override\n     public Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException {\n         if(representations == null){\n-            throw new IllegalArgumentException(\"The parsed Iterable over the Representations to store MUST NOT be NULL!\");\n+            throw new NullPointerException(\"The parsed Iterable over the Representations to store MUST NOT be NULL!\");\n         }\n         return store(representations, true);\n     }\n@@ -227,14 +311,23 @@ public Representation update(Representation representation) throws IllegalArgume\n     @Override\n     public Iterable<Representation> update(Iterable<Representation> representations) throws YardException, IllegalArgumentException {\n         if(representations == null){\n-            throw new IllegalArgumentException(\"The parsed Iterable over the Representations to update MUST NOT be NULL!\");\n+            throw new NullPointerException(\"The parsed Iterable over the Representations to update MUST NOT be NULL!\");\n         }\n         return store(representations,false);\n     }\n     protected final Iterable<Representation> store(Iterable<Representation> representations,boolean allowCreate) throws IllegalArgumentException, YardException{\n         ArrayList<Representation> added = new ArrayList<Representation>();\n         for(Representation representation : representations){\n-            added.add(store(representation,allowCreate,false));\n+            if(representation != null){\n+                Representation stored = store(representation,allowCreate,false); //reassign\n+                //to check if the store was successful\n+                if(stored != null){\n+                    added.add(stored);\n+                } else { //can only be the case if allowCreate==false (update was called)\n+                    log.warn(String.format(\"Unable to update Representation %s in Yard %s because it is not present!\",\n+                        representation.getId(),getId()));\n+                }\n+            } //ignore null values in the parsed Iterable!\n         }\n         return added;\n     }\n@@ -248,7 +341,7 @@ protected final Representation store(Representation representation,boolean allow\n //            log.info(\"  > entityhub size: \"+graph.size());\n         } else if(!allowCreate){\n             if(canNotCreateIsError) {\n-                throw new YardException(\"Parsed Representation \"+representation.getId()+\" in not managed by this Yard \"+getName()+\"(id=\"+getId()+\")\");\n+                throw new IllegalArgumentException(\"Parsed Representation \"+representation.getId()+\" in not managed by this Yard \"+getName()+\"(id=\"+getId()+\")\");\n             } else {\n                 return null;\n             }\n@@ -260,6 +353,12 @@ protected final Representation store(Representation representation,boolean allow\n         writeLock.lock();\n         try {\n             graph.addAll(toAdd.getRdfGraph());\n+            //also add the representation type within the Representation\n+            //TODO: Note somewhere that this Triple is reserved and MUST NOT\n+            //      be used by externally.\n+            if(!toAdd.getRdfGraph().filter(toAdd.getNode(), null, null).hasNext()){\n+                graph.add(new TripleImpl(toAdd.getNode(), MANAGED_REPRESENTATION, TRUE_LITERAL));\n+            }\n         } finally {\n             writeLock.unlock();\n         }",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/yard/clerezza/src/main/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYard.java",
                "sha": "cc16b580daf4c3322a0aa6916412f7817771a18d",
                "status": "modified"
            },
            {
                "additions": 62,
                "blob_url": "https://github.com/apache/stanbol/blob/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java",
                "changes": 62,
                "contents_url": "https://api.github.com/repos/apache/stanbol/contents/entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java?ref=89a09e92746f5ff9b1879a3cdcdfd84543634f77",
                "deletions": 0,
                "filename": "entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java",
                "patch": "@@ -0,0 +1,62 @@\n+package org.apache.stanbol.entityhub.yard.clerezza.impl;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.clerezza.rdf.ontologies.RDF;\n+import org.apache.stanbol.entityhub.core.yard.SimpleYardConfig;\n+import org.apache.stanbol.entityhub.core.yard.AbstractYard.YardConfig;\n+import org.apache.stanbol.entityhub.servicesapi.model.Reference;\n+import org.apache.stanbol.entityhub.servicesapi.model.Representation;\n+import org.apache.stanbol.entityhub.servicesapi.model.ValueFactory;\n+import org.apache.stanbol.entityhub.servicesapi.model.rdf.RdfResourceEnum;\n+import org.apache.stanbol.entityhub.servicesapi.yard.Yard;\n+import org.apache.stanbol.entityhub.servicesapi.yard.YardException;\n+import org.apache.stanbol.entityhub.test.yard.YardTest;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.sun.source.tree.AssertTree;\n+\n+public class ClerezzaYardTest extends YardTest {\n+    \n+    private Yard yard;\n+    \n+    @Before\n+    public final void initYard(){\n+        YardConfig config = new SimpleYardConfig(\"urn:yard.clerezza:testYardId\");\n+        config.setName(\"Clerezza Yard Test\");\n+        config.setDescription(\"The Clerezza Yard instance used to execute the Unit Tests defined for the Yard Interface\");\n+        yard = new ClerezzaYard(config);\n+    }\n+    \n+    @Override\n+    protected Yard getYard() {\n+        return yard;\n+    }\n+    \n+    /**\n+     * The Clerezza Yard uses the Statement<br>\n+     * <code>representationId -> rdf:type -> Representation</code><br>\n+     * to identify that an UriRef in the RDF graph (MGraph) represents a\n+     * Representation. This Triple is added when a Representation is stored and\n+     * removed if retrieved from the Yard.<p>\n+     * This tests if this functions as expected\n+     * @throws YardException\n+     */\n+    @Test\n+    public void testRemovalOfTypeRepresentationStatement() throws YardException {\n+        Yard yard = getYard();\n+        ValueFactory vf = yard.getValueFactory();\n+        Reference representationType = vf.createReference(RdfResourceEnum.Representation.getUri());\n+        Representation test = create();\n+        //the rdf:type Representation MUST NOT be within the Representation\n+        Assert.assertFalse(test.get(RDF.type.getUnicodeString()).hasNext());\n+        //now add the statement and see if an IllegalStateException is thrown\n+        /*\n+         * The triple within this Statement is internally used to \"mark\" the\n+         * URI of the Representation as \n+         */\n+        test.add(RDF.type.getUnicodeString(), representationType);\n+    }\n+    \n+}",
                "raw_url": "https://github.com/apache/stanbol/raw/89a09e92746f5ff9b1879a3cdcdfd84543634f77/entityhub/yard/clerezza/src/test/java/org/apache/stanbol/entityhub/yard/clerezza/impl/ClerezzaYardTest.java",
                "sha": "7a99322b398e34bd6a298dc70ba974898cabe448",
                "status": "added"
            }
        ],
        "message": "STANBOL-62: Added Unit Tests for the Yard Interface and applied them for the Clerezza based Yard implementation\n\nDetails:\n\nYard Interface\n - Added YardException to the create(..) methods\n - Adapt JavaDoc to make clear, that the create(..) methods create and store a representation within the yard\n - Converted all IllegalArgumentException that was declared as thrown when null is parsed to NullPointerExceptions\n\nUnit Test Framework\n - added the abstract YardTest class that defines around 50 Unit tests to be used for each Yard Implementation\n - Moved an utility method used previously only within the unit tests for Representation to an own utility class to have it available for all unit test classes\n\nClerezzaYard\n - adaptions to the changes in the Yard Interface\n - added several Exceptions that where not correctly thrown when illegal arguments where parsed.\n - The ClerezzaYard does no longer use the Clerezza GraphNode utility, because this Utility uses outgoing AND incoming relations as context of an resource. An representation as defined by the Entityhub only considers outgoing relations as context. Therefore using the GraphNode caused unnecessary triples to be copied. In addition when removing an Representation there was the danger that also incoming relations where deleted (something that MUST NOT be the case)\n - The check for if an Representation is stored within a Yard was outdated and no longer in sync with the current implementation of Representation. The old representation was replaced with one that does no longer make any assumption on any kind of structure within an Representation.\n - Activated Unit Tests for the Clerezza Yard implementation\n\nother:\n - various changes needed because the yard.create(..) methods now throw a YardException\n\nopen issues\n - Activate the Yard unit tests for the SolrYard implementation. To do that  without external dependencies it is necessary to support an embedded Solr Server Mode for the SolrYard - a Feature that would be nice anyway (created STANBOL-63).\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/stanbol/trunk@1066040 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/stanbol/commit/4aaf982c74d012d567edbecf2d9934339cd949e2",
        "patched_files": [
            "pom.xml",
            "Representation.java",
            "Yard.java",
            "ClerezzaYard.java",
            "AbstractYard.java",
            "SimpleYardConfig.java",
            "GeoNamesIndexer.java",
            "CacheImpl.java",
            "RdfRepresentation.java",
            "Utils.java"
        ],
        "repo": "stanbol",
        "unit_tests": [
            "RdfRepresentationTest.java",
            "RepresentationTest.java",
            "ClerezzaYardTest.java",
            "YardTest.java"
        ]
    }
}