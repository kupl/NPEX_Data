[
    {
        "repo": "calcite",
        "message": "[CALCITE-3246] NullPointerException while deserializing udf operator (Wang Yanlin).",
        "commit": "https://github.com/apache/calcite/commit/1268950211c8b1ff3888919b704fddfee58887cd",
        "parent": "https://github.com/apache/calcite/commit/ff44204dc2899e0c34e94f70c2e0c301170daca3",
        "bug_id": "calcite_1",
        "file": [
            {
                "sha": "005de2ad6b4496859fb189814bb807a9bf4cc957",
                "filename": "core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java",
                "blob_url": "https://github.com/apache/calcite/blob/1268950211c8b1ff3888919b704fddfee58887cd/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java",
                "raw_url": "https://github.com/apache/calcite/raw/1268950211c8b1ff3888919b704fddfee58887cd/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java",
                "status": "modified",
                "changes": 14,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java?ref=1268950211c8b1ff3888919b704fddfee58887cd",
                "patch": "@@ -454,13 +454,15 @@ RexNode toRex(RelInput relInput, Object o) {\n       final Map<String, Object> opMap = (Map) map.get(\"op\");\n       final RelDataTypeFactory typeFactory = cluster.getTypeFactory();\n       if (opMap != null) {\n-        final String op = (String) opMap.get(\"name\");\n+        if (map.containsKey(\"class\")) {\n+          opMap.put(\"class\", map.get(\"class\"));\n+        }\n         final List operands = (List) map.get(\"operands\");\n         final List<RexNode> rexOperands = toRexList(relInput, operands);\n         final Object jsonType = map.get(\"type\");\n         final Map window = (Map) map.get(\"window\");\n         if (window != null) {\n-          final SqlAggFunction operator = toAggregation(relInput, op, opMap);\n+          final SqlAggFunction operator = toAggregation(opMap);\n           final RelDataType type = toType(typeFactory, jsonType);\n           List<RexNode> partitionKeys = new ArrayList<>();\n           if (window.containsKey(\"partition\")) {\n@@ -492,7 +494,7 @@ RexNode toRex(RelInput relInput, Object o) {\n               ImmutableList.copyOf(orderKeys), lowerBound, upperBound, physical,\n               true, false, distinct, false);\n         } else {\n-          final SqlOperator operator = toOp(relInput, opMap);\n+          final SqlOperator operator = toOp(opMap);\n           final RelDataType type;\n           if (jsonType != null) {\n             type = toType(typeFactory, jsonType);\n@@ -632,7 +634,7 @@ private RexWindowBound toRexWindowBound(RelInput input, Map<String, Object> map)\n     return list;\n   }\n \n-  SqlOperator toOp(RelInput relInput, Map<String, Object> map) {\n+  SqlOperator toOp(Map<String, Object> map) {\n     // in case different operator has the same kind, check with both name and kind.\n     String name = map.get(\"name\").toString();\n     String kind = map.get(\"kind\").toString();\n@@ -658,8 +660,8 @@ SqlOperator toOp(RelInput relInput, Map<String, Object> map) {\n     return null;\n   }\n \n-  SqlAggFunction toAggregation(RelInput relInput, String agg, Map<String, Object> map) {\n-    return (SqlAggFunction) toOp(relInput, map);\n+  SqlAggFunction toAggregation(Map<String, Object> map) {\n+    return (SqlAggFunction) toOp(map);\n   }\n \n   private Map toJson(SqlOperator operator) {",
                "deletions": 6
            },
            {
                "sha": "d6b651b501b0f79201b4f7615f7f78cdc0b627e0",
                "filename": "core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java",
                "blob_url": "https://github.com/apache/calcite/blob/1268950211c8b1ff3888919b704fddfee58887cd/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java",
                "raw_url": "https://github.com/apache/calcite/raw/1268950211c8b1ff3888919b704fddfee58887cd/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java?ref=1268950211c8b1ff3888919b704fddfee58887cd",
                "patch": "@@ -275,7 +275,7 @@ public RelDistribution getDistribution() {\n   private AggregateCall toAggCall(RelInput relInput, Map<String, Object> jsonAggCall) {\n     final Map<String, Object> aggMap = (Map) jsonAggCall.get(\"agg\");\n     final SqlAggFunction aggregation =\n-        relJson.toAggregation(relInput, (String) aggMap.get(\"name\"), aggMap);\n+        relJson.toAggregation(aggMap);\n     final Boolean distinct = (Boolean) jsonAggCall.get(\"distinct\");\n     @SuppressWarnings(\"unchecked\")\n     final List<Integer> operands = (List<Integer>) jsonAggCall.get(\"operands\");",
                "deletions": 1
            },
            {
                "sha": "c5a26c7fa0ffe63e0e3c4ba5ead4239f7937dc9e",
                "filename": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/1268950211c8b1ff3888919b704fddfee58887cd/core/src/test/java/org/apache/calcite/plan/RelWriterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/1268950211c8b1ff3888919b704fddfee58887cd/core/src/test/java/org/apache/calcite/plan/RelWriterTest.java",
                "status": "modified",
                "changes": 19,
                "additions": 19,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/plan/RelWriterTest.java?ref=1268950211c8b1ff3888919b704fddfee58887cd",
                "patch": "@@ -51,6 +51,7 @@\n import org.apache.calcite.sql.parser.SqlParserPos;\n import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.test.JdbcTest;\n+import org.apache.calcite.test.MockSqlOperatorTable;\n import org.apache.calcite.test.RelBuilderTest;\n import org.apache.calcite.tools.FrameworkConfig;\n import org.apache.calcite.tools.Frameworks;\n@@ -742,6 +743,24 @@\n     assertThat(s, isLinux(expected));\n   }\n \n+  @Test public void testUdf() {\n+    final FrameworkConfig config = RelBuilderTest.config().build();\n+    final RelBuilder builder = RelBuilder.create(config);\n+    final RelNode rel = builder\n+        .scan(\"EMP\")\n+        .project(\n+            builder.call(new MockSqlOperatorTable.MyFunction(),\n+                builder.field(\"EMPNO\")))\n+        .build();\n+    String relJson = RelOptUtil.dumpPlan(\"\", rel,\n+        SqlExplainFormat.JSON, SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n+    String s = deserializeAndDumpToTextFormat(getSchema(rel), relJson);\n+    final String expected = \"\"\n+        + \"LogicalProject($f0=[MYFUN($0)])\\n\"\n+        + \"  LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(s, isLinux(expected));\n+  }\n+\n   /** Returns the schema of a {@link org.apache.calcite.rel.core.TableScan}\n    * in this plan, or null if there are no scans. */\n   private RelOptSchema getSchema(RelNode rel) {",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3474] NullPointerException in SqlSimpleParser toke.s.equals() (Xiucheng Qu)\n\nClose #1558",
        "commit": "https://github.com/apache/calcite/commit/4d1c3e54fc4172c7ff00db3326823c42f237cf04",
        "parent": "https://github.com/apache/calcite/commit/6ee48c66c8a51bfd9734b20927e4c2e919575bc4",
        "bug_id": "calcite_2",
        "file": [
            {
                "sha": "2e29d6de1a7f19669f04b1fcb9a29dcd232958fc",
                "filename": "core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java",
                "blob_url": "https://github.com/apache/calcite/blob/4d1c3e54fc4172c7ff00db3326823c42f237cf04/core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java",
                "raw_url": "https://github.com/apache/calcite/raw/4d1c3e54fc4172c7ff00db3326823c42f237cf04/core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java",
                "status": "modified",
                "changes": 10,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java?ref=4d1c3e54fc4172c7ff00db3326823c42f237cf04",
                "patch": "@@ -196,7 +196,7 @@ private void consumeQuery(ListIterator<Token> iter, List<Token> outList) {\n           if (iter.hasNext()) {\n             token = iter.next();\n             if ((token.type == TokenType.ID)\n-                && token.s.equalsIgnoreCase(\"ALL\")) {\n+                && \"ALL\".equalsIgnoreCase(token.s)) {\n               outList.add(token);\n             } else {\n               iter.previous();\n@@ -521,7 +521,7 @@ public Query simplify(String hintToken) {\n         for (Token token : tokenList) {\n           switch (token.type) {\n           case ID:\n-            if (token.s.equals(hintToken)) {\n+            if (hintToken.equals(token.s)) {\n               foundInClause = clause;\n             }\n             break;\n@@ -652,7 +652,7 @@ private void purgeSelectListExcept(String hintToken) {\n           }\n           break;\n         case ID:\n-          if (token.s.equals(hintToken)) {\n+          if (hintToken.equals(token.s)) {\n             found = true;\n           }\n         }\n@@ -735,7 +735,7 @@ private void purgeFromExcept(String hintToken) {\n           itemStart = i + 1;\n           break;\n         case ID:\n-          if (token.s.equals(hintToken)) {\n+          if (hintToken.equals(token.s)) {\n             found = true;\n           }\n         }\n@@ -815,7 +815,7 @@ private boolean contains(String hintToken) {\n       for (Token token : tokenList) {\n         switch (token.type) {\n         case ID:\n-          if (token.s.equals(hintToken)) {\n+          if (hintToken.equals(token.s)) {\n             return true;\n           }\n           break;",
                "deletions": 5
            },
            {
                "sha": "ace3ebf65591bba36c8989f50e781499d58cdaab",
                "filename": "core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/4d1c3e54fc4172c7ff00db3326823c42f237cf04/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/4d1c3e54fc4172c7ff00db3326823c42f237cf04/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "status": "modified",
                "changes": 4,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java?ref=4d1c3e54fc4172c7ff00db3326823c42f237cf04",
                "patch": "@@ -961,6 +961,10 @@ private String convertCompletionHints(List<SqlMoniker> hints) {\n \n     sql = \"select t.x from (select 1 as x, 2 as y from sales.^) as t\";\n     assertComplete(sql, getSalesTables());\n+\n+    // CALCITE-3474:SqlSimpleParser toke.s equals NullPointerException\n+    sql = \"select ^ from (select * from sales.emp) as t\";\n+    assertComplete(sql, getSelectKeywords(), tTable, EMP_COLUMNS, EXPR_KEYWORDS);\n   }\n \n   @Test public void testSubQueryInWhere() {",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3725] RelMetadataTest fails with NPE due to unsafe RelMetadataQuery.instance call (Jin Xing)",
        "commit": "https://github.com/apache/calcite/commit/5fc2fda637429d8810692fcab4c2d50c5448288b",
        "parent": "https://github.com/apache/calcite/commit/5cfd8c31cea1bf5411e503b15714cab5fc1c0d0a",
        "bug_id": "calcite_3",
        "file": [
            {
                "sha": "29ecb5df55a057f1304fef9ebfdfb6f7153f9d32",
                "filename": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/5fc2fda637429d8810692fcab4c2d50c5448288b/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/5fc2fda637429d8810692fcab4c2d50c5448288b/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
                "status": "modified",
                "changes": 34,
                "additions": 17,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java?ref=5fc2fda637429d8810692fcab4c2d50c5448288b",
                "patch": "@@ -1018,8 +1018,8 @@ private boolean isUnique(Set<ImmutableBitSet> uniqueKeys, ImmutableBitSet key) {\n   }\n \n   private void checkColumnUniquenessForFilterWithConstantColumns(String sql) {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(sql);\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(rel.getRowType().getFieldNames().toString(),\n         is(\"[DEPTNO, SAL]\"));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n@@ -1028,61 +1028,60 @@ private void checkColumnUniquenessForFilterWithConstantColumns(String sql) {\n   }\n \n   @Test public void testColumnUniquenessForUnionWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final String sql = \"\"\n         + \"select deptno, sal from emp where sal=1000\\n\"\n         + \"union\\n\"\n         + \"select deptno, sal from emp where sal=1000\\n\";\n     final RelNode rel = convertSql(sql);\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(rel.getRowType().getFieldNames().toString(),\n         is(\"[DEPTNO, SAL]\"));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n   }\n \n   @Test public void testColumnUniquenessForIntersectWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final String sql = \"\"\n         + \"select deptno, sal\\n\"\n         + \"from (select distinct deptno, sal from emp)\\n\"\n         + \"where sal=1000\\n\"\n         + \"intersect all\\n\"\n         + \"select deptno, sal from emp\\n\";\n     final RelNode rel = convertSql(sql);\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(rel.getRowType().getFieldNames().toString(),\n         is(\"[DEPTNO, SAL]\"));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n   }\n \n   @Test public void testColumnUniquenessForMinusWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final String sql = \"\"\n         + \"select deptno, sal\\n\"\n         + \"from (select distinct deptno, sal from emp)\\n\"\n         + \"where sal=1000\\n\"\n         + \"except all\\n\"\n         + \"select deptno, sal from emp\\n\";\n     final RelNode rel = convertSql(sql);\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(rel.getRowType().getFieldNames().toString(),\n         is(\"[DEPTNO, SAL]\"));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0)), is(true));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n   }\n \n   @Test public void testColumnUniquenessForSortWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final String sql = \"\"\n         + \"select *\\n\"\n         + \"from (select distinct deptno, sal from emp)\\n\"\n         + \"where sal=1000\\n\"\n         + \"order by deptno\";\n     final RelNode rel = convertSql(sql);\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(rel.getRowType().getFieldNames().toString(),\n         is(\"[DEPTNO, SAL]\"));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(true));\n   }\n \n   @Test public void testColumnUniquenessForJoinWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final String sql = \"\"\n         + \"select *\\n\"\n         + \"from (select distinct deptno, sal from emp) A\\n\"\n@@ -1091,25 +1090,25 @@ private void checkColumnUniquenessForFilterWithConstantColumns(String sql) {\n     final RelNode rel = convertSql(sql);\n     assertThat(rel.getRowType().getFieldNames().toString(),\n         is(\"[DEPTNO, SAL, DEPTNO0, SAL0]\"));\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 2)), is(true));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1, 2)), is(true));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 2, 3)), is(true));\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(0, 1)), is(false));\n   }\n \n   @Test public void testColumnUniquenessForAggregateWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final String sql = \"\"\n         + \"select deptno, ename, sum(sal)\\n\"\n         + \"from emp\\n\"\n         + \"where deptno=1010\\n\"\n         + \"group by deptno, ename\";\n     final RelNode rel = convertSql(sql);\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.areColumnsUnique(rel, ImmutableBitSet.of(1)), is(true));\n   }\n \n   @Test public void testColumnUniquenessForExchangeWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final FrameworkConfig config = RelBuilderTest.config().build();\n     final RelBuilder builder = RelBuilder.create(config);\n     RelNode exchange = builder.scan(\"EMP\")\n@@ -1118,11 +1117,11 @@ private void checkColumnUniquenessForFilterWithConstantColumns(String sql) {\n         .filter(builder.equals(builder.field(\"SAL\"), builder.literal(1)))\n         .exchange(RelDistributions.hash(ImmutableList.of(1)))\n         .build();\n+    final RelMetadataQuery mq = exchange.getCluster().getMetadataQuery();\n     assertThat(mq.areColumnsUnique(exchange, ImmutableBitSet.of(0)), is(true));\n   }\n \n   @Test public void testColumnUniquenessForCorrelateWithConstantColumns() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final FrameworkConfig config = RelBuilderTest.config().build();\n     final RelBuilder builder = RelBuilder.create(config);\n     RelNode rel0 = builder.scan(\"EMP\")\n@@ -1142,6 +1141,7 @@ private void checkColumnUniquenessForFilterWithConstantColumns(String sql) {\n         .push(rel1)\n         .correlate(JoinRelType.SEMI, v.get().id, builder.field(2, 0, \"DEPTNO\"))\n         .build();\n+    final RelMetadataQuery mq = correl.getCluster().getMetadataQuery();\n     assertThat(mq.areColumnsUnique(correl, ImmutableBitSet.of(0)), is(true));\n   }\n \n@@ -1965,85 +1965,85 @@ private void checkPredicates(RelOptCluster cluster, RelOptTable empTable,\n   }\n \n   @Test public void testPullUpPredicatesFromUnion0() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno from emp where empno=1\\n\"\n         + \"union all\\n\"\n         + \"select empno from emp where empno=1\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[=($0, 1)]\"));\n   }\n \n   @Test public void testPullUpPredicatesFromUnion1() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno, deptno from emp where empno=1 or deptno=2\\n\"\n         + \"union all\\n\"\n         + \"select empno, deptno from emp where empno=3 or deptno=4\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[OR(=($0, 1), =($1, 2), =($0, 3), =($1, 4))]\"));\n   }\n \n   @Test public void testPullUpPredicatesFromUnion2() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno, comm, deptno from emp where empno=1 and comm=2 and deptno=3\\n\"\n         + \"union all\\n\"\n         + \"select empno, comm, deptno from emp where empno=1 and comm=4\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[=($0, 1), OR(AND(=($2, 3), =($1, 2)), =($1, 4))]\"));\n \n   }\n \n   @Test public void testPullUpPredicatesFromIntersect0() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno from emp where empno=1\\n\"\n         + \"intersect all\\n\"\n         + \"select empno from emp where empno=1\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[=($0, 1)]\"));\n \n   }\n \n   @Test public void testPullUpPredicatesFromIntersect1() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno, deptno, comm from emp where empno=1 and deptno=2\\n\"\n         + \"intersect all\\n\"\n         + \"select empno, deptno, comm from emp where empno=1 and comm=3\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[=($0, 1), =($1, 2), =($2, 3)]\"));\n \n   }\n \n   @Test public void testPullUpPredicatesFromIntersect2() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno, deptno, comm from emp where empno=1 and deptno=2\\n\"\n         + \"intersect all\\n\"\n         + \"select empno, deptno, comm from emp where 1=empno and (deptno=2 or comm=3)\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[=($0, 1), =($1, 2)]\"));\n \n   }\n \n   @Test public void testPullUpPredicatesFromIntersect3() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno, deptno, comm from emp where empno=1 or deptno=2\\n\"\n         + \"intersect all\\n\"\n         + \"select empno, deptno, comm from emp where deptno=2 or empno=1 or comm=3\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[OR(=($0, 1), =($1, 2))]\"));\n   }\n \n   @Test public void testPullUpPredicatesFromMinus() {\n-    final RelMetadataQuery mq = RelMetadataQuery.instance();\n     final RelNode rel = convertSql(\"\"\n         + \"select empno, deptno, comm from emp where empno=1 and deptno=2\\n\"\n         + \"except all\\n\"\n         + \"select empno, deptno, comm from emp where comm=3\");\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n     assertThat(mq.getPulledUpPredicates(rel).pulledUpPredicates,\n         sortsAs(\"[=($0, 1), =($1, 2)]\"));\n   }",
                "deletions": 17
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3651] NPE when convert relational algebra that correlates TableFunctionScan (Wang Yanlin)",
        "commit": "https://github.com/apache/calcite/commit/3dd6d850adc6a0d7b14bedac0e431047c63beb3c",
        "parent": "https://github.com/apache/calcite/commit/7dcceeedbc9bb28167f3b7497a8eee1429bc51f6",
        "bug_id": "calcite_4",
        "file": [
            {
                "sha": "06dcb10ef92fdb4a2be25bfe6eb4ae609d092e85",
                "filename": "core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/3dd6d850adc6a0d7b14bedac0e431047c63beb3c/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/3dd6d850adc6a0d7b14bedac0e431047c63beb3c/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java",
                "status": "modified",
                "changes": 4,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java?ref=3dd6d850adc6a0d7b14bedac0e431047c63beb3c",
                "patch": "@@ -881,9 +881,7 @@ public Result visit(TableFunctionScan e) {\n     SqlNode select = new SqlSelect(\n         SqlParserPos.ZERO, null, null, tableCall,\n         null, null, null, null, null, null, null, SqlNodeList.EMPTY);\n-    Result x = new Result(select,\n-        ImmutableList.of(Clause.SELECT), null, e.getRowType(), null);\n-    return x;\n+    return result(select, ImmutableList.of(Clause.SELECT), e, null);\n   }\n \n   /**",
                "deletions": 3
            },
            {
                "sha": "4ba0ae2cb3004bebad1c10b9aa2213f37fbf6aeb",
                "filename": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/3dd6d850adc6a0d7b14bedac0e431047c63beb3c/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/3dd6d850adc6a0d7b14bedac0e431047c63beb3c/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "status": "modified",
                "changes": 13,
                "additions": 13,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java?ref=3dd6d850adc6a0d7b14bedac0e431047c63beb3c",
                "patch": "@@ -3734,6 +3734,19 @@ private void checkLiteral2(String expression, String expected) {\n     sql(sql).ok(expected);\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3651\">[CALCITE-3651]\n+   * NullPointerException when convert relational algebra that correlates TableFunctionScan</a>. */\n+  @Test public void testLateralCorrelate() {\n+    final String query = \"select * from \\\"product\\\",\\n\"\n+        + \"lateral table(RAMP(\\\"product\\\".\\\"product_id\\\"))\";\n+    final String expected = \"SELECT *\\n\"\n+        + \"FROM \\\"foodmart\\\".\\\"product\\\" AS \\\"$cor0\\\",\\n\"\n+        + \"LATERAL (SELECT *\\n\"\n+        + \"FROM TABLE(RAMP(\\\"$cor0\\\".\\\"product_id\\\"))) AS \\\"t\\\"\";\n+    sql(query).ok(expected);\n+  }\n+\n   @Test public void testUncollectExplicitAlias() {\n     final String sql = \"select did + 1 \\n\"\n         + \"from unnest(select collect(\\\"department_id\\\") as deptid\"",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3292] SqlToRelConverter#substituteSubQuery fails with NullPointerException when converting SqlUpdate (Jin Xing)",
        "commit": "https://github.com/apache/calcite/commit/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc",
        "parent": "https://github.com/apache/calcite/commit/72680df93ef089abd0a7c0ac8cdc6253619c2ebe",
        "bug_id": "calcite_5",
        "file": [
            {
                "sha": "9da2c3544626950bad1fade176c1c5d91dfa91c0",
                "filename": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "status": "modified",
                "changes": 10,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java?ref=b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc",
                "patch": "@@ -1102,6 +1102,16 @@ private void substituteSubQuery(Blackboard bb, SubQuery subQuery) {\n       //   where emp.deptno <> null\n       //         and q.indicator <> TRUE\"\n       //\n+      // Note:\n+      // Subquery can be used as SqlUpdate#condition like below:\n+      // \"update emp\n+      //  set empno = 1 where emp.empno in (\n+      //   select emp.empno from emp where emp.empno=2)\"\n+      // In such case, when converting SqlUpdate#condition, bb.root is null\n+      // and it makes no sense to do the subquery substituion.\n+      if (bb.root == null) {\n+        return;\n+      }\n       final RelDataType targetRowType =\n           SqlTypeUtil.promoteToRowType(typeFactory,\n               validator.getValidatedNodeType(leftKeyNode), null);",
                "deletions": 0
            },
            {
                "sha": "98f491786daa1ac245d7999d365d9834c76e3dce",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "status": "modified",
                "changes": 12,
                "additions": 12,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java?ref=b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc",
                "patch": "@@ -2202,6 +2202,18 @@ public void testJoinUsingDynamicTable() {\n     sql(sql).ok();\n   }\n \n+  /**\n+   * Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3292\">[CALCITE-3292]\n+   * NPE for UPDATE with IN query</a>.\n+   */\n+  @Test public void testUpdateSubQueryWithIn1() {\n+    final String sql = \"update emp\\n\"\n+            + \"set empno = 1 where emp.empno in (\\n\"\n+            + \"  select emp.empno from emp where emp.empno=2)\";\n+    sql(sql).ok();\n+  }\n+\n   /** Similar to {@link #testUpdateSubQueryWithIn()} but with not in instead of in. */\n   @Test public void testUpdateSubQueryWithNotIn() {\n     final String sql = \"update emp\\n\"",
                "deletions": 0
            },
            {
                "sha": "220b951949f5814710baa03bdd51a43cfc101714",
                "filename": "core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "blob_url": "https://github.com/apache/calcite/blob/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "raw_url": "https://github.com/apache/calcite/raw/b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "status": "modified",
                "changes": 19,
                "additions": 19,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml?ref=b8d24a6f7f2b4c7cb8093eea158f1fa00dbc6ffc",
                "patch": "@@ -4762,6 +4762,25 @@ LogicalTableModify(table=[[CATALOG, SALES, EMP]], operation=[UPDATE], updateColu\n           LogicalProject(EMPNO=[$0], $f1=[true])\n             LogicalFilter(condition=[=($0, 2)])\n               LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+]]>\n+        </Resource>\n+    </TestCase>\n+    <TestCase name=\"testUpdateSubQueryWithIn1\">\n+        <Resource name=\"sql\">\n+            <![CDATA[update emp\n+set empno = 1 where empno in (\n+  select empno from emp where empno=2)]]>\n+        </Resource>\n+        <Resource name=\"plan\">\n+            <![CDATA[\n+LogicalTableModify(table=[[CATALOG, SALES, EMP]], operation=[UPDATE], updateColumnList=[[EMPNO]], sourceExpressionList=[[1]], flattened=[true])\n+  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], EXPR$0=[1])\n+    LogicalJoin(condition=[=($0, $9)], joinType=[inner])\n+      LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+      LogicalAggregate(group=[{0}])\n+        LogicalProject(EMPNO=[$0])\n+          LogicalFilter(condition=[=($0, 2)])\n+            LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n ]]>\n         </Resource>\n     </TestCase>",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3536] NPE when executing plan with Coalesce due to wrong NullAs strategy (Jin Xing)\n\nClose apache/calcite#1605",
        "commit": "https://github.com/apache/calcite/commit/0e16fe375f797e498c0039fc7cffecfd0dc9bc3d",
        "parent": "https://github.com/apache/calcite/commit/abe7729fb1d6e9b9cfbe4cf498806f67991b618e",
        "bug_id": "calcite_6",
        "file": [
            {
                "sha": "d8e74af0e5516ce0f16a112deac051a4a6bf3fba",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/0e16fe375f797e498c0039fc7cffecfd0dc9bc3d/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/0e16fe375f797e498c0039fc7cffecfd0dc9bc3d/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "status": "modified",
                "changes": 4,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java?ref=0e16fe375f797e498c0039fc7cffecfd0dc9bc3d",
                "patch": "@@ -2612,10 +2612,10 @@ public Expression implement(RexToLixTranslator translator, RexCall call,\n     private Expression implementRecurse(RexToLixTranslator translator,\n         List<RexNode> operands, NullAs nullAs) {\n       if (operands.size() == 1) {\n-        return translator.translate(operands.get(0));\n+        return translator.translate(operands.get(0), nullAs);\n       } else {\n         return Expressions.condition(\n-            translator.translate(operands.get(0), NullAs.IS_NULL),\n+            translator.translate(operands.get(0), NullAs.IS_NOT_NULL),\n             translator.translate(operands.get(0), nullAs),\n             implementRecurse(translator, Util.skip(operands), nullAs));\n       }",
                "deletions": 2
            },
            {
                "sha": "1318f10c2b0377a1453e078d44dde5511e23b0f6",
                "filename": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/0e16fe375f797e498c0039fc7cffecfd0dc9bc3d/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/0e16fe375f797e498c0039fc7cffecfd0dc9bc3d/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java",
                "status": "added",
                "changes": 60,
                "additions": 60,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java?ref=0e16fe375f797e498c0039fc7cffecfd0dc9bc3d",
                "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Unit test for\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableCalc}\n+ */\n+public class EnumerableCalcTest {\n+\n+  /**\n+   * Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3536\">[CALCITE-3536]\n+   * NPE when executing plan with Coalesce due to wrong NullAs strategy</a>.\n+   */\n+  @Test public void testCoalesceImplementation() {\n+    CalciteAssert.that()\n+        .withSchema(\"s\", new ReflectiveSchema(new JdbcTest.HrSchema()))\n+        .query(\"?\")\n+        .withRel(\n+            builder -> builder\n+                .scan(\"s\", \"emps\")\n+                .project(\n+                  builder.call(\n+                    SqlStdOperatorTable.COALESCE,\n+                    builder.field(\"commission\"),\n+                    builder.literal(0)))\n+                .build()\n+        )\n+        .planContains(\"inp4_ != null ? inp4_.intValue() : 0;\")\n+        .returnsUnordered(\n+            \"$f0=0\",\n+            \"$f0=250\",\n+            \"$f0=500\",\n+            \"$f0=1000\");\n+  }\n+}\n+\n+// End EnumerableCalcTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3503] NPE at VolcanoPlanner#isValid when DEBUG is enabled (Xiening Dai)\n\nWhen planner root is null, we should skip the validation since the memo is\nempty at that moment.",
        "commit": "https://github.com/apache/calcite/commit/73417080f317fb925cf3978d40af6ba97129e3c8",
        "parent": "https://github.com/apache/calcite/commit/472523c4e0eb694f62c1da974d256553e2f33ce2",
        "bug_id": "calcite_7",
        "file": [
            {
                "sha": "c592290b5c5478814c8248895dd030d9d90eae6a",
                "filename": "core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
                "blob_url": "https://github.com/apache/calcite/blob/73417080f317fb925cf3978d40af6ba97129e3c8/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
                "raw_url": "https://github.com/apache/calcite/raw/73417080f317fb925cf3978d40af6ba97129e3c8/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
                "status": "modified",
                "changes": 4,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java?ref=73417080f317fb925cf3978d40af6ba97129e3c8",
                "patch": "@@ -877,6 +877,10 @@ public RelSubset ensureRegistered(RelNode rel, RelNode equivRel) {\n    * Checks internal consistency.\n    */\n   protected boolean isValid(Litmus litmus) {\n+    if (this.getRoot() == null) {\n+      return true;\n+    }\n+\n     RelMetadataQuery metaQuery = this.getRoot().getCluster().getMetadataQuerySupplier().get();\n     for (RelSet set : allSets) {\n       if (set.equivalentSet != null) {",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3420] NullPointerException throws for implicit type coercion of nested SET operations\n\nWe should update the nested SET operator node type when implicit type\ncoercion happens.\n\nThis bug fires when the non-first nested SET node triggers the\nimplicit type coercion.",
        "commit": "https://github.com/apache/calcite/commit/2ac44153c4a521694c4dc975dd37b097184fc998",
        "parent": "https://github.com/apache/calcite/commit/3cbbafa941128dc5097c2a26711f5751f764e12d",
        "bug_id": "calcite_8",
        "file": [
            {
                "sha": "e963c581eaf2d309d1a8498c2c520ed1d348435e",
                "filename": "core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java",
                "blob_url": "https://github.com/apache/calcite/blob/2ac44153c4a521694c4dc975dd37b097184fc998/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java",
                "raw_url": "https://github.com/apache/calcite/raw/2ac44153c4a521694c4dc975dd37b097184fc998/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java",
                "status": "modified",
                "changes": 7,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java?ref=2ac44153c4a521694c4dc975dd37b097184fc998",
                "patch": "@@ -297,22 +297,23 @@ protected void updateInferredType(SqlNode node, RelDataType type) {\n    * @param scope       validator scope\n    * @param query       node to inferred type\n    * @param columnIndex column index to update\n-   * @param targetType1 desired column type\n+   * @param desiredType desired column type\n    */\n   protected void updateInferredColumnType(\n       SqlValidatorScope scope,\n       SqlNode query,\n       int columnIndex,\n-      RelDataType targetType1) {\n+      RelDataType desiredType) {\n     final RelDataType rowType = validator.deriveType(scope, query);\n     assert rowType.isStruct();\n+    assert columnIndex < rowType.getFieldList().size();\n \n     final List<Map.Entry<String, RelDataType>> fieldList = new ArrayList<>();\n     for (int i = 0; i < rowType.getFieldCount(); i++) {\n       final RelDataTypeField field = rowType.getFieldList().get(i);\n       final String name = field.getName();\n       final RelDataType type = field.getType();\n-      final RelDataType targetType = i == columnIndex ? targetType1 : type;\n+      final RelDataType targetType = i == columnIndex ? desiredType : type;\n       fieldList.add(Pair.of(name, targetType));\n     }\n     updateInferredType(query, factory.createStructType(fieldList));",
                "deletions": 3
            },
            {
                "sha": "b5b438d144d049507d91f47a6711b5c738a9d7e8",
                "filename": "core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/2ac44153c4a521694c4dc975dd37b097184fc998/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/2ac44153c4a521694c4dc975dd37b097184fc998/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java",
                "status": "modified",
                "changes": 11,
                "additions": 9,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java?ref=2ac44153c4a521694c4dc975dd37b097184fc998",
                "patch": "@@ -106,8 +106,15 @@ public boolean rowTypeCoercion(\n     case INTERSECT:\n     case EXCEPT:\n       // Set operations are binary for now.\n-      return rowTypeCoercion(scope, ((SqlCall) query).operand(0), columnIndex, targetType)\n-          && rowTypeCoercion(scope, ((SqlCall) query).operand(1), columnIndex, targetType);\n+      final SqlCall operand0 = ((SqlCall) query).operand(0);\n+      final SqlCall operand1 = ((SqlCall) query).operand(1);\n+      final boolean coerced = rowTypeCoercion(scope, operand0, columnIndex, targetType)\n+          && rowTypeCoercion(scope, operand1, columnIndex, targetType);\n+      // Update the nested SET operator node type.\n+      if (coerced) {\n+        updateInferredColumnType(scope, query, columnIndex, targetType);\n+      }\n+      return coerced;\n     default:\n       return false;\n     }",
                "deletions": 2
            },
            {
                "sha": "25d29baa3d0cecd80a1f0336f84ad29197e40f40",
                "filename": "core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/2ac44153c4a521694c4dc975dd37b097184fc998/core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/2ac44153c4a521694c4dc975dd37b097184fc998/core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java",
                "status": "modified",
                "changes": 11,
                "additions": 11,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java?ref=2ac44153c4a521694c4dc975dd37b097184fc998",
                "patch": "@@ -473,6 +473,17 @@ assert equals(result1, expected)\n             + \" DECIMAL(19, 0) NOT NULL T1_DECIMAL,\"\n             + \" FLOAT NOT NULL T1_SMALLINT,\"\n             + \" DOUBLE NOT NULL T1_DOUBLE) NOT NULL\");\n+    // (int) union (int) union (varchar(20))\n+    sql(\"select t1_int from t1 \"\n+        + \"union select t2_int from t2 \"\n+        + \"union select t1_varchar20 from t1\")\n+        .columnType(\"VARCHAR NOT NULL\");\n+\n+    // (varchar(20)) union (int) union (int)\n+    sql(\"select t1_varchar20 from t1 \"\n+        + \"union select t2_int from t2 \"\n+        + \"union select t1_int from t1\")\n+        .columnType(\"VARCHAR NOT NULL\");\n \n     // intersect\n     sql(\"select t1_int, t1_decimal, t1_smallint, t1_double from t1 \"",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3045] NullPointerException when casting null literal to composite user defined type",
        "commit": "https://github.com/apache/calcite/commit/a8f46239509f01162c4e3ecf640a59cf0e0dfcad",
        "parent": "https://github.com/apache/calcite/commit/e3a69708df55cf05bbe38f8f1d5bd472cf8de81f",
        "bug_id": "calcite_9",
        "file": [
            {
                "sha": "f79e247202a29edec30e482c715b59b73ada58e9",
                "filename": "core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/a8f46239509f01162c4e3ecf640a59cf0e0dfcad/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/a8f46239509f01162c4e3ecf640a59cf0e0dfcad/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java",
                "status": "modified",
                "changes": 12,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java?ref=a8f46239509f01162c4e3ecf640a59cf0e0dfcad",
                "patch": "@@ -527,18 +527,18 @@ protected RexNode convertCast(\n     }\n     SqlDataTypeSpec dataType = (SqlDataTypeSpec) right;\n     RelDataType type = dataType.deriveType(typeFactory);\n-    if (SqlUtil.isNullLiteral(left, false)) {\n-      final SqlValidatorImpl validator = (SqlValidatorImpl) cx.getValidator();\n-      validator.setValidatedNodeType(left, type);\n-      return cx.convertExpression(left);\n-    }\n-    RexNode arg = cx.convertExpression(left);\n     if (type == null) {\n       type = cx.getValidator().getValidatedNodeType(dataType.getTypeName());\n     }\n+    RexNode arg = cx.convertExpression(left);\n     if (arg.getType().isNullable()) {\n       type = typeFactory.createTypeWithNullability(type, true);\n     }\n+    if (SqlUtil.isNullLiteral(left, false)) {\n+      final SqlValidatorImpl validator = (SqlValidatorImpl) cx.getValidator();\n+      validator.setValidatedNodeType(left, type);\n+      return cx.convertExpression(left);\n+    }\n     if (null != dataType.getCollectionsTypeName()) {\n       final RelDataType argComponentType =\n           arg.getType().getComponentType();",
                "deletions": 6
            },
            {
                "sha": "127eb3d56424a383c99b42400e0f5cdb559248c0",
                "filename": "core/src/test/java/org/apache/calcite/test/UdtTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/a8f46239509f01162c4e3ecf640a59cf0e0dfcad/core/src/test/java/org/apache/calcite/test/UdtTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/a8f46239509f01162c4e3ecf640a59cf0e0dfcad/core/src/test/java/org/apache/calcite/test/UdtTest.java",
                "status": "modified",
                "changes": 9,
                "additions": 9,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/UdtTest.java?ref=a8f46239509f01162c4e3ecf640a59cf0e0dfcad",
                "patch": "@@ -58,6 +58,15 @@\n         + \"from (VALUES ROW(1, 'SameName')) AS \\\"t\\\" (\\\"id\\\", \\\"desc\\\")\";\n     withUdt().query(sql).returns(\"LD=1\\n\");\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3045\">[CALCITE-3045]\n+   * NullPointerException when casting null literal to composite user defined type</a>. */\n+  @Test public void testCastNullLiteralToCompositeUdt() {\n+    final String sql = \"select CAST(null AS \\\"adhoc\\\".mytype2) as c \"\n+        + \"from (VALUES (1))\";\n+    withUdt().query(sql).returns(\"C=null\\n\");\n+  }\n }\n \n // End UdtTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2894] NullPointerException thrown by RelMdPercentageOriginalRows when explaining plan with all attributes",
        "commit": "https://github.com/apache/calcite/commit/c3fa21b805edf5be79ef4a4992d7b5213488cbaa",
        "parent": "https://github.com/apache/calcite/commit/e2b364e3353b4b78ac74e6404410df6f1a130950",
        "bug_id": "calcite_10",
        "file": [
            {
                "sha": "f74742d78069981954f17ad667628453209f7304",
                "filename": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java",
                "blob_url": "https://github.com/apache/calcite/blob/c3fa21b805edf5be79ef4a4992d7b5213488cbaa/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java",
                "raw_url": "https://github.com/apache/calcite/raw/c3fa21b805edf5be79ef4a4992d7b5213488cbaa/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java",
                "status": "modified",
                "changes": 20,
                "additions": 16,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java?ref=c3fa21b805edf5be79ef4a4992d7b5213488cbaa",
                "patch": "@@ -80,8 +80,14 @@ public Double getPercentageOriginalRows(Union rel, RelMetadataQuery mq) {\n     // case where a huge table has been completely filtered away.\n \n     for (RelNode input : rel.getInputs()) {\n-      double rowCount = mq.getRowCount(input);\n-      double percentage = mq.getPercentageOriginalRows(input);\n+      Double rowCount = mq.getRowCount(input);\n+      if (rowCount == null) {\n+        continue;\n+      }\n+      Double percentage = mq.getPercentageOriginalRows(input);\n+      if (percentage == null) {\n+        continue;\n+      }\n       if (percentage != 0.0) {\n         denominator += rowCount / percentage;\n         numerator += rowCount;\n@@ -100,8 +106,14 @@ public Double getPercentageOriginalRows(Join rel, RelMetadataQuery mq) {\n \n     // REVIEW jvs 28-Mar-2006:  need any special casing for SemiJoin?\n \n-    double left = mq.getPercentageOriginalRows(rel.getLeft());\n-    double right = mq.getPercentageOriginalRows(rel.getRight());\n+    Double left = mq.getPercentageOriginalRows(rel.getLeft());\n+    if (left == null) {\n+      return null;\n+    }\n+    Double right = mq.getPercentageOriginalRows(rel.getRight());\n+    if (right == null) {\n+      return null;\n+    }\n     return left * right;\n   }\n ",
                "deletions": 4
            },
            {
                "sha": "369a17e1b89b115687a071ef0762735c222507da",
                "filename": "core/src/test/java/org/apache/calcite/test/RelMdPercentageOriginalRowsTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/c3fa21b805edf5be79ef4a4992d7b5213488cbaa/core/src/test/java/org/apache/calcite/test/RelMdPercentageOriginalRowsTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/c3fa21b805edf5be79ef4a4992d7b5213488cbaa/core/src/test/java/org/apache/calcite/test/RelMdPercentageOriginalRowsTest.java",
                "status": "added",
                "changes": 45,
                "additions": 45,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RelMdPercentageOriginalRowsTest.java?ref=c3fa21b805edf5be79ef4a4992d7b5213488cbaa",
                "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test;\n+\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.Lex;\n+\n+import org.junit.Test;\n+\n+/** Test case for CALCITE-2894 */\n+public class RelMdPercentageOriginalRowsTest {\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-2894\">[CALCITE-2894]\n+   * NullPointerException thrown by RelMdPercentageOriginalRows when explaining\n+   * plan with all attributes</a>. */\n+  @Test public void testExplainAllAttributesSemiJoinUnionCorrelate() {\n+    CalciteAssert.that()\n+            .with(CalciteConnectionProperty.LEX, Lex.JAVA)\n+            .with(CalciteConnectionProperty.FORCE_DECORRELATE, false)\n+            .withSchema(\"s\", new ReflectiveSchema(new JdbcTest.HrSchema()))\n+            .query(\n+                    \"select deptno, name from depts where deptno in (\\n\"\n+                            + \" select e.deptno from emps e where exists (select 1 from depts d where d.deptno=e.deptno)\\n\"\n+                            + \" union select e.deptno from emps e where e.salary > 10000) \")\n+            .explainMatches(\"including all attributes \",\n+                    CalciteAssert.checkResultContains(\"EnumerableSemiJoin\"));\n+  }\n+}\n+\n+// End RelMdPercentageOriginalRowsTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3082] Fix NPE in SqlUtil#getSelectListItem\n\nQueries similar to `SELECT 1 UNION SELECT 2, 3` might cause Calcite\nvalidator to throw an NPE exception instead of a proper error message.\n\nWhen validating operands of a set operation, if operands don't have\nmatching schema, and if one of the operand doesn't have a FROM clause,\nSqlUtil#getSelectListItem throws NPE.\n\nFixing by adding a proper check.",
        "commit": "https://github.com/apache/calcite/commit/d8768f9c07fa3927475902e27c13c8bc39687897",
        "parent": "https://github.com/apache/calcite/commit/037250b99d6db8a605b64780a3643f784d07d308",
        "bug_id": "calcite_11",
        "file": [
            {
                "sha": "469f83d2dd3bf089c7837c4c0479fae53729d2f9",
                "filename": "core/src/main/java/org/apache/calcite/sql/SqlUtil.java",
                "blob_url": "https://github.com/apache/calcite/blob/d8768f9c07fa3927475902e27c13c8bc39687897/core/src/main/java/org/apache/calcite/sql/SqlUtil.java",
                "raw_url": "https://github.com/apache/calcite/raw/d8768f9c07fa3927475902e27c13c8bc39687897/core/src/main/java/org/apache/calcite/sql/SqlUtil.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/SqlUtil.java?ref=d8768f9c07fa3927475902e27c13c8bc39687897",
                "patch": "@@ -692,7 +692,7 @@ public static SqlNode getSelectListItem(SqlNode query, int i) {\n     case SELECT:\n       SqlSelect select = (SqlSelect) query;\n       final SqlNode from = stripAs(select.getFrom());\n-      if (from.getKind() == SqlKind.VALUES) {\n+      if (from != null && from.getKind() == SqlKind.VALUES) {\n         // They wrote \"VALUES (x, y)\", but the validator has\n         // converted this into \"SELECT * FROM VALUES (x, y)\".\n         return getSelectListItem(from, i);",
                "deletions": 1
            },
            {
                "sha": "c5e4b61c5263386bc6870ceb8fb5e7930c5f804a",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/d8768f9c07fa3927475902e27c13c8bc39687897/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/d8768f9c07fa3927475902e27c13c8bc39687897/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "status": "modified",
                "changes": 5,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java?ref=d8768f9c07fa3927475902e27c13c8bc39687897",
                "patch": "@@ -5626,6 +5626,11 @@ public void testInvalidGroupByWithInvalidTableName() {\n         \"select 1 from (values (^'x'^)) union\\n\"\n             + \"(values ('a'))\",\n         \"Type mismatch in column 1 of UNION\");\n+\n+    checkFails(\n+        \"select 1, ^2^, 3 union\\n \"\n+            + \"select deptno, name, deptno from dept\",\n+        \"Type mismatch in column 2 of UNION\");\n   }\n \n   @Test public void testValuesTypeMismatchFails() {",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Avoid NullPointerException when FlatList contains null elements",
        "commit": "https://github.com/apache/calcite/commit/ef822607649ad157568f868086923b2c62a316dc",
        "parent": "https://github.com/apache/calcite/commit/3183f2cae6db91f0c2bb0fc99ff6121da56652b8",
        "bug_id": "calcite_12",
        "file": [
            {
                "sha": "d491e1485c922f6e317e18cf1502e6ded5da7c4f",
                "filename": "core/src/main/java/org/apache/calcite/runtime/FlatLists.java",
                "blob_url": "https://github.com/apache/calcite/blob/ef822607649ad157568f868086923b2c62a316dc/core/src/main/java/org/apache/calcite/runtime/FlatLists.java",
                "raw_url": "https://github.com/apache/calcite/raw/ef822607649ad157568f868086923b2c62a316dc/core/src/main/java/org/apache/calcite/runtime/FlatLists.java",
                "status": "modified",
                "changes": 84,
                "additions": 42,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/runtime/FlatLists.java?ref=ef822607649ad157568f868086923b2c62a316dc",
                "patch": "@@ -350,7 +350,7 @@ public int indexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }\n@@ -363,7 +363,7 @@ public int lastIndexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }\n@@ -473,10 +473,10 @@ public int indexOf(Object o) {\n           return 1;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n       }\n@@ -492,10 +492,10 @@ public int lastIndexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }\n@@ -613,13 +613,13 @@ public int indexOf(Object o) {\n           return 2;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n       }\n@@ -638,13 +638,13 @@ public int lastIndexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }\n@@ -772,16 +772,16 @@ public int indexOf(Object o) {\n           return 3;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t3.equals(o)) {\n+        if (o.equals(t3)) {\n           return 3;\n         }\n       }\n@@ -803,16 +803,16 @@ public int lastIndexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t3.equals(o)) {\n+        if (o.equals(t3)) {\n           return 3;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }\n@@ -950,19 +950,19 @@ public int indexOf(Object o) {\n           return 4;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t3.equals(o)) {\n+        if (o.equals(t3)) {\n           return 3;\n         }\n-        if (t4.equals(o)) {\n+        if (o.equals(t4)) {\n           return 4;\n         }\n       }\n@@ -987,19 +987,19 @@ public int lastIndexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t4.equals(o)) {\n+        if (o.equals(t4)) {\n           return 4;\n         }\n-        if (t3.equals(o)) {\n+        if (o.equals(t3)) {\n           return 3;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }\n@@ -1148,22 +1148,22 @@ public int indexOf(Object o) {\n           return 5;\n         }\n       } else {\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t3.equals(o)) {\n+        if (o.equals(t3)) {\n           return 3;\n         }\n-        if (t4.equals(o)) {\n+        if (o.equals(t4)) {\n           return 4;\n         }\n-        if (t5.equals(o)) {\n+        if (o.equals(t5)) {\n           return 5;\n         }\n       }\n@@ -1191,22 +1191,22 @@ public int lastIndexOf(Object o) {\n           return 0;\n         }\n       } else {\n-        if (t5.equals(o)) {\n+        if (o.equals(t5)) {\n           return 5;\n         }\n-        if (t4.equals(o)) {\n+        if (o.equals(t4)) {\n           return 4;\n         }\n-        if (t3.equals(o)) {\n+        if (o.equals(t3)) {\n           return 3;\n         }\n-        if (t2.equals(o)) {\n+        if (o.equals(t2)) {\n           return 2;\n         }\n-        if (t1.equals(o)) {\n+        if (o.equals(t1)) {\n           return 1;\n         }\n-        if (t0.equals(o)) {\n+        if (o.equals(t0)) {\n           return 0;\n         }\n       }",
                "deletions": 42
            },
            {
                "sha": "f7a71ca1499d80349903eea97c1fdcd89e1d31e4",
                "filename": "core/src/test/java/org/apache/calcite/util/UtilTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/ef822607649ad157568f868086923b2c62a316dc/core/src/test/java/org/apache/calcite/util/UtilTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/ef822607649ad157568f868086923b2c62a316dc/core/src/test/java/org/apache/calcite/util/UtilTest.java",
                "status": "modified",
                "changes": 6,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/util/UtilTest.java?ref=ef822607649ad157568f868086923b2c62a316dc",
                "patch": "@@ -1113,6 +1113,12 @@ private String toString(byte[] bytes) {\n     final List<String> anb0 = Arrays.asList(\"A\", null, \"B\");\n     assertEquals(anb, anb0);\n     assertEquals(anb.hashCode(), anb0.hashCode());\n+    assertEquals(anb + \".indexOf(null)\", 1, anb.indexOf(null));\n+    assertEquals(anb + \".lastIndexOf(null)\", 1, anb.lastIndexOf(null));\n+    assertEquals(anb + \".indexOf(B)\", 2, anb.indexOf(\"B\"));\n+    assertEquals(anb + \".lastIndexOf(A)\", 0, anb.lastIndexOf(\"A\"));\n+    assertEquals(anb + \".indexOf(Z)\", -1, anb.indexOf(\"Z\"));\n+    assertEquals(anb + \".lastIndexOf(Z)\", -1, anb.lastIndexOf(\"Z\"));\n \n     // Comparisons\n     assertThat(emp, instanceOf(Comparable.class));",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-3360] SqlValidator throws NPE for unregistered function without implicit type coercion\n\nSqlValidator should report the function signature for unregistered UDFs\nwhen implicit type coercion is turned off.\n\nWe also change SqlTypeNameSpec constructor to public so that any other\nengine can extend it and implement their custom data type.(Because it is\ntoo small change, i just merge it into this one)",
        "commit": "https://github.com/apache/calcite/commit/883e19170a45e0badffa5b8fba04cd536e0f2eb2",
        "parent": "https://github.com/apache/calcite/commit/67fd318ed755ef975cf31262c96c982f0922a975",
        "bug_id": "calcite_13",
        "file": [
            {
                "sha": "b830a0885aa82346cfba0f5a1d5671b805a28270",
                "filename": "core/src/main/java/org/apache/calcite/sql/SqlFunction.java",
                "blob_url": "https://github.com/apache/calcite/blob/883e19170a45e0badffa5b8fba04cd536e0f2eb2/core/src/main/java/org/apache/calcite/sql/SqlFunction.java",
                "raw_url": "https://github.com/apache/calcite/raw/883e19170a45e0badffa5b8fba04cd536e0f2eb2/core/src/main/java/org/apache/calcite/sql/SqlFunction.java",
                "status": "modified",
                "changes": 24,
                "additions": 13,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/SqlFunction.java?ref=883e19170a45e0badffa5b8fba04cd536e0f2eb2",
                "patch": "@@ -271,18 +271,20 @@ private RelDataType deriveType(\n         return validator.deriveConstructorType(scope, call, this, function,\n             argTypes);\n       }\n-      if (function == null && validator.isTypeCoercionEnabled()) {\n-        // try again if implicit type coercion is allowed.\n+      if (function == null) {\n         boolean changed = false;\n-        function = (SqlFunction) SqlUtil.lookupRoutine(validator.getOperatorTable(),\n-            getNameAsId(), argTypes, argNames, getFunctionType(), SqlSyntax.FUNCTION, getKind(),\n-            validator.getCatalogReader().nameMatcher(),\n-            true);\n-        // try to coerce the function arguments to the declared sql type name.\n-        // if we succeed, the arguments would be wrapped with CAST operator.\n-        if (function != null) {\n-          TypeCoercion typeCoercion = validator.getTypeCoercion();\n-          changed = typeCoercion.userDefinedFunctionCoercion(scope, call, function);\n+        if (validator.isTypeCoercionEnabled()) {\n+          // try again if implicit type coercion is allowed.\n+          function = (SqlFunction) SqlUtil.lookupRoutine(validator.getOperatorTable(),\n+              getNameAsId(), argTypes, argNames, getFunctionType(), SqlSyntax.FUNCTION, getKind(),\n+              validator.getCatalogReader().nameMatcher(),\n+              true);\n+          // try to coerce the function arguments to the declared sql type name.\n+          // if we succeed, the arguments would be wrapped with CAST operator.\n+          if (function != null) {\n+            TypeCoercion typeCoercion = validator.getTypeCoercion();\n+            changed = typeCoercion.userDefinedFunctionCoercion(scope, call, function);\n+          }\n         }\n         if (!changed) {\n           throw validator.handleUnresolvedFunction(call, this, argTypes,",
                "deletions": 11
            },
            {
                "sha": "a0be99ae6a046d2f7732e900844ce24cae4191fa",
                "filename": "core/src/main/java/org/apache/calcite/sql/SqlTypeNameSpec.java",
                "blob_url": "https://github.com/apache/calcite/blob/883e19170a45e0badffa5b8fba04cd536e0f2eb2/core/src/main/java/org/apache/calcite/sql/SqlTypeNameSpec.java",
                "raw_url": "https://github.com/apache/calcite/raw/883e19170a45e0badffa5b8fba04cd536e0f2eb2/core/src/main/java/org/apache/calcite/sql/SqlTypeNameSpec.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/SqlTypeNameSpec.java?ref=883e19170a45e0badffa5b8fba04cd536e0f2eb2",
                "patch": "@@ -40,7 +40,7 @@\n    * @param name Name of the type.\n    * @param pos  Parser position, must not be null.\n    */\n-  SqlTypeNameSpec(SqlIdentifier name, SqlParserPos pos) {\n+  public SqlTypeNameSpec(SqlIdentifier name, SqlParserPos pos) {\n     this.typeName = name;\n     this.pos = pos;\n   }",
                "deletions": 1
            },
            {
                "sha": "77679a1742f85aa357bba40a90a558e7d364664f",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/883e19170a45e0badffa5b8fba04cd536e0f2eb2/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/883e19170a45e0badffa5b8fba04cd536e0f2eb2/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "status": "modified",
                "changes": 42,
                "additions": 42,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java?ref=883e19170a45e0badffa5b8fba04cd536e0f2eb2",
                "patch": "@@ -11513,6 +11513,48 @@ private void checkCustomColumnResolving(String table) {\n         \"VARCHAR NOT NULL\");\n   }\n \n+  @Test public void testInvalidFunctionCall() {\n+    final SqlTester tester1 = tester\n+        .withCaseSensitive(true);\n+    final MockSqlOperatorTable operatorTable =\n+        new MockSqlOperatorTable(SqlStdOperatorTable.instance());\n+    MockSqlOperatorTable.addRamp(operatorTable);\n+    tester1.withOperatorTable(operatorTable);\n+    // With implicit type coercion.\n+    checkExpFails(\"^unknown_udf(1, 2)^\",\n+        \"(?s).*No match found for function signature \"\n+            + \"UNKNOWN_UDF\\\\(<NUMERIC>, <NUMERIC>\\\\).*\");\n+    checkExpFails(\"^power(cast(1 as timestamp), cast(2 as timestamp))^\",\n+        \"(?s).*Cannot apply 'POWER' to arguments of type \"\n+            + \"'POWER\\\\(<TIMESTAMP\\\\(0\\\\)>, <TIMESTAMP\\\\(0\\\\)>\\\\)'.*\");\n+    tester1.checkFails(\"^myFUN(cast('124' as timestamp))^\",\n+            \"(?s).*Cannot apply 'MYFUN' to arguments of type \"\n+                + \"'MYFUN\\\\(<TIMESTAMP\\\\(0\\\\)>\\\\)'.*\",\n+            false);\n+    tester1.checkFails(\"^myFUN(1, 2)^\",\n+        \"(?s).*No match found for function signature \"\n+            + \"MYFUN\\\\(<NUMERIC>, <NUMERIC>\\\\).*\",\n+        false);\n+    // Without implicit type coercion.\n+    checkExpFails(\"^unknown_udf(1, 2)^\",\n+        \"(?s).*No match found for function signature \"\n+            + \"UNKNOWN_UDF\\\\(<NUMERIC>, <NUMERIC>\\\\).*\",\n+        false);\n+    checkExpFails(\"^power(cast(1 as timestamp), cast(2 as timestamp))^\",\n+        \"(?s).*Cannot apply 'POWER' to arguments of type \"\n+            + \"'POWER\\\\(<TIMESTAMP\\\\(0\\\\)>, <TIMESTAMP\\\\(0\\\\)>\\\\)'.*\", false);\n+    tester1.enableTypeCoercion(false)\n+        .checkFails(\"^myFUN(cast('124' as timestamp))^\",\n+            \"(?s).*Cannot apply 'MYFUN' to arguments of type \"\n+                + \"'MYFUN\\\\(<TIMESTAMP\\\\(0\\\\)>\\\\)'.*\",\n+            false);\n+    tester1.enableTypeCoercion(false)\n+        .checkFails(\"^myFUN(1, 2)^\",\n+        \"(?s).*No match found for function signature \"\n+            + \"MYFUN\\\\(<NUMERIC>, <NUMERIC>\\\\).*\",\n+        false);\n+  }\n+\n   @Test public void testValidatorReportsOriginalQueryUsingReader()\n       throws Exception {\n     final String sql = \"select a from b\";",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2739] NPE is thrown if the DEFINE statement contains IN in MATCH_RECOGNIZE\n\nClose #970",
        "commit": "https://github.com/apache/calcite/commit/f2869e9ad3864caa4d1678fbefc50389b981f2e6",
        "parent": "https://github.com/apache/calcite/commit/3ed76375fd05b29db17d6117aa0487ccb85f45ba",
        "bug_id": "calcite_14",
        "file": [
            {
                "sha": "6d24bf3ce9873e055bd49750b83bc51c9141ae25",
                "filename": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "status": "modified",
                "changes": 1,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java?ref=f2869e9ad3864caa4d1678fbefc50389b981f2e6",
                "patch": "@@ -2276,6 +2276,7 @@ protected void convertMatchRecognize(Blackboard bb, SqlCall call) {\n     final ImmutableMap.Builder<String, RexNode> definitionNodes =\n         ImmutableMap.builder();\n     for (SqlNode def : matchRecognize.getPatternDefList()) {\n+      replaceSubQueries(matchBb, def, RelOptUtil.Logic.UNKNOWN_AS_FALSE);\n       List<SqlNode> operands = ((SqlCall) def).getOperandList();\n       String alias = ((SqlIdentifier) operands.get(1)).getSimple();\n       RexNode rex = matchBb.convertExpression(operands.get(0));",
                "deletions": 0
            },
            {
                "sha": "b82b52cdd977164ca96979a2dd3bdf8b1cc5525f",
                "filename": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "status": "modified",
                "changes": 28,
                "additions": 28,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java?ref=f2869e9ad3864caa4d1678fbefc50389b981f2e6",
                "patch": "@@ -2978,6 +2978,34 @@ private void checkLiteral2(String expression, String expected) {\n     sql(sql).ok(expected);\n   }\n \n+  @Test public void testMatchRecognizeIn() {\n+    final String sql = \"select *\\n\"\n+        + \"  from \\\"product\\\" match_recognize\\n\"\n+        + \"  (\\n\"\n+        + \"    partition by \\\"product_class_id\\\", \\\"brand_name\\\" \\n\"\n+        + \"    order by \\\"product_class_id\\\" asc, \\\"brand_name\\\" desc \\n\"\n+        + \"    pattern (strt down+ up+)\\n\"\n+        + \"    define\\n\"\n+        + \"      down as down.\\\"net_weight\\\" in (0, 1),\\n\"\n+        + \"      up as up.\\\"net_weight\\\" > prev(up.\\\"net_weight\\\")\\n\"\n+        + \"  ) mr\";\n+\n+    final String expected = \"SELECT *\\n\"\n+        + \"FROM (SELECT *\\n\"\n+        + \"FROM \\\"foodmart\\\".\\\"product\\\") MATCH_RECOGNIZE(\\n\"\n+        + \"PARTITION BY \\\"product_class_id\\\", \\\"brand_name\\\"\\n\"\n+        + \"ORDER BY \\\"product_class_id\\\", \\\"brand_name\\\" DESC\\n\"\n+        + \"ONE ROW PER MATCH\\n\"\n+        + \"AFTER MATCH SKIP TO NEXT ROW\\n\"\n+        + \"PATTERN (\\\"STRT\\\" \\\"DOWN\\\" + \\\"UP\\\" +)\\n\"\n+        + \"DEFINE \"\n+        + \"\\\"DOWN\\\" AS PREV(\\\"DOWN\\\".\\\"net_weight\\\", 0) = \"\n+        + \"0 OR PREV(\\\"DOWN\\\".\\\"net_weight\\\", 0) = 1, \"\n+        + \"\\\"UP\\\" AS PREV(\\\"UP\\\".\\\"net_weight\\\", 0) > \"\n+        + \"PREV(\\\"UP\\\".\\\"net_weight\\\", 1))\";\n+    sql(sql).ok(expected);\n+  }\n+\n   @Test public void testValues() {\n     final String sql = \"select \\\"a\\\"\\n\"\n         + \"from (values (1, 'x'), (2, 'yy')) as t(\\\"a\\\", \\\"b\\\")\";",
                "deletions": 0
            },
            {
                "sha": "d4e2c9b36b53ce116b5964db36a6c4d215738406",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "status": "modified",
                "changes": 13,
                "additions": 13,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java?ref=f2869e9ad3864caa4d1678fbefc50389b981f2e6",
                "patch": "@@ -2972,6 +2972,19 @@ private Tester getExtendedTester() {\n     sql(sql).ok();\n   }\n \n+  @Test public void testMatchRecognizeIn() {\n+    final String sql = \"select *\\n\"\n+        + \"  from emp match_recognize\\n\"\n+        + \"  (\\n\"\n+        + \"    partition by job, sal\\n\"\n+        + \"    order by job asc, sal desc, empno\\n\"\n+        + \"    pattern (strt down+ up+)\\n\"\n+        + \"    define\\n\"\n+        + \"      down as down.mgr in (0, 1),\\n\"\n+        + \"      up as up.mgr > prev(up.mgr)) as mr\";\n+    sql(sql).ok();\n+  }\n+\n   /** Test case for\n    * <a href=\"https://issues.apache.org/jira/browse/CALCITE-2323\">[CALCITE-2323]\n    * Validator should allow alternative nullCollations for ORDER BY in",
                "deletions": 0
            },
            {
                "sha": "466a0659758f14b5d5a8e5e942a650278b07f0c0",
                "filename": "core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "blob_url": "https://github.com/apache/calcite/blob/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "raw_url": "https://github.com/apache/calcite/raw/f2869e9ad3864caa4d1678fbefc50389b981f2e6/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "status": "modified",
                "changes": 20,
                "additions": 20,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml?ref=f2869e9ad3864caa4d1678fbefc50389b981f2e6",
                "patch": "@@ -3024,6 +3024,26 @@ GROUP BY (CASE WHEN emp.empno IN (3) THEN 0 ELSE 1 END)]]>\n LogicalAggregate(group=[{0}])\n   LogicalProject(EXPR$0=[CASE(=($0, 3), 0, 1)])\n     LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+]]>\n+        </Resource>\n+    </TestCase>\n+    <TestCase name=\"testMatchRecognizeIn\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select *\n+  from emp match_recognize\n+  (\n+    partition by job, sal\n+    order by job asc, sal desc, empno\n+    pattern (strt down+ up+)\n+    define\n+      down as down.mgr in (0, 1),\n+      up as up.mgr > prev(up.mgr)) as mr]]>\n+        </Resource>\n+        <Resource name=\"plan\">\n+            <![CDATA[\n+LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8])\n+  LogicalMatch(partition=[[$2, $5]], order=[[2, 5 DESC, 0]], outputFields=[[EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, SLACKER]], allRows=[false], after=[FLAG(SKIP TO NEXT ROW)], pattern=[(('STRT', PATTERN_QUANTIFIER('DOWN', 1, -1, false)), PATTERN_QUANTIFIER('UP', 1, -1, false))], isStrictStarts=[false], isStrictEnds=[false], subsets=[[]], patternDefinitions=[[OR(=(PREV(DOWN.$3, 0), 0), =(PREV(DOWN.$3, 0), 1)), >(PREV(UP.$3, 0), PREV(UP.$3, 1))]], inputFields=[[EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, SLACKER]])\n+    LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n ]]>\n         </Resource>\n     </TestCase>",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2628] JDBC adapter throws NullPointerException while generating GROUP BY query for MySQL\n\nAlso, refactor RelToSqlConverterTest a little.",
        "commit": "https://github.com/apache/calcite/commit/784372debb2b51c3041c0d5b420a6f93a2457a16",
        "parent": "https://github.com/apache/calcite/commit/ae63f9c28c69bad135f4ebbe0086e4f09b6f58ab",
        "bug_id": "calcite_15",
        "file": [
            {
                "sha": "c480ec4427c95e4022c6ef9c6c3bd5b50b2e20c4",
                "filename": "core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java",
                "blob_url": "https://github.com/apache/calcite/blob/784372debb2b51c3041c0d5b420a6f93a2457a16/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java",
                "raw_url": "https://github.com/apache/calcite/raw/784372debb2b51c3041c0d5b420a6f93a2457a16/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java",
                "status": "modified",
                "changes": 32,
                "additions": 17,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java?ref=784372debb2b51c3041c0d5b420a6f93a2457a16",
                "patch": "@@ -988,21 +988,23 @@ public SqlNode field(int ordinal) {\n     }\n \n     private boolean hasNestedAggregations(LogicalAggregate rel) {\n-      List<AggregateCall> aggCallList = rel.getAggCallList();\n-      HashSet<Integer> aggregatesArgs = new HashSet<>();\n-      for (AggregateCall aggregateCall: aggCallList) {\n-        aggregatesArgs.addAll(aggregateCall.getArgList());\n-      }\n-      for (Integer aggregatesArg : aggregatesArgs) {\n-        SqlNode selectNode = ((SqlSelect) node).getSelectList().get(aggregatesArg);\n-        if (!(selectNode instanceof SqlBasicCall)) {\n-          continue;\n-        }\n-        for (SqlNode operand : ((SqlBasicCall) selectNode).getOperands()) {\n-          if (operand instanceof SqlCall) {\n-            final SqlOperator operator = ((SqlCall) operand).getOperator();\n-            if (operator instanceof SqlAggFunction) {\n-              return true;\n+      if (node instanceof SqlSelect) {\n+        final SqlNodeList selectList = ((SqlSelect) node).getSelectList();\n+        if (selectList != null) {\n+          final Set<Integer> aggregatesArgs = new HashSet<>();\n+          for (AggregateCall aggregateCall : rel.getAggCallList()) {\n+            aggregatesArgs.addAll(aggregateCall.getArgList());\n+          }\n+          for (int aggregatesArg : aggregatesArgs) {\n+            if (selectList.get(aggregatesArg) instanceof SqlBasicCall) {\n+              final SqlBasicCall call =\n+                  (SqlBasicCall) selectList.get(aggregatesArg);\n+              for (SqlNode operand : call.getOperands()) {\n+                if (operand instanceof SqlCall\n+                    && ((SqlCall) operand).getOperator() instanceof SqlAggFunction) {\n+                  return true;\n+                }\n+              }\n             }\n           }\n         }",
                "deletions": 15
            },
            {
                "sha": "7e5115842871c6c3b4273e514149109fdf78a071",
                "filename": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/784372debb2b51c3041c0d5b420a6f93a2457a16/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/784372debb2b51c3041c0d5b420a6f93a2457a16/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java",
                "status": "modified",
                "changes": 96,
                "additions": 74,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java?ref=784372debb2b51c3041c0d5b420a6f93a2457a16",
                "patch": "@@ -80,9 +80,6 @@\n           .withExpand(false)\n           .build();\n \n-  final RelBuilder builder = RelBuilder.create(RelBuilderTest.config().build());\n-  final RelBuilder empScan = builder.scan(\"EMP\");\n-\n   /** Initiates a test case with a given SQL query. */\n   private Sql sql(String sql) {\n     return new Sql(CalciteAssert.SchemaSpec.JDBC_FOODMART, sql,\n@@ -123,6 +120,23 @@ private static MysqlSqlDialect mySqlDialect(NullCollation nullCollation) {\n         .withNullCollation(nullCollation));\n   }\n \n+  /** Creates a RelBuilder. */\n+  private static RelBuilder relBuilder() {\n+    return RelBuilder.create(RelBuilderTest.config().build());\n+  }\n+\n+  /** Converts a relational expression to SQL. */\n+  private String toSql(RelNode root) {\n+    return toSql(root, SqlDialect.DatabaseProduct.CALCITE.getDialect());\n+  }\n+\n+  /** Converts a relational expression to SQL in a given dialect. */\n+  private static String toSql(RelNode root, SqlDialect dialect) {\n+    final RelToSqlConverter converter = new RelToSqlConverter(dialect);\n+    final SqlNode sqlNode = converter.visitChild(0, root).asStatement();\n+    return sqlNode.toSqlString(dialect).getSql();\n+  }\n+\n   @Test public void testSimpleSelectStarFromProductTable() {\n     String query = \"select * from \\\"product\\\"\";\n     sql(query).ok(\"SELECT *\\nFROM \\\"foodmart\\\".\\\"product\\\"\");\n@@ -262,6 +276,45 @@ private static MysqlSqlDialect mySqlDialect(NullCollation nullCollation) {\n         .ok(expectedPostgresql);\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-2628\">[CALCITE-2628]\n+   * JDBC adapter throws NullPointerException while generating GROUP BY query\n+   * for MySQL</a>.\n+   *\n+   * <p>MySQL does not support nested aggregates, so {@link RelToSqlConverter}\n+   * performs some extra checks, looking for aggregates in the input\n+   * sub-query, and these would fail with {@code NullPointerException}\n+   * and {@code ClassCastException} in some cases. */\n+  @Test public void testNestedAggregatesMySqlTable() {\n+    final RelBuilder builder = relBuilder();\n+    final RelNode root = builder\n+        .scan(\"EMP\")\n+        .aggregate(builder.groupKey(),\n+            builder.count(false, \"c\", builder.field(3)))\n+        .build();\n+    final SqlDialect dialect = SqlDialect.DatabaseProduct.MYSQL.getDialect();\n+    final String expectedSql = \"SELECT COUNT(`MGR`) AS `c`\\n\"\n+        + \"FROM `scott`.`EMP`\";\n+    assertThat(toSql(root, dialect), isLinux(expectedSql));\n+  }\n+\n+  /** As {@link #testNestedAggregatesMySqlTable()}, but input is a sub-query,\n+   * not a table. */\n+  @Test public void testNestedAggregatesMySqlStar() {\n+    final RelBuilder builder = relBuilder();\n+    final RelNode root = builder\n+        .scan(\"EMP\")\n+        .filter(builder.equals(builder.field(\"DEPTNO\"), builder.literal(10)))\n+        .aggregate(builder.groupKey(),\n+            builder.count(false, \"c\", builder.field(3)))\n+        .build();\n+    final SqlDialect dialect = SqlDialect.DatabaseProduct.MYSQL.getDialect();\n+    final String expectedSql = \"SELECT COUNT(`MGR`) AS `c`\\n\"\n+        + \"FROM `scott`.`EMP`\\n\"\n+        + \"WHERE `DEPTNO` = 10\";\n+    assertThat(toSql(root, dialect), isLinux(expectedSql));\n+  }\n+\n   @Test public void testSelectQueryWithGroupByAndProjectList1() {\n     String query =\n         \"select count(*)  from \\\"product\\\" group by \\\"product_class_id\\\", \\\"product_id\\\"\";\n@@ -371,57 +424,58 @@ private static MysqlSqlDialect mySqlDialect(NullCollation nullCollation) {\n     sql(query).withHive().ok(expected);\n   }\n \n-\n-  private String unparseRelTree(RelNode root) {\n-    SqlDialect dialect = SqlDialect.DatabaseProduct.CALCITE.getDialect();\n-    final RelToSqlConverter converter = new RelToSqlConverter(dialect);\n-    final SqlNode sqlNode = converter.visitChild(0, root).asStatement();\n-    return sqlNode.toSqlString(dialect).getSql();\n-  }\n-\n   /**\n    * Tests that IN can be un-parsed.\n    *\n    * <p>This cannot be tested using \"sql\", because because Calcite's SQL parser\n    * replaces INs with ORs or sub-queries.\n    */\n   @Test public void testUnparseIn1() {\n+    final RelBuilder builder = relBuilder().scan(\"EMP\");\n     final RexNode condition =\n         builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n             builder.literal(21));\n-    final String sql = unparseRelTree(empScan.filter(condition).build());\n+    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n+    final String sql = toSql(root);\n     final String expectedSql = \"SELECT *\\n\"\n         + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n         + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n     assertThat(sql, isLinux(expectedSql));\n   }\n \n   @Test public void testUnparseIn2() {\n-    final RexNode filter =\n-        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n-            builder.literal(20), builder.literal(21));\n-    final String sql = unparseRelTree(empScan.filter(filter).build());\n+    final RelBuilder builder = relBuilder();\n+    final RelNode rel = builder\n+        .scan(\"EMP\")\n+        .filter(\n+            builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n+                builder.literal(20), builder.literal(21)))\n+        .build();\n+    final String sql = toSql(rel);\n     final String expectedSql = \"SELECT *\\n\"\n         + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n         + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n     assertThat(sql, isLinux(expectedSql));\n   }\n \n   @Test public void testUnparseInStruct1() {\n+    final RelBuilder builder = relBuilder().scan(\"EMP\");\n     final RexNode condition =\n         builder.call(SqlStdOperatorTable.IN,\n             builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                 builder.field(\"JOB\")),\n             builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                 builder.literal(\"PRESIDENT\")));\n-    final String sql = unparseRelTree(empScan.filter(condition).build());\n+    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n+    final String sql = toSql(root);\n     final String expectedSql = \"SELECT *\\n\"\n         + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n         + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n     assertThat(sql, isLinux(expectedSql));\n   }\n \n   @Test public void testUnparseInStruct2() {\n+    final RelBuilder builder = relBuilder().scan(\"EMP\");\n     final RexNode condition =\n         builder.call(SqlStdOperatorTable.IN,\n             builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n@@ -430,7 +484,8 @@ private String unparseRelTree(RelNode root) {\n                 builder.literal(\"PRESIDENT\")),\n             builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                 builder.literal(\"PRESIDENT\")));\n-    final String sql = unparseRelTree(empScan.filter(condition).build());\n+    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n+    final String sql = toSql(root);\n     final String expectedSql = \"SELECT *\\n\"\n         + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n         + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n@@ -2742,10 +2797,7 @@ String exec() {\n         for (Function<RelNode, RelNode> transform : transforms) {\n           rel = transform.apply(rel);\n         }\n-        final RelToSqlConverter converter =\n-            new RelToSqlConverter(dialect);\n-        final SqlNode sqlNode = converter.visitChild(0, rel).asStatement();\n-        return sqlNode.toSqlString(dialect).getSql();\n+        return toSql(rel, dialect);\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Exception e) {",
                "deletions": 22
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2271] Join of two views with window aggregates produces incorrect results or NPE\n\nAvoid NPE in BlockBuilder.append when empty variable initializer is used\n\ncloses #673",
        "commit": "https://github.com/apache/calcite/commit/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
        "parent": "https://github.com/apache/calcite/commit/6cad2ee13e50e9444f80a744409d4e6ca483a30c",
        "bug_id": "calcite_16",
        "file": [
            {
                "sha": "58f26e721df70029c5c2265234d1e20982091951",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java",
                "status": "modified",
                "changes": 1,
                "additions": 0,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -72,7 +72,6 @@\n       new HashMap<>();\n   private final Map<Object, ParameterExpression> stashedParameters =\n       new IdentityHashMap<>();\n-  int windowCount = 0;\n \n   protected final Function1<String, RexToLixTranslator.InputGetter> allCorrelateVariables =\n       this::getCorrelVariableGetter;",
                "deletions": 1
            },
            {
                "sha": "6b55983af9d4d2bde33fddb01adfd2f51d33387d",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java",
                "status": "modified",
                "changes": 5,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -175,11 +175,10 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n \n     PhysType inputPhysType = result.physType;\n \n-    final int w = implementor.windowCount++;\n     ParameterExpression prevStart =\n-        Expressions.parameter(int.class, builder.newName(\"prevStart\" + w));\n+        Expressions.parameter(int.class, builder.newName(\"prevStart\"));\n     ParameterExpression prevEnd =\n-        Expressions.parameter(int.class, builder.newName(\"prevEnd\" + w));\n+        Expressions.parameter(int.class, builder.newName(\"prevEnd\"));\n \n     builder.add(Expressions.declare(0, prevStart, null));\n     builder.add(Expressions.declare(0, prevEnd, null));",
                "deletions": 3
            },
            {
                "sha": "ff0aadcf5ad9bbea194fc000a4be9f137d78c127",
                "filename": "core/src/test/resources/sql/winagg.iq",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/core/src/test/resources/sql/winagg.iq",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/core/src/test/resources/sql/winagg.iq",
                "status": "modified",
                "changes": 57,
                "additions": 55,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/sql/winagg.iq?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -420,16 +420,69 @@ limit 5;\n +--------+-----+-----+\n | deptno | AR  | BR  |\n +--------+-----+-----+\n+|     10 | 110 | 100 |\n |     10 | 110 | 110 |\n |     10 | 110 | 110 |\n-|     10 | 110 | 110 |\n+|     10 | 110 | 150 |\n |     20 | 200 | 200 |\n-|     20 | 200 |     |\n +--------+-----+-----+\n (5 rows)\n \n !ok\n \n+select a.\"empid\", a.\"deptno\", a.\"commission\", a.r as ar, b.r as br\n+from (\n+  select \"empid\", \"deptno\", \"commission\", first_value(\"empid\") over w as r\n+  from \"hr\".\"emps\"\n+  window w as (partition by \"deptno\" order by \"commission\")) a\n+join (\n+  select \"empid\", \"deptno\", \"commission\", last_value(\"empid\") over w as r\n+  from \"hr\".\"emps\"\n+  window w as (partition by \"deptno\" order by \"commission\")) b\n+on a.\"empid\" = b.\"empid\"\n+limit 5;\n+\n++-------+--------+------------+-----+-----+\n+| empid | deptno | commission | AR  | BR  |\n++-------+--------+------------+-----+-----+\n+|   100 |     10 |       1000 | 110 | 100 |\n+|   110 |     10 |        250 | 110 | 110 |\n+|   150 |     10 |            | 110 | 150 |\n+|   200 |     20 |        500 | 200 | 200 |\n++-------+--------+------------+-----+-----+\n+(4 rows)\n+\n+!ok\n+\n+# [CALCITE-2271] Two windows under a JOIN 2\n+select\n+ t1.l, t1.key as key1, t2.key as key2\n+from\n+ (\n+  select\n+   dense_rank() over (order by key) l,\n+   key\n+  from\n+   unnest(map[1,1,2,2]) k\n+ ) t1\n+ join\n+ (\n+  select\n+   dense_rank() over(order by key) l,\n+   key\n+  from\n+   unnest(map[2,2]) k\n+ ) t2 on (t1.l = t2.l and t1.key + 1 = t2.key);\n+\n++---+------+------+\n+| L | KEY1 | KEY2 |\n++---+------+------+\n+| 1 |    1 |    2 |\n++---+------+------+\n+(1 row)\n+\n+!ok\n+\n # NTH_VALUE\n select emp.\"ENAME\", emp.\"DEPTNO\",\n  nth_value(emp.\"DEPTNO\", 1) over() as \"first_value\",",
                "deletions": 2
            },
            {
                "sha": "e59bc65d31ae1bfaab8c9963d111e33267d4b088",
                "filename": "linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java",
                "status": "modified",
                "changes": 37,
                "additions": 28,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -121,19 +121,30 @@ public Expression append(String name, BlockStatement block,\n       }\n       if (statement instanceof DeclarationStatement) {\n         DeclarationStatement declaration = (DeclarationStatement) statement;\n-        if (variables.contains(declaration.parameter.name)) {\n-          Expression x = append(\n-              newName(declaration.parameter.name, optimize),\n-              declaration.initializer);\n+        if (!variables.contains(declaration.parameter.name)) {\n+          add(statement);\n+        } else {\n+          String newName = newName(declaration.parameter.name, optimize);\n+          Expression x;\n+          // When initializer is null, append(name, initializer) can't deduce expression type\n+          if (declaration.initializer != null && isSafeForReuse(declaration)) {\n+            x = append(newName, declaration.initializer);\n+          } else {\n+            ParameterExpression pe = Expressions.parameter(\n+                declaration.parameter.type, newName);\n+            DeclarationStatement newDeclaration = Expressions.declare(\n+                declaration.modifiers, pe, declaration.initializer\n+            );\n+            x = pe;\n+            add(newDeclaration);\n+          }\n           statement = null;\n           result = x;\n           if (declaration.parameter != x) {\n             // declaration.parameter can be equal to x if exactly the same\n             // declaration was present in BlockBuilder\n             replacements.put(declaration.parameter, x);\n           }\n-        } else {\n-          add(statement);\n         }\n       } else {\n         add(statement);\n@@ -237,7 +248,7 @@ protected boolean isSimpleExpression(Expression expr) {\n   }\n \n   protected boolean isSafeForReuse(DeclarationStatement decl) {\n-    return (decl.modifiers & Modifier.FINAL) != 0;\n+    return (decl.modifiers & Modifier.FINAL) != 0 && !decl.parameter.name.startsWith(\"_\");\n   }\n \n   protected void addExpressionForReuse(DeclarationStatement decl) {\n@@ -340,7 +351,7 @@ private boolean optimize(Shuttle optimizer, boolean performInline) {\n     }\n     final Map<ParameterExpression, Expression> subMap =\n         new IdentityHashMap<>(useCounter.map.size());\n-    final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor(\n+    final Shuttle visitor = new InlineVariableVisitor(\n         subMap);\n     final ArrayList<Statement> oldStatements = new ArrayList<>(statements);\n     statements.clear();\n@@ -493,7 +504,7 @@ public BlockBuilder append(Expression expression) {\n \n   /** Substitute Variable Visitor. */\n   private static class SubstituteVariableVisitor extends Shuttle {\n-    private final Map<ParameterExpression, Expression> map;\n+    protected final Map<ParameterExpression, Expression> map;\n     private final Map<ParameterExpression, Boolean> actives =\n         new IdentityHashMap<>();\n \n@@ -519,6 +530,14 @@ public BlockBuilder append(Expression expression) {\n       }\n       return super.visit(parameterExpression);\n     }\n+  }\n+\n+  /** Inline Variable Visitor. */\n+  private static class InlineVariableVisitor extends SubstituteVariableVisitor {\n+    InlineVariableVisitor(\n+        Map<ParameterExpression, Expression> map) {\n+      super(map);\n+    }\n \n     @Override public Expression visit(UnaryExpression unaryExpression,\n         Expression expression) {",
                "deletions": 9
            },
            {
                "sha": "0e4c3c2da1d54964f2a3ce766823f318c5c11dea",
                "filename": "linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java",
                "status": "modified",
                "changes": 3,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -2940,6 +2940,9 @@ public static DeclarationStatement declare(int modifiers,\n    */\n   public static DeclarationStatement declare(int modifiers, String name,\n       Expression initializer) {\n+    assert initializer != null\n+        : \"empty initializer for variable declaration with name '\" + name + \"', modifiers \"\n+        + modifiers + \". Please use declare(int, ParameterExpression, initializer) instead\";\n     return declare(modifiers, parameter(initializer.getType(), name),\n         initializer);\n   }",
                "deletions": 0
            },
            {
                "sha": "2886269594c6a74f18d4276f7492a1a2bdbe7c42",
                "filename": "linq4j/src/test/java/org/apache/calcite/linq4j/test/BlockBuilderTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/test/java/org/apache/calcite/linq4j/test/BlockBuilderTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/test/java/org/apache/calcite/linq4j/test/BlockBuilderTest.java",
                "status": "modified",
                "changes": 46,
                "additions": 46,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/linq4j/src/test/java/org/apache/calcite/linq4j/test/BlockBuilderTest.java?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -22,6 +22,7 @@\n import org.apache.calcite.linq4j.tree.ExpressionType;\n import org.apache.calcite.linq4j.tree.Expressions;\n import org.apache.calcite.linq4j.tree.OptimizeShuttle;\n+import org.apache.calcite.linq4j.tree.ParameterExpression;\n import org.apache.calcite.linq4j.tree.Shuttle;\n \n import org.junit.Before;\n@@ -78,6 +79,51 @@ public void prepareBuilder() {\n     b.add(Expressions.return_(null, Expressions.add(ONE, TWO)));\n     assertEquals(\"{\\n  return 4;\\n}\\n\", b.toBlock().toString());\n   }\n+\n+  private BlockBuilder appendBlockWithSameVariable(\n+      Expression initializer1, Expression initializer2) {\n+    BlockBuilder outer = new BlockBuilder();\n+    ParameterExpression outerX = Expressions.parameter(int.class, \"x\");\n+    outer.add(Expressions.declare(0, outerX, initializer1));\n+    outer.add(Expressions.statement(Expressions.assign(outerX, Expressions.constant(1))));\n+\n+    BlockBuilder inner = new BlockBuilder();\n+    ParameterExpression innerX = Expressions.parameter(int.class, \"x\");\n+    inner.add(Expressions.declare(0, innerX, initializer2));\n+    inner.add(Expressions.statement(Expressions.assign(innerX, Expressions.constant(42))));\n+    inner.add(Expressions.return_(null, innerX));\n+    outer.append(\"x\", inner.toBlock());\n+    return outer;\n+  }\n+\n+  @Test public void testRenameVariablesWithEmptyInitializer() {\n+    BlockBuilder outer = appendBlockWithSameVariable(null, null);\n+\n+    assertEquals(\"x in the second block should be renamed to avoid name clash\",\n+        \"{\\n\"\n+            + \"  int x;\\n\"\n+            + \"  x = 1;\\n\"\n+            + \"  int x0;\\n\"\n+            + \"  x0 = 42;\\n\"\n+            + \"}\\n\",\n+        Expressions.toString(outer.toBlock()));\n+  }\n+\n+  @Test public void testRenameVariablesWithInitializer() {\n+    BlockBuilder outer = appendBlockWithSameVariable(\n+        Expressions.constant(7), Expressions.constant(8));\n+\n+    assertEquals(\"x in the second block should be renamed to avoid name clash\",\n+        \"{\\n\"\n+            + \"  int x = 7;\\n\"\n+            + \"  x = 1;\\n\"\n+            + \"  int x0 = 8;\\n\"\n+            + \"  x0 = 42;\\n\"\n+            + \"}\\n\",\n+        Expressions.toString(outer.toBlock()));\n+  }\n+\n+\n }\n \n // End BlockBuilderTest.java",
                "deletions": 0
            },
            {
                "sha": "6e77bd9d29a6a09caea7291b20e39fc76db9ba1a",
                "filename": "linq4j/src/test/java/org/apache/calcite/linq4j/test/ExpressionTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/test/java/org/apache/calcite/linq4j/test/ExpressionTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/af3e35d64a7c29dfaa451c4ab4880424a8fe8cee/linq4j/src/test/java/org/apache/calcite/linq4j/test/ExpressionTest.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/linq4j/src/test/java/org/apache/calcite/linq4j/test/ExpressionTest.java?ref=af3e35d64a7c29dfaa451c4ab4880424a8fe8cee",
                "patch": "@@ -995,7 +995,8 @@ public void checkBlockBuilder(boolean optimizing, String expected) {\n             + \"  final int _b = 1 + 2;\\n\"\n             + \"  final int _c = 1 + 3;\\n\"\n             + \"  final int _d = 1 + 4;\\n\"\n-            + \"  org.apache.calcite.linq4j.test.ExpressionTest.bar(1, _b, _c, _d, org.apache.calcite.linq4j.test.ExpressionTest.foo(_c));\\n\"\n+            + \"  final int _b0 = 1 + 3;\\n\"\n+            + \"  org.apache.calcite.linq4j.test.ExpressionTest.bar(1, _b, _c, _d, org.apache.calcite.linq4j.test.ExpressionTest.foo(_b0));\\n\"\n             + \"}\\n\",\n         Expressions.toString(expression));\n     expression.accept(new Shuttle());",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2765] Bump Janino dependency to 3.0.11 (Fokko Driesprong)\n\nFixes some small issues and NPE fixes http://janino-compiler.github.io/janino/changelog.html\n\nfixes #988",
        "commit": "https://github.com/apache/calcite/commit/01c8a454622771a8542b1fbdf5b175ff76227bb2",
        "parent": "https://github.com/apache/calcite/commit/1556cdd4bb67e85f1e4036730fa510a29db59df3",
        "bug_id": "calcite_17",
        "file": [
            {
                "sha": "155395eae13a167cfa59b13fca456be4eba03a00",
                "filename": "pom.xml",
                "blob_url": "https://github.com/apache/calcite/blob/01c8a454622771a8542b1fbdf5b175ff76227bb2/pom.xml",
                "raw_url": "https://github.com/apache/calcite/raw/01c8a454622771a8542b1fbdf5b175ff76227bb2/pom.xml",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/pom.xml?ref=01c8a454622771a8542b1fbdf5b175ff76227bb2",
                "patch": "@@ -103,7 +103,7 @@ limitations under the License.\n     <hydromatic-toolbox.version>0.3</hydromatic-toolbox.version>\n     <hydromatic-tpcds.version>0.4</hydromatic-tpcds.version>\n     <jackson.version>2.9.6</jackson.version>\n-    <janino.version>3.0.9</janino.version>\n+    <janino.version>3.0.11</janino.version>\n     <java-diff.version>1.1.2</java-diff.version>\n     <javacc-maven-plugin.version>2.4</javacc-maven-plugin.version>\n     <jcip-annotations.version>1.0-1</jcip-annotations.version>",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2474] SqlAdvisor: avoid NPE in lookupFromHints where FROM is empty",
        "commit": "https://github.com/apache/calcite/commit/14a98e93949d016bb4a4d105e42414410803c8e4",
        "parent": "https://github.com/apache/calcite/commit/1c913e1b0499e85b5bfcb6495e478d68ad34d280",
        "bug_id": "calcite_18",
        "file": [
            {
                "sha": "70b8d970b03d1a6727d162f4b40d9b55a7d42118",
                "filename": "core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/14a98e93949d016bb4a4d105e42414410803c8e4/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/14a98e93949d016bb4a4d105e42414410803c8e4/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "status": "modified",
                "changes": 4,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java?ref=14a98e93949d016bb4a4d105e42414410803c8e4",
                "patch": "@@ -704,6 +704,10 @@ private void lookupFromHints(\n       SqlValidatorScope scope,\n       SqlParserPos pos,\n       Collection<SqlMoniker> hintList) {\n+    if (node == null) {\n+      // This can happen in cases like \"select * _suggest_\", so from clause is absent\n+      return;\n+    }\n     final SqlValidatorNamespace ns = getNamespace(node);\n     if (ns.isWrapperFor(IdentifierNamespace.class)) {\n       IdentifierNamespace idNs = ns.unwrap(IdentifierNamespace.class);",
                "deletions": 0
            },
            {
                "sha": "8734bcdd1f5193289bd54d2654b3a98b487d1d2b",
                "filename": "core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/14a98e93949d016bb4a4d105e42414410803c8e4/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/14a98e93949d016bb4a4d105e42414410803c8e4/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "status": "modified",
                "changes": 7,
                "additions": 7,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java?ref=14a98e93949d016bb4a4d105e42414410803c8e4",
                "patch": "@@ -1339,6 +1339,13 @@ private void testSimpleParserQuotedIdImpl() {\n         ImmutableMap.of(\"COLUMN(isOne)\", \"isOne\"));\n   }\n \n+  @Test @WithLex(Lex.JAVA) public void testAdviceEmptyFrom() {\n+    String sql;\n+    sql = \"select * from^\";\n+    assertComplete(sql, \"KEYWORD(FROM)\\n\", \"from\",\n+        ImmutableMap.of(\"KEYWORD(FROM)\", \"from\"));\n+  }\n+\n   @Test public void testInsert() throws Exception {\n     String sql;\n     sql = \"insert into emp(empno, mgr) select ^ from dept a\";",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2081] Query with windowed aggregates under both sides of a JOIN throws NullPointerException (Zhen Wang)\n\nFixed by introducing a counter so that the two windows would have\ndistinct variable names in generated code. Before this fix there was\na NullPointerException during code generation.\n\nRemove an unused constant.\n\nClose apache/calcite#634",
        "commit": "https://github.com/apache/calcite/commit/a1fe769114a15559b5f352059aec1f91f416a28b",
        "parent": "https://github.com/apache/calcite/commit/37a83b10293d80f3d3b89df8027d0311d2f95cfa",
        "bug_id": "calcite_19",
        "file": [
            {
                "sha": "dfae89f8dd1bcf391b1ae698598ec02bfb048815",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java",
                "blob_url": "https://github.com/apache/calcite/blob/a1fe769114a15559b5f352059aec1f91f416a28b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java",
                "raw_url": "https://github.com/apache/calcite/raw/a1fe769114a15559b5f352059aec1f91f416a28b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java",
                "status": "modified",
                "changes": 7,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java?ref=a1fe769114a15559b5f352059aec1f91f416a28b",
                "patch": "@@ -67,17 +67,12 @@\n  * operators of {@link EnumerableConvention} calling convention.\n  */\n public class EnumerableRelImplementor extends JavaRelImplementor {\n-  /** Maximum number of arguments to a constructor. See\n-   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1097\">[CALCITE-1097]\n-   * Exception when executing query with too many aggregation columns</a> for\n-   * details. */\n-  private static final int MAX_CONSTRUCTOR_ARG_COUNT = 10;\n-\n   public final Map<String, Object> map;\n   private final Map<String, RexToLixTranslator.InputGetter> corrVars =\n       Maps.newHashMap();\n   private final Map<Object, ParameterExpression> stashedParameters =\n       Maps.newIdentityHashMap();\n+  int windowCount = 0;\n \n   protected final Function1<String, RexToLixTranslator.InputGetter> allCorrelateVariables =\n       new Function1<String, RexToLixTranslator.InputGetter>() {",
                "deletions": 6
            },
            {
                "sha": "9c7c7370efee8fb2fdeecc1b74b9e555085158fc",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java",
                "blob_url": "https://github.com/apache/calcite/blob/a1fe769114a15559b5f352059aec1f91f416a28b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java",
                "raw_url": "https://github.com/apache/calcite/raw/a1fe769114a15559b5f352059aec1f91f416a28b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java",
                "status": "modified",
                "changes": 5,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java?ref=a1fe769114a15559b5f352059aec1f91f416a28b",
                "patch": "@@ -175,10 +175,11 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n \n     PhysType inputPhysType = result.physType;\n \n+    final int w = implementor.windowCount++;\n     ParameterExpression prevStart =\n-        Expressions.parameter(int.class, builder.newName(\"prevStart\"));\n+        Expressions.parameter(int.class, builder.newName(\"prevStart\" + w));\n     ParameterExpression prevEnd =\n-        Expressions.parameter(int.class, builder.newName(\"prevEnd\"));\n+        Expressions.parameter(int.class, builder.newName(\"prevEnd\" + w));\n \n     builder.add(Expressions.declare(0, prevStart, null));\n     builder.add(Expressions.declare(0, prevEnd, null));",
                "deletions": 2
            },
            {
                "sha": "809db7779ae3ea4afa1e195f5ef0051c34d1333d",
                "filename": "core/src/test/resources/sql/winagg.iq",
                "blob_url": "https://github.com/apache/calcite/blob/a1fe769114a15559b5f352059aec1f91f416a28b/core/src/test/resources/sql/winagg.iq",
                "raw_url": "https://github.com/apache/calcite/raw/a1fe769114a15559b5f352059aec1f91f416a28b/core/src/test/resources/sql/winagg.iq",
                "status": "modified",
                "changes": 26,
                "additions": 26,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/sql/winagg.iq?ref=a1fe769114a15559b5f352059aec1f91f416a28b",
                "patch": "@@ -404,4 +404,30 @@ order by gender, r;\n \n !ok\n \n+# [CALCITE-2081] Two windows under a JOIN\n+select a.\"deptno\", a.r as ar, b.r as br\n+from (\n+  select \"deptno\", first_value(\"empid\") over w as r\n+  from \"hr\".\"emps\"\n+  window w as (partition by \"deptno\" order by \"commission\")) a\n+join (\n+  select \"deptno\", last_value(\"empid\") over w as r\n+  from \"hr\".\"emps\"\n+  window w as (partition by \"deptno\" order by \"commission\")) b\n+on a.\"deptno\" = b.\"deptno\"\n+limit 5;\n+\n++--------+-----+-----+\n+| deptno | AR  | BR  |\n++--------+-----+-----+\n+|     10 | 110 | 110 |\n+|     10 | 110 | 110 |\n+|     10 | 110 | 110 |\n+|     20 | 200 | 200 |\n+|     20 | 200 |     |\n++--------+-----+-----+\n+(5 rows)\n+\n+!ok\n+\n # End winagg.iq",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2429] NPE: SqlValidatorImpl.lookupFieldNamespace when SQL Advisor observes non-existing field",
        "commit": "https://github.com/apache/calcite/commit/a18a380095c9f0bb3da9912748a5b368e547134f",
        "parent": "https://github.com/apache/calcite/commit/6496cb76301e71911bdbe537bfa7af64b346c243",
        "bug_id": "calcite_20",
        "file": [
            {
                "sha": "3bb0cd4478cbaead6edc0008302ed1060f96b956",
                "filename": "core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/a18a380095c9f0bb3da9912748a5b368e547134f/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/a18a380095c9f0bb3da9912748a5b368e547134f/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "status": "modified",
                "changes": 3,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java?ref=a18a380095c9f0bb3da9912748a5b368e547134f",
                "patch": "@@ -4831,6 +4831,9 @@ public void setOriginal(SqlNode expr, SqlNode original) {\n   SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {\n     final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();\n     final RelDataTypeField field = nameMatcher.field(rowType, name);\n+    if (field == null) {\n+      return null;\n+    }\n     return new FieldNamespace(this, field.getType());\n   }\n ",
                "deletions": 0
            },
            {
                "sha": "8261b8d0d776e5b8562f04785aef8b33bd359189",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/a18a380095c9f0bb3da9912748a5b368e547134f/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/a18a380095c9f0bb3da9912748a5b368e547134f/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "status": "modified",
                "changes": 8,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcTest.java?ref=a18a380095c9f0bb3da9912748a5b368e547134f",
                "patch": "@@ -413,6 +413,14 @@ private static String q(String s) {\n             \"id=empid; names=[empid]; type=COLUMN\"));\n   }\n \n+  @Test public void testSqlAdvisorNonExistingColumn()\n+      throws SQLException, ClassNotFoundException {\n+    adviseSql(\"select e.empdid_wrong_name.^ from \\\"hr\\\".\\\"emps\\\" e\",\n+        CalciteAssert.checkResultUnordered(\n+            \"id=*; names=[*]; type=KEYWORD\",\n+            \"id=; names=null; type=MATCH\"));\n+  }\n+\n   @Test public void testSqlAdvisorTableInSchema()\n       throws SQLException, ClassNotFoundException {\n     adviseSql(\"select * from \\\"hr\\\".^\",",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1054] NullPointerException caused by wrong code generation for TIMESTAMP fields\n\nAlso, tests for related/duplicate cases:\n* [CALCITE-1427] Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP fields\n* [CALCITE-1188] NullPointerException in EXTRACT with WHERE ... IN clause if field has null value\n\nClose apache/calcite#604",
        "commit": "https://github.com/apache/calcite/commit/d1bada4231c2ce81b6236e0c11d73c85a7df6e83",
        "parent": "https://github.com/apache/calcite/commit/26b18910f267233f812c3774723516742b5b3f42",
        "bug_id": "calcite_21",
        "file": [
            {
                "sha": "fe0cc7f142cd8eba4e581c22de23d920310870f7",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "status": "modified",
                "changes": 21,
                "additions": 17,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java?ref=d1bada4231c2ce81b6236e0c11d73c85a7df6e83",
                "patch": "@@ -56,8 +56,10 @@\n import org.apache.calcite.util.ImmutableIntList;\n import org.apache.calcite.util.Util;\n \n+import com.google.common.base.Function;\n import com.google.common.base.Supplier;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n import java.lang.reflect.Constructor;\n@@ -935,15 +937,26 @@ private static Expression implementNullSemantics(\n   }\n \n   private static Expression implementCall(\n-      RexToLixTranslator translator,\n+      final RexToLixTranslator translator,\n       RexCall call,\n       NotNullImplementor implementor,\n-      NullAs nullAs) {\n-    final List<Expression> translatedOperands =\n+      final NullAs nullAs) {\n+    List<Expression> translatedOperands =\n         translator.translateList(call.getOperands());\n+    // Make sure the operands have all been handled for nulls before\n+    // being passed to the NotNullImplementor.\n+    if (nullAs == NullAs.NOT_POSSIBLE) {\n+      translatedOperands = Lists.transform(\n+          translatedOperands,\n+          new Function<Expression, Expression>() {\n+            public Expression apply(Expression e) {\n+              return translator.handleNull(e, nullAs);\n+            }\n+          });\n+    }\n     Expression result =\n         implementor.implement(translator, call, translatedOperands);\n-    return nullAs.handle(result);\n+    return translator.handleNull(result, nullAs);\n   }\n \n   /** Strategy what an operator should return if one of its",
                "deletions": 4
            },
            {
                "sha": "083df7c626ca4854dc4dd35ca62ae74719025685",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java",
                "blob_url": "https://github.com/apache/calcite/blob/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java",
                "raw_url": "https://github.com/apache/calcite/raw/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java",
                "status": "modified",
                "changes": 66,
                "additions": 40,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java?ref=d1bada4231c2ce81b6236e0c11d73c85a7df6e83",
                "patch": "@@ -596,6 +596,45 @@ Expression translateCast(\n     return convert;\n   }\n \n+  /** Adapts an expression with \"normal\" result to one that adheres to\n+   * this particular policy. Wraps the result expression into a new\n+   * parameter if need be.\n+   *\n+   * @param input Expression\n+   * @param nullAs If false, if expression is definitely not null at\n+   *   runtime. Therefore we can optimize. For example, we can cast to int\n+   *   using x.intValue().\n+   * @return Translated expression\n+   */\n+  public Expression handleNull(Expression input, RexImpTable.NullAs nullAs) {\n+    final Expression nullHandled = nullAs.handle(input);\n+\n+    // If we get ConstantExpression, just return it (i.e. primitive false)\n+    if (nullHandled instanceof ConstantExpression) {\n+      return nullHandled;\n+    }\n+\n+    // if nullHandled expression is the same as \"input\",\n+    // then we can just reuse it\n+    if (nullHandled == input) {\n+      return input;\n+    }\n+\n+    // If nullHandled is different, then it might be unsafe to compute\n+    // early (i.e. unbox of null value should not happen _before_ ternary).\n+    // Thus we wrap it into brand-new ParameterExpression,\n+    // and we are guaranteed that ParameterExpression will not be shared\n+    String unboxVarName = \"v_unboxed\";\n+    if (input instanceof ParameterExpression) {\n+      unboxVarName = ((ParameterExpression) input).name + \"_unboxed\";\n+    }\n+    ParameterExpression unboxed = Expressions.parameter(nullHandled.getType(),\n+        list.newName(unboxVarName));\n+    list.add(Expressions.declare(Modifier.FINAL, unboxed, nullHandled));\n+\n+    return unboxed;\n+  }\n+\n   /** Translates an expression that is not in the cache.\n    *\n    * @param expr Expression\n@@ -621,32 +660,7 @@ private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs,\n         // unboxing via nullAs.handle below.\n         return input;\n       }\n-      Expression nullHandled = nullAs.handle(input);\n-\n-      // If we get ConstantExpression, just return it (i.e. primitive false)\n-      if (nullHandled instanceof ConstantExpression) {\n-        return nullHandled;\n-      }\n-\n-      // if nullHandled expression is the same as \"input\",\n-      // then we can just reuse it\n-      if (nullHandled == input) {\n-        return input;\n-      }\n-\n-      // If nullHandled is different, then it might be unsafe to compute\n-      // early (i.e. unbox of null value should not happen _before_ ternary).\n-      // Thus we wrap it into brand-new ParameterExpression,\n-      // and we are guaranteed that ParameterExpression will not be shared\n-      String unboxVarName = \"v_unboxed\";\n-      if (input instanceof ParameterExpression) {\n-        unboxVarName = ((ParameterExpression) input).name + \"_unboxed\";\n-      }\n-      ParameterExpression unboxed = Expressions.parameter(nullHandled.getType(),\n-          list.newName(unboxVarName));\n-      list.add(Expressions.declare(Modifier.FINAL, unboxed, nullHandled));\n-\n-      return unboxed;\n+      return handleNull(input, nullAs);\n     case LOCAL_REF:\n       return translate(\n           deref(expr),",
                "deletions": 26
            },
            {
                "sha": "8f7f9d810f861ff62adb9e7689678d08afb60198",
                "filename": "example/csv/src/test/java/org/apache/calcite/test/CsvTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/example/csv/src/test/java/org/apache/calcite/test/CsvTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/example/csv/src/test/java/org/apache/calcite/test/CsvTest.java",
                "status": "modified",
                "changes": 169,
                "additions": 167,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/example/csv/src/test/java/org/apache/calcite/test/CsvTest.java?ref=d1bada4231c2ce81b6236e0c11d73c85a7df6e83",
                "patch": "@@ -56,6 +56,7 @@\n import java.util.concurrent.Callable;\n \n import static org.hamcrest.CoreMatchers.anyOf;\n+import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.CoreMatchers.isA;\n import static org.hamcrest.CoreMatchers.nullValue;\n@@ -588,8 +589,9 @@ private String range(int first, int count) {\n     try (Connection connection\n         = DriverManager.getConnection(\"jdbc:calcite:\", info)) {\n       Statement statement = connection.createStatement();\n-      ResultSet resultSet =\n-          statement.executeQuery(\"select * from \\\"DATE\\\" where EMPNO >= 140\");\n+      final String sql = \"select * from \\\"DATE\\\"\\n\"\n+          + \"where EMPNO >= 140 and EMPNO < 200\";\n+      ResultSet resultSet = statement.executeQuery(sql);\n       int n = 0;\n       while (resultSet.next()) {\n         ++n;\n@@ -707,6 +709,169 @@ private String range(int first, int count) {\n     }\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1054\">[CALCITE-1054]\n+   * NPE caused by wrong code generation for Timestamp fields</a>. */\n+  @Test public void testFilterOnNullableTimestamp() throws Exception {\n+    Properties info = new Properties();\n+    info.put(\"model\", jsonPath(\"bug\"));\n+\n+    try (Connection connection =\n+             DriverManager.getConnection(\"jdbc:calcite:\", info)) {\n+      final Statement statement = connection.createStatement();\n+\n+      // date\n+      final String sql1 = \"select JOINEDAT from \\\"DATE\\\"\\n\"\n+          + \"where JOINEDAT < {d '2000-01-01'}\\n\"\n+          + \"or JOINEDAT >= {d '2017-01-01'}\";\n+      final ResultSet joinedAt = statement.executeQuery(sql1);\n+      assertThat(joinedAt.next(), is(true));\n+      assertThat(joinedAt.getDate(1), is(java.sql.Date.valueOf(\"1996-08-03\")));\n+\n+      // time\n+      final String sql2 = \"select JOINTIME from \\\"DATE\\\"\\n\"\n+          + \"where JOINTIME >= {t '07:00:00'}\\n\"\n+          + \"and JOINTIME < {t '08:00:00'}\";\n+      final ResultSet joinTime = statement.executeQuery(sql2);\n+      assertThat(joinTime.next(), is(true));\n+      assertThat(joinTime.getTime(1), is(java.sql.Time.valueOf(\"07:15:56\")));\n+\n+      // timestamp\n+      final String sql3 = \"select JOINTIMES,\\n\"\n+          + \"  {fn timestampadd(SQL_TSI_DAY, 1, JOINTIMES)}\\n\"\n+          + \"from \\\"DATE\\\"\\n\"\n+          + \"where (JOINTIMES >= {ts '2003-01-01 00:00:00'}\\n\"\n+          + \"and JOINTIMES < {ts '2006-01-01 00:00:00'})\\n\"\n+          + \"or (JOINTIMES >= {ts '2003-01-01 00:00:00'}\\n\"\n+          + \"and JOINTIMES < {ts '2007-01-01 00:00:00'})\";\n+      final ResultSet joinTimes = statement.executeQuery(sql3);\n+      assertThat(joinTimes.next(), is(true));\n+      assertThat(joinTimes.getTimestamp(1),\n+          is(java.sql.Timestamp.valueOf(\"2005-09-07 00:00:00\")));\n+      assertThat(joinTimes.getTimestamp(2),\n+          is(java.sql.Timestamp.valueOf(\"2005-09-08 00:00:00\")));\n+\n+      final String sql4 = \"select JOINTIMES, extract(year from JOINTIMES)\\n\"\n+          + \"from \\\"DATE\\\"\";\n+      final ResultSet joinTimes2 = statement.executeQuery(sql4);\n+      assertThat(joinTimes2.next(), is(true));\n+      assertThat(joinTimes2.getTimestamp(1),\n+          is(java.sql.Timestamp.valueOf(\"1996-08-03 00:01:02\")));\n+    }\n+  }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1118\">[CALCITE-1118]\n+   * NullPointerException in EXTRACT with WHERE ... IN clause if field has null\n+   * value</a>. */\n+  @Test public void testFilterOnNullableTimestamp2() throws Exception {\n+    Properties info = new Properties();\n+    info.put(\"model\", jsonPath(\"bug\"));\n+\n+    try (Connection connection =\n+             DriverManager.getConnection(\"jdbc:calcite:\", info)) {\n+      final Statement statement = connection.createStatement();\n+      final String sql1 = \"select extract(year from JOINTIMES)\\n\"\n+          + \"from \\\"DATE\\\"\\n\"\n+          + \"where extract(year from JOINTIMES) in (2006, 2007)\";\n+      final ResultSet joinTimes = statement.executeQuery(sql1);\n+      assertThat(joinTimes.next(), is(true));\n+      assertThat(joinTimes.getInt(1), is(2007));\n+\n+      final String sql2 = \"select extract(year from JOINTIMES),\\n\"\n+          + \"  count(0) from \\\"DATE\\\"\\n\"\n+          + \"where extract(year from JOINTIMES) between 2007 and 2016\\n\"\n+          + \"group by extract(year from JOINTIMES)\";\n+      final ResultSet joinTimes2 = statement.executeQuery(sql2);\n+      assertThat(joinTimes2.next(), is(true));\n+      assertThat(joinTimes2.getInt(1), is(2007));\n+      assertThat(joinTimes2.getLong(2), is(1L));\n+      assertThat(joinTimes2.next(), is(true));\n+      assertThat(joinTimes2.getInt(1), is(2015));\n+      assertThat(joinTimes2.getLong(2), is(2L));\n+    }\n+  }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1427\">[CALCITE-1427]\n+   * Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP\n+   * fields</a>. */\n+  @Test public void testNonNullFilterOnDateType() throws SQLException {\n+    Properties info = new Properties();\n+    info.put(\"model\", jsonPath(\"bug\"));\n+\n+    try (Connection connection =\n+             DriverManager.getConnection(\"jdbc:calcite:\", info)) {\n+      final Statement statement = connection.createStatement();\n+\n+      // date\n+      final String sql1 = \"select JOINEDAT from \\\"DATE\\\"\\n\"\n+          + \"where JOINEDAT is not null\";\n+      final ResultSet joinedAt = statement.executeQuery(sql1);\n+      assertThat(joinedAt.next(), is(true));\n+      assertThat(joinedAt.getDate(1).getClass(), equalTo(java.sql.Date.class));\n+      assertThat(joinedAt.getDate(1), is(java.sql.Date.valueOf(\"1996-08-03\")));\n+\n+      // time\n+      final String sql2 = \"select JOINTIME from \\\"DATE\\\"\\n\"\n+          + \"where JOINTIME is not null\";\n+      final ResultSet joinTime = statement.executeQuery(sql2);\n+      assertThat(joinTime.next(), is(true));\n+      assertThat(joinTime.getTime(1).getClass(), equalTo(java.sql.Time.class));\n+      assertThat(joinTime.getTime(1), is(java.sql.Time.valueOf(\"00:01:02\")));\n+\n+      // timestamp\n+      final String sql3 = \"select JOINTIMES from \\\"DATE\\\"\\n\"\n+          + \"where JOINTIMES is not null\";\n+      final ResultSet joinTimes = statement.executeQuery(sql3);\n+      assertThat(joinTimes.next(), is(true));\n+      assertThat(joinTimes.getTimestamp(1).getClass(),\n+          equalTo(java.sql.Timestamp.class));\n+      assertThat(joinTimes.getTimestamp(1),\n+          is(java.sql.Timestamp.valueOf(\"1996-08-03 00:01:02\")));\n+    }\n+  }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1427\">[CALCITE-1427]\n+   * Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP\n+   * fields</a>. */\n+  @Test public void testGreaterThanFilterOnDateType() throws SQLException {\n+    Properties info = new Properties();\n+    info.put(\"model\", jsonPath(\"bug\"));\n+\n+    try (Connection connection =\n+             DriverManager.getConnection(\"jdbc:calcite:\", info)) {\n+      final Statement statement = connection.createStatement();\n+\n+      // date\n+      final String sql1 = \"select JOINEDAT from \\\"DATE\\\"\\n\"\n+          + \"where JOINEDAT > {d '1990-01-01'}\";\n+      final ResultSet joinedAt = statement.executeQuery(sql1);\n+      assertThat(joinedAt.next(), is(true));\n+      assertThat(joinedAt.getDate(1).getClass(), equalTo(java.sql.Date.class));\n+      assertThat(joinedAt.getDate(1), is(java.sql.Date.valueOf(\"1996-08-03\")));\n+\n+      // time\n+      final String sql2 = \"select JOINTIME from \\\"DATE\\\"\\n\"\n+          + \"where JOINTIME > {t '00:00:00'}\";\n+      final ResultSet joinTime = statement.executeQuery(sql2);\n+      assertThat(joinTime.next(), is(true));\n+      assertThat(joinTime.getTime(1).getClass(), equalTo(java.sql.Time.class));\n+      assertThat(joinTime.getTime(1), is(java.sql.Time.valueOf(\"00:01:02\")));\n+\n+      // timestamp\n+      final String sql3 = \"select JOINTIMES from \\\"DATE\\\"\\n\"\n+          + \"where JOINTIMES > {ts '1990-01-01 00:00:00'}\";\n+      final ResultSet joinTimes = statement.executeQuery(sql3);\n+      assertThat(joinTimes.next(), is(true));\n+      assertThat(joinTimes.getTimestamp(1).getClass(),\n+          equalTo(java.sql.Timestamp.class));\n+      assertThat(joinTimes.getTimestamp(1),\n+          is(java.sql.Timestamp.valueOf(\"1996-08-03 00:01:02\")));\n+    }\n+  }\n+\n   @Test(timeout = 10000) public void testCsvStream() throws Exception {\n     final File file = File.createTempFile(\"stream\", \"csv\");\n     final String model = \"{\\n\"",
                "deletions": 2
            },
            {
                "sha": "2999baf6a02bc8b0c29854814336d724a0d689a7",
                "filename": "example/csv/src/test/resources/bug/DATE.csv",
                "blob_url": "https://github.com/apache/calcite/blob/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/example/csv/src/test/resources/bug/DATE.csv",
                "raw_url": "https://github.com/apache/calcite/raw/d1bada4231c2ce81b6236e0c11d73c85a7df6e83/example/csv/src/test/resources/bug/DATE.csv",
                "status": "modified",
                "changes": 1,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/example/csv/src/test/resources/bug/DATE.csv?ref=d1bada4231c2ce81b6236e0c11d73c85a7df6e83",
                "patch": "@@ -6,3 +6,4 @@ EMPNO:int,JOINEDAT:date,JOINTIME:time,JOINTIMES:timestamp\n 130,\"2007-01-01\",\"00:00:00\",\"2007-01-01 00:00:00\"\n 140,\"2015-12-31\",\"07:15:56\",\"2015-12-31 07:15:56\"\n 150,\"2015-12-31\",\"13:31:21\",\"2015-12-31 13:31:21\"\n+200,,,",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1860] Duplicate null predicates cause NullPointerException in RexUtil (Ruidong Li)\n\nClose apache/calcite#484",
        "commit": "https://github.com/apache/calcite/commit/5a91d0a41e88423eb17a85cb5d1382905181b59d",
        "parent": "https://github.com/apache/calcite/commit/a2faf47b0f2bc98482a39ff51c23f7b92c118fee",
        "bug_id": "calcite_22",
        "file": [
            {
                "sha": "33644ce789bacf19a0267cfbccd2e08e3a8bd732",
                "filename": "core/src/main/java/org/apache/calcite/rex/RexUtil.java",
                "blob_url": "https://github.com/apache/calcite/blob/5a91d0a41e88423eb17a85cb5d1382905181b59d/core/src/main/java/org/apache/calcite/rex/RexUtil.java",
                "raw_url": "https://github.com/apache/calcite/raw/5a91d0a41e88423eb17a85cb5d1382905181b59d/core/src/main/java/org/apache/calcite/rex/RexUtil.java",
                "status": "modified",
                "changes": 5,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rex/RexUtil.java?ref=5a91d0a41e88423eb17a85cb5d1382905181b59d",
                "patch": "@@ -63,6 +63,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n import javax.annotation.Nonnull;\n \n@@ -433,8 +434,8 @@ private static void decompose(Set<RexNode> set, RexNode rexNode) {\n     } else {\n       if (existedValue instanceof RexLiteral\n           && constant instanceof RexLiteral\n-          && !((RexLiteral) existedValue).getValue()\n-              .equals(((RexLiteral) constant).getValue())) {\n+          && !Objects.equals(((RexLiteral) existedValue).getValue(),\n+              ((RexLiteral) constant).getValue())) {\n         // we found conflicting values, e.g. left = 10 and left = 20\n         map.remove(left);\n         excludeSet.add(left);",
                "deletions": 2
            },
            {
                "sha": "6c973f00e2ab56b8a9aa9457beca37937b7b64a2",
                "filename": "core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/5a91d0a41e88423eb17a85cb5d1382905181b59d/core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/5a91d0a41e88423eb17a85cb5d1382905181b59d/core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java",
                "status": "modified",
                "changes": 17,
                "additions": 17,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java?ref=5a91d0a41e88423eb17a85cb5d1382905181b59d",
                "patch": "@@ -1553,6 +1553,23 @@ public void testMinusMergeRule() throws Exception {\n         \"select * from (values (1,2)) where 1 + 2 > 3 + CAST(NULL AS INTEGER)\");\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1860\">[CALCITE-1860]\n+   * Duplicate null predicates cause NullPointerException in RexUtil</a>. */\n+  @Test public void testReduceConstantsNull() throws Exception {\n+    HepProgram program = new HepProgramBuilder()\n+        .addRuleInstance(ReduceExpressionsRule.FILTER_INSTANCE)\n+        .build();\n+    final String sql = \"select * from (\\n\"\n+        + \"  select *\\n\"\n+        + \"  from (\\n\"\n+        + \"    select cast(null as integer) as n\\n\"\n+        + \"    from emp)\\n\"\n+        + \"  where n is null and n is null)\\n\"\n+        + \"where n is null\";\n+    sql(sql).with(program).check();\n+  }\n+\n   /** Test case for\n    * <a href=\"https://issues.apache.org/jira/browse/CALCITE-566\">[CALCITE-566]\n    * ReduceExpressionsRule requires planner to have an Executor</a>. */",
                "deletions": 0
            },
            {
                "sha": "ea684e50b3966aad0c49ebd2e069d19c85351252",
                "filename": "core/src/test/resources/org/apache/calcite/test/RelOptRulesTest.xml",
                "blob_url": "https://github.com/apache/calcite/blob/5a91d0a41e88423eb17a85cb5d1382905181b59d/core/src/test/resources/org/apache/calcite/test/RelOptRulesTest.xml",
                "raw_url": "https://github.com/apache/calcite/raw/5a91d0a41e88423eb17a85cb5d1382905181b59d/core/src/test/resources/org/apache/calcite/test/RelOptRulesTest.xml",
                "status": "modified",
                "changes": 29,
                "additions": 29,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/org/apache/calcite/test/RelOptRulesTest.xml?ref=5a91d0a41e88423eb17a85cb5d1382905181b59d",
                "patch": "@@ -5532,6 +5532,35 @@ LogicalProject(EMPNO=[$0])\n             <![CDATA[\n LogicalProject(EMPNO=[$0])\n   LogicalValues(tuples=[[]])\n+]]>\n+        </Resource>\n+    </TestCase>\n+    <TestCase name=\"testReduceConstantsNull\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select * from (\n+  select *\n+  from (\n+    select cast(null as integer) as n\n+    from emp)\n+  where n is null and n is null)\n+where n is null]]>\n+        </Resource>\n+        <Resource name=\"planBefore\">\n+            <![CDATA[\n+LogicalProject(N=[$0])\n+  LogicalFilter(condition=[IS NULL($0)])\n+    LogicalProject(N=[$0])\n+      LogicalFilter(condition=[AND(IS NULL($0), IS NULL($0))])\n+        LogicalProject(N=[null])\n+          LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+]]>\n+        </Resource>\n+        <Resource name=\"planAfter\">\n+            <![CDATA[\n+LogicalProject(N=[$0])\n+  LogicalProject(N=[$0])\n+    LogicalProject(N=[null])\n+      LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n ]]>\n         </Resource>\n     </TestCase>",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2703] Reduce code generation and class loading overhead when executing queries in the EnumerableConvention\n\n1. Add a configurable Guava cache in EnumerableInterpretable#getBindable to re-use Bindable instances.\n2. Avoid caching instances of classes with static fields.\n3. Add JMH benchmark for the expensive part of EnumerableInterpretable#getBindable method.\n4. Add utility method for obtaining integer runtime properties.\n5. NPE in VisitorImpl when visiting a FieldDeclaration without an initializer.",
        "commit": "https://github.com/apache/calcite/commit/e14cef28af2b4f0aac5c3876aa7023053e294ee1",
        "parent": "https://github.com/apache/calcite/commit/280642a02a4bcfd1fb9cbe8c5ab672d3619860e7",
        "bug_id": "calcite_23",
        "file": [
            {
                "sha": "86ed35c4f2d021ae392cb048f58a2c61ba124b23",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java",
                "blob_url": "https://github.com/apache/calcite/blob/e14cef28af2b4f0aac5c3876aa7023053e294ee1/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java",
                "raw_url": "https://github.com/apache/calcite/raw/e14cef28af2b4f0aac5c3876aa7023053e294ee1/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java",
                "status": "modified",
                "changes": 49,
                "additions": 41,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java?ref=e14cef28af2b4f0aac5c3876aa7023053e294ee1",
                "patch": "@@ -31,6 +31,8 @@\n import org.apache.calcite.linq4j.Enumerator;\n import org.apache.calcite.linq4j.tree.ClassDeclaration;\n import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.linq4j.tree.FieldDeclaration;\n+import org.apache.calcite.linq4j.tree.VisitorImpl;\n import org.apache.calcite.plan.ConventionTraitDef;\n import org.apache.calcite.plan.RelOptCluster;\n import org.apache.calcite.plan.RelTraitSet;\n@@ -43,15 +45,20 @@\n import org.apache.calcite.runtime.Utilities;\n import org.apache.calcite.util.Util;\n \n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+\n import org.codehaus.commons.compiler.CompileException;\n import org.codehaus.commons.compiler.CompilerFactoryFactory;\n import org.codehaus.commons.compiler.IClassBodyEvaluator;\n import org.codehaus.commons.compiler.ICompilerFactory;\n \n import java.io.IOException;\n import java.io.StringReader;\n+import java.lang.reflect.Modifier;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n \n /**\n  * Relational expression that converts an enumerable input to interpretable\n@@ -82,6 +89,18 @@ public Node implement(final InterpreterImplementor implementor) {\n     return new EnumerableNode(enumerable, implementor.compiler, this);\n   }\n \n+  /**\n+   * The cache storing Bindable objects, instantiated via dynamically generated Java classes.\n+   *\n+   * It allows to re-use Bindable objects for queries appearing relatively often. It is used\n+   * to avoid the cost of compiling and generating a new class and also instantiating the object.\n+   */\n+  private static final Cache<String, Bindable> BINDABLE_CACHE =\n+      CacheBuilder.newBuilder()\n+          .concurrencyLevel(CalciteSystemProperty.BINDABLE_CACHE_CONCURRENCY_LEVEL.value())\n+          .maximumSize(CalciteSystemProperty.BINDABLE_CACHE_MAX_SIZE.value())\n+          .build();\n+\n   public static Bindable toBindable(Map<String, Object> parameters,\n       CalcitePrepare.SparkHandler spark, EnumerableRel rel,\n       EnumerableRel.Prefer prefer) {\n@@ -110,22 +129,16 @@ public static Bindable toBindable(Map<String, Object> parameters,\n     }\n   }\n \n-  static ArrayBindable getArrayBindable(ClassDeclaration expr, String s,\n-      int fieldCount) throws CompileException, IOException {\n-    Bindable bindable = getBindable(expr, s, fieldCount);\n-    return box(bindable);\n-  }\n-\n   static Bindable getBindable(ClassDeclaration expr, String s, int fieldCount)\n-      throws CompileException, IOException {\n+      throws CompileException, IOException, ExecutionException {\n     ICompilerFactory compilerFactory;\n     try {\n       compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory();\n     } catch (Exception e) {\n       throw new IllegalStateException(\n           \"Unable to instantiate java compiler\", e);\n     }\n-    IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n+    final IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n     cbe.setClassName(expr.name);\n     cbe.setExtendedClass(Utilities.class);\n     cbe.setImplementedInterfaces(\n@@ -137,9 +150,29 @@ static Bindable getBindable(ClassDeclaration expr, String s, int fieldCount)\n       // Add line numbers to the generated janino class\n       cbe.setDebuggingInformation(true, true, true);\n     }\n+\n+    if (CalciteSystemProperty.BINDABLE_CACHE_MAX_SIZE.value() != 0) {\n+      StaticFieldDetector detector = new StaticFieldDetector();\n+      expr.accept(detector);\n+      if (!detector.containsStaticField) {\n+        return BINDABLE_CACHE.get(s, () -> (Bindable) cbe.createInstance(new StringReader(s)));\n+      }\n+    }\n     return (Bindable) cbe.createInstance(new StringReader(s));\n   }\n \n+  /**\n+   * A visitor detecting if the Java AST contains static fields.\n+   */\n+  static class StaticFieldDetector extends VisitorImpl<Void> {\n+    boolean containsStaticField = false;\n+\n+    @Override public Void visit(final FieldDeclaration fieldDeclaration) {\n+      containsStaticField = (fieldDeclaration.modifier & Modifier.STATIC) != 0;\n+      return containsStaticField ? null : super.visit(fieldDeclaration);\n+    }\n+  }\n+\n   /** Converts a bindable over scalar values into an array bindable, with each\n    * row as an array of 1 element. */\n   static ArrayBindable box(final Bindable bindable) {",
                "deletions": 8
            },
            {
                "sha": "0660b37818f44b6a594ad34b4561cdb7149677e3",
                "filename": "core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java",
                "blob_url": "https://github.com/apache/calcite/blob/e14cef28af2b4f0aac5c3876aa7023053e294ee1/core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java",
                "raw_url": "https://github.com/apache/calcite/raw/e14cef28af2b4f0aac5c3876aa7023053e294ee1/core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java",
                "status": "modified",
                "changes": 59,
                "additions": 57,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java?ref=e14cef28af2b4f0aac5c3876aa7023053e294ee1",
                "patch": "@@ -26,6 +26,7 @@\n import java.util.Properties;\n import java.util.Set;\n import java.util.function.Function;\n+import java.util.function.IntPredicate;\n import java.util.stream.Stream;\n \n /**\n@@ -245,14 +246,68 @@\n   public static final CalciteSystemProperty<Integer> METADATA_HANDLER_CACHE_MAXIMUM_SIZE =\n       intProperty(\"calcite.metadata.handler.cache.maximum.size\", 1000);\n \n+  /**\n+   * The maximum size of the cache used for storing Bindable objects, instantiated via\n+   * dynamically generated Java classes.\n+   *\n+   * <p>The default value is 0.</p>\n+   *\n+   * <p>The property can take any value between [0, {@link Integer#MAX_VALUE}] inclusive. If the\n+   * value is not valid (or not specified) then the default value is used.</p>\n+   *\n+   * <p>The cached objects may be quite big so it is suggested to use a rather small cache size\n+   * (e.g., 1000). For the most common use cases a number close to 1000 should be enough to\n+   * alleviate the performance penalty of compiling and loading classes.</p>\n+   *\n+   * <p>Setting this property to 0 disables the cache.</p>\n+   */\n+  public static final CalciteSystemProperty<Integer> BINDABLE_CACHE_MAX_SIZE =\n+      intProperty(\"calcite.bindable.cache.maxSize\", 0, v -> v >= 0 && v <= Integer.MAX_VALUE);\n+  /**\n+   * The concurrency level of the cache used for storing Bindable objects, instantiated via\n+   * dynamically generated Java classes.\n+   *\n+   * <p>The default value is 1.</p>\n+   *\n+   * <p>The property can take any value between [1, {@link Integer#MAX_VALUE}] inclusive. If the\n+   * value is not valid (or not specified) then the default value is used.</p>\n+   *\n+   * <p>This property has no effect if the cache is disabled (i.e., {@link #BINDABLE_CACHE_MAX_SIZE}\n+   * set to 0.</p>\n+   */\n+  public static final CalciteSystemProperty<Integer> BINDABLE_CACHE_CONCURRENCY_LEVEL =\n+      intProperty(\"calcite.bindable.cache.concurrencyLevel\", 1,\n+          v -> v >= 1 && v <= Integer.MAX_VALUE);\n+\n   private static CalciteSystemProperty<Boolean> booleanProperty(String key, boolean defaultValue) {\n     return new CalciteSystemProperty<>(key,\n         v -> v == null ? defaultValue : Boolean.parseBoolean(v));\n   }\n \n   private static CalciteSystemProperty<Integer> intProperty(String key, int defaultValue) {\n-    return new CalciteSystemProperty<>(key,\n-        v -> v == null ? defaultValue : Integer.parseInt(v));\n+    return intProperty(key, defaultValue, v -> true);\n+  }\n+\n+  /**\n+   * Returns the value of the system property with the specified name as int, or\n+   * the <code>defaultValue</code> if any of the conditions below hold:\n+   * (i) the property is not defined;\n+   * (ii) the property value cannot be transformed to an int;\n+   * (iii) the property value does not satisfy the checker.\n+   */\n+  private static CalciteSystemProperty<Integer> intProperty(String key, int defaultValue,\n+      IntPredicate valueChecker) {\n+    return new CalciteSystemProperty<>(key, v -> {\n+      if (v == null) {\n+        return defaultValue;\n+      }\n+      try {\n+        int intVal = Integer.parseInt(v);\n+        return valueChecker.test(intVal) ? intVal : defaultValue;\n+      } catch (NumberFormatException nfe) {\n+        return defaultValue;\n+      }\n+    });\n   }\n \n   private static CalciteSystemProperty<String> stringProperty(String key, String defaultValue) {",
                "deletions": 2
            },
            {
                "sha": "8a4bf5851946d31602032eda139b293e0db791d4",
                "filename": "linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/e14cef28af2b4f0aac5c3876aa7023053e294ee1/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/e14cef28af2b4f0aac5c3876aa7023053e294ee1/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java?ref=e14cef28af2b4f0aac5c3876aa7023053e294ee1",
                "patch": "@@ -78,7 +78,8 @@ public R visit(DynamicExpression dynamicExpression) {\n \n   public R visit(FieldDeclaration fieldDeclaration) {\n     R r0 = fieldDeclaration.parameter.accept(this);\n-    return fieldDeclaration.initializer.accept(this);\n+    return fieldDeclaration.initializer == null ? null\n+        : fieldDeclaration.initializer.accept(this);\n   }\n \n   public R visit(ForStatement forStatement) {",
                "deletions": 1
            },
            {
                "sha": "63028bde385d9eebd9d52a58723be9adaaf2cc32",
                "filename": "ubenchmark/pom.xml",
                "blob_url": "https://github.com/apache/calcite/blob/e14cef28af2b4f0aac5c3876aa7023053e294ee1/ubenchmark/pom.xml",
                "raw_url": "https://github.com/apache/calcite/raw/e14cef28af2b4f0aac5c3876aa7023053e294ee1/ubenchmark/pom.xml",
                "status": "modified",
                "changes": 19,
                "additions": 15,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/ubenchmark/pom.xml?ref=e14cef28af2b4f0aac5c3876aa7023053e294ee1",
                "patch": "@@ -39,6 +39,21 @@ limitations under the License.\n       <artifactId>calcite-core</artifactId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>org.apache.calcite</groupId>\n+      <artifactId>calcite-linq4j</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>com.google.guava</groupId>\n+      <artifactId>guava</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.codehaus.janino</groupId>\n+      <artifactId>commons-compiler</artifactId>\n+    </dependency>\n+\n     <dependency>\n       <groupId>org.openjdk.jmh</groupId>\n       <artifactId>jmh-core</artifactId>\n@@ -48,10 +63,6 @@ limitations under the License.\n       <artifactId>jmh-generator-annprocess</artifactId>\n       <scope>provided</scope>\n     </dependency>\n-    <dependency>\n-      <groupId>com.google.guava</groupId>\n-      <artifactId>guava</artifactId>\n-    </dependency>\n   </dependencies>\n \n   <build>",
                "deletions": 4
            },
            {
                "sha": "4c32cdeede55e81b6e3f3573e23e2b25f1072fb2",
                "filename": "ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/CodeGenerationBenchmark.java",
                "blob_url": "https://github.com/apache/calcite/blob/e14cef28af2b4f0aac5c3876aa7023053e294ee1/ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/CodeGenerationBenchmark.java",
                "raw_url": "https://github.com/apache/calcite/raw/e14cef28af2b4f0aac5c3876aa7023053e294ee1/ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/CodeGenerationBenchmark.java",
                "status": "added",
                "changes": 287,
                "additions": 287,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/CodeGenerationBenchmark.java?ref=e14cef28af2b4f0aac5c3876aa7023053e294ee1",
                "patch": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.jdbc.JavaTypeFactoryImpl;\n+import org.apache.calcite.linq4j.tree.ClassDeclaration;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.ConventionTraitDef;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.plan.volcano.VolcanoPlanner;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterToCalcRule;\n+import org.apache.calcite.rel.rules.ProjectToCalcRule;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.runtime.ArrayBindable;\n+import org.apache.calcite.runtime.Bindable;\n+import org.apache.calcite.runtime.Typed;\n+import org.apache.calcite.runtime.Utilities;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+\n+import org.codehaus.commons.compiler.CompilerFactoryFactory;\n+import org.codehaus.commons.compiler.IClassBodyEvaluator;\n+import org.codehaus.commons.compiler.ICompilerFactory;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.profile.GCProfiler;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A benchmark of the main methods that are dynamically\n+ * generating and compiling Java code at runtime.\n+ *\n+ * The benchmark examines the behavior of existing methods\n+ * and evaluates the potential of adding a caching layer on top.\n+ */\n+@Fork(value = 1, jvmArgsPrepend = \"-Xmx1024m\")\n+@Measurement(iterations = 10, time = 1)\n+@Warmup(iterations = 0)\n+@Threads(1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class CodeGenerationBenchmark {\n+\n+  /**\n+   * State holding the generated queries/plans and additional information\n+   * exploited by the embedded compiler in order to dynamically build a Java class.\n+   */\n+  @State(Scope.Thread)\n+  public static class QueryState {\n+    /**\n+     * The number of distinct queries to be generated.\n+     */\n+    @Param({\"1\", \"10\", \"100\", \"1000\"})\n+    int queries;\n+\n+    /**\n+     * The number of joins for each generated query.\n+     */\n+    @Param({\"1\", \"10\", \"20\"})\n+    int joins;\n+\n+    /**\n+     * The number of disjunctions for each generated query.\n+     */\n+    @Param({\"1\", \"10\", \"100\"})\n+    int whereClauseDisjunctions;\n+\n+    /**\n+     * The necessary plan information for every generated query.\n+     */\n+    PlanInfo[] planInfos;\n+\n+    private int currentPlan = 0;\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+      planInfos = new PlanInfo[queries];\n+      VolcanoPlanner planner = new VolcanoPlanner();\n+      planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n+      planner.addRule(FilterToCalcRule.INSTANCE);\n+      planner.addRule(ProjectToCalcRule.INSTANCE);\n+      planner.addRule(EnumerableRules.ENUMERABLE_CALC_RULE);\n+      planner.addRule(EnumerableRules.ENUMERABLE_JOIN_RULE);\n+      planner.addRule(EnumerableRules.ENUMERABLE_VALUES_RULE);\n+\n+      RelDataTypeFactory typeFactory =\n+          new JavaTypeFactoryImpl(org.apache.calcite.rel.type.RelDataTypeSystem.DEFAULT);\n+      RelOptCluster cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n+      RelTraitSet desiredTraits =\n+          cluster.traitSet().replace(EnumerableConvention.INSTANCE);\n+\n+      RelBuilder relBuilder = RelFactories.LOGICAL_BUILDER.create(cluster, null);\n+      // Generates queries of the following form depending on the configuration parameters.\n+      // SELECT `t`.`name`\n+      // FROM (VALUES  (1, 'Value0')) AS `t` (`id`, `name`)\n+      // INNER JOIN (VALUES  (1, 'Value1')) AS `t` (`id`, `name`) AS `t0` ON `t`.`id` = `t0`.`id`\n+      // INNER JOIN (VALUES  (2, 'Value2')) AS `t` (`id`, `name`) AS `t1` ON `t`.`id` = `t1`.`id`\n+      // INNER JOIN (VALUES  (3, 'Value3')) AS `t` (`id`, `name`) AS `t2` ON `t`.`id` = `t2`.`id`\n+      // INNER JOIN ...\n+      // WHERE\n+      //  `t`.`name` = 'name0' OR\n+      //  `t`.`name` = 'name1' OR\n+      //  `t`.`name` = 'name2' OR\n+      //  ...\n+      //  OR `t`.`id` = 0\n+      // The last disjunction (i.e, t.id = $i) is what makes the queries different from one another\n+      // by assigning a different constant literal.\n+      for (int i = 0; i < queries; i++) {\n+        relBuilder.values(new String[]{\"id\", \"name\"}, 1, \"Value\" + 0);\n+        for (int j = 1; j <= joins; j++) {\n+          relBuilder\n+              .values(new String[]{\"id\", \"name\"}, j, \"Value\" + j)\n+              .join(JoinRelType.INNER, \"id\");\n+        }\n+\n+        List<RexNode> disjunctions = new ArrayList<>();\n+        for (int j = 0; j < whereClauseDisjunctions; j++) {\n+          disjunctions.add(\n+              relBuilder.equals(\n+                  relBuilder.field(\"name\"),\n+                  relBuilder.literal(\"name\" + j)));\n+        }\n+        disjunctions.add(\n+            relBuilder.equals(\n+                relBuilder.field(\"id\"),\n+                relBuilder.literal(i)));\n+        RelNode query =\n+            relBuilder\n+                .filter(relBuilder.or(disjunctions))\n+                .project(relBuilder.field(\"name\"))\n+                .build();\n+\n+        RelNode query0 = planner.changeTraits(query, desiredTraits);\n+        planner.setRoot(query0);\n+\n+        PlanInfo info = new PlanInfo();\n+        EnumerableRel plan = (EnumerableRel) planner.findBestExp();\n+\n+        EnumerableRelImplementor relImplementor =\n+            new EnumerableRelImplementor(plan.getCluster().getRexBuilder(), new HashMap<>());\n+        info.classExpr = relImplementor.implementRoot(plan, EnumerableRel.Prefer.ARRAY);\n+        info.javaCode =\n+            Expressions.toString(info.classExpr.memberDeclarations, \"\\n\", false);\n+\n+        ICompilerFactory compilerFactory;\n+        try {\n+          compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory();\n+        } catch (Exception e) {\n+          throw new IllegalStateException(\n+              \"Unable to instantiate java compiler\", e);\n+        }\n+        IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n+        cbe.setClassName(info.classExpr.name);\n+        cbe.setExtendedClass(Utilities.class);\n+        cbe.setImplementedInterfaces(\n+            plan.getRowType().getFieldCount() == 1\n+                ? new Class[]{Bindable.class, Typed.class}\n+                : new Class[]{ArrayBindable.class});\n+        cbe.setParentClassLoader(EnumerableInterpretable.class.getClassLoader());\n+        info.cbe = cbe;\n+        planInfos[i] = info;\n+      }\n+\n+    }\n+\n+    int nextPlan() {\n+      int ret = currentPlan;\n+      currentPlan = (currentPlan + 1) % queries;\n+      return ret;\n+    }\n+  }\n+\n+  /***/\n+  private static class PlanInfo {\n+    ClassDeclaration classExpr;\n+    IClassBodyEvaluator cbe;\n+    String javaCode;\n+  }\n+\n+  /**\n+   * State holding a cache that is initialized\n+   * once at the beginning of each iteration.\n+   */\n+  @State(Scope.Thread)\n+  public static class CacheState {\n+    @Param({\"10\", \"100\", \"1000\"})\n+    int cacheSize;\n+\n+    Cache<String, Bindable> cache;\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+      cache = CacheBuilder.newBuilder().maximumSize(cacheSize).concurrencyLevel(1).build();\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Benchmarks the part creating Bindable instances from\n+   * {@link EnumerableInterpretable#getBindable(ClassDeclaration, String, int)}\n+   * method without any additional caching layer.\n+   */\n+  @Benchmark\n+  public Bindable<?> getBindableNoCache(QueryState state) throws Exception {\n+    PlanInfo info = state.planInfos[state.nextPlan()];\n+    return (Bindable) info.cbe.createInstance(new StringReader(info.javaCode));\n+  }\n+\n+  /**\n+   * Benchmarks the part of creating Bindable instances from\n+   * {@link EnumerableInterpretable#getBindable(ClassDeclaration, String, int)}\n+   * method with an additional cache layer.\n+   */\n+  @Benchmark\n+  public Bindable<?> getBindableWithCache(\n+      QueryState jState,\n+      CacheState chState) throws Exception {\n+    PlanInfo info = jState.planInfos[jState.nextPlan()];\n+    Cache<String, Bindable> cache = chState.cache;\n+\n+    EnumerableInterpretable.StaticFieldDetector detector\n+        = new EnumerableInterpretable.StaticFieldDetector();\n+    info.classExpr.accept(detector);\n+    if (!detector.containsStaticField) {\n+      return cache.get(\n+          info.javaCode,\n+          () -> (Bindable) info.cbe.createInstance(new StringReader(info.javaCode)));\n+    }\n+    throw new IllegalStateException(\"Benchmark queries should not arrive here\");\n+  }\n+\n+  public static void main(String[] args) throws RunnerException {\n+    Options opt = new OptionsBuilder()\n+        .include(CodeGenerationBenchmark.class.getName())\n+        .addProfiler(GCProfiler.class)\n+        .detectJvmArgs()\n+        .build();\n+\n+    new Runner(opt).run();\n+  }\n+}\n+\n+// End CodeGenerationBenchmark.java",
                "deletions": 0
            },
            {
                "sha": "061c3f43b80fc12c057e5acd5781c6631b079db7",
                "filename": "ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/package-info.java",
                "blob_url": "https://github.com/apache/calcite/blob/e14cef28af2b4f0aac5c3876aa7023053e294ee1/ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/package-info.java",
                "raw_url": "https://github.com/apache/calcite/raw/e14cef28af2b4f0aac5c3876aa7023053e294ee1/ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/package-info.java",
                "status": "added",
                "changes": 26,
                "additions": 26,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/ubenchmark/src/main/java/org/apache/calcite/adapter/enumerable/package-info.java?ref=e14cef28af2b4f0aac5c3876aa7023053e294ee1",
                "patch": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * JMH benchmarks for Calcite Enumerable adapter\n+ */\n+@PackageMarker\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.avatica.util.PackageMarker;\n+\n+// End package-info.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix NullPointerException in SqlJoin.toString",
        "commit": "https://github.com/apache/calcite/commit/cd92b77c476f7b095b330507402bfc6c3208e300",
        "parent": "https://github.com/apache/calcite/commit/239babd8fc26bf35be96a77fbfbea379138f3a37",
        "bug_id": "calcite_24",
        "file": [
            {
                "sha": "12b1fb0a222416acc4b9db9c0810021a3130c578",
                "filename": "core/src/main/java/org/apache/calcite/sql/SqlJoin.java",
                "blob_url": "https://github.com/apache/calcite/blob/cd92b77c476f7b095b330507402bfc6c3208e300/core/src/main/java/org/apache/calcite/sql/SqlJoin.java",
                "raw_url": "https://github.com/apache/calcite/raw/cd92b77c476f7b095b330507402bfc6c3208e300/core/src/main/java/org/apache/calcite/sql/SqlJoin.java",
                "status": "modified",
                "changes": 14,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/SqlJoin.java?ref=cd92b77c476f7b095b330507402bfc6c3208e300",
                "patch": "@@ -21,6 +21,8 @@\n import org.apache.calcite.util.ImmutableNullableList;\n import org.apache.calcite.util.Util;\n \n+import com.google.common.base.Preconditions;\n+\n import java.util.List;\n \n /**\n@@ -58,18 +60,15 @@ public SqlJoin(SqlParserPos pos, SqlNode left, SqlLiteral natural,\n       SqlNode condition) {\n     super(pos);\n     this.left = left;\n-    this.natural = natural;\n-    this.joinType = joinType;\n+    this.natural = Preconditions.checkNotNull(natural);\n+    this.joinType = Preconditions.checkNotNull(joinType);\n     this.right = right;\n-    this.conditionType = conditionType;\n+    this.conditionType = Preconditions.checkNotNull(conditionType);\n     this.condition = condition;\n \n     assert natural.getTypeName() == SqlTypeName.BOOLEAN;\n-    assert conditionType != null;\n     assert conditionType.symbolValue() instanceof JoinConditionType;\n-    assert joinType != null;\n     assert joinType.symbolValue() instanceof JoinType;\n-\n   }\n \n   //~ Methods ----------------------------------------------------------------\n@@ -196,6 +195,8 @@ public SqlCall createCall(\n         int rightPrec) {\n       final SqlJoin join = (SqlJoin) call;\n \n+      final SqlWriter.Frame joinFrame =\n+          writer.startList(SqlWriter.FrameTypeEnum.JOIN);\n       join.left.unparse(\n           writer,\n           leftPrec,\n@@ -249,6 +250,7 @@ public SqlCall createCall(\n           throw Util.unexpected(join.getConditionType());\n         }\n       }\n+      writer.endList(joinFrame);\n     }\n   }\n }",
                "deletions": 6
            },
            {
                "sha": "d45c831db9903dbbbff09033f9c18d528d387930",
                "filename": "core/src/main/java/org/apache/calcite/sql/SqlWriter.java",
                "blob_url": "https://github.com/apache/calcite/blob/cd92b77c476f7b095b330507402bfc6c3208e300/core/src/main/java/org/apache/calcite/sql/SqlWriter.java",
                "raw_url": "https://github.com/apache/calcite/raw/cd92b77c476f7b095b330507402bfc6c3208e300/core/src/main/java/org/apache/calcite/sql/SqlWriter.java",
                "status": "modified",
                "changes": 5,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/SqlWriter.java?ref=cd92b77c476f7b095b330507402bfc6c3208e300",
                "patch": "@@ -193,6 +193,11 @@\n      */\n     FROM_LIST,\n \n+    /**\n+     * Pair-wise join.\n+     */\n+    JOIN(false),\n+\n     /**\n      * WHERE clause.\n      */",
                "deletions": 0
            },
            {
                "sha": "0d786561a70a3d60ddd02b5008a19946afe19f70",
                "filename": "core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java",
                "blob_url": "https://github.com/apache/calcite/blob/cd92b77c476f7b095b330507402bfc6c3208e300/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java",
                "raw_url": "https://github.com/apache/calcite/raw/cd92b77c476f7b095b330507402bfc6c3208e300/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java",
                "status": "modified",
                "changes": 50,
                "additions": 21,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java?ref=cd92b77c476f7b095b330507402bfc6c3208e300",
                "patch": "@@ -25,6 +25,8 @@\n import org.apache.calcite.util.Util;\n import org.apache.calcite.util.trace.CalciteLogger;\n \n+import com.google.common.base.Throwables;\n+\n import java.io.PrintWriter;\n import java.io.StringWriter;\n import java.lang.reflect.InvocationTargetException;\n@@ -34,6 +36,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Properties;\n import java.util.Set;\n import java.util.logging.Logger;\n@@ -306,11 +309,10 @@ public void describe(PrintWriter pw, boolean omitDefaults) {\n     final Bean properties = getBean();\n     final String[] propertyNames = properties.getPropertyNames();\n     int count = 0;\n-    for (int i = 0; i < propertyNames.length; i++) {\n-      String key = propertyNames[i];\n+    for (String key : propertyNames) {\n       final Object value = bean.get(key);\n       final Object defaultValue = DEFAULT_BEAN.get(key);\n-      if (com.google.common.base.Objects.equal(value, defaultValue)) {\n+      if (Objects.equals(value, defaultValue)) {\n         continue;\n       }\n       if (count++ > 0) {\n@@ -327,8 +329,7 @@ public void setSettings(Properties properties) {\n     resetSettings();\n     final Bean bean = getBean();\n     final String[] propertyNames = bean.getPropertyNames();\n-    for (int i = 0; i < propertyNames.length; i++) {\n-      String propertyName = propertyNames[i];\n+    for (String propertyName : propertyNames) {\n       final String value = properties.getProperty(propertyName);\n       if (value != null) {\n         bean.set(propertyName, value);\n@@ -662,6 +663,7 @@ protected void _before() {\n             false);\n \n       case FROM_LIST:\n+      case JOIN:\n         return new FrameImpl(\n             frameType,\n             keyword,\n@@ -849,7 +851,7 @@ private static boolean needWhitespaceAfter(String s) {\n \n   protected void whiteSpace() {\n     if (needWhitespace) {\n-      if (nextWhitespace == NL) {\n+      if (nextWhitespace.equals(NL)) {\n         newlineAndIndent();\n       } else {\n         pw.print(nextWhitespace);\n@@ -1044,15 +1046,15 @@ public void setFormatOptions(SqlFormatOptions options) {\n     /**\n      * Whether to print a newline before each separator.\n      */\n-    public boolean newlineBeforeSep;\n+    public final boolean newlineBeforeSep;\n \n     /**\n      * Whether to print a newline after each separator.\n      */\n-    public boolean newlineAfterSep;\n+    public final boolean newlineAfterSep;\n     private final boolean newlineBeforeClose;\n     private final boolean newlineAfterClose;\n-    private boolean newlineAfterOpen;\n+    private final boolean newlineAfterOpen;\n \n     FrameImpl(\n         FrameType frameType,\n@@ -1107,18 +1109,14 @@ protected void sep(boolean printFirst, String sep) {\n    */\n   private static class Bean {\n     private final SqlPrettyWriter o;\n-    private final Map<String, Method> getterMethods =\n-        new HashMap<String, Method>();\n-    private final Map<String, Method> setterMethods =\n-        new HashMap<String, Method>();\n+    private final Map<String, Method> getterMethods = new HashMap<>();\n+    private final Map<String, Method> setterMethods = new HashMap<>();\n \n     Bean(SqlPrettyWriter o) {\n       this.o = o;\n \n       // Figure out the getter/setter methods for each attribute.\n-      final Method[] methods = o.getClass().getMethods();\n-      for (int i = 0; i < methods.length; i++) {\n-        Method method = methods[i];\n+      for (Method method : o.getClass().getMethods()) {\n         if (method.getName().startsWith(\"set\")\n             && (method.getReturnType() == Void.class)\n             && (method.getParameterTypes().length == 1)) {\n@@ -1157,32 +1155,26 @@ private String stripPrefix(String name, int offset) {\n     public void set(String name, String value) {\n       final Method method = setterMethods.get(name);\n       try {\n-        method.invoke(\n-            o,\n-            value);\n-      } catch (IllegalAccessException e) {\n-        throw Util.newInternal(e);\n-      } catch (InvocationTargetException e) {\n-        throw Util.newInternal(e);\n+        method.invoke(o, value);\n+      } catch (IllegalAccessException | InvocationTargetException e) {\n+        throw Throwables.propagate(e);\n       }\n     }\n \n     public Object get(String name) {\n       final Method method = getterMethods.get(name);\n       try {\n         return method.invoke(o);\n-      } catch (IllegalAccessException e) {\n-        throw Util.newInternal(e);\n-      } catch (InvocationTargetException e) {\n-        throw Util.newInternal(e);\n+      } catch (IllegalAccessException | InvocationTargetException e) {\n+        throw Throwables.propagate(e);\n       }\n     }\n \n     public String[] getPropertyNames() {\n-      final Set<String> names = new HashSet<String>();\n+      final Set<String> names = new HashSet<>();\n       names.addAll(getterMethods.keySet());\n       names.addAll(setterMethods.keySet());\n-      return (String[]) names.toArray(new String[names.size()]);\n+      return names.toArray(new String[names.size()]);\n     }\n   }\n }",
                "deletions": 29
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-843] AvaticaConnection.getAutoCommit throws NullPointerException",
        "commit": "https://github.com/apache/calcite/commit/fbe19d83be71a0c3be315262d215a2d439b34511",
        "parent": "https://github.com/apache/calcite/commit/0cb2e275d61a22b931212f834a7922266fa5d772",
        "bug_id": "calcite_25",
        "file": [
            {
                "sha": "1a7443c1f4e26b30ae42da831b88a2bf91f6c1fe",
                "filename": "avatica/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java",
                "blob_url": "https://github.com/apache/calcite/blob/fbe19d83be71a0c3be315262d215a2d439b34511/avatica/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java",
                "raw_url": "https://github.com/apache/calcite/raw/fbe19d83be71a0c3be315262d215a2d439b34511/avatica/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java",
                "status": "modified",
                "changes": 24,
                "additions": 19,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/avatica/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java?ref=fbe19d83be71a0c3be315262d215a2d439b34511",
                "patch": "@@ -134,7 +134,7 @@ public void setAutoCommit(boolean autoCommit) throws SQLException {\n   }\n \n   public boolean getAutoCommit() throws SQLException {\n-    return meta.connectionSync(handle, new ConnectionPropertiesImpl()).isAutoCommit();\n+    return unbox(sync().isAutoCommit(), true);\n   }\n \n   public void commit() throws SQLException {\n@@ -173,15 +173,15 @@ public void setReadOnly(boolean readOnly) throws SQLException {\n   }\n \n   public boolean isReadOnly() throws SQLException {\n-    return meta.connectionSync(handle, new ConnectionPropertiesImpl()).isReadOnly();\n+    return unbox(sync().isReadOnly(), true);\n   }\n \n   public void setCatalog(String catalog) throws SQLException {\n     meta.connectionSync(handle, new ConnectionPropertiesImpl().setCatalog(catalog));\n   }\n \n   public String getCatalog() {\n-    return meta.connectionSync(handle, new ConnectionPropertiesImpl()).getCatalog();\n+    return sync().getCatalog();\n   }\n \n   public void setTransactionIsolation(int level) throws SQLException {\n@@ -190,7 +190,7 @@ public void setTransactionIsolation(int level) throws SQLException {\n \n   public int getTransactionIsolation() throws SQLException {\n     //noinspection MagicConstant\n-    return meta.connectionSync(handle, new ConnectionPropertiesImpl()).getTransactionIsolation();\n+    return unbox(sync().getTransactionIsolation(), TRANSACTION_NONE);\n   }\n \n   public SQLWarning getWarnings() throws SQLException {\n@@ -358,7 +358,7 @@ public void setSchema(String schema) throws SQLException {\n   }\n \n   public String getSchema() {\n-    return meta.connectionSync(handle, new ConnectionPropertiesImpl()).getSchema();\n+    return sync().getSchema();\n   }\n \n   public void abort(Executor executor) throws SQLException {\n@@ -503,6 +503,20 @@ protected static Trojan createTrojan() {\n     return new Trojan();\n   }\n \n+  /** Converts a {@link Boolean} to a {@code boolean}, with a default value. */\n+  private boolean unbox(Boolean b, boolean defaultValue) {\n+    return b == null ? defaultValue : b;\n+  }\n+\n+  /** Converts an {@link Integer} to an {@code int}, with a default value. */\n+  private int unbox(Integer i, int defaultValue) {\n+    return i == null ? defaultValue : i;\n+  }\n+\n+  private Meta.ConnectionProperties sync() {\n+    return meta.connectionSync(handle, new ConnectionPropertiesImpl());\n+  }\n+\n   /** A way to call package-protected methods. But only a sub-class of\n    * connection can create one. */\n   public static class Trojan {",
                "deletions": 5
            },
            {
                "sha": "f6047d07c75ec37cb6ddd397b1b8fc4c9a88c0d2",
                "filename": "avatica/src/main/java/org/apache/calcite/avatica/remote/RemoteMeta.java",
                "blob_url": "https://github.com/apache/calcite/blob/fbe19d83be71a0c3be315262d215a2d439b34511/avatica/src/main/java/org/apache/calcite/avatica/remote/RemoteMeta.java",
                "raw_url": "https://github.com/apache/calcite/raw/fbe19d83be71a0c3be315262d215a2d439b34511/avatica/src/main/java/org/apache/calcite/avatica/remote/RemoteMeta.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/avatica/src/main/java/org/apache/calcite/avatica/remote/RemoteMeta.java?ref=fbe19d83be71a0c3be315262d215a2d439b34511",
                "patch": "@@ -30,7 +30,8 @@\n import java.util.Map;\n \n /**\n- * Implementation of {@link Meta} for the remote driver.\n+ * Implementation of {@link org.apache.calcite.avatica.Meta} for the remote\n+ * driver.\n  */\n class RemoteMeta extends MetaImpl {\n   final Service service;",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-865] Unknown table type causes NullPointerException in JdbcSchema",
        "commit": "https://github.com/apache/calcite/commit/d69f2c20c5a75977d50c182565d8e7b8e011515e",
        "parent": "https://github.com/apache/calcite/commit/f98ed96f041b615dca1560b7014d112a40e43d6e",
        "bug_id": "calcite_26",
        "file": [
            {
                "sha": "fe61aafed3fc5d33a3f2bcc63cff76f0a156363d",
                "filename": "avatica/src/main/java/org/apache/calcite/avatica/Meta.java",
                "blob_url": "https://github.com/apache/calcite/blob/d69f2c20c5a75977d50c182565d8e7b8e011515e/avatica/src/main/java/org/apache/calcite/avatica/Meta.java",
                "raw_url": "https://github.com/apache/calcite/raw/d69f2c20c5a75977d50c182565d8e7b8e011515e/avatica/src/main/java/org/apache/calcite/avatica/Meta.java",
                "status": "modified",
                "changes": 4,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/avatica/src/main/java/org/apache/calcite/avatica/Meta.java?ref=d69f2c20c5a75977d50c182565d8e7b8e011515e",
                "patch": "@@ -260,6 +260,10 @@ private Pat(String s) {\n       this.s = s;\n     }\n \n+    @Override public String toString() {\n+      return \"Pat[\" + s + \"]\";\n+    }\n+\n     @JsonCreator\n     public static Pat of(@JsonProperty(\"s\") String name) {\n       return new Pat(name);",
                "deletions": 0
            },
            {
                "sha": "b83c76c974fb774ba08cd5dab25c802d38fbf312",
                "filename": "core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java",
                "blob_url": "https://github.com/apache/calcite/blob/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java",
                "raw_url": "https://github.com/apache/calcite/raw/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java",
                "status": "modified",
                "changes": 6,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java?ref=d69f2c20c5a75977d50c182565d8e7b8e011515e",
                "patch": "@@ -201,6 +201,7 @@ public Expression getExpression(SchemaPlus parentSchema, String name) {\n         // returned by Phoenix among others, maps to TableType.SYSTEM_TABLE.\n         // We know enum constants are upper-case without spaces, so we can't\n         // make things worse.\n+        //\n         // PostgreSQL returns tableTypeName==null for pg_toast* tables\n         // This can happen if you start JdbcSchema off a \"public\" PG schema\n         // The tables are not designed to be queried by users, however we do\n@@ -210,7 +211,10 @@ public Expression getExpression(SchemaPlus parentSchema, String name) {\n             ? null\n             : tableTypeName.toUpperCase().replace(' ', '_');\n         final TableType tableType =\n-            Util.enumVal(TableType.class, tableTypeName2);\n+            Util.enumVal(TableType.OTHER, tableTypeName2);\n+        if (tableType == TableType.OTHER  && tableTypeName2 != null) {\n+          System.out.println(\"Unknown table type: \" + tableTypeName2);\n+        }\n         final JdbcTable table =\n             new JdbcTable(this, catalogName, schemaName, tableName, tableType);\n         builder.put(tableName, table);",
                "deletions": 1
            },
            {
                "sha": "f820c2819ce11c9fbb31d181da20c2f9163e094c",
                "filename": "core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java?ref=d69f2c20c5a75977d50c182565d8e7b8e011515e",
                "patch": "@@ -47,6 +47,7 @@\n import org.apache.calcite.util.Util;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n \n import java.sql.SQLException;\n@@ -80,7 +81,7 @@ public JdbcTable(JdbcSchema jdbcSchema, String jdbcCatalogName,\n     this.jdbcCatalogName = jdbcCatalogName;\n     this.jdbcSchemaName = jdbcSchemaName;\n     this.jdbcTableName = tableName;\n-    this.jdbcTableType = jdbcTableType;\n+    this.jdbcTableType = Preconditions.checkNotNull(jdbcTableType);\n   }\n \n   public String toString() {",
                "deletions": 1
            },
            {
                "sha": "6745e21a01f8daf6824f798862f4ff4f5d8fc4fd",
                "filename": "core/src/main/java/org/apache/calcite/schema/Schema.java",
                "blob_url": "https://github.com/apache/calcite/blob/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/schema/Schema.java",
                "raw_url": "https://github.com/apache/calcite/raw/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/schema/Schema.java",
                "status": "modified",
                "changes": 105,
                "additions": 87,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/schema/Schema.java?ref=d69f2c20c5a75977d50c182565d8e7b8e011515e",
                "patch": "@@ -144,31 +144,30 @@\n \n   /** Table type. */\n   enum TableType {\n-    /** A regular table. */\n+    /** A regular table.\n+     *\n+     * <p>Used by PostgreSQL, MySQL and others. */\n     TABLE,\n \n     /** A relation whose contents are calculated by evaluating a SQL\n-     * expression. */\n+     * expression.\n+     *\n+     * <p>Used by PostgreSQL and others. */\n     VIEW,\n \n-    /** A table maintained by the system. Data dictionary tables, such as the\n-     * \"TABLES\" and \"COLUMNS\" table in the \"metamodel\" schema, examples of\n-     * system tables. */\n-    SYSTEM_TABLE,\n-\n-    /** A table that is only visible to one connection. */\n-    LOCAL_TEMPORARY,\n+    /** Foreign table.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    FOREIGN_TABLE,\n \n-    /** A structure, similar to a view, that is the basis for auto-generated\n-     * materializations. It is either a single table or a collection of tables\n-     * that are joined via many-to-one relationships from a central hub table.\n-     * It is not available for queries, but is just used as an intermediate\n-     * structure during query planning. */\n-    STAR,\n+    /** Materialized view.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    MATERIALIZED_VIEW,\n \n     /** Index table.\n      *\n-     * <p>Used by Apache Phoenix. */\n+     * <p>Used by Apache Phoenix, PostgreSQL. */\n     INDEX,\n \n     /** Join table.\n@@ -178,12 +177,82 @@\n \n     /** Sequence table.\n      *\n-     * <p>Used by Apache Phoenix, and others. Must have a single BIGINT column\n-     * called \"$seq\". */\n+     * <p>Used by Apache Phoenix, PostgreSQL and others.\n+     * In Phoenix, must have a single BIGINT column called \"$seq\". */\n     SEQUENCE,\n \n+    /** A structure, similar to a view, that is the basis for auto-generated\n+     * materializations. It is either a single table or a collection of tables\n+     * that are joined via many-to-one relationships from a central hub table.\n+     * It is not available for queries, but is just used as an intermediate\n+     * structure during query planning. */\n+    STAR,\n+\n     /** Stream. */\n     STREAM,\n+\n+    /** Type.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    TYPE,\n+\n+    /** A table maintained by the system. Data dictionary tables, such as the\n+     * \"TABLES\" and \"COLUMNS\" table in the \"metamodel\" schema, examples of\n+     * system tables.\n+     *\n+     * <p>Used by PostgreSQL, MySQL and others. */\n+    SYSTEM_TABLE,\n+\n+    /** System view.\n+     *\n+     * <p>Used by PostgreSQL, MySQL. */\n+    SYSTEM_VIEW,\n+\n+    /** System index.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    SYSTEM_INDEX,\n+\n+    /** System TOAST index.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    SYSTEM_TOAST_INDEX,\n+\n+    /** System TOAST table.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    SYSTEM_TOAST_TABLE,\n+\n+    /** Temporary index.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    TEMPORARY_INDEX,\n+\n+    /** Temporary sequence.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    TEMPORARY_SEQUENCE,\n+\n+    /** Temporary table.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    TEMPORARY_TABLE,\n+\n+    /** Temporary view.\n+     *\n+     * <p>Used by PostgreSQL. */\n+    TEMPORARY_VIEW,\n+\n+    /** A table that is only visible to one connection.\n+     *\n+     * <p>Used by PostgreSQL, MySQL. */\n+    LOCAL_TEMPORARY,\n+\n+    /** Table type not known to Calcite.\n+     *\n+     * <p>If you get one of these, please fix the problem by adding an enum\n+     * value. */\n+    OTHER,\n   }\n }\n ",
                "deletions": 18
            },
            {
                "sha": "dbaf0a8b0383afa7406c1ef73985a674ed8f8ba2",
                "filename": "core/src/main/java/org/apache/calcite/util/Util.java",
                "blob_url": "https://github.com/apache/calcite/blob/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/util/Util.java",
                "raw_url": "https://github.com/apache/calcite/raw/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/main/java/org/apache/calcite/util/Util.java",
                "status": "modified",
                "changes": 22,
                "additions": 20,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/util/Util.java?ref=d69f2c20c5a75977d50c182565d8e7b8e011515e",
                "patch": "@@ -1859,11 +1859,29 @@ public int size() {\n    * @param <T>   Enum class type\n    * @return Enum constant or null\n    */\n-  @SuppressWarnings({\"unchecked\" })\n   public static synchronized <T extends Enum<T>> T enumVal(\n       Class<T> clazz,\n       String name) {\n-    return (T) ENUM_CONSTANTS.getUnchecked(clazz).get(name);\n+    return clazz.cast(ENUM_CONSTANTS.getUnchecked(clazz).get(name));\n+  }\n+\n+  /**\n+   * Returns the value of an enumeration with a particular or default value if\n+   * not found.\n+   *\n+   * @param default_ Default value (not null)\n+   * @param name     Name of enum constant\n+   * @param <T>      Enum class type\n+   * @return         Enum constant, never null\n+   */\n+  public static synchronized <T extends Enum<T>> T enumVal(T default_,\n+      String name) {\n+    final Class<T> clazz = default_.getDeclaringClass();\n+    final T t = clazz.cast(ENUM_CONSTANTS.getUnchecked(clazz).get(name));\n+    if (t == null) {\n+      return default_;\n+    }\n+    return t;\n   }\n \n   /**",
                "deletions": 2
            },
            {
                "sha": "cc7ec8ca12de1e55509be89cbfc23c37c8d9bccc",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/d69f2c20c5a75977d50c182565d8e7b8e011515e/core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java",
                "status": "modified",
                "changes": 35,
                "additions": 35,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java?ref=d69f2c20c5a75977d50c182565d8e7b8e011515e",
                "patch": "@@ -16,17 +16,25 @@\n  */\n package org.apache.calcite.test;\n \n+import org.apache.calcite.jdbc.CalciteConnection;\n+\n+import com.google.common.base.Function;\n+import com.google.common.base.Throwables;\n+\n import org.hsqldb.jdbcDriver;\n+\n import org.junit.Test;\n \n import java.sql.Connection;\n import java.sql.DriverManager;\n import java.sql.ResultSet;\n+import java.sql.SQLException;\n import java.sql.Statement;\n import java.util.Properties;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertThat;\n \n /**\n@@ -350,6 +358,33 @@\n         .explainContains(\"SINGLE_VALUE\")\n         .throws_(expected);\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-865\">[CALCITE-865]\n+   * Unknown table type causes NullPointerException in JdbcSchema</a>. The issue\n+   * occurred because of the \"SYSTEM_INDEX\" table type when run against\n+   * PostgreSQL. */\n+  @Test public void testMetadataTables() throws Exception {\n+    // The troublesome tables occur in PostgreSQL's system schema.\n+    final String model =\n+        JdbcTest.FOODMART_MODEL.replace(\"jdbcSchema: 'foodmart'\",\n+            \"jdbcSchema: null\");\n+    CalciteAssert.model(\n+        model)\n+        .doWithConnection(\n+            new Function<CalciteConnection, Void>() {\n+              public Void apply(CalciteConnection connection) {\n+                try {\n+                  final ResultSet resultSet =\n+                      connection.getMetaData().getTables(null, null, \"%\", null);\n+                  assertFalse(CalciteAssert.toString(resultSet).isEmpty());\n+                  return null;\n+                } catch (SQLException e) {\n+                  throw Throwables.propagate(e);\n+                }\n+              }\n+            });\n+  }\n }\n \n // End JdbcAdapterTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Test case for [CALCITE-1952] NPE in VolcanoPlanner",
        "commit": "https://github.com/apache/calcite/commit/210fa866e792ce379f2deb52f79fc0686866f07a",
        "parent": "https://github.com/apache/calcite/commit/dfe251d7e5136ce93b1172ad1822bd908e953c86",
        "bug_id": "calcite_27",
        "file": [
            {
                "sha": "b5e92aa44fc5721d2f39dce04d15030a819432b7",
                "filename": "file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/210fa866e792ce379f2deb52f79fc0686866f07a/file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/210fa866e792ce379f2deb52f79fc0686866f07a/file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java",
                "status": "modified",
                "changes": 55,
                "additions": 53,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java?ref=210fa866e792ce379f2deb52f79fc0686866f07a",
                "patch": "@@ -34,12 +34,17 @@\n \n import java.io.File;\n import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n import java.util.Iterator;\n+import java.util.Properties;\n \n /**\n  * Unit tests for FileReader.\n  */\n-\n public class FileReaderTest {\n \n   private static final Source CITIES_SOURCE =\n@@ -59,6 +64,15 @@ public static String file(String s) {\n     }\n   }\n \n+  private static String resourcePath(String path) {\n+    final URL url = FileReaderTest.class.getResource(\"/\" + path);\n+    String s = url.toString();\n+    if (s.startsWith(\"file:\")) {\n+      s = s.substring(\"file:\".length());\n+    }\n+    return s;\n+  }\n+\n   /** Tests {@link FileReader} URL instantiation - no path. */\n   @Test public void testFileReaderUrlNoPath() throws FileReaderException {\n     Assume.assumeTrue(FileSuite.hazNetwork());\n@@ -173,7 +187,6 @@ public void testFileReaderBadSelector() throws FileReaderException {\n \n   /** Tests {@link FileReader} iterator with static file, */\n   @Test public void testFileReaderIterator() throws FileReaderException {\n-    System.out.println(new File(\"\").getAbsolutePath());\n     final Source source =\n         Sources.file(null, file(\"target/test-classes/tableOK.html\"));\n     FileReader t = new FileReader(source);\n@@ -185,6 +198,44 @@ public void testFileReaderBadSelector() throws FileReaderException {\n     assertTrue(row.get(1).text().equals(\"R2C1\"));\n   }\n \n+  /** Tests reading a CSV file via the file adapter. Based on the test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1952\">[CALCITE-1952]\n+   * NPE in planner</a>. */\n+  @Test public void testCsvFile() throws Exception {\n+    Properties info = new Properties();\n+    final String model = \"inline:\"\n+        + \"{\\n\"\n+        + \"  \\\"version\\\": \\\"1.0\\\",\\n\"\n+        + \"  \\\"defaultSchema\\\": \\\"XXX\\\",\\n\"\n+        + \"  \\\"schemas\\\": [\\n\"\n+        + \"    {\\n\"\n+        + \"      \\\"name\\\": \\\"FILES\\\",\\n\"\n+        + \"      \\\"type\\\": \\\"custom\\\",\\n\"\n+        + \"      \\\"factory\\\": \\\"org.apache.calcite.adapter.file.FileSchemaFactory\\\",\\n\"\n+        + \"      \\\"operand\\\": {\\n\"\n+        + \"        \\\"directory\\\": \\\"\" + resourcePath(\"sales-csv\") + \"\\\"\\n\"\n+        + \"      }\\n\"\n+        + \"    }\\n\"\n+        + \"  ]\\n\"\n+        + \"}\";\n+    info.put(\"model\", model);\n+    info.put(\"lex\", \"JAVA\");\n+\n+    try (Connection connection =\n+             DriverManager.getConnection(\"jdbc:calcite:\", info);\n+         Statement stmt = connection.createStatement()) {\n+      final String sql = \"select * from FILES.DEPTS\";\n+      final ResultSet rs = stmt.executeQuery(sql);\n+      assertThat(rs.next(), is(true));\n+      assertThat(rs.getString(1), is(\"10\"));\n+      assertThat(rs.next(), is(true));\n+      assertThat(rs.getString(1), is(\"20\"));\n+      assertThat(rs.next(), is(true));\n+      assertThat(rs.getString(1), is(\"30\"));\n+      assertThat(rs.next(), is(false));\n+      rs.close();\n+    }\n+  }\n }\n \n // End FileReaderTest.java",
                "deletions": 2
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-509] RelMdColumnUniqueness uses ImmutableBitSet.Builder twice, gets NullPointerException",
        "commit": "https://github.com/apache/calcite/commit/b1d22c7ed929e586808f90b25df13fb86cb89546",
        "parent": "https://github.com/apache/calcite/commit/d4b80bf93f28d8aac8b1997d0b8bee2da84fb99c",
        "bug_id": "calcite_28",
        "file": [
            {
                "sha": "146f420cd16898708fe61f1f5155d6e363f9e5f9",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java",
                "blob_url": "https://github.com/apache/calcite/blob/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java",
                "raw_url": "https://github.com/apache/calcite/raw/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java",
                "status": "modified",
                "changes": 14,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java?ref=b1d22c7ed929e586808f90b25df13fb86cb89546",
                "patch": "@@ -171,24 +171,22 @@ public Expression record(\n    * See {@link org.apache.calcite.interpreter.Row}\n    */\n   ROW {\n-    @Override\n-    Type javaRowClass(JavaTypeFactory typeFactory, RelDataType type) {\n+    @Override Type javaRowClass(JavaTypeFactory typeFactory, RelDataType type) {\n       return Row.class;\n     }\n \n-    @Override\n-    Type javaFieldClass(JavaTypeFactory typeFactory, RelDataType type,\n+    @Override Type javaFieldClass(JavaTypeFactory typeFactory, RelDataType type,\n         int index) {\n       return Object.class;\n     }\n \n-    @Override\n-    public Expression record(Type javaRowClass, List<Expression> expressions) {\n+    @Override public Expression record(Type javaRowClass,\n+        List<Expression> expressions) {\n       return Expressions.call(BuiltInMethod.ROW_AS_COPY.method, expressions);\n     }\n \n-    @Override\n-    public Expression field(Expression expression, int field, Type fieldType) {\n+    @Override public Expression field(Expression expression, int field,\n+        Type fieldType) {\n       return RexToLixTranslator.convert(\n           Expressions.call(expression,\n               BuiltInMethod.ROW_VALUE.method,",
                "deletions": 8
            },
            {
                "sha": "6a6fab663709fc23f2f538bd03d194e6a3599a62",
                "filename": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java",
                "blob_url": "https://github.com/apache/calcite/blob/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java",
                "raw_url": "https://github.com/apache/calcite/raw/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java",
                "status": "modified",
                "changes": 16,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java?ref=b1d22c7ed929e586808f90b25df13fb86cb89546",
                "patch": "@@ -155,26 +155,26 @@ public Boolean areColumnsUnique(\n \n     // Divide up the input column mask into column masks for the left and\n     // right sides of the join\n-    ImmutableBitSet.Builder leftColumns = ImmutableBitSet.builder();\n-    ImmutableBitSet.Builder rightColumns = ImmutableBitSet.builder();\n+    ImmutableBitSet.Builder leftBuilder = ImmutableBitSet.builder();\n+    ImmutableBitSet.Builder rightBuilder = ImmutableBitSet.builder();\n     int nLeftColumns = left.getRowType().getFieldCount();\n     for (int bit : columns) {\n       if (bit < nLeftColumns) {\n-        leftColumns.set(bit);\n+        leftBuilder.set(bit);\n       } else {\n-        rightColumns.set(bit - nLeftColumns);\n+        rightBuilder.set(bit - nLeftColumns);\n       }\n     }\n \n     // If the original column mask contains columns from both the left and\n     // right hand side, then the columns are unique if and only if they're\n     // unique for their respective join inputs\n+    final ImmutableBitSet leftColumns = leftBuilder.build();\n     Boolean leftUnique =\n-        RelMetadataQuery.areColumnsUnique(left, leftColumns.build(),\n-            ignoreNulls);\n+        RelMetadataQuery.areColumnsUnique(left, leftColumns, ignoreNulls);\n+    final ImmutableBitSet rightColumns = rightBuilder.build();\n     Boolean rightUnique =\n-        RelMetadataQuery.areColumnsUnique(right, rightColumns.build(),\n-            ignoreNulls);\n+        RelMetadataQuery.areColumnsUnique(right, rightColumns, ignoreNulls);\n     if ((leftColumns.cardinality() > 0)\n         && (rightColumns.cardinality() > 0)) {\n       if ((leftUnique == null) || (rightUnique == null)) {",
                "deletions": 8
            },
            {
                "sha": "c152bac1cd2981f4913330dd94c46384b0f8891d",
                "filename": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java",
                "blob_url": "https://github.com/apache/calcite/blob/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java",
                "raw_url": "https://github.com/apache/calcite/raw/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java?ref=b1d22c7ed929e586808f90b25df13fb86cb89546",
                "patch": "@@ -199,7 +199,7 @@ public static double computeSemiJoinSelectivity(\n       selectivity =\n           Math.pow(\n               0.1,\n-              dimKeyBuilder.cardinality());\n+              dimKeys.cardinality());\n     } else if (selectivity > 1.0) {\n       selectivity = 1.0;\n     }",
                "deletions": 1
            },
            {
                "sha": "ab101b7ac953c508ff4cc298d8bc51711db07f81",
                "filename": "core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java",
                "blob_url": "https://github.com/apache/calcite/blob/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java",
                "raw_url": "https://github.com/apache/calcite/raw/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java",
                "status": "modified",
                "changes": 22,
                "additions": 22,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java?ref=b1d22c7ed929e586808f90b25df13fb86cb89546",
                "patch": "@@ -16,9 +16,13 @@\n  */\n package org.apache.calcite.util;\n \n+import org.apache.calcite.linq4j.Linq4j;\n import org.apache.calcite.runtime.Utilities;\n \n import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n import java.io.Serializable;\n@@ -190,6 +194,21 @@ private static int wordIndex(int bitIndex) {\n     return bitIndex >> ADDRESS_BITS_PER_WORD;\n   }\n \n+  /** Computes the power set (set of all sets) of this bit set. */\n+  public Iterable<ImmutableBitSet> powerSet() {\n+    List<List<ImmutableBitSet>> singletons = Lists.newArrayList();\n+    for (Integer bit : this) {\n+      singletons.add(\n+          ImmutableList.of(ImmutableBitSet.of(), ImmutableBitSet.of(bit)));\n+    }\n+    return Iterables.transform(Linq4j.product(singletons),\n+        new Function<List<ImmutableBitSet>, ImmutableBitSet>() {\n+          public ImmutableBitSet apply(List<ImmutableBitSet> input) {\n+            return ImmutableBitSet.union(input);\n+          }\n+        });\n+  }\n+\n   /**\n    * Returns the value of the bit with the specified index. The value\n    * is {@code true} if the bit with the index {@code bitIndex}\n@@ -796,6 +815,9 @@ public boolean wouldEqual(ImmutableBitSet bitSet) {\n \n     /** Returns the number of set bits. */\n     public int cardinality() {\n+      if (words == null) {\n+        throw new IllegalArgumentException(\"can only use builder once\");\n+      }\n       return countBits(words);\n     }\n ",
                "deletions": 0
            },
            {
                "sha": "3782957d7597fa8c76179805fb9279eb9a3443bd",
                "filename": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
                "status": "modified",
                "changes": 22,
                "additions": 22,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java?ref=b1d22c7ed929e586808f90b25df13fb86cb89546",
                "patch": "@@ -484,6 +484,12 @@ private void checkFilterSelectivity(\n         DEFAULT_SELECTIVITY);\n   }\n \n+  @Test public void testSelectivityJoin() {\n+    checkFilterSelectivity(\n+        \"select * from emp join dept using (deptno) where ename = 'foo'\",\n+        DEFAULT_EQUAL_SELECTIVITY);\n+  }\n+\n   private void checkRelSelectivity(\n       RelNode rel,\n       double expected) {\n@@ -546,6 +552,22 @@ private void checkRelSelectivity(\n     assertTrue(result == null);\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-509\">[CALCITE-509]\n+   * \"RelMdColumnUniqueness uses ImmutableBitSet.Builder twice, gets\n+   * NullPointerException\"</a>. */\n+  @Test public void testJoinUniqueKeys() {\n+    RelNode rel = convertSql(\"select * from emp join dept using (deptno)\");\n+    Set<ImmutableBitSet> result = RelMetadataQuery.getUniqueKeys(rel);\n+    assertThat(result.toString(), equalTo(\"[]\"));\n+    final ImmutableBitSet allCols =\n+        ImmutableBitSet.range(0, rel.getRowType().getFieldCount());\n+    for (ImmutableBitSet integers : allCols.powerSet()) {\n+      Boolean result2 = RelMetadataQuery.areColumnsUnique(rel, integers);\n+      assertTrue(result2 == null || !result2);\n+    }\n+  }\n+\n   @Test public void testCustomProvider() {\n     final List<String> buf = new ArrayList<String>();\n     ColTypeImpl.THREAD_LIST.set(buf);",
                "deletions": 0
            },
            {
                "sha": "29b6aba4bba8fc1d0e26367dfc5d54b5fe7115d8",
                "filename": "core/src/test/java/org/apache/calcite/util/ImmutableBitSetTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/test/java/org/apache/calcite/util/ImmutableBitSetTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/b1d22c7ed929e586808f90b25df13fb86cb89546/core/src/test/java/org/apache/calcite/util/ImmutableBitSetTest.java",
                "status": "modified",
                "changes": 18,
                "additions": 18,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/util/ImmutableBitSetTest.java?ref=b1d22c7ed929e586808f90b25df13fb86cb89546",
                "patch": "@@ -18,6 +18,7 @@\n \n import org.apache.calcite.runtime.Utilities;\n \n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n \n import org.junit.Test;\n@@ -378,6 +379,23 @@ private void assertToIterBitSet(String expected, ImmutableBitSet bitSet) {\n             \"{0={3, 4, 12}, 1={}, 2={7}, 3={3, 4, 12}, 4={4, 12}, 5={}, 6={}, 7={7}, 8={}, 9={}, 10={}, 11={}, 12={4, 12}}\"));\n     assertThat(\"argument modified\", map.toString(), equalTo(original));\n   }\n+\n+  @Test public void testPowerSet() {\n+    final ImmutableBitSet empty = ImmutableBitSet.of();\n+    assertThat(Iterables.size(empty.powerSet()), equalTo(1));\n+    assertThat(empty.powerSet().toString(), equalTo(\"[{}]\"));\n+\n+    final ImmutableBitSet single = ImmutableBitSet.of(2);\n+    assertThat(Iterables.size(single.powerSet()), equalTo(2));\n+    assertThat(single.powerSet().toString(), equalTo(\"[{}, {2}]\"));\n+\n+    final ImmutableBitSet two = ImmutableBitSet.of(2, 10);\n+    assertThat(Iterables.size(two.powerSet()), equalTo(4));\n+    assertThat(two.powerSet().toString(), equalTo(\"[{}, {10}, {2}, {2, 10}]\"));\n+\n+    final ImmutableBitSet seventeen = ImmutableBitSet.range(3, 20);\n+    assertThat(Iterables.size(seventeen.powerSet()), equalTo(131072));\n+  }\n }\n \n // End ImmutableBitSetTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-403] Enumerable gives NullPointerException with NOT on nullable expression",
        "commit": "https://github.com/apache/calcite/commit/de0bfaade674ec325c5b6a5458f2da8ac6fcd3de",
        "parent": "https://github.com/apache/calcite/commit/539253562067dcea9609c766fa7b6f413e1ac001",
        "bug_id": "calcite_29",
        "file": [
            {
                "sha": "b3166ec08d4b961ef6f8156502644d49c5a65600",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/de0bfaade674ec325c5b6a5458f2da8ac6fcd3de/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/de0bfaade674ec325c5b6a5458f2da8ac6fcd3de/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "status": "modified",
                "changes": 12,
                "additions": 12,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java?ref=de0bfaade674ec325c5b6a5458f2da8ac6fcd3de",
                "patch": "@@ -756,6 +756,18 @@ private static Expression implementNullSemantics(\n       }\n       list.add(implementCall(translator, call, implementor, nullAs));\n       return Expressions.foldAnd(list);\n+    case TRUE:\n+      // v0 == null || v1 == null || f(v0, v1)\n+      for (Ord<RexNode> operand : Ord.zip(call.getOperands())) {\n+        if (translator.isNullable(operand.e)) {\n+          list.add(\n+              translator.translate(\n+                  operand.e, NullAs.IS_NULL));\n+          translator = translator.setNullable(operand.e, false);\n+        }\n+      }\n+      list.add(implementCall(translator, call, implementor, nullAs));\n+      return Expressions.foldOr(list);\n     case NOT_POSSIBLE:\n       // Need to transmit to the implementor the fact that call cannot\n       // return null. In particular, it should return a primitive (e.g.",
                "deletions": 0
            },
            {
                "sha": "424bbe01f790ce373ee9d39b15d97c548a9af83a",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/de0bfaade674ec325c5b6a5458f2da8ac6fcd3de/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/de0bfaade674ec325c5b6a5458f2da8ac6fcd3de/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "status": "modified",
                "changes": 18,
                "additions": 13,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcTest.java?ref=de0bfaade674ec325c5b6a5458f2da8ac6fcd3de",
                "patch": "@@ -2977,23 +2977,31 @@ private void checkNullableTimestamp(CalciteAssert.Config config) {\n \n   /** Test case for\n    * <a href=\"https://issues.apache.org/jira/browse/CALCITE-403\">CALCITE-403</a>,\n-   * \"Enumerable gives NullPointerException with HAVING on nullable\n+   * \"Enumerable gives NullPointerException with NOT on nullable\n    * expression\". */\n-  @Ignore(\"CALCITE-403\")\n   @Test public void testHavingNot() throws IOException {\n     withFoodMartQuery(6597).runs();\n   }\n \n   /** Minimal case of {@link #testHavingNot()}. */\n-  @Ignore(\"CALCITE-403\")\n   @Test public void testHavingNot2() throws IOException {\n     CalciteAssert.that()\n         .with(CalciteAssert.Config.FOODMART_CLONE)\n         .query(\"select 1\\n\"\n             + \"from \\\"store\\\"\\n\"\n             + \"group by \\\"store\\\".\\\"store_street_address\\\"\\n\"\n-            + \"having NOT (sum(\\\"store\\\".\\\"grocery_sqft\\\") < 10000)\")\n-        .returnsCount(0);\n+            + \"having NOT (sum(\\\"store\\\".\\\"grocery_sqft\\\") < 20000)\")\n+        .returnsCount(10);\n+  }\n+\n+  @Test public void testWhereNot() throws IOException {\n+    CalciteAssert.that()\n+        .with(CalciteAssert.Config.FOODMART_CLONE)\n+        .query(\"select 1\\n\"\n+            + \"from \\\"store\\\"\\n\"\n+            + \"where NOT (\\\"store\\\".\\\"grocery_sqft\\\" < 22000)\\n\"\n+            + \"group by \\\"store\\\".\\\"store_street_address\\\"\\n\")\n+        .returnsCount(8);\n   }\n \n   /** Query that reads no columns from either underlying table. */",
                "deletions": 5
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1910] NPE on filtered aggregators using \"IN\"\n\nClose apache/calcite#548",
        "commit": "https://github.com/apache/calcite/commit/188c8020d4e68c0a3180265b07949aeb8830ff1b",
        "parent": "https://github.com/apache/calcite/commit/9baa96f39005a51061a675e245f1975254e37b13",
        "bug_id": "calcite_30",
        "file": [
            {
                "sha": "752743b1fdca265450fd5efb591e0c9b08224834",
                "filename": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/188c8020d4e68c0a3180265b07949aeb8830ff1b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/188c8020d4e68c0a3180265b07949aeb8830ff1b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "status": "modified",
                "changes": 16,
                "additions": 16,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java?ref=188c8020d4e68c0a3180265b07949aeb8830ff1b",
                "patch": "@@ -2693,6 +2693,10 @@ protected final void createAggImpl(\n     replaceSubQueries(bb, aggregateFinder.list,\n         RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);\n \n+    // also replace sub-queries inside filters in the aggregates\n+    replaceSubQueries(bb, aggregateFinder.filterList,\n+        RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);\n+\n     // If group-by clause is missing, pretend that it has zero elements.\n     if (groupList == null) {\n       groupList = SqlNodeList.EMPTY;\n@@ -5214,12 +5218,24 @@ private SubQuery(SqlNode node, RelOptUtil.Logic logic) {\n    */\n   private static class AggregateFinder extends SqlBasicVisitor<Void> {\n     final SqlNodeList list = new SqlNodeList(SqlParserPos.ZERO);\n+    final SqlNodeList filterList = new SqlNodeList(SqlParserPos.ZERO);\n \n     @Override public Void visit(SqlCall call) {\n       // ignore window aggregates and ranking functions (associated with OVER operator)\n       if (call.getOperator().getKind() == SqlKind.OVER) {\n         return null;\n       }\n+\n+      if (call.getOperator().getKind() == SqlKind.FILTER) {\n+        // the WHERE in a FILTER must be tracked too so we can call replaceSubQueries on it.\n+        // see https://issues.apache.org/jira/browse/CALCITE-1910\n+        final SqlNode aggCall = call.getOperandList().get(0);\n+        final SqlNode whereCall = call.getOperandList().get(1);\n+        list.add(aggCall);\n+        filterList.add(whereCall);\n+        return null;\n+      }\n+\n       if (call.getOperator().isAggregator()) {\n         list.add(call);\n         return null;",
                "deletions": 0
            },
            {
                "sha": "f0276f400f86e7a29d35f336793eef27fc2f8682",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/188c8020d4e68c0a3180265b07949aeb8830ff1b/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/188c8020d4e68c0a3180265b07949aeb8830ff1b/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "status": "modified",
                "changes": 8,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java?ref=188c8020d4e68c0a3180265b07949aeb8830ff1b",
                "patch": "@@ -469,6 +469,14 @@ protected final void check(\n     sql(sql).ok();\n   }\n \n+  @Test public void testAggFilterWithIn() {\n+    final String sql = \"select\\n\"\n+        + \"  deptno, sum(sal * 2) filter (where empno not in (1, 2)), count(*)\\n\"\n+        + \"from emp\\n\"\n+        + \"group by deptno\";\n+    sql(sql).ok();\n+  }\n+\n   @Test public void testFakeStar() {\n     sql(\"SELECT * FROM (VALUES (0, 0)) AS T(A, \\\"*\\\")\").ok();\n   }",
                "deletions": 0
            },
            {
                "sha": "dd944d10800162a0a1594eb4ba30c39a8fc4746e",
                "filename": "core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "blob_url": "https://github.com/apache/calcite/blob/188c8020d4e68c0a3180265b07949aeb8830ff1b/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "raw_url": "https://github.com/apache/calcite/raw/188c8020d4e68c0a3180265b07949aeb8830ff1b/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "status": "modified",
                "changes": 15,
                "additions": 15,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml?ref=188c8020d4e68c0a3180265b07949aeb8830ff1b",
                "patch": "@@ -2888,6 +2888,21 @@ group by deptno]]>\n LogicalAggregate(group=[{0}], EXPR$1=[SUM($1) FILTER $2], EXPR$2=[COUNT()])\n   LogicalProject(DEPTNO=[$7], $f1=[*($5, 2)], $f2=[<($0, 10)])\n     LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+]]>\n+        </Resource>\n+    </TestCase>\n+    <TestCase name=\"testAggFilterWithIn\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select\n+  deptno, sum(sal * 2) filter (where empno not in (1, 2)), count(*)\n+from emp\n+group by deptno]]>\n+        </Resource>\n+        <Resource name=\"plan\">\n+            <![CDATA[\n+LogicalAggregate(group=[{0}], EXPR$1=[SUM($1) FILTER $2], EXPR$2=[COUNT()])\n+  LogicalProject(DEPTNO=[$7], $f1=[*($5, 2)], $f2=[AND(<>($0, 1), <>($0, 2))])\n+    LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n ]]>\n         </Resource>\n     </TestCase>",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1982] NPE simplifying range expressions when literal value is null",
        "commit": "https://github.com/apache/calcite/commit/d633402c41158da3fc00eebcf0e75b0c7da71450",
        "parent": "https://github.com/apache/calcite/commit/67071b6b0ba52eeb953badfff39fa10d85b80bf5",
        "bug_id": "calcite_31",
        "file": [
            {
                "sha": "286a6972842764811bb57709154967be8f85b358",
                "filename": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java",
                "blob_url": "https://github.com/apache/calcite/blob/d633402c41158da3fc00eebcf0e75b0c7da71450/core/src/main/java/org/apache/calcite/rex/RexSimplify.java",
                "raw_url": "https://github.com/apache/calcite/raw/d633402c41158da3fc00eebcf0e75b0c7da71450/core/src/main/java/org/apache/calcite/rex/RexSimplify.java",
                "status": "modified",
                "changes": 11,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rex/RexSimplify.java?ref=d633402c41158da3fc00eebcf0e75b0c7da71450",
                "patch": "@@ -613,13 +613,18 @@ RexNode simplifyAnd2ForUnknownAsFalse(List<RexNode> terms,\n           RexCall rightCast = (RexCall) right;\n           comparedOperands.add(rightCast.getOperands().get(0).toString());\n         }\n-        // Check for equality on different constants. If the same ref or CAST(ref)\n-        // is equal to different constants, this condition cannot be satisfied,\n-        // and hence it can be evaluated to FALSE\n         final boolean leftRef = RexUtil.isReferenceOrAccess(left, true);\n         final boolean rightRef = RexUtil.isReferenceOrAccess(right, true);\n         final boolean leftConstant = left.isA(SqlKind.LITERAL);\n         final boolean rightConstant = right.isA(SqlKind.LITERAL);\n+        // Check for comparison with null values\n+        if (leftConstant && ((RexLiteral) left).getValue() == null\n+            || rightConstant && ((RexLiteral) right).getValue() == null) {\n+          return rexBuilder.makeLiteral(false);\n+        }\n+        // Check for equality on different constants. If the same ref or CAST(ref)\n+        // is equal to different constants, this condition cannot be satisfied,\n+        // and hence it can be evaluated to FALSE\n         if (term.getKind() == SqlKind.EQUALS) {\n           if (leftRef && rightConstant) {\n             final String literal = right.toString();",
                "deletions": 3
            },
            {
                "sha": "b0467d6dc6d74294af1c135779ad1ef67f096baa",
                "filename": "core/src/test/java/org/apache/calcite/test/RexProgramTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/d633402c41158da3fc00eebcf0e75b0c7da71450/core/src/test/java/org/apache/calcite/test/RexProgramTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/d633402c41158da3fc00eebcf0e75b0c7da71450/core/src/test/java/org/apache/calcite/test/RexProgramTest.java",
                "status": "modified",
                "changes": 3,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RexProgramTest.java?ref=d633402c41158da3fc00eebcf0e75b0c7da71450",
                "patch": "@@ -1311,6 +1311,9 @@ private void checkExponentialCnf(int n) {\n     checkSimplifyFilter(\n         case_(aRef, trueLiteral, bRef, trueLiteral, cRef, falseLiteral, dRef, falseLiteral,\n             unknownLiteral), \"CAST(OR(?0.a, ?0.b)):BOOLEAN\");\n+\n+    // condition with null value for range\n+    checkSimplifyFilter(and(gt(aRef, unknownLiteral), ge(bRef, literal1)), \"false\");\n   }\n \n   /** Unit test for",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1919] NullPointerException when target in ReflectiveSchema belongs to root package (Lim Chee Hau)\n\nAdd null checking before get name from package.\n\nAdd test case (Julian Hyde).\n\nClose apache/calcite#505",
        "commit": "https://github.com/apache/calcite/commit/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2",
        "parent": "https://github.com/apache/calcite/commit/a2880dd59bcf132a0a4d862815acd6f6ef244631",
        "bug_id": "calcite_32",
        "file": [
            {
                "sha": "288785cc8d9f5635a9ddf00c5d112100163b6376",
                "filename": "core/src/test/java/RootEmployee.java",
                "blob_url": "https://github.com/apache/calcite/blob/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/core/src/test/java/RootEmployee.java",
                "raw_url": "https://github.com/apache/calcite/raw/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/core/src/test/java/RootEmployee.java",
                "status": "added",
                "changes": 32,
                "additions": 32,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/RootEmployee.java?ref=3d88b254a703fa2c4b20e7952802c5cd3f38ffc2",
                "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/** Equivalent to\n+ * {@link org.apache.calcite.examples.foodmart.java.JdbcExample.Employee}, but\n+ * belongs to the unnamed (root) package. */\n+public class RootEmployee {\n+  public final int empid;\n+  public final String name;\n+\n+  /** Creates a RootEmployee. */\n+  public RootEmployee(int empid, String name) {\n+    this.empid = empid;\n+    this.name = name;\n+  }\n+}\n+\n+// End RootEmployee.java",
                "deletions": 0
            },
            {
                "sha": "e537656ea2c401b6cfa10b5f104cae38440a50fa",
                "filename": "core/src/test/java/RootHr.java",
                "blob_url": "https://github.com/apache/calcite/blob/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/core/src/test/java/RootHr.java",
                "raw_url": "https://github.com/apache/calcite/raw/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/core/src/test/java/RootHr.java",
                "status": "added",
                "changes": 29,
                "additions": 29,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/RootHr.java?ref=3d88b254a703fa2c4b20e7952802c5cd3f38ffc2",
                "patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/** Equivalent to\n+ * {@link org.apache.calcite.examples.foodmart.java.JdbcExample.Hr}, but\n+ * belongs to the unnamed (root) package. */\n+public class RootHr {\n+  public final RootEmployee[] emps = {\n+    new RootEmployee(100, \"Bill\"),\n+    new RootEmployee(200, \"Eric\"),\n+    new RootEmployee(150, \"Sebastian\"),\n+  };\n+}\n+\n+// End RootHr.java",
                "deletions": 0
            },
            {
                "sha": "801e4015db8aee12a7acd0a77734bda2918e4dd3",
                "filename": "core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java",
                "status": "modified",
                "changes": 25,
                "additions": 25,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java?ref=3d88b254a703fa2c4b20e7952802c5cd3f38ffc2",
                "patch": "@@ -20,6 +20,7 @@\n import org.apache.calcite.avatica.util.DateTimeUtils;\n import org.apache.calcite.config.Lex;\n import org.apache.calcite.jdbc.CalciteConnection;\n+import org.apache.calcite.jdbc.Driver;\n import org.apache.calcite.linq4j.Enumerable;\n import org.apache.calcite.linq4j.Linq4j;\n import org.apache.calcite.linq4j.QueryProvider;\n@@ -57,10 +58,12 @@\n import java.util.BitSet;\n import java.util.Date;\n import java.util.List;\n+import java.util.Properties;\n \n import static org.apache.calcite.test.JdbcTest.Employee;\n \n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertThat;\n import static org.junit.Assert.assertTrue;\n@@ -724,6 +727,28 @@ private static boolean isNumeric(Class type) {\n         .returnsUnordered(\"V=1970-01-01\");\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-281\">[CALCITE-1919]\n+   * NPE when target in ReflectiveSchema belongs to the unnamed package</a>. */\n+  @Test public void testReflectiveSchemaInUnnamedPackage() throws Exception {\n+    final Driver driver = new Driver();\n+    try (CalciteConnection connection = (CalciteConnection)\n+        driver.connect(\"jdbc:calcite:\", new Properties())) {\n+      SchemaPlus rootSchema = connection.getRootSchema();\n+      final Class<?> c = Class.forName(\"RootHr\");\n+      final Object o = c.getDeclaredConstructor().newInstance();\n+      rootSchema.add(\"hr\", new ReflectiveSchema(o));\n+      connection.setSchema(\"hr\");\n+      final Statement statement = connection.createStatement();\n+      final String sql = \"select * from \\\"emps\\\"\";\n+      final ResultSet resultSet = statement.executeQuery(sql);\n+      final String expected = \"empid=100; name=Bill\\n\"\n+          + \"empid=200; name=Eric\\n\"\n+          + \"empid=150; name=Sebastian\\n\";\n+      assertThat(CalciteAssert.toString(resultSet), is(expected));\n+    }\n+  }\n+\n   /** Extension to {@link Employee} with a {@code hireDate} column. */\n   public static class EmployeeWithHireDate extends Employee {\n     public final java.sql.Date hireDate;",
                "deletions": 0
            },
            {
                "sha": "b4f233a1562a36676f7f096b68d4be6ae066f692",
                "filename": "linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java",
                "blob_url": "https://github.com/apache/calcite/blob/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java",
                "raw_url": "https://github.com/apache/calcite/raw/3d88b254a703fa2c4b20e7952802c5cd3f38ffc2/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java",
                "status": "modified",
                "changes": 1,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java?ref=3d88b254a703fa2c4b20e7952802c5cd3f38ffc2",
                "patch": "@@ -252,6 +252,7 @@ static String className(Type type) {\n     }\n     String className = clazz.getName();\n     if (!clazz.isPrimitive()\n+        && clazz.getPackage() != null\n         && clazz.getPackage().getName().equals(\"java.lang\")) {\n       return className.substring(\"java.lang.\".length());\n     }",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-2237] Upgrade Maven Surefire plugin to 2.21.0 (Kevin Risden)\n\nFixes NPE when using Maven Surefire plugin 2.20.1 on JDK 10.\nSee [SUREFIRE-1439] and [MPOM-184] for details.\n\nClose apache/calcite#656",
        "commit": "https://github.com/apache/calcite/commit/000622daf9af011b88022b4679dd08c7d09f1475",
        "parent": "https://github.com/apache/calcite/commit/a838a73c92575db16de337911564c90a9d4e967f",
        "bug_id": "calcite_33",
        "file": [
            {
                "sha": "105ae4a77b2714f6158c9e4ee7f802aa523280d4",
                "filename": "pom.xml",
                "blob_url": "https://github.com/apache/calcite/blob/000622daf9af011b88022b4679dd08c7d09f1475/pom.xml",
                "raw_url": "https://github.com/apache/calcite/raw/000622daf9af011b88022b4679dd08c7d09f1475/pom.xml",
                "status": "modified",
                "changes": 5,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/pom.xml?ref=000622daf9af011b88022b4679dd08c7d09f1475",
                "patch": "@@ -104,10 +104,12 @@ limitations under the License.\n     <maven-checkstyle-plugin.version>3.0.0</maven-checkstyle-plugin.version>\n     <maven-dependency-plugin.version>2.10</maven-dependency-plugin.version>\n     <maven-enforcer-plugin.version>3.0.0-M1</maven-enforcer-plugin.version>\n-    <!-- Apache 19 has 2.10.4, but need 3.0.0 for [LANG-365]. -->\n+    <!-- Apache 19 has 2.10.4, but need 3.0.0 for [LANG-1365]. -->\n     <maven-javadoc-plugin.version>3.0.0</maven-javadoc-plugin.version>\n     <maven-scm-provider.version>1.9.4</maven-scm-provider.version>\n     <maven-shade-plugin.version>2.1</maven-shade-plugin.version>\n+    <!-- Apache 19 has 2.20.1, but need 2.21.0+ for [MPOM-184] -->\n+    <maven-surefire-plugin.version>2.21.0</maven-surefire-plugin.version>\n     <mockito.version>2.5.5</mockito.version>\n     <mongo-java-driver.version>3.5.0</mongo-java-driver.version>\n     <mysql-driver.version>5.1.20</mysql-driver.version>\n@@ -855,6 +857,7 @@ limitations under the License.\n         <plugin>\n           <groupId>org.apache.maven.plugins</groupId>\n           <artifactId>maven-surefire-plugin</artifactId>\n+          <version>${maven-surefire-plugin.version}</version>\n           <configuration>\n             <threadCount>1</threadCount>\n             <perCoreThreadCount>true</perCoreThreadCount>",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1188] NullPointerException when EXTRACT is applied to NULL date field (Alessandro Solimando)\n\nThis commit is just a test case, and it passes; the bug was apparently fixed a while ago.\n\nFix a compilation error caused by upgrade to Java 8.\n\nClose apache/calcite#607\nClose apache/calcite#608\n\nChange-Id: I5afd0f0609353666fe6236883357beb77cd10c92",
        "commit": "https://github.com/apache/calcite/commit/8de5d8d000104fc1e48d77abac72811c52fd9cf1",
        "parent": "https://github.com/apache/calcite/commit/0ecbdab792a80b1f05c6e03e99026f854b7e3af6",
        "bug_id": "calcite_34",
        "file": [
            {
                "sha": "575de7624e9b7436c43ebc9781c96f8ebba7c0c0",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/8de5d8d000104fc1e48d77abac72811c52fd9cf1/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/8de5d8d000104fc1e48d77abac72811c52fd9cf1/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "status": "modified",
                "changes": 24,
                "additions": 24,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcTest.java?ref=8de5d8d000104fc1e48d77abac72811c52fd9cf1",
                "patch": "@@ -1561,6 +1561,30 @@ public Void apply(ResultSet a0) {\n         .returns(\"C=3\\n\");\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1188\">[CALCITE-1188]\n+   * NullPointerException when EXTRACT is applied to NULL date field</a>.\n+   * The problem occurs when EXTRACT appears in both SELECT and WHERE ... IN\n+   * clauses, the latter with at least two values. */\n+  @Test public void testExtractOnNullDateField() {\n+    final String sql = \"select\\n\"\n+        + \"  extract(year from \\\"end_date\\\"), \\\"hire_date\\\", \\\"birth_date\\\"\\n\"\n+        + \"from \\\"foodmart\\\".\\\"employee\\\"\\n\"\n+        + \"where extract(year from \\\"end_date\\\") in (1994, 1995, 1996)\\n\"\n+        + \"group by\\n\"\n+        + \"  extract(year from \\\"end_date\\\"), \\\"hire_date\\\", \\\"birth_date\\\"\\n\";\n+    final String sql2 = sql + \"\\n\"\n+        + \"limit 10000\";\n+    final String sql3 = \"select *\\n\"\n+        + \"from \\\"foodmart\\\".\\\"employee\\\"\\n\"\n+        + \"where extract(year from \\\"end_date\\\") in (1994, 1995, 1996)\";\n+    final CalciteAssert.AssertThat with = CalciteAssert.that()\n+        .with(CalciteAssert.Config.FOODMART_CLONE);\n+    with.query(sql).returns(\"\");\n+    with.query(sql2).returns(\"\");\n+    with.query(sql3).returns(\"\");\n+  }\n+\n   @Test public void testFloorDate() {\n     CalciteAssert.that()\n         .with(CalciteAssert.Config.JDBC_FOODMART)",
                "deletions": 0
            },
            {
                "sha": "5a06ec1ec79546f7be2e388d3b95ccfb8c927bd7",
                "filename": "piglet/src/main/java/org/apache/calcite/piglet/Ast.java",
                "blob_url": "https://github.com/apache/calcite/blob/8de5d8d000104fc1e48d77abac72811c52fd9cf1/piglet/src/main/java/org/apache/calcite/piglet/Ast.java",
                "raw_url": "https://github.com/apache/calcite/raw/8de5d8d000104fc1e48d77abac72811c52fd9cf1/piglet/src/main/java/org/apache/calcite/piglet/Ast.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/piglet/src/main/java/org/apache/calcite/piglet/Ast.java?ref=8de5d8d000104fc1e48d77abac72811c52fd9cf1",
                "patch": "@@ -570,7 +570,7 @@ public UnParser append(Node n) {\n \n     public UnParser appendList(List<? extends Node> list) {\n       append(\"[\").in();\n-      for (Ord<Node> n : Ord.zip(list)) {\n+      for (Ord<Node> n : Ord.<Node>zip(list)) {\n         newline().append(n.e);\n         if (n.i < list.size() - 1) {\n           append(\",\");",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1859] NPE in validate method of VolcanoPlanner\n\nClose apache/calcite#483",
        "commit": "https://github.com/apache/calcite/commit/a2faf47b0f2bc98482a39ff51c23f7b92c118fee",
        "parent": "https://github.com/apache/calcite/commit/cdb30028ae429c3b6513c09627bceb3da5ac720a",
        "bug_id": "calcite_35",
        "file": [
            {
                "sha": "f364704ca6af9efb67e8aab1805455b9a6036d35",
                "filename": "core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
                "blob_url": "https://github.com/apache/calcite/blob/a2faf47b0f2bc98482a39ff51c23f7b92c118fee/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
                "raw_url": "https://github.com/apache/calcite/raw/a2faf47b0f2bc98482a39ff51c23f7b92c118fee/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
                "status": "modified",
                "changes": 5,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java?ref=a2faf47b0f2bc98482a39ff51c23f7b92c118fee",
                "patch": "@@ -888,7 +888,6 @@ public RelSubset ensureRegistered(RelNode rel, RelNode equivRel) {\n    * Checks internal consistency.\n    */\n   protected void validate() {\n-    final RelMetadataQuery mq = root.getCluster().getMetadataQuery();\n     for (RelSet set : allSets) {\n       if (set.equivalentSet != null) {\n         throw new AssertionError(\n@@ -902,7 +901,7 @@ protected void validate() {\n               + \"] is in wrong set [\" + set + \"]\");\n         }\n         for (RelNode rel : subset.getRels()) {\n-          RelOptCost relCost = getCost(rel, mq);\n+          RelOptCost relCost = getCost(rel, rel.getCluster().getMetadataQuery());\n           if (relCost.isLt(subset.bestCost)) {\n             throw new AssertionError(\n                 \"rel [\" + rel.getDescription()\n@@ -1169,7 +1168,6 @@ public void setImportance(RelNode rel, double importance) {\n    * @see #normalizePlan(String)\n    */\n   public void dump(PrintWriter pw) {\n-    final RelMetadataQuery mq = root.getCluster().getMetadataQuery();\n     pw.println(\"Root: \" + root.getDescription());\n     pw.println(\"Original rel:\");\n     pw.println(originalRootString);\n@@ -1222,6 +1220,7 @@ public int compare(\n           if (importance != null) {\n             pw.print(\", importance=\" + importance);\n           }\n+          RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n           pw.print(\", rowcount=\" + mq.getRowCount(rel));\n           pw.println(\", cumulative cost=\" + getCost(rel, mq));\n         }",
                "deletions": 3
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-801] NullPointerException using USING on table alias with column aliases\n\nFix an issue numbering the fields in a RelCrossType",
        "commit": "https://github.com/apache/calcite/commit/c57d80725766c84834a35e4f3b68feb38540b66c",
        "parent": "https://github.com/apache/calcite/commit/23396f0637724205ae35a89972bb61bc60d3e946",
        "bug_id": "calcite_36",
        "file": [
            {
                "sha": "ba2ac856877d9d0b207c8d2055ba06905061a34b",
                "filename": "core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java",
                "blob_url": "https://github.com/apache/calcite/blob/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java",
                "raw_url": "https://github.com/apache/calcite/raw/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java",
                "status": "modified",
                "changes": 1,
                "additions": 0,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java?ref=c57d80725766c84834a35e4f3b68feb38540b66c",
                "patch": "@@ -44,7 +44,6 @@ public RelCrossType(\n       List<RelDataTypeField> fields) {\n     super(fields);\n     this.types = ImmutableList.copyOf(types);\n-    assert types != null;\n     assert types.size() >= 1;\n     for (RelDataType type : types) {\n       assert !(type instanceof RelCrossType);",
                "deletions": 1
            },
            {
                "sha": "46f8ba3d7871179f3c2b433cfe62f9dcb8b7cf96",
                "filename": "core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java",
                "status": "modified",
                "changes": 48,
                "additions": 23,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java?ref=c57d80725766c84834a35e4f3b68feb38540b66c",
                "patch": "@@ -126,12 +126,10 @@ public RelDataType createJavaType(Class clazz) {\n   public RelDataType createJoinType(RelDataType... types) {\n     assert types != null;\n     assert types.length >= 1;\n-    final List<RelDataType> flattenedTypes =\n-        getTypeArray(ImmutableList.copyOf(types));\n+    final List<RelDataType> flattenedTypes = new ArrayList<>();\n+    getTypeList(ImmutableList.copyOf(types), flattenedTypes);\n     return canonize(\n-        new RelCrossType(\n-            flattenedTypes,\n-            getFieldArray(flattenedTypes)));\n+        new RelCrossType(flattenedTypes, getFieldList(flattenedTypes)));\n   }\n \n   // implement RelDataTypeFactory\n@@ -359,44 +357,39 @@ protected RelDataType canonize(\n   }\n \n   /**\n-   * Returns an array of the fields in an array of types.\n+   * Returns a list of the fields in a list of types.\n    */\n-  private static List<RelDataTypeField> getFieldArray(List<RelDataType> types) {\n-    ArrayList<RelDataTypeField> fieldList =\n-        new ArrayList<RelDataTypeField>();\n+  private static List<RelDataTypeField> getFieldList(List<RelDataType> types) {\n+    final List<RelDataTypeField> fieldList = new ArrayList<>();\n     for (RelDataType type : types) {\n       addFields(type, fieldList);\n     }\n     return fieldList;\n   }\n \n   /**\n-   * Returns an array of all atomic types in an array.\n+   * Returns a list of all atomic types in a list.\n    */\n-  private static List<RelDataType> getTypeArray(List<RelDataType> types) {\n-    List<RelDataType> flatTypes = new ArrayList<RelDataType>();\n-    getTypeArray(types, flatTypes);\n-    return flatTypes;\n-  }\n-\n-  private static void getTypeArray(\n-      List<RelDataType> inTypes,\n+  private static void getTypeList(\n+      ImmutableList<RelDataType> inTypes,\n       List<RelDataType> flatTypes) {\n     for (RelDataType inType : inTypes) {\n       if (inType instanceof RelCrossType) {\n-        getTypeArray(((RelCrossType) inType).types, flatTypes);\n+        getTypeList(((RelCrossType) inType).types, flatTypes);\n       } else {\n         flatTypes.add(inType);\n       }\n     }\n   }\n \n   /**\n-   * Adds all fields in <code>type</code> to <code>fieldList</code>.\n+   * Adds all fields in <code>type</code> to <code>fieldList</code>,\n+   * renumbering the fields (if necessary) to ensure that their index\n+   * matches their position in the list.\n    */\n   private static void addFields(\n       RelDataType type,\n-      ArrayList<RelDataTypeField> fieldList) {\n+      List<RelDataTypeField> fieldList) {\n     if (type instanceof RelCrossType) {\n       final RelCrossType crossType = (RelCrossType) type;\n       for (RelDataType type1 : crossType.types) {\n@@ -405,6 +398,10 @@ private static void addFields(\n     } else {\n       List<RelDataTypeField> fields = type.getFieldList();\n       for (RelDataTypeField field : fields) {\n+        if (field.getIndex() != fieldList.size()) {\n+          field = new RelDataTypeFieldImpl(field.getName(), fieldList.size(),\n+              field.getType());\n+        }\n         fieldList.add(field);\n       }\n     }\n@@ -415,8 +412,7 @@ public static boolean isJavaType(RelDataType t) {\n   }\n \n   private List<RelDataTypeFieldImpl> fieldsOf(Class clazz) {\n-    final List<RelDataTypeFieldImpl> list =\n-        new ArrayList<RelDataTypeFieldImpl>();\n+    final List<RelDataTypeFieldImpl> list = new ArrayList<>();\n     for (Field field : clazz.getFields()) {\n       if (Modifier.isStatic(field.getModifiers())) {\n         continue;\n@@ -436,8 +432,10 @@ public static boolean isJavaType(RelDataType t) {\n   }\n \n   /**\n-   * implement RelDataTypeFactory with SQL 2003 compliant behavior. Let p1, s1\n-   * be the precision and scale of the first operand Let p2, s2 be the\n+   * {@inheritDoc}\n+   *\n+   * <p>Implement RelDataTypeFactory with SQL 2003 compliant behavior. Let p1,\n+   * s1 be the precision and scale of the first operand Let p2, s2 be the\n    * precision and scale of the second operand Let p, s be the precision and\n    * scale of the result, Then the result type is a decimal with:\n    *",
                "deletions": 25
            },
            {
                "sha": "e733d137832fde6705c4b864885a3db1be99e2bd",
                "filename": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
                "status": "modified",
                "changes": 65,
                "additions": 32,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java?ref=c57d80725766c84834a35e4f3b68feb38540b66c",
                "patch": "@@ -562,8 +562,8 @@ protected boolean checkConvertedRowType(\n     RelDataType validatedRowType = validator.getValidatedNodeType(query);\n     validatedRowType = uniquifyFields(validatedRowType);\n \n-    return RelOptUtil.equal(\n-        \"validated row type\", validatedRowType, \"converted row type\", convertedRowType, false);\n+    return RelOptUtil.equal(\"validated row type\", validatedRowType,\n+        \"converted row type\", convertedRowType, false);\n   }\n \n   protected RelDataType uniquifyFields(RelDataType rowType) {\n@@ -1910,16 +1910,22 @@ protected void convertFrom(\n       RelNode rightRel = rightBlackboard.root;\n       JoinRelType convertedJoinType = convertJoinType(joinType);\n       RexNode conditionExp;\n+      final SqlValidatorNamespace leftNamespace = validator.getNamespace(left);\n+      final SqlValidatorNamespace rightNamespace = validator.getNamespace(right);\n       if (isNatural) {\n+        final RelDataType leftRowType = leftNamespace.getRowType();\n+        final RelDataType rightRowType = rightNamespace.getRowType();\n         final List<String> columnList =\n-            SqlValidatorUtil.deriveNaturalJoinColumnList(\n-                validator.getNamespace(left).getRowType(),\n-                validator.getNamespace(right).getRowType());\n-        conditionExp = convertUsing(leftRel, rightRel, columnList);\n+            SqlValidatorUtil.deriveNaturalJoinColumnList(leftRowType,\n+                rightRowType);\n+        conditionExp = convertUsing(leftNamespace, rightNamespace,\n+            columnList);\n       } else {\n         conditionExp =\n             convertJoinCondition(\n                 fromBlackboard,\n+                leftNamespace,\n+                rightNamespace,\n                 join.getCondition(),\n                 join.getConditionType(),\n                 leftRel,\n@@ -2253,8 +2259,9 @@ private boolean isSubQueryNonCorrelated(RelNode subq, Blackboard bb) {\n     return Collections.emptyList();\n   }\n \n-  private RexNode convertJoinCondition(\n-      Blackboard bb,\n+  private RexNode convertJoinCondition(Blackboard bb,\n+      SqlValidatorNamespace leftNamespace,\n+      SqlValidatorNamespace rightNamespace,\n       SqlNode condition,\n       JoinConditionType conditionType,\n       RelNode leftRel,\n@@ -2276,7 +2283,7 @@ private RexNode convertJoinCondition(\n         String name = id.getSimple();\n         nameList.add(name);\n       }\n-      return convertUsing(leftRel, rightRel, nameList);\n+      return convertUsing(leftNamespace, rightNamespace, nameList);\n     default:\n       throw Util.unexpected(conditionType);\n     }\n@@ -2287,37 +2294,29 @@ private RexNode convertJoinCondition(\n    * from NATURAL JOIN. \"a JOIN b USING (x, y)\" becomes \"a.x = b.x AND a.y =\n    * b.y\". Returns null if the column list is empty.\n    *\n-   * @param leftRel  Left input to the join\n-   * @param rightRel Right input to the join\n+   * @param leftNamespace Namespace of left input to join\n+   * @param rightNamespace Namespace of right input to join\n    * @param nameList List of column names to join on\n    * @return Expression to match columns from name list, or true if name list\n    * is empty\n    */\n-  private RexNode convertUsing(\n-      RelNode leftRel,\n-      RelNode rightRel,\n+  private RexNode convertUsing(SqlValidatorNamespace leftNamespace,\n+      SqlValidatorNamespace rightNamespace,\n       List<String> nameList) {\n     final List<RexNode> list = Lists.newArrayList();\n     for (String name : nameList) {\n-      final RelDataType leftRowType = leftRel.getRowType();\n-      RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n-      RexNode left =\n-          rexBuilder.makeInputRef(\n-              leftField.getType(),\n-              leftField.getIndex());\n-      final RelDataType rightRowType = rightRel.getRowType();\n-      RelDataTypeField rightField =\n-          catalogReader.field(rightRowType, name);\n-      RexNode right =\n-          rexBuilder.makeInputRef(\n-              rightField.getType(),\n-              leftRowType.getFieldList().size() + rightField.getIndex());\n-      RexNode equalsCall =\n-          rexBuilder.makeCall(\n-              SqlStdOperatorTable.EQUALS,\n-              left,\n-              right);\n-      list.add(equalsCall);\n+      List<RexNode> operands = new ArrayList<>();\n+      int offset = 0;\n+      for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace,\n+          rightNamespace)) {\n+        final RelDataType rowType = n.getRowType();\n+        final RelDataTypeField field = catalogReader.field(rowType, name);\n+        operands.add(\n+            rexBuilder.makeInputRef(field.getType(),\n+                offset + field.getIndex()));\n+        offset += rowType.getFieldList().size();\n+      }\n+      list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands));\n     }\n     return RexUtil.composeConjunction(rexBuilder, list, false);\n   }",
                "deletions": 33
            },
            {
                "sha": "ee7f2c98947cb4906bfb21387cf6d6823c15b487",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java",
                "status": "modified",
                "changes": 39,
                "additions": 26,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java?ref=c57d80725766c84834a35e4f3b68feb38540b66c",
                "patch": "@@ -151,6 +151,19 @@ protected final void check(\n         \"${plan}\");\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-801\">[CALCITE-801]\n+   * NullPointerException using USING on table alias with column\n+   * aliases</a>. */\n+  @Test public void testValuesUsing() {\n+    check(\"select d.deptno, min(e.empid) as empid\\n\"\n+            + \"from (values (100, 'Bill', 1)) as e(empid, name, deptno)\\n\"\n+            + \"join (values (1, 'LeaderShip')) as d(deptno, name)\\n\"\n+            + \"  using (deptno)\\n\"\n+            + \"group by d.deptno\",\n+        \"${plan}\");\n+  }\n+\n   @Test public void testJoinNatural() {\n     check(\n         \"SELECT * FROM emp NATURAL JOIN dept\",\n@@ -1198,7 +1211,7 @@ protected final void check(\n   @Test public void testSubqueryLimitOne() {\n     sql(\"select deptno\\n\"\n         + \"from EMP\\n\"\n-        + \"where deptno > (select deptno \\n\"\n+        + \"where deptno > (select deptno\\n\"\n         + \"from EMP order by deptno limit 1)\")\n         .convertsTo(\"${plan}\");\n   }\n@@ -1222,10 +1235,10 @@ protected final void check(\n    * Scan HAVING clause for sub-queries and IN-lists</a> relating to IN.\n    */\n   @Test public void testHavingAggrFunctionIn() {\n-    sql(\"select deptno \\n\"\n-        + \"from emp \\n\"\n-        + \"group by deptno \\n\"\n-        + \"having sum(case when deptno in (1, 2) then 0 else 1 end) + \\n\"\n+    sql(\"select deptno\\n\"\n+        + \"from emp\\n\"\n+        + \"group by deptno\\n\"\n+        + \"having sum(case when deptno in (1, 2) then 0 else 1 end) +\\n\"\n         + \"sum(case when deptno in (3, 4) then 0 else 1 end) > 10\")\n         .convertsTo(\"${plan}\");\n   }\n@@ -1237,14 +1250,14 @@ protected final void check(\n    * the HAVING clause.\n    */\n   @Test public void testHavingInSubqueryWithAggrFunction() {\n-    sql(\"select sal \\n\"\n-        + \"from emp \\n\"\n-        + \"group by sal \\n\"\n-        + \"having sal in \\n\"\n-            + \"(select deptno \\n\"\n-            + \"from dept \\n\"\n-            + \"group by deptno \\n\"\n-            + \"having sum(deptno) > 0)\")\n+    sql(\"select sal\\n\"\n+        + \"from emp\\n\"\n+        + \"group by sal\\n\"\n+        + \"having sal in (\\n\"\n+        + \"  select deptno\\n\"\n+        + \"  from dept\\n\"\n+        + \"  group by deptno\\n\"\n+        + \"  having sum(deptno) > 0)\")\n         .convertsTo(\"${plan}\");\n   }\n ",
                "deletions": 13
            },
            {
                "sha": "1130160e08c1a39714814b50f0086e0781d23add",
                "filename": "core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "blob_url": "https://github.com/apache/calcite/blob/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "raw_url": "https://github.com/apache/calcite/raw/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml",
                "status": "modified",
                "changes": 73,
                "additions": 47,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/org/apache/calcite/test/SqlToRelConverterTest.xml?ref=c57d80725766c84834a35e4f3b68feb38540b66c",
                "patch": "@@ -2438,7 +2438,7 @@ LogicalAggregate(group=[{0}], EXPR$1=[SUM($1) FILTER $2], EXPR$2=[COUNT()])\n         <Resource name=\"sql\">\n             <![CDATA[select deptno\n from EMP\n-where deptno > (select min(deptno) * 2 + 10 from EMP]]>\n+where deptno > (select min(deptno) * 2 + 10 from EMP)]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2508,7 +2508,7 @@ LogicalProject(DEPTNO=[$7])\n from emp\n group by deptno\n having sum(case when deptno in (1, 2) then 0 else 1 end) +\n-sum(case when deptno in (3, 4) then 0 else 1 end) > 10)]]>\n+sum(case when deptno in (3, 4) then 0 else 1 end) > 10]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2525,11 +2525,11 @@ LogicalProject(DEPTNO=[$0])\n             <![CDATA[select sal\n from emp\n group by sal\n-having sal in\n-(select deptno\n-from dept\n-group by deptno\n-having sum(deptno) > 0)]]>\n+having sal in (\n+  select deptno\n+  from dept\n+  group by deptno\n+  having sum(deptno) > 0)]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2633,9 +2633,10 @@ LogicalTableModify(table=[[CATALOG, SALES, EMP]], operation=[INSERT], updateColu\n     </TestCase>\n     <TestCase name=\"testWindowAggWithGroupBy\">\n         <Resource name=\"sql\">\n-            <![CDATA[select min(deptno), rank() over (order by empno)\n-            max(empno) over (partition by deptno)\n-            from emp group by deptno, empno]]>\n+            <![CDATA[select min(deptno), rank() over (order by empno),\n+max(empno) over (partition by deptno)\n+from emp group by deptno, empno\n+]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2646,13 +2647,14 @@ LogicalProject(EXPR$0=[$2], EXPR$1=[RANK() OVER (ORDER BY $1 RANGE BETWEEN UNBOU\n ]]>\n         </Resource>\n     </TestCase>\n-        <TestCase name=\"testWindowAggWithGroupByAndJoin\">\n+    <TestCase name=\"testWindowAggWithGroupByAndJoin\">\n         <Resource name=\"sql\">\n             <![CDATA[select min(d.deptno), rank() over (order by e.empno),\n-            max(e.empno) over (partition by e.deptno)\n-            from emp e, dept d\n-            where e.deptno = d.deptno\n-            group by d.deptno, e.empno, e.deptno]]>\n+ max(e.empno) over (partition by e.deptno)\n+from emp e, dept d\n+where e.deptno = d.deptno\n+group by d.deptno, e.empno, e.deptno\n+]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2669,9 +2671,10 @@ LogicalProject(EXPR$0=[$3], EXPR$1=[RANK() OVER (ORDER BY $1 RANGE BETWEEN UNBOU\n     <TestCase name=\"testWindowAggWithGroupByAndHaving\">\n         <Resource name=\"sql\">\n             <![CDATA[select min(deptno), rank() over (order by empno),\n-            max(empno) over (partition by deptno)\n-            from emp group by deptno, empno\n-            having empno < 10 and min(deptno) < 20]]>\n+max(empno) over (partition by deptno)\n+from emp group by deptno, empno\n+having empno < 10 and min(deptno) < 20\n+]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2684,14 +2687,14 @@ LogicalProject(EXPR$0=[$2], EXPR$1=[RANK() OVER (ORDER BY $1 RANGE BETWEEN UNBOU\n         </Resource>\n     </TestCase>\n     <TestCase name=\"testWindowAggInSubqueryJoin\">\n-    <Resource name=\"sql\">\n-            <![CDATA[select T.x, T.y, T.z,\n-        emp.empno from (select min(deptno) as x,\n-        rank() over (order by empno) as y,\n-        max(empno) over (partition by deptno) as z\n-        from emp group by deptno, empno) as T\n-        inner join emp on T.x = emp.deptno\n-        and T.y = emp.empno]]>\n+        <Resource name=\"sql\">\n+            <![CDATA[select T.x, T.y, T.z, emp.empno from (select min(deptno) as x,\n+   rank() over (order by empno) as y,\n+   max(empno) over (partition by deptno) as z\n+   from emp group by deptno, empno) as T\n+ inner join emp on T.x = emp.deptno\n+ and T.y = emp.empno\n+]]>\n         </Resource>\n         <Resource name=\"plan\">\n             <![CDATA[\n@@ -2702,6 +2705,24 @@ LogicalProject(X=[$0], Y=[$1], Z=[$2], EMPNO=[$3])\n         LogicalProject(DEPTNO=[$7], EMPNO=[$0])\n           LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n     LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+]]>\n+        </Resource>\n+    </TestCase>\n+    <TestCase name=\"testValuesUsing\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select d.deptno, min(e.empid) as empid\n+from (values (100, 'Bill', 1)) as e(empid, name, deptno)\n+join (values (1, 'LeaderShip')) as d(deptno, name)\n+  using (deptno)\n+group by d.deptno]]>\n+        </Resource>\n+        <Resource name=\"plan\">\n+            <![CDATA[\n+LogicalAggregate(group=[{0}], EMPID=[MIN($1)])\n+  LogicalProject(DEPTNO=[$3], EXPR$0=[$0])\n+    LogicalJoin(condition=[=($2, $3)], joinType=[inner])\n+      LogicalValues(tuples=[[{ 100, 'Bill', 1 }]])\n+      LogicalValues(tuples=[[{ 1, 'LeaderShip' }]])\n ]]>\n         </Resource>\n     </TestCase>",
                "deletions": 26
            },
            {
                "sha": "83cfb7c78623e1e27c8f69ebeb9e308f993211ac",
                "filename": "core/src/test/resources/sql/join.oq",
                "blob_url": "https://github.com/apache/calcite/blob/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/test/resources/sql/join.oq",
                "raw_url": "https://github.com/apache/calcite/raw/c57d80725766c84834a35e4f3b68feb38540b66c/core/src/test/resources/sql/join.oq",
                "status": "modified",
                "changes": 20,
                "additions": 20,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/sql/join.oq?ref=c57d80725766c84834a35e4f3b68feb38540b66c",
                "patch": "@@ -235,4 +235,24 @@ EnumerableCalc(expr#0..3=[{inputs}], DEPTNO=[$t2], DEPTNO0=[$t0])\n       EnumerableTableScan(table=[[scott, EMP]])\n !plan\n \n+### [CALCITE-801] NullPointerException using USING on table alias with column aliases\n+select *\n+from (values (100, 'Bill', 1),\n+             (200, 'Eric', 1),\n+             (150, 'Sebastian', 3)) as e(empid, name, deptno)\n+join (values (1, 'LeaderShip'),\n+             (2, 'TestGroup'),\n+             (3, 'Development')) as d(deptno, name)\n+using (deptno);\n++-------+-----------+--------+---------+-------------+\n+| EMPID | NAME      | DEPTNO | DEPTNO0 | NAME0       |\n++-------+-----------+--------+---------+-------------+\n+|   100 | Bill      |      1 |       1 | LeaderShip  |\n+|   150 | Sebastian |      3 |       3 | Development |\n+|   200 | Eric      |      1 |       1 | LeaderShip  |\n++-------+-----------+--------+---------+-------------+\n+(3 rows)\n+\n+!ok\n+\n # End join.oq",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1770] Druid adapter: CAST(NULL AS ...) gives NPE (Slim Bouguerra)\n\nClose apache/calcite#441",
        "commit": "https://github.com/apache/calcite/commit/ef00738a053cbe881f2c840f3e3b5feeb010b6e1",
        "parent": "https://github.com/apache/calcite/commit/1aaa0d6860c7538d62998ec13bcc83763c04720f",
        "bug_id": "calcite_37",
        "file": [
            {
                "sha": "81e94dda3705802c40b3a430f8edb1daf4898e01",
                "filename": "druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java",
                "blob_url": "https://github.com/apache/calcite/blob/ef00738a053cbe881f2c840f3e3b5feeb010b6e1/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java",
                "raw_url": "https://github.com/apache/calcite/raw/ef00738a053cbe881f2c840f3e3b5feeb010b6e1/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java",
                "status": "modified",
                "changes": 4,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java?ref=ef00738a053cbe881f2c840f3e3b5feeb010b6e1",
                "patch": "@@ -959,6 +959,10 @@ public String getQueryString(String pagingIdentifier, int offset) {\n       case CAST:\n         return tr(e, 0, set);\n       case LITERAL:\n+        if (((RexLiteral) e).getValue3() == null) {\n+          // Druid considers null is equivalent to empty.\n+          return \"\";\n+        }\n         return ((RexLiteral) e).getValue3().toString();\n       case FLOOR:\n       case EXTRACT:",
                "deletions": 0
            },
            {
                "sha": "17d621116929212c18029f56a53020caa1d38c4b",
                "filename": "druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java",
                "blob_url": "https://github.com/apache/calcite/blob/ef00738a053cbe881f2c840f3e3b5feeb010b6e1/druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java",
                "raw_url": "https://github.com/apache/calcite/raw/ef00738a053cbe881f2c840f3e3b5feeb010b6e1/druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java",
                "status": "modified",
                "changes": 12,
                "additions": 12,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java?ref=ef00738a053cbe881f2c840f3e3b5feeb010b6e1",
                "patch": "@@ -2088,6 +2088,18 @@ public Void apply(ResultSet resultSet) {\n     sql(sql).explainContains(plan).queryContains(druidChecker(\"'queryType':'select'\"))\n         .returnsUnordered(\"EXPR$0=19\");\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1770\">[CALCITE-1770]\n+   * Druid adapter: CAST(NULL AS ...) gives NPE</a>. */\n+  @Test public void testPushCast() {\n+    final String sql = \"SELECT \\\"product_id\\\"\\n\"\n+        + \"from \\\"foodmart\\\"\\n\"\n+        + \"where \\\"product_id\\\" = cast(NULL as varchar)\\n\"\n+        + \"group by \\\"product_id\\\"\";\n+    String druidQuery = \"'filter':{'type':'selector','dimension':'product_id','value':''}\";\n+    sql(sql).queryContains(druidChecker(druidQuery));\n+  }\n }\n \n // End DruidAdapterIT.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1595] RelBuilder.call throws NullPointerException if argument types are invalid (Jess Balint)\n\nNow, both versions of RelBuilder.call() use the same type validation;\npreviously the Iterable variant bypassed validation.\n\nClose apache/calcite#363",
        "commit": "https://github.com/apache/calcite/commit/a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f",
        "parent": "https://github.com/apache/calcite/commit/bc40bc06a1331394c95673034bedbb46f908fb13",
        "bug_id": "calcite_38",
        "file": [
            {
                "sha": "2b3a54588ff2715f7d2e36079248732d5379d896",
                "filename": "core/src/main/java/org/apache/calcite/tools/RelBuilder.java",
                "blob_url": "https://github.com/apache/calcite/blob/a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f/core/src/main/java/org/apache/calcite/tools/RelBuilder.java",
                "raw_url": "https://github.com/apache/calcite/raw/a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f/core/src/main/java/org/apache/calcite/tools/RelBuilder.java",
                "status": "modified",
                "changes": 9,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/tools/RelBuilder.java?ref=a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f",
                "patch": "@@ -513,8 +513,12 @@ public RexNode dot(RexNode node, int fieldOrdinal) {\n \n   /** Creates a call to a scalar operator. */\n   public RexNode call(SqlOperator operator, RexNode... operands) {\n+    return call(operator, ImmutableList.copyOf(operands));\n+  }\n+\n+  /** Creates a call to a scalar operator. */\n+  private RexNode call(SqlOperator operator, List<RexNode> operandList) {\n     final RexBuilder builder = cluster.getRexBuilder();\n-    final List<RexNode> operandList = ImmutableList.copyOf(operands);\n     final RelDataType type = builder.deriveReturnType(operator, operandList);\n     if (type == null) {\n       throw new IllegalArgumentException(\"cannot derive type: \" + operator\n@@ -526,8 +530,7 @@ public RexNode call(SqlOperator operator, RexNode... operands) {\n   /** Creates a call to a scalar operator. */\n   public RexNode call(SqlOperator operator,\n       Iterable<? extends RexNode> operands) {\n-    return cluster.getRexBuilder().makeCall(operator,\n-        ImmutableList.copyOf(operands));\n+    return call(operator, ImmutableList.copyOf(operands));\n   }\n \n   /** Creates an AND. */",
                "deletions": 3
            },
            {
                "sha": "cabbcdc1b82e5843525383beb358b492e412265e",
                "filename": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f/core/src/test/java/org/apache/calcite/test/RelBuilderTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f/core/src/test/java/org/apache/calcite/test/RelBuilderTest.java",
                "status": "modified",
                "changes": 25,
                "additions": 25,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RelBuilderTest.java?ref=a55e5eb4b3ca9f1afa6e9dbeef466fa78f66812f",
                "patch": "@@ -1613,6 +1613,31 @@ private String str(RelNode r) {\n       assertThat(s, is(result));\n     }\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-1595\">[CALCITE-1595]\n+   * RelBuilder.call throws NullPointerException if argument types are\n+   * invalid</a>. */\n+  @Test public void testTypeInferenceValidation() throws Exception {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    // test for a) call(operator, Iterable<RexNode>)\n+    final RexNode arg0 = builder.literal(0);\n+    final RexNode arg1 = builder.literal(\"xyz\");\n+    try {\n+      builder.call(SqlStdOperatorTable.PLUS, Lists.newArrayList(arg0, arg1));\n+      fail(\"Invalid combination of parameter types\");\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage(), containsString(\"cannot derive type\"));\n+    }\n+\n+    // test for b) call(operator, RexNode...)\n+    try {\n+      builder.call(SqlStdOperatorTable.PLUS, arg0, arg1);\n+      fail(\"Invalid combination of parameter types\");\n+    } catch (IllegalArgumentException e) {\n+      assertThat(e.getMessage(), containsString(\"cannot derive type\"));\n+    }\n+  }\n }\n \n // End RelBuilderTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-968] Stream-to-relation and stream-to-stream joins (Milinda Pathirage)\n\nRule to transform Delta(Scan(constant-table)) to Empty;\nfix NullPointerException in PruneEmptyRules.",
        "commit": "https://github.com/apache/calcite/commit/e9d506021252e1da6c09cebad3f747cd0e627d90",
        "parent": "https://github.com/apache/calcite/commit/9c86556ff397f2548bffe90e7e338774d329211d",
        "bug_id": "calcite_39",
        "file": [
            {
                "sha": "3fccdfadae839004ff0eff6d79958b71a7a185ff",
                "filename": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -72,7 +72,8 @@\n         public void onMatch(RelOptRuleCall call) {\n           LogicalUnion union = call.rel(0);\n           final List<RelNode> childRels = call.getChildRels(union);\n-          final List<RelNode> newChildRels = new ArrayList<RelNode>();\n+          assert childRels != null;\n+          final List<RelNode> newChildRels = new ArrayList<>();\n           for (RelNode childRel : childRels) {\n             if (!isEmpty(childRel)) {\n               newChildRels.add(childRel);",
                "deletions": 1
            },
            {
                "sha": "4e64dc5e2eb13ced167db53737d9e71a72656b59",
                "filename": "core/src/main/java/org/apache/calcite/rel/stream/StreamRules.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/rel/stream/StreamRules.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/rel/stream/StreamRules.java",
                "status": "modified",
                "changes": 75,
                "additions": 74,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/stream/StreamRules.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -24,16 +24,19 @@\n import org.apache.calcite.rel.RelNode;\n import org.apache.calcite.rel.core.Aggregate;\n import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n import org.apache.calcite.rel.core.Project;\n import org.apache.calcite.rel.core.Sort;\n import org.apache.calcite.rel.core.TableScan;\n import org.apache.calcite.rel.core.Union;\n import org.apache.calcite.rel.logical.LogicalAggregate;\n import org.apache.calcite.rel.logical.LogicalFilter;\n+import org.apache.calcite.rel.logical.LogicalJoin;\n import org.apache.calcite.rel.logical.LogicalProject;\n import org.apache.calcite.rel.logical.LogicalSort;\n import org.apache.calcite.rel.logical.LogicalTableScan;\n import org.apache.calcite.rel.logical.LogicalUnion;\n+import org.apache.calcite.rel.logical.LogicalValues;\n import org.apache.calcite.schema.StreamableTable;\n import org.apache.calcite.schema.Table;\n import org.apache.calcite.util.Util;\n@@ -56,7 +59,9 @@ private StreamRules() {}\n           new DeltaAggregateTransposeRule(),\n           new DeltaSortTransposeRule(),\n           new DeltaUnionTransposeRule(),\n-          new DeltaTableScanRule());\n+          new DeltaJoinTransposeRule(),\n+          new DeltaTableScanRule(),\n+          new DeltaTableScanToEmptyRule());\n \n   /** Planner rule that pushes a {@link Delta} through a {@link Project}. */\n   public static class DeltaProjectTransposeRule extends RelOptRule {\n@@ -193,6 +198,74 @@ private DeltaTableScanRule() {\n       }\n     }\n   }\n+\n+  /**\n+   * Planner rule that converts {@link Delta} over a {@link TableScan} of\n+   * a table other than {@link org.apache.calcite.schema.StreamableTable} to Empty.\n+   */\n+  public static class DeltaTableScanToEmptyRule extends RelOptRule {\n+    private DeltaTableScanToEmptyRule() {\n+      super(\n+          operand(Delta.class,\n+              operand(TableScan.class, none())));\n+    }\n+\n+    @Override public void onMatch(RelOptRuleCall call) {\n+      final Delta delta = call.rel(0);\n+      final TableScan scan = call.rel(1);\n+      final RelOptCluster cluster = delta.getCluster();\n+      final RelOptTable relOptTable = scan.getTable();\n+      final StreamableTable streamableTable =\n+          relOptTable.unwrap(StreamableTable.class);\n+      if (streamableTable == null) {\n+        call.transformTo(LogicalValues.createEmpty(cluster, delta.getRowType()));\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * Planner rule that pushes a {@link Delta} through a {@link Join}.\n+   *\n+   * Product rule [1] is applied to implement the transpose:\n+   * stream(x join y)\" = \"x join stream(y) union all stream(x) join y\n+   *\n+   * [1] https://en.wikipedia.org/wiki/Product_rule\n+   */\n+  public static class DeltaJoinTransposeRule extends RelOptRule {\n+\n+    public DeltaJoinTransposeRule() {\n+      super(\n+          operand(Delta.class,\n+              operand(Join.class, any())));\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+      final Delta delta = call.rel(0);\n+      final Join join = call.rel(1);\n+      final RelOptCluster cluster = delta.getCluster();\n+      RelNode left = join.getLeft();\n+      RelNode right = join.getRight();\n+\n+      final LogicalDelta rightWithDelta = LogicalDelta.create(right);\n+      final LogicalJoin joinL = LogicalJoin.create(left, rightWithDelta, join.getCondition(),\n+          join.getJoinType(), join.getVariablesStopped(), join.isSemiJoinDone(),\n+          ImmutableList.copyOf(join.getSystemFieldList()));\n+\n+      final LogicalDelta leftWithDelta = LogicalDelta.create(left);\n+      final LogicalJoin joinR = LogicalJoin.create(leftWithDelta, right, join.getCondition(),\n+          join.getJoinType(), join.getVariablesStopped(), join.isSemiJoinDone(),\n+          ImmutableList.copyOf(join.getSystemFieldList()));\n+\n+      List<RelNode> inputsToUnion = Lists.newArrayList();\n+      inputsToUnion.add(joinL);\n+      inputsToUnion.add(joinR);\n+\n+      final LogicalUnion newNode = LogicalUnion.create(inputsToUnion, true);\n+      call.transformTo(newNode);\n+    }\n+  }\n }\n \n // End StreamRules.java",
                "deletions": 1
            },
            {
                "sha": "c06f3c345a729ff15da6536bf72b4bcd0d1046f7",
                "filename": "core/src/main/java/org/apache/calcite/runtime/CalciteResource.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/runtime/CalciteResource.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/runtime/CalciteResource.java",
                "status": "modified",
                "changes": 3,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/runtime/CalciteResource.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -603,6 +603,9 @@\n \n   @BaseMessage(\"Table ''{0}'' not found\")\n   ExInst<CalciteException> tableNotFound(String tableName);\n+\n+  @BaseMessage(\"Cannot stream results of a query with no streaming inputs: ''{0}''. At least one input should be convertable to a stream.\")\n+  ExInst<SqlValidatorException> cannotStreamResultsForNonStreamingInputs(String inputs);\n }\n \n // End CalciteResource.java",
                "deletions": 0
            },
            {
                "sha": "d430575a2dafb58fbe44cf0bd9c7112ad1dca53e",
                "filename": "core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
                "status": "modified",
                "changes": 45,
                "additions": 38,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -82,6 +82,7 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Function;\n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n@@ -3016,17 +3017,47 @@ private SqlModality deduceModality(SqlNode query) {\n   public boolean validateModality(SqlSelect select, SqlModality modality,\n       boolean fail) {\n     final SelectScope scope = getRawSelectScope(select);\n-    for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {\n-      if (!namespace.right.supportsModality(modality)) {\n-        switch (modality) {\n-        case STREAM:\n+\n+    switch (modality) {\n+    case STREAM:\n+      if (scope.children.size() == 1) {\n+        for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {\n+          if (!namespace.right.supportsModality(modality)) {\n+            if (fail) {\n+              throw newValidationError(namespace.right.getNode(),\n+                  Static.RESOURCE.cannotConvertToStream(namespace.left));\n+            } else {\n+              return false;\n+            }\n+          }\n+        }\n+      } else {\n+        boolean atLeastOneSupportsModality = false;\n+        for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {\n+          if (namespace.right.supportsModality(modality)) {\n+            atLeastOneSupportsModality = true;\n+          }\n+        }\n+\n+        if (!atLeastOneSupportsModality) {\n           if (fail) {\n-            throw newValidationError(namespace.right.getNode(),\n-                Static.RESOURCE.cannotConvertToStream(namespace.left));\n+            List<String> inputList = new ArrayList<String>();\n+            for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {\n+              inputList.add(namespace.left);\n+            }\n+            String inputs = Joiner.on(\", \").join(inputList);\n+\n+            throw newValidationError(select,\n+                Static.RESOURCE.cannotStreamResultsForNonStreamingInputs(inputs));\n           } else {\n             return false;\n           }\n-        default:\n+        }\n+      }\n+      break;\n+    default:\n+      for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {\n+        if (!namespace.right.supportsModality(modality)) {\n           if (fail) {\n             throw newValidationError(namespace.right.getNode(),\n                 Static.RESOURCE.cannotConvertToRelation(namespace.left));",
                "deletions": 7
            },
            {
                "sha": "2eb494731dc95a123b6f6abd85fc8a78b4718b7f",
                "filename": "core/src/main/resources/org/apache/calcite/runtime/CalciteResource.properties",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/resources/org/apache/calcite/runtime/CalciteResource.properties",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/main/resources/org/apache/calcite/runtime/CalciteResource.properties",
                "status": "modified",
                "changes": 1,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/resources/org/apache/calcite/runtime/CalciteResource.properties?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -197,4 +197,5 @@ ModifiableViewMustBeBasedOnSingleTable=Modifiable view must be based on a single\n MoreThanOneMappedColumn=View is not modifiable. More than one expression maps to column ''{0}'' of base table ''{1}''\n NoValueSuppliedForViewColumn=View is not modifiable. No value is supplied for NOT NULL column ''{0}'' of base table ''{1}''\n TableNotFound=Table ''{0}'' not found\n+CannotStreamResultsForNonStreamingInputs=Cannot stream results of a query with no streaming inputs: ''{0}''. At least one input should be convertable to a stream.\n # End CalciteResource.properties",
                "deletions": 0
            },
            {
                "sha": "50019e17d4e0f4a2590f5a57a9769fe609169890",
                "filename": "core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java",
                "status": "modified",
                "changes": 4,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -72,7 +72,9 @@\n           \"TABLE(CATALOG.SALES.BONUS)\",\n           \"TABLE(CATALOG.SALES.ORDERS)\",\n           \"TABLE(CATALOG.SALES.SALGRADE)\",\n-          \"TABLE(CATALOG.SALES.SHIPMENTS)\");\n+          \"TABLE(CATALOG.SALES.SHIPMENTS)\",\n+          \"TABLE(CATALOG.SALES.PRODUCTS)\",\n+          \"TABLE(CATALOG.SALES.SUPPLIERS)\");\n \n   private static final List<String> SCHEMAS =\n       Arrays.asList(",
                "deletions": 1
            },
            {
                "sha": "b76b9084110c05f98d36c04a5e92b7b8e28d5b44",
                "filename": "core/src/test/java/org/apache/calcite/test/MockCatalogReader.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/test/MockCatalogReader.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/test/MockCatalogReader.java",
                "status": "modified",
                "changes": 16,
                "additions": 16,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/MockCatalogReader.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -250,6 +250,22 @@ public MockCatalogReader init() {\n     shipmentsStream.addColumn(\"ORDERID\", intType);\n     registerTable(shipmentsStream);\n \n+    // Register \"PRODUCTS\" table.\n+    MockTable productsTable = MockTable.create(this, salesSchema, \"PRODUCTS\",\n+        false);\n+    productsTable.addColumn(\"PRODUCTID\", intType);\n+    productsTable.addColumn(\"NAME\", varchar20Type);\n+    productsTable.addColumn(\"SUPPLIERID\", intType);\n+    registerTable(productsTable);\n+\n+    // Register \"SUPPLIERS\" table.\n+    MockTable suppliersTable = MockTable.create(this, salesSchema, \"SUPPLIERS\",\n+        false);\n+    suppliersTable.addColumn(\"SUPPLIERID\", intType);\n+    suppliersTable.addColumn(\"NAME\", varchar20Type);\n+    suppliersTable.addColumn(\"CITY\", intType);\n+    registerTable(suppliersTable);\n+\n     // Register \"EMP_20\" view.\n     // Same columns as \"EMP\",\n     // but \"DEPTNO\" not visible and set to 20 by default",
                "deletions": 0
            },
            {
                "sha": "7ace229960f4860504fe7e113527293ab4b5a618",
                "filename": "core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java",
                "status": "modified",
                "changes": 15,
                "additions": 15,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -132,6 +132,12 @@ private static String cannotConvertToRelation(String table) {\n     return \"Cannot convert stream '\" + table + \"' to relation\";\n   }\n \n+  private static String cannotStreamResultsForNonStreamingInputs(String inputs) {\n+    return \"Cannot stream results of a query with no streaming inputs: '\"\n+        + inputs\n+        + \"'. At least one input should be convertable to a stream.\";\n+  }\n+\n   @Test public void testMultipleSameAsPass() {\n     check(\"select 1 as again,2 as \\\"again\\\", 3 as AGAiN from (values (true))\");\n   }\n@@ -7415,6 +7421,15 @@ public void _testValuesWithAggFuncs() {\n         + \"order by floor(rowtime to hour), rowtime desc\").ok();\n   }\n \n+  @Test public void testStreamJoin() {\n+    sql(\"select stream \\n\"\n+        + \"orders.rowtime as rowtime, orders.orderId as orderId, products.supplierId as supplierId \\n\"\n+        + \"from orders join products on orders.productId = products.productId\").ok();\n+    sql(\"^select stream *\\n\"\n+        + \"from products join suppliers on products.supplierId = suppliers.supplierId^\")\n+        .fails(cannotStreamResultsForNonStreamingInputs(\"PRODUCTS, SUPPLIERS\"));\n+  }\n+\n   @Test public void testNew() {\n     // (To debug individual statements, paste them into this method.)\n     //            1         2         3         4         5         6",
                "deletions": 0
            },
            {
                "sha": "90d67ddebda9e63250729f528394f6778c2f9981",
                "filename": "core/src/test/java/org/apache/calcite/test/StreamTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/test/StreamTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/e9d506021252e1da6c09cebad3f747cd0e627d90/core/src/test/java/org/apache/calcite/test/StreamTest.java",
                "status": "modified",
                "changes": 108,
                "additions": 108,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/StreamTest.java?ref=e9d506021252e1da6c09cebad3f747cd0e627d90",
                "patch": "@@ -59,6 +59,7 @@\n public class StreamTest {\n   public static final String STREAM_SCHEMA_NAME = \"STREAMS\";\n   public static final String INFINITE_STREAM_SCHEMA_NAME = \"INFINITE_STREAMS\";\n+  public static final String STREAMJOINS_SCHEMA_NAME = \"STREAMJOINS\";\n \n   private static String schemaFor(String name, Class<? extends TableFactory> clazz) {\n     return \"     {\\n\"\n@@ -74,6 +75,27 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz\n       + \"     }\";\n   }\n \n+  private static final String STREAM_JOINS_MODEL = \"{\\n\"\n+      + \"  version: '1.0',\\n\"\n+      + \"  defaultSchema: 'STREAMJOINS',\\n\"\n+      + \"   schemas: [\\n\"\n+      + \"     {\\n\"\n+      + \"       name: 'STREAMJOINS',\\n\"\n+      + \"       tables: [ {\\n\"\n+      + \"         type: 'custom',\\n\"\n+      + \"         name: 'ORDERS',\\n\"\n+      + \"         stream: {\\n\"\n+      + \"           stream: true\\n\"\n+      + \"         },\\n\"\n+      + \"         factory: '\" + OrdersStreamTableFactory.class.getName() + \"'\\n\"\n+      + \"       }, \\n\"\n+      + \"       {\\n\"\n+      + \"         type: 'custom',\\n\"\n+      + \"         name: 'PRODUCTS',\\n\"\n+      + \"         factory: '\" + ProductsTableFactory.class.getName() + \"'\\n\"\n+      + \"       }]\\n\"\n+      + \"     }]}\";\n+\n   public static final String STREAM_MODEL = \"{\\n\"\n       + \"  version: '1.0',\\n\"\n       + \"  defaultSchema: 'foodmart',\\n\"\n@@ -212,6 +234,32 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz\n         .returnsCount(100);\n   }\n \n+  @Test public void testStreamToRelaitonJoin() {\n+    CalciteAssert.model(STREAM_JOINS_MODEL)\n+        .withDefaultSchema(STREAMJOINS_SCHEMA_NAME)\n+        .query(\"select stream \"\n+            + \"orders.rowtime as rowtime, orders.id as orderId, products.supplier as supplierId \"\n+            + \"from orders join products on orders.product = products.id\")\n+        .convertContains(\n+            \"LogicalDelta\\n\"\n+                + \"  LogicalProject(ROWTIME=[$0], ORDERID=[$1], SUPPLIERID=[$5])\\n\"\n+                + \"    LogicalProject(ROWTIME=[$0], ID=[$1], PRODUCT=[$2], UNITS=[$3], ID0=[$5], SUPPLIER=[$6])\\n\"\n+                + \"      LogicalJoin(condition=[=($4, $5)], joinType=[inner])\\n\"\n+                + \"        LogicalProject(ROWTIME=[$0], ID=[$1], PRODUCT=[$2], UNITS=[$3], PRODUCT4=[CAST($2):VARCHAR(32) CHARACTER SET \\\"ISO-8859-1\\\" COLLATE \\\"ISO-8859-1$en_US$primary\\\" NOT NULL])\\n\"\n+                + \"          LogicalTableScan(table=[[STREAMJOINS, ORDERS]])\\n\"\n+                + \"        LogicalTableScan(table=[[STREAMJOINS, PRODUCTS]])\\n\")\n+        .explainContains(\"\"\n+            + \"EnumerableJoin(condition=[=($4, $5)], joinType=[inner])\\n\"\n+            + \"    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) CHARACTER SET \\\"ISO-8859-1\\\" COLLATE \\\"ISO-8859-1$en_US$primary\\\" NOT NULL], proj#0..4=[{exprs}])\\n\"\n+            + \"      EnumerableInterpreter\\n\"\n+            + \"        BindableTableScan(table=[[]])\\n\"\n+            + \"    EnumerableInterpreter\\n\"\n+            + \"      BindableTableScan(table=[[STREAMJOINS, PRODUCTS]])\")\n+        .returns(startsWith(\"ROWTIME=2015-02-15 10:15:00; ORDERID=1; SUPPLIERID=1\",\n+            \"ROWTIME=2015-02-15 10:24:15; ORDERID=2; SUPPLIERID=0\",\n+            \"ROWTIME=2015-02-15 10:24:45; ORDERID=3; SUPPLIERID=1\"));\n+  }\n+\n   private Function<ResultSet, Void> startsWith(String... rows) {\n     final ImmutableList<String> rowList = ImmutableList.copyOf(rows);\n     return new Function<ResultSet, Void>() {\n@@ -362,6 +410,66 @@ public void remove() {\n       return this;\n     }\n   }\n+\n+  /**\n+   * Mocks simple relation to use for stream joining test.\n+   */\n+  public static class ProductsTableFactory implements TableFactory<Table> {\n+\n+    public ProductsTableFactory(){}\n+\n+    @Override\n+    public Table create(SchemaPlus schema, String name, Map<String, Object> operand,\n+                        RelDataType rowType) {\n+      final ImmutableList<Object[]> rows = ImmutableList.of(\n+        new Object[]{\"paint\", 1},\n+        new Object[]{\"paper\", 0},\n+        new Object[]{\"brush\", 1}\n+      );\n+      return new ProductsTable(rows);\n+    }\n+  }\n+\n+  /**\n+   * Table representing the PRODUCTS relation\n+   */\n+  public static class ProductsTable implements ScannableTable {\n+\n+    private final ImmutableList<Object[]> rows;\n+\n+    public ProductsTable(ImmutableList<Object[]> rows) {\n+      this.rows = rows;\n+    }\n+\n+    private final RelProtoDataType protoRowType = new RelProtoDataType() {\n+      public RelDataType apply(RelDataTypeFactory a0) {\n+        return a0.builder()\n+            .add(\"ID\", SqlTypeName.VARCHAR, 32)\n+            .add(\"SUPPLIER\", SqlTypeName.INTEGER)\n+            .build();\n+      }\n+    };\n+\n+    @Override\n+    public Enumerable<Object[]> scan(DataContext root) {\n+      return Linq4j.asEnumerable(rows);\n+    }\n+\n+    @Override\n+    public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n+      return protoRowType.apply(typeFactory);\n+    }\n+\n+    @Override\n+    public Statistic getStatistic() {\n+      return Statistics.of(200d, ImmutableList.<ImmutableBitSet>of());\n+    }\n+\n+    @Override\n+    public Schema.TableType getJdbcTableType() {\n+      return Schema.TableType.TABLE;\n+    }\n+  }\n }\n \n // End StreamTest.java",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-862] JdbcSchema gives NullPointerException on non-standard column type (Marc Prud'hommeaux)\n\nSolution is for SqlTypeName.getNameForJdbcType to fall back to ANY.\n\nClose apache/incubator-calcite#125",
        "commit": "https://github.com/apache/calcite/commit/f98ed96f041b615dca1560b7014d112a40e43d6e",
        "parent": "https://github.com/apache/calcite/commit/d19a9133f4941ef80195b8ef19fb7c21a1258abd",
        "bug_id": "calcite_40",
        "file": [
            {
                "sha": "64955741621fea1e8b66856b205bd53b82cfd5bd",
                "filename": "core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java",
                "blob_url": "https://github.com/apache/calcite/blob/f98ed96f041b615dca1560b7014d112a40e43d6e/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java",
                "raw_url": "https://github.com/apache/calcite/raw/f98ed96f041b615dca1560b7014d112a40e43d6e/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java",
                "status": "modified",
                "changes": 4,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java?ref=f98ed96f041b615dca1560b7014d112a40e43d6e",
                "patch": "@@ -287,7 +287,9 @@ RelProtoDataType getRelDataType(DatabaseMetaData metaData, String catalogName,\n \n   private RelDataType sqlType(RelDataTypeFactory typeFactory, int dataType,\n       int precision, int scale, String typeString) {\n-    SqlTypeName sqlTypeName = SqlTypeName.getNameForJdbcType(dataType);\n+    // Fall back to ANY if type is unknown\n+    final SqlTypeName sqlTypeName =\n+        Util.first(SqlTypeName.getNameForJdbcType(dataType), SqlTypeName.ANY);\n     switch (sqlTypeName) {\n     case ARRAY:\n       RelDataType component = null;",
                "deletions": 1
            },
            {
                "sha": "7d0c590d6d5553578a79fb104c73dfe92f66d580",
                "filename": "core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java",
                "blob_url": "https://github.com/apache/calcite/blob/f98ed96f041b615dca1560b7014d112a40e43d6e/core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java",
                "raw_url": "https://github.com/apache/calcite/raw/f98ed96f041b615dca1560b7014d112a40e43d6e/core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java?ref=f98ed96f041b615dca1560b7014d112a40e43d6e",
                "patch": "@@ -326,7 +326,7 @@ public SqlTypeFamily getFamily() {\n    * Gets the SqlTypeName corresponding to a JDBC type.\n    *\n    * @param jdbcType the JDBC type of interest\n-   * @return corresponding SqlTypeName\n+   * @return corresponding SqlTypeName, or null if the type is not known\n    */\n   public static SqlTypeName getNameForJdbcType(int jdbcType) {\n     return JDBC_TYPE_TO_NAME.get(jdbcType);",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1212] Fix NPE on some Cassandra projects",
        "commit": "https://github.com/apache/calcite/commit/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
        "parent": "https://github.com/apache/calcite/commit/26fddf2a641aebf943f18b7da8f81397955f4e59",
        "bug_id": "calcite_41",
        "file": [
            {
                "sha": "c7d0973d3972f36cba683682eff39595c88c1004",
                "filename": "cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraMethod.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraMethod.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraMethod.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraMethod.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -28,7 +28,7 @@\n  */\n public enum CassandraMethod {\n   CASSANDRA_QUERYABLE_QUERY(CassandraTable.CassandraQueryable.class, \"query\",\n-      List.class, List.class, List.class, String.class);\n+      List.class, List.class, List.class, List.class, String.class);\n \n   public final Method method;\n ",
                "deletions": 1
            },
            {
                "sha": "5e55e461ffb72b31bd1667eca95dd3e904da6e06",
                "filename": "cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java",
                "status": "modified",
                "changes": 15,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -28,8 +28,9 @@\n import org.apache.calcite.rex.RexNode;\n import org.apache.calcite.util.Pair;\n \n-import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Implementation of {@link org.apache.calcite.rel.core.Project}\n@@ -60,17 +61,11 @@ public void implement(Implementor implementor) {\n         new CassandraRules.RexToCassandraTranslator(\n             (JavaTypeFactory) getCluster().getTypeFactory(),\n             CassandraRules.cassandraFieldNames(getInput().getRowType()));\n-    final List<String> fields = new ArrayList<String>();\n+    final Map<String, String> fields = new LinkedHashMap<String, String>();\n     for (Pair<RexNode, String> pair : getNamedProjects()) {\n       final String name = pair.right;\n-      final String expr = pair.left.accept(translator);\n-\n-      // Alias the field if necessary\n-      if (name.equals(expr)) {\n-        fields.add(name);\n-      } else {\n-        fields.add(name + \" AS \" + expr);\n-      }\n+      final String originalName = pair.left.accept(translator);\n+      fields.put(originalName, name);\n     }\n     implementor.add(fields, null);\n   }",
                "deletions": 10
            },
            {
                "sha": "0191fd06b298efb14e4ee840df78ae6663e5071f",
                "filename": "cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRel.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRel.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRel.java",
                "status": "modified",
                "changes": 8,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRel.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -21,7 +21,9 @@\n import org.apache.calcite.rel.RelNode;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Relational expression that uses Cassandra calling convention.\n@@ -35,7 +37,7 @@\n   /** Callback for the implementation process that converts a tree of\n    * {@link CassandraRel} nodes into a CQL query. */\n   class Implementor {\n-    final List<String> selectFields = new ArrayList<String>();\n+    final Map<String, String> selectFields = new LinkedHashMap<String, String>();\n     final List<String> whereClause = new ArrayList<String>();\n     String limitValue = null;\n     final List<String> order = new ArrayList<String>();\n@@ -48,9 +50,9 @@\n      * @param fields New fields to be projected from a query\n      * @param predicates New predicates to be applied to the query\n      */\n-    public void add(List<String> fields, List<String> predicates) {\n+    public void add(Map<String, String> fields, List<String> predicates) {\n       if (fields != null) {\n-        selectFields.addAll(fields);\n+        selectFields.putAll(fields);\n       }\n       if (predicates != null) {\n         whereClause.addAll(predicates);",
                "deletions": 3
            },
            {
                "sha": "0e0bcb2438b93ec2be85fa3e264eccc29b249d5f",
                "filename": "cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java",
                "status": "modified",
                "changes": 11,
                "additions": 11,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -249,6 +249,17 @@ private CassandraProjectRule() {\n       super(LogicalProject.class, \"CassandraProjectRule\");\n     }\n \n+    @Override public boolean matches(RelOptRuleCall call) {\n+      LogicalProject project = call.rel(0);\n+      for (RexNode e : project.getProjects()) {\n+        if (!(e instanceof RexInputRef)) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n     public RelNode convert(RelNode rel) {\n       final LogicalProject project = (LogicalProject) rel;\n       final RelTraitSet traitSet = project.getTraitSet().replace(out);",
                "deletions": 0
            },
            {
                "sha": "c786dea45ecdcdde678ad76a07c2afef44f6fddf",
                "filename": "cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java",
                "status": "modified",
                "changes": 63,
                "additions": 48,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -22,6 +22,7 @@\n import org.apache.calcite.linq4j.Enumerator;\n import org.apache.calcite.linq4j.QueryProvider;\n import org.apache.calcite.linq4j.Queryable;\n+import org.apache.calcite.linq4j.function.Function1;\n import org.apache.calcite.plan.RelOptCluster;\n import org.apache.calcite.plan.RelOptTable;\n import org.apache.calcite.rel.RelFieldCollation;\n@@ -42,8 +43,8 @@\n import com.datastax.driver.core.ResultSet;\n import com.datastax.driver.core.Session;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n \n@@ -97,6 +98,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n \n   public Enumerable<Object> query(final Session session) {\n     return query(session, Collections.<Map.Entry<String, Class>>emptyList(),\n+        Collections.<Map.Entry<String, String>>emptyList(),\n         Collections.<String>emptyList(), Collections.<String>emptyList(), null);\n   }\n \n@@ -108,27 +110,56 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n    * @return Enumerator of results\n    */\n   public Enumerable<Object> query(final Session session, List<Map.Entry<String, Class>> fields,\n-        List<String> predicates, List<String> order, String limit) {\n+        final List<Map.Entry<String, String>> selectFields, List<String> predicates,\n+        List<String> order, String limit) {\n     // Build the type of the resulting row based on the provided fields\n     final RelDataTypeFactory typeFactory =\n         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);\n     final RelDataTypeFactory.FieldInfoBuilder fieldInfo = typeFactory.builder();\n     final RelDataType rowType = protoRowType.apply(typeFactory);\n-    List<String> fieldNames = new ArrayList<String>();\n-    for (Map.Entry<String, Class> field : fields) {\n-      String fieldName = field.getKey();\n-      fieldNames.add(fieldName);\n-      SqlTypeName typeName = rowType.getField(fieldName, true, false).getType().getSqlTypeName();\n-      fieldInfo.add(fieldName, typeFactory.createSqlType(typeName)).nullable(true);\n+\n+    Function1<String, Void> addField = new Function1<String, Void>() {\n+      public Void apply(String fieldName) {\n+        SqlTypeName typeName = rowType.getField(fieldName, true, false).getType().getSqlTypeName();\n+        fieldInfo.add(fieldName, typeFactory.createSqlType(typeName)).nullable(true);\n+        return null;\n+      }\n+    };\n+\n+    if (selectFields.isEmpty()) {\n+      for (Map.Entry<String, Class> field : fields) {\n+        addField.apply(field.getKey());\n+      }\n+    } else {\n+      for (Map.Entry<String, String> field : selectFields) {\n+        addField.apply(field.getKey());\n+      }\n     }\n+\n     final RelProtoDataType resultRowType = RelDataTypeImpl.proto(fieldInfo.build());\n \n     // Construct the list of fields to project\n-    final String selectFields;\n-    if (fields.isEmpty()) {\n-      selectFields = \"*\";\n+    final String selectString;\n+    if (selectFields.isEmpty()) {\n+      selectString = \"*\";\n     } else {\n-      selectFields = Util.toString(fieldNames, \"\", \", \", \"\");\n+      selectString = Util.toString(new Iterable<String>() {\n+        public Iterator<String> iterator() {\n+          final Iterator<Map.Entry<String, String>> selectIterator =\n+              selectFields.iterator();\n+\n+          return new Iterator<String>() {\n+            public boolean hasNext() {\n+              return selectIterator.hasNext();\n+            }\n+\n+            public String next() {\n+              Map.Entry<String, String> entry = selectIterator.next();\n+              return entry.getKey() + \" AS \" + entry.getValue();\n+            }\n+          };\n+        }\n+      }, \"\", \", \", \"\");\n     }\n \n     // Combine all predicates conjunctively\n@@ -140,7 +171,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n \n     // Build and issue the query and return an Enumerator over the results\n     StringBuilder queryBuilder = new StringBuilder(\"SELECT \");\n-    queryBuilder.append(selectFields);\n+    queryBuilder.append(selectString);\n     queryBuilder.append(\" FROM \\\"\" + columnFamily + \"\\\"\");\n     queryBuilder.append(whereClause);\n     if (!order.isEmpty()) {\n@@ -202,8 +233,10 @@ private Session getSession() {\n      */\n     @SuppressWarnings(\"UnusedDeclaration\")\n     public Enumerable<Object> query(List<Map.Entry<String, Class>> fields,\n-        List<String> predicates, List<String> order, String limit) {\n-      return getTable().query(getSession(), fields, predicates, order, limit);\n+        List<Map.Entry<String, String>> selectFields, List<String> predicates,\n+        List<String> order, String limit) {\n+      return getTable().query(getSession(), fields, selectFields, predicates,\n+          order, limit);\n     }\n   }\n }",
                "deletions": 15
            },
            {
                "sha": "31bfdcc2913b92db80521fe97927a42f043a4bf9",
                "filename": "cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java",
                "status": "modified",
                "changes": 12,
                "additions": 11,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -43,7 +43,9 @@\n import com.google.common.collect.Lists;\n \n import java.util.AbstractList;\n+import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Relational expression representing a scan of a table in a Cassandra data source.\n@@ -92,6 +94,14 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n                       }\n                     }),\n                 Pair.class));\n+    List<Map.Entry<String, String>> selectList = new ArrayList<Map.Entry<String, String>>();\n+    for (Map.Entry<String, String> entry\n+            : Pair.zip(cassandraImplementor.selectFields.keySet(),\n+                cassandraImplementor.selectFields.values())) {\n+      selectList.add(entry);\n+    }\n+    final Expression selectFields =\n+        list.append(\"selectFields\", constantArrayList(selectList, Pair.class));\n     final Expression table =\n         list.append(\"table\",\n             cassandraImplementor.table.getExpression(\n@@ -109,7 +119,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n         list.append(\"enumerable\",\n             Expressions.call(table,\n                 CassandraMethod.CASSANDRA_QUERYABLE_QUERY.method, fields,\n-                predicates, order, limit));\n+                selectFields, predicates, order, limit));\n     if (CalcitePrepareImpl.DEBUG) {\n       System.out.println(\"Cassandra: \" + predicates);\n     }",
                "deletions": 1
            },
            {
                "sha": "e02e4974fb898f3fbef58a670f3b368ecdad13c3",
                "filename": "cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterIT.java",
                "blob_url": "https://github.com/apache/calcite/blob/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterIT.java",
                "raw_url": "https://github.com/apache/calcite/raw/6baa9c4bed1100012ebf4ef9547cbb077f2edaaf/cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterIT.java",
                "status": "modified",
                "changes": 17,
                "additions": 17,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterIT.java?ref=6baa9c4bed1100012ebf4ef9547cbb077f2edaaf",
                "patch": "@@ -111,6 +111,23 @@ protected boolean enabled() {\n                 + \"      CassandraFilter(condition=[=(CAST($0):VARCHAR(8) CHARACTER SET \\\"ISO-8859-1\\\" COLLATE \\\"ISO-8859-1$en_US$primary\\\", '!PUBLIC!')])\\n\");\n   }\n \n+  @Test public void testProjectAlias() {\n+    CalciteAssert.that()\n+        .enable(enabled())\n+        .with(TWISSANDRA)\n+        .query(\"select \\\"tweet_id\\\" as \\\"foo\\\" from \\\"userline\\\" \"\n+                + \"where \\\"username\\\" = '!PUBLIC!' limit 1\")\n+        .returns(\"foo=f3c329de-d05b-11e5-b58b-90e2ba530b12\\n\");\n+  }\n+\n+  @Test public void testProjectConstant() {\n+    CalciteAssert.that()\n+        .enable(enabled())\n+        .with(TWISSANDRA)\n+        .query(\"select 'foo' as \\\"bar\\\" from \\\"userline\\\" limit 1\")\n+        .returns(\"bar=foo\\n\");\n+  }\n+\n   @Test public void testLimit() {\n     CalciteAssert.that()\n         .enable(enabled())",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix a NPE.",
        "commit": "https://github.com/apache/calcite/commit/4d8fb0901782ee9cf59af51b989e879ce586beee",
        "parent": "https://github.com/apache/calcite/commit/ef2a54c8620751c56059dfb89e9b080ece516ef6",
        "bug_id": "calcite_42",
        "file": [
            {
                "sha": "8096eaf640369c3d5d16b97c6d810f8c67f814c4",
                "filename": "core/src/main/java/org/eigenbase/sql/type/SqlTypeExplicitPrecedenceList.java",
                "blob_url": "https://github.com/apache/calcite/blob/4d8fb0901782ee9cf59af51b989e879ce586beee/core/src/main/java/org/eigenbase/sql/type/SqlTypeExplicitPrecedenceList.java",
                "raw_url": "https://github.com/apache/calcite/raw/4d8fb0901782ee9cf59af51b989e879ce586beee/core/src/main/java/org/eigenbase/sql/type/SqlTypeExplicitPrecedenceList.java",
                "status": "modified",
                "changes": 11,
                "additions": 9,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/eigenbase/sql/type/SqlTypeExplicitPrecedenceList.java?ref=4d8fb0901782ee9cf59af51b989e879ce586beee",
                "patch": "@@ -22,6 +22,8 @@\n import org.eigenbase.reltype.*;\n import org.eigenbase.util.Util;\n \n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n \n@@ -53,6 +55,10 @@\n           SqlTypeName.FLOAT,\n           SqlTypeName.DOUBLE);\n \n+  private static final List<SqlTypeName> COMPACT_NUMERIC_TYPES =\n+      ImmutableList.copyOf(\n+          Iterables.filter(NUMERIC_TYPES, Predicates.notNull()));\n+\n   /**\n    * Map from SqlTypeName to corresponding precedence list.\n    *\n@@ -100,8 +106,9 @@ private static SqlTypeExplicitPrecedenceList list(SqlTypeName... array) {\n   }\n \n   private static SqlTypeExplicitPrecedenceList numeric(SqlTypeName typeName) {\n-    int i = getListPosition(typeName, NUMERIC_TYPES);\n-    return new SqlTypeExplicitPrecedenceList(Util.skip(NUMERIC_TYPES, i));\n+    int i = getListPosition(typeName, COMPACT_NUMERIC_TYPES);\n+    return new SqlTypeExplicitPrecedenceList(\n+        Util.skip(COMPACT_NUMERIC_TYPES, i));\n   }\n \n   // implement RelDataTypePrecedenceList",
                "deletions": 2
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-1770] Druid adapter: CAST(NULL AS ...) gives NPE (Slim Bouguerra)\n\nAvoid pushing literal NULL values to Druid.\n\nClose apache/calcite#448",
        "commit": "https://github.com/apache/calcite/commit/ea994131cd6d109ff7edf5e61754104e2b8619be",
        "parent": "https://github.com/apache/calcite/commit/e046be23d7364e16648ade5240ad948a04cc814b",
        "bug_id": "calcite_43",
        "file": [
            {
                "sha": "c25262ed988a9aef1ed7802539a39551de8716e8",
                "filename": "druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java",
                "blob_url": "https://github.com/apache/calcite/blob/ea994131cd6d109ff7edf5e61754104e2b8619be/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java",
                "raw_url": "https://github.com/apache/calcite/raw/ea994131cd6d109ff7edf5e61754104e2b8619be/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java",
                "status": "modified",
                "changes": 7,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java?ref=ea994131cd6d109ff7edf5e61754104e2b8619be",
                "patch": "@@ -207,8 +207,9 @@ boolean isValidFilter(RexNode e) {\n   boolean isValidFilter(RexNode e, boolean boundedComparator) {\n     switch (e.getKind()) {\n     case INPUT_REF:\n-    case LITERAL:\n       return true;\n+    case LITERAL:\n+      return ((RexLiteral) e).getValue() != null;\n     case AND:\n     case OR:\n     case NOT:\n@@ -959,10 +960,6 @@ public String getQueryString(String pagingIdentifier, int offset) {\n       case CAST:\n         return tr(e, 0, set);\n       case LITERAL:\n-        if (((RexLiteral) e).getValue3() == null) {\n-          // Druid considers null is equivalent to empty.\n-          return \"\";\n-        }\n         return ((RexLiteral) e).getValue3().toString();\n       case FLOOR:\n       case EXTRACT:",
                "deletions": 5
            },
            {
                "sha": "2b639c84fef03c94433ce22f84a9765bb0030aa1",
                "filename": "druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java",
                "blob_url": "https://github.com/apache/calcite/blob/ea994131cd6d109ff7edf5e61754104e2b8619be/druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java",
                "raw_url": "https://github.com/apache/calcite/raw/ea994131cd6d109ff7edf5e61754104e2b8619be/druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java",
                "status": "modified",
                "changes": 8,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java?ref=ea994131cd6d109ff7edf5e61754104e2b8619be",
                "patch": "@@ -2097,8 +2097,12 @@ public Void apply(ResultSet resultSet) {\n         + \"from \\\"foodmart\\\"\\n\"\n         + \"where \\\"product_id\\\" = cast(NULL as varchar)\\n\"\n         + \"group by \\\"product_id\\\"\";\n-    String druidQuery = \"'filter':{'type':'selector','dimension':'product_id','value':''}\";\n-    sql(sql).queryContains(druidChecker(druidQuery));\n+    final String plan = \"PLAN=EnumerableInterpreter\\n\"\n+        + \"  BindableAggregate(group=[{0}])\\n\"\n+        + \"    BindableFilter(condition=[=($0, null)])\\n\"\n+        + \"      DruidQuery(table=[[foodmart, foodmart]], \"\n+        + \"intervals=[[1900-01-09T00:00:00.000/2992-01-10T00:00:00.000]], projects=[[$1]])\";\n+    sql(sql).explainContains(plan);\n   }\n \n   @Test public void testFalseFilter() {",
                "deletions": 2
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix traits in MongoDB adapter, and NPE in JdbcTest",
        "commit": "https://github.com/apache/calcite/commit/65774b056bcd277634e0fc6f678806f15ba05e83",
        "parent": "https://github.com/apache/calcite/commit/e48c7627c162726f42e786a0e0b8c3042315491a",
        "bug_id": "calcite_44",
        "file": [
            {
                "sha": "0f0e1627f9a4fecc4a4e4d3d999bb1d632efbf43",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/65774b056bcd277634e0fc6f678806f15ba05e83/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/65774b056bcd277634e0fc6f678806f15ba05e83/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "status": "modified",
                "changes": 12,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcTest.java?ref=65774b056bcd277634e0fc6f678806f15ba05e83",
                "patch": "@@ -192,13 +192,17 @@\n       + \"   ]\\n\"\n       + \"}\";\n \n+  private static final ConnectionSpec SCOTT =\n+      Util.first(CalciteAssert.DB.scott,\n+          CalciteAssert.DatabaseInstance.HSQLDB.scott);\n+\n   public static final String SCOTT_SCHEMA = \"     {\\n\"\n       + \"       type: 'jdbc',\\n\"\n       + \"       name: 'SCOTT',\\n\"\n-      + \"       jdbcDriver: '\" + CalciteAssert.DB.scott.driver + \"',\\n\"\n-      + \"       jdbcUser: '\" + CalciteAssert.DB.scott.username + \"',\\n\"\n-      + \"       jdbcPassword: '\" + CalciteAssert.DB.scott.password + \"',\\n\"\n-      + \"       jdbcUrl: '\" + CalciteAssert.DB.scott.url + \"',\\n\"\n+      + \"       jdbcDriver: '\" + SCOTT.driver + \"',\\n\"\n+      + \"       jdbcUser: '\" + SCOTT.username + \"',\\n\"\n+      + \"       jdbcPassword: '\" + SCOTT.password + \"',\\n\"\n+      + \"       jdbcUrl: '\" + SCOTT.url + \"',\\n\"\n       + \"       jdbcCatalog: null,\\n\"\n       + \"       jdbcSchema: 'SCOTT'\\n\"\n       + \"     }\\n\";",
                "deletions": 4
            },
            {
                "sha": "0249cce81aacf8a34a75a71d1bcf7d87578f3bb1",
                "filename": "mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java",
                "blob_url": "https://github.com/apache/calcite/blob/65774b056bcd277634e0fc6f678806f15ba05e83/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java",
                "raw_url": "https://github.com/apache/calcite/raw/65774b056bcd277634e0fc6f678806f15ba05e83/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java",
                "status": "modified",
                "changes": 4,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java?ref=65774b056bcd277634e0fc6f678806f15ba05e83",
                "patch": "@@ -239,7 +239,7 @@ public RelNode convert(RelNode rel) {\n       return new MongoFilter(\n           rel.getCluster(),\n           traitSet,\n-          convert(filter.getInput(), traitSet),\n+          convert(filter.getInput(), out),\n           filter.getCondition());\n     }\n   }\n@@ -260,7 +260,7 @@ public RelNode convert(RelNode rel) {\n       final LogicalProject project = (LogicalProject) rel;\n       final RelTraitSet traitSet = project.getTraitSet().replace(out);\n       return new MongoProject(project.getCluster(), traitSet,\n-          convert(project.getInput(), traitSet), project.getProjects(),\n+          convert(project.getInput(), out), project.getProjects(),\n           project.getRowType());\n     }\n   }",
                "deletions": 2
            },
            {
                "sha": "bc9a9dcbbac7bdd855cbebba8bfd8b1ac10baf8a",
                "filename": "mongodb/src/test/java/org/apache/calcite/test/MongoAdapterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/65774b056bcd277634e0fc6f678806f15ba05e83/mongodb/src/test/java/org/apache/calcite/test/MongoAdapterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/65774b056bcd277634e0fc6f678806f15ba05e83/mongodb/src/test/java/org/apache/calcite/test/MongoAdapterTest.java",
                "status": "modified",
                "changes": 19,
                "additions": 14,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/mongodb/src/test/java/org/apache/calcite/test/MongoAdapterTest.java?ref=65774b056bcd277634e0fc6f678806f15ba05e83",
                "patch": "@@ -530,8 +530,15 @@ public Void apply(ResultSet resultSet) {\n             + \" min(pop) as min_pop, max(pop) as max_pop, sum(pop) as sum_pop\\n\"\n             + \"from zips group by state\")\n         .limit(2)\n-        .returns(\"C=659; STATE=WV; MIN_POP=0; MAX_POP=70185; SUM_POP=1793477\\n\"\n-            + \"C=484; STATE=WA; MIN_POP=2; MAX_POP=50515; SUM_POP=4866692\\n\");\n+        .returns(\"C=195; STATE=AK; MIN_POP=0; MAX_POP=32383; SUM_POP=544698\\n\"\n+            + \"C=567; STATE=AL; MIN_POP=0; MAX_POP=44165; SUM_POP=4040587\\n\")\n+        .queryContains(\n+            mongoChecker(\n+                \"{$project: {STATE: '$state', POP: '$pop'}}\",\n+                \"{$group: {_id: '$STATE', C: {$sum: 1}, MIN_POP: {$min: '$POP'}, MAX_POP: {$max: '$POP'}, SUM_POP: {$sum: '$POP'}}}\",\n+                \"{$project: {STATE: '$_id', C: '$C', MIN_POP: '$MIN_POP', MAX_POP: '$MAX_POP', SUM_POP: '$SUM_POP'}}\",\n+                \"{$project: {C: 1, STATE: 1, MIN_POP: 1, MAX_POP: 1, SUM_POP: 1}}\",\n+                \"{$sort: {STATE: 1}}\"));\n   }\n \n   @Test public void testGroupComposite() {\n@@ -547,9 +554,9 @@ public Void apply(ResultSet resultSet) {\n                 \"{$project: {STATE: '$state', CITY: '$city'}}\",\n                 \"{$group: {_id: {STATE: '$STATE', CITY: '$CITY'}, C: {$sum: 1}}}\",\n                 \"{$project: {_id: 0, STATE: '$_id.STATE', CITY: '$_id.CITY', C: '$C'}}\",\n-                \"{$project: {C: 1, STATE: 1, CITY: 1}}\",\n                 \"{$sort: {C: -1}}\",\n-                \"{$limit: 2}\"));\n+                \"{$limit: 2}\",\n+                \"{$project: {C: 1, STATE: 1, CITY: 1}}\"));\n   }\n \n   @Test public void testDistinctCount() {\n@@ -615,7 +622,9 @@ public Void apply(ResultSet resultSet) {\n             + \"STATE=AL; CITY=ADAMSVILLE; ZERO=0\\n\")\n         .queryContains(\n             mongoChecker(\n-                \"{$project: {STATE: '$state', CITY: '$city', ZERO: {$ifNull: [null, 0]}}}\"));\n+                \"{$project: {CITY: '$city', STATE: '$state'}}\",\n+                \"{$sort: {STATE: 1, CITY: 1}}\",\n+                \"{$project: {STATE: 1, CITY: 1, ZERO: {$ifNull: [null, 0]}}}\"));\n   }\n \n   @Test public void testFilter() {",
                "deletions": 5
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Add test case for [DRILL-4407] GROUP BY subquery causes Java NPE",
        "commit": "https://github.com/apache/calcite/commit/0ad58ed624dfad43bfcd26881588a9d3482397c1",
        "parent": "https://github.com/apache/calcite/commit/3a54e54fadfcf383693555ac753e88edb8f3f5d6",
        "bug_id": "calcite_45",
        "file": [
            {
                "sha": "d4f3a1009807b7d190dd78f250940cc76721945c",
                "filename": "core/src/test/resources/sql/subquery.iq",
                "blob_url": "https://github.com/apache/calcite/blob/0ad58ed624dfad43bfcd26881588a9d3482397c1/core/src/test/resources/sql/subquery.iq",
                "raw_url": "https://github.com/apache/calcite/raw/0ad58ed624dfad43bfcd26881588a9d3482397c1/core/src/test/resources/sql/subquery.iq",
                "status": "modified",
                "changes": 11,
                "additions": 11,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/sql/subquery.iq?ref=0ad58ed624dfad43bfcd26881588a9d3482397c1",
                "patch": "@@ -274,6 +274,17 @@ GROUP BY emp.deptno;\n \n !ok\n \n+# [DRILL-4407] Group by subquery causes Java NPE\n+select count(*) as c\n+from \"scott\".emp\n+group by (select deptno from \"scott\".emp where empno = 10);\n+ C\n+----\n+ 14\n+(1 row)\n+\n+!ok\n+\n !if (fixed.calcite1045) {\n # Correlated IN sub-query in WHERE clause of JOIN\n select empno from \"scott\".emp as e",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-929] Calls to AbstractRelNode may result in NPE\n\nClose apache/incubator-calcite#158",
        "commit": "https://github.com/apache/calcite/commit/ee0e824d1246bb3ac4da3bfd2757d390f8ca6583",
        "parent": "https://github.com/apache/calcite/commit/a6f65dc97ac578c886544b961cb4db40e90bcccf",
        "bug_id": "calcite_46",
        "file": [
            {
                "sha": "0e7facdde8f4b91dcec8fd6a845aa2a711ca3554",
                "filename": "core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java",
                "blob_url": "https://github.com/apache/calcite/blob/ee0e824d1246bb3ac4da3bfd2757d390f8ca6583/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java",
                "raw_url": "https://github.com/apache/calcite/raw/ee0e824d1246bb3ac4da3bfd2757d390f8ca6583/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java",
                "status": "modified",
                "changes": 4,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java?ref=ee0e824d1246bb3ac4da3bfd2757d390f8ca6583",
                "patch": "@@ -159,11 +159,11 @@ public String getCorrelVariable() {\n   }\n \n   public boolean isDistinct() {\n-    return RelMetadataQuery.areRowsUnique(this);\n+    return Boolean.TRUE.equals(RelMetadataQuery.areRowsUnique(this));\n   }\n \n   public boolean isKey(ImmutableBitSet columns) {\n-    return RelMetadataQuery.areColumnsUnique(this, columns);\n+    return Boolean.TRUE.equals(RelMetadataQuery.areColumnsUnique(this, columns));\n   }\n \n   public int getId() {",
                "deletions": 2
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix NPE in CachingRelMetadataProvider if arg is null.",
        "commit": "https://github.com/apache/calcite/commit/5a6b465b5b67cad20d309abe5d570e5311a03cbb",
        "parent": "https://github.com/apache/calcite/commit/8b0a22ee178b5f96cd2982ba75e8b36a2eb2ed5f",
        "bug_id": "calcite_47",
        "file": [
            {
                "sha": "e3b8f23b8a2f1eaa194b9632af92694ca379322d",
                "filename": "core/src/main/java/org/eigenbase/rel/metadata/CachingRelMetadataProvider.java",
                "blob_url": "https://github.com/apache/calcite/blob/5a6b465b5b67cad20d309abe5d570e5311a03cbb/core/src/main/java/org/eigenbase/rel/metadata/CachingRelMetadataProvider.java",
                "raw_url": "https://github.com/apache/calcite/raw/5a6b465b5b67cad20d309abe5d570e5311a03cbb/core/src/main/java/org/eigenbase/rel/metadata/CachingRelMetadataProvider.java",
                "status": "modified",
                "changes": 12,
                "additions": 11,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/eigenbase/rel/metadata/CachingRelMetadataProvider.java?ref=5a6b465b5b67cad20d309abe5d570e5311a03cbb",
                "patch": "@@ -39,6 +39,13 @@\n \n   private final RelOptPlanner planner;\n \n+  private static final Object NULL_SENTINEL = new Object() {\n+    @Override\n+    public String toString() {\n+      return \"{null}\";\n+    }\n+  };\n+\n   //~ Constructors -----------------------------------------------------------\n \n   public CachingRelMetadataProvider(\n@@ -93,7 +100,10 @@ public Object invoke(Object proxy, Method method, Object[] args)\n       builder.add(method);\n       builder.add(metadata.rel());\n       if (args != null) {\n-        builder.add(args);\n+        for (Object arg : args) {\n+          // Replace null values because ImmutableList does not allow them.\n+          builder.add(arg == null ? NULL_SENTINEL : arg);\n+        }\n       }\n       List<Object> key = builder.build();\n ",
                "deletions": 1
            },
            {
                "sha": "7b587fe1174b77eb63ac0db775843352bd628efc",
                "filename": "core/src/test/java/org/eigenbase/test/RelMetadataTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/5a6b465b5b67cad20d309abe5d570e5311a03cbb/core/src/test/java/org/eigenbase/test/RelMetadataTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/5a6b465b5b67cad20d309abe5d570e5311a03cbb/core/src/test/java/org/eigenbase/test/RelMetadataTest.java",
                "status": "modified",
                "changes": 24,
                "additions": 23,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/eigenbase/test/RelMetadataTest.java?ref=5a6b465b5b67cad20d309abe5d570e5311a03cbb",
                "patch": "@@ -27,6 +27,8 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n \n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.Matcher;\n import org.junit.Ignore;\n import org.junit.Test;\n \n@@ -62,6 +64,10 @@\n \n   //~ Methods ----------------------------------------------------------------\n \n+  private static Matcher<? super Number> nearTo(Number v, Number epsilon) {\n+    return CoreMatchers.equalTo(v); // TODO: use epsilon\n+  }\n+\n   // ----------------------------------------------------------------------\n   // Tests for getPercentageOriginalRows\n   // ----------------------------------------------------------------------\n@@ -476,7 +482,7 @@ private void checkRelSelectivity(\n     RelNode rel =\n         convertSql(\n             \"select * from (select * from emp union all select * from emp) \"\n-            + \"where deptno = 10\");\n+                + \"where deptno = 10\");\n     checkRelSelectivity(rel, DEFAULT_EQUAL_SELECTIVITY);\n   }\n \n@@ -490,6 +496,22 @@ private void checkRelSelectivity(\n         DEFAULT_COMP_SELECTIVITY * DEFAULT_EQUAL_SELECTIVITY);\n   }\n \n+  /** Checks that we can cache a metadata request that includes a null\n+   * argument. */\n+  @Test public void testSelectivityAggCached() {\n+    RelNode rel =\n+        convertSql(\n+            \"select deptno, count(*) from emp where deptno > 10 \"\n+            + \"group by deptno having count(*) = 0\");\n+    rel.getCluster().setMetadataProvider(\n+        new CachingRelMetadataProvider(\n+            rel.getCluster().getMetadataProvider(),\n+            rel.getCluster().getPlanner()));\n+    Double result = RelMetadataQuery.getSelectivity(rel, null);\n+    assertThat(result,\n+        nearTo(DEFAULT_COMP_SELECTIVITY * DEFAULT_EQUAL_SELECTIVITY, EPSILON));\n+  }\n+\n   @Test public void testDistinctRowCountTable() {\n     // no unique key information is available so return null\n     RelNode rel = convertSql(\"select * from emp where deptno = 10\");",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-821] Frameworks gives NPE when FrameworkConfig has no default schema",
        "commit": "https://github.com/apache/calcite/commit/1580bd0fec62d836c9870edc339b0ab99d909cad",
        "parent": "https://github.com/apache/calcite/commit/2376ae4a876b421ee19c2b2a05a6bd1d306e442b",
        "bug_id": "calcite_48",
        "file": [
            {
                "sha": "f3ebe1212b0ed5517660f8ba4f71061157956668",
                "filename": "core/src/main/java/org/apache/calcite/tools/Frameworks.java",
                "blob_url": "https://github.com/apache/calcite/blob/1580bd0fec62d836c9870edc339b0ab99d909cad/core/src/main/java/org/apache/calcite/tools/Frameworks.java",
                "raw_url": "https://github.com/apache/calcite/raw/1580bd0fec62d836c9870edc339b0ab99d909cad/core/src/main/java/org/apache/calcite/tools/Frameworks.java",
                "status": "modified",
                "changes": 4,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/tools/Frameworks.java?ref=1580bd0fec62d836c9870edc339b0ab99d909cad",
                "patch": "@@ -33,6 +33,7 @@\n import org.apache.calcite.sql.parser.SqlParser;\n import org.apache.calcite.sql2rel.SqlRexConvertletTable;\n import org.apache.calcite.sql2rel.StandardConvertletTable;\n+import org.apache.calcite.util.Util;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n@@ -107,7 +108,8 @@ public abstract R apply(RelOptCluster cluster, RelOptSchema relOptSchema,\n           public R apply(RelOptCluster cluster, RelOptSchema relOptSchema,\n               SchemaPlus rootSchema, CalciteServerStatement statement) {\n             final CalciteSchema schema =\n-                CalciteSchema.from(config.getDefaultSchema());\n+                CalciteSchema.from(\n+                    Util.first(config.getDefaultSchema(), rootSchema));\n             return action.apply(cluster, relOptSchema, schema.root().plus());\n           }\n         });",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-657] NullPointerException when executing JdbcAggregate implement method (Yuri Au Yong)\n\nAlso, use a pool for jdbc:hsqldb:mem connections, so that tests run in parallel don't use the same database. (Julian Hyde)",
        "commit": "https://github.com/apache/calcite/commit/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5",
        "parent": "https://github.com/apache/calcite/commit/30ae0513c1c7e9cfb14a8a6b0e60cc37ec499ce7",
        "bug_id": "calcite_49",
        "file": [
            {
                "sha": "d519029cf470ece2dd3f71013f33cb4fea7ba158",
                "filename": "core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java",
                "blob_url": "https://github.com/apache/calcite/blob/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java",
                "raw_url": "https://github.com/apache/calcite/raw/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java?ref=241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5",
                "patch": "@@ -706,7 +706,7 @@ public JdbcAggregate(\n         groupByList.add(field);\n       }\n       for (AggregateCall aggCall : aggCalls) {\n-        addSelect(selectList, builder.context.toSql(aggCall), rowType);\n+        addSelect(selectList, builder.context.toSql(aggCall), getRowType());\n       }\n       builder.setSelect(new SqlNodeList(selectList, POS));\n       if (!groupByList.isEmpty() || aggCalls.isEmpty()) {",
                "deletions": 1
            },
            {
                "sha": "e7faeef804a5b418f49bdf53c8bce29c4d40caf0",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5/core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5/core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java",
                "status": "modified",
                "changes": 57,
                "additions": 57,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java?ref=241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5",
                "patch": "@@ -16,8 +16,19 @@\n  */\n package org.apache.calcite.test;\n \n+import org.hsqldb.jdbcDriver;\n import org.junit.Test;\n \n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+\n /**\n  * Tests for the {@code org.apache.calcite.adapter.jdbc} package.\n  */\n@@ -274,6 +285,52 @@\n             + \"FROM \\\"SCOTT\\\".\\\"EMP\\\"\\n\"\n             + \"WHERE CAST(\\\"DEPTNO\\\" AS INTEGER) = 20) AS \\\"t1\\\" ON \\\"t\\\".\\\"DEPTNO\\\" = \\\"t1\\\".\\\"DEPTNO\\\"\");\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-657\">[CALCITE-657]\n+   * NullPointerException when executing JdbcAggregate implement method</a>. */\n+  @Test public void testJdbcAggregate() throws Exception {\n+    final String url = MultiJdbcSchemaJoinTest.TempDb.INSTANCE.getUrl();\n+    Connection baseConnection = DriverManager.getConnection(url);\n+    Statement baseStmt = baseConnection.createStatement();\n+    baseStmt.execute(\"CREATE TABLE T2 (\\n\"\n+            + \"ID INTEGER,\\n\"\n+            + \"VALS INTEGER)\");\n+    baseStmt.execute(\"INSERT INTO T2 VALUES (1, 1)\");\n+    baseStmt.execute(\"INSERT INTO T2 VALUES (2, null)\");\n+    baseStmt.close();\n+    baseConnection.commit();\n+\n+    Properties info = new Properties();\n+    info.put(\"model\",\n+        \"inline:\"\n+            + \"{\\n\"\n+            + \"  version: '1.0',\\n\"\n+            + \"  defaultSchema: 'BASEJDBC',\\n\"\n+            + \"  schemas: [\\n\"\n+            + \"     {\\n\"\n+            + \"       type: 'jdbc',\\n\"\n+            + \"       name: 'BASEJDBC',\\n\"\n+            + \"       jdbcDriver: '\" + jdbcDriver.class.getName() + \"',\\n\"\n+            + \"       jdbcUrl: '\" + url + \"',\\n\"\n+            + \"       jdbcCatalog: null,\\n\"\n+            + \"       jdbcSchema: null\\n\"\n+            + \"     }\\n\"\n+            + \"  ]\\n\"\n+            + \"}\");\n+\n+    final Connection calciteConnection =\n+        DriverManager.getConnection(\"jdbc:calcite:\", info);\n+    ResultSet rs = calciteConnection\n+        .prepareStatement(\"select 10 * count(ID) from t2\").executeQuery();\n+\n+    assertThat(rs.next(), is(true));\n+    assertThat((Long) rs.getObject(1), equalTo(20L));\n+    assertThat(rs.next(), is(false));\n+\n+    rs.close();\n+    calciteConnection.close();\n+  }\n }\n \n // End JdbcAdapterTest.java",
                "deletions": 0
            },
            {
                "sha": "730c672886b1efdf63c334cbeabb63a36ad7f697",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "status": "modified",
                "changes": 6,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcTest.java?ref=241f77e256a1ee7df8c9bd5c73b025d45b7e6cb5",
                "patch": "@@ -1845,8 +1845,8 @@ private static void checkJoinNWay(int n) {\n \n   /** Tests accessing a column in a JDBC source whose type is ARRAY. */\n   @Test public void testArray() throws Exception {\n-    String hsqldbMemUrl = \"jdbc:hsqldb:mem:.\";\n-    Connection baseConnection = DriverManager.getConnection(hsqldbMemUrl);\n+    final String url = MultiJdbcSchemaJoinTest.TempDb.INSTANCE.getUrl();\n+    Connection baseConnection = DriverManager.getConnection(url);\n     Statement baseStmt = baseConnection.createStatement();\n     baseStmt.execute(\"CREATE TABLE ARR_TABLE (\\n\"\n         + \"ID INTEGER,\\n\"\n@@ -1872,7 +1872,7 @@ private static void checkJoinNWay(int n) {\n             + \"       type: 'jdbc',\\n\"\n             + \"       name: 'BASEJDBC',\\n\"\n             + \"       jdbcDriver: '\" + jdbcDriver.class.getName() + \"',\\n\"\n-            + \"       jdbcUrl: '\" + hsqldbMemUrl + \"',\\n\"\n+            + \"       jdbcUrl: '\" + url + \"',\\n\"\n             + \"       jdbcCatalog: null,\\n\"\n             + \"       jdbcSchema: null\\n\"\n             + \"     }\\n\"",
                "deletions": 3
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Test case and NPE patch for [CALCITE-661] Remote fetch in Calcite JDBC driver (Yeong Wei)",
        "commit": "https://github.com/apache/calcite/commit/88a6c5bdd2437eecabe05181c892957ff6b1ac5c",
        "parent": "https://github.com/apache/calcite/commit/ca871d3776646e94e6b1a1d61692c6d80777952f",
        "bug_id": "calcite_50",
        "file": [
            {
                "sha": "455e55e21f7017a3b9ca21004807a0d60ab13de2",
                "filename": "core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java",
                "blob_url": "https://github.com/apache/calcite/blob/88a6c5bdd2437eecabe05181c892957ff6b1ac5c/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java",
                "raw_url": "https://github.com/apache/calcite/raw/88a6c5bdd2437eecabe05181c892957ff6b1ac5c/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java",
                "status": "modified",
                "changes": 5,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java?ref=88a6c5bdd2437eecabe05181c892957ff6b1ac5c",
                "patch": "@@ -471,8 +471,9 @@ public MetaResultSet getTableTypes() {\n     final StatementHandle h = createStatement(ch);\n     final CalciteConnectionImpl calciteConnection = getConnection();\n     CalciteServerStatement statement = calciteConnection.server.getStatement(h);\n-    calciteConnection.parseQuery(sql, statement.createPrepareContext(),\n-        maxRowCount);\n+    h.signature =\n+        calciteConnection.parseQuery(sql, statement.createPrepareContext(),\n+            maxRowCount);\n     return h;\n   }\n ",
                "deletions": 2
            },
            {
                "sha": "c19216a48eeba9dfd65ec4603384a759f01d6320",
                "filename": "core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/88a6c5bdd2437eecabe05181c892957ff6b1ac5c/core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/88a6c5bdd2437eecabe05181c892957ff6b1ac5c/core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java",
                "status": "modified",
                "changes": 12,
                "additions": 12,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java?ref=88a6c5bdd2437eecabe05181c892957ff6b1ac5c",
                "patch": "@@ -408,6 +408,18 @@ public void testAvaticaStatementException() throws Exception {\n     remoteConnection.createStatement().getMoreResults();\n   }\n \n+  @Test public void testRemotePreparedStatement() throws Exception {\n+    final PreparedStatement preparedStatement =\n+        remoteConnection.prepareStatement(\"select * from \\\"hr\\\".\\\"emps\\\"\");\n+    ResultSet resultSet = preparedStatement.executeQuery();\n+    int count = 0;\n+    while (resultSet.next()) {\n+      count += 1;\n+    }\n+    // TODO: implement remote fetch\n+    //assertTrue(count > 0);\n+  }\n+\n   /** A bunch of sample values of various types. */\n   private static final List<Object> SAMPLE_VALUES =\n       ImmutableList.<Object>of(false, true,",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix NPE using TRIM function with JDBC.\n\nSymbols have a null family.",
        "commit": "https://github.com/apache/calcite/commit/92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c",
        "parent": "https://github.com/apache/calcite/commit/4c47a15cd156ef6b6aadbda63a896b065b44498c",
        "bug_id": "calcite_51",
        "file": [
            {
                "sha": "b565a496a344e2fad30a98e1849cd764b0b2c2d5",
                "filename": "core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java",
                "blob_url": "https://github.com/apache/calcite/blob/92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c/core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java",
                "raw_url": "https://github.com/apache/calcite/raw/92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c/core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java",
                "status": "modified",
                "changes": 5,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java?ref=92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c",
                "patch": "@@ -30,6 +30,7 @@\n import org.eigenbase.sql.fun.SqlStdOperatorTable;\n import org.eigenbase.sql.parser.SqlParserPos;\n import org.eigenbase.sql.type.BasicSqlType;\n+import org.eigenbase.sql.type.SqlTypeName;\n import org.eigenbase.sql.validate.SqlValidatorUtil;\n import org.eigenbase.util.Pair;\n import org.eigenbase.util.Util;\n@@ -117,6 +118,10 @@ SqlNode toSql(RexProgram program, RexNode rex) {\n \n       case LITERAL:\n         final RexLiteral literal = (RexLiteral) rex;\n+        if (literal.getTypeName().equals(SqlTypeName.SYMBOL)) {\n+          return SqlLiteral\n+              .createSymbol((SqlLiteral.SqlSymbol) literal.getValue(), POS);\n+        }\n         switch (literal.getTypeName().getFamily()) {\n         case CHARACTER:\n           return SqlLiteral.createCharString((String) literal.getValue2(), POS);",
                "deletions": 0
            },
            {
                "sha": "c117345b55f9eacb338ce118890dcd5cbd64578f",
                "filename": "core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c/core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c/core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java",
                "status": "modified",
                "changes": 14,
                "additions": 14,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java?ref=92cb0b67a21cd9bdd6ca622e416ef0d6c4a03e3c",
                "patch": "@@ -2183,6 +2183,20 @@ private void checkNullableTimestamp(OptiqAssert.Config config) {\n     predicate(\"\\\"name\\\" not in ('a', 'b', null) and \\\"name\\\" is not null\");\n   }\n \n+  @Test public void testTrim() {\n+    OptiqAssert.that()\n+        .withModel(FOODMART_MODEL)\n+        .query(\"select trim(\\\"lname\\\") as \\\"lname\\\" \"\n+            + \"from \\\"customer\\\" where \\\"lname\\\" = 'Nowmer'\")\n+        .returns(\"lname=Nowmer\\n\");\n+\n+    OptiqAssert.that()\n+        .withModel(FOODMART_MODEL)\n+        .query(\"select trim(leading 'N' from \\\"lname\\\") as \\\"lname\\\" \"\n+            + \"from \\\"customer\\\" where \\\"lname\\\" = 'Nowmer'\")\n+        .returns(\"lname=owmer\\n\");\n+  }\n+\n   private OptiqAssert.AssertQuery predicate(String foo) {\n     return OptiqAssert.that()\n         .with(OptiqAssert.Config.REGULAR)",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix bug where non-existent directory would give NPE. Instead print warning.",
        "commit": "https://github.com/apache/calcite/commit/387bee8b616623d91103751e8afe6d7c21842446",
        "parent": "https://github.com/apache/calcite/commit/5b0e70c7457d23f7cf5ddb74c78395f5ad45476c",
        "bug_id": "calcite_52",
        "file": [
            {
                "sha": "8640228582add0586a43a4fb0edc66e94d4bd5a7",
                "filename": "src/main/java/net/hydromatic/optiq/impl/csv/CsvSchema.java",
                "blob_url": "https://github.com/apache/calcite/blob/387bee8b616623d91103751e8afe6d7c21842446/src/main/java/net/hydromatic/optiq/impl/csv/CsvSchema.java",
                "raw_url": "https://github.com/apache/calcite/raw/387bee8b616623d91103751e8afe6d7c21842446/src/main/java/net/hydromatic/optiq/impl/csv/CsvSchema.java",
                "status": "modified",
                "changes": 4,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/main/java/net/hydromatic/optiq/impl/csv/CsvSchema.java?ref=387bee8b616623d91103751e8afe6d7c21842446",
                "patch": "@@ -67,6 +67,10 @@ public boolean accept(File dir, String name) {\n             return name.endsWith(\".csv\");\n           }\n         });\n+    if (files == null) {\n+      System.out.println(\"directory \" + directoryFile + \" not found\");\n+      files = new File[0];\n+    }\n     for (File file : files) {\n       String tableName = file.getName();\n       if (tableName.endsWith(\".csv\")) {",
                "deletions": 0
            },
            {
                "sha": "a7869091924d39c6afc615d3e36e89d7f396cdad",
                "filename": "src/test/java/net/hydromatic/optiq/test/CsvTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/387bee8b616623d91103751e8afe6d7c21842446/src/test/java/net/hydromatic/optiq/test/CsvTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/387bee8b616623d91103751e8afe6d7c21842446/src/test/java/net/hydromatic/optiq/test/CsvTest.java",
                "status": "modified",
                "changes": 29,
                "additions": 29,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/test/java/net/hydromatic/optiq/test/CsvTest.java?ref=387bee8b616623d91103751e8afe6d7c21842446",
                "patch": "@@ -71,6 +71,35 @@ private void close(Connection connection, Statement statement) {\n     connection.close();\n   }\n \n+  /** Tests an inline schema with a non-existent directory. */\n+  @Test public void testBadDirectory() throws SQLException {\n+    Properties info = new Properties();\n+    info.put(\"model\",\n+        \"inline:\"\n+        + \"{\\n\"\n+        + \"  version: '1.0',\\n\"\n+        + \"   schemas: [\\n\"\n+        + \"     {\\n\"\n+        + \"       type: 'custom',\\n\"\n+        + \"       name: 'bad',\\n\"\n+        + \"       factory: 'net.hydromatic.optiq.impl.csv.CsvSchemaFactory',\\n\"\n+        + \"       operand: {\\n\"\n+        + \"         directory: '/does/not/exist'\\n\"\n+        + \"       }\\n\"\n+        + \"     }\\n\"\n+        + \"   ]\\n\"\n+        + \"}\");\n+\n+    Connection connection =\n+        DriverManager.getConnection(\"jdbc:optiq:\", info);\n+    // must print \"directory ... not found\" to stdout, but not fail\n+    ResultSet tables =\n+        connection.getMetaData().getTables(null, null, null, null);\n+    tables.next();\n+    tables.close();\n+    connection.close();\n+  }\n+\n   /**\n    * Reads from a table.\n    */",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix a type-cast issue in DatabaseMetaData.getColumns(), and an NPE handling a switched CASE expression.",
        "commit": "https://github.com/apache/calcite/commit/fcdb825e892d39c7f2157e05a68add24bddc82db",
        "parent": "https://github.com/apache/calcite/commit/6bf299263c39c353e600c4285f3291f4462d5236",
        "bug_id": "calcite_53",
        "file": [
            {
                "sha": "882a39f1b440373c6a7b02f8c96112e84a9161cc",
                "filename": "src/main/java/net/hydromatic/optiq/jdbc/Meta.java",
                "blob_url": "https://github.com/apache/calcite/blob/fcdb825e892d39c7f2157e05a68add24bddc82db/src/main/java/net/hydromatic/optiq/jdbc/Meta.java",
                "raw_url": "https://github.com/apache/calcite/raw/fcdb825e892d39c7f2157e05a68add24bddc82db/src/main/java/net/hydromatic/optiq/jdbc/Meta.java",
                "status": "modified",
                "changes": 32,
                "additions": 30,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/main/java/net/hydromatic/optiq/jdbc/Meta.java?ref=fcdb825e892d39c7f2157e05a68add24bddc82db",
                "patch": "@@ -24,12 +24,13 @@\n import net.hydromatic.optiq.*;\n import net.hydromatic.optiq.impl.TableInSchemaImpl;\n import net.hydromatic.optiq.impl.java.MapSchema;\n-\n import net.hydromatic.optiq.runtime.*;\n \n import org.eigenbase.reltype.*;\n import org.eigenbase.util.Pair;\n \n+import com.google.common.collect.ImmutableMap;\n+\n import java.lang.reflect.Field;\n import java.sql.*;\n import java.sql.Types;\n@@ -451,6 +452,28 @@ public String getName() {\n   }\n \n   private static class NamedFieldGetter {\n+    private static final Map<Class, Pair<Integer, String>> MAP =\n+        ImmutableMap.<Class, Pair<Integer, String>>builder()\n+            .put(boolean.class, Pair.of(Types.BOOLEAN, \"BOOLEAN\"))\n+            .put(Boolean.class, Pair.of(Types.BOOLEAN, \"BOOLEAN\"))\n+            .put(byte.class, Pair.of(Types.TINYINT, \"TINYINT\"))\n+            .put(Byte.class, Pair.of(Types.TINYINT, \"TINYINT\"))\n+            .put(short.class, Pair.of(Types.SMALLINT, \"SMALLINT\"))\n+            .put(Short.class, Pair.of(Types.SMALLINT, \"SMALLINT\"))\n+            .put(int.class, Pair.of(Types.INTEGER, \"INTEGER\"))\n+            .put(Integer.class, Pair.of(Types.INTEGER, \"INTEGER\"))\n+            .put(long.class, Pair.of(Types.BIGINT, \"BIGINT\"))\n+            .put(Long.class, Pair.of(Types.BIGINT, \"BIGINT\"))\n+            .put(float.class, Pair.of(Types.FLOAT, \"FLOAT\"))\n+            .put(Float.class, Pair.of(Types.FLOAT, \"FLOAT\"))\n+            .put(double.class, Pair.of(Types.DOUBLE, \"DOUBLE\"))\n+            .put(Double.class, Pair.of(Types.DOUBLE, \"DOUBLE\"))\n+            .put(String.class, Pair.of(Types.VARCHAR, \"VARCHAR\"))\n+            .put(java.sql.Date.class, Pair.of(Types.DATE, \"DATE\"))\n+            .put(Time.class, Pair.of(Types.TIME, \"TIME\"))\n+            .put(Timestamp.class, Pair.of(Types.TIMESTAMP, \"TIMESTAMP\"))\n+            .build();\n+\n     private final List<Field> fields = new ArrayList<Field>();\n     private final List<ColumnMetaData> columnNames =\n         new ArrayList<ColumnMetaData>();\n@@ -465,19 +488,24 @@ public NamedFieldGetter(Class clazz, String... names) {\n         } catch (NoSuchFieldException e) {\n           throw new RuntimeException(e);\n         }\n+        Pair<Integer, String> pair = lookupType(field.getType());\n         columnNames.add(\n             new ColumnMetaData(\n                 index, false, true, false, false,\n                 Primitive.is(field.getType())\n                     ? DatabaseMetaData.columnNullable\n                     : DatabaseMetaData.columnNoNulls,\n                 true, -1, name, name, null,\n-                0, 0, null, null, Types.VARCHAR, \"VARCHAR\", true,\n+                0, 0, null, null, pair.left, pair.right, true,\n                 false, false, null, field.getType()));\n         fields.add(field);\n       }\n     }\n \n+    private Pair<Integer, String> lookupType(Class<?> type) {\n+      return MAP.get(type);\n+    }\n+\n     private String uncamel(String name) {\n       StringBuilder buf = new StringBuilder();\n       int nextUpper = -1;",
                "deletions": 2
            },
            {
                "sha": "47a79e1fd7cad23ed6d9cb8a24e37eb5a25bf610",
                "filename": "src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java",
                "blob_url": "https://github.com/apache/calcite/blob/fcdb825e892d39c7f2157e05a68add24bddc82db/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java",
                "raw_url": "https://github.com/apache/calcite/raw/fcdb825e892d39c7f2157e05a68add24bddc82db/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java",
                "status": "modified",
                "changes": 5,
                "additions": 4,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java?ref=fcdb825e892d39c7f2157e05a68add24bddc82db",
                "patch": "@@ -4652,7 +4652,10 @@ public Void visit(SqlCall call)\n                 return null;\n             } else {\n                 for (SqlNode operand : call.operands) {\n-                    operand.accept(this);\n+                    // Operands are occasionally null, e.g. switched CASE arg 0.\n+                    if (operand != null) {\n+                        operand.accept(this);\n+                    }\n                 }\n             }\n             return null;",
                "deletions": 1
            },
            {
                "sha": "9ea8ed5b163dd2687a1e3619387c99fed41c828c",
                "filename": "src/test/java/net/hydromatic/optiq/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/fcdb825e892d39c7f2157e05a68add24bddc82db/src/test/java/net/hydromatic/optiq/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/fcdb825e892d39c7f2157e05a68add24bddc82db/src/test/java/net/hydromatic/optiq/test/JdbcTest.java",
                "status": "modified",
                "changes": 28,
                "additions": 28,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/test/java/net/hydromatic/optiq/test/JdbcTest.java?ref=fcdb825e892d39c7f2157e05a68add24bddc82db",
                "patch": "@@ -435,6 +435,14 @@ public void onStatementClose(OptiqStatement statement) {\n     DatabaseMetaData metaData = connection.getMetaData();\n     ResultSet resultSet = metaData.getColumns(null, null, null, null);\n     assertTrue(resultSet.next()); // there's something\n+    String name = resultSet.getString(4);\n+    int type = resultSet.getInt(5);\n+    String typeName = resultSet.getString(6);\n+    int columnSize = resultSet.getInt(7);\n+    int decimalDigits = resultSet.getInt(9);\n+    int numPrecRadix = resultSet.getInt(10);\n+    int charOctetLength = resultSet.getInt(16);\n+    String isNullable = resultSet.getString(18);\n     resultSet.close();\n     connection.close();\n   }\n@@ -463,6 +471,16 @@ public void onStatementClose(OptiqStatement statement) {\n     connection.close();\n   }\n \n+  /** Tests some queries that have expedited processing because connection pools\n+   * like to use them to check whether the connection is alive.\n+   */\n+  @Test public void testSimple() {\n+    OptiqAssert.assertThat()\n+        .with(OptiqAssert.Config.FOODMART_CLONE)\n+        .query(\"SELECT 1\")\n+        .returns(\"EXPR$0=1\\n\");\n+  }\n+\n   @Test public void testCloneSchema()\n       throws ClassNotFoundException, SQLException {\n     final OptiqConnection connection = JdbcTest.getConnection(null, false);\n@@ -533,6 +551,16 @@ public void onStatementClose(OptiqStatement statement) {\n             + \"\\n\");\n   }\n \n+  @Test public void testOrderByCase() {\n+    OptiqAssert.assertThat()\n+        .with(OptiqAssert.Config.FOODMART_CLONE)\n+        .query(\n+            \"select \\\"time_by_day\\\".\\\"the_year\\\" as \\\"c0\\\" from \\\"time_by_day\\\" as \\\"time_by_day\\\" group by \\\"time_by_day\\\".\\\"the_year\\\" order by CASE WHEN \\\"time_by_day\\\".\\\"the_year\\\" IS NULL THEN 1 ELSE 0 END, \\\"time_by_day\\\".\\\"the_year\\\" ASC\")\n+        .returns(\n+            \"c0=1997\\n\"\n+            + \"c0=1998\\n\");\n+  }\n+\n   private static final String[] queries = {\n       \"select count(*) from (select 1 as \\\"c0\\\" from \\\"salary\\\" as \\\"salary\\\") as \\\"init\\\"\",\n       \"EXPR$0=21252\\n\",",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "Fix NPE when executing a DatabaseMetaData method that returns the empty set (e.g. getPrimaryKeys).",
        "commit": "https://github.com/apache/calcite/commit/86f5c4e2ff3ba239589cac9d9a961994eef3279b",
        "parent": "https://github.com/apache/calcite/commit/160433c8eee622ce7e495b3d44537af60d9bc472",
        "bug_id": "calcite_54",
        "file": [
            {
                "sha": "0d8359bff8b627fa1621f5df45bd25e30beca285",
                "filename": "src/main/java/net/hydromatic/optiq/jdbc/Meta.java",
                "blob_url": "https://github.com/apache/calcite/blob/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/main/java/net/hydromatic/optiq/jdbc/Meta.java",
                "raw_url": "https://github.com/apache/calcite/raw/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/main/java/net/hydromatic/optiq/jdbc/Meta.java",
                "status": "modified",
                "changes": 6,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/main/java/net/hydromatic/optiq/jdbc/Meta.java?ref=86f5c4e2ff3ba239589cac9d9a961994eef3279b",
                "patch": "@@ -128,17 +128,15 @@ private ResultSet createResultSet(\n         final NamedFieldGetter columnGetter)\n     {\n         try {\n-            OptiqResultSet x = connection.driver.factory.newResultSet(\n+            return connection.driver.factory.newResultSet(\n                 connection.createStatement(),\n                 columnGetter.columnNames,\n                 new Function0<Cursor>() {\n                     public Cursor apply() {\n                         return columnGetter.cursor(\n                             ((Enumerable) enumerable).enumerator());\n                     }\n-                });\n-            x.execute();\n-            return x;\n+                }).execute();\n         } catch (SQLException e) {\n             throw new RuntimeException(e);\n         }",
                "deletions": 4
            },
            {
                "sha": "72efc5311b07adbcbfeca14f1b06172acbc5f348",
                "filename": "src/main/java/net/hydromatic/optiq/jdbc/OptiqDatabaseMetaData.java",
                "blob_url": "https://github.com/apache/calcite/blob/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/main/java/net/hydromatic/optiq/jdbc/OptiqDatabaseMetaData.java",
                "raw_url": "https://github.com/apache/calcite/raw/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/main/java/net/hydromatic/optiq/jdbc/OptiqDatabaseMetaData.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/main/java/net/hydromatic/optiq/jdbc/OptiqDatabaseMetaData.java?ref=86f5c4e2ff3ba239589cac9d9a961994eef3279b",
                "patch": "@@ -882,7 +882,7 @@ public boolean next() {\n                             }\n                         };\n                     }\n-                });\n+                }).execute();\n         } catch (SQLException e) {\n             throw new RuntimeException(e);\n         }",
                "deletions": 1
            },
            {
                "sha": "bbcc7efb6d96086ee512d0061d451419250cc36b",
                "filename": "src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java",
                "blob_url": "https://github.com/apache/calcite/blob/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java",
                "raw_url": "https://github.com/apache/calcite/raw/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java?ref=86f5c4e2ff3ba239589cac9d9a961994eef3279b",
                "patch": "@@ -130,7 +130,7 @@ void cancel() {\n      * constructor occurs while the statement is locked, to make sure that\n      * execute/cancel don't happen at the same time.</p>\n      */\n-    void execute() {\n+    OptiqResultSet execute() {\n         // Call driver's callback. It is permitted to throw a RuntimeException.\n         final boolean autoTemp =\n             ConnectionProperty.AUTO_TEMP.getBoolean(\n@@ -151,6 +151,7 @@ public void toBeCompleted() {\n         for (Map.Entry<String, Integer> entry : columnNameMap.entrySet()) {\n             accessorMap.put(entry.getKey(), accessorList.get(entry.getValue()));\n         }\n+        return this;\n     }\n \n     public boolean next() throws SQLException {",
                "deletions": 1
            },
            {
                "sha": "7f5b94d21aef890f8643b4cb9fa9aab453ba8539",
                "filename": "src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/86f5c4e2ff3ba239589cac9d9a961994eef3279b/src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackTest.java",
                "status": "modified",
                "changes": 23,
                "additions": 23,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackTest.java?ref=86f5c4e2ff3ba239589cac9d9a961994eef3279b",
                "patch": "@@ -127,6 +127,29 @@ public Object apply(OptiqConnection a0) {\n             );\n     }\n \n+    /** Tests a JDBC method known to be not implemented (as it happens,\n+     * {@link java.sql.DatabaseMetaData#getPrimaryKeys}) that therefore uses\n+     * empty result set. */\n+    public void testEmpty() throws Exception {\n+        assertThat()\n+            .with(OptiqAssert.Config.JDBC_FOODMART2)\n+            .doWithConnection(\n+                new Function1<OptiqConnection, Object>() {\n+                    public Object apply(OptiqConnection a0) {\n+                        try {\n+                            ResultSet rset =\n+                                a0.getMetaData().getPrimaryKeys(\n+                                    null, null, \"sales_fact_1997\");\n+                            assertFalse(rset.next());\n+                        } catch (SQLException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        return null;\n+                    }\n+                }\n+            );\n+    }\n+\n     public void testCase() {\n         assertThat()\n             .with(OptiqAssert.Config.JDBC_FOODMART2)",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "calcite",
        "message": "[CALCITE-980] Fix AND and OR implementation in Enumerable convention\n\nPreviously it could fail with NPE or return wrong result\n\nfixes #169",
        "commit": "https://github.com/apache/calcite/commit/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb",
        "parent": "https://github.com/apache/calcite/commit/47e0e7c952aed22dd237529bb459a59580034f91",
        "bug_id": "calcite_55",
        "file": [
            {
                "sha": "32c043ca28e4d7c0d1f76f8114f8772d8ac25d8c",
                "filename": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "blob_url": "https://github.com/apache/calcite/blob/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "raw_url": "https://github.com/apache/calcite/raw/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java",
                "status": "modified",
                "changes": 91,
                "additions": 55,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java?ref=963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb",
                "patch": "@@ -55,10 +55,8 @@\n import org.apache.calcite.util.BuiltInMethod;\n import org.apache.calcite.util.Util;\n \n-import com.google.common.base.Function;\n import com.google.common.base.Supplier;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n import java.lang.reflect.Constructor;\n@@ -428,22 +426,38 @@ public Expression implement(\n       return new CallImplementor() {\n         public Expression implement(\n             RexToLixTranslator translator, RexCall call, NullAs nullAs) {\n+          assert call.getOperator() == AND\n+              : \"AND null semantics is supported only for AND operator. Actual operator is \"\n+              + String.valueOf(call.getOperator());\n           final RexCall call2 = call2(false, translator, call);\n-          final NullAs nullAs2 = nullAs == NullAs.TRUE ? NullAs.NULL : nullAs;\n-          final List<Expression> expressions =\n-              translator.translateList(call2.getOperands(), nullAs2);\n           switch (nullAs) {\n-          case NOT_POSSIBLE:\n+          case NOT_POSSIBLE: // Just foldAnd\n           case TRUE:\n+            // AND call should return false iff has FALSEs,\n+            // thus if we convert nulls to true then no harm is made\n+          case FALSE:\n+            // AND call should return false iff has FALSEs or has NULLs,\n+            // thus if we convert nulls to false, no harm is made\n+            final List<Expression> expressions =\n+                translator.translateList(call2.getOperands(), nullAs);\n             return Expressions.foldAnd(expressions);\n+          case NULL:\n+          case IS_NULL:\n+          case IS_NOT_NULL:\n+            final List<Expression> nullAsTrue =\n+                translator.translateList(call2.getOperands(), NullAs.TRUE);\n+            final List<Expression> nullAsIsNull =\n+                translator.translateList(call2.getOperands(), NullAs.IS_NULL);\n+            Expression hasFalse = Expressions.not(Expressions.foldAnd(nullAsTrue));\n+            Expression hasNull = Expressions.foldOr(nullAsIsNull);\n+            Expression result = nullAs.handle(\n+                Expressions.condition(hasFalse, BOXED_FALSE_EXPR,\n+                    Expressions.condition(hasNull, NULL_EXPR, BOXED_TRUE_EXPR)));\n+            return result;\n+          default:\n+            throw new IllegalArgumentException(\n+                \"Unknown nullAs when implementing AND: \" + nullAs);\n           }\n-          return Expressions.foldAnd(\n-              Lists.transform(expressions,\n-                  new Function<Expression, Expression>() {\n-                    public Expression apply(Expression e) {\n-                      return nullAs2.handle(e);\n-                    }\n-                  }));\n         }\n       };\n     case OR:\n@@ -456,34 +470,39 @@ public Expression apply(Expression e) {\n       //   : Boolean.TRUE;\n       return new CallImplementor() {\n         public Expression implement(\n-            RexToLixTranslator translator, RexCall call, NullAs nullAs) {\n+            RexToLixTranslator translator, RexCall call, final NullAs nullAs) {\n+          assert call.getOperator() == OR\n+              : \"OR null semantics is supported only for OR operator. Actual operator is \"\n+              + String.valueOf(call.getOperator());\n           final RexCall call2 = call2(harmonize, translator, call);\n-          final NullAs nullAs2 = nullAs == NullAs.TRUE ? NullAs.NULL : nullAs;\n-          final List<Expression> expressions =\n-              translator.translateList(call2.getOperands(), nullAs2);\n           switch (nullAs) {\n-          case NOT_POSSIBLE:\n+          case NOT_POSSIBLE: // Just foldOr\n+          case TRUE:\n+            // This should return false iff all arguments are FALSE,\n+            // thus we convert nulls to TRUE and foldOr\n           case FALSE:\n+            // This should return true iff has TRUE arguments,\n+            // thus we convert nulls to FALSE and foldOr\n+            final List<Expression> expressions =\n+                translator.translateList(call2.getOperands(), nullAs);\n             return Expressions.foldOr(expressions);\n+          case NULL:\n+          case IS_NULL:\n+          case IS_NOT_NULL:\n+            final List<Expression> nullAsFalse =\n+                translator.translateList(call2.getOperands(), NullAs.FALSE);\n+            final List<Expression> nullAsIsNull =\n+                translator.translateList(call2.getOperands(), NullAs.IS_NULL);\n+            Expression hasTrue = Expressions.foldOr(nullAsFalse);\n+            Expression hasNull = Expressions.foldOr(nullAsIsNull);\n+            Expression result = nullAs.handle(\n+                Expressions.condition(hasTrue, BOXED_TRUE_EXPR,\n+                    Expressions.condition(hasNull, NULL_EXPR, BOXED_FALSE_EXPR)));\n+            return result;\n+          default:\n+            throw new IllegalArgumentException(\n+                \"Unknown nullAs when implementing OR: \" + nullAs);\n           }\n-          final Expression t0 = expressions.get(0);\n-          final Expression t1 = expressions.get(1);\n-          if (!nullable(call2, 0) && !nullable(call2, 1)) {\n-            return Expressions.orElse(t0, t1);\n-          }\n-          return optimize(\n-              Expressions.condition(\n-                  Expressions.equal(t0, NULL_EXPR),\n-                  Expressions.condition(\n-                      Expressions.orElse(\n-                          Expressions.equal(t1, NULL_EXPR),\n-                          Expressions.not(t1)),\n-                      NULL_EXPR,\n-                      BOXED_TRUE_EXPR),\n-                  Expressions.condition(\n-                      Expressions.not(t0),\n-                      t1,\n-                      BOXED_TRUE_EXPR)));\n         }\n       };\n     case NOT:",
                "deletions": 36
            },
            {
                "sha": "4c203d671674ae39c5eb46294a98efc5ad3fd725",
                "filename": "core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/test/java/org/apache/calcite/test/JdbcTest.java",
                "status": "modified",
                "changes": 51,
                "additions": 51,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/JdbcTest.java?ref=963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb",
                "patch": "@@ -4277,6 +4277,57 @@ private void startOfGroupStep3(String startOfGroup) {\n             \"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\\n\");\n   }\n \n+  /** Tests CALCITE-980: Not (C='a' or C='b') causes NPE */\n+  @Test public void testWhereOrAndNullable() {\n+    /* Generates the following code:\n+       public boolean moveNext() {\n+         while (inputEnumerator.moveNext()) {\n+           final Object[] current = (Object[]) inputEnumerator.current();\n+           final String inp0_ = current[0] == null ? (String) null : current[0].toString();\n+           final String inp1_ = current[1] == null ? (String) null : current[1].toString();\n+           if (inp0_ != null && org.apache.calcite.runtime.SqlFunctions.eq(inp0_, \"a\")\n+               && (inp1_ != null && org.apache.calcite.runtime.SqlFunctions.eq(inp1_, \"b\"))\n+               || inp0_ != null && org.apache.calcite.runtime.SqlFunctions.eq(inp0_, \"b\")\n+               && (inp1_ != null && org.apache.calcite.runtime.SqlFunctions.eq(inp1_, \"c\"))) {\n+             return true;\n+           }\n+         }\n+         return false;\n+       }\n+     */\n+    CalciteAssert.that()\n+        .with(CalciteAssert.Config.REGULAR)\n+        .query(\"with tst(c) as (values('a'),('b'),('c'),(cast(null as varchar)))\"\n+            + \" select u.c u, v.c v from tst u, tst v where ((u.c = 'a' and v.c = 'b') or (u.c = 'b' and v.c = 'c'))\")\n+        .returnsUnordered(\n+            \"U=a; V=b\",\n+            \"U=b; V=c\");\n+  }\n+\n+  /** Tests CALCITE-980: different flavors of boolean logic */\n+  @Test public void testBooleansInWhere() throws Exception {\n+    checkRun(\"sql/conditions.oq\");\n+  }\n+\n+  /** Tests CALCITE-980: different flavors of boolean logic */\n+  @Ignore(\"Fails with org.codehaus.commons.compiler.CompileException: Line 16, Column 112:\"\n+      + \" Cannot compare types \\\"int\\\" and \\\"java.lang.String\\\"\\n\")\n+  @Test public void testComparingIntAndString() throws Exception {\n+    // if (((...test.ReflectiveSchemaTest.IntAndString) inputEnumerator.current()).id == \"T\")\n+\n+    CalciteAssert.that()\n+        .withSchema(\"s\",\n+            new ReflectiveSchema(\n+                new ReflectiveSchemaTest.CatchallSchema()))\n+        .query(\"select a.\\\"value\\\", b.\\\"value\\\"\\n\"\n+            + \"  from \\\"bools\\\" a\\n\"\n+            + \"     , \\\"bools\\\" b\\n\"\n+            + \" where b.\\\"value\\\" = 'T'\\n\"\n+            + \" order by 1, 2\")\n+        .returnsUnordered(\n+            \"should fail with 'not a number' sql error while converting text to number\");\n+  }\n+\n   /** Tests the LIKE operator. */\n   @Test public void testLike() {\n     CalciteAssert.that()",
                "deletions": 0
            },
            {
                "sha": "0ebd616ac5395fed40c4c3f1d9969ffa41a9bd94",
                "filename": "core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java",
                "blob_url": "https://github.com/apache/calcite/blob/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java",
                "raw_url": "https://github.com/apache/calcite/raw/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java",
                "status": "modified",
                "changes": 18,
                "additions": 18,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java?ref=963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb",
                "patch": "@@ -798,6 +798,17 @@ public boolean apply(Field v1) {\n     public final BitSet bitSet = new BitSet(0);\n   }\n \n+  /** Table that has integer and string fields */\n+  public static class IntAndString {\n+    public final int id;\n+    public final String value;\n+\n+    public IntAndString(int id, String value) {\n+      this.id = id;\n+      this.value = value;\n+    }\n+  }\n+\n   /** Object whose fields are relations. Called \"catch-all\" because it's OK\n    * if tests add new fields. */\n   public static class CatchallSchema {\n@@ -841,6 +852,13 @@ public boolean apply(Field v1) {\n \n     public final IntHolder[] primesCustomBoxed =\n         new IntHolder[]{new IntHolder(1), new IntHolder(3), new IntHolder(5)};\n+\n+    public final IntAndString[] nullables = new IntAndString[] {\n+      new IntAndString(1, \"A\"), new IntAndString(2, \"B\"), new IntAndString(2, \"C\"),\n+      new IntAndString(3, null)};\n+\n+    public final IntAndString[] bools = new IntAndString[] {\n+      new IntAndString(1, \"T\"), new IntAndString(2, \"F\"), new IntAndString(3, null)};\n   }\n \n   /**",
                "deletions": 0
            },
            {
                "sha": "f7d7f51c7450c1f26d7423b6e9ec62cd9342ed50",
                "filename": "core/src/test/resources/sql/conditions.oq",
                "blob_url": "https://github.com/apache/calcite/blob/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/test/resources/sql/conditions.oq",
                "raw_url": "https://github.com/apache/calcite/raw/963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb/core/src/test/resources/sql/conditions.oq",
                "status": "added",
                "changes": 259,
                "additions": 259,
                "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/resources/sql/conditions.oq?ref=963ba1b1b3d2ab95989d8383e0a855c3ae5e24cb",
                "patch": "@@ -0,0 +1,259 @@\n+# conditions.oq - conditions\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to you under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+!use catchall\n+!set outputformat mysql\n+\n+# OR test\n+\n+with tmp(a, b) as (\n+  values (1, 1), (1, 0), (1, cast(null as int))\n+       , (0, 1), (0, 0), (0, cast(null as int))\n+       , (cast(null as int), 1), (cast(null as int), 0), (cast(null as int), cast(null as int)))\n+select *\n+  from tmp\n+ where a = 1 or b = 1\n+ order by 1, 2;\n+\n++---+---+\n+| A | B |\n++---+---+\n+| 0 | 1 |\n+| 1 | 0 |\n+| 1 | 1 |\n+| 1 |   |\n+|   | 1 |\n++---+---+\n+(5 rows)\n+\n+!ok\n+\n+with tmp(a, b) as (\n+  values (1, 1), (1, 0), (1, cast(null as int))\n+       , (0, 1), (0, 0), (0, cast(null as int))\n+       , (cast(null as int), 1), (cast(null as int), 0), (cast(null as int), cast(null as int)))\n+select *\n+  from tmp\n+ where not (a = 1 or b = 1)\n+ order by 1, 2;\n+\n++---+---+\n+| A | B |\n++---+---+\n+| 0 | 0 |\n++---+---+\n+(1 row)\n+\n+!ok\n+\n+# AND test\n+\n+with tmp(a, b) as (\n+  values (1, 1), (1, 0), (1, cast(null as int))\n+       , (0, 1), (0, 0), (0, cast(null as int))\n+       , (cast(null as int), 1), (cast(null as int), 0), (cast(null as int), cast(null as int)))\n+select *\n+  from tmp\n+ where a = 1 AND b = 1\n+ order by 1, 2;\n+\n++---+---+\n+| A | B |\n++---+---+\n+| 1 | 1 |\n++---+---+\n+(1 row)\n+\n+!ok\n+\n+with tmp(a, b) as (\n+  values (1, 1), (1, 0), (1, cast(null as int))\n+       , (0, 1), (0, 0), (0, cast(null as int))\n+       , (cast(null as int), 1), (cast(null as int), 0), (cast(null as int), cast(null as int)))\n+select *\n+  from tmp\n+ where not (a = 1 AND b = 1)\n+ order by 1, 2;\n+\n++---+---+\n+| A | B |\n++---+---+\n+| 0 | 0 |\n+| 0 | 1 |\n+| 0 |   |\n+| 1 | 0 |\n+|   | 0 |\n++---+---+\n+(5 rows)\n+\n+!ok\n+\n+# Test cases for CALCITE-980\n+\n+select \"value\" from \"nullables\" a where \"value\" = 'A' or \"value\" = 'B' order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| A     |\n+| B     |\n++-------+\n+(2 rows)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a where not (\"value\" = 'A' or \"value\" = 'B') order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| C     |\n++-------+\n+(1 row)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a where not (not (\"value\" = 'A' or \"value\" = 'B')) order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| A     |\n+| B     |\n++-------+\n+(2 rows)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a where \"value\" = 'A' and \"value\" = 'B' order by 1;\n+\n++-------+\n+| value |\n++-------+\n++-------+\n+(0 rows)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a where not (\"value\" = 'A' and \"value\" = 'B') order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| A     |\n+| B     |\n+| C     |\n++-------+\n+(3 rows)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a where not (not (\"value\" = 'A' and \"value\" = 'B')) order by 1;\n+\n++-------+\n+| value |\n++-------+\n++-------+\n+(0 rows)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a\n+ where case when not (\"value\" = 'A' or \"value\" = 'B') then 1 else 0 end = 1\n+ order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| C     |\n++-------+\n+(1 row)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a\n+ where\n+   case when not (\"value\"='A' or \"value\"='B')\n+     then\n+       case when (\"value\"='A' or \"value\"='B') then 1 else 2 end\n+     else 0\n+   end = 2\n+ order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| C     |\n++-------+\n+(1 row)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a\n+ where\n+   case when not (\"value\"='A' or \"value\"='B')\n+     then\n+       case when not /* <--diff from above */ (\"value\"='A' or \"value\"='B') then 1 else 2 end\n+     else 0\n+   end = 1 /* <- diff from above*/\n+ order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| C     |\n++-------+\n+(1 row)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a\n+ where\n+   case when not (\"value\"='A' or \"value\"='B')\n+     then\n+       case when not (\"value\"='A' or \"value\"='B') then 1 else 2 end\n+     else 0\n+   end = 0 /* <- diff from above*/\n+ order by 1;\n+\n++-------+\n+| value |\n++-------+\n+| A     |\n+| B     |\n+|       |\n++-------+\n+(3 rows)\n+\n+!ok\n+\n+select \"value\" from \"nullables\" a\n+ where\n+   case when not (\"value\"='A' or \"value\"='B')\n+     then\n+       case when not (\"value\"='A' or \"value\"='B') then 1 else 2 end\n+     else 0\n+   end = 2 /* <- diff from above*/\n+ order by 1;\n+\n++-------+\n+| value |\n++-------+\n++-------+\n+(0 rows)\n+\n+!ok",
                "deletions": 0
            }
        ]
    }
]