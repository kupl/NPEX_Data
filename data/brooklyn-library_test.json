{
    "brooklyn-library_023e492": {
        "bug_id": "brooklyn-library_023e492",
        "commit": "https://github.com/apache/brooklyn-library/commit/023e49287c8acdb6daf3af171e7e7277b145f63a",
        "file": [
            {
                "additions": 41,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java",
                "changes": 72,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java?ref=023e49287c8acdb6daf3af171e7e7277b145f63a",
                "deletions": 31,
                "filename": "software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java",
                "patch": "@@ -54,6 +54,7 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Objects;\n+import com.google.common.base.Optional;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n@@ -230,7 +231,15 @@ public String getProtocol() {\n     public String getDomain() {\n         return getAttribute(DOMAIN_NAME);\n     }\n-    \n+\n+    protected String getDomainWithoutWildcard() {\n+        String domain = getDomain();\n+        if (domain != null && domain.startsWith(\"*.\")) {\n+            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n+        }\n+        return domain;\n+    }\n+\n     @Override\n     public Integer getPort() {\n         if (isSsl())\n@@ -267,39 +276,21 @@ protected String inferProtocol() {\n         return isSsl() ? \"https\" : \"http\";\n     }\n \n-    protected String inferUrlSubnet() {\n-        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n-        String domain = getDomain();\n-        if (domain != null && domain.startsWith(\"*.\")) {\n-            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n-        }\n-        Integer port = checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n-\n+    protected String inferUrlForSubnet() {\n+        String domain = getDomainWithoutWildcard();\n         if (domain==null) domain = getAttribute(Attributes.SUBNET_ADDRESS);\n-        if (domain==null) return null;\n-        return protocol+\"://\"+domain+\":\"+port+\"/\"+getConfig(SERVICE_UP_URL_PATH);\n+        return inferUrl(domain, Optional.<Integer>absent());\n     }\n \n-    protected String inferUrlPublic() {\n-        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n-        String domain = getDomain();\n-        if (domain != null && domain.startsWith(\"*.\")) {\n-            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n-        }\n-        Integer port = checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n-\n+    protected String inferUrlForPublic() {\n+        String domain = getDomainWithoutWildcard();\n         if (domain==null) domain = getAttribute(Attributes.ADDRESS);\n-        if (domain==null) return null;\n-        return protocol+\"://\"+domain+\":\"+port+\"/\"+getConfig(SERVICE_UP_URL_PATH);\n+        return inferUrl(domain, Optional.<Integer>absent());\n     }\n \n     /** returns URL, if it can be inferred; null otherwise */\n     protected String inferUrl(boolean requireManagementAccessible) {\n-        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n-        String domain = getDomain();\n-        if (domain != null && domain.startsWith(\"*.\")) {\n-            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n-        }\n+        String domain = getDomainWithoutWildcard();\n         Integer port = checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n         if (requireManagementAccessible) {\n             HostAndPort accessible = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, port);\n@@ -309,8 +300,15 @@ protected String inferUrl(boolean requireManagementAccessible) {\n             }\n         }\n         if (domain==null) domain = Machines.findSubnetHostname(this).orNull();\n-        if (domain==null) return null;\n-        return protocol+\"://\"+domain+\":\"+port+\"/\"+getConfig(SERVICE_UP_URL_PATH);\n+        return inferUrl(domain, Optional.of(port));\n+    }\n+\n+    protected String inferUrl(String host, Optional<Integer> portOverride) {\n+        if (host == null) return null;\n+        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n+        int port = portOverride.isPresent() ? portOverride.get() : checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n+        String path = getConfig(SERVICE_UP_URL_PATH);\n+        return protocol+\"://\"+host+\":\"+port+\"/\"+path;\n     }\n \n     protected String inferUrl() {\n@@ -343,14 +341,26 @@ protected void computePortsAndUrls() {\n         ConfigToAttributes.apply(this);\n \n         sensors().set(PROTOCOL, inferProtocol());\n-        sensors().set(MAIN_URI, URI.create(inferUrl()));\n-        sensors().set(MAIN_URI_MAPPED_SUBNET, URI.create(inferUrlSubnet()));\n-        sensors().set(MAIN_URI_MAPPED_PUBLIC, URI.create(inferUrlPublic()));\n+        sensors().set(MAIN_URI, createUriOrNull(inferUrl()));\n+        sensors().set(MAIN_URI_MAPPED_SUBNET, createUriOrNull(inferUrlForSubnet()));\n+        sensors().set(MAIN_URI_MAPPED_PUBLIC, createUriOrNull(inferUrlForPublic()));\n         sensors().set(ROOT_URL, inferUrl());\n  \n         checkNotNull(getPortNumberSensor(), \"no sensor configured to infer port number\");\n     }\n     \n+    private URI createUriOrNull(String val) {\n+        if (val == null) {\n+            return null;\n+        }\n+        try {\n+            return URI.create(val);\n+        } catch (IllegalArgumentException e) {\n+            LOG.warn(\"Invalid URI for {}: {}\", this, val);\n+            return null;\n+        }\n+    }\n+    \n     @Override\n     protected void connectSensors() {\n         super.connectSensors();",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java",
                "sha": "3277e381f59311f97d0ac8ea831497ca2fb9a318",
                "status": "modified"
            },
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java?ref=023e49287c8acdb6daf3af171e7e7277b145f63a",
                "deletions": 18,
                "filename": "software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java",
                "patch": "@@ -31,7 +31,6 @@\n import java.util.Set;\n \n import org.apache.brooklyn.api.entity.Entity;\n-import org.apache.brooklyn.api.entity.EntityLocal;\n import org.apache.brooklyn.api.entity.EntitySpec;\n import org.apache.brooklyn.api.location.Location;\n import org.apache.brooklyn.api.location.LocationSpec;\n@@ -43,6 +42,7 @@\n import org.apache.brooklyn.core.entity.EntityAsserts;\n import org.apache.brooklyn.core.entity.factory.EntityFactory;\n import org.apache.brooklyn.core.entity.trait.Startable;\n+import org.apache.brooklyn.core.location.HasSubnetHostname;\n import org.apache.brooklyn.core.location.PortRanges;\n import org.apache.brooklyn.core.test.BrooklynAppUnitTestSupport;\n import org.apache.brooklyn.core.test.entity.TestEntity;\n@@ -155,7 +155,7 @@ public void testUpdateCalledWhenChildHostnameAndPortChanges() throws Exception {\n     public void testUpdateCalledWithAddressesOfNewChildren() {\n         // First child\n         cluster.resize(1);\n-        EntityLocal child = (EntityLocal) Iterables.getOnlyElement(cluster.getMembers());\n+        Entity child = Iterables.getOnlyElement(cluster.getMembers());\n         \n         List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());\n         assertTrue(u.isEmpty(), \"expected empty list but got \"+u);\n@@ -171,7 +171,7 @@ public void testUpdateCalledWithAddressesOfNewChildren() {\n             public void run() {\n                 assertEquals(cluster.getMembers().size(), 2);\n             }});\n-        EntityLocal child2 = (EntityLocal) Iterables.getOnlyElement(MutableSet.builder().addAll(cluster.getMembers()).remove(child).build());\n+        Entity child2 = Iterables.getOnlyElement(MutableSet.<Entity>builder().addAll(cluster.getMembers()).remove(child).build());\n         \n         child2.sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n         child2.sensors().set(Startable.SERVICE_UP, true);\n@@ -192,8 +192,8 @@ public void testUpdateCalledWithAddressesRemovedForStoppedChildren() {\n         // Get some children, so we can remove one...\n         cluster.resize(2);\n         for (Entity it: cluster.getMembers()) { \n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n-            ((EntityLocal)it).sensors().set(Startable.SERVICE_UP, true);\n+            it.sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n+            it.sensors().set(Startable.SERVICE_UP, true);\n         }\n         assertEventuallyAddressesMatchCluster();\n \n@@ -208,17 +208,17 @@ public void testUpdateCalledWithAddressesRemovedForServiceDownChildrenThatHaveCl\n         // Get some children, so we can remove one...\n         cluster.resize(2);\n         for (Entity it: cluster.getMembers()) { \n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n-            ((EntityLocal)it).sensors().set(Startable.SERVICE_UP, true);\n+            it.sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n+            it.sensors().set(Startable.SERVICE_UP, true);\n         }\n         assertEventuallyAddressesMatchCluster();\n \n         // Now unset host/port, and remove children\n         // Note the unsetting of hostname is done in SoftwareProcessImpl.stop(), so this is realistic\n         for (Entity it : cluster.getMembers()) {\n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HTTP_PORT, null);\n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HOSTNAME, null);\n-            ((EntityLocal)it).sensors().set(Startable.SERVICE_UP, false);\n+            it.sensors().set(ClusteredEntity.HTTP_PORT, null);\n+            it.sensors().set(ClusteredEntity.HOSTNAME, null);\n+            it.sensors().set(Startable.SERVICE_UP, false);\n         }\n         assertEventuallyAddressesMatch(ImmutableList.<Entity>of());\n     }\n@@ -314,24 +314,34 @@ public void testMainUriSensorsCorrectlyComputedWithDomain() throws Exception {\n \n     @Test\n     public void testMainUriSensorsCorrectlyComputedWithoutDomain() throws Exception {\n+        // The MachineLocation needs to implement HasSubnetHostname for the Attributes.SUBNET_HOSTNAME \n+        // to be set with the subnet addresss (otherwise it will fall back to using machine.getAddress()).\n+        // See Machines.getSubnetHostname. \n+        \n         TrackingAbstractController controller2 = app.addChild(EntitySpec.create(TrackingAbstractController.class)\n                 .configure(TrackingAbstractController.SERVER_POOL, cluster)\n                 .configure(TrackingAbstractController.PROXY_HTTP_PORT, PortRanges.fromInteger(8081))\n-                .location(LocationSpec.create(SshMachineLocation.class)\n+                .location(LocationSpec.create(SshMachineLocationWithSubnetHostname.class)\n                         .configure(\"address\", Inet4Address.getByName(\"1.1.1.1\"))\n                         .configure(SshMachineLocation.PRIVATE_ADDRESSES, ImmutableList.of(\"2.2.2.2\"))));\n         controller2.start(ImmutableList.<Location>of());\n \n-        // Unfortunately the Attributes.SUBNET_HOSTNAME is 1.1.1.1, because SshMachineLocation does not implement\n-        // HasSubnetHostname (see Machines.getSubnetHostname). It falls back to using the machine.getAddress().\n-        // Hence the MAIN_URI uses 1.1.1.1.\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.ADDRESS, \"1.1.1.1\");\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.SUBNET_ADDRESS, \"2.2.2.2\");\n-        EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI, URI.create(\"http://1.1.1.1:8081/\"));\n+        EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI, URI.create(\"http://2.2.2.2:8081/\"));\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI_MAPPED_PUBLIC, URI.create(\"http://1.1.1.1:8081/\"));\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI_MAPPED_SUBNET, URI.create(\"http://2.2.2.2:8081/\"));\n     }\n-\n+    public static class SshMachineLocationWithSubnetHostname extends SshMachineLocation implements HasSubnetHostname {\n+        @Override public String getSubnetHostname() {\n+            return getSubnetIp();\n+        }\n+        @Override public String getSubnetIp() {\n+            Set<String> addrs = getPrivateAddresses();\n+            return (addrs.isEmpty()) ? getAddress().getHostAddress() : Iterables.get(addrs, 0);\n+        }\n+    }\n+    \n     private void assertEventuallyAddressesMatchCluster() {\n         assertEventuallyAddressesMatch(cluster.getMembers());\n     }\n@@ -388,10 +398,10 @@ public ClusteredEntity newEntity(Map flags, Entity parent) {\n         @SetFromFlag(\"hostAndPort\")\n         public static final AttributeSensor<String> HOST_AND_PORT = Attributes.HOST_AND_PORT;\n         \n-        MachineProvisioningLocation provisioner;\n+        MachineProvisioningLocation<MachineLocation> provisioner;\n         \n         public void start(Collection<? extends Location> locs) {\n-            provisioner = (MachineProvisioningLocation) locs.iterator().next();\n+            provisioner = (MachineProvisioningLocation<MachineLocation>) locs.iterator().next();\n             MachineLocation machine;\n             try {\n                 machine = provisioner.obtain(MutableMap.of());",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java",
                "sha": "831df4c7a49f4416438d78ff4df336ed33ce9342",
                "status": "modified"
            }
        ],
        "message": "Improvements for PR #66\n\n* Avoid NPE in in AbstractController.computePortsAndUrls() if inferUrl\n  returns null.\n* Remove some duplication from inferUrl*()\n* Renames inferUrlPublic() to inferUrlForPublic() - and same for subnet\n* testMainUriSensorsCorrectlyComputedWithoutDomain to use machineLocation\n  extending HasSubnetHostname, so subnet address set as expected.\n* Tidy deprecated code and generics in test.",
        "parent": "https://github.com/apache/brooklyn-library/commit/313203f0b45d2178fa142167d2b42238544b8dce",
        "patched_files": [
            "AbstractControllerImpl.java",
            "AbstractController.java"
        ],
        "repo": "brooklyn-library",
        "unit_tests": [
            "AbstractControllerTest.java"
        ]
    },
    "brooklyn-library_08e185c": {
        "bug_id": "brooklyn-library_08e185c",
        "commit": "https://github.com/apache/brooklyn-library/commit/08e185c2a11d466a1198625764c641905830d5d2",
        "file": [
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/08e185c2a11d466a1198625764c641905830d5d2/software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServer.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServer.java?ref=08e185c2a11d466a1198625764c641905830d5d2",
                "deletions": 3,
                "filename": "software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServer.java",
                "patch": "@@ -25,10 +25,12 @@\n import brooklyn.entity.basic.SoftwareProcess;\n import brooklyn.entity.proxying.ImplementedBy;\n import brooklyn.event.AttributeSensor;\n+import brooklyn.event.basic.BasicAttributeSensor;\n import brooklyn.event.basic.BasicConfigKey;\n import brooklyn.event.basic.PortAttributeSensorAndConfigKey;\n import brooklyn.location.basic.PortRanges;\n import brooklyn.util.flags.SetFromFlag;\n+import brooklyn.util.net.Cidr;\n \n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n@@ -52,12 +54,11 @@\n \n     @SetFromFlag(\"reverseLookupNetwork\")\n     ConfigKey<String> REVERSE_LOOKUP_NETWORK = new BasicConfigKey<String>(String.class,\n-            \"bind.reverse-lookup.address\", \"Network address for reverse lookup zone (defaults to server address /24)\");\n+            \"bind.reverse-lookup.address\", \"Network address for reverse lookup zone\");\n \n     @SetFromFlag(\"subnet\")\n     ConfigKey<String> MANAGEMENT_CIDR = new BasicConfigKey<String>(String.class,\n-            \"bind.access.cidr\", \"Subnet CIDR allowed to access DNS\", \"0.0.0.0/0\");\n-            // TODO should default be a /0, or 'any', or use brooklyn management CIDR?\n+            \"bind.access.cidr\", \"Subnet CIDR or ACL allowed to access DNS\", \"0.0.0.0/0\");\n \n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     @SetFromFlag(\"hostnameSensor\")\n@@ -82,6 +83,14 @@\n             \"bind.template.named-conf\", \"The BIND named configuration file (as FreeMarker template)\",\n             \"classpath://brooklyn/entity/network/bind/named.conf\");\n \n+    /* Reverse lookup attributes. */\n+\n+    AttributeSensor<Cidr> REVERSE_LOOKUP_CIDR = new BasicAttributeSensor<Cidr>(Cidr.class,\n+            \"bind.reverse-lookup.cidr\", \"The network CIDR that hosts must have for reverse lookup entriers to be added (default uses server address /24)\");\n+\n+    AttributeSensor<String> REVERSE_LOOKUP_DOMAIN = new BasicAttributeSensor<String>(String.class,\n+            \"bind.reverse-lookup.domain\", \"The in-addr.arpa reverse lookup domain name\");\n+\n     /* Configuration applicable to clients of the BIND DNS service. */\n \n     @SetFromFlag(\"replaceResolvConf\")",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/08e185c2a11d466a1198625764c641905830d5d2/software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServer.java",
                "sha": "271e898bac199988041f3e2eee2b5712b633937b",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/08e185c2a11d466a1198625764c641905830d5d2/software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServerImpl.java",
                "changes": 34,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServerImpl.java?ref=08e185c2a11d466a1198625764c641905830d5d2",
                "deletions": 16,
                "filename": "software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServerImpl.java",
                "patch": "@@ -16,8 +16,6 @@\n package brooklyn.entity.network.bind;\n \n import java.io.ByteArrayInputStream;\n-import java.net.InetAddress;\n-import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -67,7 +65,6 @@\n     private Multimap<Location, Entity> entityLocations = HashMultimap.create();\n     private ConcurrentMap<String, String> addressMappings = Maps.newConcurrentMap();\n     private ConcurrentMap<String, String> reverseMappings = Maps.newConcurrentMap();\n-    private Cidr reverseNetwork;\n \n     public BindDnsServerImpl() {\n         super();\n@@ -89,11 +86,12 @@ public long getSerial() {\n         return serial.incrementAndGet();\n     }\n \n+    public Cidr getReverseLookupNetwork() {\n+        return getAttribute(REVERSE_LOOKUP_CIDR);\n+    }\n+\n     public String getReverseLookupDomain() {\n-        String reverse = getConfig(REVERSE_LOOKUP_NETWORK);\n-        if (Strings.isBlank(reverse)) reverse = getAttribute(ADDRESS);\n-        reverseNetwork = new Cidr(reverse + \"/24\");\n-        return Joiner.on('.').join(Iterables.skip(Lists.reverse(Lists.newArrayList(Splitter.on('.').split(reverse))), 1)) + \" .in-addr.arpa\";\n+        return getAttribute(REVERSE_LOOKUP_DOMAIN);\n     }\n \n     @Override\n@@ -134,6 +132,12 @@ public void disconnectSensors() {\n \n     @Override\n     protected void preStart() {\n+        String reverse = getConfig(REVERSE_LOOKUP_NETWORK);\n+        if (Strings.isBlank(reverse)) reverse = getAttribute(ADDRESS);\n+        setAttribute(REVERSE_LOOKUP_CIDR, new Cidr(reverse + \"/24\"));\n+        String reverseLookupDomain = Joiner.on('.').join(Iterables.skip(Lists.reverse(Lists.newArrayList(Splitter.on('.').split(reverse))), 1)) + \".in-addr.arpa\";\n+        setAttribute(REVERSE_LOOKUP_DOMAIN, reverseLookupDomain);\n+\n         Map<?, ?> flags = MutableMap.builder()\n                 .put(\"name\", \"Address tracker\")\n                 .put(\"sensorsToTrack\", ImmutableSet.of(getConfig(HOSTNAME_SENSOR)))\n@@ -142,14 +146,16 @@ protected void preStart() {\n             @Override\n             protected void onEntityChange(Entity member) { added(member); }\n             @Override\n-            protected void onEntityAdded(Entity member) { added(member); }\n+            protected void onEntityAdded(Entity member) {\n+                if (Strings.isNonBlank(member.getAttribute(getConfig(HOSTNAME_SENSOR)))) added(member); // Ignore, unless hostname set\n+            }\n             @Override\n             protected void onEntityRemoved(Entity member) { removed(member); }\n         };\n \n         // For any entities that have already come up\n         for (Entity member : entities.getMembers()) {\n-            added(member);\n+            if (Strings.isNonBlank(member.getAttribute(getConfig(HOSTNAME_SENSOR)))) added(member); // Ignore, unless hostname set\n         }\n \n         addPolicy(policy);\n@@ -171,7 +177,7 @@ public void added(Entity member) {\n                 if (!entityLocations.containsKey(machine)) {\n                     entityLocations.put(machine, member);\n                     addressMappings.putIfAbsent(address, hostname);\n-                    if (reverseNetwork.contains(new Cidr(address + \"/32\"))) {\n+                    if (getReverseLookupNetwork().contains(new Cidr(address + \"/32\"))) {\n                         String octet = Iterables.get(Splitter.on('.').split(address), 3);\n                         reverseMappings.putIfAbsent(hostname, octet);\n                     }\n@@ -181,8 +187,6 @@ public void added(Entity member) {\n                     configure(machine);\n                     LOG.info(\"{} added at location {} with name {}\", new Object[] { member, machine, hostname });\n                 }\n-            } else {\n-                LOG.warn(\"added({}) called but entity not ready\", member);\n             }\n         }\n     }\n@@ -208,12 +212,10 @@ private Location findLocation(Entity member) {\n                     return entry.getKey();\n                 }\n             }\n-            return null;\n-        } else {\n-            return null;\n         }\n+        return null;\n     }\n-    \n+\n     public void update() {\n         Optional<Location> location = Iterables.tryFind(getLocations(), Predicates.instanceOf(SshMachineLocation.class));\n         SshMachineLocation machine = (SshMachineLocation) location.get();",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/08e185c2a11d466a1198625764c641905830d5d2/software/network/src/main/java/brooklyn/entity/network/bind/BindDnsServerImpl.java",
                "sha": "6ab00b68adf0e39a92ce61eeb5260b6c4935ae91",
                "status": "modified"
            }
        ],
        "message": "Review changes for #810 including fix for NPE and adding new reverse lookup attributes",
        "parent": "https://github.com/apache/brooklyn-library/commit/cd3e70ff53fdc46f96d65dfc837ad561b804d5c4",
        "patched_files": [
            "BindDnsServerImpl.java"
        ],
        "repo": "brooklyn-library",
        "unit_tests": [
            "TestBindDnsServerImpl.java"
        ]
    },
    "brooklyn-library_113d039": {
        "bug_id": "brooklyn-library_113d039",
        "commit": "https://github.com/apache/brooklyn-library/commit/113d0392c00cdcb6810bc58780b9b846ad2c4e8a",
        "file": [
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNode.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNode.java?ref=113d0392c00cdcb6810bc58780b9b846ad2c4e8a",
                "deletions": 9,
                "filename": "software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNode.java",
                "patch": "@@ -8,12 +8,14 @@\n import brooklyn.entity.basic.MethodEffector;\n import brooklyn.entity.basic.SoftwareProcess;\n import brooklyn.entity.proxying.ImplementedBy;\n+import brooklyn.entity.webapp.WebAppService;\n import brooklyn.entity.webapp.WebAppServiceConstants;\n import brooklyn.event.AttributeSensor;\n import brooklyn.event.basic.BasicAttributeSensorAndConfigKey;\n import brooklyn.event.basic.PortAttributeSensorAndConfigKey;\n import brooklyn.event.basic.Sensors;\n import brooklyn.util.flags.SetFromFlag;\n+import brooklyn.util.text.ByteSizeStrings;\n \n @ImplementedBy(CouchbaseNodeImpl.class)\n public interface CouchbaseNode extends SoftwareProcess {\n@@ -78,27 +80,33 @@\n             \"Retrieved from pools/nodes/<current node>/interestingStats/cmd_get\");\n     AttributeSensor<Integer> CURR_ITEMS_TOT = Sensors.newIntegerSensor(\"couchbase.stats.curr.items.tot\", \n             \"Retrieved from pools/nodes/<current node>/interestingStats/curr_items_tot\");\n+\n     \n-    // this class is added because the ROOT_URL relies on a static initialization which unfortunately\n-    // can't be added to\n-    // an interface.\n     class RootUrl {\n-        public static final AttributeSensor<String> ROOT_URL = Sensors.newStringSensor(\"webapp.url\", \"URL\");\n-\n+        public static final AttributeSensor<String> ROOT_URL = WebAppService.ROOT_URL;\n+        \n         static {\n-            RendererHints.register(ROOT_URL, new RendererHints.NamedActionWithUrl(\"Open\"));\n+            // ROOT_URL does not need init because it refers to something already initialized\n             RendererHints.register(COUCHBASE_WEB_ADMIN_URL, new RendererHints.NamedActionWithUrl(\"Open\"));\n+\n+            RendererHints.register(COUCH_DOCS_DATA_SIZE, RendererHints.displayValue(ByteSizeStrings.metric()));\n+            RendererHints.register(COUCH_DOCS_ACTUAL_DISK_SIZE, RendererHints.displayValue(ByteSizeStrings.metric()));\n+            RendererHints.register(MEM_USED, RendererHints.displayValue(ByteSizeStrings.metric()));\n+            RendererHints.register(COUCH_VIEWS_ACTUAL_DISK_SIZE, RendererHints.displayValue(ByteSizeStrings.metric()));\n+            RendererHints.register(COUCH_VIEWS_DATA_SIZE, RendererHints.displayValue(ByteSizeStrings.metric()));\n         }\n     }\n+    \n+    // this long-winded reference is done just to trigger the initialization above\n+    AttributeSensor<String> ROOT_URL = RootUrl.ROOT_URL;\n \n-    public static final MethodEffector<Void> SERVER_ADD = new MethodEffector<Void>(CouchbaseNode.class, \"serverAdd\");\n-    public static final MethodEffector<Void> REBALANCE = new MethodEffector<Void>(CouchbaseNode.class, \"rebalance\");\n+    MethodEffector<Void> SERVER_ADD = new MethodEffector<Void>(CouchbaseNode.class, \"serverAdd\");\n+    MethodEffector<Void> REBALANCE = new MethodEffector<Void>(CouchbaseNode.class, \"rebalance\");\n \n     @Effector(description = \"add a server to a cluster\")\n     public void serverAdd(@EffectorParam(name = \"serverHostname\") String serverToAdd, @EffectorParam(name = \"username\") String username, @EffectorParam(name = \"password\") String password);\n \n     @Effector(description = \"rebalance the couchbase cluster\")\n     public void rebalance();\n \n-\n }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNode.java",
                "sha": "46b49f5cd5fb10cd194ea0f4a7502174a7bf9f71",
                "status": "modified"
            },
            {
                "additions": 41,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNodeImpl.java",
                "changes": 93,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNodeImpl.java?ref=113d0392c00cdcb6810bc58780b9b846ad2c4e8a",
                "deletions": 52,
                "filename": "software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNodeImpl.java",
                "patch": "@@ -8,6 +8,7 @@\n \n import brooklyn.entity.basic.Attributes;\n import brooklyn.entity.basic.SoftwareProcessImpl;\n+import brooklyn.event.AttributeSensor;\n import brooklyn.event.SensorEvent;\n import brooklyn.event.SensorEventListener;\n import brooklyn.event.feed.http.HttpFeed;\n@@ -19,6 +20,9 @@\n import brooklyn.location.cloud.CloudLocationConfig;\n import brooklyn.util.collections.MutableSet;\n import brooklyn.util.config.ConfigBag;\n+import brooklyn.util.guava.Functionals;\n+import brooklyn.util.guava.MaybeFunctions;\n+import brooklyn.util.guava.TypeTokens;\n import brooklyn.util.http.HttpToolResponse;\n \n import com.google.common.base.Function;\n@@ -88,26 +92,35 @@ public void rebalance() {\n         getDriver().rebalance();\n     }\n \n+    protected final static Function<HttpToolResponse, JsonElement> GET_THIS_NODE_STATS = Functionals.chain(\n+        HttpValueFunctions.jsonContents(), \n+        JsonFunctions.walk(\"nodes\"), \n+        new Function<JsonElement, JsonElement>() {\n+            @Override public JsonElement apply(JsonElement input) {\n+                JsonArray nodes = input.getAsJsonArray();\n+                for (JsonElement element : nodes) {\n+                    JsonElement thisNode = element.getAsJsonObject().get(\"thisNode\");\n+                    if (thisNode!=null && Boolean.TRUE.equals(thisNode.getAsBoolean())) {\n+                        return element.getAsJsonObject().get(\"interestingStats\");\n+                    }\n+                }\n+                return null;\n+        }}\n+    );\n+    \n+    protected final static <T> HttpPollConfig<T> getSensorFromNodeStat(AttributeSensor<T> sensor, String ...jsonPath) {\n+        return new HttpPollConfig<T>(sensor)\n+            .onSuccess(Functionals.chain(GET_THIS_NODE_STATS, \n+                MaybeFunctions.<JsonElement>wrap(), \n+                JsonFunctions.walkM(jsonPath), \n+                JsonFunctions.castM(TypeTokens.getRawRawType(sensor.getTypeToken()), null)))\n+            .onFailureOrException(Functions.<T>constant(null));\n+    }\n \n     public void connectSensors() {\n         super.connectSensors();\n         connectServiceUpIsRunning();\n-        \n-        Function<HttpToolResponse, JsonElement> getThisNodesStats = HttpValueFunctions.chain(\n-            HttpValueFunctions.jsonContents(), \n-            JsonFunctions.walk(\"nodes\"), \n-            new Function<JsonElement, JsonElement>() {\n-                @Override public JsonElement apply(JsonElement input) {\n-                    JsonArray nodes = input.getAsJsonArray();\n-                    for (JsonElement element : nodes) {\n-                        if (Boolean.TRUE.equals(element.getAsJsonObject().get(\"thisNode\").getAsBoolean())) {\n-                            return element.getAsJsonObject().get(\"interestingStats\");\n-                        }\n-                    }\n-                    return null;\n-            }}\n-        );\n-        \n+                \n         Integer rawPort = getAttribute(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT);\n         Preconditions.checkNotNull(rawPort, \"HTTP_PORT sensors not set for %s; is an acceptable port available?\", this);\n         HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, rawPort);\n@@ -119,42 +132,18 @@ public void connectSensors() {\n             .period(1000)\n             .baseUri(adminUrl + \"/pools/nodes/\")\n             .credentialsIfNotNull(getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME), getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.OPS)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"ops\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.COUCH_DOCS_DATA_SIZE)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"couch_docs_data_size\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.COUCH_DOCS_ACTUAL_DISK_SIZE)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"couch_docs_actual_disk_size\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.EP_BG_FETCHED)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"ep_bg_fetched\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.MEM_USED)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"mem_used\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.COUCH_VIEWS_ACTUAL_DISK_SIZE)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"couch_views_actual_disk_size\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.CURR_ITEMS)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"curr_items\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.VB_REPLICA_CURR_ITEMS)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"vb_replica_curr_items\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.COUCH_VIEWS_DATA_SIZE)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"couch_views_data_size\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.GET_HITS)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"get_hits\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.CMD_GET)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"cmd_get\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n-            .poll(new HttpPollConfig<Integer>(CouchbaseNode.CURR_ITEMS_TOT)\n-                    .onSuccess(HttpValueFunctions.chain(getThisNodesStats, JsonFunctions.walk(\"curr_items_tot\"), JsonFunctions.cast(Integer.class)))\n-                    .onFailureOrException(Functions.<Integer>constant(null)))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.OPS, \"ops\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_DOCS_DATA_SIZE, \"couch_docs_data_size\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_DOCS_ACTUAL_DISK_SIZE, \"couch_docs_actual_disk_size\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.EP_BG_FETCHED, \"ep_bg_fetched\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.MEM_USED, \"mem_used\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_VIEWS_ACTUAL_DISK_SIZE, \"couch_views_actual_disk_size\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.CURR_ITEMS, \"curr_items\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.VB_REPLICA_CURR_ITEMS, \"vb_replica_curr_items\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_VIEWS_DATA_SIZE, \"couch_views_data_size\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.GET_HITS, \"get_hits\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.CMD_GET, \"cmd_get\"))\n+            .poll(getSensorFromNodeStat(CouchbaseNode.CURR_ITEMS_TOT, \"curr_items_tot\"))\n             .build();\n     }\n ",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/nosql/src/main/java/brooklyn/entity/nosql/couchbase/CouchbaseNodeImpl.java",
                "sha": "06d9c187688fc6e83e67f3561749e028f71de1d0",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java?ref=113d0392c00cdcb6810bc58780b9b846ad2c4e8a",
                "deletions": 2,
                "filename": "software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java",
                "patch": "@@ -1,9 +1,11 @@\n package brooklyn.entity.webapp;\n \n+import brooklyn.config.render.RendererHints;\n import brooklyn.entity.group.DynamicCluster;\n import brooklyn.entity.proxying.ImplementedBy;\n import brooklyn.event.AttributeSensor;\n import brooklyn.event.basic.BasicAttributeSensor;\n+import brooklyn.util.time.Duration;\n \n /**\n  * DynamicWebAppClusters provide cluster-wide aggregates of entity attributes.  Currently totals and averages:\n@@ -29,10 +31,17 @@\n     public static final AttributeSensor<Double> REQUESTS_PER_SECOND_IN_WINDOW_PER_NODE = new BasicAttributeSensor<Double>(\n             Double.class, \"webapp.reqs.perSec.windowed.perNode\", \"Reqs/sec (over time window) averaged over all nodes\");\n \n-    public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME_PER_NODE = new BasicAttributeSensor<Integer>(\n-            Integer.class, \"webapp.reqs.processingTime.perNode\", \"Total processing time per node\");\n+    public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME_PER_NODE = ApplyDisplayHints.TOTAL_PROCESSING_TIME_PER_NODE;\n \n     public static final AttributeSensor<Double> PROCESSING_TIME_FRACTION_IN_WINDOW_PER_NODE = new BasicAttributeSensor<Double>(\n             Double.class, \"webapp.reqs.processingTime.fraction.windowed.perNode\", \"Fraction of time spent processing reported by webserver (percentage, over time window) averaged over all nodes\");\n \n+    class ApplyDisplayHints {\n+        public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME_PER_NODE = new BasicAttributeSensor<Integer>(\n+            Integer.class, \"webapp.reqs.processingTime.perNode\", \"Total processing time per node (millis)\");\n+        static {\n+            RendererHints.register(TOTAL_PROCESSING_TIME_PER_NODE, RendererHints.displayValue(Duration.millisToStringRounded()));\n+        }\n+    }\n+\n }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java",
                "sha": "19f320d4ef5594deb7ac1f374395eb650300b95f",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabric.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabric.java?ref=113d0392c00cdcb6810bc58780b9b846ad2c4e8a",
                "deletions": 7,
                "filename": "software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabric.java",
                "patch": "@@ -23,12 +23,8 @@\n     public static final AttributeSensor<Integer> ERROR_COUNT_PER_NODE = new BasicAttributeSensor<Integer>(\n             Integer.class, \"webapp.reqs.errors.perNode\", \"Fabric entity request error average\");\n \n-    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_LAST_PER_NODE = new BasicAttributeSensor<Double>(\n-            Double.class, \"webapp.reqs.perSec.last.perNode\", \"Reqs/sec (last datapoint) averaged over all nodes\");\n+    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_LAST_PER_NODE = DynamicWebAppCluster.REQUESTS_PER_SECOND_LAST_PER_NODE;\n+    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_IN_WINDOW_PER_NODE = DynamicWebAppCluster.REQUESTS_PER_SECOND_IN_WINDOW_PER_NODE;\n+    public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME_PER_NODE = DynamicWebAppCluster.TOTAL_PROCESSING_TIME_PER_NODE;\n \n-    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_IN_WINDOW_PER_NODE = new BasicAttributeSensor<Double>(\n-            Double.class, \"webapp.reqs.perSec.windowed.perNode\", \"Reqs/sec (over time window) averaged over all nodes\");\n-\n-    public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME_PER_NODE = new BasicAttributeSensor<Integer>(\n-            Integer.class, \"webapp.reqs.processingTime.perNode\", \"Total processing time per node\");\n }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabric.java",
                "sha": "b1c75cfc9d3cc63c0dda56536244def7413640e3",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java?ref=113d0392c00cdcb6810bc58780b9b846ad2c4e8a",
                "deletions": 0,
                "filename": "software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java",
                "patch": "@@ -10,6 +10,8 @@\n import brooklyn.event.basic.PortAttributeSensorAndConfigKey;\n import brooklyn.event.basic.Sensors;\n import brooklyn.util.flags.SetFromFlag;\n+import brooklyn.util.text.ByteSizeStrings;\n+import brooklyn.util.time.Duration;\n \n import com.google.common.collect.ImmutableList;\n \n@@ -71,5 +73,9 @@\n \n     static {\n         RendererHints.register(ROOT_URL, new RendererHints.NamedActionWithUrl(\"Open\"));\n+        RendererHints.register(WebAppServiceConstants.TOTAL_PROCESSING_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));\n+        RendererHints.register(WebAppServiceConstants.MAX_PROCESSING_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));\n+        RendererHints.register(WebAppServiceConstants.BYTES_RECEIVED, RendererHints.displayValue(ByteSizeStrings.metric()));\n+        RendererHints.register(WebAppServiceConstants.BYTES_SENT, RendererHints.displayValue(ByteSizeStrings.metric()));\n     }\n }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/113d0392c00cdcb6810bc58780b9b846ad2c4e8a/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java",
                "sha": "91a46e2cd91158aeeddcb8d2b2d8b07069aed1a4",
                "status": "modified"
            }
        ],
        "message": "Merge pull request #1474 from ahgittin/couchbase\n\nCouchbase code tidy, nicer way to define sensors, and prevent NPE's, using new `Functionals`",
        "parent": "https://github.com/apache/brooklyn-library/commit/70f2e77d071e6e662b908a67ab8ca3cd498f465a",
        "patched_files": [
            "DynamicWebAppCluster.java",
            "DynamicWebAppFabric.java"
        ],
        "repo": "brooklyn-library",
        "unit_tests": [
            "DynamicWebAppClusterTest.java",
            "DynamicWebAppFabricTest.java"
        ]
    },
    "brooklyn-library_2a71311": {
        "bug_id": "brooklyn-library_2a71311",
        "commit": "https://github.com/apache/brooklyn-library/commit/2a71311f2a82611b7c8c71526a53380fbc42b744",
        "file": [
            {
                "additions": 81,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/2a71311f2a82611b7c8c71526a53380fbc42b744/software/webapp/src/main/java/brooklyn/entity/dns/AbstractGeoDnsServiceImpl.java",
                "changes": 117,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/main/java/brooklyn/entity/dns/AbstractGeoDnsServiceImpl.java?ref=2a71311f2a82611b7c8c71526a53380fbc42b744",
                "deletions": 36,
                "filename": "software/webapp/src/main/java/brooklyn/entity/dns/AbstractGeoDnsServiceImpl.java",
                "patch": "@@ -5,6 +5,7 @@\n import java.net.InetAddress;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.net.UnknownHostException;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -47,11 +48,17 @@\n \n     protected Map<Entity, HostGeoInfo> targetHosts = Collections.synchronizedMap(new LinkedHashMap<Entity, HostGeoInfo>());\n     \n-    // We complain when we encounter a target entity for whom we can't derive geo information; the commonest case is a\n-    // transient condition between the time the entity is created and the time it is started (at which point the location is\n-    // specified). This set contains those entities we've complained about already, to avoid repetitive logging.\n+    // We complain (at debug) when we encounter a target entity for whom we can't derive hostname/ip information; \n+    // this is the commonest case for the transient condition between the time the entity is created and the time \n+    // it is started (at which point the location is specified). This set contains those entities we've complained \n+    // about already, to avoid repetitive logging.\n+    transient protected Set<Entity> entitiesWithoutHostname = new HashSet<Entity>();\n+\n+    // We complain (at info/warn) when we encounter a target entity for whom we can't derive geo information, even \n+    // when hostname/ip is known. This set contains those entities we've complained about already, to avoid repetitive \n+    // logging.\n     transient protected Set<Entity> entitiesWithoutGeoInfo = new HashSet<Entity>();\n-    \n+\n     public AbstractGeoDnsServiceImpl() {\n         super();\n     }\n@@ -170,53 +177,58 @@ protected void refreshGroupMembership() {\n     \n     /**\n      * Adds this host, if it is absent or if its hostname has changed.\n-     *  \n+     * \n+     * For whether to use hostname or ip, see config and attributes {@link AbstractGeoDnsService#USE_HOSTNAMES}, \n+     * {@link Attributes#HOSTNAME} and {@link Attributes#ADDRESS} (via {@link #inferHostname(Entity)} and {@link #inferIp(Entity)}.\n+     * Note that the \"hostname\" could infact be an IP address, if {@link #inferHostname(Entity)} returns an IP!\n+     * <p>\n+     * The \"hostname\" is always preferred for inferring the geo info, if it is available. The {@code USE_HOSTNAMES==false} \n+     * is just used to say whether to fall back to IP if that is not available (and whether to switch the the geo-info so it\n+     * refs the IP instead of the hostname).\n+     * \n+     * TODO in a future release, we may change this to explicitly set the sensor(s) to look at on the entity, and \n+     * be stricter about using them in order.\n+     * \n      * @return true if host is added or changed\n      */\n-    protected boolean addTargetHost(Entity e) {\n+    protected boolean addTargetHost(Entity entity) {\n         try {\n-            HostGeoInfo oldGeo = targetHosts.get(e);\n-            String hostname = inferHostname(e);\n-            String ip = inferIp(e);\n-            HostGeoInfo geoH = (hostname == null) ? null : HostGeoInfo.fromIpAddress(InetAddress.getByName(hostname));\n-            HostGeoInfo geoE = HostGeoInfo.fromEntity(e);\n-\n-            // Switch to IP address if that's what we're configured to use, and it's available\n-            if (!getConfig(USE_HOSTNAMES) && ip != null) {\n-                geoH = HostGeoInfo.create(ip, geoH.displayName, geoH.latitude, geoH.longitude);\n-            }\n-            \n-            if (hostname == null || (!getConfig(USE_HOSTNAMES) && ip!=null)) hostname = ip;\n+            HostGeoInfo oldGeo = targetHosts.get(entity);\n+            String hostname = inferHostname(entity);\n+            String ip = inferIp(entity);\n+            String addr = (getConfig(USE_HOSTNAMES) || ip == null) ? hostname : ip;\n+            HostGeoInfo geoE = HostGeoInfo.fromEntity(entity);\n+            HostGeoInfo geoH = inferHostGeoInfo(hostname, ip);\n             \n-            if (hostname == null) {\n-                if (entitiesWithoutGeoInfo.add(e)) {\n-                    log.debug(\"GeoDns ignoring {}, will continue scanning (no hostname or URL available)\", e);\n+            if (addr == null) {\n+                if (entitiesWithoutHostname.add(entity)) {\n+                    log.debug(\"GeoDns ignoring {}, will continue scanning (no hostname or URL available)\", entity);\n                 }\n                 return false;\n             }\n             \n-            if (Networking.isPrivateSubnet(hostname)) {\n+            if (Networking.isPrivateSubnet(addr)) {\n                 if (getConfig(INCLUDE_HOMELESS_ENTITIES)) {\n-                    if (entitiesWithoutGeoInfo.add(e)) {\n-                        log.info(\"GeoDns including {}, even though {} is a private subnet (homeless entities included)\", e, hostname);\n+                    if (entitiesWithoutGeoInfo.add(entity)) {\n+                        log.info(\"GeoDns including {}, even though {} is a private subnet (homeless entities included)\", entity, addr);\n                     }\n                 } else {\n-                    if (entitiesWithoutGeoInfo.add(e)) {\n-                        log.warn(\"GeoDns ignoring {} (private subnet detected for {})\", e, hostname);\n+                    if (entitiesWithoutGeoInfo.add(entity)) {\n+                        log.warn(\"GeoDns ignoring {} (private subnet detected for {})\", entity, addr);\n                     }\n                     return false;\n                 }\n             }\n             \n             if (geoH == null) {\n                 if (getConfig(INCLUDE_HOMELESS_ENTITIES)) {\n-                    if (entitiesWithoutGeoInfo.add(e)) {\n-                        log.info(\"GeoDns including {}, even though no geography info available for {})\", e, hostname);\n+                    if (entitiesWithoutGeoInfo.add(entity)) {\n+                        log.info(\"GeoDns including {}, even though no geography info available for {})\", entity, addr);\n                     }\n-                    geoH = (geoE != null) ? geoE : HostGeoInfo.create(hostname, \"unknownLocation(\"+hostname+\")\", 0, 0);\n+                    geoH = (geoE != null) ? geoE : HostGeoInfo.create(addr, \"unknownLocation(\"+addr+\")\", 0, 0);\n                 } else {\n-                    if (entitiesWithoutGeoInfo.add(e)) {\n-                        log.warn(\"GeoDns ignoring {} (no geography info available for {})\", e, hostname);\n+                    if (entitiesWithoutGeoInfo.add(entity)) {\n+                        log.warn(\"GeoDns ignoring {} (no geography info available for {})\", entity, addr);\n                     }\n                     return false;\n                 }\n@@ -231,17 +243,18 @@ protected boolean addTargetHost(Entity e) {\n             if (geoE != null) {\n                 if ((Math.abs(geoH.latitude-geoE.latitude)>3) ||\n                         (Math.abs(geoH.longitude-geoE.longitude)>3) ) {\n-                    log.warn(\"GeoDns mismatch, {} is in {} but hosts URL in {}\", new Object[] {e, geoE, geoH});\n+                    log.warn(\"GeoDns mismatch, {} is in {} but hosts URL in {}\", new Object[] {entity, geoE, geoH});\n                 }\n             }\n             \n-            entitiesWithoutGeoInfo.remove(e);\n-            log.info(\"GeoDns adding \"+e+\" at \"+geoH+(oldGeo != null ? \" (previously \"+oldGeo+\")\" : \"\"));\n-            targetHosts.put(e, geoH);\n+            entitiesWithoutHostname.remove(entity);\n+            entitiesWithoutGeoInfo.remove(entity);\n+            log.info(\"GeoDns adding \"+entity+\" at \"+geoH+(oldGeo != null ? \" (previously \"+oldGeo+\")\" : \"\"));\n+            targetHosts.put(entity, geoH);\n             return true;\n \n         } catch (Exception ee) {\n-            log.warn(\"GeoDns ignoring {} (error analysing location, {}\", e, ee);\n+            log.warn(\"GeoDns ignoring {} (error analysing location, {}\", entity, ee);\n             return false;\n         }\n     }\n@@ -301,4 +314,36 @@ protected String inferHostname(Entity entity) {\n     protected String inferIp(Entity entity) {\n         return entity.getAttribute(Attributes.ADDRESS);\n     }\n+    \n+    protected HostGeoInfo inferHostGeoInfo(String hostname, String ip) throws UnknownHostException {\n+        // Look up the geo-info from the hostname/ip\n+        HostGeoInfo geoH;\n+        try {\n+            InetAddress addr = (hostname == null) ? null : InetAddress.getByName(hostname);\n+            geoH = (addr == null) ? null : HostGeoInfo.fromIpAddress(addr);\n+        } catch (UnknownHostException e) {\n+            if (getConfig(USE_HOSTNAMES) || ip == null) {\n+                throw e;\n+            } else {\n+                if (log.isTraceEnabled()) log.trace(\"GeoDns failed to infer GeoInfo from hostname {}; will try with IP {} ({})\", new Object[] {hostname, ip, e});\n+                geoH = null;\n+            }\n+        }\n+\n+        // Switch to IP address if that's what we're configured to use, and it's available\n+        if (!getConfig(USE_HOSTNAMES) && ip != null) {\n+            if (geoH == null) {\n+                InetAddress addr = Networking.getInetAddressWithFixedName(ip);\n+                geoH = HostGeoInfo.fromIpAddress(addr);\n+                if (log.isTraceEnabled()) log.trace(\"GeoDns inferred GeoInfo {} from ip {} (could not infer from hostname {})\", new Object[] {geoH, ip, hostname});\n+            } else {\n+                geoH = HostGeoInfo.create(ip, geoH.displayName, geoH.latitude, geoH.longitude);\n+                if (log.isTraceEnabled()) log.trace(\"GeoDns inferred GeoInfo {} from hostname {}; switching it to ip {}\", new Object[] {geoH, hostname, ip});\n+            }\n+        } else {\n+            if (log.isTraceEnabled()) log.trace(\"GeoDns inferred GeoInfo {} from hostname {}\", geoH, hostname);\n+        }\n+        \n+        return geoH;\n+    }\n }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/2a71311f2a82611b7c8c71526a53380fbc42b744/software/webapp/src/main/java/brooklyn/entity/dns/AbstractGeoDnsServiceImpl.java",
                "sha": "d22a88a9fe37b4b90de59535a8bd4a59bc745300",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/2a71311f2a82611b7c8c71526a53380fbc42b744/software/webapp/src/test/java/brooklyn/entity/dns/geoscaling/GeoscalingIntegrationTest.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/test/java/brooklyn/entity/dns/geoscaling/GeoscalingIntegrationTest.java?ref=2a71311f2a82611b7c8c71526a53380fbc42b744",
                "deletions": 1,
                "filename": "software/webapp/src/test/java/brooklyn/entity/dns/geoscaling/GeoscalingIntegrationTest.java",
                "patch": "@@ -92,6 +92,9 @@ public void tearDown() throws Exception {\n     \n     @Test(groups={\"Integration\"})\n     public void testRoutesToExpectedLocation() {\n+        // Without this config, running on a home network (i.e. no public IP) the entity will have a private IP and will be ignored\n+        ((EntityLocal)geoDns).setConfig(GeoscalingDnsService.INCLUDE_HOMELESS_ENTITIES, true);\n+        \n         target.setAttribute(Attributes.HOSTNAME,addrWithGeo.getHostName());\n         \n         app.start(ImmutableList.of(locWithGeo));\n@@ -121,12 +124,14 @@ public void testIgnoresAddressWithoutGeography() {\n     public void testIncludesAddressWithoutGeography() {\n         System.setProperty(BrooklynSystemProperties.HOST_GEO_LOOKUP_IMPL.getPropertyName(), StubHostGeoLookup.class.getName());\n         ((EntityLocal)geoDns).setConfig(GeoscalingDnsService.INCLUDE_HOMELESS_ENTITIES, true);\n-        target.setAttribute(Attributes.HOSTNAME, StubHostGeoLookup.HOMELESS_IP);\n+        //target.setAttribute(Attributes.HOSTNAME, StubHostGeoLookup.HOMELESS_IP);\n         \n         app.start(ImmutableList.of(locWithoutGeo));\n         \n         LOG.info(\"geo-scaling test, using {}.{}; expect to be wired to {}\", new Object[] {subDomain, primaryDomain, addrWithoutGeo});\n         \n+        target.setAttribute(Attributes.HOSTNAME, StubHostGeoLookup.HOMELESS_IP);\n+        \n         assertTargetHostsEventually(geoDns, 1);\n     }\n ",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/2a71311f2a82611b7c8c71526a53380fbc42b744/software/webapp/src/test/java/brooklyn/entity/dns/geoscaling/GeoscalingIntegrationTest.java",
                "sha": "cb5dd20ce94e1aa1ce089fc007cc20f95120ba21",
                "status": "modified"
            }
        ],
        "message": "Cleanup AbstractGeoDnsService.addTargetHost\n\n- avoid NPE when hostname==null and ip!=null, and !USE_HOSTNAMES\n- improve logging, so if log about hostname missing and then subsequent\n  can't infer geo, then still log about the latter.\n- general code cleanup; but more could be done.",
        "parent": "https://github.com/apache/brooklyn-library/commit/c58c63f7153f71bd26d565f78a865029d25f7f4e",
        "patched_files": [
            "AbstractGeoDnsServiceImpl.java"
        ],
        "repo": "brooklyn-library",
        "unit_tests": [
            "GeoscalingIntegrationTest.java"
        ]
    },
    "brooklyn-library_389eb0c": {
        "bug_id": "brooklyn-library_389eb0c",
        "commit": "https://github.com/apache/brooklyn-library/commit/389eb0c962a612327cb3ceb802aaa0c115070275",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/389eb0c962a612327cb3ceb802aaa0c115070275/software/messaging/src/main/java/brooklyn/entity/messaging/rabbit/RabbitSshDriver.groovy",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/messaging/src/main/java/brooklyn/entity/messaging/rabbit/RabbitSshDriver.groovy?ref=389eb0c962a612327cb3ceb802aaa0c115070275",
                "deletions": 1,
                "filename": "software/messaging/src/main/java/brooklyn/entity/messaging/rabbit/RabbitSshDriver.groovy",
                "patch": "@@ -1,15 +1,19 @@\n package brooklyn.entity.messaging.rabbit;\n \n+import static java.lang.String.format;\n import static brooklyn.entity.basic.lifecycle.CommonCommands.*\n \n import org.slf4j.Logger\n import org.slf4j.LoggerFactory\n \n import brooklyn.entity.basic.AbstractSoftwareProcessSshDriver\n+import brooklyn.entity.basic.lifecycle.CommonCommands\n import brooklyn.entity.messaging.amqp.AmqpServer\n import brooklyn.location.basic.SshMachineLocation\n import brooklyn.util.NetworkUtils\n \n+import com.google.common.collect.ImmutableList\n+\n /**\n  * TODO javadoc\n  */\n@@ -35,7 +39,7 @@ public class RabbitSshDriver extends AbstractSoftwareProcessSshDriver implements\n         String url = \"http://www.rabbitmq.com/releases/rabbitmq-server/v${version}/rabbitmq-server-generic-unix-${version}.tar.gz\";\n         String saveAs = \"rabbitmq-server-generic-unix-${version}.tar.gz\";\n \n-        List<String> commands = ImmutableList.builder()\n+        List<String> commands = ImmutableList.<String>builder()\n                 .add(installPackage(\"erlang\", // NOTE only 'port' states the version of Erlang used, maybe remove this constraint?\n                         apt:\"erlang-nox erlang-dev\",\n                         port:\"erlang@${erlangVersion}+ssl\"))",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/389eb0c962a612327cb3ceb802aaa0c115070275/software/messaging/src/main/java/brooklyn/entity/messaging/rabbit/RabbitSshDriver.groovy",
                "sha": "12a95355135a00566f87c50147f92fdd7504603d",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/389eb0c962a612327cb3ceb802aaa0c115070275/software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxUrlMappingIntegrationTest.groovy",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxUrlMappingIntegrationTest.groovy?ref=389eb0c962a612327cb3ceb802aaa0c115070275",
                "deletions": 11,
                "filename": "software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxUrlMappingIntegrationTest.groovy",
                "patch": "@@ -122,19 +122,19 @@ public class NginxUrlMappingIntegrationTest {\n             for (int i = 0; i < 2; i++) {\n                 assertUrlHasText(\"http://localhost1:${port}\", \"Hello\");\n                 assertUrlHasText(\"http://localhost1:${port}/\", \"Hello\");\n-                assertUrlHasText(\"http://localhost1:${port}/hello/frank\", \"http://\"+u0.id+\"/hello/frank\");\n+                assertUrlHasText(\"http://localhost1:${port}/hello/frank\", \"http://localhost1:${port}/hello/frank\");\n             }\n             //cluster 1\n             for (int i = 0; i < 2; i++) {\n                 assertUrlHasText(\"http://localhost2:${port}/hello-world\", \"Hello\");\n                 assertUrlHasText(\"http://localhost2:${port}/hello-world/\", \"Hello\");\n-                assertUrlHasText(\"http://localhost2:${port}/hello-world/hello/bob\", \"http://\"+u1.id+\"/hello-world/hello/bob\");\n+                assertUrlHasText(\"http://localhost2:${port}/hello-world/hello/bob\", \"http://localhost2:${port}/hello-world/hello/bob\");\n             }\n             //cluster 2\n             for (int i = 0; i < 2; i++) {\n                 assertUrlHasText(\"http://localhost3:${port}/c2\", \"Hello\");\n                 assertUrlHasText(\"http://localhost3:${port}/c2/\", \"Hello\");\n-                assertUrlHasText(\"http://localhost3:${port}/c2/hello/joe\", \"http://\"+u2.id+\"/c2/hello/new%20joe\");\n+                assertUrlHasText(\"http://localhost3:${port}/c2/hello/joe\", \"http://localhost3:${port}/c2/hello/new%20joe\");\n             }\n         }\n         \n@@ -273,24 +273,24 @@ public class NginxUrlMappingIntegrationTest {\n         executeUntilSucceeds {\n             // health check\n             assertUrlHasText(\"http://localhost1:${port}\", \"Hello\");\n-            assertUrlHasText(\"http://localhost1:${port}/hello/frank\", \"http://\"+u0.id+\"/hello/frank\");\n+            assertUrlHasText(\"http://localhost1:${port}/hello/frank\", \"http://localhost1:${port}/hello/frank\");\n             \n             // goodbye rewritten to hello\n-            assertUrlHasText(\"http://localhost1:${port}/goodbye/frank\", \"http://\"+u0.id+\"/hello/frank\");\n+            assertUrlHasText(\"http://localhost1:${port}/goodbye/frank\", \"http://localhost1:${port}/hello/frank\");\n             // hello al rewritten to hello Big Al\n-            assertUrlHasText(\"http://localhost1:${port}/hello/aled\", \"http://\"+u0.id+\"/hello/Big%20Aled\");\n+            assertUrlHasText(\"http://localhost1:${port}/hello/aled\", \"http://localhost1:${port}/hello/Big%20Aled\");\n             // hello andrew rewritten to hello Sir Andrew\n-            assertUrlHasText(\"http://localhost1:${port}/hello/andrew\", \"http://\"+u0.id+\"/hello/Sir%20Andrew\");\n+            assertUrlHasText(\"http://localhost1:${port}/hello/andrew\", \"http://localhost1:${port}/hello/Sir%20Andrew\");\n             \n             // goodbye alex rewritten to hello Big Alex (two rewrites)\n-            assertUrlHasText(\"http://localhost1:${port}/goodbye/alex\", \"http://\"+u0.id+\"/hello/Big%20Alex\");\n+            assertUrlHasText(\"http://localhost1:${port}/goodbye/alex\", \"http://localhost1:${port}/hello/Big%20Alex\");\n             // but goodbye andrew rewritten only to hello Andrew -- test the \"break\" logic above (won't continue rewriting)\n-            assertUrlHasText(\"http://localhost1:${port}/goodbye/andrew\", \"http://\"+u0.id+\"/hello/andrew\");\n+            assertUrlHasText(\"http://localhost1:${port}/goodbye/andrew\", \"http://localhost1:${port}/hello/andrew\");\n             \n             // al rewrite can be anywhere\n-            assertUrlHasText(\"http://localhost1:${port}/hello/hello/alex\", \"http://\"+u0.id+\"/hello/hello/Big%20Alex\");\n+            assertUrlHasText(\"http://localhost1:${port}/hello/hello/alex\", \"http://localhost1:${port}/hello/hello/Big%20Alex\");\n             // but an rewrite must be at beginning\n-            assertUrlHasText(\"http://localhost1:${port}/hello/hello/andrew\", \"http://\"+u0.id+\"/hello/hello/andrew\");\n+            assertUrlHasText(\"http://localhost1:${port}/hello/hello/andrew\", \"http://localhost1:${port}/hello/hello/andrew\");\n         }\n     }\n     ",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/389eb0c962a612327cb3ceb802aaa0c115070275/software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxUrlMappingIntegrationTest.groovy",
                "sha": "18934137c6cc8718afa4fea77bf88d54ff6a785f",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/389eb0c962a612327cb3ceb802aaa0c115070275/software/webapp/src/test/java/brooklyn/entity/webapp/ElasticJavaWebAppServiceIntegrationTest.groovy",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/test/java/brooklyn/entity/webapp/ElasticJavaWebAppServiceIntegrationTest.groovy?ref=389eb0c962a612327cb3ceb802aaa0c115070275",
                "deletions": 1,
                "filename": "software/webapp/src/test/java/brooklyn/entity/webapp/ElasticJavaWebAppServiceIntegrationTest.groovy",
                "patch": "@@ -33,6 +33,6 @@ public class ElasticJavaWebAppServiceIntegrationTest {\n         app.start([new LocalhostMachineProvisioningLocation()]);\n         String url = svc.getAttribute(ElasticJavaWebAppService.ROOT_URL);\n         Assert.assertNotNull(url);\n-        HttpTestUtils.assertContentContainsText(url, \"Hello\");\n+        HttpTestUtils.assertContentEventuallyContainsText(url, \"Hello\");\n     }\n }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/389eb0c962a612327cb3ceb802aaa0c115070275/software/webapp/src/test/java/brooklyn/entity/webapp/ElasticJavaWebAppServiceIntegrationTest.groovy",
                "sha": "931b1e193efeefb1d236049d67ae39690b376a59",
                "status": "modified"
            }
        ],
        "message": "Fix integration tests\n\n- NginxUrlMapping: test webapp changed, so writes out original url rather\n  than url-mapping id\n- Fix ElasticJavaWebAppServiceIntegrationTest\n- Avoid NPE in ReflectionScanner if class can't be found\n- fix RabbitSshDriver imports",
        "parent": "https://github.com/apache/brooklyn-library/commit/d32586eef146d117e09fcd8bdc20a2d8f9ac1953",
        "patched_files": [
            "RabbitSshDriver.java"
        ],
        "repo": "brooklyn-library",
        "unit_tests": [
            "NginxUrlMappingIntegrationTest.java",
            "ElasticJavaWebAppServiceIntegrationTest.java"
        ]
    },
    "brooklyn-library_71527c8": {
        "bug_id": "brooklyn-library_71527c8",
        "commit": "https://github.com/apache/brooklyn-library/commit/71527c835600be1ada7ba86da85d94808b3079b4",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/brooklyn-library/blob/71527c835600be1ada7ba86da85d94808b3079b4/software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxRebindIntegrationTest.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxRebindIntegrationTest.java?ref=71527c835600be1ada7ba86da85d94808b3079b4",
                "deletions": 1,
                "filename": "software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxRebindIntegrationTest.java",
                "patch": "@@ -75,7 +75,7 @@ public void tearDown() throws Exception {\n         \tmonitor.terminate();\n         }\n         if (executor != null) executor.shutdownNow();\n-        if (newApp != null) newApp.stop();\n+        if (newApp != null && newApp.getManagementSupport().getManagementContext(true).isManaged(newApp)) newApp.stop();\n         if (origApp != null && origApp.getManagementSupport().getManagementContext(true).isManaged(origApp)) origApp.stop();\n         //if (mementoDir != null) RebindTestUtils.deleteMementoDir(mementoDir);\n     }",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/71527c835600be1ada7ba86da85d94808b3079b4/software/webapp/src/test/java/brooklyn/entity/proxy/nginx/NginxRebindIntegrationTest.java",
                "sha": "fa5103cbf416cbc26cec109f5115b6f18510fc9b",
                "status": "modified"
            }
        ],
        "message": "Supports periodic persist for RebindManager\n\n- Avoids hammering the CPU too much, by continually serializing\n  mementos and persisting them.\n- Fixes NPE in AbstractEntity.invalidate\n- Fixes location rebind, where was overwriting all fields\n  with their default values!\n- In EntityManagementSupport, sets currentlyDeployed before\n  calling onManagementStarting.\n- ScheduledTask: make it useable from java\n- Fixes SoftwareProcessEntity rebind (so provisioningLocation is\n  restored, and stop can subsequently release the machine)",
        "parent": "https://github.com/apache/brooklyn-library/commit/308ad03b30018779d1a251463b78429fcb18a0d4",
        "patched_files": [],
        "repo": "brooklyn-library",
        "unit_tests": [
            "NginxRebindIntegrationTest.java"
        ]
    }
}