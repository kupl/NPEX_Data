{
    "brooklyn-library_023e492": {
        "repo": "brooklyn-library",
        "message": "Improvements for PR #66\n\n* Avoid NPE in in AbstractController.computePortsAndUrls() if inferUrl\n  returns null.\n* Remove some duplication from inferUrl*()\n* Renames inferUrlPublic() to inferUrlForPublic() - and same for subnet\n* testMainUriSensorsCorrectlyComputedWithoutDomain to use machineLocation\n  extending HasSubnetHostname, so subnet address set as expected.\n* Tidy deprecated code and generics in test.",
        "commit": "https://github.com/apache/brooklyn-library/commit/023e49287c8acdb6daf3af171e7e7277b145f63a",
        "parent": "https://github.com/apache/brooklyn-library/commit/313203f0b45d2178fa142167d2b42238544b8dce",
        "bug_id": "brooklyn-library_023e492",
        "file": [
            {
                "sha": "3277e381f59311f97d0ac8ea831497ca2fb9a318",
                "filename": "software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java",
                "blob_url": "https://github.com/apache/brooklyn-library/blob/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java",
                "status": "modified",
                "changes": 72,
                "additions": 41,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/main/java/org/apache/brooklyn/entity/proxy/AbstractControllerImpl.java?ref=023e49287c8acdb6daf3af171e7e7277b145f63a",
                "patch": "@@ -54,6 +54,7 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Objects;\n+import com.google.common.base.Optional;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n@@ -230,7 +231,15 @@ public String getProtocol() {\n     public String getDomain() {\n         return getAttribute(DOMAIN_NAME);\n     }\n-    \n+\n+    protected String getDomainWithoutWildcard() {\n+        String domain = getDomain();\n+        if (domain != null && domain.startsWith(\"*.\")) {\n+            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n+        }\n+        return domain;\n+    }\n+\n     @Override\n     public Integer getPort() {\n         if (isSsl())\n@@ -267,39 +276,21 @@ protected String inferProtocol() {\n         return isSsl() ? \"https\" : \"http\";\n     }\n \n-    protected String inferUrlSubnet() {\n-        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n-        String domain = getDomain();\n-        if (domain != null && domain.startsWith(\"*.\")) {\n-            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n-        }\n-        Integer port = checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n-\n+    protected String inferUrlForSubnet() {\n+        String domain = getDomainWithoutWildcard();\n         if (domain==null) domain = getAttribute(Attributes.SUBNET_ADDRESS);\n-        if (domain==null) return null;\n-        return protocol+\"://\"+domain+\":\"+port+\"/\"+getConfig(SERVICE_UP_URL_PATH);\n+        return inferUrl(domain, Optional.<Integer>absent());\n     }\n \n-    protected String inferUrlPublic() {\n-        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n-        String domain = getDomain();\n-        if (domain != null && domain.startsWith(\"*.\")) {\n-            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n-        }\n-        Integer port = checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n-\n+    protected String inferUrlForPublic() {\n+        String domain = getDomainWithoutWildcard();\n         if (domain==null) domain = getAttribute(Attributes.ADDRESS);\n-        if (domain==null) return null;\n-        return protocol+\"://\"+domain+\":\"+port+\"/\"+getConfig(SERVICE_UP_URL_PATH);\n+        return inferUrl(domain, Optional.<Integer>absent());\n     }\n \n     /** returns URL, if it can be inferred; null otherwise */\n     protected String inferUrl(boolean requireManagementAccessible) {\n-        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n-        String domain = getDomain();\n-        if (domain != null && domain.startsWith(\"*.\")) {\n-            domain = domain.replace(\"*.\", \"\"); // Strip wildcard\n-        }\n+        String domain = getDomainWithoutWildcard();\n         Integer port = checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n         if (requireManagementAccessible) {\n             HostAndPort accessible = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, port);\n@@ -309,8 +300,15 @@ protected String inferUrl(boolean requireManagementAccessible) {\n             }\n         }\n         if (domain==null) domain = Machines.findSubnetHostname(this).orNull();\n-        if (domain==null) return null;\n-        return protocol+\"://\"+domain+\":\"+port+\"/\"+getConfig(SERVICE_UP_URL_PATH);\n+        return inferUrl(domain, Optional.of(port));\n+    }\n+\n+    protected String inferUrl(String host, Optional<Integer> portOverride) {\n+        if (host == null) return null;\n+        String protocol = checkNotNull(getProtocol(), \"no protocol configured\");\n+        int port = portOverride.isPresent() ? portOverride.get() : checkNotNull(getPort(), \"no port configured (the requested port may be in use)\");\n+        String path = getConfig(SERVICE_UP_URL_PATH);\n+        return protocol+\"://\"+host+\":\"+port+\"/\"+path;\n     }\n \n     protected String inferUrl() {\n@@ -343,14 +341,26 @@ protected void computePortsAndUrls() {\n         ConfigToAttributes.apply(this);\n \n         sensors().set(PROTOCOL, inferProtocol());\n-        sensors().set(MAIN_URI, URI.create(inferUrl()));\n-        sensors().set(MAIN_URI_MAPPED_SUBNET, URI.create(inferUrlSubnet()));\n-        sensors().set(MAIN_URI_MAPPED_PUBLIC, URI.create(inferUrlPublic()));\n+        sensors().set(MAIN_URI, createUriOrNull(inferUrl()));\n+        sensors().set(MAIN_URI_MAPPED_SUBNET, createUriOrNull(inferUrlForSubnet()));\n+        sensors().set(MAIN_URI_MAPPED_PUBLIC, createUriOrNull(inferUrlForPublic()));\n         sensors().set(ROOT_URL, inferUrl());\n  \n         checkNotNull(getPortNumberSensor(), \"no sensor configured to infer port number\");\n     }\n     \n+    private URI createUriOrNull(String val) {\n+        if (val == null) {\n+            return null;\n+        }\n+        try {\n+            return URI.create(val);\n+        } catch (IllegalArgumentException e) {\n+            LOG.warn(\"Invalid URI for {}: {}\", this, val);\n+            return null;\n+        }\n+    }\n+    \n     @Override\n     protected void connectSensors() {\n         super.connectSensors();",
                "deletions": 31
            },
            {
                "sha": "831df4c7a49f4416438d78ff4df336ed33ce9342",
                "filename": "software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java",
                "blob_url": "https://github.com/apache/brooklyn-library/blob/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java",
                "raw_url": "https://github.com/apache/brooklyn-library/raw/023e49287c8acdb6daf3af171e7e7277b145f63a/software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java",
                "status": "modified",
                "changes": 46,
                "additions": 28,
                "contents_url": "https://api.github.com/repos/apache/brooklyn-library/contents/software/webapp/src/test/java/org/apache/brooklyn/entity/proxy/AbstractControllerTest.java?ref=023e49287c8acdb6daf3af171e7e7277b145f63a",
                "patch": "@@ -31,7 +31,6 @@\n import java.util.Set;\n \n import org.apache.brooklyn.api.entity.Entity;\n-import org.apache.brooklyn.api.entity.EntityLocal;\n import org.apache.brooklyn.api.entity.EntitySpec;\n import org.apache.brooklyn.api.location.Location;\n import org.apache.brooklyn.api.location.LocationSpec;\n@@ -43,6 +42,7 @@\n import org.apache.brooklyn.core.entity.EntityAsserts;\n import org.apache.brooklyn.core.entity.factory.EntityFactory;\n import org.apache.brooklyn.core.entity.trait.Startable;\n+import org.apache.brooklyn.core.location.HasSubnetHostname;\n import org.apache.brooklyn.core.location.PortRanges;\n import org.apache.brooklyn.core.test.BrooklynAppUnitTestSupport;\n import org.apache.brooklyn.core.test.entity.TestEntity;\n@@ -155,7 +155,7 @@ public void testUpdateCalledWhenChildHostnameAndPortChanges() throws Exception {\n     public void testUpdateCalledWithAddressesOfNewChildren() {\n         // First child\n         cluster.resize(1);\n-        EntityLocal child = (EntityLocal) Iterables.getOnlyElement(cluster.getMembers());\n+        Entity child = Iterables.getOnlyElement(cluster.getMembers());\n         \n         List<Collection<String>> u = Lists.newArrayList(controller.getUpdates());\n         assertTrue(u.isEmpty(), \"expected empty list but got \"+u);\n@@ -171,7 +171,7 @@ public void testUpdateCalledWithAddressesOfNewChildren() {\n             public void run() {\n                 assertEquals(cluster.getMembers().size(), 2);\n             }});\n-        EntityLocal child2 = (EntityLocal) Iterables.getOnlyElement(MutableSet.builder().addAll(cluster.getMembers()).remove(child).build());\n+        Entity child2 = Iterables.getOnlyElement(MutableSet.<Entity>builder().addAll(cluster.getMembers()).remove(child).build());\n         \n         child2.sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n         child2.sensors().set(Startable.SERVICE_UP, true);\n@@ -192,8 +192,8 @@ public void testUpdateCalledWithAddressesRemovedForStoppedChildren() {\n         // Get some children, so we can remove one...\n         cluster.resize(2);\n         for (Entity it: cluster.getMembers()) { \n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n-            ((EntityLocal)it).sensors().set(Startable.SERVICE_UP, true);\n+            it.sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n+            it.sensors().set(Startable.SERVICE_UP, true);\n         }\n         assertEventuallyAddressesMatchCluster();\n \n@@ -208,17 +208,17 @@ public void testUpdateCalledWithAddressesRemovedForServiceDownChildrenThatHaveCl\n         // Get some children, so we can remove one...\n         cluster.resize(2);\n         for (Entity it: cluster.getMembers()) { \n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n-            ((EntityLocal)it).sensors().set(Startable.SERVICE_UP, true);\n+            it.sensors().set(ClusteredEntity.HTTP_PORT, 1234);\n+            it.sensors().set(Startable.SERVICE_UP, true);\n         }\n         assertEventuallyAddressesMatchCluster();\n \n         // Now unset host/port, and remove children\n         // Note the unsetting of hostname is done in SoftwareProcessImpl.stop(), so this is realistic\n         for (Entity it : cluster.getMembers()) {\n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HTTP_PORT, null);\n-            ((EntityLocal)it).sensors().set(ClusteredEntity.HOSTNAME, null);\n-            ((EntityLocal)it).sensors().set(Startable.SERVICE_UP, false);\n+            it.sensors().set(ClusteredEntity.HTTP_PORT, null);\n+            it.sensors().set(ClusteredEntity.HOSTNAME, null);\n+            it.sensors().set(Startable.SERVICE_UP, false);\n         }\n         assertEventuallyAddressesMatch(ImmutableList.<Entity>of());\n     }\n@@ -314,24 +314,34 @@ public void testMainUriSensorsCorrectlyComputedWithDomain() throws Exception {\n \n     @Test\n     public void testMainUriSensorsCorrectlyComputedWithoutDomain() throws Exception {\n+        // The MachineLocation needs to implement HasSubnetHostname for the Attributes.SUBNET_HOSTNAME \n+        // to be set with the subnet addresss (otherwise it will fall back to using machine.getAddress()).\n+        // See Machines.getSubnetHostname. \n+        \n         TrackingAbstractController controller2 = app.addChild(EntitySpec.create(TrackingAbstractController.class)\n                 .configure(TrackingAbstractController.SERVER_POOL, cluster)\n                 .configure(TrackingAbstractController.PROXY_HTTP_PORT, PortRanges.fromInteger(8081))\n-                .location(LocationSpec.create(SshMachineLocation.class)\n+                .location(LocationSpec.create(SshMachineLocationWithSubnetHostname.class)\n                         .configure(\"address\", Inet4Address.getByName(\"1.1.1.1\"))\n                         .configure(SshMachineLocation.PRIVATE_ADDRESSES, ImmutableList.of(\"2.2.2.2\"))));\n         controller2.start(ImmutableList.<Location>of());\n \n-        // Unfortunately the Attributes.SUBNET_HOSTNAME is 1.1.1.1, because SshMachineLocation does not implement\n-        // HasSubnetHostname (see Machines.getSubnetHostname). It falls back to using the machine.getAddress().\n-        // Hence the MAIN_URI uses 1.1.1.1.\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.ADDRESS, \"1.1.1.1\");\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.SUBNET_ADDRESS, \"2.2.2.2\");\n-        EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI, URI.create(\"http://1.1.1.1:8081/\"));\n+        EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI, URI.create(\"http://2.2.2.2:8081/\"));\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI_MAPPED_PUBLIC, URI.create(\"http://1.1.1.1:8081/\"));\n         EntityAsserts.assertAttributeEquals(controller2, Attributes.MAIN_URI_MAPPED_SUBNET, URI.create(\"http://2.2.2.2:8081/\"));\n     }\n-\n+    public static class SshMachineLocationWithSubnetHostname extends SshMachineLocation implements HasSubnetHostname {\n+        @Override public String getSubnetHostname() {\n+            return getSubnetIp();\n+        }\n+        @Override public String getSubnetIp() {\n+            Set<String> addrs = getPrivateAddresses();\n+            return (addrs.isEmpty()) ? getAddress().getHostAddress() : Iterables.get(addrs, 0);\n+        }\n+    }\n+    \n     private void assertEventuallyAddressesMatchCluster() {\n         assertEventuallyAddressesMatch(cluster.getMembers());\n     }\n@@ -388,10 +398,10 @@ public ClusteredEntity newEntity(Map flags, Entity parent) {\n         @SetFromFlag(\"hostAndPort\")\n         public static final AttributeSensor<String> HOST_AND_PORT = Attributes.HOST_AND_PORT;\n         \n-        MachineProvisioningLocation provisioner;\n+        MachineProvisioningLocation<MachineLocation> provisioner;\n         \n         public void start(Collection<? extends Location> locs) {\n-            provisioner = (MachineProvisioningLocation) locs.iterator().next();\n+            provisioner = (MachineProvisioningLocation<MachineLocation>) locs.iterator().next();\n             MachineLocation machine;\n             try {\n                 machine = provisioner.obtain(MutableMap.of());",
                "deletions": 18
            }
        ],
        "patched_files": [
            "AbstractControllerImpl.java",
            "AbstractController.java"
        ],
        "unit_tests": [
            "AbstractControllerTest.java"
        ]
    }
}