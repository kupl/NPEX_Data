[
    {
        "repo": "phoenix",
        "commit": "https://github.com/apache/phoenix/commit/28007f804dd3d132d39169f532be050717c3526d",
        "bug_id": "phoenix_28007f8",
        "message": "PHOENIX-2304 NullPointerException when using an index and a char array (Julian Jaffe, Navis, James Taylor)",
        "parent": "https://github.com/apache/phoenix/commit/18d063353d8857898b29f68aa7789d33c16b1960",
        "patched_files": [
            "SQLExceptionCode.java",
            "ColumnDef.java",
            "QueryOptimizer.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 37,
                "raw_url": "https://github.com/apache/phoenix/raw/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java?ref=28007f804dd3d132d39169f532be050717c3526d",
                "filename": "phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java",
                "deletions": 39,
                "sha": "53a13be1a7d6a200b1b692fc67fa26e36838d5ba",
                "blob_url": "https://github.com/apache/phoenix/blob/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java",
                "patch": "@@ -46,9 +46,9 @@\n \n \n /**\n- * Various SQLException Information. Including a vender-specific errorcode and a standard SQLState.\n- * \n- * \n+ * Various SQLException Information. Including a vendor-specific errorcode and a standard SQLState.\n+ *\n+ *\n  * @since 1.0\n  */\n public enum SQLExceptionCode {\n@@ -59,7 +59,7 @@\n     IO_EXCEPTION(101, \"08000\", \"Unexpected IO exception.\"),\n     MALFORMED_CONNECTION_URL(102, \"08001\", \"Malformed connection url.\"),\n     CANNOT_ESTABLISH_CONNECTION(103, \"08004\", \"Unable to establish connection.\"),\n-    \n+\n     /**\n      * Data Exception (errorcode 02, sqlstate 22)\n      */\n@@ -74,19 +74,17 @@ public SQLException newException(SQLExceptionInfo info) {\n     VALUE_IN_UPSERT_NOT_CONSTANT(204, \"22008\", \"Values in UPSERT must evaluate to a constant.\"),\n     MALFORMED_URL(205, \"22009\", \"Malformed URL.\"),\n     DATA_EXCEEDS_MAX_CAPACITY(206, \"22003\", \"The data exceeds the max capacity for the data type.\"),\n-    MISSING_CHAR_LENGTH(207, \"22003\", \"Missing length for CHAR.\"),\n-    NONPOSITIVE_CHAR_LENGTH(208, \"22003\", \"CHAR or VARCHAR must have a positive length.\"),\n+    MISSING_MAX_LENGTH(207, \"22004\", \"Max length must be specified for type.\"),\n+    NONPOSITIVE_MAX_LENGTH(208, \"22006\", \"Max length must have a positive length for type.\"),\n     DECIMAL_PRECISION_OUT_OF_RANGE(209, \"22003\", \"Decimal precision outside of range. Should be within 1 and \" + PDataType.MAX_PRECISION + \".\"),\n-    MISSING_BINARY_LENGTH(210, \"22003\", \"Missing length for BINARY.\"),\n-    NONPOSITIVE_BINARY_LENGTH(211, \"22003\", \"BINARY must have a positive length.\"),\n     SERVER_ARITHMETIC_ERROR(212, \"22012\", \"Arithmetic error on server.\"),\n     VALUE_OUTSIDE_RANGE(213,\"22003\",\"Value outside range.\"),\n     VALUE_IN_LIST_NOT_CONSTANT(214, \"22008\", \"Values in IN must evaluate to a constant.\"),\n     SINGLE_ROW_SUBQUERY_RETURNS_MULTIPLE_ROWS(215, \"22015\", \"Single-row sub-query returns more than one row.\"),\n     SUBQUERY_RETURNS_DIFFERENT_NUMBER_OF_FIELDS(216, \"22016\", \"Sub-query must return the same number of fields as the left-hand-side expression of 'IN'.\"),\n-    AMBIGUOUS_JOIN_CONDITION(217, \"22017\", \"Amibiguous or non-equi join condition specified. Consider using table list with where clause.\"),\n-    CONSTRAINT_VIOLATION(218, \"22018\", \"Constraint violatioin.\"),\n-    \n+    AMBIGUOUS_JOIN_CONDITION(217, \"22017\", \"Ambiguous or non-equi join condition specified. Consider using table list with where clause.\"),\n+    CONSTRAINT_VIOLATION(218, \"22018\", \"Constraint violation.\"),\n+\n     /**\n      * Constraint Violation (errorcode 03, sqlstate 23)\n      */\n@@ -97,13 +95,13 @@ public SQLException newException(SQLExceptionInfo info) {\n         }\n     }),\n     CANNOT_INDEX_COLUMN_ON_TYPE(302, \"23100\", \"The column cannot be index due to its type.\"),\n-    \n+\n     /**\n      * Invalid Cursor State (errorcode 04, sqlstate 24)\n      */\n     CURSOR_BEFORE_FIRST_ROW(401, \"24015\",\"Cursor before first row.\"),\n     CURSOR_PAST_LAST_ROW(402, \"24016\", \"Cursor past last row.\"),\n-    \n+\n     /**\n      * Syntax Error or Access Rule Violation (errorcode 05, sqlstate 42)\n      */\n@@ -152,22 +150,22 @@ public SQLException newException(SQLExceptionInfo info) {\n      *  Invalid Transaction State (errorcode 05, sqlstate 25)\n      */\n      READ_ONLY_CONNECTION(518,\"25502\",\"Mutations are not permitted for a read-only connection.\"),\n- \n+\n      VARBINARY_ARRAY_NOT_SUPPORTED(519, \"42896\", \"VARBINARY ARRAY is not supported\"),\n-    \n+\n      /**\n       *  Expression Index exceptions.\n       */\n-     AGGREGATE_EXPRESSION_NOT_ALLOWED_IN_INDEX(520, \"42897\", \"Aggreagaate expression not allowed in an index\"),\n+     AGGREGATE_EXPRESSION_NOT_ALLOWED_IN_INDEX(520, \"42897\", \"Aggregate expression not allowed in an index\"),\n      NON_DETERMINISTIC_EXPRESSION_NOT_ALLOWED_IN_INDEX(521, \"42898\", \"Non-deterministic expression not allowed in an index\"),\n      STATELESS_EXPRESSION_NOT_ALLOWED_IN_INDEX(522, \"42899\", \"Stateless expression not allowed in an index\"),\n \n-     /** \n+     /**\n       * Union All related errors\n       */\n      SELECT_COLUMN_NUM_IN_UNIONALL_DIFFS(525, \"42902\", \"SELECT column number differs in a Union All query is not allowed\"),\n      SELECT_COLUMN_TYPE_IN_UNIONALL_DIFFS(526, \"42903\", \"SELECT column types differ in a Union All query is not allowed\"),\n-     \n+\n      /**\n       * Row timestamp column related errors\n       */\n@@ -177,10 +175,10 @@ public SQLException newException(SQLExceptionInfo info) {\n      ROWTIMESTAMP_COL_INVALID_TYPE(530, \"42907\", \"A column can be added as ROW_TIMESTAMP only if it is of type DATE, BIGINT, TIME OR TIMESTAMP\"),\n      ROWTIMESTAMP_NOT_ALLOWED_ON_VIEW(531, \"42908\", \"Declaring a column as row_timestamp is not allowed for views\"),\n      INVALID_SCN(532, \"42909\", \"Value of SCN cannot be less than zero\"),\n-     /** \n+     /**\n      * HBase and Phoenix specific implementation defined sub-classes.\n      * Column family related exceptions.\n-     * \n+     *\n      * For the following exceptions, use errorcode 10.\n      */\n     SINGLE_PK_MAY_NOT_BE_NULL(1000, \"42I00\", \"Single column primary key may not be NULL.\"),\n@@ -237,11 +235,11 @@ public SQLException newException(SQLExceptionInfo info) {\n     NO_MUTABLE_INDEXES(1026, \"42Y85\", \"Mutable secondary indexes are only supported for HBase version \" + MetaDataUtil.decodeHBaseVersionAsString(PhoenixDatabaseMetaData.MUTABLE_SI_VERSION_THRESHOLD) + \" and above.\"),\n     INVALID_FILTER_ON_IMMUTABLE_ROWS(1027, \"42Y86\", \"All columns referenced in a WHERE clause must be available in every index for a table with immutable rows.\"),\n     INVALID_INDEX_STATE_TRANSITION(1028, \"42Y87\", \"Invalid index state transition.\"),\n-    INVALID_MUTABLE_INDEX_CONFIG(1029, \"42Y88\", \"Mutable secondary indexes must have the \" \n-            + IndexManagementUtil.WAL_EDIT_CODEC_CLASS_KEY + \" property set to \" \n+    INVALID_MUTABLE_INDEX_CONFIG(1029, \"42Y88\", \"Mutable secondary indexes must have the \"\n+            + IndexManagementUtil.WAL_EDIT_CODEC_CLASS_KEY + \" property set to \"\n             +  IndexManagementUtil.INDEX_WAL_EDIT_CODEC_CLASS_NAME + \" in the hbase-sites.xml of every region server\"),\n-            \n-            \n+\n+\n     CANNOT_CREATE_TENANT_SPECIFIC_TABLE(1030, \"42Y89\", \"Cannot create table for tenant-specific connection\"),\n     DEFAULT_COLUMN_FAMILY_ONLY_ON_CREATE_TABLE(1034, \"42Y93\", \"Default column family may only be specified when creating a table.\"),\n     INSUFFICIENT_MULTI_TENANT_COLUMNS(1040, \"42Y96\", \"A MULTI_TENANT table must have two or more PK columns with the first column being NOT NULL.\"),\n@@ -255,8 +253,8 @@ public SQLException newException(SQLExceptionInfo info) {\n     CANNOT_ALTER_PROPERTY(1051, \"43A08\", \"Property can be specified or changed only when creating a table\"),\n     CANNOT_SET_PROPERTY_FOR_COLUMN_NOT_ADDED(1052, \"43A09\", \"Property cannot be specified for a column family that is not being added or modified\"),\n     CANNOT_SET_TABLE_PROPERTY_ADD_COLUMN(1053, \"43A10\", \"Table level property cannot be set when adding a column\"),\n-    \n-    NO_LOCAL_INDEXES(1054, \"43A11\", \"Local secondary indexes are not supported for HBase versions \" + \n+\n+    NO_LOCAL_INDEXES(1054, \"43A11\", \"Local secondary indexes are not supported for HBase versions \" +\n         MetaDataUtil.decodeHBaseVersionAsString(PhoenixDatabaseMetaData.MIN_LOCAL_SI_VERSION_DISALLOW) + \" through \" + MetaDataUtil.decodeHBaseVersionAsString(PhoenixDatabaseMetaData.MAX_LOCAL_SI_VERSION_DISALLOW) + \" inclusive.\"),\n     UNALLOWED_LOCAL_INDEXES(1055, \"43A12\", \"Local secondary indexes are configured to not be allowed.\"),\n     DESC_VARBINARY_NOT_SUPPORTED(1056, \"43A13\", \"Descending VARBINARY columns not supported\"),\n@@ -288,18 +286,18 @@ public SQLException newException(SQLExceptionInfo info) {\n     SEQUENCE_VAL_REACHED_MAX_VALUE(1212, \"42Z12\", \"Reached MAXVALUE of sequence\"),\n     SEQUENCE_VAL_REACHED_MIN_VALUE(1213, \"42Z13\", \"Reached MINVALUE of sequence\"),\n     INCREMENT_BY_MUST_NOT_BE_ZERO(1214, \"42Z14\", \"Sequence INCREMENT BY value cannot be zero\"),\n-    NUM_SEQ_TO_ALLOCATE_MUST_BE_CONSTANT(1215, \"42Z15\", \"Sequence NEXT n VALUES FOR must be a postive integer or constant.\" ),\n+    NUM_SEQ_TO_ALLOCATE_MUST_BE_CONSTANT(1215, \"42Z15\", \"Sequence NEXT n VALUES FOR must be a positive integer or constant.\" ),\n     NUM_SEQ_TO_ALLOCATE_NOT_SUPPORTED(1216, \"42Z16\", \"Sequence NEXT n VALUES FOR is not supported for Sequences with the CYCLE flag\" ),\n-                    \n+\n     /** Parser error. (errorcode 06, sqlState 42P) */\n-    PARSER_ERROR(601, \"42P00\", \"Syntax error.\", Factory.SYTAX_ERROR),\n-    MISSING_TOKEN(602, \"42P00\", \"Syntax error.\", Factory.SYTAX_ERROR),\n-    UNWANTED_TOKEN(603, \"42P00\", \"Syntax error.\", Factory.SYTAX_ERROR),\n-    MISMATCHED_TOKEN(604, \"42P00\", \"Syntax error.\", Factory.SYTAX_ERROR),\n-    UNKNOWN_FUNCTION(605, \"42P00\", \"Syntax error.\", Factory.SYTAX_ERROR),\n-    \n+    PARSER_ERROR(601, \"42P00\", \"Syntax error.\", Factory.SYNTAX_ERROR),\n+    MISSING_TOKEN(602, \"42P00\", \"Syntax error.\", Factory.SYNTAX_ERROR),\n+    UNWANTED_TOKEN(603, \"42P00\", \"Syntax error.\", Factory.SYNTAX_ERROR),\n+    MISMATCHED_TOKEN(604, \"42P00\", \"Syntax error.\", Factory.SYNTAX_ERROR),\n+    UNKNOWN_FUNCTION(605, \"42P00\", \"Syntax error.\", Factory.SYNTAX_ERROR),\n+\n     /**\n-     * Implementation defined class. Execution exceptions (errorcode 11, sqlstate XCL). \n+     * Implementation defined class. Execution exceptions (errorcode 11, sqlstate XCL).\n      */\n     RESULTSET_CLOSED(1101, \"XCL01\", \"ResultSet is closed.\"),\n     GET_TABLE_REGIONS_FAIL(1102, \"XCL02\", \"Cannot get all table regions\"),\n@@ -316,7 +314,7 @@ public SQLException newException(SQLExceptionInfo info) {\n     }),\n     CANNOT_SPLIT_LOCAL_INDEX(1109,\"XCL09\", \"Local index may not be pre-split\"),\n     CANNOT_SALT_LOCAL_INDEX(1110,\"XCL10\", \"Local index may not be salted\"),\n-    \n+\n     /**\n      * Implementation defined class. Phoenix internal error. (errorcode 20, sqlstate INT).\n      */\n@@ -359,7 +357,7 @@ public SQLException newException(SQLExceptionInfo info) {\n     private final Factory factory;\n \n     private SQLExceptionCode(int errorCode, String sqlState, String message) {\n-        this(errorCode, sqlState, message, Factory.DEFAULTY);\n+        this(errorCode, sqlState, message, Factory.DEFAULT);\n     }\n \n     private SQLExceptionCode(int errorCode, String sqlState, String message, Factory factory) {\n@@ -391,15 +389,15 @@ public Factory getExceptionFactory() {\n     }\n \n     public static interface Factory {\n-        public static final Factory DEFAULTY = new Factory() {\n+        public static final Factory DEFAULT = new Factory() {\n \n             @Override\n             public SQLException newException(SQLExceptionInfo info) {\n                 return new SQLException(info.toString(), info.getCode().getSQLState(), info.getCode().getErrorCode(), info.getRootCause());\n             }\n             \n         };\n-        public static final Factory SYTAX_ERROR = new Factory() {\n+        public static final Factory SYNTAX_ERROR = new Factory() {\n \n             @Override\n             public SQLException newException(SQLExceptionInfo info) {",
                "changes": 76
            },
            {
                "status": "modified",
                "additions": 109,
                "raw_url": "https://github.com/apache/phoenix/raw/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/main/java/org/apache/phoenix/parse/ColumnDef.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/parse/ColumnDef.java?ref=28007f804dd3d132d39169f532be050717c3526d",
                "filename": "phoenix-core/src/main/java/org/apache/phoenix/parse/ColumnDef.java",
                "deletions": 119,
                "sha": "278b4aa7c7716f3b25dd9580b7a4a042584ebfd1",
                "blob_url": "https://github.com/apache/phoenix/blob/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/main/java/org/apache/phoenix/parse/ColumnDef.java",
                "patch": "@@ -22,12 +22,9 @@\n import org.apache.phoenix.exception.SQLExceptionCode;\n import org.apache.phoenix.exception.SQLExceptionInfo;\n import org.apache.phoenix.schema.SortOrder;\n-import org.apache.phoenix.schema.types.PBinary;\n-import org.apache.phoenix.schema.types.PChar;\n import org.apache.phoenix.schema.types.PDataType;\n import org.apache.phoenix.schema.types.PDecimal;\n import org.apache.phoenix.schema.types.PVarbinary;\n-import org.apache.phoenix.schema.types.PVarchar;\n import org.apache.phoenix.util.SchemaUtil;\n \n import com.google.common.base.Preconditions;\n@@ -42,7 +39,7 @@\n  */\n public class ColumnDef {\n     private final ColumnName columnDefName;\n-    private PDataType dataType;\n+    private final PDataType dataType;\n     private final Boolean isNull;\n     private final Integer maxLength;\n     private final Integer scale;\n@@ -52,98 +49,91 @@\n     private final Integer arrSize;\n     private final String expressionStr;\n     private final boolean isRowTimestamp;\n- \n+\n     ColumnDef(ColumnName columnDefName, String sqlTypeName, boolean isArray, Integer arrSize, Boolean isNull, Integer maxLength,\n-    \t\t            Integer scale, boolean isPK, SortOrder sortOrder, String expressionStr, boolean isRowTimestamp) {\n-   \t try {\n-         Preconditions.checkNotNull(sortOrder);\n-   \t     PDataType localType = null;\n-         this.columnDefName = columnDefName;\n-         this.isArray = isArray;\n-         // TODO : Add correctness check for arrSize.  Should this be ignored as in postgres\n-         // Also add what is the limit that we would support.  Are we going to support a\n-         //  fixed size or like postgres allow infinite.  May be the data types max limit can \n-         // be used for the array size (May be too big)\n-         if(this.isArray) {\n-        \t localType = sqlTypeName == null ? null : PDataType.fromTypeId(PDataType.sqlArrayType(SchemaUtil.normalizeIdentifier(sqlTypeName)));\n-        \t this.dataType = sqlTypeName == null ? null : PDataType.fromSqlTypeName(SchemaUtil.normalizeIdentifier(sqlTypeName));\n-             this.arrSize = arrSize; // Can only be non negative based on parsing\n-             if (this.dataType == PVarbinary.INSTANCE) {\n-                 throw new SQLExceptionInfo.Builder(SQLExceptionCode.VARBINARY_ARRAY_NOT_SUPPORTED)\n-                 .setColumnName(columnDefName.getColumnName()).build().buildException();\n-             }\n-         } else {\n-             this.dataType = sqlTypeName == null ? null : PDataType.fromSqlTypeName(SchemaUtil.normalizeIdentifier(sqlTypeName));\n-             this.arrSize = null;\n-         }\n-         \n-         this.isNull = isNull;\n-         if (this.dataType == PChar.INSTANCE) {\n-             if (maxLength == null) {\n-                 throw new SQLExceptionInfo.Builder(SQLExceptionCode.MISSING_CHAR_LENGTH)\n-                     .setColumnName(columnDefName.getColumnName()).build().buildException();\n-             }\n-             if (maxLength < 1) {\n-                 throw new SQLExceptionInfo.Builder(SQLExceptionCode.NONPOSITIVE_CHAR_LENGTH)\n-                     .setColumnName(columnDefName.getColumnName()).build().buildException();\n-             }\n-             scale = null;\n-         } else if (this.dataType == PVarchar.INSTANCE) {\n-             if (maxLength != null && maxLength < 1) {\n-                 throw new SQLExceptionInfo.Builder(SQLExceptionCode.NONPOSITIVE_CHAR_LENGTH)\n-                     .setColumnName(columnDefName.getColumnName()).build().buildException(); \n-             }\n-             scale = null;\n-         } else if (this.dataType == PDecimal.INSTANCE) {\n-             // for deciaml, 1 <= maxLength <= PDataType.MAX_PRECISION;\n-             if (maxLength != null) {\n-                 if (maxLength < 1 || maxLength > PDataType.MAX_PRECISION) {\n-                     throw new SQLExceptionInfo.Builder(SQLExceptionCode.DECIMAL_PRECISION_OUT_OF_RANGE)\n-                         .setColumnName(columnDefName.getColumnName()).build().buildException();\n-                 }\n-                 // When a precision is specified and a scale is not specified, it is set to 0. \n-                 // \n-                 // This is the standard as specified in\n-                 // http://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT1832\n-                 // and \n-                 // http://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15260.html.\n-                 // Otherwise, if scale is bigger than maxLength, just set it to the maxLength;\n-                 //\n-                 // When neither a precision nor a scale is specified, the precision and scale is\n-                 // ignored. All decimal are stored with as much decimal points as possible.\n-                 scale = scale == null ? PDataType.DEFAULT_SCALE : scale > maxLength ? maxLength : scale; \n-             }\n-         } else if (this.dataType == PBinary.INSTANCE) {\n-             if (maxLength == null) {\n-                 throw new SQLExceptionInfo.Builder(SQLExceptionCode.MISSING_BINARY_LENGTH)\n-                     .setColumnName(columnDefName.getColumnName()).build().buildException();\n-             }\n-             if (maxLength < 1) {\n-                 throw new SQLExceptionInfo.Builder(SQLExceptionCode.NONPOSITIVE_BINARY_LENGTH)\n-                     .setColumnName(columnDefName.getColumnName()).build().buildException();\n-             }\n-             scale = null;\n-         } else {\n-             // ignore maxLength and scale for other types.\n-             maxLength = null;\n-             scale = null;\n-         }\n-         this.maxLength = maxLength;\n-         this.scale = scale;\n-         this.isPK = isPK;\n-         this.sortOrder = sortOrder;\n-         if(this.isArray) {\n-             this.dataType = localType;\n-         }\n-         this.expressionStr = expressionStr;\n-         this.isRowTimestamp = isRowTimestamp;\n-     } catch (SQLException e) {\n-         throw new ParseException(e);\n-     }\n+            Integer scale, boolean isPK, SortOrder sortOrder, String expressionStr, boolean isRowTimestamp) {\n+        try {\n+            Preconditions.checkNotNull(sortOrder);\n+            PDataType baseType;\n+            PDataType dataType;\n+            this.columnDefName = columnDefName;\n+            // TODO : Add correctness check for arrSize.  Should this be ignored as in postgres\n+            // Also add what is the limit that we would support.  Are we going to support a\n+            //  fixed size or like postgres allow infinite.  May be the data types max limit can \n+            // be used for the array size (May be too big)\n+            if (isArray) {\n+                this.isArray = true;\n+                dataType = sqlTypeName == null ? null : PDataType.fromTypeId(PDataType.sqlArrayType(SchemaUtil.normalizeIdentifier(sqlTypeName)));\n+                baseType = sqlTypeName == null ? null : PDataType.fromSqlTypeName(SchemaUtil.normalizeIdentifier(sqlTypeName));\n+                this.arrSize = arrSize; // Can only be non negative based on parsing\n+                if (baseType == PVarbinary.INSTANCE) {\n+                    throw new SQLExceptionInfo.Builder(SQLExceptionCode.VARBINARY_ARRAY_NOT_SUPPORTED)\n+                    .setColumnName(columnDefName.getColumnName()).build().buildException();\n+                }\n+            } else {\n+                baseType = dataType = sqlTypeName == null ? null : PDataType.fromSqlTypeName(SchemaUtil.normalizeIdentifier(sqlTypeName));\n+                if (this.isArray = dataType != null && dataType.isArrayType()) {\n+                    baseType = PDataType.arrayBaseType(dataType);\n+                }\n+                this.arrSize = null;\n+            }\n+\n+            this.isNull = isNull;\n+            if (baseType == PDecimal.INSTANCE) {\n+                // for deciaml, 1 <= maxLength <= PDataType.MAX_PRECISION;\n+                if (maxLength == null) {\n+                    scale = null;\n+                } else {\n+                    if (maxLength < 1 || maxLength > PDataType.MAX_PRECISION) {\n+                        throw new SQLExceptionInfo.Builder(SQLExceptionCode.DECIMAL_PRECISION_OUT_OF_RANGE)\n+                        .setColumnName(columnDefName.getColumnName()).build().buildException();\n+                    }\n+                    // When a precision is specified and a scale is not specified, it is set to 0. \n+                    // \n+                    // This is the standard as specified in\n+                    // http://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT1832\n+                    // and \n+                    // http://docs.oracle.com/javadb/10.6.2.1/ref/rrefsqlj15260.html.\n+                    // Otherwise, if scale is bigger than maxLength, just set it to the maxLength;\n+                    //\n+                    // When neither a precision nor a scale is specified, the precision and scale is\n+                    // ignored. All decimal are stored with as much decimal points as possible.\n+                    scale = scale == null ? PDataType.DEFAULT_SCALE : scale > maxLength ? maxLength : scale; \n+                }\n+            } else {\n+                if (maxLength != null && maxLength < 1) {\n+                    throw new SQLExceptionInfo.Builder(SQLExceptionCode.NONPOSITIVE_MAX_LENGTH)\n+                    .setColumnName(columnDefName.getColumnName()).build().buildException();\n+                }\n+                scale = null;\n+                if (baseType == null) {\n+                    maxLength = null;\n+                } else if (baseType.isFixedWidth()) {\n+                    if (baseType.getByteSize() == null) {\n+                        if (maxLength == null) {\n+                            throw new SQLExceptionInfo.Builder(SQLExceptionCode.MISSING_MAX_LENGTH)\n+                            .setColumnName(columnDefName.getColumnName()).build().buildException();\n+                        }\n+                    } else {\n+                        maxLength = null;\n+                    }\n+                }\n+            }\n+            this.maxLength = maxLength;\n+            this.scale = scale;\n+            this.isPK = isPK;\n+            this.sortOrder = sortOrder;\n+            this.dataType = dataType;\n+            this.expressionStr = expressionStr;\n+            this.isRowTimestamp = isRowTimestamp;\n+        } catch (SQLException e) {\n+            throw new ParseException(e);\n+        }\n     }\n+\n     ColumnDef(ColumnName columnDefName, String sqlTypeName, Boolean isNull, Integer maxLength,\n             Integer scale, boolean isPK, SortOrder sortOrder, String expressionStr, boolean isRowTimestamp) {\n-    \tthis(columnDefName, sqlTypeName, false, 0, isNull, maxLength, scale, isPK, sortOrder, expressionStr, isRowTimestamp);\n+        this(columnDefName, sqlTypeName, false, 0, isNull, maxLength, scale, isPK, sortOrder, expressionStr, isRowTimestamp);\n     }\n \n     public ColumnName getColumnDefName() {\n@@ -175,45 +165,45 @@ public Integer getScale() {\n     public boolean isPK() {\n         return isPK;\n     }\n-    \n+\n     public SortOrder getSortOrder() {\n-    \treturn sortOrder;\n+        return sortOrder;\n+    }\n+\n+    public boolean isArray() {\n+        return isArray;\n     }\n-        \n-\tpublic boolean isArray() {\n-\t\treturn isArray;\n-\t}\n-\n-\tpublic Integer getArraySize() {\n-\t\treturn arrSize;\n-\t}\n-\n-\tpublic String getExpression() {\n-\t\treturn expressionStr;\n-\t}\n-\t\n-\tpublic boolean isRowTimestamp() {\n-\t    return isRowTimestamp;\n-\t}\n-\t@Override\n+\n+    public Integer getArraySize() {\n+        return arrSize;\n+    }\n+\n+    public String getExpression() {\n+        return expressionStr;\n+    }\n+\n+    public boolean isRowTimestamp() {\n+        return isRowTimestamp;\n+    }\n+    @Override\n     public String toString() {\n-\t    StringBuilder buf = new StringBuilder(columnDefName.getColumnNode().toString());\n-\t    buf.append(' ');\n+        StringBuilder buf = new StringBuilder(columnDefName.getColumnNode().toString());\n+        buf.append(' ');\n         buf.append(dataType.getSqlTypeName());\n         if (maxLength != null) {\n             buf.append('(');\n             buf.append(maxLength);\n             if (scale != null) {\n-              buf.append(',');\n-              buf.append(scale); // has both max length and scale. For ex- decimal(10,2)\n+                buf.append(',');\n+                buf.append(scale); // has both max length and scale. For ex- decimal(10,2)\n             }       \n             buf.append(')');\n-       }\n+        }\n         if (isArray) {\n             buf.append(' ');\n             buf.append(PDataType.ARRAY_TYPE_SUFFIX);\n             buf.append(' ');\n         }\n-\t    return buf.toString();\n-\t}\n-}\n+        return buf.toString();\n+    }\n+}\n\\ No newline at end of file",
                "changes": 228
            },
            {
                "status": "modified",
                "additions": 17,
                "raw_url": "https://github.com/apache/phoenix/raw/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/test/java/org/apache/phoenix/compile/QueryOptimizerTest.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/test/java/org/apache/phoenix/compile/QueryOptimizerTest.java?ref=28007f804dd3d132d39169f532be050717c3526d",
                "filename": "phoenix-core/src/test/java/org/apache/phoenix/compile/QueryOptimizerTest.java",
                "deletions": 0,
                "sha": "e528d3ba4941156deb5f5211e2e6516c44080b6c",
                "blob_url": "https://github.com/apache/phoenix/blob/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/test/java/org/apache/phoenix/compile/QueryOptimizerTest.java",
                "patch": "@@ -38,6 +38,7 @@\n import org.apache.phoenix.jdbc.PhoenixStatement;\n import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PColumn;\n import org.apache.phoenix.schema.PTableType;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.QueryUtil;\n@@ -390,6 +391,22 @@ public void testQueryOptimizerShouldSelectThePlanWithMoreNumberOfPKColumns() thr\n         assertEquals(\"CLIENT PARALLEL 1-WAY SKIP SCAN ON 15 KEYS OVER INDEX_TEST_TABLE_INDEX_F ['1','1111'] - ['5','3333']\", QueryUtil.getExplainPlan(rs));\n     }\n \n+    @Test\n+    public void testCharArrayLength() throws Exception {\n+        Connection conn = DriverManager.getConnection(getUrl());\n+        conn.createStatement().execute(\n+                \"CREATE TABLE TEST.TEST (testInt INTEGER, testCharArray CHAR(3)[], testByteArray BINARY(7)[], \" +\n+                \"CONSTRAINT test_pk PRIMARY KEY(testInt)) DEFAULT_COLUMN_FAMILY='T'\");\n+        conn.createStatement().execute(\"CREATE INDEX TEST_INDEX ON TEST.TEST (testInt) INCLUDE (testCharArray, testByteArray)\");\n+        PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+\n+        QueryPlan plan = stmt.optimizeQuery(\"SELECT /*+ INDEX(TEST.TEST TEST_INDEX)*/ testCharArray,testByteArray FROM TEST.TEST\");\n+        List<PColumn> columns = plan.getTableRef().getTable().getColumns();\n+        assertEquals(3, columns.size());\n+        assertEquals(3, columns.get(1).getMaxLength().intValue());\n+        assertEquals(7, columns.get(2).getMaxLength().intValue());\n+    }\n+\n     private void testAssertQueryPlanDetails(boolean multitenant, boolean useIndex, boolean salted) throws Exception {\n         String sql;\n         PreparedStatement stmt;",
                "changes": 17
            },
            {
                "status": "modified",
                "additions": 50,
                "raw_url": "https://github.com/apache/phoenix/raw/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/test/java/org/apache/phoenix/parse/QueryParserTest.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/test/java/org/apache/phoenix/parse/QueryParserTest.java?ref=28007f804dd3d132d39169f532be050717c3526d",
                "filename": "phoenix-core/src/test/java/org/apache/phoenix/parse/QueryParserTest.java",
                "deletions": 49,
                "sha": "5363042b956e7e0307df69c8253042a934dab908",
                "blob_url": "https://github.com/apache/phoenix/blob/28007f804dd3d132d39169f532be050717c3526d/phoenix-core/src/test/java/org/apache/phoenix/parse/QueryParserTest.java",
                "patch": "@@ -376,41 +376,41 @@ public void testParsingStatementWithExtraToken() throws Exception {\n \n     @Test\n     public void testParseCreateTableInlinePrimaryKeyWithOrder() throws Exception {\n-    \tfor (String order : new String[]{\"asc\", \"desc\"}) {\n+        for (String order : new String[]{\"asc\", \"desc\"}) {\n             String s = \"create table core.entity_history_archive (id char(15) primary key ${o})\".replace(\"${o}\", order);\n-    \t\tCreateTableStatement stmt = (CreateTableStatement)new SQLParser((s)).parseStatement();\n-    \t\tList<ColumnDef> columnDefs = stmt.getColumnDefs();\n-    \t\tassertEquals(1, columnDefs.size());\n-    \t\tassertEquals(SortOrder.fromDDLValue(order), columnDefs.iterator().next().getSortOrder()); \n-    \t}\n+            CreateTableStatement stmt = (CreateTableStatement)new SQLParser((s)).parseStatement();\n+            List<ColumnDef> columnDefs = stmt.getColumnDefs();\n+            assertEquals(1, columnDefs.size());\n+            assertEquals(SortOrder.fromDDLValue(order), columnDefs.iterator().next().getSortOrder()); \n+        }\n     }\n     \n     @Test\n     public void testParseCreateTableOrderWithoutPrimaryKeyFails() throws Exception {\n-    \tfor (String order : new String[]{\"asc\", \"desc\"}) {\n-    \t\tString stmt = \"create table core.entity_history_archive (id varchar(20) ${o})\".replace(\"${o}\", order);\n-    \t\ttry {\n-    \t\t\tnew SQLParser((stmt)).parseStatement();\n-    \t\t\tfail(\"Expected parse exception to be thrown\");\n-    \t\t} catch (SQLException e) {\n-    \t\t\tString errorMsg = \"ERROR 603 (42P00): Syntax error. Unexpected input. Expecting \\\"RPAREN\\\", got \\\"${o}\\\"\".replace(\"${o}\", order);\n-    \t\t\tassertTrue(\"Expected message to contain \\\"\" + errorMsg + \"\\\" but got \\\"\" + e.getMessage() + \"\\\"\", e.getMessage().contains(errorMsg));\n-    \t\t}\n-    \t}\n+        for (String order : new String[]{\"asc\", \"desc\"}) {\n+            String stmt = \"create table core.entity_history_archive (id varchar(20) ${o})\".replace(\"${o}\", order);\n+            try {\n+                new SQLParser((stmt)).parseStatement();\n+                fail(\"Expected parse exception to be thrown\");\n+            } catch (SQLException e) {\n+                String errorMsg = \"ERROR 603 (42P00): Syntax error. Unexpected input. Expecting \\\"RPAREN\\\", got \\\"${o}\\\"\".replace(\"${o}\", order);\n+                assertTrue(\"Expected message to contain \\\"\" + errorMsg + \"\\\" but got \\\"\" + e.getMessage() + \"\\\"\", e.getMessage().contains(errorMsg));\n+            }\n+        }\n     }\n     \n     @Test\n     public void testParseCreateTablePrimaryKeyConstraintWithOrder() throws Exception {\n-    \tfor (String order : new String[]{\"asc\", \"desc\"}) {\n-    \t\tString s = \"create table core.entity_history_archive (id CHAR(15), name VARCHAR(150), constraint pk primary key (id ${o}, name ${o}))\".replace(\"${o}\", order);\n-    \t\tCreateTableStatement stmt = (CreateTableStatement)new SQLParser((s)).parseStatement();\n-    \t\tPrimaryKeyConstraint pkConstraint = stmt.getPrimaryKeyConstraint();\n-    \t\tList<Pair<ColumnName,SortOrder>> columns = pkConstraint.getColumnNames();\n-    \t\tassertEquals(2, columns.size());\n-    \t\tfor (Pair<ColumnName,SortOrder> pair : columns) {\n-    \t\t\tassertEquals(SortOrder.fromDDLValue(order), pkConstraint.getColumnWithSortOrder(pair.getFirst()).getSecond());\n-    \t\t}    \t\t\n-    \t}\n+        for (String order : new String[]{\"asc\", \"desc\"}) {\n+            String s = \"create table core.entity_history_archive (id CHAR(15), name VARCHAR(150), constraint pk primary key (id ${o}, name ${o}))\".replace(\"${o}\", order);\n+            CreateTableStatement stmt = (CreateTableStatement)new SQLParser((s)).parseStatement();\n+            PrimaryKeyConstraint pkConstraint = stmt.getPrimaryKeyConstraint();\n+            List<Pair<ColumnName,SortOrder>> columns = pkConstraint.getColumnNames();\n+            assertEquals(2, columns.size());\n+            for (Pair<ColumnName,SortOrder> pair : columns) {\n+                assertEquals(SortOrder.fromDDLValue(order), pkConstraint.getColumnWithSortOrder(pair.getFirst()).getSecond());\n+            }           \n+        }\n     }\n \n     @Test\n@@ -439,46 +439,47 @@ public void testInvalidTrailingCommaOnCreateTable() throws Exception {\n     }\n \n     @Test\n-\tpublic void testCreateSequence() throws Exception {\n-\t\tString sql = ((\n-\t\t\t\t\"create sequence foo.bar\\n\" + \n-\t\t\t\t\t\t\"start with 0\\n\"\t+ \n-\t\t\t\t\t\t\"increment by 1\\n\"));\n-\t\tparseQuery(sql);\n-\t}\n-\t\n-\t@Test\n-\tpublic void testNextValueForSelect() throws Exception {\n-\t\tString sql = ((\n-\t\t\t\t\"select next value for foo.bar \\n\" + \n-\t\t\t\t\t\t\"from core.custom_entity_data\\n\"));\t\t\t\t\t\t\n-\t\tparseQuery(sql);\n-\t}\n-\t\n-\t@Test\n+    public void testCreateSequence() throws Exception {\n+        String sql = ((\n+                \"create sequence foo.bar\\n\" + \n+                        \"start with 0\\n\"    + \n+                        \"increment by 1\\n\"));\n+        parseQuery(sql);\n+    }\n+    \n+    @Test\n+    public void testNextValueForSelect() throws Exception {\n+        String sql = ((\n+                \"select next value for foo.bar \\n\" + \n+                        \"from core.custom_entity_data\\n\"));                     \n+        parseQuery(sql);\n+    }\n+    \n+    @Test\n     public void testNextValueForWhere() throws Exception {\n         String sql = ((\n                 \"upsert into core.custom_entity_data\\n\" + \n                         \"select next value for foo.bar from core.custom_entity_data\\n\"));                    \n         parseQuery(sql);\n     }\n-\t\n+\n+    @Test\n     public void testBadCharDef() throws Exception {\n         try {\n             String sql = (\"CREATE TABLE IF NOT EXISTS testBadVarcharDef\" + \n                     \"  (pk VARCHAR NOT NULL PRIMARY KEY, col CHAR(0))\");\n             parseQuery(sql);\n             fail(\"Should have caught bad char definition.\");\n         } catch (SQLException e) {\n-            assertTrue(e.getMessage(), e.getMessage().contains(\"ERROR 208 (22003): CHAR or VARCHAR must have a positive length. columnName=COL\"));\n+            assertEquals(SQLExceptionCode.NONPOSITIVE_MAX_LENGTH.getErrorCode(), e.getErrorCode());\n         }\n         try {\n             String sql = (\"CREATE TABLE IF NOT EXISTS testBadVarcharDef\" + \n                     \"  (pk VARCHAR NOT NULL PRIMARY KEY, col CHAR)\");\n             parseQuery(sql);\n             fail(\"Should have caught bad char definition.\");\n         } catch (SQLException e) {\n-            assertTrue(e.getMessage(), e.getMessage().contains(\"ERROR 207 (22003): Missing length for CHAR. columnName=COL\"));\n+            assertEquals(SQLExceptionCode.MISSING_MAX_LENGTH.getErrorCode(), e.getErrorCode());\n         }\n     }\n \n@@ -490,7 +491,7 @@ public void testBadVarcharDef() throws Exception {\n             parseQuery(sql);\n             fail(\"Should have caught bad varchar definition.\");\n         } catch (SQLException e) {\n-            assertTrue(e.getMessage(), e.getMessage().contains(\"ERROR 208 (22003): CHAR or VARCHAR must have a positive length. columnName=COL\"));\n+            assertEquals(SQLExceptionCode.NONPOSITIVE_MAX_LENGTH.getErrorCode(), e.getErrorCode());\n         }\n     }\n \n@@ -522,15 +523,15 @@ public void testBadBinaryDef() throws Exception {\n             parseQuery(sql);\n             fail(\"Should have caught bad binary definition.\");\n         } catch (SQLException e) {\n-            assertTrue(e.getMessage(), e.getMessage().contains(\"ERROR 211 (22003): BINARY must have a positive length. columnName=COL\"));\n+            assertEquals(SQLExceptionCode.NONPOSITIVE_MAX_LENGTH.getErrorCode(), e.getErrorCode());\n         }\n         try {\n             String sql = (\"CREATE TABLE IF NOT EXISTS testBadVarcharDef\" + \n                     \"  (pk VARCHAR NOT NULL PRIMARY KEY, col BINARY)\");\n             parseQuery(sql);\n             fail(\"Should have caught bad char definition.\");\n         } catch (SQLException e) {\n-            assertTrue(e.getMessage(), e.getMessage().contains(\"ERROR 210 (22003): Missing length for BINARY. columnName=COL\"));\n+            assertEquals(SQLExceptionCode.MISSING_MAX_LENGTH.getErrorCode(), e.getErrorCode());\n         }\n     }\n ",
                "changes": 99
            }
        ],
        "unit_tests": [
            "QueryParserTest.java",
            "QueryOptimizerTest.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "phoenix-core/src/test/java/org/apache/phoenix/parse/QueryParserTest.java",
        "buggy_files": [
            "phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java",
            "phoenix-core/src/main/java/org/apache/phoenix/parse/ColumnDef.java",
            "phoenix-core/src/main/java/org/apache/phoenix/optimize/QueryOptimizer.java"
        ],
        "fixed": true
    }
]