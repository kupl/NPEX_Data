[
    {
        "repo": "dubbo",
        "commit": "https://github.com/apache/dubbo/commit/50afb8775cb78acf1592516f31143afc2b6e7e38",
        "bug_id": "dubbo_50afb87",
        "message": "Merge pull request #3083 beiwei30/incubator-dubbo,  more code review.\n\n* refactor ScriptRouter\r\n\r\n* refactor TagRouter\r\n\r\n* refactor AbstractConfiguratorListener\r\n\r\n* make sure parameter should not be null\r\n\r\n* correct comments\r\n\r\n* make ReferenceConfigurationListener private static\r\n\r\n* avoid dup code in init\r\n\r\n* add fixme for potential useless code\r\n\r\n* clean up useless variables\r\n\r\n* move methods into UrlUtils\r\n\r\n* make method private\r\n\r\n* reformat javadoc\r\n\r\n* avoid dup code\r\n\r\n* reformat log message\r\n\r\n* reformat log message\r\n\r\n* reformat the code\r\n\r\n* remove useless imports\r\n\r\n* remove useless code\r\n\r\n* refactor ScriptRouter\r\n\r\n* refactor TagRouter\r\n\r\n* refactor AbstractConfiguratorListener\r\n\r\n* Add comment\r\n\r\n* Fix UT\r\n\r\n* make sure parameter should not be null\r\n\r\n* correct comments\r\n\r\n* make ReferenceConfigurationListener private static\r\n\r\n* Revert demo changes\r\n\r\n* Revert code to avoid NPE in RPC wire after providers are cleared.\r\n\r\n* make ListenableRouter code thread safe\r\n\r\n* Fix UT\r\n\r\n* Remove assert check to continue with execute.\r\n\r\n* avoid dup code in init\r\n\r\n* solve compile error\r\n\r\n* add fixme for potential useless code\r\n\r\n* clean up useless variables\r\n\r\n* move methods into UrlUtils\r\n\r\n* make method private\r\n\r\n* reformat javadoc\r\n\r\n* avoid dup code\r\n\r\n* reformat log message\r\n\r\n* reformat log message\r\n\r\n* reformat the code\r\n\r\n* remove useless imports\r\n\r\n* remove useless code\r\n\r\n* code review comments from @khanimteyaz\r\n\r\n* code review from @khanimteyaz",
        "parent": "https://github.com/apache/dubbo/commit/5c54c6837876b7daf0c55d9f9cafde109baa1a5d",
        "patched_files": [
            "UrlUtils.java",
            "RegistryDirectory.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 0,
                "raw_url": "https://github.com/apache/dubbo/raw/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java?ref=50afb8775cb78acf1592516f31143afc2b6e7e38",
                "filename": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java",
                "deletions": 4,
                "sha": "a690d73f1c9f88e178cdd83aebaff649511f54d6",
                "blob_url": "https://github.com/apache/dubbo/blob/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java",
                "patch": "@@ -67,10 +67,6 @@ public void initWithRouters(List<Router> builtinRouters) {\n         this.sort();\n     }\n \n-    public void addRouter(Router router) {\n-        this.routers.add(router);\n-    }\n-\n     /**\n      * If we use route:// protocol in version before 2.7.0, each URL will generate a Router instance, so we should\n      * keep the routers up to date, that is, each time router URLs changes, we should update the routers list, only",
                "changes": 4
            },
            {
                "status": "modified",
                "additions": 2,
                "raw_url": "https://github.com/apache/dubbo/raw/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java?ref=50afb8775cb78acf1592516f31143afc2b6e7e38",
                "filename": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java",
                "deletions": 3,
                "sha": "54ce8269afda990fd4693a0445e4eacbb17cd621",
                "blob_url": "https://github.com/apache/dubbo/blob/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java",
                "patch": "@@ -28,7 +28,7 @@\n import org.apache.dubbo.rpc.cluster.Router;\n import org.apache.dubbo.rpc.cluster.RouterChain;\n \n-import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n@@ -96,8 +96,7 @@ public void setRouterChain(RouterChain<T> routerChain) {\n     }\n \n     protected void addRouters(List<Router> routers) {\n-        // copy list\n-        routers = routers == null ? new ArrayList<>() : new ArrayList<>(routers);\n+        routers = routers == null ? Collections.emptyList() : routers;\n         routerChain.addRouters(routers);\n     }\n ",
                "changes": 5
            },
            {
                "status": "modified",
                "additions": 29,
                "raw_url": "https://github.com/apache/dubbo/raw/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java?ref=50afb8775cb78acf1592516f31143afc2b6e7e38",
                "filename": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java",
                "deletions": 5,
                "sha": "f93bc5a5f349302d200b25bb576b6f521ab13a36",
                "blob_url": "https://github.com/apache/dubbo/blob/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java",
                "patch": "@@ -27,6 +27,14 @@\n import java.util.function.Predicate;\r\n import java.util.stream.Collectors;\r\n \r\n+import static org.apache.dubbo.common.Constants.CATEGORY_KEY;\r\n+import static org.apache.dubbo.common.Constants.CONFIGURATORS_CATEGORY;\r\n+import static org.apache.dubbo.common.Constants.DEFAULT_CATEGORY;\r\n+import static org.apache.dubbo.common.Constants.OVERRIDE_PROTOCOL;\r\n+import static org.apache.dubbo.common.Constants.PROVIDERS_CATEGORY;\r\n+import static org.apache.dubbo.common.Constants.ROUTERS_CATEGORY;\r\n+import static org.apache.dubbo.common.Constants.ROUTE_PROTOCOL;\r\n+\r\n public class UrlUtils {\r\n \r\n     /**\r\n@@ -343,14 +351,14 @@ public static URL getEmptyUrl(String service, String category) {\n             service = service.substring(0, i);\r\n         }\r\n         return URL.valueOf(Constants.EMPTY_PROTOCOL + \"://0.0.0.0/\" + service + URL_PARAM_STARTING_SYMBOL\r\n-                + Constants.CATEGORY_KEY + \"=\" + category\r\n+                + CATEGORY_KEY + \"=\" + category\r\n                 + (group == null ? \"\" : \"&\" + Constants.GROUP_KEY + \"=\" + group)\r\n                 + (version == null ? \"\" : \"&\" + Constants.VERSION_KEY + \"=\" + version));\r\n     }\r\n \r\n     public static boolean isMatchCategory(String category, String categories) {\r\n         if (categories == null || categories.length() == 0) {\r\n-            return Constants.DEFAULT_CATEGORY.equals(category);\r\n+            return DEFAULT_CATEGORY.equals(category);\r\n         } else if (categories.contains(Constants.ANY_VALUE)) {\r\n             return true;\r\n         } else if (categories.contains(Constants.REMOVE_VALUE_PREFIX)) {\r\n@@ -370,8 +378,8 @@ public static boolean isMatch(URL consumerUrl, URL providerUrl) {\n             return false;\r\n         }\r\n \r\n-        if (!isMatchCategory(providerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY),\r\n-                consumerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY))) {\r\n+        if (!isMatchCategory(providerUrl.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY),\r\n+                consumerUrl.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY))) {\r\n             return false;\r\n         }\r\n         if (!providerUrl.getParameter(Constants.ENABLED_KEY, true)\r\n@@ -445,6 +453,22 @@ public static boolean isServiceKeyMatch(URL pattern, URL value) {\n         return urls.stream().filter(predicate).collect(Collectors.toList());\r\n     }\r\n \r\n+    public static boolean isConfigurator(URL url) {\r\n+        return OVERRIDE_PROTOCOL.equals(url.getProtocol()) ||\r\n+                CONFIGURATORS_CATEGORY.equals(url.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY));\r\n+    }\r\n+\r\n+    public static boolean isRoute(URL url) {\r\n+        return ROUTE_PROTOCOL.equals(url.getProtocol()) ||\r\n+                ROUTERS_CATEGORY.equals(url.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY));\r\n+    }\r\n+\r\n+    public static boolean isProvider(URL url) {\r\n+        return !OVERRIDE_PROTOCOL.equals(url.getProtocol()) &&\r\n+                !ROUTE_PROTOCOL.equals(url.getProtocol()) &&\r\n+                PROVIDERS_CATEGORY.equals(url.getParameter(CATEGORY_KEY, PROVIDERS_CATEGORY));\r\n+    }\r\n+\r\n     /**\r\n      * Check if the given value matches the given pattern. The pattern supports wildcard \"*\".\r\n      *\r\n@@ -459,4 +483,4 @@ static boolean isItemMatch(String pattern, String value) {\n             return \"*\".equals(pattern) || pattern.equals(value);\r\n         }\r\n     }\r\n-}\n\\ No newline at end of file\n+}\r",
                "changes": 34
            },
            {
                "status": "modified",
                "additions": 46,
                "raw_url": "https://github.com/apache/dubbo/raw/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java?ref=50afb8775cb78acf1592516f31143afc2b6e7e38",
                "filename": "dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java",
                "deletions": 115,
                "sha": "5ebace2a4b283364f8e217ed2e8e1f29951508e4",
                "blob_url": "https://github.com/apache/dubbo/blob/50afb8775cb78acf1592516f31143afc2b6e7e38/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java",
                "patch": "@@ -25,6 +25,7 @@\n import org.apache.dubbo.common.utils.Assert;\r\n import org.apache.dubbo.common.utils.NetUtils;\r\n import org.apache.dubbo.common.utils.StringUtils;\r\n+import org.apache.dubbo.common.utils.UrlUtils;\r\n import org.apache.dubbo.configcenter.DynamicConfiguration;\r\n import org.apache.dubbo.registry.NotifyListener;\r\n import org.apache.dubbo.registry.Registry;\r\n@@ -34,7 +35,6 @@\n import org.apache.dubbo.rpc.RpcException;\r\n import org.apache.dubbo.rpc.cluster.Cluster;\r\n import org.apache.dubbo.rpc.cluster.Configurator;\r\n-import org.apache.dubbo.rpc.cluster.ConfiguratorFactory;\r\n import org.apache.dubbo.rpc.cluster.Router;\r\n import org.apache.dubbo.rpc.cluster.RouterChain;\r\n import org.apache.dubbo.rpc.cluster.RouterFactory;\r\n@@ -47,7 +47,6 @@\n import java.util.ArrayList;\r\n import java.util.Collection;\r\n import java.util.Collections;\r\n-import java.util.Comparator;\r\n import java.util.HashMap;\r\n import java.util.HashSet;\r\n import java.util.List;\r\n@@ -61,7 +60,6 @@\n import static org.apache.dubbo.common.Constants.CONFIGURATORS_CATEGORY;\r\n import static org.apache.dubbo.common.Constants.DEFAULT_CATEGORY;\r\n import static org.apache.dubbo.common.Constants.DYNAMIC_CONFIGURATORS_CATEGORY;\r\n-import static org.apache.dubbo.common.Constants.OVERRIDE_PROTOCOL;\r\n import static org.apache.dubbo.common.Constants.PROVIDERS_CATEGORY;\r\n import static org.apache.dubbo.common.Constants.ROUTERS_CATEGORY;\r\n import static org.apache.dubbo.common.Constants.ROUTE_PROTOCOL;\r\n@@ -80,13 +78,10 @@\n     private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class)\r\n             .getAdaptiveExtension();\r\n \r\n-    private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\r\n-            .getAdaptiveExtension();\r\n     private final String serviceKey; // Initialization at construction time, assertion not null\r\n     private final Class<T> serviceType; // Initialization at construction time, assertion not null\r\n     private final Map<String, String> queryMap; // Initialization at construction time, assertion not null\r\n     private final URL directoryUrl; // Initialization at construction time, assertion not null, and always assign non null value\r\n-    private final String[] serviceMethods;\r\n     private final boolean multiGroup;\r\n     private Protocol protocol; // Initialization at the time of injection, the assertion is not null\r\n     private Registry registry; // Initialization at the time of injection, the assertion is not null\r\n@@ -106,9 +101,6 @@\n     private volatile Map<String, Invoker<T>> urlInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference\r\n     private volatile List<Invoker<T>> invokers;\r\n \r\n-    // Map<methodName, Invoker> cache service method to invokers mapping.\r\n-//    private volatile Map<String, List<Invoker<T>>> methodInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference\r\n-\r\n     // Set<invokerUrls> cache invokeUrls to invokers mapping.\r\n     private volatile Set<URL> cachedInvokerUrls; // The initial value is null and the midway may be assigned to null, please use the local variable reference\r\n \r\n@@ -130,8 +122,6 @@ public RegistryDirectory(Class<T> serviceType, URL url) {\n         this.overrideDirectoryUrl = this.directoryUrl = turnRegistryUrlToConsumerUrl(url);\r\n         String group = directoryUrl.getParameter(Constants.GROUP_KEY, \"\");\r\n         this.multiGroup = group != null && (\"*\".equals(group) || group.contains(\",\"));\r\n-        String methods = queryMap.get(Constants.METHODS_KEY);\r\n-        this.serviceMethods = methods == null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);\r\n     }\r\n \r\n     private URL turnRegistryUrlToConsumerUrl(URL url) {\r\n@@ -187,37 +177,38 @@ public void destroy() {\n \r\n     @Override\r\n     public synchronized void notify(List<URL> urls) {\r\n-        List<URL> categoryUrls = urls.stream().filter(this::isValidCategory).filter(this::isNotCompatibleFor26x).collect(Collectors.toList());\r\n+        List<URL> categoryUrls = urls.stream()\r\n+                .filter(this::isValidCategory)\r\n+                .filter(this::isNotCompatibleFor26x)\r\n+                .collect(Collectors.toList());\r\n \r\n         /**\r\n          * TODO Try to refactor the processing of these three type of urls using Collectors.groupBy()?\r\n          */\r\n-        this.configurators = Configurator.toConfigurators(classifyUrls(categoryUrls, url -> (CONFIGURATORS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY))\r\n-                 || OVERRIDE_PROTOCOL.equals(url.getProtocol())))).orElse(configurators);\r\n+        this.configurators = Configurator.toConfigurators(classifyUrls(categoryUrls, UrlUtils::isConfigurator))\r\n+                .orElse(configurators);\r\n \r\n-        toRouters(classifyUrls(categoryUrls, url -> {\r\n-            return ROUTE_PROTOCOL.equals(url.getProtocol())\r\n-                    || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY));\r\n-        })).ifPresent(this::addRouters);\r\n+        toRouters(classifyUrls(categoryUrls, UrlUtils::isRoute)).ifPresent(this::addRouters);\r\n \r\n         // providers\r\n-        refreshOverrideAndInvoker(classifyUrls(categoryUrls, url -> PROVIDERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, PROVIDERS_CATEGORY))\r\n-                && !OVERRIDE_PROTOCOL.equals(url.getProtocol())\r\n-                && !ROUTE_PROTOCOL.equals(url.getProtocol()))\r\n-        );\r\n+        refreshOverrideAndInvoker(classifyUrls(categoryUrls, UrlUtils::isProvider));\r\n     }\r\n \r\n-    public void refreshOverrideAndInvoker(List<URL> urls) {\r\n+    private void refreshOverrideAndInvoker(List<URL> urls) {\r\n         // mock zookeeper://xxx?mock=return null\r\n         overrideDirectoryUrl();\r\n         refreshInvoker(urls);\r\n     }\r\n \r\n     /**\r\n      * Convert the invokerURL list to the Invoker Map. The rules of the conversion are as follows:\r\n-     * 1.If URL has been converted to invoker, it is no longer re-referenced and obtained directly from the cache, and notice that any parameter changes in the URL will be re-referenced.\r\n-     * 2.If the incoming invoker list is not empty, it means that it is the latest invoker list\r\n-     * 3.If the list of incoming invokerUrl is empty, It means that the rule is only a override rule or a route rule, which needs to be re-contrasted to decide whether to re-reference.\r\n+     * <ol>\r\n+     * <li> If URL has been converted to invoker, it is no longer re-referenced and obtained directly from the cache,\r\n+     * and notice that any parameter changes in the URL will be re-referenced.</li>\r\n+     * <li>If the incoming invoker list is not empty, it means that it is the latest invoker list.</li>\r\n+     * <li>If the list of incoming invokerUrl is empty, It means that the rule is only a override rule or a route\r\n+     * rule, which needs to be re-contrasted to decide whether to re-reference.</li>\r\n+     * </ol>\r\n      *\r\n      * @param invokerUrls this parameter can't be null\r\n      */\r\n@@ -248,7 +239,6 @@ private void refreshInvoker(List<URL> invokerUrls) {\n                 return;\r\n             }\r\n             Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map\r\n-//            Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map\r\n \r\n             // state change\r\n             // If the calculation is wrong, it is not processed.\r\n@@ -262,7 +252,6 @@ private void refreshInvoker(List<URL> invokerUrls) {\n             // pre-route and build cache, notice that route cache should build on original Invoker list.\r\n             // toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.\r\n             routerChain.setInvokers(newInvokers);\r\n-//            this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\r\n             this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;\r\n             this.urlInvokerMap = newUrlInvokerMap;\r\n \r\n@@ -307,7 +296,7 @@ private void refreshInvoker(List<URL> invokerUrls) {\n             return Optional.empty();\r\n         }\r\n \r\n-        List<Router> routers = new ArrayList<Router>();\r\n+        List<Router> routers = new ArrayList<>();\r\n         for (URL url : urls) {\r\n             if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\r\n                 continue;\r\n@@ -318,8 +307,9 @@ private void refreshInvoker(List<URL> invokerUrls) {\n             }\r\n             try {\r\n                 Router router = routerFactory.getRouter(url);\r\n-                routerChain.addRouter(router);\r\n-                if (!routers.contains(router)) routers.add(router);\r\n+                if (!routers.contains(router)) {\r\n+                    routers.add(router);\r\n+                }\r\n             } catch (Throwable t) {\r\n                 logger.error(\"convert router url to router error, url: \" + url, t);\r\n             }\r\n@@ -360,10 +350,10 @@ private void refreshInvoker(List<URL> invokerUrls) {\n                 continue;\r\n             }\r\n             if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\r\n-                logger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl()\r\n-                        .getAddress() + \" to consumer \" + NetUtils.getLocalHost() + \", supported protocol: \" + ExtensionLoader\r\n-                        .getExtensionLoader(Protocol.class)\r\n-                        .getSupportedExtensions()));\r\n+                logger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() +\r\n+                        \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() +\r\n+                        \" to consumer \" + NetUtils.getLocalHost() + \", supported protocol: \" +\r\n+                        ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));\r\n                 continue;\r\n             }\r\n             URL url = mergeUrl(providerUrl);\r\n@@ -437,71 +427,27 @@ private URL mergeUrl(URL providerUrl) {\n     }\r\n \r\n     private URL overrideWithConfigurator(URL providerUrl) {\r\n-        List<Configurator> localConfigurators = this.configurators; // local reference\r\n-        if (localConfigurators != null && !localConfigurators.isEmpty()) {\r\n-            for (Configurator configurator : localConfigurators) {\r\n-                providerUrl = configurator.configure(providerUrl);\r\n-            }\r\n-        }\r\n+        // override url with configurator from \"override://\" URL for dubbo 2.6 and before\r\n+        providerUrl = overrideWithConfigurators(this.configurators, providerUrl);\r\n \r\n-        List<Configurator> localAppDynamicConfigurators = consumerConfigurationListener.getConfigurators(); // local reference\r\n-        if (localAppDynamicConfigurators != null && !localAppDynamicConfigurators.isEmpty()) {\r\n-            for (Configurator configurator : localAppDynamicConfigurators) {\r\n-                providerUrl = configurator.configure(providerUrl);\r\n-            }\r\n-        }\r\n+        // override url with configurator from configurator from \"app-name.configurators\"\r\n+        providerUrl = overrideWithConfigurators(consumerConfigurationListener.getConfigurators(), providerUrl);\r\n \r\n+        // override url with configurator from configurators from \"service-name.configurators\"\r\n         if (serviceConfigurationListener != null) {\r\n-            List<Configurator> localDynamicConfigurators = serviceConfigurationListener.getConfigurators(); // local reference\r\n-            if (localDynamicConfigurators != null && !localDynamicConfigurators.isEmpty()) {\r\n-                for (Configurator configurator : localDynamicConfigurators) {\r\n-                    providerUrl = configurator.configure(providerUrl);\r\n-                }\r\n-            }\r\n+            providerUrl = overrideWithConfigurators(serviceConfigurationListener.getConfigurators(), providerUrl);\r\n         }\r\n \r\n         return providerUrl;\r\n     }\r\n \r\n-    /**\r\n-     * Transform the invokers list into a mapping relationship with a method\r\n-     *\r\n-     * @param invokersMap Invoker Map\r\n-     * @return Mapping relation between Invoker and method\r\n-     */\r\n-    private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {\r\n-        Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();\r\n-        // According to the methods classification declared by the provider URL, the methods is compatible with the registry to execute the filtered methods\r\n-        List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();\r\n-        if (invokersMap != null && invokersMap.size() > 0) {\r\n-            for (Invoker<T> invoker : invokersMap.values()) {\r\n-                String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\r\n-                if (parameter != null && parameter.length() > 0) {\r\n-                    String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\r\n-                    if (methods != null && methods.length > 0) {\r\n-                        for (String method : methods) {\r\n-                            if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) {\r\n-                                List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\r\n-                                if (methodInvokers == null) {\r\n-                                    methodInvokers = new ArrayList<Invoker<T>>();\r\n-                                    newMethodInvokerMap.put(method, methodInvokers);\r\n-                                }\r\n-                                methodInvokers.add(invoker);\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                }\r\n-                invokersList.add(invoker);\r\n+    private URL overrideWithConfigurators(List<Configurator> configurators, URL url) {\r\n+        if (configurators != null && !configurators.isEmpty()) {\r\n+            for (Configurator configurator : configurators) {\r\n+                url = configurator.configure(url);\r\n             }\r\n         }\r\n-        newMethodInvokerMap.put(Constants.ANY_VALUE, invokersList);\r\n-        // sort and unmodifiable\r\n-        for (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {\r\n-            List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\r\n-            Collections.sort(methodInvokers, InvokerComparator.getComparator());\r\n-            newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\r\n-        }\r\n-        return Collections.unmodifiableMap(newMethodInvokerMap);\r\n+        return url;\r\n     }\r\n \r\n     /**\r\n@@ -571,8 +517,10 @@ private void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap, Map\n     public List<Invoker<T>> doList(Invocation invocation) {\r\n         if (forbidden) {\r\n             // 1. No service provider 2. Service providers are disabled\r\n-            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION, \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl()\r\n-                    .getServiceKey() + \" on consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\");\r\n+            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION, \"No provider available from registry \" +\r\n+                    getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" +\r\n+                    NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() +\r\n+                    \", please check status of providers(disabled, not registered or in blacklist).\");\r\n         }\r\n \r\n         if (multiGroup) {\r\n@@ -647,33 +595,16 @@ public void buildRouterChain(URL url) {\n         return invokers;\r\n     }\r\n \r\n-    private static class InvokerComparator implements Comparator<Invoker<?>> {\r\n-\r\n-        private static final InvokerComparator comparator = new InvokerComparator();\r\n-\r\n-        private InvokerComparator() {\r\n-        }\r\n-\r\n-        public static InvokerComparator getComparator() {\r\n-            return comparator;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int compare(Invoker<?> o1, Invoker<?> o2) {\r\n-            return o1.getUrl().toString().compareTo(o2.getUrl().toString());\r\n-        }\r\n-\r\n-    }\r\n-\r\n     private boolean isValidCategory(URL url) {\r\n         String category = url.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);\r\n-        if ((ROUTERS_CATEGORY.equals(category) || ROUTE_PROTOCOL.equals(url.getProtocol())) || PROVIDERS_CATEGORY.equals(category) || CONFIGURATORS_CATEGORY\r\n-                .equals(category) || DYNAMIC_CONFIGURATORS_CATEGORY.equals(category) || APP_DYNAMIC_CONFIGURATORS_CATEGORY\r\n-                .equals(category)) {\r\n+        if ((ROUTERS_CATEGORY.equals(category) || ROUTE_PROTOCOL.equals(url.getProtocol())) ||\r\n+                PROVIDERS_CATEGORY.equals(category) ||\r\n+                CONFIGURATORS_CATEGORY.equals(category) || DYNAMIC_CONFIGURATORS_CATEGORY.equals(category) ||\r\n+                APP_DYNAMIC_CONFIGURATORS_CATEGORY.equals(category)) {\r\n             return true;\r\n         }\r\n-        logger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils\r\n-                .getLocalHost());\r\n+        logger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" +\r\n+                getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost());\r\n         return false;\r\n     }\r\n \r",
                "changes": 161
            }
        ],
        "unit_tests": [
            "RegistryDirectoryTest.java",
            "UrlUtilsTest.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "dubbo-registry/dubbo-registry-default/src/test/java/org/apache/dubbo/registry/dubbo/RegistryDirectoryTest.java",
        "buggy_files": [
            "dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java",
            "dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java"
        ],
        "fixed": true
    }
]