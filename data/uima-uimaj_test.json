{
    "uima-uimaj_16526d6": {
        "repo": "uima-uimaj",
        "message": "[UIMA-4674] avoid npe when locator value not available\n\ngit-svn-id: https://svn.apache.org/repos/asf/uima/uimaj/branches/experiment-v3-jcas@1759855 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/uima-uimaj/commit/16526d6f2e58da9582ff0d9dfbc7f6443513aeff",
        "parent": "https://github.com/apache/uima-uimaj/commit/3fed532b0831f01ab021b914e06c93d265c380e7",
        "bug_id": "uima-uimaj_16526d6",
        "file": [
            {
                "sha": "0fcb0b7213d930e4bf49fa74e4dfdc121d954986",
                "filename": "uimaj-core/src/main/java/org/apache/uima/cas/impl/XmiCasDeserializer.java",
                "blob_url": "https://github.com/apache/uima-uimaj/blob/16526d6f2e58da9582ff0d9dfbc7f6443513aeff/uimaj-core/src/main/java/org/apache/uima/cas/impl/XmiCasDeserializer.java",
                "raw_url": "https://github.com/apache/uima-uimaj/raw/16526d6f2e58da9582ff0d9dfbc7f6443513aeff/uimaj-core/src/main/java/org/apache/uima/cas/impl/XmiCasDeserializer.java",
                "status": "modified",
                "changes": 6,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/uima-uimaj/contents/uimaj-core/src/main/java/org/apache/uima/cas/impl/XmiCasDeserializer.java?ref=16526d6f2e58da9582ff0d9dfbc7f6443513aeff",
                "patch": "@@ -628,8 +628,8 @@ private void doDeferFsOrThrow(String idStr, String nameSpaceURI, String localNam\n       this.deferredFsElement = new OotsElementData(\n           idStr, \n           new XmlElementName(nameSpaceURI, localName, qualifiedName),\n-          locator.getLineNumber(),\n-          locator.getColumnNumber());\n+          (locator == null) ? 0 : locator.getLineNumber(),\n+          (locator == null) ? 0 : locator.getColumnNumber());\n       \n       deferredFSs.add(this.deferredFsElement);\n       // This next call isn't about oots data, it's reusing that to store the attributes with the deferred thing.\n@@ -1871,7 +1871,7 @@ public void ignorableWhitespace(char[] arg0, int arg1, int arg2) throws SAXExcep\n      */\n     @Override\n     public void setDocumentLocator(Locator loc) {\n-      // System.out.println(\"Setting document locator.\");\n+//       System.out.println(\"debug  DEBUG  Setting document locator.\");\n       this.locator = loc;\n     }\n ",
                "deletions": 3
            }
        ],
        "patched_files": [
            "XmiCasDeserializer.java"
        ],
        "unit_tests": [
            "XmiCasDeserializerTest.java"
        ]
    },
    "uima-uimaj_d1ef364": {
        "repo": "uima-uimaj",
        "message": "[UIMA-3776] fix failing test cases which get a NPE trying to get the class info from the Java Bean when the only getter is an array getter (shows up in CPE tests)\n\ngit-svn-id: https://svn.apache.org/repos/asf/uima/uimaj/trunk@1590115 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/uima-uimaj/commit/d1ef364a3464835ba233e8ada7bf7e9ebe4f03a6",
        "parent": "https://github.com/apache/uima-uimaj/commit/1f5a3549ccb2312759e875ec531f279817d6a872",
        "bug_id": "uima-uimaj_d1ef364",
        "file": [
            {
                "sha": "954a379603aa65b552a782a5e874aa440133ba21",
                "filename": "uimaj-core/src/main/java/org/apache/uima/resource/metadata/impl/MetaDataObject_impl.java",
                "blob_url": "https://github.com/apache/uima-uimaj/blob/d1ef364a3464835ba233e8ada7bf7e9ebe4f03a6/uimaj-core/src/main/java/org/apache/uima/resource/metadata/impl/MetaDataObject_impl.java",
                "raw_url": "https://github.com/apache/uima-uimaj/raw/d1ef364a3464835ba233e8ada7bf7e9ebe4f03a6/uimaj-core/src/main/java/org/apache/uima/resource/metadata/impl/MetaDataObject_impl.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/uima-uimaj/contents/uimaj-core/src/main/java/org/apache/uima/resource/metadata/impl/MetaDataObject_impl.java?ref=d1ef364a3464835ba233e8ada7bf7e9ebe4f03a6",
                "patch": "@@ -245,7 +245,7 @@ private void getAttributesFromBeans(final Class<? extends MetaDataObject_impl> c\n         String propName = pd.getName();\n         Class<?> propClass = pd.getPropertyType();\n         // translate primitive types (int, boolean, etc.) to wrapper classes\n-        if (propClass.isPrimitive()) {\n+        if (null != propClass && propClass.isPrimitive()) {\n           propClass = getWrapperClass(propClass);\n         }\n         MetaDataAttr mda = new MetaDataAttr(propName, pd.getReadMethod(), pd.getWriteMethod(), propClass);",
                "deletions": 1
            }
        ],
        "patched_files": [
            "MetaDataObject_impl.java"
        ],
        "unit_tests": [
            "MetaDataObject_implTest.java"
        ]
    },
    "uima-uimaj_cf9d5c9": {
        "repo": "uima-uimaj",
        "message": "[UIMA-2409] fixed NPE, and also clarified that source/dest CASes must be different; added checks, add test cases.\n\ngit-svn-id: https://svn.apache.org/repos/asf/uima/uimaj/trunk@1504178 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/uima-uimaj/commit/cf9d5c9b007f9c377ce244d5e155d0971b048bc0",
        "parent": "https://github.com/apache/uima-uimaj/commit/a5b532c5c2e4408a7150426b275f0173b175d4bb",
        "bug_id": "uima-uimaj_cf9d5c9",
        "file": [
            {
                "sha": "0afb81ec51c0326da4890e2c776be6627118fd9b",
                "filename": "uimaj-core/src/main/java/org/apache/uima/UIMARuntimeException.java",
                "blob_url": "https://github.com/apache/uima-uimaj/blob/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/main/java/org/apache/uima/UIMARuntimeException.java",
                "raw_url": "https://github.com/apache/uima-uimaj/raw/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/main/java/org/apache/uima/UIMARuntimeException.java",
                "status": "modified",
                "changes": 18,
                "additions": 18,
                "contents_url": "https://api.github.com/repos/apache/uima-uimaj/contents/uimaj-core/src/main/java/org/apache/uima/UIMARuntimeException.java?ref=cf9d5c9b007f9c377ce244d5e155d0971b048bc0",
                "patch": "@@ -117,6 +117,24 @@\n    */\n   public static final String RESULT_SPEC_NULL = \"result_spec_null\";\n \n+  /**\n+   * Message key for a standard UIMA exception message:\n+   * In CasCopier, the {0} view is doesn't belong to the original {0} CAS specified when creating the CasCopier instance \n+   */\n+  public static final String VIEW_NOT_PART_OF_CAS = \"view_not_part_of_cas\";\n+  \n+  /**\n+   * Message key for a standard UIMA exception message:\n+   * Unsupported invocation of CasCopier copyCasView, specifying a source or destination as a base CAS.  \n+   */\n+  public static final String UNSUPPORTED_CAS_COPY_TO_OR_FROM_BASE_CAS = \"unsupported_cas_copy_view_base_cas\";\n+ \n+  /**\n+   * Message key for a standard UIMA exception message:\n+   * It is not permitted to use CasCopier to copy a Cas to itself, even in another view.  \n+   */\n+  public static final String ILLEGAL_CAS_COPY_TO_SAME_CAS = \"illegal_cas_copy_to_same_cas\";\n+  \n   /**\n    * Creates a new exception with a null message.\n    */",
                "deletions": 0
            },
            {
                "sha": "1042065a708013394430169df05c4c1533513d06",
                "filename": "uimaj-core/src/main/java/org/apache/uima/util/CasCopier.java",
                "blob_url": "https://github.com/apache/uima-uimaj/blob/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/main/java/org/apache/uima/util/CasCopier.java",
                "raw_url": "https://github.com/apache/uima-uimaj/raw/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/main/java/org/apache/uima/util/CasCopier.java",
                "status": "modified",
                "changes": 138,
                "additions": 101,
                "contents_url": "https://api.github.com/repos/apache/uima-uimaj/contents/uimaj-core/src/main/java/org/apache/uima/util/CasCopier.java?ref=cf9d5c9b007f9c377ce244d5e155d0971b048bc0",
                "patch": "@@ -53,11 +53,22 @@\n  * CasCopier and use it to copy multiple FeatureStructures. The CasCopier will remember previously\n  * copied FeatureStructures, so if you later copy another FS that has a reference to a previously\n  * copied FS, it will not duplicate the multiply-referenced FS.\n+ * \n  */\n public class CasCopier {\n-  private CAS mSrcCas;\n-  private CAS mDestCas;\n+  private final CAS mSrcBaseCas;\n+  private final CAS mDestBaseCas;\n+  \n+  private final CAS mOriginalSrcCasView;\n+  private final CAS mOriginalTgtCasView;\n+  /**\n+   * The source view name - may be null if the view is of the base CAS\n+   */\n   private String mSrcCasViewName;\n+  /**\n+   * The target view name - not used unless doing a view copy \n+   * Allows copying a view to another CAS under a different name\n+   */\n   private String mTgtCasViewName;\n   private LowLevelCAS mLowLevelDestCas;\n   final private Feature mDestSofaFeature;\n@@ -85,6 +96,9 @@\n    *       the destination CAS, the copy will fail (in other words, the lenient setting is false,\n    *       by default).\n    *\n+   * Note: The source and destination CASes must be different, and have different\n+   *       base CASs (they cannot be two different views of the same CAS)\n+   *       \n    * @param aSrcCas\n    *          the CAS to copy from.\n    * @param aDestCas\n@@ -100,6 +114,9 @@ public CasCopier(CAS aSrcCas, CAS aDestCas) {\n    * for each source CAS. This version of the constructor supports a \"lenient copy\" option. When set,\n    * the CAS copy function will ignore (not attempt to copy) FSs and features not defined in the type system\n    * of the destination CAS, rather than throwing an exception.\n+   * \n+   * Note: The source and destination CASes must be different, and have different\n+   *       base CASs (they cannot be two different views of the same CAS)\n    *\n    * @param aSrcCas\n    *          the CAS to copy from.\n@@ -109,10 +126,17 @@ public CasCopier(CAS aSrcCas, CAS aDestCas) {\n    *          ignore FSs and features not defined in the type system of the destination CAS\n    */\n   public CasCopier(CAS aSrcCas, CAS aDestCas, boolean lenient) {\n-    mSrcCas = aSrcCas;\n-    mDestCas = aDestCas;\n+    mOriginalSrcCasView = aSrcCas;\n+    mOriginalTgtCasView = aDestCas;\n+    mSrcBaseCas = ((CASImpl)aSrcCas).getBaseCAS();\n+    mDestBaseCas = ((CASImpl)aDestCas).getBaseCAS();\n+    \n     mDestSofaFeature = aDestCas.getTypeSystem().getFeatureByFullName(CAS.FEATURE_FULL_NAME_SOFA);    \n     this.lenient = lenient;\n+    \n+    if (mSrcBaseCas == mDestBaseCas) {\n+      throw new UIMARuntimeException(UIMARuntimeException.ILLEGAL_CAS_COPY_TO_SAME_CAS, null); \n+    }\n   }\n   \n   /**\n@@ -183,11 +207,16 @@ public static void copyCas(CAS aSrcCas, CAS aDestCas, boolean aCopySofa, boolean\n    * Cross-view references may result in creating additional views in the destination CAS;\n    * for these views, any Sofa data in the source is *not* copied.\n    * \n-   * @param aSrcCasView the CAS to copy from\n+   * If the source and destination CASes (as set in the constructor for this class) \n+   * are the same, or are two different views of the same CAS, then\n+   * this method will make a deep copy of all the feature structures in the view,\n+   * duplicating them, and indexing them.\n+   * \n+   * @param aSrcCasView the CAS to copy from.  This must be a view in the src Cas set by the constructor\n    * @param aCopySofa if true, the sofa data and mimeType will be copied. If false they will not.\n    */\n   public void copyCasView(CAS aSrcCasView, boolean aCopySofa) {\n-    copyCasView(aSrcCasView, getOrCreateView(mDestCas, aSrcCasView.getViewName()), aCopySofa);\n+    copyCasView(aSrcCasView, getOrCreateView(mDestBaseCas, aSrcCasView.getViewName()), aCopySofa);\n   }\n   \n   /**\n@@ -201,11 +230,16 @@ public void copyCasView(CAS aSrcCasView, boolean aCopySofa) {\n    * for these views, any Sofa data in the source is *not* copied.  Any views created because\n    * of cross-view references will have the same view name as in the source.\n    * \n+   * If the source and destination CASes (as set in the constructor for this class) \n+   * are the same, or are two different views of the same CAS, then\n+   * this method will make a deep copy of all the feature structures in the view,\n+   * duplicating them, and indexing them.\n+   *\n    * @param aSrcCasViewName the name of the view in the source CAS to copy from\n    * @param aCopySofa if true, the sofa data and mimeType will be copied. If false they will not.\n    */\n   public void copyCasView(String aSrcCasViewName, boolean aCopySofa) {\n-    copyCasView(getOrCreateView(mSrcCas, aSrcCasViewName), aCopySofa);\n+    copyCasView(getOrCreateView(mSrcBaseCas, aSrcCasViewName), aCopySofa);\n   }\n   \n   /**\n@@ -220,12 +254,17 @@ public void copyCasView(String aSrcCasViewName, boolean aCopySofa) {\n    * for these views, any Sofa data in the source is *not* copied.  Any views created because\n    * of cross-view references will have the same view name as in the source.\n    * \n+   * If the source and destination CASes (as set in the constructor for this class) \n+   * are the same, or are two different views of the same CAS, then\n+   * this method will make a deep copy of all the feature structures in the view,\n+   * duplicating them, and indexing them.\n+   * \n    * @param aSrcCasView The view in the source to copy from\n    * @param aTgtCasViewName The name of the view in the destination CAS to copy into\n    * @param aCopySofa if true, the sofa data and mimeType will be copied. If false they will not.\n    */\n   public void copyCasView(CAS aSrcCasView, String aTgtCasViewName, boolean aCopySofa) {\n-    copyCasView(aSrcCasView, getOrCreateView(mDestCas, aTgtCasViewName), aCopySofa);\n+    copyCasView(aSrcCasView, getOrCreateView(mDestBaseCas, aTgtCasViewName), aCopySofa);\n   }\n \n   /**\n@@ -238,41 +277,65 @@ public void copyCasView(CAS aSrcCasView, String aTgtCasViewName, boolean aCopySo\n    * for these views, any Sofa data in the source is *not* copied.  Any views created because\n    * of cross-view references will have the same view name as in the source.\n    * \n+   * If the source and destination CASes (as set in the constructor for this class) \n+   * are the same, or are two different views of the same CAS, then\n+   * this method will make a deep copy of all the feature structures in the view,\n+   * duplicating them, and indexing them.\n+   * \n    * @param aSrcCasViewName The name of the view in the Source CAS to copy from\n    * @param aTgtCasView The view in the destination CAS to copy into\n    * @param aCopySofa if true, the sofa data and mimeType will be copied. If false they will not.\n    */\n   public void copyCasView(String aSrcCasViewName, CAS aTgtCasView, boolean aCopySofa) {\n-    copyCasView(getOrCreateView(mSrcCas, aSrcCasViewName), aTgtCasView, aCopySofa);\n+    copyCasView(getOrCreateView(mSrcBaseCas, aSrcCasViewName), aTgtCasView, aCopySofa);\n   }\n \n   /**\n    * Does a deep copy of the contents of one CAS View into another CAS view,\n    * with a possibly different name.\n+   * \n+   * The CASes must be different (that is, they cannot be 2 views of the same CAS).  \n+   * \n    * All FeatureStructures \n    * (except for those dropped because the target type system doesn't have the needed type) that are indexed \n    * in the source CAS view will become indexed in the target view.\n    * Cross-view references may result in creating additional views in the destination CAS;\n    * for these views, any Sofa data in the source is *not* copied.  Any views created because\n    * of cross-view references will have the same view name as in the source.\n    * \n+   * If called on the same CAS (to copy one view into another one, within one CAS), it will\n+   * create duplicates of the Feature Structures.\n+   * \n    * @param aSrcCasView\n-   *          the CAS to copy from\n+   *          the CAS to copy from. This must be a view of the srcCas set in the constructor\n    * @param aCopySofa\n-   *          if true, the sofa data and mimeType will be copied. If false they will not.\n+   *          if true, the sofa data and mimeType will be copied. If false they will not.  \n+   *          If true and the sofa data is already set in the target, will throw CASRuntimeException        \n    */\n   public void copyCasView(CAS aSrcCasView, CAS aTgtCasView, boolean aCopySofa) {\n-    if (aSrcCasView == aTgtCasView) {\n-      throw new UIMARuntimeException(UIMARuntimeException.ILLEGAL_CAS_COPY_TO_SAME_CAS_SAME_VIEW, null);\n+//    if (aSrcCasView == aTgtCasView) {\n+//      throw new UIMARuntimeException(UIMARuntimeException.ILLEGAL_CAS_COPY_TO_SAME_CAS_SAME_VIEW, null);\n+//    }\n+    \n+//    if (aSrcCasView == ((CASImpl)aSrcCasView).getBaseCAS() ||\n+//        aTgtCasView == ((CASImpl)aTgtCasView).getBaseCAS())\n+//      throw new UIMARuntimeException(UIMARuntimeException.UNSUPPORTED_CAS_COPY_TO_OR_FROM_BASE_CAS, null);\n+    \n+    if (mSrcBaseCas != ((CASImpl)aSrcCasView).getBaseCAS()) {\n+      throw new UIMARuntimeException(UIMARuntimeException.VIEW_NOT_PART_OF_CAS, new Object[] {\"Source\"});\n+    }\n+    if (mDestBaseCas != ((CASImpl)aTgtCasView).getBaseCAS()) {\n+      throw new UIMARuntimeException(UIMARuntimeException.VIEW_NOT_PART_OF_CAS, new Object[] {\"Destination\"});\n     }\n     \n-    mSrcCas = aSrcCasView;\n-    mSrcCasViewName = aSrcCasView.getViewName();\n-       \n-    mDestCas = aTgtCasView;\n+    mSrcCasViewName = aSrcCasView.getViewName(); \n     mTgtCasViewName = aTgtCasView.getViewName();\n-    \n-    mLowLevelDestCas = mDestCas.getLowLevelCAS();\n+\n+    if (null == mSrcCasViewName || null == mTgtCasViewName ) {\n+      throw new UIMARuntimeException(UIMARuntimeException.UNSUPPORTED_CAS_COPY_TO_OR_FROM_BASE_CAS, null);\n+    }\n+        \n+    mLowLevelDestCas = mDestBaseCas.getLowLevelCAS();\n     \n     // The top level sofa associated with this view is copied (or not)\n     \n@@ -300,7 +363,8 @@ public void copyCasView(CAS aSrcCasView, CAS aTgtCasView, boolean aCopySofa) {\n     \n     Set<FeatureStructure> indexedFs = new HashSet<FeatureStructure>();\n     \n-    // We don't clear the map here, in order to skip actually copying the\n+    // The indexFs set starts out \"cleared\", but \n+    // we don't clear the cas copier instance map \"mFsMap\" here, in order to skip actually copying the\n     //   FSs when doing a full CAS copy with multiple views - the 2nd and subsequent\n     //   views don't copy, but they do index.\n     \n@@ -368,15 +432,15 @@ public FeatureStructure copyFs(FeatureStructure aFS) {\n     // note these variables are null if copyFs is called after\n     //   creating an instance of this class\n     if (null == mSrcCasViewName) {\n-      mSrcCasViewName = mSrcCas.getViewName();\n+      mSrcCasViewName = mOriginalSrcCasView.getViewName();  // may set it to null, if Cas is base view\n     }\n     \n     if (null == mTgtCasViewName) {\n-      mTgtCasViewName = mDestCas.getViewName();\n+      mTgtCasViewName = mOriginalTgtCasView.getViewName(); // may set it to null, if Cas is base view\n     }\n     \n     if (null == mLowLevelDestCas) {\n-      mLowLevelDestCas = mDestCas.getLowLevelCAS();\n+      mLowLevelDestCas = mDestBaseCas.getLowLevelCAS();\n     }\n     \n     return copyFs2(aFS);\n@@ -403,7 +467,7 @@ private FeatureStructure copyFs2(FeatureStructure aFS) {\n    */\n   private FeatureStructure copyFsInner(FeatureStructure aFS) {\n     // FS must be in the source CAS\n-    assert ((CASImpl) aFS.getCAS()).getBaseCAS() == ((CASImpl) mSrcCas).getBaseCAS();\n+    assert ((CASImpl) aFS.getCAS()).getBaseCAS() == mSrcBaseCas;\n \n     // check if we already copied this FS\n     FeatureStructure copy = (FeatureStructure) mFsMap.get(aFS);\n@@ -419,7 +483,7 @@ private FeatureStructure copyFsInner(FeatureStructure aFS) {\n     // same Sofa ID in the target CAS. If it does not exist it will be created.\n     if (aFS instanceof SofaFS) {\n       String destSofaId = getDestSofaId(((SofaFS) aFS).getSofaID());\n-      return getOrCreateView(mDestCas, destSofaId).getSofa();\n+      return getOrCreateView(mDestBaseCas, destSofaId).getSofa();\n     }\n \n     // DocumentAnnotation - instead of creating a new instance, reuse the automatically created\n@@ -432,7 +496,7 @@ private FeatureStructure copyFsInner(FeatureStructure aFS) {\n       //   but this is unlikely.  To have this case this would require\n       //   indexing some other feature structure in this view, which, in turn,\n       //   has a reference to the DocumentAnnotation FS belonging to another view\n-      CAS destView = getOrCreateView(mDestCas, destViewName);\n+      CAS destView = getOrCreateView(mDestBaseCas, destViewName);\n       FeatureStructure destDocAnnot = destView.getDocumentAnnotation();\n       if (destDocAnnot != null) {  // Note: is always non-null, getDocumentAnnotation creates if not exist\n         copyFeatures(aFS, destDocAnnot);\n@@ -448,7 +512,7 @@ private FeatureStructure copyFsInner(FeatureStructure aFS) {\n     }\n \n     // create a new FS of the same type in the target CAS\n-    Type destType = (mDestCas.getTypeSystem() == mSrcCas.getTypeSystem()) ? srcType : mDestCas\n+    Type destType = (mDestBaseCas.getTypeSystem() == mSrcBaseCas.getTypeSystem()) ? srcType : mDestBaseCas\n         .getTypeSystem().getType(srcType.getName());\n     if (destType == null) {\n       // If in lenient mode, do not act on this FS. Instead just\n@@ -478,7 +542,7 @@ private FeatureStructure copyFsInner(FeatureStructure aFS) {\n   }\n   \n   private String getDestSofaId(String id) {\n-    return mSrcCasViewName.equals(id) ? mTgtCasViewName : id;\n+    return (null != mSrcCasViewName && mSrcCasViewName.equals(id)) ? mTgtCasViewName : id;\n   }\n   \n   /**\n@@ -556,7 +620,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof StringArrayFS) {\n       StringArrayFS arrayFs = (StringArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      StringArrayFS destFS = mDestCas.createStringArrayFS(len);\n+      StringArrayFS destFS = mDestBaseCas.createStringArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -565,7 +629,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof IntArrayFS) {\n       IntArrayFS arrayFs = (IntArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      IntArrayFS destFS = mDestCas.createIntArrayFS(len);\n+      IntArrayFS destFS = mDestBaseCas.createIntArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -574,7 +638,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof ByteArrayFS) {\n       ByteArrayFS arrayFs = (ByteArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      ByteArrayFS destFS = mDestCas.createByteArrayFS(len);\n+      ByteArrayFS destFS = mDestBaseCas.createByteArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -583,7 +647,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof ShortArrayFS) {\n       ShortArrayFS arrayFs = (ShortArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      ShortArrayFS destFS = mDestCas.createShortArrayFS(len);\n+      ShortArrayFS destFS = mDestBaseCas.createShortArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -592,7 +656,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof LongArrayFS) {\n       LongArrayFS arrayFs = (LongArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      LongArrayFS destFS = mDestCas.createLongArrayFS(len);\n+      LongArrayFS destFS = mDestBaseCas.createLongArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -601,7 +665,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof FloatArrayFS) {\n       FloatArrayFS arrayFs = (FloatArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      FloatArrayFS destFS = mDestCas.createFloatArrayFS(len);\n+      FloatArrayFS destFS = mDestBaseCas.createFloatArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -610,7 +674,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof DoubleArrayFS) {\n       DoubleArrayFS arrayFs = (DoubleArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      DoubleArrayFS destFS = mDestCas.createDoubleArrayFS(len);\n+      DoubleArrayFS destFS = mDestBaseCas.createDoubleArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -619,7 +683,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof BooleanArrayFS) {\n       BooleanArrayFS arrayFs = (BooleanArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      BooleanArrayFS destFS = mDestCas.createBooleanArrayFS(len);\n+      BooleanArrayFS destFS = mDestBaseCas.createBooleanArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         destFS.set(i, arrayFs.get(i));\n       }\n@@ -628,7 +692,7 @@ private FeatureStructure copyArray(FeatureStructure aSrcFs) {\n     if (aSrcFs instanceof ArrayFS) {\n       ArrayFS arrayFs = (ArrayFS) aSrcFs;\n       int len = arrayFs.size();\n-      ArrayFS destFS = mDestCas.createArrayFS(len);\n+      ArrayFS destFS = mDestBaseCas.createArrayFS(len);\n       for (int i = 0; i < len; i++) {\n         FeatureStructure srcElem = arrayFs.get(i);\n         if (srcElem != null) {",
                "deletions": 37
            },
            {
                "sha": "f11de20d6ade1a5fb387b597a62c93b3967e5790",
                "filename": "uimaj-core/src/main/resources/org/apache/uima/UIMAException_Messages.properties",
                "blob_url": "https://github.com/apache/uima-uimaj/blob/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/main/resources/org/apache/uima/UIMAException_Messages.properties",
                "raw_url": "https://github.com/apache/uima-uimaj/raw/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/main/resources/org/apache/uima/UIMAException_Messages.properties",
                "status": "modified",
                "changes": 12,
                "additions": 8,
                "contents_url": "https://api.github.com/repos/apache/uima-uimaj/contents/uimaj-core/src/main/resources/org/apache/uima/UIMAException_Messages.properties?ref=cf9d5c9b007f9c377ce244d5e155d0971b048bc0",
                "patch": "@@ -39,8 +39,6 @@ define_cas_pool_called_twice = The method CasManager.defineCasPool() was called\n        \n unsupported_cas_interface = Unsupported CAS interface {0}.\n \n-illegal_copy_same_cas_same_view = CAS Copying of the same view to the same CAS with the same view name is not allowed.\n-\n type_not_found_during_cas_copy = Attempted to copy a FeatureStructure of type \"{0}\", which is not defined in the type system of the destination CAS.\n \n feature_not_found_during_cas_copy = Attempted to copy a Feature \"{0}\", which is not defined in the type system of the destination CAS.\n@@ -49,6 +47,12 @@ uima_context_null = Saved UIMA context is null; probable cause: Annotator''s ini\n \n result_spec_null = Saved result specification is null; probable cause: Annotator overrode setResultSpecification(spec) but failed to call super.setResultSpecification(spec).\n \n+view_not_part_of_cas = In CasCopier, the {0} view is doesn''t belong to the original {0} CAS specified when creating the CasCopier instance.\n+\n+illegal_cas_copy_to_same_cas = It is not permitted to use CasCopier to copy a Cas to itself, even in another view.\n+\n+unsupported_cas_copy_view_base_cas = Unsupported invocation of CasCopier copyCasView, specifying a source or destination as a base CAS.\n+\n #--------------------------\n #UIMA_IllegalStateException\n #--------------------------          \n@@ -199,7 +203,7 @@ remove_ae_from_flow_not_supported = The FlowController class {0} does not suppor\n  Analysis Engines cannot be dynamically removed from the flow.\n  \n flow_cannot_continue_after_remove = The Analysis Engine(s) {0} have been removed from the flow, and the FlowController \\\n-  has determined that the Aggregate Analysis Engine's processing can no longer continue.\n+  has determined that the Aggregate Analysis Engine''s processing can no longer continue.\n  \n  \n #-------------------------------\n@@ -393,7 +397,7 @@ sofa_mapping_not_supported_for_remote = Sofa mappings were specified for the rem\n undefined_key_in_flow = The descriptor for Aggregate Analysis Engine \"{0}\" specified an invalid flow.  The key \"{1}\" was used in the flow \\\n   but is not defined as a key in the <delegateAnalysisEngineSpecifiers> element of the descriptor. (Descriptor: {2})\n \n-invalid_action_after_cas_multiplier = The value \"{0}\" is an invalid value for the FixedFlowController's \"ActionAfterCasMultiplier\" configuration \\\n+invalid_action_after_cas_multiplier = The value \"{0}\" is an invalid value for the FixedFlowController''s \"ActionAfterCasMultiplier\" configuration \\\n   parameter.  Valid values are \"continue\", \"stop\", \"drop\", and \"dropIfNewCasProduced\".\n     \n flow_controller_requires_flow_constraints = The Flow Controller \"{0}\" requires a flow contraints element of type \"{1}\" in the aggregate descriptor. \\",
                "deletions": 4
            },
            {
                "sha": "671390ed3a82f41264de4ef4214f43fa2bad1087",
                "filename": "uimaj-core/src/test/java/org/apache/uima/util/CasCopierTest.java",
                "blob_url": "https://github.com/apache/uima-uimaj/blob/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/test/java/org/apache/uima/util/CasCopierTest.java",
                "raw_url": "https://github.com/apache/uima-uimaj/raw/cf9d5c9b007f9c377ce244d5e155d0971b048bc0/uimaj-core/src/test/java/org/apache/uima/util/CasCopierTest.java",
                "status": "modified",
                "changes": 21,
                "additions": 21,
                "contents_url": "https://api.github.com/repos/apache/uima-uimaj/contents/uimaj-core/src/test/java/org/apache/uima/util/CasCopierTest.java?ref=cf9d5c9b007f9c377ce244d5e155d0971b048bc0",
                "patch": "@@ -27,6 +27,7 @@\n import junit.framework.TestCase;\n \n import org.apache.uima.UIMAFramework;\n+import org.apache.uima.UIMARuntimeException;\n import org.apache.uima.cas.ArrayFS;\n import org.apache.uima.cas.CAS;\n import org.apache.uima.cas.FeatureStructure;\n@@ -97,6 +98,15 @@ public void testCopyCas() throws Exception {\n     CAS destCasBase = ((CASImpl) destCas).getBaseCAS();\n     CasCopier.copyCas(srcCasBase, destCasBase, true);\n     CasComparer.assertEquals(srcCasBase, destCasBase);\n+    \n+    //try with source and dest cas the same\n+    Exception ee = null;\n+    try {\n+      CasCopier.copyCas(srcCasBase,  srcCasBase, false);\n+    } catch (Exception e) {\n+      ee = e;\n+    }\n+    assertTrue(ee instanceof UIMARuntimeException);\n   }\n   \n   public void testCopyCasWithDifferentTypeSystemObject() throws Exception {\n@@ -209,6 +219,17 @@ public void testCopyFs() throws Exception {\n     arrFS.set(2, relFS);\n     FeatureStructure copyArrFS = copier.copyFs(arrFS);\n     CasComparer.assertEquals(arrFS, copyArrFS);\n+    \n+    // test with using base cas\n+    destCas = CasCreationUtils.createCas(typeSystem, new TypePriorities_impl(), indexes);\n+    destCas.setDocumentText(srcCas.getDocumentText());\n+    copier = new CasCopier(((CASImpl)srcCas).getBaseCAS(), ((CASImpl)destCas).getBaseCAS());\n+\n+    annotIter = srcCas.getAnnotationIndex().iterator();\n+    annot = (FeatureStructure) annotIter.next();\n+    copy = copier.copyFs(annot);\n+    // verify copy\n+    CasComparer.assertEquals(annot, copy);\n   }\n \n   public void testAnnotationWithNullSofaRef() throws Exception {",
                "deletions": 0
            }
        ],
        "patched_files": [
            "UIMARuntimeException.java",
            "CasCopier.java"
        ],
        "unit_tests": [
            "CasCopierTest.java"
        ]
    }
}