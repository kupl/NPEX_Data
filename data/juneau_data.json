[
    {
        "repo": "juneau",
        "message": "[JUNEAU-86] Avoid NPE stopping RestMicroservice.",
        "commit": "https://github.com/apache/juneau/commit/6052578cdcdc41e6dde0b6acf08e8fbb88e71cee",
        "parent": "https://github.com/apache/juneau/commit/aa2065cab5281bd5d6f4d5bb0959bbb88d5663f1",
        "bug_id": "juneau_1",
        "file": [
            {
                "sha": "b9ae8262c9b0023cce133da46043205a77283338",
                "filename": "juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java",
                "blob_url": "https://github.com/apache/juneau/blob/6052578cdcdc41e6dde0b6acf08e8fbb88e71cee/juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java",
                "raw_url": "https://github.com/apache/juneau/raw/6052578cdcdc41e6dde0b6acf08e8fbb88e71cee/juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java",
                "status": "modified",
                "changes": 1056,
                "additions": 528,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java?ref=6052578cdcdc41e6dde0b6acf08e8fbb88e71cee",
                "patch": "@@ -1,528 +1,528 @@\n-// ***************************************************************************************************************************\r\n-// * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file *\r\n-// * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file        *\r\n-// * to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance            *\r\n-// * with the License.  You may obtain a copy of the License at                                                              *\r\n-// *                                                                                                                         *\r\n-// *  http://www.apache.org/licenses/LICENSE-2.0                                                                             *\r\n-// *                                                                                                                         *\r\n-// * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an  *\r\n-// * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the        *\r\n-// * specific language governing permissions and limitations under the License.                                              *\r\n-// ***************************************************************************************************************************\r\n-package org.apache.juneau.microservice;\r\n-\r\n-import java.io.*;\r\n-import java.net.*;\r\n-import java.util.*;\r\n-import java.util.logging.*;\r\n-\r\n-import javax.servlet.*;\r\n-\r\n-import org.apache.juneau.*;\r\n-import org.apache.juneau.config.*;\r\n-import org.apache.juneau.config.event.*;\r\n-import org.apache.juneau.internal.*;\r\n-import org.apache.juneau.svl.*;\r\n-import org.apache.juneau.utils.*;\r\n-import org.eclipse.jetty.server.*;\r\n-import org.eclipse.jetty.server.Handler;\r\n-import org.eclipse.jetty.server.handler.*;\r\n-import org.eclipse.jetty.servlet.*;\r\n-import org.eclipse.jetty.xml.*;\r\n-\r\n-/**\r\n- * Entry point for Juneau microservice that implements a REST interface using Jetty on a single port.\r\n- *\r\n- * <h5 class='topic'>Jetty Server Details</h5>\r\n- *\r\n- * The Jetty server is created by the {@link #createServer()} method and started with the {@link #startServer()} method.\r\n- * These methods can be overridden to provided customized behavior.\r\n- *\r\n- * <h5 class='topic'>Defining REST Resources</h5>\r\n- *\r\n- * Top-level REST resources are defined in the <code>jetty.xml</code> file as normal servlets.\r\n- *\r\n- * <h5 class='topic'>Logging</h5>\r\n- *\r\n- * Logging is initialized by the {@link #initLogging()} method.\r\n- * This method can be overridden to provide customized logging behavior.\r\n- *\r\n- * <h5 class='topic'>Lifecycle Listener Methods</h5>\r\n- * Subclasses can optionally implement the following event listener methods:\r\n- * <ul class='spaced-list'>\r\n- * \t<li>\r\n- * \t\t{@link #onStart()} - Gets executed before {@link #start()}.\r\n- * \t<li>\r\n- * \t\t{@link #onStop()} - Gets executed before {@link #stop()}.\r\n- * \t<li>\r\n- * \t\t{@link #onCreateServer()} - Gets executed before {@link #createServer()}.\r\n- * \t<li>\r\n- * \t\t{@link #onStartServer()} - Gets executed before {@link #startServer()}.\r\n- * \t<li>\r\n- * \t\t{@link #onPostStartServer()} - Gets executed after {@link #startServer()}.\r\n- * \t<li>\r\n- * \t\t{@link #onStopServer()} - Gets executed before {@link #stop()}.\r\n- * \t<li>\r\n- * \t\t{@link #onPostStopServer()} - Gets executed after {@link #stop()}.\r\n- * </ul>\r\n- */\r\n-public class RestMicroservice extends Microservice {\r\n-\r\n-\tServer server;\r\n-\tprivate Object jettyXml;\r\n-\tprivate final MessageBundle mb = MessageBundle.create(RestMicroservice.class, \"Messages\");\r\n-\r\n-\tprivate static volatile RestMicroservice INSTANCE;\r\n-\r\n-\t/**\r\n-\t * Returns the Microservice instance.\r\n-\t * <p>\r\n-\t * This method only works if there's only one Microservice instance in a JVM.\r\n-\t * Otherwise, it's just overwritten by the last call to {@link #RestMicroservice(String...)}.\r\n-\t *\r\n-\t * @return The Microservice instance, or <jk>null</jk> if there isn't one.\r\n-\t */\r\n-\tpublic static RestMicroservice getInstance() {\r\n-\t\tsynchronized(RestMicroservice.class) {\r\n-\t\t\treturn INSTANCE;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Main method.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses must also implement this method!\r\n-\t *\r\n-\t * @param args Command line arguments.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tpublic static void main(String[] args) throws Exception {\r\n-\t\tnew RestMicroservice(args).start().join();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Constructor.\r\n-\t *\r\n-\t * @param args Command line arguments.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tpublic RestMicroservice(String...args) throws Exception {\r\n-\t\tsuper(args);\r\n-\t\tsetInstance(this);\r\n-\t}\r\n-\r\n-\tprivate static void setInstance(RestMicroservice rm) {\r\n-\t\tsynchronized(RestMicroservice.class) {\r\n-\t\t\tINSTANCE = rm;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// Methods implemented on Microservice API\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice start() throws Exception {\r\n-\t\tsuper.start();\r\n-\t\tcreateServer();\r\n-\t\tstartServer();\r\n-\t\tstartConsole();\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice join() throws Exception {\r\n-\t\tserver.join();\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice stop() {\r\n-\t\tfinal Logger logger = getLogger();\r\n-\t\tfinal MessageBundle mb2 = mb;\r\n-\t\tThread t = new Thread() {\r\n-\t\t\t@Override /* Thread */\r\n-\t\t\tpublic void run() {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tif (server.isStopping() || server.isStopped())\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\tonStopServer();\r\n-\t\t\t\t\tout(mb2, \"StoppingServer\");\r\n-\t\t\t\t\tserver.stop();\r\n-\t\t\t\t\tout(mb2, \"ServerStopped\");\r\n-\t\t\t\t\tonPostStopServer();\r\n-\t\t\t\t} catch (Exception e) {\r\n-\t\t\t\t\tlogger.log(Level.WARNING, e.getLocalizedMessage(), e);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t};\r\n-\t\tt.start();\r\n-\t\ttry {\r\n-\t\t\tt.join();\r\n-\t\t} catch (InterruptedException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t}\r\n-\t\tsuper.stop();\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// RestMicroservice API methods.\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t/**\r\n-\t * Returns the port that this microservice started up on.\r\n-\t * <p>\r\n-\t * The value is determined by looking at the <code>Server/Connectors[ServerConnector]/port</code> value in the\r\n-\t * Jetty configuration.\r\n-\t *\r\n-\t * @return The port that this microservice started up on.\r\n-\t */\r\n-\tpublic int getPort() {\r\n-\t\tfor (Connector c : getServer().getConnectors())\r\n-\t\t\tif (c instanceof ServerConnector)\r\n-\t\t\t\treturn ((ServerConnector)c).getPort();\r\n-\t\tthrow new RuntimeException(\"Could not locate ServerConnector in Jetty server.\");\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the context path that this microservice is using.\r\n-\t * <p>\r\n-\t * The value is determined by looking at the <code>Server/Handlers[ServletContextHandler]/contextPath</code> value\r\n-\t * in the Jetty configuration.\r\n-\t *\r\n-\t * @return The context path that this microservice is using.\r\n-\t */\r\n-\tpublic String getContextPath() {\r\n-\t\tfor (Handler h : getServer().getHandlers()) {\r\n-\t\t\tif (h instanceof HandlerCollection) {\r\n-\t\t\t\tfor (Handler h2 : ((HandlerCollection)h).getChildHandlers())\r\n-\t\t\t\t\tif (h2 instanceof ServletContextHandler)\r\n-\t\t\t\t\t\treturn ((ServletContextHandler)h2).getContextPath();\r\n-\t\t\t}\r\n-\t\t\tif (h instanceof ServletContextHandler)\r\n-\t\t\t\treturn ((ServletContextHandler)h).getContextPath();\r\n-\t\t}\r\n-\t\tthrow new RuntimeException(\"Could not locate ServletContextHandler in Jetty server.\");\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\r\n-\t * <p>\r\n-\t * The value is determined by looking for the existence of an SSL Connection Factorie by looking for the\r\n-\t * <code>Server/Connectors[ServerConnector]/ConnectionFactories[SslConnectionFactory]</code> value in the Jetty\r\n-\t * configuration.\r\n-\t *\r\n-\t * @return Whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\r\n-\t */\r\n-\tpublic String getProtocol() {\r\n-\t\tfor (Connector c : getServer().getConnectors())\r\n-\t\t\tif (c instanceof ServerConnector)\r\n-\t\t\t\tfor (ConnectionFactory cf : ((ServerConnector)c).getConnectionFactories())\r\n-\t\t\t\t\tif (cf instanceof SslConnectionFactory)\r\n-\t\t\t\t\t\treturn \"https\";\r\n-\t\treturn \"http\";\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the hostname of this microservice.\r\n-\t * <p>\r\n-\t * Simply uses <code>InetAddress.getLocalHost().getHostName()</code>.\r\n-\t *\r\n-\t * @return The hostname of this microservice.\r\n-\t */\r\n-\tpublic String getHostName() {\r\n-\t\tString hostname = \"localhost\";\r\n-\t\ttry {\r\n-\t\t\thostname = InetAddress.getLocalHost().getHostName();\r\n-\t\t} catch (UnknownHostException e) {}\r\n-\t\treturn hostname;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the URI where this microservice is listening on.\r\n-\t *\r\n-\t * @return The URI where this microservice is listening on.\r\n-\t */\r\n-\tpublic URI getURI() {\r\n-\t\tString cp = getContextPath();\r\n-\t\ttry {\r\n-\t\t\treturn new URI(getProtocol(), null, getHostName(), getPort(), \"/\".equals(cp) ? null : cp, null, null);\r\n-\t\t} catch (URISyntaxException e) {\r\n-\t\t\tthrow new RuntimeException(e);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Method used to create (but not start) an instance of a Jetty server.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to customize the Jetty server before it is started.\r\n-\t *\r\n-\t * <p>\r\n-\t * The default implementation is configured by the following values in the config file\r\n-\t * if a jetty.xml is not specified via a <code>REST/jettyXml</code> setting:\r\n-\t * <p class='bcode w800'>\r\n-\t * \t<cc>#================================================================================\r\n-\t * \t# Jetty settings\r\n-\t * \t#================================================================================</cc>\r\n-\t * \t<cs>[Jetty]</cs>\r\n-\t *\r\n-\t * \t<cc># Path of the jetty.xml file used to configure the Jetty server.</cc>\r\n-\t * \t<ck>config</ck> = jetty.xml\r\n-\t *\r\n-\t * \t<cc># Resolve Juneau variables in the jetty.xml file.</cc>\r\n-\t * \t<ck>resolveVars</ck> = true\r\n-\t *\r\n-\t * \t<cc># Port to use for the jetty server.\r\n-\t * \t# You can specify multiple ports.  The first available will be used.  '0' indicates to try a random port.\r\n-\t * \t# The resulting available port gets set as the system property \"availablePort\" which can be referenced in the\r\n-\t * \t# jetty.xml file as \"$S{availablePort}\" (assuming resolveVars is enabled).</cc>\r\n-\t * \t<ck>port</ck> = 10000,0,0,0\r\n-\t * </p>\r\n-\t *\r\n-\t * @return The newly-created server.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tprotected Server createServer() throws Exception {\r\n-\t\tonCreateServer();\r\n-\r\n-\t\tConfig cf = getConfig();\r\n-\t\tObjectMap mf = getManifest();\r\n-\t\tVarResolver vr = getVarResolver();\r\n-\r\n-\t\tint[] ports = cf.getObjectWithDefault(\"Jetty/port\", mf.getWithDefault(\"Jetty-Port\", new int[]{8000}, int[].class), int[].class);\r\n-\t\tint availablePort = findOpenPort(ports);\r\n-\t\tSystem.setProperty(\"availablePort\", String.valueOf(availablePort));\r\n-\r\n-\t\tif (jettyXml == null)\r\n-\t\t\tjettyXml = cf.getString(\"Jetty/config\", mf.getString(\"Jetty-Config\", null));\r\n-\r\n-\t\tif (jettyXml == null)\r\n-\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file location was not specified in the configuration file (Jetty/config) or manifest file (Jetty-Config).\");\r\n-\r\n-\t\tString xmlConfig = null;\r\n-\r\n-\t\tif (jettyXml instanceof String)\r\n-\t\t\tjettyXml = new File(jettyXml.toString());\r\n-\r\n-\t\tif (jettyXml instanceof File) {\r\n-\t\t\tFile f = (File)jettyXml;\r\n-\t\t\tif (f.exists())\r\n-\t\t\t\txmlConfig = IOUtils.read((File)jettyXml);\r\n-\t\t\telse\r\n-\t\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file ''{0}'' was specified but not found on the file system.\", f.getName());\r\n-\t\t} else {\r\n-\t\t\txmlConfig = IOUtils.read(jettyXml);\r\n-\t\t}\r\n-\r\n-\t\tif (cf.getBoolean(\"Jetty/resolveVars\", false))\r\n-\t\t\txmlConfig = vr.resolve(xmlConfig);\r\n-\r\n-\t\tgetLogger().info(xmlConfig);\r\n-\r\n-\t\tXmlConfiguration config = new XmlConfiguration(new ByteArrayInputStream(xmlConfig.getBytes()));\r\n-\t\tserver = (Server)config.configure();\r\n-\r\n-\t\treturn server;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Adds an arbitrary servlet to this microservice.\r\n-\t *\r\n-\t * @param servlet The servlet instance.\r\n-\t * @param pathSpec The context path of the servlet.\r\n-\t * @return This object (for method chaining).\r\n-\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\r\n-\t */\r\n-\tpublic RestMicroservice addServlet(Servlet servlet, String pathSpec) {\r\n-\t\tfor (Handler h : getServer().getHandlers()) {\r\n-\t\t\tif (h instanceof ServletContextHandler) {\r\n-\t\t\t\tServletHolder sh = new ServletHolder(servlet);\r\n-\t\t\t\t((ServletContextHandler)h).addServlet(sh, pathSpec);\r\n-\t\t\t\treturn this;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tthrow new RuntimeException(\"Servlet context handler not found in jetty server.\");\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Adds a servlet attribute to the Jetty server.\r\n-\t *\r\n-\t * @param name The server attribute name.\r\n-\t * @param value The context path of the servlet.\r\n-\t * @return This object (for method chaining).\r\n-\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\r\n-\t */\r\n-\tpublic RestMicroservice addServletAttribute(String name, Object value) {\r\n-\t\tgetServer().setAttribute(name, value);\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the underlying Jetty server.\r\n-\t *\r\n-\t * @return The underlying Jetty server, or <jk>null</jk> if {@link #createServer()} has not yet been called.\r\n-\t */\r\n-\tpublic Server getServer() {\r\n-\t\tif (server == null)\r\n-\t\t\tthrow new RuntimeException(\"Server not found.  createServer() must be called first.\");\r\n-\t\treturn server;\r\n-\t}\r\n-\r\n-\tprivate static int findOpenPort(int[] ports) {\r\n-\t\tfor (int port : ports) {\r\n-\t\t\t// If port is 0, try a random port between ports[0] and 32767.\r\n-\t\t\tif (port == 0)\r\n-\t\t\t\tport = new Random().nextInt(32767 - ports[0] + 1) + ports[0];\r\n-\t\t\ttry (ServerSocket ss = new ServerSocket(port)) {\r\n-\t\t\t\treturn port;\r\n-\t\t\t} catch (IOException e) {}\r\n-\t\t}\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Method used to start the Jetty server created by {@link #createServer()}.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to customize server startup.\r\n-\t *\r\n-\t * @return The port that this server started on.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tprotected int startServer() throws Exception {\r\n-\t\tonStartServer();\r\n-\t\tserver.start();\r\n-\t\tout(mb, \"ServerStarted\", getPort());\r\n-\t\tonPostStartServer();\r\n-\t\treturn getPort();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when {@link Config#commit()} is called on the config file.\r\n-\t *\r\n-\t * <p>\r\n-\t * The default behavior is configured by the following value in the config file:\r\n-\t * <p class='bcode w800'>\r\n-\t * \t<cc># What to do when the config file is saved.\r\n-\t * \t# Possible values:\r\n-\t * \t# \tNOTHING - Don't do anything. (default)\r\n-\t * \t#\tRESTART_SERVER - Restart the Jetty server.\r\n-\t * \t#\tRESTART_SERVICE - Shutdown and exit with code '3'.</cc>\r\n-\t * \t<ck>saveConfigAction</ck> = RESTART_SERVER\r\n-\t * </p>\r\n-\t */\r\n-\t@Override /* Microservice */\r\n-\tpublic void onConfigChange(List<ConfigEvent> events) {\r\n-\t\ttry {\r\n-\t\t\tString saveConfigAction = getConfig().getString(\"saveConfigAction\", \"NOTHING\");\r\n-\t\t\tif (saveConfigAction.equals(\"RESTART_SERVER\")) {\r\n-\t\t\t\tnew Thread() {\r\n-\t\t\t\t\t@Override /* Thread */\r\n-\t\t\t\t\tpublic void run() {\r\n-\t\t\t\t\t\ttry {\r\n-\t\t\t\t\t\t\tRestMicroservice.this.stop();\r\n-\t\t\t\t\t\t\tRestMicroservice.this.start();\r\n-\t\t\t\t\t\t} catch (Exception e) {\r\n-\t\t\t\t\t\t\tgetLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}.start();\r\n-\t\t\t} else if (saveConfigAction.equals(\"RESTART_SERVICE\")) {\r\n-\t\t\t\tstop();\r\n-\t\t\t\tSystem.exit(3);\r\n-\t\t\t}\r\n-\t\t} catch (Exception e) {\r\n-\t\t\tthrow new RuntimeException(e);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Sets the <code>jetty.xml</code> used to configure the Jetty server.\r\n-\t *\r\n-\t * <p>\r\n-\t *\r\n-\t * @param jettyXml\r\n-\t * \tThe <code>jetty.xml</code>.\r\n-\t * \t<br>Can be any of the following:\r\n-\t * \t<ul>\r\n-\t * \t\t<li>A {@link File} representing the location on the file system.\r\n-\t * \t\t<li>An {@link InputStream} containing the contents of the file.\r\n-\t * \t\t<li>A {@link String} representing the file system path.\r\n-\t * \t</ul>\r\n-\t * @return This object (for method chaining).\r\n-\t */\r\n-\tpublic RestMicroservice setJettyXml(Object jettyXml) {\r\n-\t\tif (jettyXml instanceof String || jettyXml instanceof File || jettyXml instanceof InputStream || jettyXml instanceof Reader)\r\n-\t\t\tthis.jettyXml = jettyXml;\r\n-\t\telse\r\n-\t\t\tthrow new FormattedRuntimeException(\"Invalid object type passed to setJettyXml()\", jettyXml == null ? null : jettyXml.getClass().getName());\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// Lifecycle listener methods.\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t/**\r\n-\t * Called before {@link #createServer()} is called.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onCreateServer() {}\r\n-\r\n-\t/**\r\n-\t * Called before {@link #startServer()} is called.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onStartServer() {}\r\n-\r\n-\t/**\r\n-\t * Called after the Jetty server is started.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onPostStartServer() {}\r\n-\r\n-\t/**\r\n-\t * Called before the Jetty server is stopped.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onStopServer() {}\r\n-\r\n-\t/**\r\n-\t * Called after the Jetty server is stopped.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onPostStopServer() {}\r\n-\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// Overridden methods.\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice setConfig(String cfPath, boolean create) throws IOException {\r\n-\t\tsuper.setConfig(cfPath, create);\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice setManifestContents(String...contents) throws IOException {\r\n-\t\tsuper.setManifestContents(contents);\r\n-\t\treturn this;\r\n-\t}\r\n-}\r\n+// ***************************************************************************************************************************\n+// * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file *\n+// * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file        *\n+// * to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance            *\n+// * with the License.  You may obtain a copy of the License at                                                              *\n+// *                                                                                                                         *\n+// *  http://www.apache.org/licenses/LICENSE-2.0                                                                             *\n+// *                                                                                                                         *\n+// * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an  *\n+// * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the        *\n+// * specific language governing permissions and limitations under the License.                                              *\n+// ***************************************************************************************************************************\n+package org.apache.juneau.microservice;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+import java.util.logging.*;\n+\n+import javax.servlet.*;\n+\n+import org.apache.juneau.*;\n+import org.apache.juneau.config.*;\n+import org.apache.juneau.config.event.*;\n+import org.apache.juneau.internal.*;\n+import org.apache.juneau.svl.*;\n+import org.apache.juneau.utils.*;\n+import org.eclipse.jetty.server.*;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.handler.*;\n+import org.eclipse.jetty.servlet.*;\n+import org.eclipse.jetty.xml.*;\n+\n+/**\n+ * Entry point for Juneau microservice that implements a REST interface using Jetty on a single port.\n+ *\n+ * <h5 class='topic'>Jetty Server Details</h5>\n+ *\n+ * The Jetty server is created by the {@link #createServer()} method and started with the {@link #startServer()} method.\n+ * These methods can be overridden to provided customized behavior.\n+ *\n+ * <h5 class='topic'>Defining REST Resources</h5>\n+ *\n+ * Top-level REST resources are defined in the <code>jetty.xml</code> file as normal servlets.\n+ *\n+ * <h5 class='topic'>Logging</h5>\n+ *\n+ * Logging is initialized by the {@link #initLogging()} method.\n+ * This method can be overridden to provide customized logging behavior.\n+ *\n+ * <h5 class='topic'>Lifecycle Listener Methods</h5>\n+ * Subclasses can optionally implement the following event listener methods:\n+ * <ul class='spaced-list'>\n+ * \t<li>\n+ * \t\t{@link #onStart()} - Gets executed before {@link #start()}.\n+ * \t<li>\n+ * \t\t{@link #onStop()} - Gets executed before {@link #stop()}.\n+ * \t<li>\n+ * \t\t{@link #onCreateServer()} - Gets executed before {@link #createServer()}.\n+ * \t<li>\n+ * \t\t{@link #onStartServer()} - Gets executed before {@link #startServer()}.\n+ * \t<li>\n+ * \t\t{@link #onPostStartServer()} - Gets executed after {@link #startServer()}.\n+ * \t<li>\n+ * \t\t{@link #onStopServer()} - Gets executed before {@link #stop()}.\n+ * \t<li>\n+ * \t\t{@link #onPostStopServer()} - Gets executed after {@link #stop()}.\n+ * </ul>\n+ */\n+public class RestMicroservice extends Microservice {\n+\n+\tServer server;\n+\tprivate Object jettyXml;\n+\tprivate final MessageBundle mb = MessageBundle.create(RestMicroservice.class, \"Messages\");\n+\n+\tprivate static volatile RestMicroservice INSTANCE;\n+\n+\t/**\n+\t * Returns the Microservice instance.\n+\t * <p>\n+\t * This method only works if there's only one Microservice instance in a JVM.\n+\t * Otherwise, it's just overwritten by the last call to {@link #RestMicroservice(String...)}.\n+\t *\n+\t * @return The Microservice instance, or <jk>null</jk> if there isn't one.\n+\t */\n+\tpublic static RestMicroservice getInstance() {\n+\t\tsynchronized(RestMicroservice.class) {\n+\t\t\treturn INSTANCE;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Main method.\n+\t *\n+\t * <p>\n+\t * Subclasses must also implement this method!\n+\t *\n+\t * @param args Command line arguments.\n+\t * @throws Exception\n+\t */\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tnew RestMicroservice(args).start().join();\n+\t}\n+\n+\t/**\n+\t * Constructor.\n+\t *\n+\t * @param args Command line arguments.\n+\t * @throws Exception\n+\t */\n+\tpublic RestMicroservice(String...args) throws Exception {\n+\t\tsuper(args);\n+\t\tsetInstance(this);\n+\t}\n+\n+\tprivate static void setInstance(RestMicroservice rm) {\n+\t\tsynchronized(RestMicroservice.class) {\n+\t\t\tINSTANCE = rm;\n+\t\t}\n+\t}\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// Methods implemented on Microservice API\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice start() throws Exception {\n+\t\tsuper.start();\n+\t\tcreateServer();\n+\t\tstartServer();\n+\t\tstartConsole();\n+\t\treturn this;\n+\t}\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice join() throws Exception {\n+\t\tserver.join();\n+\t\treturn this;\n+\t}\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice stop() {\n+\t\tfinal Logger logger = getLogger();\n+\t\tfinal MessageBundle mb2 = mb;\n+\t\tThread t = new Thread() {\n+\t\t\t@Override /* Thread */\n+\t\t\tpublic void run() {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (server == null || server.isStopping() || server.isStopped())\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tonStopServer();\n+\t\t\t\t\tout(mb2, \"StoppingServer\");\n+\t\t\t\t\tserver.stop();\n+\t\t\t\t\tout(mb2, \"ServerStopped\");\n+\t\t\t\t\tonPostStopServer();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tlogger.log(Level.WARNING, e.getLocalizedMessage(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tt.start();\n+\t\ttry {\n+\t\t\tt.join();\n+\t\t} catch (InterruptedException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\tsuper.stop();\n+\t\treturn this;\n+\t}\n+\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// RestMicroservice API methods.\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Returns the port that this microservice started up on.\n+\t * <p>\n+\t * The value is determined by looking at the <code>Server/Connectors[ServerConnector]/port</code> value in the\n+\t * Jetty configuration.\n+\t *\n+\t * @return The port that this microservice started up on.\n+\t */\n+\tpublic int getPort() {\n+\t\tfor (Connector c : getServer().getConnectors())\n+\t\t\tif (c instanceof ServerConnector)\n+\t\t\t\treturn ((ServerConnector)c).getPort();\n+\t\tthrow new RuntimeException(\"Could not locate ServerConnector in Jetty server.\");\n+\t}\n+\n+\t/**\n+\t * Returns the context path that this microservice is using.\n+\t * <p>\n+\t * The value is determined by looking at the <code>Server/Handlers[ServletContextHandler]/contextPath</code> value\n+\t * in the Jetty configuration.\n+\t *\n+\t * @return The context path that this microservice is using.\n+\t */\n+\tpublic String getContextPath() {\n+\t\tfor (Handler h : getServer().getHandlers()) {\n+\t\t\tif (h instanceof HandlerCollection) {\n+\t\t\t\tfor (Handler h2 : ((HandlerCollection)h).getChildHandlers())\n+\t\t\t\t\tif (h2 instanceof ServletContextHandler)\n+\t\t\t\t\t\treturn ((ServletContextHandler)h2).getContextPath();\n+\t\t\t}\n+\t\t\tif (h instanceof ServletContextHandler)\n+\t\t\t\treturn ((ServletContextHandler)h).getContextPath();\n+\t\t}\n+\t\tthrow new RuntimeException(\"Could not locate ServletContextHandler in Jetty server.\");\n+\t}\n+\n+\t/**\n+\t * Returns whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\n+\t * <p>\n+\t * The value is determined by looking for the existence of an SSL Connection Factorie by looking for the\n+\t * <code>Server/Connectors[ServerConnector]/ConnectionFactories[SslConnectionFactory]</code> value in the Jetty\n+\t * configuration.\n+\t *\n+\t * @return Whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\n+\t */\n+\tpublic String getProtocol() {\n+\t\tfor (Connector c : getServer().getConnectors())\n+\t\t\tif (c instanceof ServerConnector)\n+\t\t\t\tfor (ConnectionFactory cf : ((ServerConnector)c).getConnectionFactories())\n+\t\t\t\t\tif (cf instanceof SslConnectionFactory)\n+\t\t\t\t\t\treturn \"https\";\n+\t\treturn \"http\";\n+\t}\n+\n+\t/**\n+\t * Returns the hostname of this microservice.\n+\t * <p>\n+\t * Simply uses <code>InetAddress.getLocalHost().getHostName()</code>.\n+\t *\n+\t * @return The hostname of this microservice.\n+\t */\n+\tpublic String getHostName() {\n+\t\tString hostname = \"localhost\";\n+\t\ttry {\n+\t\t\thostname = InetAddress.getLocalHost().getHostName();\n+\t\t} catch (UnknownHostException e) {}\n+\t\treturn hostname;\n+\t}\n+\n+\t/**\n+\t * Returns the URI where this microservice is listening on.\n+\t *\n+\t * @return The URI where this microservice is listening on.\n+\t */\n+\tpublic URI getURI() {\n+\t\tString cp = getContextPath();\n+\t\ttry {\n+\t\t\treturn new URI(getProtocol(), null, getHostName(), getPort(), \"/\".equals(cp) ? null : cp, null, null);\n+\t\t} catch (URISyntaxException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Method used to create (but not start) an instance of a Jetty server.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to customize the Jetty server before it is started.\n+\t *\n+\t * <p>\n+\t * The default implementation is configured by the following values in the config file\n+\t * if a jetty.xml is not specified via a <code>REST/jettyXml</code> setting:\n+\t * <p class='bcode w800'>\n+\t * \t<cc>#================================================================================\n+\t * \t# Jetty settings\n+\t * \t#================================================================================</cc>\n+\t * \t<cs>[Jetty]</cs>\n+\t *\n+\t * \t<cc># Path of the jetty.xml file used to configure the Jetty server.</cc>\n+\t * \t<ck>config</ck> = jetty.xml\n+\t *\n+\t * \t<cc># Resolve Juneau variables in the jetty.xml file.</cc>\n+\t * \t<ck>resolveVars</ck> = true\n+\t *\n+\t * \t<cc># Port to use for the jetty server.\n+\t * \t# You can specify multiple ports.  The first available will be used.  '0' indicates to try a random port.\n+\t * \t# The resulting available port gets set as the system property \"availablePort\" which can be referenced in the\n+\t * \t# jetty.xml file as \"$S{availablePort}\" (assuming resolveVars is enabled).</cc>\n+\t * \t<ck>port</ck> = 10000,0,0,0\n+\t * </p>\n+\t *\n+\t * @return The newly-created server.\n+\t * @throws Exception\n+\t */\n+\tprotected Server createServer() throws Exception {\n+\t\tonCreateServer();\n+\n+\t\tConfig cf = getConfig();\n+\t\tObjectMap mf = getManifest();\n+\t\tVarResolver vr = getVarResolver();\n+\n+\t\tint[] ports = cf.getObjectWithDefault(\"Jetty/port\", mf.getWithDefault(\"Jetty-Port\", new int[]{8000}, int[].class), int[].class);\n+\t\tint availablePort = findOpenPort(ports);\n+\t\tSystem.setProperty(\"availablePort\", String.valueOf(availablePort));\n+\n+\t\tif (jettyXml == null)\n+\t\t\tjettyXml = cf.getString(\"Jetty/config\", mf.getString(\"Jetty-Config\", null));\n+\n+\t\tif (jettyXml == null)\n+\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file location was not specified in the configuration file (Jetty/config) or manifest file (Jetty-Config).\");\n+\n+\t\tString xmlConfig = null;\n+\n+\t\tif (jettyXml instanceof String)\n+\t\t\tjettyXml = new File(jettyXml.toString());\n+\n+\t\tif (jettyXml instanceof File) {\n+\t\t\tFile f = (File)jettyXml;\n+\t\t\tif (f.exists())\n+\t\t\t\txmlConfig = IOUtils.read((File)jettyXml);\n+\t\t\telse\n+\t\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file ''{0}'' was specified but not found on the file system.\", f.getName());\n+\t\t} else {\n+\t\t\txmlConfig = IOUtils.read(jettyXml);\n+\t\t}\n+\n+\t\tif (cf.getBoolean(\"Jetty/resolveVars\", false))\n+\t\t\txmlConfig = vr.resolve(xmlConfig);\n+\n+\t\tgetLogger().info(xmlConfig);\n+\n+\t\tXmlConfiguration config = new XmlConfiguration(new ByteArrayInputStream(xmlConfig.getBytes()));\n+\t\tserver = (Server)config.configure();\n+\n+\t\treturn server;\n+\t}\n+\n+\t/**\n+\t * Adds an arbitrary servlet to this microservice.\n+\t *\n+\t * @param servlet The servlet instance.\n+\t * @param pathSpec The context path of the servlet.\n+\t * @return This object (for method chaining).\n+\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\n+\t */\n+\tpublic RestMicroservice addServlet(Servlet servlet, String pathSpec) {\n+\t\tfor (Handler h : getServer().getHandlers()) {\n+\t\t\tif (h instanceof ServletContextHandler) {\n+\t\t\t\tServletHolder sh = new ServletHolder(servlet);\n+\t\t\t\t((ServletContextHandler)h).addServlet(sh, pathSpec);\n+\t\t\t\treturn this;\n+\t\t\t}\n+\t\t}\n+\t\tthrow new RuntimeException(\"Servlet context handler not found in jetty server.\");\n+\t}\n+\n+\t/**\n+\t * Adds a servlet attribute to the Jetty server.\n+\t *\n+\t * @param name The server attribute name.\n+\t * @param value The context path of the servlet.\n+\t * @return This object (for method chaining).\n+\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\n+\t */\n+\tpublic RestMicroservice addServletAttribute(String name, Object value) {\n+\t\tgetServer().setAttribute(name, value);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Returns the underlying Jetty server.\n+\t *\n+\t * @return The underlying Jetty server, or <jk>null</jk> if {@link #createServer()} has not yet been called.\n+\t */\n+\tpublic Server getServer() {\n+\t\tif (server == null)\n+\t\t\tthrow new RuntimeException(\"Server not found.  createServer() must be called first.\");\n+\t\treturn server;\n+\t}\n+\n+\tprivate static int findOpenPort(int[] ports) {\n+\t\tfor (int port : ports) {\n+\t\t\t// If port is 0, try a random port between ports[0] and 32767.\n+\t\t\tif (port == 0)\n+\t\t\t\tport = new Random().nextInt(32767 - ports[0] + 1) + ports[0];\n+\t\t\ttry (ServerSocket ss = new ServerSocket(port)) {\n+\t\t\t\treturn port;\n+\t\t\t} catch (IOException e) {}\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Method used to start the Jetty server created by {@link #createServer()}.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to customize server startup.\n+\t *\n+\t * @return The port that this server started on.\n+\t * @throws Exception\n+\t */\n+\tprotected int startServer() throws Exception {\n+\t\tonStartServer();\n+\t\tserver.start();\n+\t\tout(mb, \"ServerStarted\", getPort());\n+\t\tonPostStartServer();\n+\t\treturn getPort();\n+\t}\n+\n+\t/**\n+\t * Called when {@link Config#commit()} is called on the config file.\n+\t *\n+\t * <p>\n+\t * The default behavior is configured by the following value in the config file:\n+\t * <p class='bcode w800'>\n+\t * \t<cc># What to do when the config file is saved.\n+\t * \t# Possible values:\n+\t * \t# \tNOTHING - Don't do anything. (default)\n+\t * \t#\tRESTART_SERVER - Restart the Jetty server.\n+\t * \t#\tRESTART_SERVICE - Shutdown and exit with code '3'.</cc>\n+\t * \t<ck>saveConfigAction</ck> = RESTART_SERVER\n+\t * </p>\n+\t */\n+\t@Override /* Microservice */\n+\tpublic void onConfigChange(List<ConfigEvent> events) {\n+\t\ttry {\n+\t\t\tString saveConfigAction = getConfig().getString(\"saveConfigAction\", \"NOTHING\");\n+\t\t\tif (saveConfigAction.equals(\"RESTART_SERVER\")) {\n+\t\t\t\tnew Thread() {\n+\t\t\t\t\t@Override /* Thread */\n+\t\t\t\t\tpublic void run() {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tRestMicroservice.this.stop();\n+\t\t\t\t\t\t\tRestMicroservice.this.start();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tgetLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}.start();\n+\t\t\t} else if (saveConfigAction.equals(\"RESTART_SERVICE\")) {\n+\t\t\t\tstop();\n+\t\t\t\tSystem.exit(3);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the <code>jetty.xml</code> used to configure the Jetty server.\n+\t *\n+\t * <p>\n+\t *\n+\t * @param jettyXml\n+\t * \tThe <code>jetty.xml</code>.\n+\t * \t<br>Can be any of the following:\n+\t * \t<ul>\n+\t * \t\t<li>A {@link File} representing the location on the file system.\n+\t * \t\t<li>An {@link InputStream} containing the contents of the file.\n+\t * \t\t<li>A {@link String} representing the file system path.\n+\t * \t</ul>\n+\t * @return This object (for method chaining).\n+\t */\n+\tpublic RestMicroservice setJettyXml(Object jettyXml) {\n+\t\tif (jettyXml instanceof String || jettyXml instanceof File || jettyXml instanceof InputStream || jettyXml instanceof Reader)\n+\t\t\tthis.jettyXml = jettyXml;\n+\t\telse\n+\t\t\tthrow new FormattedRuntimeException(\"Invalid object type passed to setJettyXml()\", jettyXml == null ? null : jettyXml.getClass().getName());\n+\t\treturn this;\n+\t}\n+\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// Lifecycle listener methods.\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Called before {@link #createServer()} is called.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onCreateServer() {}\n+\n+\t/**\n+\t * Called before {@link #startServer()} is called.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onStartServer() {}\n+\n+\t/**\n+\t * Called after the Jetty server is started.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onPostStartServer() {}\n+\n+\t/**\n+\t * Called before the Jetty server is stopped.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onStopServer() {}\n+\n+\t/**\n+\t * Called after the Jetty server is stopped.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onPostStopServer() {}\n+\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// Overridden methods.\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice setConfig(String cfPath, boolean create) throws IOException {\n+\t\tsuper.setConfig(cfPath, create);\n+\t\treturn this;\n+\t}\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice setManifestContents(String...contents) throws IOException {\n+\t\tsuper.setManifestContents(contents);\n+\t\treturn this;\n+\t}\n+}",
                "deletions": 528
            }
        ]
    },
    {
        "repo": "juneau",
        "message": "Merge pull request #7 from garydgregory/JUNEAU-86\n\n[JUNEAU-86] Avoid NPE stopping RestMicroservice.",
        "commit": "https://github.com/apache/juneau/commit/343fd59779f8d3e4bfcf9dc56dd0a63efc733212",
        "parent": "https://github.com/apache/juneau/commit/3d656e2eb970e665f11c6a64591d55d97c7c788f",
        "bug_id": "juneau_2",
        "file": [
            {
                "sha": "b9ae8262c9b0023cce133da46043205a77283338",
                "filename": "juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java",
                "blob_url": "https://github.com/apache/juneau/blob/343fd59779f8d3e4bfcf9dc56dd0a63efc733212/juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java",
                "raw_url": "https://github.com/apache/juneau/raw/343fd59779f8d3e4bfcf9dc56dd0a63efc733212/juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java",
                "status": "modified",
                "changes": 1056,
                "additions": 528,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-microservice/juneau-microservice-server/src/main/java/org/apache/juneau/microservice/RestMicroservice.java?ref=343fd59779f8d3e4bfcf9dc56dd0a63efc733212",
                "patch": "@@ -1,528 +1,528 @@\n-// ***************************************************************************************************************************\r\n-// * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file *\r\n-// * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file        *\r\n-// * to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance            *\r\n-// * with the License.  You may obtain a copy of the License at                                                              *\r\n-// *                                                                                                                         *\r\n-// *  http://www.apache.org/licenses/LICENSE-2.0                                                                             *\r\n-// *                                                                                                                         *\r\n-// * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an  *\r\n-// * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the        *\r\n-// * specific language governing permissions and limitations under the License.                                              *\r\n-// ***************************************************************************************************************************\r\n-package org.apache.juneau.microservice;\r\n-\r\n-import java.io.*;\r\n-import java.net.*;\r\n-import java.util.*;\r\n-import java.util.logging.*;\r\n-\r\n-import javax.servlet.*;\r\n-\r\n-import org.apache.juneau.*;\r\n-import org.apache.juneau.config.*;\r\n-import org.apache.juneau.config.event.*;\r\n-import org.apache.juneau.internal.*;\r\n-import org.apache.juneau.svl.*;\r\n-import org.apache.juneau.utils.*;\r\n-import org.eclipse.jetty.server.*;\r\n-import org.eclipse.jetty.server.Handler;\r\n-import org.eclipse.jetty.server.handler.*;\r\n-import org.eclipse.jetty.servlet.*;\r\n-import org.eclipse.jetty.xml.*;\r\n-\r\n-/**\r\n- * Entry point for Juneau microservice that implements a REST interface using Jetty on a single port.\r\n- *\r\n- * <h5 class='topic'>Jetty Server Details</h5>\r\n- *\r\n- * The Jetty server is created by the {@link #createServer()} method and started with the {@link #startServer()} method.\r\n- * These methods can be overridden to provided customized behavior.\r\n- *\r\n- * <h5 class='topic'>Defining REST Resources</h5>\r\n- *\r\n- * Top-level REST resources are defined in the <code>jetty.xml</code> file as normal servlets.\r\n- *\r\n- * <h5 class='topic'>Logging</h5>\r\n- *\r\n- * Logging is initialized by the {@link #initLogging()} method.\r\n- * This method can be overridden to provide customized logging behavior.\r\n- *\r\n- * <h5 class='topic'>Lifecycle Listener Methods</h5>\r\n- * Subclasses can optionally implement the following event listener methods:\r\n- * <ul class='spaced-list'>\r\n- * \t<li>\r\n- * \t\t{@link #onStart()} - Gets executed before {@link #start()}.\r\n- * \t<li>\r\n- * \t\t{@link #onStop()} - Gets executed before {@link #stop()}.\r\n- * \t<li>\r\n- * \t\t{@link #onCreateServer()} - Gets executed before {@link #createServer()}.\r\n- * \t<li>\r\n- * \t\t{@link #onStartServer()} - Gets executed before {@link #startServer()}.\r\n- * \t<li>\r\n- * \t\t{@link #onPostStartServer()} - Gets executed after {@link #startServer()}.\r\n- * \t<li>\r\n- * \t\t{@link #onStopServer()} - Gets executed before {@link #stop()}.\r\n- * \t<li>\r\n- * \t\t{@link #onPostStopServer()} - Gets executed after {@link #stop()}.\r\n- * </ul>\r\n- */\r\n-public class RestMicroservice extends Microservice {\r\n-\r\n-\tServer server;\r\n-\tprivate Object jettyXml;\r\n-\tprivate final MessageBundle mb = MessageBundle.create(RestMicroservice.class, \"Messages\");\r\n-\r\n-\tprivate static volatile RestMicroservice INSTANCE;\r\n-\r\n-\t/**\r\n-\t * Returns the Microservice instance.\r\n-\t * <p>\r\n-\t * This method only works if there's only one Microservice instance in a JVM.\r\n-\t * Otherwise, it's just overwritten by the last call to {@link #RestMicroservice(String...)}.\r\n-\t *\r\n-\t * @return The Microservice instance, or <jk>null</jk> if there isn't one.\r\n-\t */\r\n-\tpublic static RestMicroservice getInstance() {\r\n-\t\tsynchronized(RestMicroservice.class) {\r\n-\t\t\treturn INSTANCE;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Main method.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses must also implement this method!\r\n-\t *\r\n-\t * @param args Command line arguments.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tpublic static void main(String[] args) throws Exception {\r\n-\t\tnew RestMicroservice(args).start().join();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Constructor.\r\n-\t *\r\n-\t * @param args Command line arguments.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tpublic RestMicroservice(String...args) throws Exception {\r\n-\t\tsuper(args);\r\n-\t\tsetInstance(this);\r\n-\t}\r\n-\r\n-\tprivate static void setInstance(RestMicroservice rm) {\r\n-\t\tsynchronized(RestMicroservice.class) {\r\n-\t\t\tINSTANCE = rm;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// Methods implemented on Microservice API\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice start() throws Exception {\r\n-\t\tsuper.start();\r\n-\t\tcreateServer();\r\n-\t\tstartServer();\r\n-\t\tstartConsole();\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice join() throws Exception {\r\n-\t\tserver.join();\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice stop() {\r\n-\t\tfinal Logger logger = getLogger();\r\n-\t\tfinal MessageBundle mb2 = mb;\r\n-\t\tThread t = new Thread() {\r\n-\t\t\t@Override /* Thread */\r\n-\t\t\tpublic void run() {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tif (server.isStopping() || server.isStopped())\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\tonStopServer();\r\n-\t\t\t\t\tout(mb2, \"StoppingServer\");\r\n-\t\t\t\t\tserver.stop();\r\n-\t\t\t\t\tout(mb2, \"ServerStopped\");\r\n-\t\t\t\t\tonPostStopServer();\r\n-\t\t\t\t} catch (Exception e) {\r\n-\t\t\t\t\tlogger.log(Level.WARNING, e.getLocalizedMessage(), e);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t};\r\n-\t\tt.start();\r\n-\t\ttry {\r\n-\t\t\tt.join();\r\n-\t\t} catch (InterruptedException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t}\r\n-\t\tsuper.stop();\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// RestMicroservice API methods.\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t/**\r\n-\t * Returns the port that this microservice started up on.\r\n-\t * <p>\r\n-\t * The value is determined by looking at the <code>Server/Connectors[ServerConnector]/port</code> value in the\r\n-\t * Jetty configuration.\r\n-\t *\r\n-\t * @return The port that this microservice started up on.\r\n-\t */\r\n-\tpublic int getPort() {\r\n-\t\tfor (Connector c : getServer().getConnectors())\r\n-\t\t\tif (c instanceof ServerConnector)\r\n-\t\t\t\treturn ((ServerConnector)c).getPort();\r\n-\t\tthrow new RuntimeException(\"Could not locate ServerConnector in Jetty server.\");\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the context path that this microservice is using.\r\n-\t * <p>\r\n-\t * The value is determined by looking at the <code>Server/Handlers[ServletContextHandler]/contextPath</code> value\r\n-\t * in the Jetty configuration.\r\n-\t *\r\n-\t * @return The context path that this microservice is using.\r\n-\t */\r\n-\tpublic String getContextPath() {\r\n-\t\tfor (Handler h : getServer().getHandlers()) {\r\n-\t\t\tif (h instanceof HandlerCollection) {\r\n-\t\t\t\tfor (Handler h2 : ((HandlerCollection)h).getChildHandlers())\r\n-\t\t\t\t\tif (h2 instanceof ServletContextHandler)\r\n-\t\t\t\t\t\treturn ((ServletContextHandler)h2).getContextPath();\r\n-\t\t\t}\r\n-\t\t\tif (h instanceof ServletContextHandler)\r\n-\t\t\t\treturn ((ServletContextHandler)h).getContextPath();\r\n-\t\t}\r\n-\t\tthrow new RuntimeException(\"Could not locate ServletContextHandler in Jetty server.\");\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\r\n-\t * <p>\r\n-\t * The value is determined by looking for the existence of an SSL Connection Factorie by looking for the\r\n-\t * <code>Server/Connectors[ServerConnector]/ConnectionFactories[SslConnectionFactory]</code> value in the Jetty\r\n-\t * configuration.\r\n-\t *\r\n-\t * @return Whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\r\n-\t */\r\n-\tpublic String getProtocol() {\r\n-\t\tfor (Connector c : getServer().getConnectors())\r\n-\t\t\tif (c instanceof ServerConnector)\r\n-\t\t\t\tfor (ConnectionFactory cf : ((ServerConnector)c).getConnectionFactories())\r\n-\t\t\t\t\tif (cf instanceof SslConnectionFactory)\r\n-\t\t\t\t\t\treturn \"https\";\r\n-\t\treturn \"http\";\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the hostname of this microservice.\r\n-\t * <p>\r\n-\t * Simply uses <code>InetAddress.getLocalHost().getHostName()</code>.\r\n-\t *\r\n-\t * @return The hostname of this microservice.\r\n-\t */\r\n-\tpublic String getHostName() {\r\n-\t\tString hostname = \"localhost\";\r\n-\t\ttry {\r\n-\t\t\thostname = InetAddress.getLocalHost().getHostName();\r\n-\t\t} catch (UnknownHostException e) {}\r\n-\t\treturn hostname;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the URI where this microservice is listening on.\r\n-\t *\r\n-\t * @return The URI where this microservice is listening on.\r\n-\t */\r\n-\tpublic URI getURI() {\r\n-\t\tString cp = getContextPath();\r\n-\t\ttry {\r\n-\t\t\treturn new URI(getProtocol(), null, getHostName(), getPort(), \"/\".equals(cp) ? null : cp, null, null);\r\n-\t\t} catch (URISyntaxException e) {\r\n-\t\t\tthrow new RuntimeException(e);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Method used to create (but not start) an instance of a Jetty server.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to customize the Jetty server before it is started.\r\n-\t *\r\n-\t * <p>\r\n-\t * The default implementation is configured by the following values in the config file\r\n-\t * if a jetty.xml is not specified via a <code>REST/jettyXml</code> setting:\r\n-\t * <p class='bcode w800'>\r\n-\t * \t<cc>#================================================================================\r\n-\t * \t# Jetty settings\r\n-\t * \t#================================================================================</cc>\r\n-\t * \t<cs>[Jetty]</cs>\r\n-\t *\r\n-\t * \t<cc># Path of the jetty.xml file used to configure the Jetty server.</cc>\r\n-\t * \t<ck>config</ck> = jetty.xml\r\n-\t *\r\n-\t * \t<cc># Resolve Juneau variables in the jetty.xml file.</cc>\r\n-\t * \t<ck>resolveVars</ck> = true\r\n-\t *\r\n-\t * \t<cc># Port to use for the jetty server.\r\n-\t * \t# You can specify multiple ports.  The first available will be used.  '0' indicates to try a random port.\r\n-\t * \t# The resulting available port gets set as the system property \"availablePort\" which can be referenced in the\r\n-\t * \t# jetty.xml file as \"$S{availablePort}\" (assuming resolveVars is enabled).</cc>\r\n-\t * \t<ck>port</ck> = 10000,0,0,0\r\n-\t * </p>\r\n-\t *\r\n-\t * @return The newly-created server.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tprotected Server createServer() throws Exception {\r\n-\t\tonCreateServer();\r\n-\r\n-\t\tConfig cf = getConfig();\r\n-\t\tObjectMap mf = getManifest();\r\n-\t\tVarResolver vr = getVarResolver();\r\n-\r\n-\t\tint[] ports = cf.getObjectWithDefault(\"Jetty/port\", mf.getWithDefault(\"Jetty-Port\", new int[]{8000}, int[].class), int[].class);\r\n-\t\tint availablePort = findOpenPort(ports);\r\n-\t\tSystem.setProperty(\"availablePort\", String.valueOf(availablePort));\r\n-\r\n-\t\tif (jettyXml == null)\r\n-\t\t\tjettyXml = cf.getString(\"Jetty/config\", mf.getString(\"Jetty-Config\", null));\r\n-\r\n-\t\tif (jettyXml == null)\r\n-\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file location was not specified in the configuration file (Jetty/config) or manifest file (Jetty-Config).\");\r\n-\r\n-\t\tString xmlConfig = null;\r\n-\r\n-\t\tif (jettyXml instanceof String)\r\n-\t\t\tjettyXml = new File(jettyXml.toString());\r\n-\r\n-\t\tif (jettyXml instanceof File) {\r\n-\t\t\tFile f = (File)jettyXml;\r\n-\t\t\tif (f.exists())\r\n-\t\t\t\txmlConfig = IOUtils.read((File)jettyXml);\r\n-\t\t\telse\r\n-\t\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file ''{0}'' was specified but not found on the file system.\", f.getName());\r\n-\t\t} else {\r\n-\t\t\txmlConfig = IOUtils.read(jettyXml);\r\n-\t\t}\r\n-\r\n-\t\tif (cf.getBoolean(\"Jetty/resolveVars\", false))\r\n-\t\t\txmlConfig = vr.resolve(xmlConfig);\r\n-\r\n-\t\tgetLogger().info(xmlConfig);\r\n-\r\n-\t\tXmlConfiguration config = new XmlConfiguration(new ByteArrayInputStream(xmlConfig.getBytes()));\r\n-\t\tserver = (Server)config.configure();\r\n-\r\n-\t\treturn server;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Adds an arbitrary servlet to this microservice.\r\n-\t *\r\n-\t * @param servlet The servlet instance.\r\n-\t * @param pathSpec The context path of the servlet.\r\n-\t * @return This object (for method chaining).\r\n-\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\r\n-\t */\r\n-\tpublic RestMicroservice addServlet(Servlet servlet, String pathSpec) {\r\n-\t\tfor (Handler h : getServer().getHandlers()) {\r\n-\t\t\tif (h instanceof ServletContextHandler) {\r\n-\t\t\t\tServletHolder sh = new ServletHolder(servlet);\r\n-\t\t\t\t((ServletContextHandler)h).addServlet(sh, pathSpec);\r\n-\t\t\t\treturn this;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tthrow new RuntimeException(\"Servlet context handler not found in jetty server.\");\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Adds a servlet attribute to the Jetty server.\r\n-\t *\r\n-\t * @param name The server attribute name.\r\n-\t * @param value The context path of the servlet.\r\n-\t * @return This object (for method chaining).\r\n-\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\r\n-\t */\r\n-\tpublic RestMicroservice addServletAttribute(String name, Object value) {\r\n-\t\tgetServer().setAttribute(name, value);\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the underlying Jetty server.\r\n-\t *\r\n-\t * @return The underlying Jetty server, or <jk>null</jk> if {@link #createServer()} has not yet been called.\r\n-\t */\r\n-\tpublic Server getServer() {\r\n-\t\tif (server == null)\r\n-\t\t\tthrow new RuntimeException(\"Server not found.  createServer() must be called first.\");\r\n-\t\treturn server;\r\n-\t}\r\n-\r\n-\tprivate static int findOpenPort(int[] ports) {\r\n-\t\tfor (int port : ports) {\r\n-\t\t\t// If port is 0, try a random port between ports[0] and 32767.\r\n-\t\t\tif (port == 0)\r\n-\t\t\t\tport = new Random().nextInt(32767 - ports[0] + 1) + ports[0];\r\n-\t\t\ttry (ServerSocket ss = new ServerSocket(port)) {\r\n-\t\t\t\treturn port;\r\n-\t\t\t} catch (IOException e) {}\r\n-\t\t}\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Method used to start the Jetty server created by {@link #createServer()}.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to customize server startup.\r\n-\t *\r\n-\t * @return The port that this server started on.\r\n-\t * @throws Exception\r\n-\t */\r\n-\tprotected int startServer() throws Exception {\r\n-\t\tonStartServer();\r\n-\t\tserver.start();\r\n-\t\tout(mb, \"ServerStarted\", getPort());\r\n-\t\tonPostStartServer();\r\n-\t\treturn getPort();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when {@link Config#commit()} is called on the config file.\r\n-\t *\r\n-\t * <p>\r\n-\t * The default behavior is configured by the following value in the config file:\r\n-\t * <p class='bcode w800'>\r\n-\t * \t<cc># What to do when the config file is saved.\r\n-\t * \t# Possible values:\r\n-\t * \t# \tNOTHING - Don't do anything. (default)\r\n-\t * \t#\tRESTART_SERVER - Restart the Jetty server.\r\n-\t * \t#\tRESTART_SERVICE - Shutdown and exit with code '3'.</cc>\r\n-\t * \t<ck>saveConfigAction</ck> = RESTART_SERVER\r\n-\t * </p>\r\n-\t */\r\n-\t@Override /* Microservice */\r\n-\tpublic void onConfigChange(List<ConfigEvent> events) {\r\n-\t\ttry {\r\n-\t\t\tString saveConfigAction = getConfig().getString(\"saveConfigAction\", \"NOTHING\");\r\n-\t\t\tif (saveConfigAction.equals(\"RESTART_SERVER\")) {\r\n-\t\t\t\tnew Thread() {\r\n-\t\t\t\t\t@Override /* Thread */\r\n-\t\t\t\t\tpublic void run() {\r\n-\t\t\t\t\t\ttry {\r\n-\t\t\t\t\t\t\tRestMicroservice.this.stop();\r\n-\t\t\t\t\t\t\tRestMicroservice.this.start();\r\n-\t\t\t\t\t\t} catch (Exception e) {\r\n-\t\t\t\t\t\t\tgetLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}.start();\r\n-\t\t\t} else if (saveConfigAction.equals(\"RESTART_SERVICE\")) {\r\n-\t\t\t\tstop();\r\n-\t\t\t\tSystem.exit(3);\r\n-\t\t\t}\r\n-\t\t} catch (Exception e) {\r\n-\t\t\tthrow new RuntimeException(e);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Sets the <code>jetty.xml</code> used to configure the Jetty server.\r\n-\t *\r\n-\t * <p>\r\n-\t *\r\n-\t * @param jettyXml\r\n-\t * \tThe <code>jetty.xml</code>.\r\n-\t * \t<br>Can be any of the following:\r\n-\t * \t<ul>\r\n-\t * \t\t<li>A {@link File} representing the location on the file system.\r\n-\t * \t\t<li>An {@link InputStream} containing the contents of the file.\r\n-\t * \t\t<li>A {@link String} representing the file system path.\r\n-\t * \t</ul>\r\n-\t * @return This object (for method chaining).\r\n-\t */\r\n-\tpublic RestMicroservice setJettyXml(Object jettyXml) {\r\n-\t\tif (jettyXml instanceof String || jettyXml instanceof File || jettyXml instanceof InputStream || jettyXml instanceof Reader)\r\n-\t\t\tthis.jettyXml = jettyXml;\r\n-\t\telse\r\n-\t\t\tthrow new FormattedRuntimeException(\"Invalid object type passed to setJettyXml()\", jettyXml == null ? null : jettyXml.getClass().getName());\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// Lifecycle listener methods.\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t/**\r\n-\t * Called before {@link #createServer()} is called.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onCreateServer() {}\r\n-\r\n-\t/**\r\n-\t * Called before {@link #startServer()} is called.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onStartServer() {}\r\n-\r\n-\t/**\r\n-\t * Called after the Jetty server is started.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onPostStartServer() {}\r\n-\r\n-\t/**\r\n-\t * Called before the Jetty server is stopped.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onStopServer() {}\r\n-\r\n-\t/**\r\n-\t * Called after the Jetty server is stopped.\r\n-\t *\r\n-\t * <p>\r\n-\t * Subclasses can override this method to hook into the lifecycle of this application.\r\n-\t */\r\n-\tprotected void onPostStopServer() {}\r\n-\r\n-\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\t// Overridden methods.\r\n-\t//-----------------------------------------------------------------------------------------------------------------\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice setConfig(String cfPath, boolean create) throws IOException {\r\n-\t\tsuper.setConfig(cfPath, create);\r\n-\t\treturn this;\r\n-\t}\r\n-\r\n-\t@Override /* Microservice */\r\n-\tpublic RestMicroservice setManifestContents(String...contents) throws IOException {\r\n-\t\tsuper.setManifestContents(contents);\r\n-\t\treturn this;\r\n-\t}\r\n-}\r\n+// ***************************************************************************************************************************\n+// * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file *\n+// * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file        *\n+// * to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance            *\n+// * with the License.  You may obtain a copy of the License at                                                              *\n+// *                                                                                                                         *\n+// *  http://www.apache.org/licenses/LICENSE-2.0                                                                             *\n+// *                                                                                                                         *\n+// * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an  *\n+// * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the        *\n+// * specific language governing permissions and limitations under the License.                                              *\n+// ***************************************************************************************************************************\n+package org.apache.juneau.microservice;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+import java.util.logging.*;\n+\n+import javax.servlet.*;\n+\n+import org.apache.juneau.*;\n+import org.apache.juneau.config.*;\n+import org.apache.juneau.config.event.*;\n+import org.apache.juneau.internal.*;\n+import org.apache.juneau.svl.*;\n+import org.apache.juneau.utils.*;\n+import org.eclipse.jetty.server.*;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.handler.*;\n+import org.eclipse.jetty.servlet.*;\n+import org.eclipse.jetty.xml.*;\n+\n+/**\n+ * Entry point for Juneau microservice that implements a REST interface using Jetty on a single port.\n+ *\n+ * <h5 class='topic'>Jetty Server Details</h5>\n+ *\n+ * The Jetty server is created by the {@link #createServer()} method and started with the {@link #startServer()} method.\n+ * These methods can be overridden to provided customized behavior.\n+ *\n+ * <h5 class='topic'>Defining REST Resources</h5>\n+ *\n+ * Top-level REST resources are defined in the <code>jetty.xml</code> file as normal servlets.\n+ *\n+ * <h5 class='topic'>Logging</h5>\n+ *\n+ * Logging is initialized by the {@link #initLogging()} method.\n+ * This method can be overridden to provide customized logging behavior.\n+ *\n+ * <h5 class='topic'>Lifecycle Listener Methods</h5>\n+ * Subclasses can optionally implement the following event listener methods:\n+ * <ul class='spaced-list'>\n+ * \t<li>\n+ * \t\t{@link #onStart()} - Gets executed before {@link #start()}.\n+ * \t<li>\n+ * \t\t{@link #onStop()} - Gets executed before {@link #stop()}.\n+ * \t<li>\n+ * \t\t{@link #onCreateServer()} - Gets executed before {@link #createServer()}.\n+ * \t<li>\n+ * \t\t{@link #onStartServer()} - Gets executed before {@link #startServer()}.\n+ * \t<li>\n+ * \t\t{@link #onPostStartServer()} - Gets executed after {@link #startServer()}.\n+ * \t<li>\n+ * \t\t{@link #onStopServer()} - Gets executed before {@link #stop()}.\n+ * \t<li>\n+ * \t\t{@link #onPostStopServer()} - Gets executed after {@link #stop()}.\n+ * </ul>\n+ */\n+public class RestMicroservice extends Microservice {\n+\n+\tServer server;\n+\tprivate Object jettyXml;\n+\tprivate final MessageBundle mb = MessageBundle.create(RestMicroservice.class, \"Messages\");\n+\n+\tprivate static volatile RestMicroservice INSTANCE;\n+\n+\t/**\n+\t * Returns the Microservice instance.\n+\t * <p>\n+\t * This method only works if there's only one Microservice instance in a JVM.\n+\t * Otherwise, it's just overwritten by the last call to {@link #RestMicroservice(String...)}.\n+\t *\n+\t * @return The Microservice instance, or <jk>null</jk> if there isn't one.\n+\t */\n+\tpublic static RestMicroservice getInstance() {\n+\t\tsynchronized(RestMicroservice.class) {\n+\t\t\treturn INSTANCE;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Main method.\n+\t *\n+\t * <p>\n+\t * Subclasses must also implement this method!\n+\t *\n+\t * @param args Command line arguments.\n+\t * @throws Exception\n+\t */\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tnew RestMicroservice(args).start().join();\n+\t}\n+\n+\t/**\n+\t * Constructor.\n+\t *\n+\t * @param args Command line arguments.\n+\t * @throws Exception\n+\t */\n+\tpublic RestMicroservice(String...args) throws Exception {\n+\t\tsuper(args);\n+\t\tsetInstance(this);\n+\t}\n+\n+\tprivate static void setInstance(RestMicroservice rm) {\n+\t\tsynchronized(RestMicroservice.class) {\n+\t\t\tINSTANCE = rm;\n+\t\t}\n+\t}\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// Methods implemented on Microservice API\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice start() throws Exception {\n+\t\tsuper.start();\n+\t\tcreateServer();\n+\t\tstartServer();\n+\t\tstartConsole();\n+\t\treturn this;\n+\t}\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice join() throws Exception {\n+\t\tserver.join();\n+\t\treturn this;\n+\t}\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice stop() {\n+\t\tfinal Logger logger = getLogger();\n+\t\tfinal MessageBundle mb2 = mb;\n+\t\tThread t = new Thread() {\n+\t\t\t@Override /* Thread */\n+\t\t\tpublic void run() {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (server == null || server.isStopping() || server.isStopped())\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tonStopServer();\n+\t\t\t\t\tout(mb2, \"StoppingServer\");\n+\t\t\t\t\tserver.stop();\n+\t\t\t\t\tout(mb2, \"ServerStopped\");\n+\t\t\t\t\tonPostStopServer();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tlogger.log(Level.WARNING, e.getLocalizedMessage(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tt.start();\n+\t\ttry {\n+\t\t\tt.join();\n+\t\t} catch (InterruptedException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\tsuper.stop();\n+\t\treturn this;\n+\t}\n+\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// RestMicroservice API methods.\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Returns the port that this microservice started up on.\n+\t * <p>\n+\t * The value is determined by looking at the <code>Server/Connectors[ServerConnector]/port</code> value in the\n+\t * Jetty configuration.\n+\t *\n+\t * @return The port that this microservice started up on.\n+\t */\n+\tpublic int getPort() {\n+\t\tfor (Connector c : getServer().getConnectors())\n+\t\t\tif (c instanceof ServerConnector)\n+\t\t\t\treturn ((ServerConnector)c).getPort();\n+\t\tthrow new RuntimeException(\"Could not locate ServerConnector in Jetty server.\");\n+\t}\n+\n+\t/**\n+\t * Returns the context path that this microservice is using.\n+\t * <p>\n+\t * The value is determined by looking at the <code>Server/Handlers[ServletContextHandler]/contextPath</code> value\n+\t * in the Jetty configuration.\n+\t *\n+\t * @return The context path that this microservice is using.\n+\t */\n+\tpublic String getContextPath() {\n+\t\tfor (Handler h : getServer().getHandlers()) {\n+\t\t\tif (h instanceof HandlerCollection) {\n+\t\t\t\tfor (Handler h2 : ((HandlerCollection)h).getChildHandlers())\n+\t\t\t\t\tif (h2 instanceof ServletContextHandler)\n+\t\t\t\t\t\treturn ((ServletContextHandler)h2).getContextPath();\n+\t\t\t}\n+\t\t\tif (h instanceof ServletContextHandler)\n+\t\t\t\treturn ((ServletContextHandler)h).getContextPath();\n+\t\t}\n+\t\tthrow new RuntimeException(\"Could not locate ServletContextHandler in Jetty server.\");\n+\t}\n+\n+\t/**\n+\t * Returns whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\n+\t * <p>\n+\t * The value is determined by looking for the existence of an SSL Connection Factorie by looking for the\n+\t * <code>Server/Connectors[ServerConnector]/ConnectionFactories[SslConnectionFactory]</code> value in the Jetty\n+\t * configuration.\n+\t *\n+\t * @return Whether this microservice is using <js>\"http\"</js> or <js>\"https\"</js>.\n+\t */\n+\tpublic String getProtocol() {\n+\t\tfor (Connector c : getServer().getConnectors())\n+\t\t\tif (c instanceof ServerConnector)\n+\t\t\t\tfor (ConnectionFactory cf : ((ServerConnector)c).getConnectionFactories())\n+\t\t\t\t\tif (cf instanceof SslConnectionFactory)\n+\t\t\t\t\t\treturn \"https\";\n+\t\treturn \"http\";\n+\t}\n+\n+\t/**\n+\t * Returns the hostname of this microservice.\n+\t * <p>\n+\t * Simply uses <code>InetAddress.getLocalHost().getHostName()</code>.\n+\t *\n+\t * @return The hostname of this microservice.\n+\t */\n+\tpublic String getHostName() {\n+\t\tString hostname = \"localhost\";\n+\t\ttry {\n+\t\t\thostname = InetAddress.getLocalHost().getHostName();\n+\t\t} catch (UnknownHostException e) {}\n+\t\treturn hostname;\n+\t}\n+\n+\t/**\n+\t * Returns the URI where this microservice is listening on.\n+\t *\n+\t * @return The URI where this microservice is listening on.\n+\t */\n+\tpublic URI getURI() {\n+\t\tString cp = getContextPath();\n+\t\ttry {\n+\t\t\treturn new URI(getProtocol(), null, getHostName(), getPort(), \"/\".equals(cp) ? null : cp, null, null);\n+\t\t} catch (URISyntaxException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Method used to create (but not start) an instance of a Jetty server.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to customize the Jetty server before it is started.\n+\t *\n+\t * <p>\n+\t * The default implementation is configured by the following values in the config file\n+\t * if a jetty.xml is not specified via a <code>REST/jettyXml</code> setting:\n+\t * <p class='bcode w800'>\n+\t * \t<cc>#================================================================================\n+\t * \t# Jetty settings\n+\t * \t#================================================================================</cc>\n+\t * \t<cs>[Jetty]</cs>\n+\t *\n+\t * \t<cc># Path of the jetty.xml file used to configure the Jetty server.</cc>\n+\t * \t<ck>config</ck> = jetty.xml\n+\t *\n+\t * \t<cc># Resolve Juneau variables in the jetty.xml file.</cc>\n+\t * \t<ck>resolveVars</ck> = true\n+\t *\n+\t * \t<cc># Port to use for the jetty server.\n+\t * \t# You can specify multiple ports.  The first available will be used.  '0' indicates to try a random port.\n+\t * \t# The resulting available port gets set as the system property \"availablePort\" which can be referenced in the\n+\t * \t# jetty.xml file as \"$S{availablePort}\" (assuming resolveVars is enabled).</cc>\n+\t * \t<ck>port</ck> = 10000,0,0,0\n+\t * </p>\n+\t *\n+\t * @return The newly-created server.\n+\t * @throws Exception\n+\t */\n+\tprotected Server createServer() throws Exception {\n+\t\tonCreateServer();\n+\n+\t\tConfig cf = getConfig();\n+\t\tObjectMap mf = getManifest();\n+\t\tVarResolver vr = getVarResolver();\n+\n+\t\tint[] ports = cf.getObjectWithDefault(\"Jetty/port\", mf.getWithDefault(\"Jetty-Port\", new int[]{8000}, int[].class), int[].class);\n+\t\tint availablePort = findOpenPort(ports);\n+\t\tSystem.setProperty(\"availablePort\", String.valueOf(availablePort));\n+\n+\t\tif (jettyXml == null)\n+\t\t\tjettyXml = cf.getString(\"Jetty/config\", mf.getString(\"Jetty-Config\", null));\n+\n+\t\tif (jettyXml == null)\n+\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file location was not specified in the configuration file (Jetty/config) or manifest file (Jetty-Config).\");\n+\n+\t\tString xmlConfig = null;\n+\n+\t\tif (jettyXml instanceof String)\n+\t\t\tjettyXml = new File(jettyXml.toString());\n+\n+\t\tif (jettyXml instanceof File) {\n+\t\t\tFile f = (File)jettyXml;\n+\t\t\tif (f.exists())\n+\t\t\t\txmlConfig = IOUtils.read((File)jettyXml);\n+\t\t\telse\n+\t\t\t\tthrow new FormattedRuntimeException(\"Jetty.xml file ''{0}'' was specified but not found on the file system.\", f.getName());\n+\t\t} else {\n+\t\t\txmlConfig = IOUtils.read(jettyXml);\n+\t\t}\n+\n+\t\tif (cf.getBoolean(\"Jetty/resolveVars\", false))\n+\t\t\txmlConfig = vr.resolve(xmlConfig);\n+\n+\t\tgetLogger().info(xmlConfig);\n+\n+\t\tXmlConfiguration config = new XmlConfiguration(new ByteArrayInputStream(xmlConfig.getBytes()));\n+\t\tserver = (Server)config.configure();\n+\n+\t\treturn server;\n+\t}\n+\n+\t/**\n+\t * Adds an arbitrary servlet to this microservice.\n+\t *\n+\t * @param servlet The servlet instance.\n+\t * @param pathSpec The context path of the servlet.\n+\t * @return This object (for method chaining).\n+\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\n+\t */\n+\tpublic RestMicroservice addServlet(Servlet servlet, String pathSpec) {\n+\t\tfor (Handler h : getServer().getHandlers()) {\n+\t\t\tif (h instanceof ServletContextHandler) {\n+\t\t\t\tServletHolder sh = new ServletHolder(servlet);\n+\t\t\t\t((ServletContextHandler)h).addServlet(sh, pathSpec);\n+\t\t\t\treturn this;\n+\t\t\t}\n+\t\t}\n+\t\tthrow new RuntimeException(\"Servlet context handler not found in jetty server.\");\n+\t}\n+\n+\t/**\n+\t * Adds a servlet attribute to the Jetty server.\n+\t *\n+\t * @param name The server attribute name.\n+\t * @param value The context path of the servlet.\n+\t * @return This object (for method chaining).\n+\t * @throws RuntimeException if {@link #createServer()} has not previously been called.\n+\t */\n+\tpublic RestMicroservice addServletAttribute(String name, Object value) {\n+\t\tgetServer().setAttribute(name, value);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Returns the underlying Jetty server.\n+\t *\n+\t * @return The underlying Jetty server, or <jk>null</jk> if {@link #createServer()} has not yet been called.\n+\t */\n+\tpublic Server getServer() {\n+\t\tif (server == null)\n+\t\t\tthrow new RuntimeException(\"Server not found.  createServer() must be called first.\");\n+\t\treturn server;\n+\t}\n+\n+\tprivate static int findOpenPort(int[] ports) {\n+\t\tfor (int port : ports) {\n+\t\t\t// If port is 0, try a random port between ports[0] and 32767.\n+\t\t\tif (port == 0)\n+\t\t\t\tport = new Random().nextInt(32767 - ports[0] + 1) + ports[0];\n+\t\t\ttry (ServerSocket ss = new ServerSocket(port)) {\n+\t\t\t\treturn port;\n+\t\t\t} catch (IOException e) {}\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Method used to start the Jetty server created by {@link #createServer()}.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to customize server startup.\n+\t *\n+\t * @return The port that this server started on.\n+\t * @throws Exception\n+\t */\n+\tprotected int startServer() throws Exception {\n+\t\tonStartServer();\n+\t\tserver.start();\n+\t\tout(mb, \"ServerStarted\", getPort());\n+\t\tonPostStartServer();\n+\t\treturn getPort();\n+\t}\n+\n+\t/**\n+\t * Called when {@link Config#commit()} is called on the config file.\n+\t *\n+\t * <p>\n+\t * The default behavior is configured by the following value in the config file:\n+\t * <p class='bcode w800'>\n+\t * \t<cc># What to do when the config file is saved.\n+\t * \t# Possible values:\n+\t * \t# \tNOTHING - Don't do anything. (default)\n+\t * \t#\tRESTART_SERVER - Restart the Jetty server.\n+\t * \t#\tRESTART_SERVICE - Shutdown and exit with code '3'.</cc>\n+\t * \t<ck>saveConfigAction</ck> = RESTART_SERVER\n+\t * </p>\n+\t */\n+\t@Override /* Microservice */\n+\tpublic void onConfigChange(List<ConfigEvent> events) {\n+\t\ttry {\n+\t\t\tString saveConfigAction = getConfig().getString(\"saveConfigAction\", \"NOTHING\");\n+\t\t\tif (saveConfigAction.equals(\"RESTART_SERVER\")) {\n+\t\t\t\tnew Thread() {\n+\t\t\t\t\t@Override /* Thread */\n+\t\t\t\t\tpublic void run() {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tRestMicroservice.this.stop();\n+\t\t\t\t\t\t\tRestMicroservice.this.start();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tgetLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}.start();\n+\t\t\t} else if (saveConfigAction.equals(\"RESTART_SERVICE\")) {\n+\t\t\t\tstop();\n+\t\t\t\tSystem.exit(3);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the <code>jetty.xml</code> used to configure the Jetty server.\n+\t *\n+\t * <p>\n+\t *\n+\t * @param jettyXml\n+\t * \tThe <code>jetty.xml</code>.\n+\t * \t<br>Can be any of the following:\n+\t * \t<ul>\n+\t * \t\t<li>A {@link File} representing the location on the file system.\n+\t * \t\t<li>An {@link InputStream} containing the contents of the file.\n+\t * \t\t<li>A {@link String} representing the file system path.\n+\t * \t</ul>\n+\t * @return This object (for method chaining).\n+\t */\n+\tpublic RestMicroservice setJettyXml(Object jettyXml) {\n+\t\tif (jettyXml instanceof String || jettyXml instanceof File || jettyXml instanceof InputStream || jettyXml instanceof Reader)\n+\t\t\tthis.jettyXml = jettyXml;\n+\t\telse\n+\t\t\tthrow new FormattedRuntimeException(\"Invalid object type passed to setJettyXml()\", jettyXml == null ? null : jettyXml.getClass().getName());\n+\t\treturn this;\n+\t}\n+\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// Lifecycle listener methods.\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Called before {@link #createServer()} is called.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onCreateServer() {}\n+\n+\t/**\n+\t * Called before {@link #startServer()} is called.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onStartServer() {}\n+\n+\t/**\n+\t * Called after the Jetty server is started.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onPostStartServer() {}\n+\n+\t/**\n+\t * Called before the Jetty server is stopped.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onStopServer() {}\n+\n+\t/**\n+\t * Called after the Jetty server is stopped.\n+\t *\n+\t * <p>\n+\t * Subclasses can override this method to hook into the lifecycle of this application.\n+\t */\n+\tprotected void onPostStopServer() {}\n+\n+\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\t// Overridden methods.\n+\t//-----------------------------------------------------------------------------------------------------------------\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice setConfig(String cfPath, boolean create) throws IOException {\n+\t\tsuper.setConfig(cfPath, create);\n+\t\treturn this;\n+\t}\n+\n+\t@Override /* Microservice */\n+\tpublic RestMicroservice setManifestContents(String...contents) throws IOException {\n+\t\tsuper.setManifestContents(contents);\n+\t\treturn this;\n+\t}\n+}",
                "deletions": 528
            }
        ]
    },
    {
        "repo": "juneau",
        "message": "PojoQuery can cause XmlSerializer to throw a NullPointerException.",
        "commit": "https://github.com/apache/juneau/commit/24d06b7fc23b1eb1237da6ea93ba6edf0be2a00e",
        "parent": "https://github.com/apache/juneau/commit/bf06f82a162e766b04fc450e725190f5148e793c",
        "bug_id": "juneau_3",
        "file": [
            {
                "sha": "df9640812eb3f0a4fbdfb2c47c5c5424d9aa4100",
                "filename": "org.apache.juneau/src/main/java/org/apache/juneau/internal/DelegateBeanMap.java",
                "blob_url": "https://github.com/apache/juneau/blob/24d06b7fc23b1eb1237da6ea93ba6edf0be2a00e/org.apache.juneau/src/main/java/org/apache/juneau/internal/DelegateBeanMap.java",
                "raw_url": "https://github.com/apache/juneau/raw/24d06b7fc23b1eb1237da6ea93ba6edf0be2a00e/org.apache.juneau/src/main/java/org/apache/juneau/internal/DelegateBeanMap.java",
                "status": "modified",
                "changes": 16,
                "additions": 16,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/org.apache.juneau/src/main/java/org/apache/juneau/internal/DelegateBeanMap.java?ref=24d06b7fc23b1eb1237da6ea93ba6edf0be2a00e",
                "patch": "@@ -15,6 +15,9 @@\n import java.util.*;\r\n \r\n import org.apache.juneau.*;\r\n+import org.apache.juneau.html.*;\r\n+import org.apache.juneau.jena.*;\r\n+import org.apache.juneau.xml.*;\r\n \r\n /**\r\n  * Represents a wrapped {@link BeanMap} where property values can be overridden, removed, or reordered\r\n@@ -117,11 +120,24 @@ public Object remove(Object key) {\n \t\tfor (final String key : keys) {\r\n \t\t\tBeanPropertyMeta<T> p = this.getPropertyMeta(key);\r\n \t\t\tif (overrideValues.containsKey(key)) {\r\n+\t\t\t\tfinal BeanPropertyMeta<T> p2 = p;\r\n \t\t\t\tp = new BeanPropertyMeta<T>(this.meta, key) {\r\n \t\t\t\t\t@Override /* BeanPropertyMeta */\r\n \t\t\t\t\tpublic Object get(BeanMap<T> m) {\r\n \t\t\t\t\t\treturn overrideValues.get(key);\r\n \t\t\t\t\t}\r\n+\t\t\t\t\t@Override /* BeanPropertyMeta */\r\n+\t\t\t\t\tpublic RdfBeanPropertyMeta<T> getRdfMeta() {\r\n+\t\t\t\t\t\treturn p2.getRdfMeta();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t@Override /* BeanPropertyMeta */\r\n+\t\t\t\t\tpublic HtmlBeanPropertyMeta<T> getHtmlMeta() {\r\n+\t\t\t\t\t\treturn p2.getHtmlMeta();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t@Override /* BeanPropertyMeta */\r\n+\t\t\t\t\tpublic XmlBeanPropertyMeta<T> getXmlMeta() {\r\n+\t\t\t\t\t\treturn p2.getXmlMeta();\r\n+\t\t\t\t\t}\r\n \t\t\t\t};\r\n \t\t\t}\r\n \t\t\tif (p == null)\r",
                "deletions": 0
            }
        ]
    },
    {
        "repo": "juneau",
        "message": "Fix NPE when using ObjectMap(Reader)",
        "commit": "https://github.com/apache/juneau/commit/9d086440ead9c596c824f5a04bd5048ba47e6b71",
        "parent": "https://github.com/apache/juneau/commit/9475ed212e035be5e6eeb681b000cfbd98f83bc1",
        "bug_id": "juneau_4",
        "file": [
            {
                "sha": "0f136e6db68fa0b191adc6fe7c31b7e38e54a5be",
                "filename": "juneau-core-test/src/test/java/org/apache/juneau/ObjectListTest.java",
                "blob_url": "https://github.com/apache/juneau/blob/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core-test/src/test/java/org/apache/juneau/ObjectListTest.java",
                "raw_url": "https://github.com/apache/juneau/raw/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core-test/src/test/java/org/apache/juneau/ObjectListTest.java",
                "status": "modified",
                "changes": 10,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core-test/src/test/java/org/apache/juneau/ObjectListTest.java?ref=9d086440ead9c596c824f5a04bd5048ba47e6b71",
                "patch": "@@ -12,8 +12,10 @@\n // ***************************************************************************************************************************\r\n package org.apache.juneau;\r\n \r\n+import static org.apache.juneau.TestUtils.*;\r\n import static org.junit.Assert.*;\r\n \r\n+import java.io.*;\r\n import java.util.*;\r\n \r\n import org.junit.*;\r\n@@ -96,4 +98,12 @@ public void testAtMethods() throws Exception {\n \t\tl.deleteAt(\"2\");\r\n \t\tassertEquals(\"[{foo:'bing'},{baz:123}]\", l.toString());\r\n \t}\r\n+\r\n+\t//====================================================================================================\r\n+\t// ObjectList(Reader)\r\n+\t//====================================================================================================\r\n+\t@Test\r\n+\tpublic void testFromReader() throws Exception {\r\n+\t\tassertObjectEquals(\"[1,2,3]\", new ObjectList(new StringReader(\"[1,2,3]\")));\r\n+\t}\r\n }\n\\ No newline at end of file",
                "deletions": 0
            },
            {
                "sha": "850eef3a8252d21681281bf8470fa40be4356179",
                "filename": "juneau-core-test/src/test/java/org/apache/juneau/ObjectMapTest.java",
                "blob_url": "https://github.com/apache/juneau/blob/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core-test/src/test/java/org/apache/juneau/ObjectMapTest.java",
                "raw_url": "https://github.com/apache/juneau/raw/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core-test/src/test/java/org/apache/juneau/ObjectMapTest.java",
                "status": "modified",
                "changes": 10,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core-test/src/test/java/org/apache/juneau/ObjectMapTest.java?ref=9d086440ead9c596c824f5a04bd5048ba47e6b71",
                "patch": "@@ -15,6 +15,8 @@\n import static org.apache.juneau.TestUtils.*;\r\n import static org.junit.Assert.*;\r\n \r\n+import java.io.*;\r\n+\r\n import org.apache.juneau.utils.*;\r\n import org.junit.*;\r\n \r\n@@ -311,4 +313,12 @@ public void testAtMethods() throws Exception {\n \t\tm.deleteAt(\"a/1\");\r\n \t\tassertEquals(\"{a:[{b:'d'}]}\", m.toString());\r\n \t}\r\n+\r\n+\t//====================================================================================================\r\n+\t// ObjectMap(Reader)\r\n+\t//====================================================================================================\r\n+\t@Test\r\n+\tpublic void testFromReader() throws Exception {\r\n+\t\tassertObjectEquals(\"{foo:'bar'}\", new ObjectMap(new StringReader(\"{foo:'bar'}\")));\r\n+\t}\r\n }\n\\ No newline at end of file",
                "deletions": 0
            },
            {
                "sha": "0629d3f89d7b3a7f1e63d4a7949e0c1cf84dd4e9",
                "filename": "juneau-core/src/main/java/org/apache/juneau/ObjectList.java",
                "blob_url": "https://github.com/apache/juneau/blob/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core/src/main/java/org/apache/juneau/ObjectList.java",
                "raw_url": "https://github.com/apache/juneau/raw/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core/src/main/java/org/apache/juneau/ObjectList.java",
                "status": "modified",
                "changes": 13,
                "additions": 13,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core/src/main/java/org/apache/juneau/ObjectList.java?ref=9d086440ead9c596c824f5a04bd5048ba47e6b71",
                "patch": "@@ -162,9 +162,22 @@ public ObjectList(CharSequence s) throws ParseException {\n \t * @throws IOException If a problem occurred trying to read from the reader.\r\n \t */\r\n \tpublic ObjectList(Reader r, Parser p) throws ParseException, IOException {\r\n+\t\tthis(p == null ? BeanContext.DEFAULT.createSession() : p.getBeanContext().createSession());\r\n \t\tparseReader(r, p);\r\n \t}\r\n \r\n+\t/**\r\n+\t * Shortcut for <code><jk>new</jk> ObjectList(reader, JsonParser.<jsf>DEFAULT</jsf>)</code>.\r\n+\t *\r\n+\t * @param r The reader to read from.  The reader will be wrapped in a {@link BufferedReader} if it isn't already.\r\n+\t * @throws ParseException If the input contains a syntax error or is malformed.\r\n+\t * @throws IOException If a problem occurred trying to read from the reader.\r\n+\t */\r\n+\tpublic ObjectList(Reader r) throws ParseException, IOException {\r\n+\t\tthis(BeanContext.DEFAULT.createSession());\r\n+\t\tparseReader(r, JsonParser.DEFAULT);\r\n+\t}\r\n+\r\n \tprivate void parseReader(Reader r, Parser p) throws ParseException {\r\n \t\tif (p == null)\r\n \t\t\tp = JsonParser.DEFAULT;\r",
                "deletions": 0
            },
            {
                "sha": "110c84dd0b45c3c7de98f8cf59b22346c61ee291",
                "filename": "juneau-core/src/main/java/org/apache/juneau/ObjectMap.java",
                "blob_url": "https://github.com/apache/juneau/blob/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core/src/main/java/org/apache/juneau/ObjectMap.java",
                "raw_url": "https://github.com/apache/juneau/raw/9d086440ead9c596c824f5a04bd5048ba47e6b71/juneau-core/src/main/java/org/apache/juneau/ObjectMap.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core/src/main/java/org/apache/juneau/ObjectMap.java?ref=9d086440ead9c596c824f5a04bd5048ba47e6b71",
                "patch": "@@ -173,6 +173,7 @@ public ObjectMap(CharSequence s) throws ParseException {\n \t * @throws IOException If a problem occurred trying to read from the reader.\r\n \t */\r\n \tpublic ObjectMap(Reader r, Parser p) throws ParseException, IOException {\r\n+\t\tthis(p == null ? BeanContext.DEFAULT.createSession() : p.getBeanContext().createSession());\r\n \t\tparseReader(r, p);\r\n \t}\r\n \r\n@@ -184,6 +185,7 @@ public ObjectMap(Reader r, Parser p) throws ParseException, IOException {\n \t * @throws IOException If a problem occurred trying to read from the reader.\r\n \t */\r\n \tpublic ObjectMap(Reader r) throws ParseException, IOException {\r\n+\t\tthis(BeanContext.DEFAULT.createSession());\r\n \t\tparseReader(r, JsonParser.DEFAULT);\r\n \t}\r\n \r\n@@ -206,7 +208,6 @@ public ObjectMap() {\n \t * @param session The bean session to use for creating beans.\r\n \t */\r\n \tpublic ObjectMap(BeanSession session) {\r\n-\t\tsuper();\r\n \t\tthis.session = session;\r\n \t}\r\n \r",
                "deletions": 1
            }
        ]
    },
    {
        "repo": "juneau",
        "message": "Fix possible NPEs in Calendar and Date swaps.",
        "commit": "https://github.com/apache/juneau/commit/9475ed212e035be5e6eeb681b000cfbd98f83bc1",
        "parent": "https://github.com/apache/juneau/commit/d5ba839707e462f6791a18ba752d45e623e14bdd",
        "bug_id": "juneau_5",
        "file": [
            {
                "sha": "02294aba46cfd5c9bae5f0d03a70a55b5ad20738",
                "filename": "juneau-core/src/main/java/org/apache/juneau/transforms/CalendarSwap.java",
                "blob_url": "https://github.com/apache/juneau/blob/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/CalendarSwap.java",
                "raw_url": "https://github.com/apache/juneau/raw/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/CalendarSwap.java",
                "status": "modified",
                "changes": 10,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core/src/main/java/org/apache/juneau/transforms/CalendarSwap.java?ref=9475ed212e035be5e6eeb681b000cfbd98f83bc1",
                "patch": "@@ -142,6 +142,8 @@ public Calendar unswap(BeanSession session, String o, ClassMeta<?> hint) throws\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Calendar o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\to = setTimeZone(session, o);\r\n \t\t\treturn DatatypeConverter.printDateTime(o);\r\n \t\t}\r\n@@ -173,6 +175,8 @@ public Calendar unswap(BeanSession session, String o, ClassMeta<?> hint) throws\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Calendar o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tif (o.getTimeZone().getRawOffset() != 0) {\r\n \t\t\t\tCalendar c = Calendar.getInstance(GMT);\r\n \t\t\t\tc.setTime(o.getTime());\r\n@@ -192,6 +196,8 @@ public String swap(BeanSession session, Calendar o) {\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Calendar o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tString s = super.swap(session, o);\r\n \t\t\treturn String.format(\"%s.%03d%s\", s.substring(0, 19), o.get(Calendar.MILLISECOND), s.substring(19));\r\n \t\t}\r\n@@ -207,6 +213,8 @@ public String swap(BeanSession session, Calendar o) {\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Calendar o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tString s = super.swap(session, o);\r\n \t\t\treturn String.format(\"%s.%03d%s\", s.substring(0, 19), o.get(Calendar.MILLISECOND), s.substring(19));\r\n \t\t}\r\n@@ -552,6 +560,8 @@ else if (c != null && ! c.getTimeZone().equals(df.getTimeZone())) {\n \t */\r\n \t@Override /* PojoSwap */\r\n \tpublic String swap(BeanSession session, Calendar o) {\r\n+\t\tif (o == null)\r\n+\t\t\treturn null;\r\n \t\treturn getDateFormat(session, o).format(o.getTime());\r\n \t}\r\n \r",
                "deletions": 0
            },
            {
                "sha": "93162806656eb6d9534e0bbc6d8cf60f016da58c",
                "filename": "juneau-core/src/main/java/org/apache/juneau/transforms/DateLongSwap.java",
                "blob_url": "https://github.com/apache/juneau/blob/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/DateLongSwap.java",
                "raw_url": "https://github.com/apache/juneau/raw/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/DateLongSwap.java",
                "status": "modified",
                "changes": 2,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core/src/main/java/org/apache/juneau/transforms/DateLongSwap.java?ref=9475ed212e035be5e6eeb681b000cfbd98f83bc1",
                "patch": "@@ -28,6 +28,8 @@\n \t */\r\n \t@Override /* PojoSwap */\r\n \tpublic Long swap(BeanSession session, Date o) {\r\n+\t\tif (o == null)\r\n+\t\t\treturn null;\r\n \t\treturn o.getTime();\r\n \t}\r\n \r",
                "deletions": 0
            },
            {
                "sha": "fcaafe015b44e5933f4f7344c38d124fd257126c",
                "filename": "juneau-core/src/main/java/org/apache/juneau/transforms/DateMapSwap.java",
                "blob_url": "https://github.com/apache/juneau/blob/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/DateMapSwap.java",
                "raw_url": "https://github.com/apache/juneau/raw/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/DateMapSwap.java",
                "status": "modified",
                "changes": 2,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core/src/main/java/org/apache/juneau/transforms/DateMapSwap.java?ref=9475ed212e035be5e6eeb681b000cfbd98f83bc1",
                "patch": "@@ -29,6 +29,8 @@\n \t */\r\n \t@Override /* PojoSwap */\r\n \tpublic Map swap(BeanSession session, Date o) {\r\n+\t\tif (o == null)\r\n+\t\t\treturn null;\r\n \t\tObjectMap m = new ObjectMap();\r\n \t\tm.put(\"time\", o.getTime());\r\n \t\treturn m;\r",
                "deletions": 0
            },
            {
                "sha": "3de5ba354b97788605cffb1202ab1cc20e36c7a0",
                "filename": "juneau-core/src/main/java/org/apache/juneau/transforms/DateSwap.java",
                "blob_url": "https://github.com/apache/juneau/blob/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/DateSwap.java",
                "raw_url": "https://github.com/apache/juneau/raw/9475ed212e035be5e6eeb681b000cfbd98f83bc1/juneau-core/src/main/java/org/apache/juneau/transforms/DateSwap.java",
                "status": "modified",
                "changes": 10,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/juneau/contents/juneau-core/src/main/java/org/apache/juneau/transforms/DateSwap.java?ref=9475ed212e035be5e6eeb681b000cfbd98f83bc1",
                "patch": "@@ -141,6 +141,8 @@ public Date unswap(BeanSession session, String o, ClassMeta<?> hint) throws Pars\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Date o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tCalendar c = new GregorianCalendar();\r\n \t\t\tc.setTime(o);\r\n \t\t\tc = setTimeZone(session, c);\r\n@@ -174,6 +176,8 @@ public Date unswap(BeanSession session, String o, ClassMeta<?> hint) throws Pars\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Date o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tCalendar c = new GregorianCalendar();\r\n \t\t\tc.setTime(o);\r\n \t\t\tif (c.getTimeZone().getRawOffset() != 0) {\r\n@@ -195,6 +199,8 @@ public String swap(BeanSession session, Date o) {\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Date o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tCalendar c = new GregorianCalendar();\r\n \t\t\tc.setTime(o);\r\n \t\t\tString s = super.swap(session, o);\r\n@@ -212,6 +218,8 @@ public String swap(BeanSession session, Date o) {\n \r\n \t\t@Override /* PojoSwap */\r\n \t\tpublic String swap(BeanSession session, Date o) {\r\n+\t\t\tif (o == null)\r\n+\t\t\t\treturn null;\r\n \t\t\tCalendar c = new GregorianCalendar();\r\n \t\t\tc.setTime(o);\r\n \t\t\tString s = super.swap(session, o);\r\n@@ -553,6 +561,8 @@ else if (session.getTimeZone() != null)\n \t */\r\n \t@Override /* PojoSwap */\r\n \tpublic String swap(BeanSession session, Date o) {\r\n+\t\tif (o == null)\r\n+\t\t\treturn null;\r\n \t\treturn getDateFormat(session).format(o.getTime());\r\n \t}\r\n \r",
                "deletions": 0
            }
        ]
    }
]