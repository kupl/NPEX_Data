{
    "manifoldcf-integration-solr-3.x_328e663": {
        "bug_id": "manifoldcf-integration-solr-3.x_328e663",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/328e663779c34d1126a39b94cb239e8575b39172",
        "file": [
            {
                "additions": 49,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler-extras/src/test/org/apache/solr/handler/dataimport/TestTikaEntityProcessor.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/contrib/dataimporthandler-extras/src/test/org/apache/solr/handler/dataimport/TestTikaEntityProcessor.java?ref=328e663779c34d1126a39b94cb239e8575b39172",
                "deletions": 19,
                "filename": "solr/contrib/dataimporthandler-extras/src/test/org/apache/solr/handler/dataimport/TestTikaEntityProcessor.java",
                "patch": "@@ -18,36 +18,66 @@\n \n import org.junit.BeforeClass;\n import org.junit.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.xml.sax.InputSource;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n \n /**Testcase for TikaEntityProcessor\n- * @version $Id$\n- * @since solr 1.5 \n+ *\n+ * @since solr 3.1\n  */\n public class TestTikaEntityProcessor extends AbstractDataImportHandlerTestCase {\n+  private String conf =\n+  \"<dataConfig>\" +\n+  \"  <dataSource type=\\\"BinFileDataSource\\\"/>\" +\n+  \"  <document>\" +\n+  \"    <entity processor=\\\"TikaEntityProcessor\\\" url=\\\"\" + getFile(\"solr-word.pdf\").getAbsolutePath() + \"\\\" >\" +\n+  \"      <field column=\\\"Author\\\" meta=\\\"true\\\" name=\\\"author\\\"/>\" +\n+  \"      <field column=\\\"title\\\" meta=\\\"true\\\" name=\\\"title\\\"/>\" +\n+  \"      <field column=\\\"text\\\"/>\" +\n+  \"     </entity>\" +\n+  \"  </document>\" +\n+  \"</dataConfig>\";\n+\n+  private String[] tests = {\n+      \"//*[@numFound='1']\"\n+      ,\"//str[@name='author'][.='Grant Ingersoll']\"\n+      ,\"//str[@name='title'][.='solr-word']\"\n+      ,\"//str[@name='text']\"\n+  };\n+\n+\n   @BeforeClass\n   public static void beforeClass() throws Exception {\n     initCore(\"dataimport-solrconfig.xml\", \"dataimport-schema-no-unique-key.xml\", getFile(\"solr-dihextras\").getAbsolutePath());\n   }\n \n   @Test\n   public void testIndexingWithTikaEntityProcessor() throws Exception {\n-    String conf =\n-            \"<dataConfig>\" +\n-                    \"  <dataSource type=\\\"BinFileDataSource\\\"/>\" +\n-                    \"  <document>\" +\n-                    \"    <entity processor=\\\"TikaEntityProcessor\\\" url=\\\"\" + getFile(\"solr-word.pdf\").getAbsolutePath() + \"\\\" >\" +\n-                    \"      <field column=\\\"Author\\\" meta=\\\"true\\\" name=\\\"author\\\"/>\" +\n-                    \"      <field column=\\\"title\\\" meta=\\\"true\\\" name=\\\"title\\\"/>\" +\n-                    \"      <field column=\\\"text\\\"/>\" +\n-                    \"     </entity>\" +\n-                    \"  </document>\" +\n-                    \"</dataConfig>\";\n     runFullImport(conf);\n-    assertQ(req(\"*:*\")\n-            ,\"//*[@numFound='1']\"\n-            ,\"//str[@name='author'][.='Grant Ingersoll']\"\n-            ,\"//str[@name='title'][.='solr-word']\"\n-            ,\"//str[@name='text']\"\n-            );\n+    assertQ(req(\"*:*\"), tests );\n   }\n+\n+  @Test\n+  public void testIndexingWithTikaEntityProcessorThreaded() throws Exception {\n+    DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+    Document doc = builder.parse(new InputSource(new StringReader(conf)));\n+    ((Element) doc.getElementsByTagName(\"entity\").item(0)).setAttribute(\"threads\", \"1\");\n+    Transformer trans = TransformerFactory.newInstance().newTransformer();\n+    StringWriter writer = new StringWriter();\n+    trans.transform(new DOMSource(doc), new StreamResult(writer));\n+\n+    runFullImport(writer.toString());\n+    assertQ(req(\"*:*\"), tests );\n+  }\n+\n }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler-extras/src/test/org/apache/solr/handler/dataimport/TestTikaEntityProcessor.java",
                "sha": "7912c5f92d844d6bd060ce05ec0882a03255c38f",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler/CHANGES.txt",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/contrib/dataimporthandler/CHANGES.txt?ref=328e663779c34d1126a39b94cb239e8575b39172",
                "deletions": 0,
                "filename": "solr/contrib/dataimporthandler/CHANGES.txt",
                "patch": "@@ -15,6 +15,7 @@ Bug Fixes\n ----------------------\n * SOLR-2644: When using threads=2 the default logging is set too high (Bill Bell via shalin)\n * SOLR-2492: DIH does not commit if only deletes are processed (James Dyer via shalin)\n+* SOLR-2186: DataImportHandler's multi-threaded option throws NPE (Lance Norskog, Frank Wesemann, shalin)\n \n ==================  3.3.0 ==================\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler/CHANGES.txt",
                "sha": "66be321d1d0aa325b32fd9c47de89c809bc67463",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java?ref=328e663779c34d1126a39b94cb239e8575b39172",
                "deletions": 1,
                "filename": "solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java",
                "patch": "@@ -34,7 +34,7 @@\n  * @since solr 1.3\n  */\n public class ContextImpl extends Context {\n-  private DataConfig.Entity entity;\n+  protected DataConfig.Entity entity;\n \n   private ContextImpl parent;\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java",
                "sha": "b7dbc6eee05396f858f913a63f14dbd1cf7ea667",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ThreadedContext.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ThreadedContext.java?ref=328e663779c34d1126a39b94cb239e8575b39172",
                "deletions": 1,
                "filename": "solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ThreadedContext.java",
                "patch": "@@ -75,7 +75,7 @@ private void checkLimited() {\n   @Override\n   public String getResolvedEntityAttribute(String name) {\n     checkLimited();\n-    return super.getResolvedEntityAttribute(name);\n+    return entity == null ? null : getVariableResolver().replaceTokens(entity.allAttributes.get(name));\n   }\n \n   @Override",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/328e663779c34d1126a39b94cb239e8575b39172/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ThreadedContext.java",
                "sha": "59d3a0bb8736b98d6827bc6ff767d49a57bf1bd2",
                "status": "modified"
            }
        ],
        "message": "SOLR-2186 -- DataImportHandler's multi-threaded option throws NPE\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1147033 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/7dfeb75d85bcc64d29922d51047711b5ea79a624",
        "patched_files": [
            "CHANGES.java",
            "ThreadedContext.java",
            "ContextImpl.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestTikaEntityProcessor.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_3af1ed1": {
        "bug_id": "manifoldcf-integration-solr-3.x_3af1ed1",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc/lucene/CHANGES.txt",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/CHANGES.txt?ref=3af1ed1a92e55a960d60a5fef88cf66c4f306ebc",
                "deletions": 0,
                "filename": "lucene/CHANGES.txt",
                "patch": "@@ -246,6 +246,9 @@ Bug fixes\n   lock (previously we only released on IOException).  (Tamas Cservenak\n   via Mike McCandless)\n \n+* LUCENE-2478: Fix CachingWrapperFilter to not throw NPE when\n+  Filter.getDocIdSet() returns null.  (Uwe Schindler, Daniel Noll)\n+\n New features\n \n * LUCENE-2128: Parallelized fetching document frequencies during weight",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc/lucene/CHANGES.txt",
                "sha": "c604c342f6c588c93073221da84107ffba3fb4d4",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc/lucene/src/java/org/apache/lucene/search/CachingWrapperFilter.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/java/org/apache/lucene/search/CachingWrapperFilter.java?ref=3af1ed1a92e55a960d60a5fef88cf66c4f306ebc",
                "deletions": 1,
                "filename": "lucene/src/java/org/apache/lucene/search/CachingWrapperFilter.java",
                "patch": "@@ -53,7 +53,10 @@ public CachingWrapperFilter(Filter filter) {\n    *  an {@link OpenBitSetDISI}.\n    */\n   protected DocIdSet docIdSetToCache(DocIdSet docIdSet, IndexReader reader) throws IOException {\n-    if (docIdSet.isCacheable()) {\n+    if (docIdSet == null) {\n+      // this is better than returning null, as the nonnull result can be cached\n+      return DocIdSet.EMPTY_DOCIDSET;\n+    } else if (docIdSet.isCacheable()) {\n       return docIdSet;\n     } else {\n       final DocIdSetIterator it = docIdSet.iterator();",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc/lucene/src/java/org/apache/lucene/search/CachingWrapperFilter.java",
                "sha": "5e277e1b6ccacea9aaa37b06bd277c0c8641bb1d",
                "status": "modified"
            },
            {
                "additions": 52,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc/lucene/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java",
                "changes": 55,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java?ref=3af1ed1a92e55a960d60a5fef88cf66c4f306ebc",
                "deletions": 3,
                "filename": "lucene/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java",
                "patch": "@@ -19,7 +19,7 @@\n \n import java.io.IOException;\n \n-import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.analysis.KeywordAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.index.IndexWriter;\n import org.apache.lucene.index.IndexWriterConfig;\n@@ -34,7 +34,7 @@\n   public void testCachingWorks() throws Exception {\n     Directory dir = new RAMDirectory();\n     IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n-        TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n+        TEST_VERSION_CURRENT, new KeywordAnalyzer()));\n     writer.close();\n \n     IndexReader reader = IndexReader.open(dir, true);\n@@ -57,6 +57,55 @@ public void testCachingWorks() throws Exception {\n     reader.close();\n   }\n   \n+  public void testNullDocIdSet() throws Exception {\n+    Directory dir = new RAMDirectory();\n+    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n+        TEST_VERSION_CURRENT, new KeywordAnalyzer()));\n+    writer.close();\n+\n+    IndexReader reader = IndexReader.open(dir, true);\n+\n+    final Filter filter = new Filter() {\n+      @Override\n+      public DocIdSet getDocIdSet(IndexReader reader) {\n+        return null;\n+      }\n+    };\n+    CachingWrapperFilter cacher = new CachingWrapperFilter(filter);\n+\n+    // the caching filter should return the empty set constant\n+    assertSame(DocIdSet.EMPTY_DOCIDSET, cacher.getDocIdSet(reader));\n+    \n+    reader.close();\n+  }\n+  \n+  public void testNullDocIdSetIterator() throws Exception {\n+    Directory dir = new RAMDirectory();\n+    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n+        TEST_VERSION_CURRENT, new KeywordAnalyzer()));\n+    writer.close();\n+\n+    IndexReader reader = IndexReader.open(dir, true);\n+\n+    final Filter filter = new Filter() {\n+      @Override\n+      public DocIdSet getDocIdSet(IndexReader reader) {\n+        return new DocIdSet() {\n+          @Override\n+          public DocIdSetIterator iterator() {\n+            return null;\n+          }\n+        };\n+      }\n+    };\n+    CachingWrapperFilter cacher = new CachingWrapperFilter(filter);\n+\n+    // the caching filter should return the empty set constant\n+    assertSame(DocIdSet.EMPTY_DOCIDSET, cacher.getDocIdSet(reader));\n+    \n+    reader.close();\n+  }\n+  \n   private static void assertDocIdSetCacheable(IndexReader reader, Filter filter, boolean shouldCacheable) throws IOException {\n     final CachingWrapperFilter cacher = new CachingWrapperFilter(filter);\n     final DocIdSet originalSet = filter.getDocIdSet(reader);\n@@ -73,7 +122,7 @@ private static void assertDocIdSetCacheable(IndexReader reader, Filter filter, b\n   \n   public void testIsCacheAble() throws Exception {\n     Directory dir = new RAMDirectory();\n-    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n+    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new KeywordAnalyzer()));\n     writer.close();\n \n     IndexReader reader = IndexReader.open(dir, true);",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/3af1ed1a92e55a960d60a5fef88cf66c4f306ebc/lucene/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java",
                "sha": "e1000504c56fc7549329cb560b29b9e04c9e7596",
                "status": "modified"
            }
        ],
        "message": "LUCENE-2478: Fix CachingWrapperFilter to not throw NPE when Filter.getDocIdSet() returns null (3x)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@948430 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/b9dd56f25bc6e72d2411d19fd7f8d72ca406510b",
        "patched_files": [
            "CHANGES.java",
            "CachingWrapperFilter.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestCachingWrapperFilter.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_42ee5fd": {
        "bug_id": "manifoldcf-integration-solr-3.x_42ee5fd",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/42ee5fd17f9319f77de3bb3289d990341ed3a5ec",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/42ee5fd17f9319f77de3bb3289d990341ed3a5ec/solr/CHANGES.txt",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/CHANGES.txt?ref=42ee5fd17f9319f77de3bb3289d990341ed3a5ec",
                "deletions": 0,
                "filename": "solr/CHANGES.txt",
                "patch": "@@ -520,6 +520,12 @@ Bug Fixes\n * SOLR-2339: Fix sorting to explicitly generate an error if you\n   attempt to sort on a multiValued field. (hossman)\n \n+* SOLR-1191: resolve DataImportHandler deltaQuery column against pk when pk\n+  has a prefix (e.g. pk=\"book.id\" deltaQuery=\"select id from ...\"). More\n+  useful error reporting when no match found (previously failed with a\n+  NullPointerException in log and no clear user feedback). (gthb via yonik)\n+\n+\n Other Changes\n ----------------------\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/42ee5fd17f9319f77de3bb3289d990341ed3a5ec/solr/CHANGES.txt",
                "sha": "6e563b64273162803ce0aaf7efb7caf2f26a9290",
                "status": "modified"
            },
            {
                "additions": 42,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/42ee5fd17f9319f77de3bb3289d990341ed3a5ec/solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DocBuilder.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DocBuilder.java?ref=42ee5fd17f9319f77de3bb3289d990341ed3a5ec",
                "deletions": 3,
                "filename": "solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DocBuilder.java",
                "patch": "@@ -318,7 +318,11 @@ private void deleteAll(Set<Map<String, Object>> deletedKeys) {\n       String keyName = root.isDocRoot ? root.getPk() : root.getSchemaPk();\n       Object key = map.get(keyName);\n       if(key == null) {\n-        LOG.warn(\"no key was available for deleteted pk query. keyName = \" + keyName);\n+        keyName = findMatchingPkColumn(keyName, map);\n+        key = map.get(keyName);\n+      }\n+      if(key == null) {\n+        LOG.warn(\"no key was available for deleted pk query. keyName = \" + keyName);\n         continue;\n       }\n       writer.deleteDoc(key);\n@@ -816,6 +820,28 @@ private EntityProcessorWrapper getEntityProcessor(DataConfig.Entity entity) {\n     return entity.processor = new EntityProcessorWrapper(entityProcessor, this);\n   }\n \n+  private String findMatchingPkColumn(String pk, Map<String, Object> row) {\n+    if (row.containsKey(pk))\n+      throw new IllegalArgumentException(\n+        String.format(\"deltaQuery returned a row with null for primary key %s\", pk));\n+    String resolvedPk = null;\n+    for (String columnName : row.keySet()) {\n+      if (columnName.endsWith(\".\" + pk) || pk.endsWith(\".\" + columnName)) {\n+        if (resolvedPk != null)\n+          throw new IllegalArgumentException(\n+            String.format(\n+              \"deltaQuery has more than one column (%s and %s) that might resolve to declared primary key pk='%s'\",\n+              resolvedPk, columnName, pk));\n+        resolvedPk = columnName;\n+      }\n+    }\n+    if (resolvedPk == null)\n+      throw new IllegalArgumentException(\n+        String.format(\"deltaQuery has no column to resolve to declared primary key pk='%s'\", pk));\n+    LOG.info(String.format(\"Resolving deltaQuery column '%s' to match entity's declared pk '%s'\", resolvedPk, pk));\n+    return resolvedPk;\n+  }\n+\n   /**\n    * <p> Collects unique keys of all Solr documents for whom one or more source tables have been changed since the last\n    * indexed time. </p> <p> Note: In our definition, unique key of Solr document is the primary key of the top level\n@@ -852,13 +878,20 @@ private EntityProcessorWrapper getEntityProcessor(DataConfig.Entity entity) {\n     Map<String, Map<String, Object>> deltaSet = new HashMap<String, Map<String, Object>>();\n     LOG.info(\"Running ModifiedRowKey() for Entity: \" + entity.name);\n     //get the modified rows in this entity\n+    String pk = entity.getPk();\n     while (true) {\n       Map<String, Object> row = entityProcessor.nextModifiedRowKey();\n \n       if (row == null)\n         break;\n \n-      deltaSet.put(row.get(entity.getPk()).toString(), row);\n+      Object pkValue = row.get(pk);\n+      if (pkValue == null) {\n+        pk = findMatchingPkColumn(pk, row);\n+        pkValue = row.get(pk);\n+      }\n+\n+      deltaSet.put(pkValue.toString(), row);\n       importStatistics.rowsCount.incrementAndGet();\n       // check for abort\n       if (stop.get())\n@@ -873,8 +906,14 @@ private EntityProcessorWrapper getEntityProcessor(DataConfig.Entity entity) {\n \n       deletedSet.add(row);\n       \n+      Object pkValue = row.get(pk);\n+      if (pkValue == null) {\n+        pk = findMatchingPkColumn(pk, row);\n+        pkValue = row.get(pk);\n+      }\n+\n       // Remove deleted rows from the delta rows\n-      String deletedRowPk = row.get(entity.getPk()).toString();\n+      String deletedRowPk = pkValue.toString();\n       if (deltaSet.containsKey(deletedRowPk)) {\n         deltaSet.remove(deletedRowPk);\n       }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/42ee5fd17f9319f77de3bb3289d990341ed3a5ec/solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DocBuilder.java",
                "sha": "858d688976ec2c68ef18b595c201a43a3cd3dd2f",
                "status": "modified"
            },
            {
                "additions": 145,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/42ee5fd17f9319f77de3bb3289d990341ed3a5ec/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDeltaPrefixedPk.java",
                "changes": 145,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDeltaPrefixedPk.java?ref=42ee5fd17f9319f77de3bb3289d990341ed3a5ec",
                "deletions": 0,
                "filename": "solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDeltaPrefixedPk.java",
                "patch": "@@ -0,0 +1,145 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.handler.dataimport;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.*;\n+\n+/**\n+ * <p>\n+ * Test for SqlEntityProcessorDelta verifying fix for SOLR-1191\n+ * </p>\n+ * \n+ *\n+ * @version $Id$\n+ * @since solr 3.1\n+ */\n+public class TestSqlEntityProcessorDeltaPrefixedPk extends AbstractDataImportHandlerTestCase {\n+  private static final String FULLIMPORT_QUERY = \"select * from x\";\n+\n+  private static final String DELTA_QUERY = \"select id from x where last_modified > NOW\";\n+\n+  private static final String DELETED_PK_QUERY = \"select id from x where last_modified > NOW AND deleted='true'\";\n+\n+  private static final String dataConfig_delta =\n+    \"<dataConfig>\" +\n+    \"  <dataSource  type=\\\"MockDataSource\\\"/>\\n\" +\n+    \"  <document>\\n\" +\n+    \"    <entity name=\\\"x\\\" transformer=\\\"TemplateTransformer\\\" pk=\\\"x.id\\\"\" +\n+    \"            query=\\\"\" + FULLIMPORT_QUERY + \"\\\"\" +\n+    \"            deletedPkQuery=\\\"\" + DELETED_PK_QUERY + \"\\\"\" +\n+    \"            deltaImportQuery=\\\"select * from x where id='${dih.delta.id}'\\\"\" +\n+    \"            deltaQuery=\\\"\" + DELTA_QUERY + \"\\\">\\n\" +\n+    \"      <field column=\\\"id\\\" name=\\\"id\\\"/>\\n\" +\n+    \"      <field column=\\\"desc\\\" name=\\\"desc\\\"/>\\n\" +\n+    \"    </entity>\\n\" +\n+    \"  </document>\\n\" +\n+    \"</dataConfig>\\n\";\n+  \n+  private static final List EMPTY_LIST = Collections.EMPTY_LIST;\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    initCore(\"dataimport-solrconfig.xml\", \"dataimport-schema.xml\");\n+  }\n+\n+  @Before @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    clearIndex();\n+    assertU(commit());\n+    //Logger.getLogger(\"\").setLevel(Level.ALL);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private void add1document() throws Exception {\n+    List row = new ArrayList();\n+    row.add(createMap(\"id\", \"1\", \"desc\", \"bar\"));\n+    MockDataSource.setIterator(FULLIMPORT_QUERY, row.iterator());\n+\n+    runFullImport(dataConfig_delta);\n+\n+    assertQ(req(\"*:* OR add1document\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"id:1\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"desc:bar\"), \"//*[@numFound='1']\");\n+  }\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void testDeltaImport_deleteResolvesUnprefixedPk() throws Exception {\n+    add1document();\n+    MockDataSource.clearCache();\n+    List deletedRows = new ArrayList();\n+    deletedRows.add(createMap(\"id\", \"1\"));\n+    MockDataSource.setIterator(DELETED_PK_QUERY, deletedRows.iterator());\n+    MockDataSource.setIterator(DELTA_QUERY, EMPTY_LIST.iterator());\n+    runDeltaImport(dataConfig_delta);\n+\n+    assertQ(req(\"*:* OR testDeltaImport_deleteResolvesUnprefixedPk\"), \"//*[@numFound='0']\");\n+  }\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void testDeltaImport_replace_resolvesUnprefixedPk() throws Exception {\n+    add1document();\n+    MockDataSource.clearCache();\n+    List deltaRows = new ArrayList();\n+    deltaRows.add(createMap(\"id\", \"1\"));\n+    MockDataSource.setIterator(DELTA_QUERY, deltaRows.iterator());\n+    MockDataSource.setIterator(DELETED_PK_QUERY, EMPTY_LIST.iterator());\n+    List rows = new ArrayList();\n+    rows.add(createMap(\"id\", \"1\", \"desc\", \"baz\"));\n+    MockDataSource.setIterator(\"select * from x where id='1'\", rows.iterator());\n+\n+    runDeltaImport(dataConfig_delta);\n+\n+    assertQ(req(\"*:* OR testDeltaImport_replace_resolvesUnprefixedPk\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"id:1\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"desc:bar\"), \"//*[@numFound='0']\");\n+    assertQ(req(\"desc:baz\"), \"//*[@numFound='1']\");\n+  }\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void testDeltaImport_addResolvesUnprefixedPk() throws Exception {\n+    add1document();\n+    MockDataSource.clearCache();\n+\n+    List deltaRows = new ArrayList();\n+    deltaRows.add(createMap(\"id\", \"2\"));\n+    MockDataSource.setIterator(DELTA_QUERY, deltaRows.iterator());\n+\n+    List rows = new ArrayList();\n+    rows.add(createMap(\"id\", \"2\", \"desc\", \"xyzzy\"));\n+    MockDataSource.setIterator(\"select * from x where id='2'\", rows.iterator());\n+\n+    runDeltaImport(dataConfig_delta);\n+\n+    assertQ(req(\"*:* OR testDeltaImport_addResolvesUnprefixedPk\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"id:1\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"id:2\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"desc:bar\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"desc:xyzzy\"), \"//*[@numFound='1']\");\n+  }\n+\n+}",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/42ee5fd17f9319f77de3bb3289d990341ed3a5ec/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDeltaPrefixedPk.java",
                "sha": "51fc50b9f1a88718a3b339c35e47309a667cc09f",
                "status": "added"
            }
        ],
        "message": "SOLR-1191: fix DIH deltaQyery when pk has prefix, change NPE to better error reporting\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1071438 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/fcf4f62e89508802a65405199a7db7663ea43ddd",
        "patched_files": [
            "CHANGES.java",
            "DocBuilder.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestSqlEntityProcessorDeltaPrefixedPk.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_4fb39fb": {
        "bug_id": "manifoldcf-integration-solr-3.x_4fb39fb",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e/lucene/src/java/org/apache/lucene/search/function/OrdFieldSource.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/java/org/apache/lucene/search/function/OrdFieldSource.java?ref=4fb39fb4a7380dfb770182410aa4b1f62ee86e8e",
                "deletions": 1,
                "filename": "lucene/src/java/org/apache/lucene/search/function/OrdFieldSource.java",
                "patch": "@@ -98,7 +98,9 @@ Object getInnerArray() {\n   /*(non-Javadoc) @see java.lang.Object#equals(java.lang.Object) */\n   @Override\n   public boolean equals(Object o) {\n-    if (o.getClass() !=  OrdFieldSource.class) return false;\n+    if (o == this) return true;\n+    if (o == null) return false;\n+    if (o.getClass() != OrdFieldSource.class) return false;\n     OrdFieldSource other = (OrdFieldSource)o;\n     return this.field.equals(other.field);\n   }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e/lucene/src/java/org/apache/lucene/search/function/OrdFieldSource.java",
                "sha": "1a85098ace657f936f8bb87f477c03abef5953a0",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e/lucene/src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java?ref=4fb39fb4a7380dfb770182410aa4b1f62ee86e8e",
                "deletions": 1,
                "filename": "lucene/src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java",
                "patch": "@@ -108,7 +108,9 @@ Object getInnerArray() {\n   /*(non-Javadoc) @see java.lang.Object#equals(java.lang.Object) */\n   @Override\n   public boolean equals(Object o) {\n-    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;\n+    if (o == this) return true;\n+    if (o == null) return false;\n+    if (o.getClass() != ReverseOrdFieldSource.class) return false;\n     ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;\n     return this.field.equals(other.field); \n   }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e/lucene/src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java",
                "sha": "7f7d652256b7267c41dcfb18679b697f49045a36",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e/lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java?ref=4fb39fb4a7380dfb770182410aa4b1f62ee86e8e",
                "deletions": 0,
                "filename": "lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java",
                "patch": "@@ -253,4 +253,13 @@ private String testName() {\n     return getClass().getName() + \".\" + getName();\n   }\n \n+  // LUCENE-1250\n+  public void testEqualsNull() throws Exception {\n+    OrdFieldSource ofs = new OrdFieldSource(\"f\");\n+    assertFalse(ofs.equals(null));\n+    \n+    ReverseOrdFieldSource rofs = new ReverseOrdFieldSource(\"f\");\n+    assertFalse(rofs.equals(null));\n+  }\n+  \n }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/4fb39fb4a7380dfb770182410aa4b1f62ee86e8e/lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java",
                "sha": "bad275f2ce09168ca0f3ea403506d95b7548351c",
                "status": "modified"
            }
        ],
        "message": "LUCENE-1250: fix equals() to check for null and not fail on NPE (3x)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1063271 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/bd54aba17c04081a060095f022b46d41fe47e398",
        "patched_files": [
            "OrdFieldSource.java",
            "ReverseOrdFieldSource.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestOrdValues.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_87a4c5b": {
        "bug_id": "manifoldcf-integration-solr-3.x_87a4c5b",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/87a4c5b53a96ff827a339295b02efc2b401dd879",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/87a4c5b53a96ff827a339295b02efc2b401dd879/lucene/CHANGES.txt",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/CHANGES.txt?ref=87a4c5b53a96ff827a339295b02efc2b401dd879",
                "deletions": 0,
                "filename": "lucene/CHANGES.txt",
                "patch": "@@ -286,6 +286,10 @@ Bug fixes\n   files when a mergedSegmentWarmer is set on IndexWriter.  (Mike\n   McCandless)\n \n+* LUCENE-2496: Don't throw NPE if IndexWriter is opened with CREATE on\n+  a prior (corrupt) index missing its segments_N file.  (Mike\n+  McCandless)\n+\n New features\n \n * LUCENE-2128: Parallelized fetching document frequencies during weight",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/87a4c5b53a96ff827a339295b02efc2b401dd879/lucene/CHANGES.txt",
                "sha": "e6e389021c4420df03cfd2d9afd6b7a333656c74",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/87a4c5b53a96ff827a339295b02efc2b401dd879/lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java?ref=87a4c5b53a96ff827a339295b02efc2b401dd879",
                "deletions": 9,
                "filename": "lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java",
                "patch": "@@ -130,8 +130,10 @@ public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, Segment\n     this.docWriter = docWriter;\n     this.infoStream = infoStream;\n \n+    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n+\n     if (infoStream != null)\n-      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n+      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n \n     this.policy = policy;\n     this.directory = directory;\n@@ -142,7 +144,6 @@ public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, Segment\n     IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n \n     CommitPoint currentCommitPoint = null;\n-    boolean seenIndexFiles = false;\n     String[] files = null;\n     try {\n       files = directory.listAll();\n@@ -154,7 +155,6 @@ public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, Segment\n     for (String fileName : files) {\n \n       if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n-        seenIndexFiles = true;\n         \n         // Add this file to refCounts with initial count 0:\n         getRefCount(fileName);\n@@ -197,10 +197,7 @@ public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, Segment\n       }\n     }\n \n-    // If we haven't seen any Lucene files, then currentCommitPoint is expected\n-    // to be null, because it means it's a fresh Directory. Therefore it cannot\n-    // be any NFS cache issues - so just ignore.\n-    if (currentCommitPoint == null && seenIndexFiles) {\n+    if (currentCommitPoint == null && currentSegmentsFile != null) {\n       // We did not in fact see the segments_N file\n       // corresponding to the segmentInfos that was passed\n       // in.  Yet, it must exist, because our caller holds\n@@ -210,7 +207,7 @@ public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, Segment\n       // try now to explicitly open this commit point:\n       SegmentInfos sis = new SegmentInfos();\n       try {\n-        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n+        sis.read(directory, currentSegmentsFile);\n       } catch (IOException e) {\n         throw new CorruptIndexException(\"failed to locate current segments_N file\");\n       }\n@@ -240,7 +237,7 @@ public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, Segment\n \n     // Finally, give policy a chance to remove things on\n     // startup:\n-    if (seenIndexFiles) {\n+    if (currentSegmentsFile != null) {\n       policy.onInit(commits);\n     }\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/87a4c5b53a96ff827a339295b02efc2b401dd879/lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java",
                "sha": "5984c80f3a034ed5f114041aed466a4c08f67283",
                "status": "modified"
            },
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/87a4c5b53a96ff827a339295b02efc2b401dd879/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java",
                "changes": 29,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java?ref=87a4c5b53a96ff827a339295b02efc2b401dd879",
                "deletions": 1,
                "filename": "lucene/src/test/org/apache/lucene/index/TestIndexWriter.java",
                "patch": "@@ -4885,5 +4885,32 @@ public void testEmptyDirRollback() throws Exception {\n     writer.close();\n     assertEquals(\"expected a no-op close after IW.rollback()\", 0, dir.listAll().length);\n   }\n-  \n+\n+  public void testNoSegmentFile() throws IOException {\n+    File tempDir = _TestUtil.getTempDir(\"noSegmentFile\");\n+    try {\n+      Directory dir = FSDirectory.open(tempDir);\n+      dir.setLockFactory(new NoLockFactory());\n+      IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(\n+                                                                 TEST_VERSION_CURRENT, new WhitespaceAnalyzer())\n+                                      .setMaxBufferedDocs(2));\n+\n+      Document doc = new Document();\n+      doc.add(new Field(\"c\", \"val\", Store.YES, Index.ANALYZED, TermVector.WITH_POSITIONS_OFFSETS));\n+      w.addDocument(doc);\n+      w.addDocument(doc);\n+      String[] files = dir.listAll();\n+      for(String file : files) {\n+        System.out.println(\"file=\" + file);\n+      }\n+      IndexWriter w2 = new IndexWriter(dir, new IndexWriterConfig(\n+                                                                  TEST_VERSION_CURRENT, new WhitespaceAnalyzer())\n+                                       .setMaxBufferedDocs(2).setOpenMode(OpenMode.CREATE));\n+\n+      w2.close();\n+      dir.close();\n+    } finally {\n+      _TestUtil.rmDir(tempDir);\n+    }\n+  }\n }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/87a4c5b53a96ff827a339295b02efc2b401dd879/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java",
                "sha": "9202aa12d607120c19cf8bbef806f68111634325",
                "status": "modified"
            }
        ],
        "message": "LUCENE-2496: don't throw NPE on trying to CREATE over a corrupt index\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@953631 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/91997021b5320a8854f13bdcc8acdd9191d94335",
        "patched_files": [
            "CHANGES.java",
            "IndexFileDeleter.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestIndexWriter.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_9475d5c": {
        "bug_id": "manifoldcf-integration-solr-3.x_9475d5c",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf/solr/CHANGES.txt",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/CHANGES.txt?ref=9475d5c5ca14fe3269f87e04ffb39f9dd27decbf",
                "deletions": 0,
                "filename": "solr/CHANGES.txt",
                "patch": "@@ -46,6 +46,9 @@ Optimizations\n Bug Fixes\n ----------------------\n \n+* SOLR-2625: TermVectorComponent throws NPE if TF-IDF option is used without DF\n+  option. (Daniel Erenrich, Simon Willnauer)\n+\n Other Changes\n ----------------------\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf/solr/CHANGES.txt",
                "sha": "2271adc9fcc0b25976d88a6026268346cc75435f",
                "status": "modified"
            },
            {
                "additions": 24,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf/solr/src/java/org/apache/solr/handler/component/TermVectorComponent.java",
                "changes": 51,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/src/java/org/apache/solr/handler/component/TermVectorComponent.java?ref=9475d5c5ca14fe3269f87e04ffb39f9dd27decbf",
                "deletions": 27,
                "filename": "solr/src/java/org/apache/solr/handler/component/TermVectorComponent.java",
                "patch": "@@ -89,7 +89,7 @@ public void process(ResponseBuilder rb) throws IOException {\n       return;\n     }\n \n-    NamedList termVectors = new NamedList();\n+    NamedList<Object> termVectors = new NamedList<Object>();\n     rb.rsp.add(TERM_VECTORS, termVectors);\n     FieldOptions allFields = new FieldOptions();\n     //figure out what options we have, and try to get the appropriate vector\n@@ -118,7 +118,7 @@ public void process(ResponseBuilder rb) throws IOException {\n     IndexSchema schema = rb.req.getSchema();\n     //Build up our per field mapping\n     Map<String, FieldOptions> fieldOptions = new HashMap<String, FieldOptions>();\n-    NamedList warnings = new NamedList();\n+    NamedList<List<String>>  warnings = new NamedList<List<String>> ();\n     List<String>  noTV = new ArrayList<String>();\n     List<String>  noPos = new ArrayList<String>();\n     List<String>  noOff = new ArrayList<String>();\n@@ -142,11 +142,11 @@ public void process(ResponseBuilder rb) throws IOException {\n             option.tfIdf = params.getFieldBool(field, TermVectorParams.TF_IDF, allFields.tfIdf);\n             //Validate these are even an option\n             option.positions = params.getFieldBool(field, TermVectorParams.POSITIONS, allFields.positions);\n-            if (option.positions == true && sf.storeTermPositions() == false){\n+            if (option.positions && !sf.storeTermPositions()){\n               noPos.add(field);\n             }\n             option.offsets = params.getFieldBool(field, TermVectorParams.OFFSETS, allFields.offsets);\n-            if (option.offsets == true && sf.storeTermOffsets() == false){\n+            if (option.offsets && !sf.storeTermOffsets()){\n               noOff.add(field);\n             }\n           } else {//field doesn't have term vectors\n@@ -159,26 +159,26 @@ public void process(ResponseBuilder rb) throws IOException {\n       }\n     } //else, deal with all fields\n     boolean hasWarnings = false;\n-    if (noTV.isEmpty() == false) {\n+    if (!noTV.isEmpty()) {\n       warnings.add(\"noTermVectors\", noTV);\n       hasWarnings = true;\n     }\n-    if (noPos.isEmpty() == false) {\n+    if (!noPos.isEmpty()) {\n       warnings.add(\"noPositions\", noPos);\n       hasWarnings = true;\n     }\n-    if (noOff.isEmpty() == false) {\n+    if (!noOff.isEmpty()) {\n       warnings.add(\"noOffsets\", noOff);\n       hasWarnings = true;\n     }\n-    if (hasWarnings == true) {\n+    if (hasWarnings) {\n       termVectors.add(\"warnings\", warnings);\n     }\n \n     DocListAndSet listAndSet = rb.getResults();\n     List<Integer> docIds = getInts(params.getParams(TermVectorParams.DOC_IDS));\n     Iterator<Integer> iter;\n-    if (docIds != null && docIds.isEmpty() == false) {\n+    if (docIds != null && !docIds.isEmpty()) {\n       iter = docIds.iterator();\n     } else {\n       DocList list = listAndSet.docList;\n@@ -199,7 +199,7 @@ public void process(ResponseBuilder rb) throws IOException {\n     mapper.fieldOptions = allFields; //this will only stay set if fieldOptions.isEmpty() (in other words, only if the user didn't set any fields)\n     while (iter.hasNext()) {\n       Integer docId = iter.next();\n-      NamedList docNL = new NamedList();\n+      NamedList<Object> docNL = new NamedList<Object>();\n       mapper.docNL = docNL;\n       termVectors.add(\"doc-\" + docId, docNL);\n \n@@ -215,7 +215,7 @@ public void process(ResponseBuilder rb) throws IOException {\n           termVectors.add(\"uniqueKeyFieldName\", uniqFieldName);\n         }\n       }\n-      if (fieldOptions.isEmpty() == false) {\n+      if (!fieldOptions.isEmpty()) {\n         for (Map.Entry<String, FieldOptions> entry : fieldOptions.entrySet()) {\n           mapper.fieldOptions = entry.getValue();\n           reader.getTermFreqVector(docId, entry.getKey(), mapper);\n@@ -284,15 +284,15 @@ public int distributedProcess(ResponseBuilder rb) throws IOException {\n \n   private static class TVMapper extends TermVectorMapper {\n     private IndexReader reader;\n-    private NamedList docNL;\n+    private NamedList<Object> docNL;\n \n     //needs to be set for each new field\n     FieldOptions fieldOptions;\n \n     //internal vars not passed in by construction\n     private boolean useOffsets, usePositions;\n     //private Map<String, Integer> idfCache;\n-    private NamedList fieldNL;\n+    private NamedList<Object> fieldNL;\n     private Term currentTerm;\n \n \n@@ -302,31 +302,31 @@ public TVMapper(IndexReader reader) {\n \n     @Override\n     public void map(String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {\n-      NamedList termInfo = new NamedList();\n+      NamedList<Object> termInfo = new NamedList<Object>();\n         fieldNL.add(term, termInfo);\n-        if (fieldOptions.termFreq == true) {\n+        if (fieldOptions.termFreq) {\n           termInfo.add(\"tf\", frequency);\n         }\n-        if (useOffsets == true) {\n-          NamedList theOffsets = new NamedList();\n+        if (useOffsets) {\n+          NamedList<Integer> theOffsets = new NamedList<Integer>();\n           termInfo.add(\"offsets\", theOffsets);\n           for (int i = 0; i < offsets.length; i++) {\n             TermVectorOffsetInfo offset = offsets[i];\n             theOffsets.add(\"start\", offset.getStartOffset());\n             theOffsets.add(\"end\", offset.getEndOffset());\n           }\n         }\n-        if (usePositions == true) {\n-          NamedList positionsNL = new NamedList();\n+        if (usePositions) {\n+          NamedList<Integer> positionsNL = new NamedList<Integer>();\n           for (int i = 0; i < positions.length; i++) {\n             positionsNL.add(\"position\", positions[i]);\n           }\n           termInfo.add(\"positions\", positionsNL);\n         }\n-        if (fieldOptions.docFreq == true) {\n+        if (fieldOptions.docFreq) {\n           termInfo.add(\"df\", getDocFreq(term));\n         }\n-        if (fieldOptions.tfIdf == true) {\n+        if (fieldOptions.tfIdf) {\n           double tfIdfVal = ((double) frequency) / getDocFreq(term);\n           termInfo.add(\"tf-idf\", tfIdfVal);\n         }\n@@ -336,7 +336,7 @@ private int getDocFreq(String term) {\n       int result = 1;\n       currentTerm = currentTerm.createTerm(term);\n       try {\n-        TermEnum termEnum = reader.terms(currentTerm);\n+        final TermEnum termEnum = reader.terms(currentTerm);\n         if (termEnum != null && termEnum.term().equals(currentTerm)) {\n           result = termEnum.docFreq();\n         }\n@@ -348,13 +348,10 @@ private int getDocFreq(String term) {\n \n     @Override\n     public void setExpectations(String field, int numTerms, boolean storeOffsets, boolean storePositions) {\n-\n-      if (fieldOptions.docFreq == true && reader != null) {\n-        this.currentTerm = new Term(field);\n-      }\n+      currentTerm = new Term(field);\n       useOffsets = storeOffsets && fieldOptions.offsets;\n       usePositions = storePositions && fieldOptions.positions;\n-      fieldNL = new NamedList();\n+      fieldNL = new NamedList<Object>();\n       docNL.add(field, fieldNL);\n     }\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf/solr/src/java/org/apache/solr/handler/component/TermVectorComponent.java",
                "sha": "6a3bf8378ed22620c703ca095fdf26d8eb0afbe3",
                "status": "modified"
            },
            {
                "additions": 47,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf/solr/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java?ref=9475d5c5ca14fe3269f87e04ffb39f9dd27decbf",
                "deletions": 21,
                "filename": "solr/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java",
                "patch": "@@ -1,24 +1,4 @@\n package org.apache.solr.handler.component;\n-\n-import org.apache.solr.SolrTestCaseJ4;\n-import org.apache.solr.core.SolrCore;\n-import org.apache.solr.common.params.ModifiableSolrParams;\n-import org.apache.solr.common.params.CommonParams;\n-import org.apache.solr.common.params.TermVectorParams;\n-import org.apache.solr.common.util.NamedList;\n-import org.apache.solr.common.util.SimpleOrderedMap;\n-import org.apache.solr.request.SolrRequestHandler;\n-import org.apache.solr.request.LocalSolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n-\n-import static org.junit.Assert.*;\n-\n-import java.util.HashMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n  * contributor license agreements.  See the NOTICE file distributed with\n@@ -36,6 +16,19 @@\n  * limitations under the License.\n  */\n \n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.common.params.ModifiableSolrParams;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.params.TermVectorParams;\n+import org.apache.solr.request.LocalSolrQueryRequest;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.HashMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n \n /**\n  *\n@@ -140,7 +133,40 @@ public void testOptions() throws Exception {\n     assertJQ(req(\"json.nl\",\"map\", \"qt\",tv, \"q\", \"id:0\", TermVectorComponent.COMPONENT_NAME, \"true\"\n        , TermVectorParams.TF, \"true\", TermVectorParams.DF, \"true\", TermVectorParams.OFFSETS, \"true\", TermVectorParams.POSITIONS, \"true\", TermVectorParams.TF_IDF, \"true\")\n        ,\"/termVectors/doc-0/test_posofftv/anoth=={'tf':1, 'offsets':{'start':20, 'end':27}, 'positions':{'position':1}, 'df':2, 'tf-idf':0.5}\"\n-    );    \n+    );\n+    \n+    assertJQ(req(\"json.nl\",\"map\", \"qt\",tv, \"q\", \"id:0\", TermVectorComponent.COMPONENT_NAME, \"true\"\n+        , TermVectorParams.ALL, \"true\")\n+        ,\"/termVectors/doc-0/test_posofftv/anoth=={'tf':1, 'offsets':{'start':20, 'end':27}, 'positions':{'position':1}, 'df':2, 'tf-idf':0.5}\"\n+     );\n+    \n+    // test each combination at random\n+    final List<String> list = new ArrayList<String>();\n+    list.addAll(Arrays.asList(\"json.nl\",\"map\", \"qt\",tv, \"q\", \"id:0\", TermVectorComponent.COMPONENT_NAME, \"true\"));\n+    String[][] options = new String[][] { \n+        { TermVectorParams.TF, \"'tf':1\" },\n+        { TermVectorParams.OFFSETS, \"'offsets':{'start':20, 'end':27}\" },\n+        { TermVectorParams.POSITIONS, \"'positions':{'position':1}\" },\n+        { TermVectorParams.DF, \"'df':2\" },\n+        { TermVectorParams.TF_IDF, \"'tf-idf':0.5\" } };\n+    StringBuilder expected = new StringBuilder(\"/termVectors/doc-0/test_posofftv/anoth=={\");\n+    boolean first = true;\n+    for (int i = 0; i < options.length; i++) {\n+      final boolean use = random.nextBoolean();\n+      if (use) {\n+        if (!first) {\n+          expected.append(\", \");\n+        }\n+        first = false;\n+        expected.append(options[i][1]);\n+        \n+      }\n+      list.add(options[i][0]);\n+      list.add(use ? \"true\" : \"false\");\n+    }\n+    \n+    expected.append(\"}\");\n+    assertJQ(req(list.toArray(new String[0])), expected.toString());\n   }\n \n   @Test",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/9475d5c5ca14fe3269f87e04ffb39f9dd27decbf/solr/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java",
                "sha": "747bb2833858caf6697d51f1d70fa159bc6e9a7d",
                "status": "modified"
            }
        ],
        "message": "SOLR-2625: TermVectorComponent throws NPE if TF-IDF option is used without DF option.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1141405 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/d4d5d041c46b5b6ea5539d2f37f31368f79c11a9",
        "patched_files": [
            "CHANGES.java",
            "TermVectorComponent.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TermVectorComponentTest.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_c531a1e": {
        "bug_id": "manifoldcf-integration-solr-3.x_c531a1e",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/c531a1ef617eaa7263b5cf4afff5afd80888c11c",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/c531a1ef617eaa7263b5cf4afff5afd80888c11c/lucene/CHANGES.txt",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/CHANGES.txt?ref=c531a1ef617eaa7263b5cf4afff5afd80888c11c",
                "deletions": 0,
                "filename": "lucene/CHANGES.txt",
                "patch": "@@ -292,6 +292,9 @@ New features\n   to wrap any other Analyzer and provide the same functionality as\n   MaxFieldLength provided on IndexWriter.  This patch also fixes a bug\n   in the offset calculation in CharTokenizer. (Uwe Schindler, Shai Erera)\n+\n+* LUCENE-2526: Don't throw NPE from MultiPhraseQuery.toString when\n+  it's empty.  (Ross Woolf via Mike McCandless)\n   \n Optimizations\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/c531a1ef617eaa7263b5cf4afff5afd80888c11c/lucene/CHANGES.txt",
                "sha": "c5da179952466e4698da81e86d254ee9d3ba1d61",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/c531a1ef617eaa7263b5cf4afff5afd80888c11c/lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java?ref=c531a1ef617eaa7263b5cf4afff5afd80888c11c",
                "deletions": 1,
                "filename": "lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java",
                "patch": "@@ -319,7 +319,7 @@ public Weight createWeight(Searcher searcher) throws IOException {\n   @Override\n   public final String toString(String f) {\n     StringBuilder buffer = new StringBuilder();\n-    if (!field.equals(f)) {\n+    if (field == null || !field.equals(f)) {\n       buffer.append(field);\n       buffer.append(\":\");\n     }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/c531a1ef617eaa7263b5cf4afff5afd80888c11c/lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java",
                "sha": "aacfe383b0630b0c75db3992c49aeefaab6e8e85",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/c531a1ef617eaa7263b5cf4afff5afd80888c11c/lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java?ref=c531a1ef617eaa7263b5cf4afff5afd80888c11c",
                "deletions": 0,
                "filename": "lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java",
                "patch": "@@ -257,4 +257,9 @@ private void add(String s, String type, IndexWriter writer) throws IOException {\n     writer.addDocument(doc);\n   }\n \n+  // LUCENE-2526\n+  public void testEmptyToString() {\n+    new MultiPhraseQuery().toString();\n+  }\n+\n }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/c531a1ef617eaa7263b5cf4afff5afd80888c11c/lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java",
                "sha": "e3740029b77f0b6b2119ce1ce8bfcf4131e68f39",
                "status": "modified"
            }
        ],
        "message": "LUCENE-2526: don't throw NPE from MultiPhraseQuery.toString if it has no terms\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@960368 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/6ad5e825a182a3d31ec3357caf81c7f23f6ed460",
        "patched_files": [
            "CHANGES.java",
            "MultiPhraseQuery.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestMultiPhraseQuery.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_ea009a4": {
        "bug_id": "manifoldcf-integration-solr-3.x_ea009a4",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/CHANGES.txt",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/CHANGES.txt?ref=ea009a4785a1a2b04dfd9a190bea7a1cc68129f9",
                "deletions": 0,
                "filename": "solr/CHANGES.txt",
                "patch": "@@ -43,6 +43,8 @@ Bug Fixes\n   could commit too frequently and could block adds until a new seaercher was\n   registered. (yonik)\n \n+* SOLR-2726: Fixed NullPointerException when using spellcheck.q with Suggester.\n+  (Bernd Fehling, valentin via rmuir)\n \n  Other Changes\n ----------------------",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/CHANGES.txt",
                "sha": "817d6c5734988fbab32bb9b90e7af6d2994558b8",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java?ref=ea009a4785a1a2b04dfd9a190bea7a1cc68129f9",
                "deletions": 16,
                "filename": "solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java",
                "patch": "@@ -69,14 +69,11 @@\n   public static final String INDEX_DIR = \"spellcheckIndexDir\";\n   public static final String ACCURACY = \"accuracy\";\n   public static final String STRING_DISTANCE = \"distanceMeasure\";\n-  public static final String FIELD_TYPE = \"fieldType\";\n   public static final String COMPARATOR_CLASS = \"comparatorClass\";\n \n   public static final String SCORE_COMP = \"score\";\n   public static final String FREQ_COMP = \"freq\";\n \n-  protected String field;\n-  protected String fieldTypeName;\n   protected org.apache.lucene.search.spell.SpellChecker spellChecker;\n \n   protected String sourceLocation;\n@@ -118,7 +115,6 @@ public String init(NamedList config, SolrCore core) {\n     } else {\n       comp = SuggestWordQueue.DEFAULT_COMPARATOR;\n     }\n-    field = (String) config.get(FIELD);\n     String strDistanceName = (String)config.get(STRING_DISTANCE);\n     if (strDistanceName != null) {\n       sd = (StringDistance) core.getResourceLoader().newInstance(strDistanceName);\n@@ -141,18 +137,6 @@ public String init(NamedList config, SolrCore core) {\n                 \"Unparseable accuracy given for dictionary: \" + name, e);\n       }\n     }\n-    if (field != null && core.getSchema().getFieldTypeNoEx(field) != null)  {\n-      analyzer = core.getSchema().getFieldType(field).getQueryAnalyzer();\n-    }\n-    fieldTypeName = (String) config.get(FIELD_TYPE);\n-    if (core.getSchema().getFieldTypes().containsKey(fieldTypeName))  {\n-      FieldType fieldType = core.getSchema().getFieldTypes().get(fieldTypeName);\n-      analyzer = fieldType.getQueryAnalyzer();\n-    }\n-    if (analyzer == null)   {\n-      log.info(\"Using WhitespaceAnalzyer for dictionary: \" + name);\n-      analyzer = new WhitespaceAnalyzer(core.getSolrConfig().luceneMatchVersion);\n-    }\n     return name;\n   }\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java",
                "sha": "032e29f51d7af93df54621769f9b1bd1681bc3eb",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker.java?ref=ea009a4785a1a2b04dfd9a190bea7a1cc68129f9",
                "deletions": 0,
                "filename": "solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker.java",
                "patch": "@@ -19,8 +19,10 @@\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.Token;\n import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.analysis.WhitespaceAnalyzer;\n import org.apache.solr.common.util.NamedList;\n import org.apache.solr.core.SolrCore;\n+import org.apache.solr.schema.FieldType;\n import org.apache.solr.search.SolrIndexSearcher;\n \n import java.io.IOException;\n@@ -38,15 +40,31 @@\n public abstract class SolrSpellChecker {\n   public static final String DICTIONARY_NAME = \"name\";\n   public static final String DEFAULT_DICTIONARY_NAME = \"default\";\n+  public static final String FIELD = \"field\";\n+  public static final String FIELD_TYPE = \"fieldType\";\n   /** Dictionary name */\n   protected String name;\n   protected Analyzer analyzer;\n+  protected String field;\n+  protected String fieldTypeName;\n \n   public String init(NamedList config, SolrCore core) {\n     name = (String) config.get(DICTIONARY_NAME);\n     if (name == null) {\n       name = DEFAULT_DICTIONARY_NAME;\n     }\n+    field = (String)config.get(FIELD);\n+    if (field != null && core.getSchema().getFieldTypeNoEx(field) != null)  {\n+      analyzer = core.getSchema().getFieldType(field).getQueryAnalyzer();\n+    }\n+    fieldTypeName = (String) config.get(FIELD_TYPE);\n+    if (core.getSchema().getFieldTypes().containsKey(fieldTypeName))  {\n+      FieldType fieldType = core.getSchema().getFieldTypes().get(fieldTypeName);\n+      analyzer = fieldType.getQueryAnalyzer();\n+    }\n+    if (analyzer == null)   {\n+      analyzer = new WhitespaceAnalyzer(core.getSolrConfig().luceneMatchVersion);\n+    }\n     return name;\n   }\n   ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker.java",
                "sha": "1b17e80400484f7936b16fece68c7b1fbb60ac50",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/java/org/apache/solr/spelling/suggest/Suggester.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/core/src/java/org/apache/solr/spelling/suggest/Suggester.java?ref=ea009a4785a1a2b04dfd9a190bea7a1cc68129f9",
                "deletions": 4,
                "filename": "solr/core/src/java/org/apache/solr/spelling/suggest/Suggester.java",
                "patch": "@@ -52,8 +52,6 @@\n    * current IndexReader.\n    */\n   public static final String LOCATION = \"sourceLocation\";\n-  /** Field to use as the source of terms if using IndexReader. */\n-  public static final String FIELD = \"field\";\n   /** Fully-qualified class of the {@link Lookup} implementation. */\n   public static final String LOOKUP_IMPL = \"lookupImpl\";\n   /**\n@@ -69,7 +67,6 @@\n   \n   protected String sourceLocation;\n   protected File storeDir;\n-  protected String field;\n   protected float threshold;\n   protected Dictionary dictionary;\n   protected IndexReader reader;\n@@ -84,7 +81,6 @@ public String init(NamedList config, SolrCore core) {\n     threshold = config.get(THRESHOLD_TOKEN_FREQUENCY) == null ? 0.0f\n             : (Float)config.get(THRESHOLD_TOKEN_FREQUENCY);\n     sourceLocation = (String) config.get(LOCATION);\n-    field = (String)config.get(FIELD);\n     lookupImpl = (String)config.get(LOOKUP_IMPL);\n \n     // support the old classnames without -Factory for config file backwards compatibility.",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/java/org/apache/solr/spelling/suggest/Suggester.java",
                "sha": "8db99160dd78abb868aa930257a7792857e8740d",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/test/org/apache/solr/spelling/suggest/SuggesterTest.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/solr/core/src/test/org/apache/solr/spelling/suggest/SuggesterTest.java?ref=ea009a4785a1a2b04dfd9a190bea7a1cc68129f9",
                "deletions": 0,
                "filename": "solr/core/src/test/org/apache/solr/spelling/suggest/SuggesterTest.java",
                "patch": "@@ -21,6 +21,7 @@\n \n import org.apache.solr.SolrTestCaseJ4;\n import org.apache.solr.common.params.SpellingParams;\n+import org.apache.solr.common.util.NamedList;\n import org.junit.BeforeClass;\n import org.junit.Test;\n \n@@ -95,4 +96,13 @@ public void testRebuild() throws Exception {\n     assertQ(req(\"qt\", requestUri, \"q\", \"ac\", SpellingParams.SPELLCHECK_COUNT, \"2\", SpellingParams.SPELLCHECK_ONLY_MORE_POPULAR, \"true\"),\n       \"//lst[@name='spellcheck']/lst[@name='suggestions']/lst[@name='ac']/int[@name='numFound'][.='2']\");\n   }\n+  \n+  // SOLR-2726\n+  public void testAnalyzer() throws Exception {\n+    Suggester suggester = new Suggester();\n+    NamedList params = new NamedList();\n+    params.add(\"lookupImpl\", \"org.apache.solr.spelling.suggest.tst.TSTLookupFactory\");\n+    suggester.init(params, h.getCore());\n+    assertTrue(suggester.getQueryAnalyzer() != null);\n+  }\n }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/ea009a4785a1a2b04dfd9a190bea7a1cc68129f9/solr/core/src/test/org/apache/solr/spelling/suggest/SuggesterTest.java",
                "sha": "600c598a745e87b73b6543a4bc86c671a64173d3",
                "status": "modified"
            }
        ],
        "message": "SOLR-2726: Fixed NullPointerException when using spellcheck.q with Suggester\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1171601 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/d15f51a23cd13f1cd211c81d1df3340bd5f4c87e",
        "patched_files": [
            "CHANGES.java",
            "SolrSpellChecker.java",
            "AbstractLuceneSpellChecker.java",
            "Suggester.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "SuggesterTest.java"
        ]
    },
    "manifoldcf-integration-solr-3.x_f647fb8": {
        "bug_id": "manifoldcf-integration-solr-3.x_f647fb8",
        "commit": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/f647fb810dcaafc1b06634dc588f0b3367c33739",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/f647fb810dcaafc1b06634dc588f0b3367c33739/lucene/contrib/CHANGES.txt",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/contrib/CHANGES.txt?ref=f647fb810dcaafc1b06634dc588f0b3367c33739",
                "deletions": 1,
                "filename": "lucene/contrib/CHANGES.txt",
                "patch": "@@ -2,7 +2,10 @@ Lucene contrib change Log\n \n ======================= Lucene 3.x (not yet released) =======================\n \n-(No changes)\n+Bug fixes\n+\n+ * LUCENE-3026: SmartChineseAnalyzer's WordTokenFilter threw NullPointerException\n+   on sentences longer than 32,767 characters.  (wangzhenghang via Robert Muir)\n \n ======================= Lucene 3.1.0 =======================\n ",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/f647fb810dcaafc1b06634dc588f0b3367c33739/lucene/contrib/CHANGES.txt",
                "sha": "8eead21b1dd1fa15b4ae29119a6879c094180556",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/f647fb810dcaafc1b06634dc588f0b3367c33739/lucene/contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java?ref=f647fb810dcaafc1b06634dc588f0b3367c33739",
                "deletions": 1,
                "filename": "lucene/contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java",
                "patch": "@@ -75,7 +75,7 @@ public int getMaxStart() {\n     List<SegToken> result = new ArrayList<SegToken>();\n     int s = -1, count = 0, size = tokenListTable.size();\n     List<SegToken> tokenList;\n-    short index = 0;\n+    int index = 0;\n     while (count < size) {\n       if (isStartExist(s)) {\n         tokenList = tokenListTable.get(s);",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/f647fb810dcaafc1b06634dc588f0b3367c33739/lucene/contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java",
                "sha": "f7b40d54c5ba2074615edfa1b553b517a960637d",
                "status": "modified"
            },
            {
                "additions": 29,
                "blob_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/blob/f647fb810dcaafc1b06634dc588f0b3367c33739/lucene/contrib/analyzers/smartcn/src/test/org/apache/lucene/analysis/cn/smart/TestSmartChineseAnalyzer.java",
                "changes": 29,
                "contents_url": "https://api.github.com/repos/apache/manifoldcf-integration-solr-3.x/contents/lucene/contrib/analyzers/smartcn/src/test/org/apache/lucene/analysis/cn/smart/TestSmartChineseAnalyzer.java?ref=f647fb810dcaafc1b06634dc588f0b3367c33739",
                "deletions": 0,
                "filename": "lucene/contrib/analyzers/smartcn/src/test/org/apache/lucene/analysis/cn/smart/TestSmartChineseAnalyzer.java",
                "patch": "@@ -17,8 +17,11 @@\n \n package org.apache.lucene.analysis.cn.smart;\n \n+import java.io.StringReader;\n+\n import org.apache.lucene.analysis.BaseTokenStreamTestCase;\n import org.apache.lucene.analysis.Analyzer;\n+import org.apache.lucene.analysis.TokenStream;\n import org.apache.lucene.util.Version;\n \n public class TestSmartChineseAnalyzer extends BaseTokenStreamTestCase {\n@@ -166,4 +169,30 @@ public void testReusableTokenStream() throws Exception {\n         new int[] { 0, 1, 3, 4, 6, 7 },\n         new int[] { 1, 3, 4, 6, 7, 9 });\n   }\n+  \n+  // LUCENE-3026\n+  public void testLargeDocument() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    for (int i = 0; i < 5000; i++) {\n+      sb.append(\"\u6211\u8d2d\u4e70\u4e86\u9053\u5177\u548c\u670d\u88c5\u3002\");\n+    }\n+    Analyzer analyzer = new SmartChineseAnalyzer(TEST_VERSION_CURRENT);\n+    TokenStream stream = analyzer.reusableTokenStream(\"\", new StringReader(sb.toString()));\n+    stream.reset();\n+    while (stream.incrementToken()) {\n+    }\n+  }\n+  \n+  // LUCENE-3026\n+  public void testLargeSentence() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    for (int i = 0; i < 5000; i++) {\n+      sb.append(\"\u6211\u8d2d\u4e70\u4e86\u9053\u5177\u548c\u670d\u88c5\");\n+    }\n+    Analyzer analyzer = new SmartChineseAnalyzer(TEST_VERSION_CURRENT);\n+    TokenStream stream = analyzer.reusableTokenStream(\"\", new StringReader(sb.toString()));\n+    stream.reset();\n+    while (stream.incrementToken()) {\n+    }\n+  }\n }",
                "raw_url": "https://github.com/apache/manifoldcf-integration-solr-3.x/raw/f647fb810dcaafc1b06634dc588f0b3367c33739/lucene/contrib/analyzers/smartcn/src/test/org/apache/lucene/analysis/cn/smart/TestSmartChineseAnalyzer.java",
                "sha": "6c61d45d27b2d38bd18ff3fcae010e86b993489b",
                "status": "modified"
            }
        ],
        "message": "LUCENE-3026: SmartChineseAnalyzer's WordTokenFilter threw NullPointerException on sentences longer than 32,767 characters\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_3x@1092338 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/manifoldcf-integration-solr-3.x/commit/b35a60cd17e2da68070922309b2f74ef02484885",
        "patched_files": [
            "CHANGES.java",
            "SegGraph.java"
        ],
        "repo": "manifoldcf-integration-solr-3.x",
        "unit_tests": [
            "TestSmartChineseAnalyzer.java"
        ]
    }
}