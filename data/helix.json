{
    "helix_06a9350": {
        "bug_id": "helix_06a9350",
        "commit": "https://github.com/apache/helix/commit/06a9350f2392a9dc845e54282a29eccc8267bdf5",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/helix/blob/06a9350f2392a9dc845e54282a29eccc8267bdf5/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java?ref=06a9350f2392a9dc845e54282a29eccc8267bdf5",
                "deletions": 2,
                "filename": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "patch": "@@ -151,8 +151,10 @@ public long getDisabledInstancesGauge() {\n     }\n \n     // TODO : Get rid of this after old API removed.\n-    for (String instance : _oldDisabledPartitions.keySet()) {\n-      numDisabled += _oldDisabledPartitions.get(instance).size();\n+    for (List<String> partitions : _oldDisabledPartitions.values()) {\n+      if (partitions != null) {\n+        numDisabled += partitions.size();\n+      }\n     }\n \n     return numDisabled;",
                "raw_url": "https://github.com/apache/helix/raw/06a9350f2392a9dc845e54282a29eccc8267bdf5/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "sha": "e91f503fc8ef795291262298393ffba3fda42f16",
                "status": "modified"
            }
        ],
        "message": "Fix NPE in clusterstatusmonitor.\n\nShould check _oldDisabledPartitions for preventing null values.",
        "parent": "https://github.com/apache/helix/commit/edaf78e279e87f74a08355103b2ef1b427ae0012",
        "repo": "helix",
        "unit_tests": [
            "TestClusterStatusMonitor.java"
        ]
    },
    "helix_10114cd": {
        "bug_id": "helix_10114cd",
        "commit": "https://github.com/apache/helix/commit/10114cd0a201344c58bd9b1e51311d69011c5198",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/helix/blob/10114cd0a201344c58bd9b1e51311d69011c5198/helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java?ref=10114cd0a201344c58bd9b1e51311d69011c5198",
                "deletions": 2,
                "filename": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java",
                "patch": "@@ -881,6 +881,8 @@ public void handleNewSession() throws Exception {\n       throw new HelixException(\"Cluster structure is not set up for cluster: \" + _clusterName);\n     }\n \n+    _sessionStartTime = System.currentTimeMillis();\n+\n     switch (_instanceType) {\n     case PARTICIPANT:\n       handleNewSessionAsParticipant();\n@@ -898,8 +900,6 @@ public void handleNewSession() throws Exception {\n       break;\n     }\n \n-    _sessionStartTime = System.currentTimeMillis();\n-\n     startTimerTasks();\n \n     /**",
                "raw_url": "https://github.com/apache/helix/raw/10114cd0a201344c58bd9b1e51311d69011c5198/helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java",
                "sha": "cded08603f8869b5142e68b5428f85fd0f25cf0d",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/helix/blob/10114cd0a201344c58bd9b1e51311d69011c5198/helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java?ref=10114cd0a201344c58bd9b1e51311d69011c5198",
                "deletions": 2,
                "filename": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java",
                "patch": "@@ -881,16 +881,16 @@ public MessageHandler createMessageHandler(Message message, NotificationContext\n     String msgType = message.getMsgType().toString();\n \n     MsgHandlerFactoryRegistryItem item = _hdlrFtyRegistry.get(msgType);\n-    MessageHandlerFactory handlerFactory = item.factory();\n \n     // Fail to find a MessageHandlerFactory for the message\n     // we will keep the message and the message will be handled when\n     // the corresponding MessageHandlerFactory is registered\n-    if (handlerFactory == null) {\n+    if (item == null) {\n       LOG.warn(\"Fail to find message handler factory for type: \" + msgType + \" msgId: \"\n           + message.getMsgId());\n       return null;\n     }\n+    MessageHandlerFactory handlerFactory = item.factory();\n \n     // pass the executor to msg-handler since batch-msg-handler needs task-executor to schedule\n     // sub-msgs",
                "raw_url": "https://github.com/apache/helix/raw/10114cd0a201344c58bd9b1e51311d69011c5198/helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java",
                "sha": "717bbcf63345bcc5ceb5865768235573821b29b3",
                "status": "modified"
            }
        ],
        "message": "Bug fix\n\n(1) HelixTaskExecutor checks whether MsgHandlerFactoryRegistryItem\nexists.\n(2) ZkHelixManager, onMessage callback might occur before\nsessionStartTime is set, which will cause NPE. Set the time first before\nregistering the message listener.",
        "parent": "https://github.com/apache/helix/commit/826d6c00832851124219f9d72da430e751e07300",
        "repo": "helix",
        "unit_tests": [
            "TestHelixTaskExecutor.java"
        ]
    },
    "helix_79301ad": {
        "bug_id": "helix_79301ad",
        "commit": "https://github.com/apache/helix/commit/79301ad19871b1acb179436277b7f34683872b9c",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/helix/blob/79301ad19871b1acb179436277b7f34683872b9c/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java?ref=79301ad19871b1acb179436277b7f34683872b9c",
                "deletions": 0,
                "filename": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java",
                "patch": "@@ -178,6 +178,9 @@ public void updateResource(ExternalView externalView, IdealState idealState, Sta\n       Map<String, String> idealRecord = idealState.getInstanceStateMap(partition);\n       Map<String, String> externalViewRecord = externalView.getStateMap(partition);\n \n+      if (idealRecord == null) {\n+        idealRecord = Collections.emptyMap();\n+      }\n       if (externalViewRecord == null) {\n         externalViewRecord = Collections.emptyMap();\n       }",
                "raw_url": "https://github.com/apache/helix/raw/79301ad19871b1acb179436277b7f34683872b9c/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java",
                "sha": "41c73ed71f50ac069f65961a2ab7f3a1d5227878",
                "status": "modified"
            }
        ],
        "message": "Adding check to avoid possible NPE when recording resource status.",
        "parent": "https://github.com/apache/helix/commit/8b7632ecec3e447bef5201bc1218e1dea2d45938",
        "repo": "helix",
        "unit_tests": [
            "TestResourceMonitor.java"
        ]
    },
    "helix_895cd9c": {
        "bug_id": "helix_895cd9c",
        "commit": "https://github.com/apache/helix/commit/895cd9c14f071a62af59a7cc4d2627455a9eb9d1",
        "file": [
            {
                "additions": 228,
                "blob_url": "https://github.com/apache/helix/blob/895cd9c14f071a62af59a7cc4d2627455a9eb9d1/cluster-manager-core/src/main/java/com/linkedin/clustermanager/tools/ClusterSetup.java",
                "changes": 488,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/cluster-manager-core/src/main/java/com/linkedin/clustermanager/tools/ClusterSetup.java?ref=895cd9c14f071a62af59a7cc4d2627455a9eb9d1",
                "deletions": 260,
                "filename": "cluster-manager-core/src/main/java/com/linkedin/clustermanager/tools/ClusterSetup.java",
                "patch": "@@ -12,7 +12,6 @@\n import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Option;\n import org.apache.commons.cli.OptionBuilder;\n-import org.apache.commons.cli.OptionGroup;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n import org.apache.log4j.Logger;\n@@ -33,42 +32,35 @@\n \n public class ClusterSetup\n {\n-  private static Logger logger = Logger.getLogger(ClusterSetup.class);\n-  public static final String zkServerAddress = \"zkSvr\";\n+  private static Logger      logger                = Logger.getLogger(ClusterSetup.class);\n+  public static final String zkServerAddress       = \"zkSvr\";\n \n   // List info about the cluster / DB/ Instances\n-  public static final String listClusters = \"listClusters\";\n-  public static final String listResourceGroups = \"listResourceGroups\";\n-  public static final String listInstances = \"listInstances\";\n+  public static final String listClusters          = \"listClusters\";\n+  public static final String listResourceGroups    = \"listResourceGroups\";\n+  public static final String listInstances         = \"listInstances\";\n \n   // Add and rebalance\n-  public static final String addCluster = \"addCluster\";\n-  public static final String addInstance = \"addNode\";\n-  public static final String addResourceGroup = \"addResourceGroup\";\n-  public static final String addStateModelDef = \"addStateModelDef\";\n-  public static final String addIdealState = \"addIdealState\";\n-  public static final String rebalance = \"rebalance\";\n+  public static final String addCluster            = \"addCluster\";\n+  public static final String addInstance           = \"addNode\";\n+  public static final String addResourceGroup      = \"addResourceGroup\";\n+  public static final String addStateModelDef      = \"addStateModelDef\";\n+  public static final String addIdealState         = \"addIdealState\";\n+  public static final String rebalance             = \"rebalance\";\n \n   // Query info (TBD in V2)\n-  public static final String listClusterInfo = \"listClusterInfo\";\n-  public static final String listInstanceInfo = \"listInstanceInfo\";\n+  public static final String listClusterInfo       = \"listClusterInfo\";\n+  public static final String listInstanceInfo      = \"listInstanceInfo\";\n   public static final String listResourceGroupInfo = \"listResourceGroupInfo\";\n-  public static final String listResourceInfo = \"listResourceInfo\";\n-  public static final String listStateModels = \"listStateModels\";\n-  public static final String listStateModel = \"listStateModel\";\n-  \n-\n-  // TODO: refactor\n-  // setup for file-based cluster manager\n-  // public static final String configFile = \"configFile\";\n+  public static final String listResourceInfo      = \"listResourceInfo\";\n+  public static final String listStateModels       = \"listStateModels\";\n+  public static final String listStateModel        = \"listStateModel\";\n \n   // enable / disable Instances\n-  public static final String enableInstance = \"enableInstance\";\n-\n-  public static final String help = \"help\";\n-\n-  static Logger _logger = Logger.getLogger(ClusterSetup.class);\n-  String _zkServerAddress;\n+  public static final String enableInstance        = \"enableInstance\";\n+  public static final String help                  = \"help\";\n+  static Logger              _logger               = Logger.getLogger(ClusterSetup.class);\n+  String                     _zkServerAddress;\n \n   public ClusterSetup(String zkServerAddress)\n   {\n@@ -78,23 +70,21 @@ public ClusterSetup(String zkServerAddress)\n   public void addCluster(String clusterName, boolean overwritePrevious)\n   {\n     ClusterManagementService managementTool = getClusterManagementTool();\n-    \n+\n     managementTool.addCluster(clusterName, overwritePrevious);\n     StateModelConfigGenerator generator = new StateModelConfigGenerator();\n-    addStateModelDef(clusterName, \"MasterSlave\",\n-        generator.generateConfigForMasterSlave());\n-    \n-    addStateModelDef(clusterName, \"LeaderStandby\",\n-        generator.generateConfigForLeaderStandby());\n-    \n-    addStateModelDef(clusterName, \"StorageSchemata\",\n-        generator.generateConfigForStorageSchemata());\n-    \n-    addStateModelDef(clusterName, \"OnlineOffline\",\n-        generator.generateConfigForOnlineOffline());\n+    addStateModelDef(clusterName, \"MasterSlave\", generator.generateConfigForMasterSlave());\n+\n+    addStateModelDef(clusterName, \"LeaderStandby\", generator.generateConfigForLeaderStandby());\n+\n+    addStateModelDef(clusterName, \"StorageSchemata\", generator.generateConfigForStorageSchemata());\n+\n+    addStateModelDef(clusterName, \"OnlineOffline\", generator.generateConfigForOnlineOffline());\n   }\n-  \n-  public void addCluster(String clusterName, boolean overwritePrevious, String stateModDefName, \n+\n+  public void addCluster(String clusterName,\n+                         boolean overwritePrevious,\n+                         String stateModDefName,\n                          ZNRecord stateModDef)\n   {\n     ClusterManagementService managementTool = getClusterManagementTool();\n@@ -138,10 +128,8 @@ public void addInstanceToCluster(String clusterName, String host, int port)\n     String InstanceId = host + \"_\" + port;\n     InstanceConfig.setId(InstanceId);\n     InstanceConfig.setSimpleField(InstanceConfigProperty.HOST.toString(), host);\n-    InstanceConfig\n-        .setSimpleField(InstanceConfigProperty.PORT.toString(), \"\" + port);\n-    InstanceConfig.setSimpleField(InstanceConfigProperty.ENABLED.toString(),\n-        true + \"\");\n+    InstanceConfig.setSimpleField(InstanceConfigProperty.PORT.toString(), \"\" + port);\n+    InstanceConfig.setSimpleField(InstanceConfigProperty.ENABLED.toString(), true + \"\");\n \n     managementTool.addInstance(clusterName, InstanceConfig);\n   }\n@@ -152,119 +140,124 @@ public ClusterManagementService getClusterManagementTool()\n     return new ZKClusterManagementTool(zkClient);\n   }\n \n-  public void addStateModelDef(String clusterName, String stateModelDef,\n-      ZNRecord record)\n+  public void addStateModelDef(String clusterName, String stateModelDef, ZNRecord record)\n   {\n     ClusterManagementService managementTool = getClusterManagementTool();\n     managementTool.addStateModelDef(clusterName, stateModelDef, record);\n   }\n \n   public void addResourceGroupToCluster(String clusterName,\n-      String resourceGroup, int numResources, String stateModelRef)\n+                                        String resourceGroup,\n+                                        int numResources,\n+                                        String stateModelRef)\n   {\n-    /*\n-    ClusterManagementService managementTool = getClusterManagementTool();\n-    managementTool.addResourceGroup(clusterName, resourceGroup, numResources,\n-        stateModelRef);\n-    */\n-    addResourceGroupToCluster(clusterName, resourceGroup, numResources, stateModelRef, \n+    addResourceGroupToCluster(clusterName,\n+                              resourceGroup,\n+                              numResources,\n+                              stateModelRef,\n                               IdealStateConfigProperty.AUTO.toString());\n   }\n-  \n+\n   public void addResourceGroupToCluster(String clusterName,\n-      String resourceGroup, int numResources, String stateModelRef, String idealStateMode)\n+                                        String resourceGroup,\n+                                        int numResources,\n+                                        String stateModelRef,\n+                                        String idealStateMode)\n   {\n     if (!idealStateMode.equalsIgnoreCase(IdealStateConfigProperty.CUSTOMIZED.toString()))\n     {\n       logger.info(\"ideal state mode is configured to auto mode\");\n       idealStateMode = IdealStateConfigProperty.AUTO.toString();\n     }\n     ClusterManagementService managementTool = getClusterManagementTool();\n-    managementTool.addResourceGroup(clusterName, resourceGroup, numResources,\n-        stateModelRef, idealStateMode);\n+    managementTool.addResourceGroup(clusterName,\n+                                    resourceGroup,\n+                                    numResources,\n+                                    stateModelRef,\n+                                    idealStateMode);\n   }\n-  \n-  public void dropResourceGroupToCluster(String clusterName,\n-      String resourceGroup)\n+\n+  public void dropResourceGroupToCluster(String clusterName, String resourceGroup)\n   {\n     ClusterManagementService managementTool = getClusterManagementTool();\n     managementTool.dropResourceGroup(clusterName, resourceGroup);\n   }\n \n-  public void rebalanceStorageCluster(String clusterName,\n-      String resourceGroupName, int replica)\n+  public void rebalanceStorageCluster(String clusterName, String resourceGroupName, int replica)\n   {\n-    replica --;\n+    replica--;\n     ClusterManagementService managementTool = getClusterManagementTool();\n     List<String> InstanceNames = managementTool.getInstancesInCluster(clusterName);\n \n-    ZNRecord dbIdealState = managementTool.getResourceGroupIdealState(\n-        clusterName, resourceGroupName);\n-    int partitions = Integer\n-        .parseInt(dbIdealState.getSimpleField(\"partitions\"));\n+    ZNRecord dbIdealState =\n+        managementTool.getResourceGroupIdealState(clusterName, resourceGroupName);\n+    int partitions = Integer.parseInt(dbIdealState.getSimpleField(\"partitions\"));\n \n     ZkClient zkClient = ZKClientPool.getZkClient(_zkServerAddress);\n     String idealStatePath = CMUtil.getIdealStatePath(clusterName, resourceGroupName);\n-    ZNRecord idealState = zkClient.<ZNRecord>readData(idealStatePath);\n+    ZNRecord idealState = zkClient.<ZNRecord> readData(idealStatePath);\n     String stateModelName = idealState.getSimpleField(\"state_model_def_ref\");\n     ZNRecord stateModDef = managementTool.getStateModelDef(clusterName, stateModelName);\n- \n+\n     if (stateModDef == null)\n     {\n       throw new ClusterManagerException(\"cannot find state model \" + stateModelName);\n     }\n     StateModelDefinition def = new StateModelDefinition(stateModDef);\n-    \n+\n     List<String> statePriorityList = def.getStatesPriorityList();\n-    \n+\n     String masterStateValue = null;\n     String slaveStateValue = null;\n-    \n-    for(String state : statePriorityList)\n+\n+    for (String state : statePriorityList)\n     {\n       String count = def.getNumInstancesPerState(state);\n-      if(count.equals(\"1\"))\n+      if (count.equals(\"1\"))\n       {\n-        if(masterStateValue != null)\n+        if (masterStateValue != null)\n         {\n           throw new ClusterManagerException(\"Invalid or unsupported state model definition\");\n         }\n         masterStateValue = state;\n       }\n-      else if(count.equalsIgnoreCase(\"R\"))\n+      else if (count.equalsIgnoreCase(\"R\"))\n       {\n-        if(slaveStateValue != null)\n+        if (slaveStateValue != null)\n         {\n           throw new ClusterManagerException(\"Invalid or unsupported state model definition\");\n         }\n         slaveStateValue = state;\n       }\n-      else if(count.equalsIgnoreCase(\"N\"))\n+      else if (count.equalsIgnoreCase(\"N\"))\n       {\n-        if(!(masterStateValue == null && slaveStateValue == null))\n+        if (!(masterStateValue == null && slaveStateValue == null))\n         {\n           throw new ClusterManagerException(\"Invalid or unsupported state model definition\");\n         }\n         replica = InstanceNames.size() - 1;\n         masterStateValue = slaveStateValue = state;\n       }\n     }\n-    if(masterStateValue == null && slaveStateValue == null)\n+    if (masterStateValue == null && slaveStateValue == null)\n     {\n       throw new ClusterManagerException(\"Invalid or unsupported state model definition\");\n     }\n-    \n-    if(masterStateValue == null)\n+\n+    if (masterStateValue == null)\n     {\n       masterStateValue = slaveStateValue;\n     }\n-    \n-    idealState = IdealStateCalculatorForStorageNode\n-        .calculateIdealState(InstanceNames, partitions, replica, resourceGroupName,\n-                             masterStateValue, slaveStateValue);\n+\n+    idealState =\n+        IdealStateCalculatorForStorageNode.calculateIdealState(InstanceNames,\n+                                                               partitions,\n+                                                               replica,\n+                                                               resourceGroupName,\n+                                                               masterStateValue,\n+                                                               slaveStateValue);\n     idealState.setSimpleFields(dbIdealState.getSimpleFields());\n-    managementTool.setResourceGroupIdealState(clusterName, resourceGroupName,\n-        idealState);\n+    managementTool.setResourceGroupIdealState(clusterName, resourceGroupName, idealState);\n   }\n \n   /**\n@@ -295,131 +288,145 @@ public static void printUsage(Options cliOptions)\n   @SuppressWarnings(\"static-access\")\n   private static Options constructCommandLineOptions()\n   {\n-    Option helpOption = OptionBuilder.withLongOpt(help)\n-        .withDescription(\"Prints command-line options info\").create();\n-\n-    Option zkServerOption = OptionBuilder.withLongOpt(zkServerAddress)\n-        .withDescription(\"Provide zookeeper address\").create();\n+    Option helpOption =\n+        OptionBuilder.withLongOpt(help)\n+                     .withDescription(\"Prints command-line options info\")\n+                     .create();\n+\n+    Option zkServerOption =\n+        OptionBuilder.withLongOpt(zkServerAddress)\n+                     .withDescription(\"Provide zookeeper address\")\n+                     .create();\n     zkServerOption.setArgs(1);\n     zkServerOption.setRequired(true);\n     zkServerOption.setArgName(\"ZookeeperServerAddress(Required)\");\n \n-    Option listClustersOption = OptionBuilder.withLongOpt(listClusters)\n-        .withDescription(\"List existing clusters\").create();\n+    Option listClustersOption =\n+        OptionBuilder.withLongOpt(listClusters).withDescription(\"List existing clusters\").create();\n     listClustersOption.setArgs(0);\n     listClustersOption.setRequired(false);\n \n-    Option listResourceGroupOption = OptionBuilder\n-        .withLongOpt(listResourceGroups)\n-        .withDescription(\"List resourceGroups hosted in a cluster\").create();\n+    Option listResourceGroupOption =\n+        OptionBuilder.withLongOpt(listResourceGroups)\n+                     .withDescription(\"List resourceGroups hosted in a cluster\")\n+                     .create();\n     listResourceGroupOption.setArgs(1);\n     listResourceGroupOption.setRequired(false);\n     listResourceGroupOption.setArgName(\"clusterName\");\n \n-    Option listInstancesOption = OptionBuilder.withLongOpt(listInstances)\n-        .withDescription(\"List Instances in a cluster\").create();\n+    Option listInstancesOption =\n+        OptionBuilder.withLongOpt(listInstances)\n+                     .withDescription(\"List Instances in a cluster\")\n+                     .create();\n     listInstancesOption.setArgs(1);\n     listInstancesOption.setRequired(false);\n     listInstancesOption.setArgName(\"clusterName\");\n \n-    Option addClusterOption = OptionBuilder.withLongOpt(addCluster)\n-        .withDescription(\"Add a new cluster\").create();\n+    Option addClusterOption =\n+        OptionBuilder.withLongOpt(addCluster).withDescription(\"Add a new cluster\").create();\n     addClusterOption.setArgs(1);\n     addClusterOption.setRequired(false);\n     addClusterOption.setArgName(\"clusterName\");\n \n-    Option addInstanceOption = OptionBuilder.withLongOpt(addInstance)\n-        .withDescription(\"Add a new Instance to a cluster\").create();\n+    Option addInstanceOption =\n+        OptionBuilder.withLongOpt(addInstance)\n+                     .withDescription(\"Add a new Instance to a cluster\")\n+                     .create();\n     addInstanceOption.setArgs(2);\n     addInstanceOption.setRequired(false);\n     addInstanceOption.setArgName(\"clusterName InstanceAddress(host:port)\");\n \n-    Option addResourceGroupOption = OptionBuilder.withLongOpt(addResourceGroup)\n-        .withDescription(\"Add a resourceGroup to a cluster\").create();\n+    Option addResourceGroupOption =\n+        OptionBuilder.withLongOpt(addResourceGroup)\n+                     .withDescription(\"Add a resourceGroup to a cluster\")\n+                     .create();\n     addResourceGroupOption.setArgs(4);\n     addResourceGroupOption.setRequired(false);\n-    addResourceGroupOption\n-        .setArgName(\"clusterName resourceGroupName partitionNo stateModelRef\");\n+    addResourceGroupOption.setArgName(\"clusterName resourceGroupName partitionNo stateModelRef\");\n \n-    Option addStateModelDefOption = OptionBuilder\n-        .withLongOpt(addStateModelDef)\n-        .withDescription(\"Add a State model to a cluster\").create();\n+    Option addStateModelDefOption =\n+        OptionBuilder.withLongOpt(addStateModelDef)\n+                     .withDescription(\"Add a State model to a cluster\")\n+                     .create();\n     addStateModelDefOption.setArgs(2);\n     addStateModelDefOption.setRequired(false);\n     addStateModelDefOption.setArgName(\"clusterName <filename>\");\n-    \n-    Option addIdealStateOption = OptionBuilder\n-        .withLongOpt(addIdealState)\n-        .withDescription(\"Add a State model to a cluster\").create();\n+\n+    Option addIdealStateOption =\n+        OptionBuilder.withLongOpt(addIdealState)\n+                     .withDescription(\"Add a State model to a cluster\")\n+                     .create();\n     addIdealStateOption.setArgs(3);\n     addIdealStateOption.setRequired(false);\n     addIdealStateOption.setArgName(\"clusterName reourceGroupName <filename>\");\n \n-    Option rebalanceOption = OptionBuilder.withLongOpt(rebalance)\n-        .withDescription(\"Rebalance a resourceGroup in a cluster\").create();\n+    Option rebalanceOption =\n+        OptionBuilder.withLongOpt(rebalance)\n+                     .withDescription(\"Rebalance a resourceGroup in a cluster\")\n+                     .create();\n     rebalanceOption.setArgs(3);\n     rebalanceOption.setRequired(false);\n     rebalanceOption.setArgName(\"clusterName resourceGroupName replicationNo\");\n \n-    Option InstanceInfoOption = OptionBuilder.withLongOpt(listInstanceInfo)\n-        .withDescription(\"Query info of a Instance in a cluster\").create();\n+    Option InstanceInfoOption =\n+        OptionBuilder.withLongOpt(listInstanceInfo)\n+                     .withDescription(\"Query info of a Instance in a cluster\")\n+                     .create();\n     InstanceInfoOption.setArgs(2);\n     InstanceInfoOption.setRequired(false);\n     InstanceInfoOption.setArgName(\"clusterName InstanceName\");\n \n-    Option clusterInfoOption = OptionBuilder.withLongOpt(listClusterInfo)\n-        .withDescription(\"Query info of a cluster\").create();\n+    Option clusterInfoOption =\n+        OptionBuilder.withLongOpt(listClusterInfo)\n+                     .withDescription(\"Query info of a cluster\")\n+                     .create();\n     clusterInfoOption.setArgs(1);\n     clusterInfoOption.setRequired(false);\n     clusterInfoOption.setArgName(\"clusterName\");\n \n-    Option resourceGroupInfoOption = OptionBuilder\n-        .withLongOpt(listResourceGroupInfo)\n-        .withDescription(\"Query info of a resourceGroup\").create();\n+    Option resourceGroupInfoOption =\n+        OptionBuilder.withLongOpt(listResourceGroupInfo)\n+                     .withDescription(\"Query info of a resourceGroup\")\n+                     .create();\n     resourceGroupInfoOption.setArgs(2);\n     resourceGroupInfoOption.setRequired(false);\n     resourceGroupInfoOption.setArgName(\"clusterName resourceGroupName\");\n \n-    Option partitionInfoOption = OptionBuilder.withLongOpt(listResourceInfo)\n-        .withDescription(\"Query info of a partition\").create();\n+    Option partitionInfoOption =\n+        OptionBuilder.withLongOpt(listResourceInfo)\n+                     .withDescription(\"Query info of a partition\")\n+                     .create();\n     partitionInfoOption.setArgs(2);\n     partitionInfoOption.setRequired(false);\n     partitionInfoOption.setArgName(\"clusterName partitionName\");\n \n-    Option enableInstanceOption = OptionBuilder.withLongOpt(enableInstance)\n-        .withDescription(\"Enable / disable a Instance\").create();\n+    Option enableInstanceOption =\n+        OptionBuilder.withLongOpt(enableInstance)\n+                     .withDescription(\"Enable / disable a Instance\")\n+                     .create();\n     enableInstanceOption.setArgs(3);\n     enableInstanceOption.setRequired(false);\n     enableInstanceOption.setArgName(\"clusterName InstanceName true/false\");\n-    \n-    Option listStateModelsOption = OptionBuilder.withLongOpt(listStateModels)\n-      .withDescription(\"Query info of state models in a cluster\").create();\n+\n+    Option listStateModelsOption =\n+        OptionBuilder.withLongOpt(listStateModels)\n+                     .withDescription(\"Query info of state models in a cluster\")\n+                     .create();\n     listStateModelsOption.setArgs(1);\n     listStateModelsOption.setRequired(false);\n     listStateModelsOption.setArgName(\"clusterName\");\n \n-    Option listStateModelOption = OptionBuilder.withLongOpt(listStateModel)\n-      .withDescription(\"Query info of a state model in a cluster\").create();\n+    Option listStateModelOption =\n+        OptionBuilder.withLongOpt(listStateModel)\n+                     .withDescription(\"Query info of a state model in a cluster\")\n+                     .create();\n     listStateModelOption.setArgs(2);\n     listStateModelOption.setRequired(false);\n     listStateModelOption.setArgName(\"clusterName stateModelName\");\n \n-\n-    // add an option group including either --zkSvr or --configFile\n-    /**\n-    Option fileOption = OptionBuilder.withLongOpt(configFile)\n-        .withDescription(\"Provide file to write states/messages\").create();\n-    fileOption.setArgs(1);\n-    fileOption.setRequired(true);\n-    fileOption.setArgName(\"File to write states/messages (Optional)\");\n-     **/\n-    OptionGroup optionGroup = new OptionGroup();\n-    optionGroup.addOption(zkServerOption);\n-    // optionGroup.addOption(fileOption);\n-\n     Options options = new Options();\n     options.addOption(helpOption);\n-    // options.addOption(zkServerOption);\n+    options.addOption(zkServerOption);\n     options.addOption(rebalanceOption);\n     options.addOption(addResourceGroupOption);\n     options.addOption(addClusterOption);\n@@ -438,26 +445,25 @@ private static Options constructCommandLineOptions()\n     options.addOption(listStateModelsOption);\n     options.addOption(listStateModelOption);\n \n-    options.addOptionGroup(optionGroup);\n-\n     return options;\n   }\n+\n   private static byte[] readFile(String filePath) throws IOException\n   {\n-    File file = new File(filePath); \n+    File file = new File(filePath);\n \n-    int size = (int)file.length(); \n-    byte[] bytes = new byte[size]; \n-    DataInputStream dis = new DataInputStream(new FileInputStream(file)); \n+    int size = (int) file.length();\n+    byte[] bytes = new byte[size];\n+    DataInputStream dis = new DataInputStream(new FileInputStream(file));\n     int read = 0;\n     int numRead = 0;\n-    while (read < bytes.length && \n-        (numRead = dis.read(bytes, read, bytes.length-read)) >= 0) \n+    while (read < bytes.length && (numRead = dis.read(bytes, read, bytes.length - read)) >= 0)\n     {\n       read = read + numRead;\n     }\n     return bytes;\n   }\n+\n   public static int processCommandLineArgs(String[] cliArgs) throws Exception\n   {\n     CommandLineParser cliParser = new GnuParser();\n@@ -467,54 +473,16 @@ public static int processCommandLineArgs(String[] cliArgs) throws Exception\n     try\n     {\n       cmd = cliParser.parse(cliOptions, cliArgs);\n-    } catch (ParseException pe)\n+    }\n+    catch (ParseException pe)\n     {\n-      System.err\n-          .println(\"CommandLineClient: failed to parse command-line options: \"\n-              + pe.toString());\n+      System.err.println(\"CommandLineClient: failed to parse command-line options: \"\n+          + pe.toString());\n       printUsage(cliOptions);\n       System.exit(1);\n     }\n \n-    /**\n-    if (cmd.hasOption(configFile))\n-    {\n-      String file = cmd.getOptionValue(configFile);\n-\n-      // for temporary test only, will move to command line\n-      // create fake db names\n-      List<FileBasedClusterManager.DBParam> dbParams = new ArrayList<FileBasedClusterManager.DBParam>();\n-      dbParams.add(new FileBasedClusterManager.DBParam(\"BizFollow\", 1));\n-      dbParams.add(new FileBasedClusterManager.DBParam(\"BizProfile\", 1));\n-      dbParams.add(new FileBasedClusterManager.DBParam(\"EspressoDB\", 10));\n-      dbParams.add(new FileBasedClusterManager.DBParam(\"MailboxDB\", 128));\n-      dbParams.add(new FileBasedClusterManager.DBParam(\"MyDB\", 8));\n-      dbParams.add(new FileBasedClusterManager.DBParam(\"schemata\", 1));\n-      String[] InstancesInfo =\n-      { \"localhost:8900\" };\n-\n-      // ClusterViewSerializer serializer = new ClusterViewSerializer(file);\n-      int replica = 0;\n-      ClusterView view = FileBasedClusterManager\n-          .generateStaticConfigClusterView(InstancesInfo, dbParams, replica);\n-\n-      // byte[] bytes;\n-      ClusterViewSerializer.serialize(view, new File(file));\n-      // System.out.println(new String(bytes));\n-\n-      ClusterView restoredView = ClusterViewSerializer.deserialize(new File(\n-          file));\n-      // System.out.println(restoredView);\n-\n-      byte[] bytes = ClusterViewSerializer.serialize(restoredView);\n-      // System.out.println(new String(bytes));\n-\n-      return 0;\n-    }\n-    **/\n-    \n-    ClusterSetup setupTool = new ClusterSetup(\n-        cmd.getOptionValue(zkServerAddress));\n+    ClusterSetup setupTool = new ClusterSetup(cmd.getOptionValue(zkServerAddress));\n \n     if (cmd.hasOption(addCluster))\n     {\n@@ -536,11 +504,9 @@ public static int processCommandLineArgs(String[] cliArgs) throws Exception\n     {\n       String clusterName = cmd.getOptionValues(addResourceGroup)[0];\n       String resourceGroupName = cmd.getOptionValues(addResourceGroup)[1];\n-      int partitions = Integer\n-          .parseInt(cmd.getOptionValues(addResourceGroup)[2]);\n+      int partitions = Integer.parseInt(cmd.getOptionValues(addResourceGroup)[2]);\n       String stateModelRef = cmd.getOptionValues(addResourceGroup)[3];\n-      setupTool.addResourceGroupToCluster(clusterName, resourceGroupName,\n-          partitions, stateModelRef);\n+      setupTool.addResourceGroupToCluster(clusterName, resourceGroupName, partitions, stateModelRef);\n       return 0;\n     }\n \n@@ -549,15 +515,13 @@ public static int processCommandLineArgs(String[] cliArgs) throws Exception\n       String clusterName = cmd.getOptionValues(rebalance)[0];\n       String resourceGroupName = cmd.getOptionValues(rebalance)[1];\n       int replicas = Integer.parseInt(cmd.getOptionValues(rebalance)[2]);\n-      setupTool.rebalanceStorageCluster(clusterName, resourceGroupName,\n-          replicas);\n+      setupTool.rebalanceStorageCluster(clusterName, resourceGroupName, replicas);\n       return 0;\n     }\n \n     if (cmd.hasOption(listClusters))\n     {\n-      List<String> clusters = setupTool.getClusterManagementTool()\n-          .getClusters();\n+      List<String> clusters = setupTool.getClusterManagementTool().getClusters();\n \n       System.out.println(\"Existing clusters:\");\n       for (String cluster : clusters)\n@@ -570,30 +534,30 @@ public static int processCommandLineArgs(String[] cliArgs) throws Exception\n     if (cmd.hasOption(listResourceGroups))\n     {\n       String clusterName = cmd.getOptionValue(listResourceGroups);\n-      List<String> resourceGroupNames = setupTool.getClusterManagementTool()\n-          .getResourceGroupsInCluster(clusterName);\n+      List<String> resourceGroupNames =\n+          setupTool.getClusterManagementTool().getResourceGroupsInCluster(clusterName);\n \n       System.out.println(\"Existing resources in cluster \" + clusterName + \":\");\n       for (String resourceGroupName : resourceGroupNames)\n       {\n         System.out.println(resourceGroupName);\n       }\n       return 0;\n-    } \n-    else if(cmd.hasOption(listClusterInfo))\n+    }\n+    else if (cmd.hasOption(listClusterInfo))\n     {\n       String clusterName = cmd.getOptionValue(listClusterInfo);\n-      List<String> resourceGroupNames = setupTool.getClusterManagementTool()\n-          .getResourceGroupsInCluster(clusterName);\n-      List<String> Instances = setupTool.getClusterManagementTool()\n-        .getInstancesInCluster(clusterName);\n-      \n+      List<String> resourceGroupNames =\n+          setupTool.getClusterManagementTool().getResourceGroupsInCluster(clusterName);\n+      List<String> Instances =\n+          setupTool.getClusterManagementTool().getInstancesInCluster(clusterName);\n+\n       System.out.println(\"Existing resources in cluster \" + clusterName + \":\");\n       for (String resourceGroupName : resourceGroupNames)\n       {\n         System.out.println(resourceGroupName);\n       }\n-      \n+\n       System.out.println(\"Instances in cluster \" + clusterName + \":\");\n       for (String InstanceName : Instances)\n       {\n@@ -604,8 +568,8 @@ else if(cmd.hasOption(listClusterInfo))\n     else if (cmd.hasOption(listInstances))\n     {\n       String clusterName = cmd.getOptionValue(listInstances);\n-      List<String> Instances = setupTool.getClusterManagementTool()\n-          .getInstancesInCluster(clusterName);\n+      List<String> Instances =\n+          setupTool.getClusterManagementTool().getInstancesInCluster(clusterName);\n \n       System.out.println(\"Instances in cluster \" + clusterName + \":\");\n       for (String InstanceName : Instances)\n@@ -618,53 +582,54 @@ else if (cmd.hasOption(listInstanceInfo))\n     {\n       String clusterName = cmd.getOptionValues(listInstanceInfo)[0];\n       String instanceName = cmd.getOptionValues(listInstanceInfo)[1];\n-      ZNRecord record = setupTool.getClusterManagementTool().getInstanceConfig(clusterName, instanceName);\n-      \n+      ZNRecord record =\n+          setupTool.getClusterManagementTool().getInstanceConfig(clusterName, instanceName);\n+\n       String result = new String(new ZNRecordSerializer().serialize(record));\n       System.out.println(result);\n       return 0;\n-      \n-      // print out current states and\n-    } \n+    }\n     else if (cmd.hasOption(listResourceGroupInfo))\n     {\n       // print out partition number, db name and replication number\n       // Also the ideal states and current states\n       String clusterName = cmd.getOptionValues(listResourceGroupInfo)[0];\n       String resourceGroupName = cmd.getOptionValues(listResourceGroupInfo)[1];\n-      ZNRecord idealState = setupTool.getClusterManagementTool().getResourceGroupIdealState(clusterName, resourceGroupName);\n-      ZNRecord externalView = setupTool.getClusterManagementTool().getResourceGroupExternalView(clusterName, resourceGroupName);\n-      \n-      System.out.println(\"IdealState for \"+resourceGroupName+\":\");\n+      ZNRecord idealState =\n+          setupTool.getClusterManagementTool().getResourceGroupIdealState(clusterName,\n+                                                                          resourceGroupName);\n+      ZNRecord externalView =\n+          setupTool.getClusterManagementTool().getResourceGroupExternalView(clusterName,\n+                                                                            resourceGroupName);\n+\n+      System.out.println(\"IdealState for \" + resourceGroupName + \":\");\n       System.out.println(new String(new ZNRecordSerializer().serialize(idealState)));\n-      \n+\n       System.out.println();\n-      System.out.println(\"External view for \"+resourceGroupName+\":\");\n+      System.out.println(\"External view for \" + resourceGroupName + \":\");\n       System.out.println(new String(new ZNRecordSerializer().serialize(externalView)));\n       return 0;\n-      \n-    } \n+\n+    }\n     else if (cmd.hasOption(listResourceInfo))\n     {\n       // print out where the partition master / slaves locates\n-    } \n+    }\n     else if (cmd.hasOption(enableInstance))\n     {\n       String clusterName = cmd.getOptionValues(enableInstance)[0];\n       String instanceName = cmd.getOptionValues(enableInstance)[1];\n-      boolean enabled = Boolean.parseBoolean(cmd.getOptionValues(enableInstance)[1]\n-          .toLowerCase());\n+      boolean enabled = Boolean.parseBoolean(cmd.getOptionValues(enableInstance)[1].toLowerCase());\n \n-      setupTool.getClusterManagementTool().enableInstance(clusterName,\n-          instanceName, enabled);\n+      setupTool.getClusterManagementTool().enableInstance(clusterName, instanceName, enabled);\n       return 0;\n-    } \n-    else if(cmd.hasOption(listStateModels))\n+    }\n+    else if (cmd.hasOption(listStateModels))\n     {\n       String clusterName = cmd.getOptionValues(listStateModels)[0];\n-      \n-      List<String> stateModels =  setupTool.getClusterManagementTool()\n-      .getStateModelDefs(clusterName);\n+\n+      List<String> stateModels =\n+          setupTool.getClusterManagementTool().getStateModelDefs(clusterName);\n \n       System.out.println(\"Existing state models:\");\n       for (String stateModel : stateModels)\n@@ -677,36 +642,43 @@ else if (cmd.hasOption(listStateModel))\n     {\n       String clusterName = cmd.getOptionValues(listStateModel)[0];\n       String stateModel = cmd.getOptionValues(listStateModel)[1];\n-      ZNRecord record = setupTool.getClusterManagementTool().getStateModelDef(clusterName, stateModel);\n+      ZNRecord record =\n+          setupTool.getClusterManagementTool().getStateModelDef(clusterName, stateModel);\n       String result = new String(new ZNRecordSerializer().serialize(record));\n       System.out.println(result);\n       return 0;\n     }\n-    else if(cmd.hasOption(addStateModelDef))\n+    else if (cmd.hasOption(addStateModelDef))\n     {\n       String clusterName = cmd.getOptionValues(addStateModelDef)[0];\n       String stateModelFile = cmd.getOptionValues(addStateModelDef)[1];\n-      \n-      ZNRecord stateModelRecord = (ZNRecord)(new ZNRecordSerializer().deserialize(readFile(stateModelFile)));\n-      if(stateModelRecord.getId() == null || stateModelRecord.getId().length() == 0)\n+\n+      ZNRecord stateModelRecord =\n+          (ZNRecord) (new ZNRecordSerializer().deserialize(readFile(stateModelFile)));\n+      if (stateModelRecord.getId() == null || stateModelRecord.getId().length() == 0)\n       {\n         throw new IllegalArgumentException(\"ZNRecord for state model definition must have an id\");\n       }\n-      setupTool.getClusterManagementTool().addStateModelDef(clusterName, stateModelRecord.getId(), stateModelRecord);\n+      setupTool.getClusterManagementTool().addStateModelDef(clusterName,\n+                                                            stateModelRecord.getId(),\n+                                                            stateModelRecord);\n       return 0;\n     }\n-    else if(cmd.hasOption(addIdealState))\n+    else if (cmd.hasOption(addIdealState))\n     {\n       String clusterName = cmd.getOptionValues(addIdealState)[0];\n       String resourceGroupName = cmd.getOptionValues(addIdealState)[1];\n       String idealStateFile = cmd.getOptionValues(addIdealState)[2];\n-      \n-      ZNRecord idealStateRecord = (ZNRecord)(new ZNRecordSerializer().deserialize(readFile(idealStateFile)));\n-      if(idealStateRecord.getId() == null || !idealStateRecord.getId().equals(resourceGroupName))\n+\n+      ZNRecord idealStateRecord =\n+          (ZNRecord) (new ZNRecordSerializer().deserialize(readFile(idealStateFile)));\n+      if (idealStateRecord.getId() == null || !idealStateRecord.getId().equals(resourceGroupName))\n       {\n         throw new IllegalArgumentException(\"ideal state must have same id as resourceGroup name\");\n       }\n-      setupTool.getClusterManagementTool().setResourceGroupIdealState(clusterName, resourceGroupName, idealStateRecord);\n+      setupTool.getClusterManagementTool().setResourceGroupIdealState(clusterName,\n+                                                                      resourceGroupName,\n+                                                                      idealStateRecord);\n       return 0;\n     }\n     else if (cmd.hasOption(help))\n@@ -725,14 +697,10 @@ else if (cmd.hasOption(help))\n    */\n   public static void main(String[] args) throws Exception\n   {\n-    // For temporary test only, remove later\n-    // Logger.getRootLogger().setLevel(Level.ERROR);\n     if (args.length == 0)\n     {\n-      new ClusterSetup(\"localhost:2181\")\n-          .setupTestCluster(\"storage-integration-cluster\");\n-      new ClusterSetup(\"localhost:2181\")\n-          .setupTestCluster(\"relay-integration-cluster\");\n+      new ClusterSetup(\"localhost:2181\").setupTestCluster(\"storage-integration-cluster\");\n+      new ClusterSetup(\"localhost:2181\").setupTestCluster(\"relay-integration-cluster\");\n       System.exit(0);\n     }\n ",
                "raw_url": "https://github.com/apache/helix/raw/895cd9c14f071a62af59a7cc4d2627455a9eb9d1/cluster-manager-core/src/main/java/com/linkedin/clustermanager/tools/ClusterSetup.java",
                "sha": "5d56a3eebbb2cca27e50ed595353fd18df15d397",
                "status": "modified"
            }
        ],
        "message": "fix NPE in ClusterSetup.main()",
        "parent": "https://github.com/apache/helix/commit/49cb4ff8e08ef02b84378365cf4230c33371a3a7",
        "repo": "helix",
        "unit_tests": [
            "TestClusterSetup.java"
        ]
    },
    "helix_90ef589": {
        "bug_id": "helix_90ef589",
        "commit": "https://github.com/apache/helix/commit/90ef589aa47ef1726356ce5ea37e12d27372b342",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/helix/blob/90ef589aa47ef1726356ce5ea37e12d27372b342/helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java?ref=90ef589aa47ef1726356ce5ea37e12d27372b342",
                "deletions": 11,
                "filename": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java",
                "patch": "@@ -464,23 +464,18 @@ boolean containsState(String state) {\n   private static Comparator<InstanceConfig> INSTANCE_CONFIG_COMPARATOR =\n       new Comparator<InstanceConfig>() {\n         @Override\n-        public int compare(InstanceConfig o1, InstanceConfig o2) {\n-          if (o1 == o2) {\n+        public int compare(InstanceConfig config1, InstanceConfig config2) {\n+          if (config1 == config2) {\n             return 0;\n           }\n-          if (o1 == null) {\n+          if (config1 == null) {\n             return -1;\n           }\n-          if (o2 == null) {\n+          if (config2 == null) {\n             return 1;\n           }\n-\n-          int compareTo = o1.getHostName().compareTo(o2.getHostName());\n-          if (compareTo == 0) {\n-            return o1.getPort().compareTo(o2.getPort());\n-          }\n-\n-          return compareTo;\n+          // IDs for InstanceConfigs are a concatenation of instance name, host, and port.\n+          return config1.getId().compareTo(config2.getId());\n         }\n       };\n }",
                "raw_url": "https://github.com/apache/helix/raw/90ef589aa47ef1726356ce5ea37e12d27372b342/helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java",
                "sha": "46cf4711a48c0fff5ef26ab66218eee134db8d04",
                "status": "modified"
            }
        ],
        "message": "[HELIX-699] Compare InstanceConfigs using their IDs in RoutingTable\n\nA possible race condition was causing a NPE on InstanceConfig.getHostName(). Instead of comparing hostnames and ports, we compare IDs, which are supposed to be concatenation of instance name, hostname, and port anyways and should always be set.",
        "parent": "https://github.com/apache/helix/commit/0e4163f18c1274c0f77320698e9dfbf42314810d",
        "repo": "helix",
        "unit_tests": [
            "TestRoutingTable.java"
        ]
    },
    "helix_959966e": {
        "bug_id": "helix_959966e",
        "commit": "https://github.com/apache/helix/commit/959966effa11f7cce0e054b6189c5e97130ae039",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/helix/blob/959966effa11f7cce0e054b6189c5e97130ae039/helix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java?ref=959966effa11f7cce0e054b6189c5e97130ae039",
                "deletions": 1,
                "filename": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java",
                "patch": "@@ -185,7 +185,9 @@ public void close() throws ZkInterruptedException {\n       }\n     } finally {\n       getEventLock().unlock();\n-      _monitor.unregister();\n+      if (_monitor != null) {\n+        _monitor.unregister();\n+      }\n       LOG.info(\"Closed zkclient\");\n     }\n   }",
                "raw_url": "https://github.com/apache/helix/raw/959966effa11f7cce0e054b6189c5e97130ae039/helix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java",
                "sha": "aa1a0738cc3415f53719043b81209c97d6402c55",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/helix/blob/959966effa11f7cce0e054b6189c5e97130ae039/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ZkClientMonitor.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ZkClientMonitor.java?ref=959966effa11f7cce0e054b6189c5e97130ae039",
                "deletions": 4,
                "filename": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ZkClientMonitor.java",
                "patch": "@@ -22,6 +22,7 @@\n import java.lang.management.ManagementFactory;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n import javax.management.JMException;\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n@@ -62,10 +63,10 @@ public boolean match(String path) {\n   private long _writeCounter;\n   private long _readBytesCounter;\n   private long _writeBytesCounter;\n-  private Map<PredefinedPath, Long> _readCounterMap = new HashMap<PredefinedPath, Long>();\n-  private Map<PredefinedPath, Long> _writeCounterMap = new HashMap<PredefinedPath, Long>();\n-  private Map<PredefinedPath, Long> _readBytesCounterMap = new HashMap<PredefinedPath, Long>();\n-  private Map<PredefinedPath, Long> _writBytesCounterMap = new HashMap<PredefinedPath, Long>();\n+  private Map<PredefinedPath, Long> _readCounterMap = new ConcurrentHashMap<>();\n+  private Map<PredefinedPath, Long> _writeCounterMap = new ConcurrentHashMap<>();\n+  private Map<PredefinedPath, Long> _readBytesCounterMap = new ConcurrentHashMap<>();\n+  private Map<PredefinedPath, Long> _writBytesCounterMap = new ConcurrentHashMap<>();\n \n   public ZkClientMonitor(String tag) throws JMException {\n     tag = tag == null ? DEFAULT_TAG : tag;",
                "raw_url": "https://github.com/apache/helix/raw/959966effa11f7cce0e054b6189c5e97130ae039/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ZkClientMonitor.java",
                "sha": "5811d7ec316fc62a23c17649d7b8f2bdca761d21",
                "status": "modified"
            }
        ],
        "message": "Fix ZkClientMonitor bugs\n\nNPE check and thread-safe map for counter maps.",
        "parent": "https://github.com/apache/helix/commit/3768fc11cfe3be87131ce1743ea335e578c3d55e",
        "repo": "helix",
        "unit_tests": [
            "TestZkClientMonitor.java"
        ]
    },
    "helix_b429d48": {
        "bug_id": "helix_b429d48",
        "commit": "https://github.com/apache/helix/commit/b429d4815f5314bdb0c67ca7ed31d17270a4b878",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/helix/blob/b429d4815f5314bdb0c67ca7ed31d17270a4b878/helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java?ref=b429d4815f5314bdb0c67ca7ed31d17270a4b878",
                "deletions": 13,
                "filename": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java",
                "patch": "@@ -250,6 +250,13 @@ private boolean computeResourceBestPossibleState(ClusterEvent event, ResourceCon\n         // The next release will support rebalancers that compute the mapping from start to finish\n         partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n+\n+        if (partitionStateAssignment == null) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+          return false;\n+        }\n+\n         for (Partition partition : resource.getPartitions()) {\n           Map<String, String> newStateMap = partitionStateAssignment.getReplicaMap(partition);\n           output.setState(resourceName, partition, newStateMap);\n@@ -263,19 +270,6 @@ private boolean computeResourceBestPossibleState(ClusterEvent event, ResourceCon\n       } catch (Exception e) {\n         LogUtil.logError(logger, _eventId,\n             \"Error computing assignment for resource \" + resourceName + \". Skipping.\");\n-        // TODO : remove this part after debugging NPE\n-        StringBuilder sb = new StringBuilder();\n-\n-        sb.append(String\n-            .format(\"HelixManager is null : %s\\n\", event.getAttribute(\"helixmanager\") == null));\n-        sb.append(String.format(\"Rebalancer is null : %s\\n\", rebalancer == null));\n-        sb.append(String.format(\"Calculated idealState is null : %s\\n\", idealState == null));\n-        sb.append(String.format(\"MappingCaculator is null : %s\\n\", mappingCalculator == null));\n-        sb.append(\n-            String.format(\"PartitionAssignment is null : %s\\n\", partitionStateAssignment == null));\n-        sb.append(String.format(\"Output is null : %s\\n\", output == null));\n-\n-        LogUtil.logError(logger, _eventId, sb.toString());\n       }\n     }\n     // Exception or rebalancer is not found",
                "raw_url": "https://github.com/apache/helix/raw/b429d4815f5314bdb0c67ca7ed31d17270a4b878/helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java",
                "sha": "85a4add52dfe2edec42c03c3d36e083873ce3993",
                "status": "modified"
            }
        ],
        "message": "Remove TODO NPE log for computeResourceBestPossibleState\n\nThe logs related to NPE in computeResourceBestPossibleState is not needed anymore.\n\nThis commit fixes issue #351.",
        "parent": "https://github.com/apache/helix/commit/c9300968690024765fe9d66ca1ac248720cd0af8",
        "repo": "helix",
        "unit_tests": [
            "TestBestPossibleStateCalcStage.java"
        ]
    },
    "helix_c0bef9a": {
        "bug_id": "helix_c0bef9a",
        "commit": "https://github.com/apache/helix/commit/c0bef9a1c734f2396e9dc31c53dd047bbfd5dd61",
        "file": [
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/helix/blob/c0bef9a1c734f2396e9dc31c53dd047bbfd5dd61/helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java",
                "changes": 27,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java?ref=c0bef9a1c734f2396e9dc31c53dd047bbfd5dd61",
                "deletions": 13,
                "filename": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java",
                "patch": "@@ -271,8 +271,9 @@ public boolean getInstanceEnabledForPartition(String resource, String partition)\n   public List<String> getDisabledPartitions() {\n     List<String> oldDisabled =\n         _record.getListField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name());\n-    if (!_record.getMapFields().containsKey(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name())\n-        && oldDisabled == null) {\n+    Map<String, String> newDisabledMap =\n+        _record.getMapField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name());\n+    if (newDisabledMap == null && oldDisabled == null) {\n       return null;\n     }\n \n@@ -281,11 +282,11 @@ public boolean getInstanceEnabledForPartition(String resource, String partition)\n       disabledPartitions.addAll(oldDisabled);\n     }\n \n-    for (String perResource : _record\n-        .getMapField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name()).values()) {\n-      disabledPartitions.addAll(HelixUtil.deserializeByComma(perResource));\n+    if (newDisabledMap != null) {\n+      for (String perResource : newDisabledMap.values()) {\n+        disabledPartitions.addAll(HelixUtil.deserializeByComma(perResource));\n+      }\n     }\n-\n     return new ArrayList<String>(disabledPartitions);\n   }\n \n@@ -298,9 +299,10 @@ public boolean getInstanceEnabledForPartition(String resource, String partition)\n     // TODO: Remove this logic getting data from list field when getDisabledParition() removed.\n     List<String> oldDisabled =\n         _record.getListField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name());\n-    if ((!_record.getMapFields().containsKey(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name())\n-        || !_record.getMapField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name())\n-        .containsKey(resourceName)) && oldDisabled == null) {\n+    Map<String, String> newDisabledMap =\n+        _record.getMapField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name());\n+    if ((newDisabledMap == null || !newDisabledMap.containsKey(resourceName))\n+        && oldDisabled == null) {\n       return null;\n     }\n \n@@ -309,10 +311,9 @@ public boolean getInstanceEnabledForPartition(String resource, String partition)\n       disabledPartitions.addAll(oldDisabled);\n     }\n \n-    disabledPartitions.addAll(HelixUtil.deserializeByComma(\n-        _record.getMapField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.name())\n-            .get(resourceName)));\n-\n+    if (newDisabledMap != null) {\n+      disabledPartitions.addAll(HelixUtil.deserializeByComma(newDisabledMap.get(resourceName)));\n+    }\n     return new ArrayList<String>(disabledPartitions);\n   }\n ",
                "raw_url": "https://github.com/apache/helix/raw/c0bef9a1c734f2396e9dc31c53dd047bbfd5dd61/helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java",
                "sha": "0d540596080362f6b584fee4918094e877f4ba0b",
                "status": "modified"
            }
        ],
        "message": "Fix NPE for get disabled partitions",
        "parent": "https://github.com/apache/helix/commit/04281faf0302fa7cfdbe81ec86325c043627489f",
        "repo": "helix",
        "unit_tests": [
            "TestInstanceConfig.java"
        ]
    },
    "helix_d9ac96e": {
        "bug_id": "helix_d9ac96e",
        "commit": "https://github.com/apache/helix/commit/d9ac96eb842d2025168bce5a87268c5bc5bd3a77",
        "file": [
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/helix/blob/d9ac96eb842d2025168bce5a87268c5bc5bd3a77/helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java?ref=d9ac96eb842d2025168bce5a87268c5bc5bd3a77",
                "deletions": 0,
                "filename": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java",
                "patch": "@@ -132,6 +132,8 @@ MessageHandlerFactory factory() {\n   // timer for schedule timeout tasks\n   final Timer _timer;\n \n+  private boolean _isShuttingDown;\n+\n   public HelixTaskExecutor() {\n     this(new ParticipantStatusMonitor(false, null));\n   }\n@@ -157,6 +159,8 @@ public HelixTaskExecutor(ParticipantStatusMonitor participantStatusMonitor) {\n \n     _timer = new Timer(true); // created as a daemon timer thread to handle task timeout\n \n+    _isShuttingDown = false;\n+\n     startMonitorThread();\n   }\n \n@@ -173,6 +177,8 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n           + factory.getMessageTypes());\n     }\n \n+    _isShuttingDown = false;\n+\n     MsgHandlerFactoryRegistryItem newItem =\n         new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n     MsgHandlerFactoryRegistryItem prevItem = _hdlrFtyRegistry.putIfAbsent(type, newItem);\n@@ -386,6 +392,13 @@ public boolean scheduleTask(MessageTask task) {\n         if (!_taskMap.containsKey(taskId)) {\n           ExecutorService exeSvc = findExecutorServiceForMsg(message);\n \n+          if (exeSvc == null) {\n+            LOG.warn(String\n+                .format(\"Threadpool is null for type %s of message %s\", message.getMsgType(),\n+                    message.getMsgId()));\n+            return false;\n+          }\n+\n           LOG.info(\"Submit task: \" + taskId + \" to pool: \" + exeSvc);\n           Future<HelixTaskResult> future = exeSvc.submit(task);\n \n@@ -586,6 +599,8 @@ void init() {\n       _messageQueueMonitor.init();\n     }\n \n+    _isShuttingDown = false;\n+\n     // Re-init all existing factories\n     for (String msgType : _hdlrFtyRegistry.keySet()) {\n       MsgHandlerFactoryRegistryItem item = _hdlrFtyRegistry.get(msgType);\n@@ -649,6 +664,16 @@ public void onMessage(String instanceName, List<Message> messages,\n       // continue to process messages\n     }\n \n+    if (_isShuttingDown) {\n+      StringBuilder sb = new StringBuilder();\n+      for (Message message : messages) {\n+        sb.append(message.getMsgId() + \",\");\n+      }\n+      LOG.info(\n+          \"Helix task executor is shutting down, discard unprocessed messages : \" + sb.toString());\n+      return;\n+    }\n+\n     if (messages == null || messages.size() == 0) {\n       LOG.info(\"No Messages to process\");\n       return;\n@@ -953,6 +978,7 @@ private void removeMessageFromZk(HelixDataAccessor accessor, Message message,\n   @Override\n   public void shutdown() {\n     LOG.info(\"Shutting down HelixTaskExecutor\");\n+    _isShuttingDown = true;\n     _timer.cancel();\n \n     reset();",
                "raw_url": "https://github.com/apache/helix/raw/d9ac96eb842d2025168bce5a87268c5bc5bd3a77/helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java",
                "sha": "ad4a2767687a5a1634879c706cd4c5d6e767464e",
                "status": "modified"
            }
        ],
        "message": "Fix NPEs for HelixTask Executors\n\nHelixTaskExecutors has some NPEs when participant disconnects from ZK. Fix those NPEs by protective checks and shut downs signals.\nx",
        "parent": "https://github.com/apache/helix/commit/9178f035569db3288590ae505c2b692aaf27700a",
        "repo": "helix",
        "unit_tests": [
            "TestHelixTaskExecutor.java"
        ]
    },
    "helix_dca1ed0": {
        "bug_id": "helix_dca1ed0",
        "commit": "https://github.com/apache/helix/commit/dca1ed05bfccce69814fdb59b095d734d1c82de0",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/helix/blob/dca1ed05bfccce69814fdb59b095d734d1c82de0/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java?ref=dca1ed05bfccce69814fdb59b095d734d1c82de0",
                "deletions": 0,
                "filename": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "patch": "@@ -463,6 +463,11 @@ public void updateJobCounters(JobConfig jobConfig, TaskState to) {\n   }\n \n   private void updateJobGauges(JobConfig jobConfig, TaskState current) {\n+    // When first time for WorkflowRebalancer call, jobconfig may not ready.\n+    // Thus only check it for gauge.\n+    if (jobConfig == null) {\n+      return;\n+    }\n     String jobType = jobConfig.getJobType();\n     jobType = preProcessJobMonitor(jobType);\n     _perTypeJobMonitorMap.get(jobType).updateJobGauge(current);",
                "raw_url": "https://github.com/apache/helix/raw/dca1ed05bfccce69814fdb59b095d734d1c82de0/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "sha": "7f996c5a2896276675fb2be68ee1afc41bfe7fcb",
                "status": "modified"
            }
        ],
        "message": "Fix NPE when first time call WorkflowRebalancer",
        "parent": "https://github.com/apache/helix/commit/f5705dc9201716543c72427c004f1f64211e304e",
        "repo": "helix",
        "unit_tests": [
            "TestClusterStatusMonitor.java"
        ]
    },
    "helix_fe5062f": {
        "bug_id": "helix_fe5062f",
        "commit": "https://github.com/apache/helix/commit/fe5062f5d7f230c41524d0d0ac66a955f4c3661f",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/helix/blob/fe5062f5d7f230c41524d0d0ac66a955f4c3661f/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/helix/contents/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java?ref=fe5062f5d7f230c41524d0d0ac66a955f4c3661f",
                "deletions": 0,
                "filename": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "patch": "@@ -493,6 +493,11 @@ public void updateJobCounters(JobConfig jobConfig, TaskState to) {\n   }\n \n   private void updateJobGauges(JobConfig jobConfig, TaskState current) {\n+    // When first time for WorkflowRebalancer call, jobconfig may not ready.\n+    // Thus only check it for gauge.\n+    if (jobConfig == null) {\n+      return;\n+    }\n     String jobType = jobConfig.getJobType();\n     jobType = preProcessJobMonitor(jobType);\n     _perTypeJobMonitorMap.get(jobType).updateJobGauge(current);",
                "raw_url": "https://github.com/apache/helix/raw/fe5062f5d7f230c41524d0d0ac66a955f4c3661f/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java",
                "sha": "95ee43f2ad84e999f8c2b17bbf4c0f1f98e44cd5",
                "status": "modified"
            }
        ],
        "message": "Fix NPE when first time call WorkflowRebalancer",
        "parent": "https://github.com/apache/helix/commit/f117e24522b0da3dc983f27faa3a427b156124a2",
        "repo": "helix",
        "unit_tests": [
            "TestClusterStatusMonitor.java"
        ]
    }
}