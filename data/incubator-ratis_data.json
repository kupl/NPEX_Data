[{"commit": "https://github.com/apache/incubator-ratis/commit/f36acabc58d6ed0146a9998150b5d7a038bdda7d", "parent": "https://github.com/apache/incubator-ratis/commit/d11320db65ce26b40994959c8a72c8f69556ad81", "message": "RATIS-717. NPE thrown on the follower while instantiating RaftLeaderMetrics. Contributed by Aravindan Vijayan.", "bug_id": "incubator-ratis_1", "file": [{"additions": 9, "raw_url": "https://github.com/apache/incubator-ratis/raw/f36acabc58d6ed0146a9998150b5d7a038bdda7d/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftLeaderMetrics.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/f36acabc58d6ed0146a9998150b5d7a038bdda7d/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftLeaderMetrics.java", "sha": "245aa3928b00d274f7697a4452f8fbaee6f95f7b", "changes": 11, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftLeaderMetrics.java?ref=f36acabc58d6ed0146a9998150b5d7a038bdda7d", "patch": "@@ -26,7 +26,9 @@\n import java.util.SortedMap;\n \n import com.codahale.metrics.Gauge;\n+\n import org.apache.ratis.metrics.RatisMetricRegistry;\n+import org.apache.ratis.proto.RaftProtos;\n import org.apache.ratis.protocol.RaftPeer;\n import org.apache.ratis.server.metrics.RatisMetrics;\n import org.apache.ratis.thirdparty.com.google.common.annotations.VisibleForTesting;\n@@ -82,8 +84,13 @@ public void addFollower(RaftPeer peer) {\n   public void addPeerCommitIndexGauge(RaftPeer peer) {\n     String followerCommitIndexKey = String.format(\n         LEADER_METRIC_PEER_COMMIT_INDEX, peer.getId().toString());\n-    registry.gauge(followerCommitIndexKey,\n-        () -> () -> commitInfoCache.get(peer.getId()).getCommitIndex());\n+    registry.gauge(followerCommitIndexKey, () -> () -> {\n+      RaftProtos.CommitInfoProto commitInfoProto = commitInfoCache.get(peer.getId());\n+      if (commitInfoProto != null) {\n+        return commitInfoProto.getCommitIndex();\n+      }\n+      return 0L;\n+    });\n   }\n \n   /**", "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/RaftLeaderMetrics.java"}], "repo": "incubator-ratis"}, {"commit": "https://github.com/apache/incubator-ratis/commit/008c0093fed0cfd7e53b7d455621e1ec794d6f38", "parent": "https://github.com/apache/incubator-ratis/commit/300d9c53c4b77e16ddd5d68dcf6c792d52a94a02", "message": "RATIS-577. NPE in LogAppender while creating a new request.", "bug_id": "incubator-ratis_2", "file": [{"additions": 5, "raw_url": "https://github.com/apache/incubator-ratis/raw/008c0093fed0cfd7e53b7d455621e1ec794d6f38/ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/008c0093fed0cfd7e53b7d455621e1ec794d6f38/ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java", "sha": "1586ecb79ed219959d9a87f1cb38d8a793676103", "changes": 7, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java?ref=008c0093fed0cfd7e53b7d455621e1ec794d6f38", "patch": "@@ -178,8 +178,8 @@ private void loadLogSegments(long lastIndexInSnapshot,\n   @Override\n   public LogEntryProto get(long index) throws RaftLogIOException {\n     checkLogState();\n-    LogSegment segment;\n-    LogRecordWithEntry recordAndEntry;\n+    final LogSegment segment;\n+    final LogRecordWithEntry recordAndEntry;\n     try (AutoCloseableLock readLock = readLock()) {\n       segment = cache.getSegment(index);\n       if (segment == null) {\n@@ -203,6 +203,9 @@ public LogEntryProto get(long index) throws RaftLogIOException {\n   @Override\n   public EntryWithData getEntryWithData(long index) throws RaftLogIOException {\n     final LogEntryProto entry = get(index);\n+    if (entry == null) {\n+      throw new RaftLogIOException(\"Log entry not found: index = \" + index);\n+    }\n     if (!ServerProtoUtils.shouldReadStateMachineData(entry)) {\n       return new EntryWithData(entry, null);\n     }", "filename": "ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java"}], "repo": "incubator-ratis"}, {"commit": "https://github.com/apache/incubator-ratis/commit/bbfb8754d136a5404e8c2a813a7468d94165d80c", "parent": "https://github.com/apache/incubator-ratis/commit/f6814c6b46a54a787983a4245121ee35a9cad0b8", "message": "RATIS-336. LeaderState.isBootStrappingPeer may have NPE.", "bug_id": "incubator-ratis_3", "file": [{"additions": 1, "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java", "sha": "d62b1a7b28609f407884d4f89276527c697ea7a3", "changes": 2, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c", "patch": "@@ -170,7 +170,7 @@ private void askForVotes() throws InterruptedException, IOException {\n           case DISCOVERED_A_NEW_TERM:\n             final long term = r.term > server.getState().getCurrentTerm() ?\n                 r.term : server.getState().getCurrentTerm();\n-            server.changeToFollower(term, true);\n+            server.changeToFollowerAndPersistMetadata(term);\n             return;\n           case TIMEOUT:\n             // should start another election", "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java"}, {"additions": 106, "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java", "sha": "b4b613e745c5a43e6e35fac6669be4d484e3719f", "changes": 173, "status": "modified", "deletions": 67, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c", "patch": "@@ -40,8 +40,6 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n-import static org.apache.ratis.server.impl.LeaderState.StateUpdateEventType.*;\n-\n /**\n  * States for leader only. It contains three different types of processors:\n  * 1. RPC senders: each thread is appending log to a follower\n@@ -54,21 +52,76 @@\n   private static final Logger LOG = RaftServerImpl.LOG;\n   public static final String APPEND_PLACEHOLDER = LeaderState.class.getSimpleName() + \".placeholder\";\n \n-  enum StateUpdateEventType {\n-    STEPDOWN, UPDATECOMMIT, STAGINGPROGRESS\n-  }\n-\n-  enum BootStrapProgress {\n+  private enum BootStrapProgress {\n     NOPROGRESS, PROGRESSING, CAUGHTUP\n   }\n \n   static class StateUpdateEvent {\n-    final StateUpdateEventType type;\n+    private enum Type {\n+      STEP_DOWN, UPDATE_COMMIT, CHECK_STAGING\n+    }\n+\n+    final Type type;\n     final long newTerm;\n+    final Runnable handler;\n \n-    StateUpdateEvent(StateUpdateEventType type, long newTerm) {\n+    StateUpdateEvent(Type type, long newTerm, Runnable handler) {\n       this.type = type;\n       this.newTerm = newTerm;\n+      this.handler = handler;\n+    }\n+\n+    void execute() {\n+      handler.run();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (obj == this) {\n+        return true;\n+      } else if (!(obj instanceof StateUpdateEvent)) {\n+        return false;\n+      }\n+      final StateUpdateEvent that = (StateUpdateEvent)obj;\n+      return this.type == that.type && this.newTerm == that.newTerm;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return type + (newTerm >= 0? \":\" + newTerm: \"\");\n+    }\n+  }\n+\n+  private class EventQueue {\n+    private final BlockingQueue<StateUpdateEvent> queue = new ArrayBlockingQueue<>(4096);\n+\n+    void submit(StateUpdateEvent event) {\n+      try {\n+        queue.put(event);\n+      } catch (InterruptedException e) {\n+        LOG.info(\"{}: Interrupted when submitting {} \", server.getId(), event);\n+      }\n+    }\n+\n+    StateUpdateEvent poll() {\n+      final StateUpdateEvent e;\n+      try {\n+        e = queue.poll(server.getMaxTimeoutMs(), TimeUnit.MILLISECONDS);\n+      } catch(InterruptedException ie) {\n+        String s = server.getId() + \": \" + getClass().getSimpleName() + \" thread is interrupted\";\n+        if (!running) {\n+          LOG.info(s + \" gracefully\");\n+          return null;\n+        } else {\n+          throw new IllegalStateException(s + \" UNEXPECTEDLY\", ie);\n+        }\n+      }\n+\n+      if (e != null) {\n+        // remove duplicated events from the head.\n+        for(; e.equals(queue.peek()); queue.poll());\n+      }\n+      return e;\n     }\n   }\n \n@@ -101,10 +154,10 @@ boolean removeAll(Collection<LogAppender> c) {\n     }\n   }\n \n-  static final StateUpdateEvent UPDATE_COMMIT_EVENT =\n-      new StateUpdateEvent(StateUpdateEventType.UPDATECOMMIT, -1);\n-  static final StateUpdateEvent STAGING_PROGRESS_EVENT =\n-      new StateUpdateEvent(StateUpdateEventType.STAGINGPROGRESS, -1);\n+  private final StateUpdateEvent UPDATE_COMMIT_EVENT =\n+      new StateUpdateEvent(StateUpdateEvent.Type.UPDATE_COMMIT, -1, this::updateCommit);\n+  private final StateUpdateEvent CHECK_STAGING_EVENT =\n+      new StateUpdateEvent(StateUpdateEvent.Type.CHECK_STAGING, -1, this::checkStaging);\n \n   private final RaftServerImpl server;\n   private final RaftLog raftLog;\n@@ -117,7 +170,7 @@ boolean removeAll(Collection<LogAppender> c) {\n    * The list is protected by the RaftServer's lock.\n    */\n   private final SenderList senders;\n-  private final BlockingQueue<StateUpdateEvent> eventQ;\n+  private final EventQueue eventQueue = new EventQueue();\n   private final EventProcessor processor;\n   private final PendingRequests pendingRequests;\n   private volatile boolean running = true;\n@@ -135,7 +188,6 @@ boolean removeAll(Collection<LogAppender> c) {\n     final ServerState state = server.getState();\n     this.raftLog = state.getLog();\n     this.currentTerm = state.getCurrentTerm();\n-    eventQ = new ArrayBlockingQueue<>(4096);\n     processor = new EventProcessor();\n     pendingRequests = new PendingRequests(server);\n \n@@ -192,10 +244,6 @@ boolean inStagingState() {\n     return stagingState != null;\n   }\n \n-  ConfigurationStagingState getStagingState() {\n-    return stagingState;\n-  }\n-\n   long getCurrentTerm() {\n     return currentTerm;\n   }\n@@ -299,11 +347,25 @@ private void updateSenders(RaftConfiguration conf) {\n     stopAndRemoveSenders(s -> !conf.containsInConf(s.getFollower().getPeer().getId()));\n   }\n \n-  void submitUpdateStateEvent(StateUpdateEvent event) {\n+  void submitStepDownEvent() {\n+    submitStepDownEvent(getCurrentTerm());\n+  }\n+\n+  void submitStepDownEvent(long term) {\n+    eventQueue.submit(new StateUpdateEvent(StateUpdateEvent.Type.STEP_DOWN, term, () -> stepDown(term)));\n+  }\n+\n+  private void stepDown(long term) {\n     try {\n-      eventQ.put(event);\n-    } catch (InterruptedException e) {\n-      LOG.info(\"Interrupted when adding event {} into the queue\", event);\n+      server.changeToFollowerAndPersistMetadata(term);\n+    } catch(IOException e) {\n+      final String s = server.getId() + \": Failed to persist metadata for term \" + term;\n+      LOG.warn(s, e);\n+      // the failure should happen while changing the state to follower\n+      // thus the in-memory state should have been updated\n+      if (running) {\n+        throw new IllegalStateException(s + \" and running == true\", e);\n+      }\n     }\n   }\n \n@@ -331,50 +393,20 @@ public void run() {\n       prepare();\n \n       while (running) {\n-        try {\n-          StateUpdateEvent event = eventQ.poll(server.getMaxTimeoutMs(),\n-              TimeUnit.MILLISECONDS);\n-          synchronized (server) {\n-            if (running) {\n-              handleEvent(event);\n+        final StateUpdateEvent event = eventQueue.poll();\n+        synchronized(server) {\n+          if (running) {\n+            if (event != null) {\n+              event.execute();\n+            } else if (inStagingState()) {\n+              checkStaging();\n             }\n           }\n-          // the updated configuration does not need to be sync'ed here\n-        } catch (InterruptedException e) {\n-          final String s = server.getId() + \" \" + getClass().getSimpleName()\n-              + \" thread is interrupted \";\n-          if (!running) {\n-            LOG.info(s + \" gracefully; server=\" + server);\n-          } else {\n-            LOG.warn(s + \" UNEXPECTEDLY; server=\" + server, e);\n-            throw new RuntimeException(e);\n-          }\n-        } catch (IOException e) {\n-          LOG.warn(\"Failed to persist new votedFor/term.\", e);\n-          // the failure should happen while changing the state to follower\n-          // thus the in-memory state should have been updated\n-          Preconditions.assertTrue(!running);\n         }\n       }\n     }\n   }\n \n-  private void handleEvent(StateUpdateEvent e) throws IOException {\n-    if (e == null) {\n-      if (inStagingState()) {\n-        checkNewPeers();\n-      }\n-    } else {\n-      if (e.type == STEPDOWN) {\n-        server.changeToFollower(e.newTerm, true);\n-      } else if (e.type == UPDATECOMMIT) {\n-        updateLastCommitted();\n-      } else if (e.type == STAGINGPROGRESS) {\n-        checkNewPeers();\n-      }\n-    }\n-  }\n-\n   /**\n    * So far we use a simple implementation for catchup checking:\n    * 1. If the latest rpc time of the remote peer is before 3 * max_timeout,\n@@ -410,11 +442,14 @@ private BootStrapProgress checkProgress(FollowerInfo follower,\n         .collect(Collectors.toCollection(ArrayList::new));\n   }\n \n-  private void checkNewPeers() {\n+  void submitCheckStagingEvent() {\n+    eventQueue.submit(CHECK_STAGING_EVENT);\n+  }\n+\n+  private void checkStaging() {\n     if (!inStagingState()) {\n-      // it is possible that the bootstrapping is done and we still have\n-      // remaining STAGINGPROGRESS event to handle.\n-      updateLastCommitted();\n+      // it is possible that the bootstrapping is done. Then, fallback to UPDATE_COMMIT\n+      UPDATE_COMMIT_EVENT.execute();\n     } else {\n       final long committedIndex = server.getState().getLog()\n           .getLastCommittedIndex();\n@@ -431,10 +466,14 @@ private void checkNewPeers() {\n   }\n \n   boolean isBootStrappingPeer(RaftPeerId peerId) {\n-    return inStagingState() && getStagingState().contains(peerId);\n+    return Optional.ofNullable(stagingState).map(s -> s.contains(peerId)).orElse(false);\n+  }\n+\n+  void submitUpdateCommitEvent() {\n+    eventQueue.submit(UPDATE_COMMIT_EVENT);\n   }\n \n-  private void updateLastCommitted() {\n+  private void updateCommit() {\n     final RaftPeerId selfId = server.getId();\n     final RaftConfiguration conf = server.getRaftConf();\n \n@@ -575,7 +614,7 @@ static long getMajority(long[] indices) {\n   /** @return true if the request is replied; otherwise, the reply is delayed, return false. */\n   boolean replyPendingRequest(long logIndex, RaftClientReply reply, RetryCache.CacheEntry cacheEntry) {\n     if (!pendingRequests.replyPendingRequest(logIndex, reply, cacheEntry)) {\n-      submitUpdateStateEvent(UPDATE_COMMIT_EVENT);\n+      submitUpdateCommitEvent();\n       return false;\n     }\n     return true;", "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java"}, {"additions": 6, "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java", "sha": "3c9b2d4dbf61476ac48abb3282027af6952f3f9c", "changes": 15, "status": "modified", "deletions": 9, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c", "patch": "@@ -20,7 +20,6 @@\n import org.apache.ratis.conf.RaftProperties;\n import org.apache.ratis.protocol.RaftPeerId;\n import org.apache.ratis.server.RaftServerConfigKeys;\n-import org.apache.ratis.server.impl.LeaderState.StateUpdateEventType;\n import org.apache.ratis.server.protocol.TermIndex;\n import org.apache.ratis.server.storage.RaftLog.EntryWithData;\n import org.apache.ratis.server.storage.FileInfo;\n@@ -45,7 +44,6 @@\n import static org.apache.ratis.util.LifeCycle.State.CLOSED;\n import static org.apache.ratis.util.LifeCycle.State.CLOSING;\n import static org.apache.ratis.util.LifeCycle.State.EXCEPTION;\n-import static org.apache.ratis.util.LifeCycle.State.NEW;\n import static org.apache.ratis.util.LifeCycle.State.RUNNING;\n import static org.apache.ratis.util.LifeCycle.State.STARTING;\n \n@@ -491,10 +489,11 @@ private void handleException(Exception e) {\n   }\n \n   protected void submitEventOnSuccessAppend() {\n-    LeaderState.StateUpdateEvent e = follower.isAttendingVote() ?\n-        LeaderState.UPDATE_COMMIT_EVENT :\n-        LeaderState.STAGING_PROGRESS_EVENT;\n-    leaderState.submitUpdateStateEvent(e);\n+    if (follower.isAttendingVote()) {\n+      leaderState.submitUpdateCommitEvent();\n+    } else {\n+      leaderState.submitCheckStagingEvent();\n+    }\n   }\n \n   protected void checkSlowness() {\n@@ -531,9 +530,7 @@ protected void checkResponseTerm(long responseTerm) {\n     synchronized (server) {\n       if (isAppenderRunning() && follower.isAttendingVote()\n           && responseTerm > leaderState.getCurrentTerm()) {\n-        leaderState.submitUpdateStateEvent(\n-            new LeaderState.StateUpdateEvent(StateUpdateEventType.STEPDOWN,\n-                responseTerm));\n+        leaderState.submitStepDownEvent(responseTerm);\n       }\n     }\n   }", "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java"}, {"additions": 11, "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java", "sha": "d4b32a10362f407c1aa97ef7234b46a9ffb6a4b5", "changes": 27, "status": "modified", "deletions": 16, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c", "patch": "@@ -295,13 +295,10 @@ public boolean isLeader() {\n   /**\n    * Change the server state to Follower if necessary\n    * @param newTerm The new term.\n-   * @param sync We will call {@link ServerState#persistMetadata()} if this is\n-   *             set to true and term/votedFor get updated.\n    * @return if the term/votedFor should be updated to the new term\n    * @throws IOException if term/votedFor persistence failed.\n    */\n-  synchronized boolean changeToFollower(long newTerm, boolean sync)\n-      throws IOException {\n+  private synchronized boolean changeToFollower(long newTerm) {\n     final RaftPeerRole old = role.getCurrentRole();\n     final boolean metadataUpdated = state.updateCurrentTerm(newTerm);\n \n@@ -314,11 +311,13 @@ synchronized boolean changeToFollower(long newTerm, boolean sync)\n       }\n       startHeartbeatMonitor();\n     }\n+    return metadataUpdated;\n+  }\n \n-    if (metadataUpdated && sync) {\n+  synchronized void changeToFollowerAndPersistMetadata(long newTerm) throws IOException {\n+    if (changeToFollower(newTerm)) {\n       state.persistMetadata();\n     }\n-    return metadataUpdated;\n   }\n \n   private synchronized void shutdownLeaderState(boolean allowNull) {\n@@ -546,9 +545,7 @@ void assertGroup(Object requestorId, RaftGroupId requestorGroupId) throws GroupM\n         cacheEntry.failWithReply(exceptionReply);\n         // leader will step down here\n         if (isLeader() && leaderState != null) {\n-          leaderState.submitUpdateStateEvent(new LeaderState.StateUpdateEvent(\n-              LeaderState.StateUpdateEventType.STEPDOWN,\n-              leaderState.getCurrentTerm()));\n+          leaderState.submitStepDownEvent();\n         }\n         return CompletableFuture.completedFuture(exceptionReply);\n       }\n@@ -777,7 +774,7 @@ private RequestVoteReplyProto requestVote(\n             getId(), role, candidateId, candidateTerm, state.getLeaderId(), state.getCurrentTerm(),\n             isFollower()? heartbeatMonitor.getLastRpcTime().elapsedTimeMs() + \"ms\": null);\n       } else if (state.recognizeCandidate(candidateId, candidateTerm)) {\n-        boolean termUpdated = changeToFollower(candidateTerm, false);\n+        final boolean termUpdated = changeToFollower(candidateTerm);\n         // see Section 5.4.1 Election restriction\n         if (state.isLogUpToDate(candidateLastEntry)) {\n           heartbeatMonitor.updateLastRpcTime(false);\n@@ -910,7 +907,7 @@ static void logAppendEntries(boolean isHeartbeat, Supplier<String> message) {\n         }\n         return CompletableFuture.completedFuture(reply);\n       }\n-      changeToFollower(leaderTerm, true);\n+      changeToFollowerAndPersistMetadata(leaderTerm);\n       state.setLeader(leaderId, \"appendEntries\");\n \n       if (!initializing && lifeCycle.compareAndTransition(STARTING, RUNNING)) {\n@@ -1010,7 +1007,7 @@ public InstallSnapshotReplyProto installSnapshot(\n             \" Reply: {}\", getId(), reply);\n         return reply;\n       }\n-      changeToFollower(leaderTerm, true);\n+      changeToFollowerAndPersistMetadata(leaderTerm);\n       state.setLeader(leaderId, \"installSnapshot\");\n \n       if (lifeCycle.getCurrentState() == RUNNING) {\n@@ -1062,10 +1059,8 @@ synchronized RequestVoteRequestProto createRequestVoteRequest(\n         groupId, term, lastEntry);\n   }\n \n-  public synchronized void submitLocalSyncEvent() {\n-    if (isLeader() && leaderState != null) {\n-      leaderState.submitUpdateStateEvent(LeaderState.UPDATE_COMMIT_EVENT);\n-    }\n+  public void submitUpdateCommitEvent() {\n+    Optional.ofNullable(leaderState).ifPresent(LeaderState::submitUpdateCommitEvent);\n   }\n \n   /**", "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java"}, {"additions": 6, "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java", "sha": "715370b554b114af25aded930b7629f0a6dc8352", "changes": 18, "status": "modified", "deletions": 12, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c", "patch": "@@ -61,7 +61,7 @@\n \n   private final RaftStorage storage;\n   private volatile LogOutputStream out;\n-  private final RaftServerImpl raftServer;\n+  private final Runnable submitUpdateCommitEvent;\n   private final StateMachine stateMachine;\n   private final Supplier<Timer> logFlushTimer;\n \n@@ -86,7 +86,7 @@\n     this.name = selfId + \"-\" + getClass().getSimpleName();\n     LOG.info(\"new {} for {}\", name, storage);\n \n-    this.raftServer = raftServer;\n+    this.submitUpdateCommitEvent = raftServer != null? raftServer::submitUpdateCommitEvent: () -> {};\n     this.stateMachine = raftServer != null? raftServer.getStateMachine(): null;\n \n     this.storage = storage;\n@@ -100,11 +100,8 @@\n     this.workerThread = new Thread(this, name);\n \n     // Server Id can be null in unit tests\n-    Supplier<String> serverId = () -> raftServer == null || raftServer.getId() == null\n-        ? \"null\" : raftServer.getId().toString();\n     this.logFlushTimer = JavaUtils.memoize(() -> RatisMetricsRegistry.getRegistry()\n-        .timer(MetricRegistry.name(RaftLogWorker.class, serverId.get(),\n-            \"flush-time\")));\n+        .timer(MetricRegistry.name(RaftLogWorker.class, selfId.toString(), \"flush-time\")));\n   }\n \n   void start(long latestIndex, File openSegmentFile) throws IOException {\n@@ -243,9 +240,7 @@ private void flushWrites() throws IOException {\n   private void updateFlushedIndex() {\n     flushedIndex = lastWrittenIndex;\n     pendingFlushNum = 0;\n-    if (raftServer != null) {\n-      raftServer.submitLocalSyncEvent();\n-    }\n+    submitUpdateCommitEvent.run();\n   }\n \n   /**\n@@ -288,9 +283,8 @@ Task truncate(TruncationSegments ts) {\n           // this.entry != entry iff the entry has state machine data\n           this.stateMachineFuture = stateMachine.writeStateMachineData(entry);\n         } catch (Throwable e) {\n-          LOG.error(\"{}: writeStateMachineData failed for index:{} proto:{}\",\n-              raftServer.getId() ,entry.getIndex(),\n-              ServerProtoUtils.toString(entry), e.getMessage());\n+          LOG.error(name + \": writeStateMachineData failed for index \" + entry.getIndex()\n+              + \", entry=\" + ServerProtoUtils.toLogEntryString(entry), e);\n           throw e;\n         }\n       }", "filename": "ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java"}, {"additions": 1, "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java", "sha": "862e21f87f20ee9db3ed1709651be62ec170486b", "changes": 3, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c", "patch": "@@ -105,8 +105,7 @@ public String toString() {\n   private final long segmentMaxSize;\n \n   public SegmentedRaftLog(RaftPeerId selfId, RaftServerImpl server,\n-      RaftStorage storage, long lastIndexInSnapshot, RaftProperties properties)\n-      throws IOException {\n+      RaftStorage storage, long lastIndexInSnapshot, RaftProperties properties) {\n     super(selfId, RaftServerConfigKeys.Log.Appender.bufferCapacity(properties)\n         .getSizeInt());\n     this.server = server;", "filename": "ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java"}], "repo": "incubator-ratis"}, {"commit": "https://github.com/apache/incubator-ratis/commit/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0", "parent": "https://github.com/apache/incubator-ratis/commit/ce783995f6612fa76f24a59c23e5964a4bf434a1", "message": "RATIS-361. Fix the NPE bug in MemoryRaftLog.", "bug_id": "incubator-ratis_4", "file": [{"additions": 43, "raw_url": "https://github.com/apache/incubator-ratis/raw/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java", "sha": "2661ba8c6eb0a7e911e85e0e90db0beb42e3bb84", "changes": 68, "status": "modified", "deletions": 25, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java?ref=8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0", "patch": "@@ -30,12 +30,40 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n \n /**\n  * A simple RaftLog implementation in memory. Used only for testing.\n  */\n public class MemoryRaftLog extends RaftLog {\n-  private final List<LogEntryProto> entries = new ArrayList<>();\n+  static class EntryList {\n+    private final List<LogEntryProto> entries = new ArrayList<>();\n+\n+    LogEntryProto get(int i) {\n+      return i >= 0 && i < entries.size() ? entries.get(i) : null;\n+    }\n+\n+    TermIndex getTermIndex(int i) {\n+      return ServerProtoUtils.toTermIndex(get(i));\n+    }\n+\n+    int size() {\n+      return entries.size();\n+    }\n+\n+    void truncate(int index) {\n+      if (entries.size() > index) {\n+        entries.subList(index, entries.size()).clear();\n+      }\n+    }\n+\n+    void add(LogEntryProto entry) {\n+      entries.add(entry);\n+    }\n+  }\n+\n+  private final EntryList entries = new EntryList();\n+  private final AtomicReference<Metadata> metadata = new AtomicReference<>(new Metadata(null, 0));\n \n   public MemoryRaftLog(RaftPeerId selfId, int maxBufferSize) {\n     super(selfId, maxBufferSize);\n@@ -45,8 +73,7 @@ public MemoryRaftLog(RaftPeerId selfId, int maxBufferSize) {\n   public LogEntryProto get(long index) {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int i = (int) index;\n-      return i >= 0 && i < entries.size() ? entries.get(i) : null;\n+      return entries.get(Math.toIntExact(index));\n     }\n   }\n \n@@ -59,25 +86,22 @@ public EntryWithData getEntryWithData(long index) {\n   public TermIndex getTermIndex(long index) {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int i = (int) index;\n-      return i >= 0 && i < entries.size() ?\n-          ServerProtoUtils.toTermIndex(entries.get(i)) : null;\n+      return entries.getTermIndex(Math.toIntExact(index));\n     }\n   }\n \n   @Override\n   public TermIndex[] getEntries(long startIndex, long endIndex) {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int from = (int) startIndex;\n       if (startIndex >= entries.size()) {\n         return null;\n       }\n-      final int to = (int) Math.min(entries.size(), endIndex);\n+      final int from = Math.toIntExact(startIndex);\n+      final int to = Math.toIntExact(Math.min(entries.size(), endIndex));\n       TermIndex[] ti = new TermIndex[to - from];\n       for (int i = 0; i < ti.length; i++) {\n-        ti[i] = TermIndex.newTermIndex(entries.get(i).getTerm(),\n-            entries.get(i).getIndex());\n+        ti[i] = entries.getTermIndex(i);\n       }\n       return ti;\n     }\n@@ -88,10 +112,7 @@ public TermIndex getTermIndex(long index) {\n     checkLogState();\n     try(AutoCloseableLock writeLock = writeLock()) {\n       Preconditions.assertTrue(index >= 0);\n-      final int truncateIndex = (int) index;\n-      for (int i = entries.size() - 1; i >= truncateIndex; i--) {\n-        entries.remove(i);\n-      }\n+      entries.truncate(Math.toIntExact(index));\n     }\n     return CompletableFuture.completedFuture(index);\n   }\n@@ -100,8 +121,7 @@ public TermIndex getTermIndex(long index) {\n   public TermIndex getLastEntryTermIndex() {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int size = entries.size();\n-      return size == 0 ? null : ServerProtoUtils.toTermIndex(entries.get(size - 1));\n+      return entries.getTermIndex(entries.size() - 1);\n     }\n   }\n \n@@ -120,26 +140,24 @@ public long append(long term, RaftConfiguration newConf) {\n     checkLogState();\n     try(AutoCloseableLock writeLock = writeLock()) {\n       final long nextIndex = getNextIndex();\n-      final LogEntryProto e = ServerProtoUtils.toLogEntryProto(newConf, term,\n-          nextIndex);\n+      final LogEntryProto e = ServerProtoUtils.toLogEntryProto(newConf, term, nextIndex);\n       entries.add(e);\n       return nextIndex;\n     }\n   }\n \n   @Override\n   public long getStartIndex() {\n-    return entries.isEmpty() ? RaftServerConstants.INVALID_LOG_INDEX :\n-        entries.get(0).getIndex();\n+    return entries.size() == 0? RaftServerConstants.INVALID_LOG_INDEX: entries.getTermIndex(0).getIndex();\n   }\n \n   @Override\n   public List<CompletableFuture<Long>> append(LogEntryProto... entries) {\n     checkLogState();\n+    if (entries == null || entries.length == 0) {\n+      return Collections.emptyList();\n+    }\n     try(AutoCloseableLock writeLock = writeLock()) {\n-      if (entries == null || entries.length == 0) {\n-        return Collections.emptyList();\n-      }\n       // Before truncating the entries, we first need to check if some\n       // entries are duplicated. If the leader sends entry 6, entry 7, then\n       // entry 6 again, without this check the follower may truncate entry 7\n@@ -191,12 +209,12 @@ public long getLatestFlushedIndex() {\n \n   @Override\n   public void writeMetadata(long term, RaftPeerId votedFor) {\n-    // do nothing\n+    metadata.set(new Metadata(votedFor, term));\n   }\n \n   @Override\n   public Metadata loadMetadata() {\n-    return new Metadata(null, 0);\n+    return metadata.get();\n   }\n \n   @Override", "filename": "ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java"}, {"additions": 10, "raw_url": "https://github.com/apache/incubator-ratis/raw/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java", "sha": "329b02bfe0913c83215cafcb59392679e56b8218", "changes": 14, "status": "modified", "deletions": 4, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java?ref=8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0", "patch": "@@ -116,12 +116,18 @@ void rethrowIfException() throws Throwable {\n \n   @Test\n   public void testTransactionContextIsPassedBack() throws Throwable {\n+    runTestTransactionContextIsPassedBack(false);\n+  }\n+\n+  @Test\n+  public void testTransactionContextIsPassedBackUseMemory() throws Throwable {\n+    runTestTransactionContextIsPassedBack(true);\n+  }\n+\n+  void runTestTransactionContextIsPassedBack(boolean useMemory) throws Throwable {\n     final RaftProperties properties = new RaftProperties();\n     properties.setClass(MiniRaftCluster.STATEMACHINE_CLASS_KEY, SMTransactionContext.class, StateMachine.class);\n-\n-    // TODO: fix and run with in-memory log. It fails with NPE\n-    // TODO: if change setUseMemory to true\n-    RaftServerConfigKeys.Log.setUseMemory(properties, false);\n+    RaftServerConfigKeys.Log.setUseMemory(properties, useMemory);\n \n     try(MiniRaftClusterWithSimulatedRpc cluster = getFactory().newCluster(NUM_SERVERS, properties)) {\n       cluster.start();", "filename": "ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java"}], "repo": "incubator-ratis"}, {"commit": "https://github.com/apache/incubator-ratis/commit/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6", "parent": "https://github.com/apache/incubator-ratis/commit/1fe655b34bb8546db9901700fdca05832437c43f", "message": "Fix NPE in PendingRequests#getTransactionContext: pendingRequest may be null if the peer just becomes the new leader and commits transactions received by the previous leader.", "bug_id": "incubator-ratis_5", "file": [{"additions": 4, "raw_url": "https://github.com/apache/incubator-ratis/raw/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6/raft-server/src/main/java/org/apache/raft/server/PendingRequests.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6/raft-server/src/main/java/org/apache/raft/server/PendingRequests.java", "sha": "77f8ccae07b0c4fc8e6163606c8091106ffa260d", "changes": 5, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/raft-server/src/main/java/org/apache/raft/server/PendingRequests.java?ref=6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6", "patch": "@@ -84,7 +84,10 @@ void failSetConfiguration(RaftException e) {\n   }\n \n   TrxContext getTransactionContext(long index) {\n-    return pendingRequests.get(index).getEntry();\n+    PendingRequest pendingRequest = pendingRequests.get(index);\n+    // it is possible that the pendingRequest is null if this peer just becomes\n+    // the new leader and commits transactions received by the previous leader\n+    return pendingRequest != null ? pendingRequest.getEntry() : null;\n   }\n \n   void replyPendingRequest(long index, CompletableFuture<Message> messageFuture) {", "filename": "raft-server/src/main/java/org/apache/raft/server/PendingRequests.java"}, {"additions": 2, "raw_url": "https://github.com/apache/incubator-ratis/raw/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6/raft-server/src/main/java/org/apache/raft/server/StateMachineUpdater.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6/raft-server/src/main/java/org/apache/raft/server/StateMachineUpdater.java", "sha": "ebabf50527fef5f6cb3e531eca7f297e70067a4f", "changes": 4, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/raft-server/src/main/java/org/apache/raft/server/StateMachineUpdater.java?ref=6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6", "patch": "@@ -145,13 +145,13 @@ public void run() {\n         while (lastAppliedIndex < committedIndex) {\n           final LogEntryProto next = raftLog.get(lastAppliedIndex + 1);\n           if (next != null) {\n-            if (next.hasConfigurationEntry()) {\n+            if (next.getType() == LogEntryProto.Type.CONFIGURATION) {\n               // the reply should have already been set. only need to record\n               // the new conf in the state machine.\n               stateMachine.setRaftConfiguration(\n                   ServerProtoUtils.toRaftConfiguration(next.getIndex(),\n                       next.getConfigurationEntry()));\n-            } else if (next.hasSmLogEntry()) {\n+            } else if (next.getType() == LogEntryProto.Type.CLIENT_MESSAGE) {\n               // check whether there is a TransactionContext because we are the leader.\n               TrxContext trx = server.getTransactionContext(next.getIndex());\n               if (trx == null) {", "filename": "raft-server/src/main/java/org/apache/raft/server/StateMachineUpdater.java"}, {"additions": 2, "raw_url": "https://github.com/apache/incubator-ratis/raw/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6/raft-server/src/main/java/org/apache/raft/server/storage/RaftLog.java", "blob_url": "https://github.com/apache/incubator-ratis/blob/6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6/raft-server/src/main/java/org/apache/raft/server/storage/RaftLog.java", "sha": "2440817eabced4a2b8708aa3b2a6b8f3488a7ff0", "changes": 4, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/raft-server/src/main/java/org/apache/raft/server/storage/RaftLog.java?ref=6cf4be6675e23ce93aaa3e9d1a72d29aa5bad9e6", "patch": "@@ -128,8 +128,8 @@ public long append(long term, TrxContext operation) {\n     checkLogState();\n     try(AutoCloseableLock writeLock = writeLock()) {\n       final long nextIndex = getNextIndex();\n-      final LogEntryProto e = ProtoUtils.toLogEntryProto(operation.getSMLogEntry().get(), term,\n-          nextIndex);\n+      final LogEntryProto e = ProtoUtils.toLogEntryProto(\n+          operation.getSMLogEntry().get(), term, nextIndex);\n       appendEntry(e);\n       operation.setLogEntry(e);\n       return nextIndex;", "filename": "raft-server/src/main/java/org/apache/raft/server/storage/RaftLog.java"}], "repo": "incubator-ratis"}]
