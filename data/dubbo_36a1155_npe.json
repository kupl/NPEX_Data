[
    {
        "repo": "dubbo",
        "commit": "https://github.com/apache/dubbo/commit/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
        "bug_id": "dubbo_36a1155",
        "message": "[version 2.7.0]remove the StaticContext class and refactor the code related to Async (#2688)\n\n* [Dubbo] move the classes of model from config to rpc-api for reusing\r\n\r\n* remove ServiceClassHolder and use the ApplicationModel replacedly\r\n\r\n* [Dubbo] delete the unused imported of ApplicationModel\r\n\r\n* Update dubbo-demo-consumer.xml\r\n\r\nthis commits is no need to commit to remote repo.\r\n\r\n* remove StaticContext\r\n\r\n* remove the unused imported classes of ReferenceConfig\r\n\r\n* fix NPE of ConsumerModel\r\n\r\n* fix the failed testcase of AbstractClusterInvokerTest\r\n\r\n* [Dubbo] #PR2688 to fix the review issues",
        "parent": "https://github.com/apache/dubbo/commit/99a00ba72b53d6f740899ddb76c858b8f99683ac",
        "patched_files": [
            "AbstractClusterInvoker.java",
            "MethodConfig.java",
            "ConsumerMethodModel.java",
            "ConsumerModel.java",
            "StaticContext.java",
            "TagRouter.java",
            "ReferenceConfig.java",
            "AbstractConfig.java",
            "ApplicationModel.java",
            "ProviderModel.java",
            "FutureFilter.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 4,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouterTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouterTest.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouterTest.java",
                "deletions": 3,
                "sha": "a3ba0924013998c6073f444cb567826d33db23e8",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouterTest.java",
                "patch": "@@ -26,8 +26,8 @@\n import org.apache.dubbo.rpc.cluster.Router;\n import org.apache.dubbo.rpc.cluster.RouterFactory;\n import org.apache.dubbo.rpc.cluster.router.MockInvoker;\n+import org.junit.After;\n import org.junit.Assert;\n-import org.junit.Before;\n import org.junit.BeforeClass;\n import org.junit.Test;\n \n@@ -47,8 +47,9 @@\n     public static void setUpBeforeClass() throws Exception {\n     }\n \n-    @Before\n-    public void setUp() throws Exception {\n+    @After\n+    public void teardown() throws Exception {\n+        RpcContext.getContext().clearAttachments();\n     }\n \n     @Test",
                "changes": 7
            },
            {
                "status": "modified",
                "additions": 6,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java",
                "deletions": 0,
                "sha": "2039b0a0e4c2d0191317f6475294ddb6cf53680f",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvokerTest.java",
                "patch": "@@ -34,6 +34,7 @@\n import org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance;\n import org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance;\n \n+import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.BeforeClass;\n@@ -74,6 +75,11 @@\n     public static void setUpBeforeClass() throws Exception {\n     }\n \n+    @After\n+    public void teardown() throws Exception {\n+        RpcContext.getContext().clearAttachments();\n+    }\n+\n     @SuppressWarnings({\"unchecked\"})\n     @Before\n     public void setUp() throws Exception {",
                "changes": 6
            },
            {
                "status": "modified",
                "additions": 21,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java",
                "deletions": 6,
                "sha": "e7e0601e2b3a2de53fca69bc2cc043c49e5261cc",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-compatible/src/test/java/org/apache/dubbo/config/MethodConfigTest.java",
                "patch": "@@ -20,6 +20,9 @@\n import com.alibaba.dubbo.common.Constants;\n import com.alibaba.dubbo.config.MethodConfig;\n import com.alibaba.dubbo.config.ArgumentConfig;\n+\n+import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n+import org.apache.dubbo.service.Person;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n \n@@ -34,6 +37,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.not;\n import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n \n public class MethodConfigTest {\n     @Test\n@@ -97,12 +101,23 @@ public void testSticky() throws Exception {\n         assertThat(method.getSticky(), is(true));\n     }\n \n+    @Test\n+    public void testConverMethodConfig2AsyncInfo() throws Exception{\n+        org.apache.dubbo.config.MethodConfig methodConfig = new org.apache.dubbo.config.MethodConfig();\n+        methodConfig.setOninvokeMethod(\"setName\");\n+        methodConfig.setOninvoke(new Person());\n+\n+        ConsumerMethodModel.AsyncMethodInfo methodInfo = org.apache.dubbo.config.MethodConfig.convertMethodConfig2AyncInfo(methodConfig);\n+\n+        assertTrue(methodInfo.getOninvokeMethod().equals( Person.class.getMethod(\"setName\", String.class)));\n+    }\n+\n     @Test\n     public void testOnreturn() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnreturn(\"on-return-object\");\n         assertThat(method.getOnreturn(), equalTo((Object) \"on-return-object\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_INSTANCE_KEY, (Object) \"on-return-object\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -115,7 +130,7 @@ public void testOnreturnMethod() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnreturnMethod(\"on-return-method\");\n         assertThat(method.getOnreturnMethod(), equalTo(\"on-return-method\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_METHOD_KEY, (Object) \"on-return-method\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -128,7 +143,7 @@ public void testOnthrow() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnthrow(\"on-throw-object\");\n         assertThat(method.getOnthrow(), equalTo((Object) \"on-throw-object\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_THROW_INSTANCE_KEY, (Object) \"on-throw-object\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -141,7 +156,7 @@ public void testOnthrowMethod() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnthrowMethod(\"on-throw-method\");\n         assertThat(method.getOnthrowMethod(), equalTo(\"on-throw-method\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_THROW_METHOD_KEY, (Object) \"on-throw-method\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -154,7 +169,7 @@ public void testOninvoke() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOninvoke(\"on-invoke-object\");\n         assertThat(method.getOninvoke(), equalTo((Object) \"on-invoke-object\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_INSTANCE_KEY, (Object) \"on-invoke-object\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -167,7 +182,7 @@ public void testOninvokeMethod() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOninvokeMethod(\"on-invoke-method\");\n         assertThat(method.getOninvokeMethod(), equalTo(\"on-invoke-method\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_METHOD_KEY, (Object) \"on-invoke-method\"));\n         Map<String, String> parameters = new HashMap<String, String>();",
                "changes": 27
            },
            {
                "status": "modified",
                "additions": 534,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java",
                "deletions": 487,
                "sha": "fdaa3b16a1cf9d08e5ff891b89e38f9919a8cdc4",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java",
                "patch": "@@ -1,487 +1,534 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.dubbo.config;\r\n-\r\n-import org.apache.dubbo.common.Constants;\r\n-import org.apache.dubbo.common.URL;\r\n-import org.apache.dubbo.common.extension.ExtensionLoader;\r\n-import org.apache.dubbo.common.logger.Logger;\r\n-import org.apache.dubbo.common.logger.LoggerFactory;\r\n-import org.apache.dubbo.common.utils.CollectionUtils;\r\n-import org.apache.dubbo.common.utils.ConfigUtils;\r\n-import org.apache.dubbo.common.utils.ReflectUtils;\r\n-import org.apache.dubbo.common.utils.StringUtils;\r\n-import org.apache.dubbo.config.support.Parameter;\r\n-\r\n-import java.io.Serializable;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-import java.util.regex.Matcher;\r\n-import java.util.regex.Pattern;\r\n-\r\n-/**\r\n- * Utility methods and public methods for parsing configuration\r\n- *\r\n- * @export\r\n- */\r\n-public abstract class AbstractConfig implements Serializable {\r\n-\r\n-    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);\r\n-    private static final long serialVersionUID = 4267533505537413570L;\r\n-    private static final int MAX_LENGTH = 200;\r\n-\r\n-    private static final int MAX_PATH_LENGTH = 200;\r\n-\r\n-    private static final Pattern PATTERN_NAME = Pattern.compile(\"[\\\\-._0-9a-zA-Z]+\");\r\n-\r\n-    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(\"[,\\\\-._0-9a-zA-Z]+\");\r\n-\r\n-    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(\"[a-zA-Z][0-9a-zA-Z]*\");\r\n-\r\n-    private static final Pattern PATTERN_PATH = Pattern.compile(\"[/\\\\-$._0-9a-zA-Z]+\");\r\n-\r\n-    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(\"[:*,/\\\\-._0-9a-zA-Z]+\");\r\n-\r\n-    private static final Pattern PATTERN_KEY = Pattern.compile(\"[*,\\\\-._0-9a-zA-Z]+\");\r\n-    private static final Map<String, String> legacyProperties = new HashMap<String, String>();\r\n-    private static final String[] SUFFIXES = new String[]{\"Config\", \"Bean\"};\r\n-\r\n-    static {\r\n-        legacyProperties.put(\"dubbo.protocol.name\", \"dubbo.service.protocol\");\r\n-        legacyProperties.put(\"dubbo.protocol.host\", \"dubbo.service.server.host\");\r\n-        legacyProperties.put(\"dubbo.protocol.port\", \"dubbo.service.server.port\");\r\n-        legacyProperties.put(\"dubbo.protocol.threads\", \"dubbo.service.max.thread.pool.size\");\r\n-        legacyProperties.put(\"dubbo.consumer.timeout\", \"dubbo.service.invoke.timeout\");\r\n-        legacyProperties.put(\"dubbo.consumer.retries\", \"dubbo.service.max.retry.providers\");\r\n-        legacyProperties.put(\"dubbo.consumer.check\", \"dubbo.service.allow.no.provider\");\r\n-        legacyProperties.put(\"dubbo.service.url\", \"dubbo.service.address\");\r\n-\r\n-        // this is only for compatibility\r\n-        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());\r\n-    }\r\n-\r\n-    protected String id;\r\n-\r\n-    private static String convertLegacyValue(String key, String value) {\r\n-        if (value != null && value.length() > 0) {\r\n-            if (\"dubbo.service.max.retry.providers\".equals(key)) {\r\n-                return String.valueOf(Integer.parseInt(value) - 1);\r\n-            } else if (\"dubbo.service.allow.no.provider\".equals(key)) {\r\n-                return String.valueOf(!Boolean.parseBoolean(value));\r\n-            }\r\n-        }\r\n-        return value;\r\n-    }\r\n-\r\n-    protected static void appendProperties(AbstractConfig config) {\r\n-        if (config == null) {\r\n-            return;\r\n-        }\r\n-        String prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\";\r\n-        Method[] methods = config.getClass().getMethods();\r\n-        for (Method method : methods) {\r\n-            try {\r\n-                String name = method.getName();\r\n-                if (name.length() > 3 && name.startsWith(\"set\") && Modifier.isPublic(method.getModifiers())\r\n-                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {\r\n-                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\");\r\n-\r\n-                    String value = null;\r\n-                    if (config.getId() != null && config.getId().length() > 0) {\r\n-                        String pn = prefix + config.getId() + \".\" + property;\r\n-                        value = System.getProperty(pn);\r\n-                        if (!StringUtils.isBlank(value)) {\r\n-                            logger.info(\"Use System Property \" + pn + \" to config dubbo\");\r\n-                        }\r\n-                    }\r\n-                    if (value == null || value.length() == 0) {\r\n-                        String pn = prefix + property;\r\n-                        value = System.getProperty(pn);\r\n-                        if (!StringUtils.isBlank(value)) {\r\n-                            logger.info(\"Use System Property \" + pn + \" to config dubbo\");\r\n-                        }\r\n-                    }\r\n-                    if (value == null || value.length() == 0) {\r\n-                        Method getter;\r\n-                        try {\r\n-                            getter = config.getClass().getMethod(\"get\" + name.substring(3));\r\n-                        } catch (NoSuchMethodException e) {\r\n-                            try {\r\n-                                getter = config.getClass().getMethod(\"is\" + name.substring(3));\r\n-                            } catch (NoSuchMethodException e2) {\r\n-                                getter = null;\r\n-                            }\r\n-                        }\r\n-                        if (getter != null) {\r\n-                            if (getter.invoke(config) == null) {\r\n-                                if (config.getId() != null && config.getId().length() > 0) {\r\n-                                    value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property);\r\n-                                }\r\n-                                if (value == null || value.length() == 0) {\r\n-                                    value = ConfigUtils.getProperty(prefix + property);\r\n-                                }\r\n-                                if (value == null || value.length() == 0) {\r\n-                                    String legacyKey = legacyProperties.get(prefix + property);\r\n-                                    if (legacyKey != null && legacyKey.length() > 0) {\r\n-                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));\r\n-                                    }\r\n-                                }\r\n-\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                    if (value != null && value.length() > 0) {\r\n-                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));\r\n-                    }\r\n-                }\r\n-            } catch (Exception e) {\r\n-                logger.error(e.getMessage(), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static String getTagName(Class<?> cls) {\r\n-        String tag = cls.getSimpleName();\r\n-        for (String suffix : SUFFIXES) {\r\n-            if (tag.endsWith(suffix)) {\r\n-                tag = tag.substring(0, tag.length() - suffix.length());\r\n-                break;\r\n-            }\r\n-        }\r\n-        tag = tag.toLowerCase();\r\n-        return tag;\r\n-    }\r\n-\r\n-    protected static void appendParameters(Map<String, String> parameters, Object config) {\r\n-        appendParameters(parameters, config, null);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {\r\n-        if (config == null) {\r\n-            return;\r\n-        }\r\n-        Method[] methods = config.getClass().getMethods();\r\n-        for (Method method : methods) {\r\n-            try {\r\n-                String name = method.getName();\r\n-                if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\r\n-                        && !\"getClass\".equals(name)\r\n-                        && Modifier.isPublic(method.getModifiers())\r\n-                        && method.getParameterTypes().length == 0\r\n-                        && isPrimitive(method.getReturnType())) {\r\n-                    Parameter parameter = method.getAnnotation(Parameter.class);\r\n-                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {\r\n-                        continue;\r\n-                    }\r\n-                    int i = name.startsWith(\"get\") ? 3 : 2;\r\n-                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\");\r\n-                    String key;\r\n-                    if (parameter != null && parameter.key().length() > 0) {\r\n-                        key = parameter.key();\r\n-                    } else {\r\n-                        key = prop;\r\n-                    }\r\n-                    Object value = method.invoke(config);\r\n-                    String str = String.valueOf(value).trim();\r\n-                    if (value != null && str.length() > 0) {\r\n-                        if (parameter != null && parameter.escaped()) {\r\n-                            str = URL.encode(str);\r\n-                        }\r\n-                        if (parameter != null && parameter.append()) {\r\n-                            String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key);\r\n-                            if (pre != null && pre.length() > 0) {\r\n-                                str = pre + \",\" + str;\r\n-                            }\r\n-                            pre = parameters.get(key);\r\n-                            if (pre != null && pre.length() > 0) {\r\n-                                str = pre + \",\" + str;\r\n-                            }\r\n-                        }\r\n-                        if (prefix != null && prefix.length() > 0) {\r\n-                            key = prefix + \".\" + key;\r\n-                        }\r\n-                        parameters.put(key, str);\r\n-                    } else if (parameter != null && parameter.required()) {\r\n-                        throw new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\");\r\n-                    }\r\n-                } else if (\"getParameters\".equals(name)\r\n-                        && Modifier.isPublic(method.getModifiers())\r\n-                        && method.getParameterTypes().length == 0\r\n-                        && method.getReturnType() == Map.class) {\r\n-                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);\r\n-                    if (map != null && map.size() > 0) {\r\n-                        String pre = (prefix != null && prefix.length() > 0 ? prefix + \".\" : \"\");\r\n-                        for (Map.Entry<String, String> entry : map.entrySet()) {\r\n-                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());\r\n-                        }\r\n-                    }\r\n-                }\r\n-            } catch (Exception e) {\r\n-                throw new IllegalStateException(e.getMessage(), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected static void appendAttributes(Map<Object, Object> parameters, Object config) {\r\n-        appendAttributes(parameters, config, null);\r\n-    }\r\n-\r\n-    protected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {\r\n-        if (config == null) {\r\n-            return;\r\n-        }\r\n-        Method[] methods = config.getClass().getMethods();\r\n-        for (Method method : methods) {\r\n-            try {\r\n-                String name = method.getName();\r\n-                if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\r\n-                        && !\"getClass\".equals(name)\r\n-                        && Modifier.isPublic(method.getModifiers())\r\n-                        && method.getParameterTypes().length == 0\r\n-                        && isPrimitive(method.getReturnType())) {\r\n-                    Parameter parameter = method.getAnnotation(Parameter.class);\r\n-                    if (parameter == null || !parameter.attribute()) {\r\n-                        continue;\r\n-                    }\r\n-                    String key;\r\n-                    if (parameter.key().length() > 0) {\r\n-                        key = parameter.key();\r\n-                    } else {\r\n-                        int i = name.startsWith(\"get\") ? 3 : 2;\r\n-                        key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\r\n-                    }\r\n-                    Object value = method.invoke(config);\r\n-                    if (value != null) {\r\n-                        if (prefix != null && prefix.length() > 0) {\r\n-                            key = prefix + \".\" + key;\r\n-                        }\r\n-                        parameters.put(key, value);\r\n-                    }\r\n-                }\r\n-            } catch (Exception e) {\r\n-                throw new IllegalStateException(e.getMessage(), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static boolean isPrimitive(Class<?> type) {\r\n-        return type.isPrimitive()\r\n-                || type == String.class\r\n-                || type == Character.class\r\n-                || type == Boolean.class\r\n-                || type == Byte.class\r\n-                || type == Short.class\r\n-                || type == Integer.class\r\n-                || type == Long.class\r\n-                || type == Float.class\r\n-                || type == Double.class\r\n-                || type == Object.class;\r\n-    }\r\n-\r\n-    private static Object convertPrimitive(Class<?> type, String value) {\r\n-        if (type == char.class || type == Character.class) {\r\n-            return value.length() > 0 ? value.charAt(0) : '\\0';\r\n-        } else if (type == boolean.class || type == Boolean.class) {\r\n-            return Boolean.valueOf(value);\r\n-        } else if (type == byte.class || type == Byte.class) {\r\n-            return Byte.valueOf(value);\r\n-        } else if (type == short.class || type == Short.class) {\r\n-            return Short.valueOf(value);\r\n-        } else if (type == int.class || type == Integer.class) {\r\n-            return Integer.valueOf(value);\r\n-        } else if (type == long.class || type == Long.class) {\r\n-            return Long.valueOf(value);\r\n-        } else if (type == float.class || type == Float.class) {\r\n-            return Float.valueOf(value);\r\n-        } else if (type == double.class || type == Double.class) {\r\n-            return Double.valueOf(value);\r\n-        }\r\n-        return value;\r\n-    }\r\n-\r\n-    protected static void checkExtension(Class<?> type, String property, String value) {\r\n-        checkName(property, value);\r\n-        if (value != null && value.length() > 0\r\n-                && !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) {\r\n-            throw new IllegalStateException(\"No such extension \" + value + \" for \" + property + \"/\" + type.getName());\r\n-        }\r\n-    }\r\n-\r\n-    protected static void checkMultiExtension(Class<?> type, String property, String value) {\r\n-        checkMultiName(property, value);\r\n-        if (value != null && value.length() > 0) {\r\n-            String[] values = value.split(\"\\\\s*[,]+\\\\s*\");\r\n-            for (String v : values) {\r\n-                if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) {\r\n-                    v = v.substring(1);\r\n-                }\r\n-                if (Constants.DEFAULT_KEY.equals(v)) {\r\n-                    continue;\r\n-                }\r\n-                if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) {\r\n-                    throw new IllegalStateException(\"No such extension \" + v + \" for \" + property + \"/\" + type.getName());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected static void checkLength(String property, String value) {\r\n-        checkProperty(property, value, MAX_LENGTH, null);\r\n-    }\r\n-\r\n-    protected static void checkPathLength(String property, String value) {\r\n-        checkProperty(property, value, MAX_PATH_LENGTH, null);\r\n-    }\r\n-\r\n-    protected static void checkName(String property, String value) {\r\n-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME);\r\n-    }\r\n-\r\n-    protected static void checkNameHasSymbol(String property, String value) {\r\n-        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL);\r\n-    }\r\n-\r\n-    protected static void checkKey(String property, String value) {\r\n-        checkProperty(property, value, MAX_LENGTH, PATTERN_KEY);\r\n-    }\r\n-\r\n-    protected static void checkMultiName(String property, String value) {\r\n-        checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME);\r\n-    }\r\n-\r\n-    protected static void checkPathName(String property, String value) {\r\n-        checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH);\r\n-    }\r\n-\r\n-    protected static void checkMethodName(String property, String value) {\r\n-        checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME);\r\n-    }\r\n-\r\n-    protected static void checkParameterName(Map<String, String> parameters) {\r\n-        if (parameters == null || parameters.size() == 0) {\r\n-            return;\r\n-        }\r\n-        for (Map.Entry<String, String> entry : parameters.entrySet()) {\r\n-            checkNameHasSymbol(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) {\r\n-        if (value == null || value.length() == 0) {\r\n-            return;\r\n-        }\r\n-        if (value.length() > maxlength) {\r\n-            throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" is longer than \" + maxlength);\r\n-        }\r\n-        if (pattern != null) {\r\n-            Matcher matcher = pattern.matcher(value);\r\n-            if (!matcher.matches()) {\r\n-                throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" contains illegal \" +\r\n-                        \"character, only digit, letter, '-', '_' or '.' is legal.\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Parameter(excluded = true)\r\n-    public String getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    protected void appendAnnotation(Class<?> annotationClass, Object annotation) {\r\n-        Method[] methods = annotationClass.getMethods();\r\n-        for (Method method : methods) {\r\n-            if (method.getDeclaringClass() != Object.class\r\n-                    && method.getReturnType() != void.class\r\n-                    && method.getParameterTypes().length == 0\r\n-                    && Modifier.isPublic(method.getModifiers())\r\n-                    && !Modifier.isStatic(method.getModifiers())) {\r\n-                try {\r\n-                    String property = method.getName();\r\n-                    if (\"interfaceClass\".equals(property) || \"interfaceName\".equals(property)) {\r\n-                        property = \"interface\";\r\n-                    }\r\n-                    String setter = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\r\n-                    Object value = method.invoke(annotation);\r\n-                    if (value != null && !value.equals(method.getDefaultValue())) {\r\n-                        Class<?> parameterType = ReflectUtils.getBoxedClass(method.getReturnType());\r\n-                        if (\"filter\".equals(property) || \"listener\".equals(property)) {\r\n-                            parameterType = String.class;\r\n-                            value = StringUtils.join((String[]) value, \",\");\r\n-                        } else if (\"parameters\".equals(property)) {\r\n-                            parameterType = Map.class;\r\n-                            value = CollectionUtils.toStringMap((String[]) value);\r\n-                        }\r\n-                        try {\r\n-                            Method setterMethod = getClass().getMethod(setter, parameterType);\r\n-                            setterMethod.invoke(this, value);\r\n-                        } catch (NoSuchMethodException e) {\r\n-                            // ignore\r\n-                        }\r\n-                    }\r\n-                } catch (Throwable e) {\r\n-                    logger.error(e.getMessage(), e);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public String toString() {\r\n-        try {\r\n-            StringBuilder buf = new StringBuilder();\r\n-            buf.append(\"<dubbo:\");\r\n-            buf.append(getTagName(getClass()));\r\n-            Method[] methods = getClass().getMethods();\r\n-            for (Method method : methods) {\r\n-                try {\r\n-                    String name = method.getName();\r\n-                    if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\r\n-                            && !\"getClass\".equals(name) && !\"get\".equals(name) && !\"is\".equals(name)\r\n-                            && Modifier.isPublic(method.getModifiers())\r\n-                            && method.getParameterTypes().length == 0\r\n-                            && isPrimitive(method.getReturnType())) {\r\n-                        int i = name.startsWith(\"get\") ? 3 : 2;\r\n-                        String key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\r\n-                        Object value = method.invoke(this);\r\n-                        if (value != null) {\r\n-                            buf.append(\" \");\r\n-                            buf.append(key);\r\n-                            buf.append(\"=\\\"\");\r\n-                            buf.append(value);\r\n-                            buf.append(\"\\\"\");\r\n-                        }\r\n-                    }\r\n-                } catch (Exception e) {\r\n-                    logger.warn(e.getMessage(), e);\r\n-                }\r\n-            }\r\n-            buf.append(\" />\");\r\n-            return buf.toString();\r\n-        } catch (Throwable t) {\r\n-            logger.warn(t.getMessage(), t);\r\n-            return super.toString();\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.config;\n+\n+import org.apache.dubbo.common.Constants;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.ConfigUtils;\n+import org.apache.dubbo.common.utils.ReflectUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.config.support.Parameter;\n+import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utility methods and public methods for parsing configuration\n+ *\n+ * @export\n+ */\n+public abstract class AbstractConfig implements Serializable {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractConfig.class);\n+    private static final long serialVersionUID = 4267533505537413570L;\n+    private static final int MAX_LENGTH = 200;\n+\n+    private static final int MAX_PATH_LENGTH = 200;\n+\n+    private static final Pattern PATTERN_NAME = Pattern.compile(\"[\\\\-._0-9a-zA-Z]+\");\n+\n+    private static final Pattern PATTERN_MULTI_NAME = Pattern.compile(\"[,\\\\-._0-9a-zA-Z]+\");\n+\n+    private static final Pattern PATTERN_METHOD_NAME = Pattern.compile(\"[a-zA-Z][0-9a-zA-Z]*\");\n+\n+    private static final Pattern PATTERN_PATH = Pattern.compile(\"[/\\\\-$._0-9a-zA-Z]+\");\n+\n+    private static final Pattern PATTERN_NAME_HAS_SYMBOL = Pattern.compile(\"[:*,/\\\\-._0-9a-zA-Z]+\");\n+\n+    private static final Pattern PATTERN_KEY = Pattern.compile(\"[*,\\\\-._0-9a-zA-Z]+\");\n+    private static final Map<String, String> legacyProperties = new HashMap<String, String>();\n+    private static final String[] SUFFIXES = new String[]{\"Config\", \"Bean\"};\n+\n+    static {\n+        legacyProperties.put(\"dubbo.protocol.name\", \"dubbo.service.protocol\");\n+        legacyProperties.put(\"dubbo.protocol.host\", \"dubbo.service.server.host\");\n+        legacyProperties.put(\"dubbo.protocol.port\", \"dubbo.service.server.port\");\n+        legacyProperties.put(\"dubbo.protocol.threads\", \"dubbo.service.max.thread.pool.size\");\n+        legacyProperties.put(\"dubbo.consumer.timeout\", \"dubbo.service.invoke.timeout\");\n+        legacyProperties.put(\"dubbo.consumer.retries\", \"dubbo.service.max.retry.providers\");\n+        legacyProperties.put(\"dubbo.consumer.check\", \"dubbo.service.allow.no.provider\");\n+        legacyProperties.put(\"dubbo.service.url\", \"dubbo.service.address\");\n+\n+        // this is only for compatibility\n+        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());\n+    }\n+\n+    protected String id;\n+\n+    private static String convertLegacyValue(String key, String value) {\n+        if (value != null && value.length() > 0) {\n+            if (\"dubbo.service.max.retry.providers\".equals(key)) {\n+                return String.valueOf(Integer.parseInt(value) - 1);\n+            } else if (\"dubbo.service.allow.no.provider\".equals(key)) {\n+                return String.valueOf(!Boolean.parseBoolean(value));\n+            }\n+        }\n+        return value;\n+    }\n+\n+    protected static void appendProperties(AbstractConfig config) {\n+        if (config == null) {\n+            return;\n+        }\n+        String prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\";\n+        Method[] methods = config.getClass().getMethods();\n+        for (Method method : methods) {\n+            try {\n+                String name = method.getName();\n+                if (name.length() > 3 && name.startsWith(\"set\") && Modifier.isPublic(method.getModifiers())\n+                        && method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {\n+                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\");\n+\n+                    String value = null;\n+                    if (config.getId() != null && config.getId().length() > 0) {\n+                        String pn = prefix + config.getId() + \".\" + property;\n+                        value = System.getProperty(pn);\n+                        if (!StringUtils.isBlank(value)) {\n+                            logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n+                        }\n+                    }\n+                    if (value == null || value.length() == 0) {\n+                        String pn = prefix + property;\n+                        value = System.getProperty(pn);\n+                        if (!StringUtils.isBlank(value)) {\n+                            logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n+                        }\n+                    }\n+                    if (value == null || value.length() == 0) {\n+                        Method getter;\n+                        try {\n+                            getter = config.getClass().getMethod(\"get\" + name.substring(3));\n+                        } catch (NoSuchMethodException e) {\n+                            try {\n+                                getter = config.getClass().getMethod(\"is\" + name.substring(3));\n+                            } catch (NoSuchMethodException e2) {\n+                                getter = null;\n+                            }\n+                        }\n+                        if (getter != null) {\n+                            if (getter.invoke(config) == null) {\n+                                if (config.getId() != null && config.getId().length() > 0) {\n+                                    value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property);\n+                                }\n+                                if (value == null || value.length() == 0) {\n+                                    value = ConfigUtils.getProperty(prefix + property);\n+                                }\n+                                if (value == null || value.length() == 0) {\n+                                    String legacyKey = legacyProperties.get(prefix + property);\n+                                    if (legacyKey != null && legacyKey.length() > 0) {\n+                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));\n+                                    }\n+                                }\n+\n+                            }\n+                        }\n+                    }\n+                    if (value != null && value.length() > 0) {\n+                        method.invoke(config, convertPrimitive(method.getParameterTypes()[0], value));\n+                    }\n+                }\n+            } catch (Exception e) {\n+                logger.error(e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    private static String getTagName(Class<?> cls) {\n+        String tag = cls.getSimpleName();\n+        for (String suffix : SUFFIXES) {\n+            if (tag.endsWith(suffix)) {\n+                tag = tag.substring(0, tag.length() - suffix.length());\n+                break;\n+            }\n+        }\n+        tag = tag.toLowerCase();\n+        return tag;\n+    }\n+\n+    protected static void appendParameters(Map<String, String> parameters, Object config) {\n+        appendParameters(parameters, config, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {\n+        if (config == null) {\n+            return;\n+        }\n+        Method[] methods = config.getClass().getMethods();\n+        for (Method method : methods) {\n+            try {\n+                String name = method.getName();\n+                if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n+                        && !\"getClass\".equals(name)\n+                        && Modifier.isPublic(method.getModifiers())\n+                        && method.getParameterTypes().length == 0\n+                        && isPrimitive(method.getReturnType())) {\n+                    Parameter parameter = method.getAnnotation(Parameter.class);\n+                    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {\n+                        continue;\n+                    }\n+                    int i = name.startsWith(\"get\") ? 3 : 2;\n+                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\");\n+                    String key;\n+                    if (parameter != null && parameter.key().length() > 0) {\n+                        key = parameter.key();\n+                    } else {\n+                        key = prop;\n+                    }\n+                    Object value = method.invoke(config);\n+                    String str = String.valueOf(value).trim();\n+                    if (value != null && str.length() > 0) {\n+                        if (parameter != null && parameter.escaped()) {\n+                            str = URL.encode(str);\n+                        }\n+                        if (parameter != null && parameter.append()) {\n+                            String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key);\n+                            if (pre != null && pre.length() > 0) {\n+                                str = pre + \",\" + str;\n+                            }\n+                            pre = parameters.get(key);\n+                            if (pre != null && pre.length() > 0) {\n+                                str = pre + \",\" + str;\n+                            }\n+                        }\n+                        if (prefix != null && prefix.length() > 0) {\n+                            key = prefix + \".\" + key;\n+                        }\n+                        parameters.put(key, str);\n+                    } else if (parameter != null && parameter.required()) {\n+                        throw new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\");\n+                    }\n+                } else if (\"getParameters\".equals(name)\n+                        && Modifier.isPublic(method.getModifiers())\n+                        && method.getParameterTypes().length == 0\n+                        && method.getReturnType() == Map.class) {\n+                    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);\n+                    if (map != null && map.size() > 0) {\n+                        String pre = (prefix != null && prefix.length() > 0 ? prefix + \".\" : \"\");\n+                        for (Map.Entry<String, String> entry : map.entrySet()) {\n+                            parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    protected static void appendAttributes(Map<String, Object> parameters, Object config) {\n+        appendAttributes(parameters, config, null);\n+    }\n+\n+    protected static void appendAttributes(Map<String, Object> parameters, Object config, String prefix) {\n+        if (config == null) {\n+            return;\n+        }\n+        Method[] methods = config.getClass().getMethods();\n+        for (Method method : methods) {\n+            try {\n+                Parameter parameter = method.getAnnotation(Parameter.class);\n+                if (parameter == null || !parameter.attribute()) {\n+                    continue;\n+                }\n+                String name = method.getName();\n+                if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n+                        && !\"getClass\".equals(name)\n+                        && Modifier.isPublic(method.getModifiers())\n+                        && method.getParameterTypes().length == 0\n+                        && isPrimitive(method.getReturnType())) {\n+                    String key;\n+                    if (parameter.key().length() > 0) {\n+                        key = parameter.key();\n+                    } else {\n+                        int i = name.startsWith(\"get\") ? 3 : 2;\n+                        key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\n+                    }\n+                    Object value = method.invoke(config);\n+                    if (value != null) {\n+                        if (prefix != null && prefix.length() > 0) {\n+                            key = prefix + \".\" + key;\n+                        }\n+                        parameters.put(key, value);\n+                    }\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    protected static ConsumerMethodModel.AsyncMethodInfo convertMethodConfig2AyncInfo(MethodConfig methodConfig) {\n+        if (methodConfig == null || (methodConfig.getOninvoke() == null && methodConfig.getOnreturn() == null && methodConfig.getOnthrow() == null)) {\n+            return null;\n+        }\n+\n+        //check config conflict\n+        if (Boolean.FALSE.equals(methodConfig.isReturn()) && (methodConfig.getOnreturn() != null || methodConfig.getOnthrow() != null)) {\n+            throw new IllegalStateException(\"method config error : return attribute must be set true when onreturn or onthrow has been set.\");\n+        }\n+\n+        ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = new ConsumerMethodModel.AsyncMethodInfo();\n+\n+        asyncMethodInfo.setOninvokeInstance(methodConfig.getOninvoke());\n+        asyncMethodInfo.setOnreturnInstance(methodConfig.getOnreturn());\n+        asyncMethodInfo.setOnthrowInstance(methodConfig.getOnthrow());\n+\n+        try {\n+            String oninvokeMethod = methodConfig.getOninvokeMethod();\n+            if (StringUtils.isNotEmpty(oninvokeMethod)) {\n+                asyncMethodInfo.setOninvokeMethod(getMethodByName(methodConfig.getOninvoke().getClass(), oninvokeMethod));\n+            }\n+\n+            String onreturnMethod = methodConfig.getOnreturnMethod();\n+            if (StringUtils.isNotEmpty(onreturnMethod)) {\n+                asyncMethodInfo.setOnreturnMethod(getMethodByName(methodConfig.getOnreturn().getClass(), onreturnMethod));\n+            }\n+\n+            String onthrowMethod = methodConfig.getOnthrowMethod();\n+            if (StringUtils.isNotEmpty(onthrowMethod)) {\n+                asyncMethodInfo.setOnthrowMethod(getMethodByName(methodConfig.getOnthrow().getClass(), onthrowMethod));\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e.getMessage(), e);\n+        }\n+\n+        return asyncMethodInfo;\n+    }\n+\n+    private static Method getMethodByName(Class<?> clazz, String methodName) {\n+        try {\n+            return ReflectUtils.findMethodByMethodName(clazz, methodName);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private static boolean isPrimitive(Class<?> type) {\n+        return type.isPrimitive()\n+                || type == String.class\n+                || type == Character.class\n+                || type == Boolean.class\n+                || type == Byte.class\n+                || type == Short.class\n+                || type == Integer.class\n+                || type == Long.class\n+                || type == Float.class\n+                || type == Double.class\n+                || type == Object.class;\n+    }\n+\n+    private static Object convertPrimitive(Class<?> type, String value) {\n+        if (type == char.class || type == Character.class) {\n+            return value.length() > 0 ? value.charAt(0) : '\\0';\n+        } else if (type == boolean.class || type == Boolean.class) {\n+            return Boolean.valueOf(value);\n+        } else if (type == byte.class || type == Byte.class) {\n+            return Byte.valueOf(value);\n+        } else if (type == short.class || type == Short.class) {\n+            return Short.valueOf(value);\n+        } else if (type == int.class || type == Integer.class) {\n+            return Integer.valueOf(value);\n+        } else if (type == long.class || type == Long.class) {\n+            return Long.valueOf(value);\n+        } else if (type == float.class || type == Float.class) {\n+            return Float.valueOf(value);\n+        } else if (type == double.class || type == Double.class) {\n+            return Double.valueOf(value);\n+        }\n+        return value;\n+    }\n+\n+    protected static void checkExtension(Class<?> type, String property, String value) {\n+        checkName(property, value);\n+        if (value != null && value.length() > 0\n+                && !ExtensionLoader.getExtensionLoader(type).hasExtension(value)) {\n+            throw new IllegalStateException(\"No such extension \" + value + \" for \" + property + \"/\" + type.getName());\n+        }\n+    }\n+\n+    protected static void checkMultiExtension(Class<?> type, String property, String value) {\n+        checkMultiName(property, value);\n+        if (value != null && value.length() > 0) {\n+            String[] values = value.split(\"\\\\s*[,]+\\\\s*\");\n+            for (String v : values) {\n+                if (v.startsWith(Constants.REMOVE_VALUE_PREFIX)) {\n+                    v = v.substring(1);\n+                }\n+                if (Constants.DEFAULT_KEY.equals(v)) {\n+                    continue;\n+                }\n+                if (!ExtensionLoader.getExtensionLoader(type).hasExtension(v)) {\n+                    throw new IllegalStateException(\"No such extension \" + v + \" for \" + property + \"/\" + type.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    protected static void checkLength(String property, String value) {\n+        checkProperty(property, value, MAX_LENGTH, null);\n+    }\n+\n+    protected static void checkPathLength(String property, String value) {\n+        checkProperty(property, value, MAX_PATH_LENGTH, null);\n+    }\n+\n+    protected static void checkName(String property, String value) {\n+        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME);\n+    }\n+\n+    protected static void checkNameHasSymbol(String property, String value) {\n+        checkProperty(property, value, MAX_LENGTH, PATTERN_NAME_HAS_SYMBOL);\n+    }\n+\n+    protected static void checkKey(String property, String value) {\n+        checkProperty(property, value, MAX_LENGTH, PATTERN_KEY);\n+    }\n+\n+    protected static void checkMultiName(String property, String value) {\n+        checkProperty(property, value, MAX_LENGTH, PATTERN_MULTI_NAME);\n+    }\n+\n+    protected static void checkPathName(String property, String value) {\n+        checkProperty(property, value, MAX_PATH_LENGTH, PATTERN_PATH);\n+    }\n+\n+    protected static void checkMethodName(String property, String value) {\n+        checkProperty(property, value, MAX_LENGTH, PATTERN_METHOD_NAME);\n+    }\n+\n+    protected static void checkParameterName(Map<String, String> parameters) {\n+        if (parameters == null || parameters.size() == 0) {\n+            return;\n+        }\n+        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n+            checkNameHasSymbol(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    protected static void checkProperty(String property, String value, int maxlength, Pattern pattern) {\n+        if (value == null || value.length() == 0) {\n+            return;\n+        }\n+        if (value.length() > maxlength) {\n+            throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" is longer than \" + maxlength);\n+        }\n+        if (pattern != null) {\n+            Matcher matcher = pattern.matcher(value);\n+            if (!matcher.matches()) {\n+                throw new IllegalStateException(\"Invalid \" + property + \"=\\\"\" + value + \"\\\" contains illegal \" +\n+                        \"character, only digit, letter, '-', '_' or '.' is legal.\");\n+            }\n+        }\n+    }\n+\n+    @Parameter(excluded = true)\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    protected void appendAnnotation(Class<?> annotationClass, Object annotation) {\n+        Method[] methods = annotationClass.getMethods();\n+        for (Method method : methods) {\n+            if (method.getDeclaringClass() != Object.class\n+                    && method.getReturnType() != void.class\n+                    && method.getParameterTypes().length == 0\n+                    && Modifier.isPublic(method.getModifiers())\n+                    && !Modifier.isStatic(method.getModifiers())) {\n+                try {\n+                    String property = method.getName();\n+                    if (\"interfaceClass\".equals(property) || \"interfaceName\".equals(property)) {\n+                        property = \"interface\";\n+                    }\n+                    String setter = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\n+                    Object value = method.invoke(annotation);\n+                    if (value != null && !value.equals(method.getDefaultValue())) {\n+                        Class<?> parameterType = ReflectUtils.getBoxedClass(method.getReturnType());\n+                        if (\"filter\".equals(property) || \"listener\".equals(property)) {\n+                            parameterType = String.class;\n+                            value = StringUtils.join((String[]) value, \",\");\n+                        } else if (\"parameters\".equals(property)) {\n+                            parameterType = Map.class;\n+                            value = CollectionUtils.toStringMap((String[]) value);\n+                        }\n+                        try {\n+                            Method setterMethod = getClass().getMethod(setter, parameterType);\n+                            setterMethod.invoke(this, value);\n+                        } catch (NoSuchMethodException e) {\n+                            // ignore\n+                        }\n+                    }\n+                } catch (Throwable e) {\n+                    logger.error(e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        try {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(\"<dubbo:\");\n+            buf.append(getTagName(getClass()));\n+            Method[] methods = getClass().getMethods();\n+            for (Method method : methods) {\n+                try {\n+                    String name = method.getName();\n+                    if ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n+                            && !\"getClass\".equals(name) && !\"get\".equals(name) && !\"is\".equals(name)\n+                            && Modifier.isPublic(method.getModifiers())\n+                            && method.getParameterTypes().length == 0\n+                            && isPrimitive(method.getReturnType())) {\n+                        int i = name.startsWith(\"get\") ? 3 : 2;\n+                        String key = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\n+                        Object value = method.invoke(this);\n+                        if (value != null) {\n+                            buf.append(\" \");\n+                            buf.append(key);\n+                            buf.append(\"=\\\"\");\n+                            buf.append(value);\n+                            buf.append(\"\\\"\");\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(e.getMessage(), e);\n+                }\n+            }\n+            buf.append(\" />\");\n+            return buf.toString();\n+        } catch (Throwable t) {\n+            logger.warn(t.getMessage(), t);\n+            return super.toString();\n+        }\n+    }\n+\n+}",
                "changes": 1021
            },
            {
                "status": "modified",
                "additions": 9,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java",
                "deletions": 47,
                "sha": "61ed531e141359dadfc7905a298c3e9bfcff5681",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java",
                "patch": "@@ -24,14 +24,12 @@\n import org.apache.dubbo.common.extension.ExtensionLoader;\r\n import org.apache.dubbo.common.utils.ConfigUtils;\r\n import org.apache.dubbo.common.utils.NetUtils;\r\n-import org.apache.dubbo.common.utils.ReflectUtils;\r\n import org.apache.dubbo.common.utils.StringUtils;\r\n import org.apache.dubbo.config.annotation.Reference;\r\n import org.apache.dubbo.config.support.Parameter;\r\n import org.apache.dubbo.rpc.Invoker;\r\n import org.apache.dubbo.rpc.Protocol;\r\n import org.apache.dubbo.rpc.ProxyFactory;\r\n-import org.apache.dubbo.rpc.StaticContext;\r\n import org.apache.dubbo.rpc.cluster.Cluster;\r\n import org.apache.dubbo.rpc.cluster.directory.StaticDirectory;\r\n import org.apache.dubbo.rpc.cluster.support.AvailableCluster;\r\n@@ -45,7 +43,6 @@\n import java.io.File;\r\n import java.io.FileInputStream;\r\n import java.io.IOException;\r\n-import java.lang.reflect.Method;\r\n import java.util.ArrayList;\r\n import java.util.Arrays;\r\n import java.util.HashMap;\r\n@@ -116,39 +113,6 @@ public ReferenceConfig(Reference reference) {\n         appendAnnotation(Reference.class, reference);\r\n     }\r\n \r\n-    private static void checkAndConvertImplicitConfig(MethodConfig method, Map<String, String> map, Map<Object, Object> attributes) {\r\n-        //check config conflict\r\n-        if (Boolean.FALSE.equals(method.isReturn()) && (method.getOnreturn() != null || method.getOnthrow() != null)) {\r\n-            throw new IllegalStateException(\"method config error : return attribute must be set true when onreturn or onthrow has been setted.\");\r\n-        }\r\n-        //convert onreturn methodName to Method\r\n-        String onReturnMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_RETURN_METHOD_KEY);\r\n-        Object onReturnMethod = attributes.get(onReturnMethodKey);\r\n-        if (onReturnMethod instanceof String) {\r\n-            attributes.put(onReturnMethodKey, getMethodByName(method.getOnreturn().getClass(), onReturnMethod.toString()));\r\n-        }\r\n-        //convert onthrow methodName to Method\r\n-        String onThrowMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_THROW_METHOD_KEY);\r\n-        Object onThrowMethod = attributes.get(onThrowMethodKey);\r\n-        if (onThrowMethod instanceof String) {\r\n-            attributes.put(onThrowMethodKey, getMethodByName(method.getOnthrow().getClass(), onThrowMethod.toString()));\r\n-        }\r\n-        //convert oninvoke methodName to Method\r\n-        String onInvokeMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_INVOKE_METHOD_KEY);\r\n-        Object onInvokeMethod = attributes.get(onInvokeMethodKey);\r\n-        if (onInvokeMethod instanceof String) {\r\n-            attributes.put(onInvokeMethodKey, getMethodByName(method.getOninvoke().getClass(), onInvokeMethod.toString()));\r\n-        }\r\n-    }\r\n-\r\n-    private static Method getMethodByName(Class<?> clazz, String methodName) {\r\n-        try {\r\n-            return ReflectUtils.findMethodByMethodName(clazz, methodName);\r\n-        } catch (Exception e) {\r\n-            throw new IllegalStateException(e);\r\n-        }\r\n-    }\r\n-\r\n     public URL toUrl() {\r\n         return urls.isEmpty() ? null : urls.iterator().next();\r\n     }\r\n@@ -309,23 +273,20 @@ private void init() {\n         appendParameters(map, module);\r\n         appendParameters(map, consumer, Constants.DEFAULT_KEY);\r\n         appendParameters(map, this);\r\n-        String prefix = StringUtils.getServiceKey(map);\r\n+        Map<String, Object> attributes = null;\r\n         if (methods != null && !methods.isEmpty()) {\r\n-            Map<Object, Object> attributes = new HashMap<Object, Object>();\r\n-            for (MethodConfig method : methods) {\r\n-                appendParameters(map, method, method.getName());\r\n-                String retryKey = method.getName() + \".retry\";\r\n+            attributes = new HashMap<String, Object>();\r\n+            for (MethodConfig methodConfig : methods) {\r\n+                appendParameters(map, methodConfig, methodConfig.getName());\r\n+                String retryKey = methodConfig.getName() + \".retry\";\r\n                 if (map.containsKey(retryKey)) {\r\n                     String retryValue = map.remove(retryKey);\r\n                     if (\"false\".equals(retryValue)) {\r\n-                        map.put(method.getName() + \".retries\", \"0\");\r\n+                        map.put(methodConfig.getName() + \".retries\", \"0\");\r\n                     }\r\n                 }\r\n-                appendAttributes(attributes, method, prefix + \".\" + method.getName());\r\n-                checkAndConvertImplicitConfig(method, map, attributes);\r\n+                attributes.put(methodConfig.getName(), convertMethodConfig2AyncInfo(methodConfig));\r\n             }\r\n-            //attributes are stored by system context.\r\n-            StaticContext.getSystemContext().putAll(attributes);\r\n         }\r\n \r\n         String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\r\n@@ -337,7 +298,8 @@ private void init() {\n         map.put(Constants.REGISTER_IP_KEY, hostToRegistry);\r\n \r\n         ref = createProxy(map);\r\n-        ConsumerModel consumerModel = new ConsumerModel(getUniqueServiceName(), ref, interfaceClass.getMethods());\r\n+\r\n+        ConsumerModel consumerModel = new ConsumerModel(getUniqueServiceName(), ref, interfaceClass.getMethods(), attributes);\r\n         ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\r\n     }\r\n \r",
                "changes": 56
            },
            {
                "status": "modified",
                "additions": 2,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java",
                "deletions": 2,
                "sha": "ef7354dfd2b430a84f27e850b75508f22e436776",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java",
                "patch": "@@ -141,7 +141,7 @@ public void testAppendParameters4() throws Exception {\n \n     @Test\n     public void testAppendAttributes1() throws Exception {\n-        Map<Object, Object> parameters = new HashMap<Object, Object>();\n+        Map<String, Object> parameters = new HashMap<String, Object>();\n         AbstractConfig.appendAttributes(parameters, new AttributeConfig('l', true, (byte) 0x01), \"prefix\");\n         TestCase.assertEquals('l', parameters.get(\"prefix.let\"));\n         TestCase.assertEquals(true, parameters.get(\"prefix.activate\"));\n@@ -150,7 +150,7 @@ public void testAppendAttributes1() throws Exception {\n \n     @Test\n     public void testAppendAttributes2() throws Exception {\n-        Map<Object, Object> parameters = new HashMap<Object, Object>();\n+        Map<String, Object> parameters = new HashMap<String, Object>();\n         AbstractConfig.appendAttributes(parameters, new AttributeConfig('l', true, (byte) 0x01));\n         TestCase.assertEquals('l', parameters.get(\"let\"));\n         TestCase.assertEquals(true, parameters.get(\"activate\"));",
                "changes": 4
            },
            {
                "status": "modified",
                "additions": 6,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MethodConfigTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MethodConfigTest.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MethodConfigTest.java",
                "deletions": 6,
                "sha": "8f7e8609ce7e9ffcefaf3d7982a3de589563501c",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/MethodConfigTest.java",
                "patch": "@@ -100,7 +100,7 @@ public void testOnreturn() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnreturn(\"on-return-object\");\n         assertThat(method.getOnreturn(), equalTo((Object) \"on-return-object\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_INSTANCE_KEY, (Object) \"on-return-object\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -113,7 +113,7 @@ public void testOnreturnMethod() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnreturnMethod(\"on-return-method\");\n         assertThat(method.getOnreturnMethod(), equalTo(\"on-return-method\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_RETURN_METHOD_KEY, (Object) \"on-return-method\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -126,7 +126,7 @@ public void testOnthrow() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnthrow(\"on-throw-object\");\n         assertThat(method.getOnthrow(), equalTo((Object) \"on-throw-object\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_THROW_INSTANCE_KEY, (Object) \"on-throw-object\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -139,7 +139,7 @@ public void testOnthrowMethod() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOnthrowMethod(\"on-throw-method\");\n         assertThat(method.getOnthrowMethod(), equalTo(\"on-throw-method\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_THROW_METHOD_KEY, (Object) \"on-throw-method\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -152,7 +152,7 @@ public void testOninvoke() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOninvoke(\"on-invoke-object\");\n         assertThat(method.getOninvoke(), equalTo((Object) \"on-invoke-object\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_INSTANCE_KEY, (Object) \"on-invoke-object\"));\n         Map<String, String> parameters = new HashMap<String, String>();\n@@ -165,7 +165,7 @@ public void testOninvokeMethod() throws Exception {\n         MethodConfig method = new MethodConfig();\n         method.setOninvokeMethod(\"on-invoke-method\");\n         assertThat(method.getOninvokeMethod(), equalTo(\"on-invoke-method\"));\n-        Map<Object, Object> attribute = new HashMap<Object, Object>();\n+        Map<String, Object> attribute = new HashMap<String, Object>();\n         MethodConfig.appendAttributes(attribute, method);\n         assertThat(attribute, hasEntry((Object) Constants.ON_INVOKE_METHOD_KEY, (Object) \"on-invoke-method\"));\n         Map<String, String> parameters = new HashMap<String, String>();",
                "changes": 12
            },
            {
                "status": "removed",
                "additions": 0,
                "raw_url": "https://github.com/apache/dubbo/raw/99a00ba72b53d6f740899ddb76c858b8f99683ac/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/StaticContext.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/StaticContext.java?ref=99a00ba72b53d6f740899ddb76c858b8f99683ac",
                "filename": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/StaticContext.java",
                "deletions": 75,
                "sha": "30caf571092d2e7ed41978a071265ab67dcec191",
                "blob_url": "https://github.com/apache/dubbo/blob/99a00ba72b53d6f740899ddb76c858b8f99683ac/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/StaticContext.java",
                "patch": "@@ -1,75 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc;\n-\n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.utils.StringUtils;\n-\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-/**\n- * System context, for internal use only\n- */\n-public class StaticContext extends ConcurrentHashMap<Object, Object> {\n-    private static final long serialVersionUID = 1L;\n-    private static final String SYSTEMNAME = \"system\";\n-    private static final ConcurrentMap<String, StaticContext> context_map = new ConcurrentHashMap<String, StaticContext>();\n-    private String name;\n-\n-    private StaticContext(String name) {\n-        super();\n-        this.name = name;\n-    }\n-\n-    public static StaticContext getSystemContext() {\n-        return getContext(SYSTEMNAME);\n-    }\n-\n-    public static StaticContext getContext(String name) {\n-        StaticContext appContext = context_map.get(name);\n-        if (appContext == null) {\n-            appContext = context_map.putIfAbsent(name, new StaticContext(name));\n-            if (appContext == null) {\n-                appContext = context_map.get(name);\n-            }\n-        }\n-        return appContext;\n-    }\n-\n-    public static StaticContext remove(String name) {\n-        return context_map.remove(name);\n-    }\n-\n-    public static String getKey(URL url, String methodName, String suffix) {\n-        return getKey(url.getServiceKey(), methodName, suffix);\n-    }\n-\n-    public static String getKey(Map<String, String> paras, String methodName, String suffix) {\n-        return getKey(StringUtils.getServiceKey(paras), methodName, suffix);\n-    }\n-\n-    private static String getKey(String servicekey, String methodName, String suffix) {\n-        StringBuffer sb = new StringBuffer().append(servicekey).append(\".\").append(methodName).append(\".\").append(suffix);\n-        return sb.toString();\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-}\n\\ No newline at end of file",
                "changes": 75
            },
            {
                "status": "modified",
                "additions": 9,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java",
                "deletions": 1,
                "sha": "74a52d7c4c7f47cfa86182c706ef148c680b030d",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java",
                "patch": "@@ -23,7 +23,15 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n \n-// adjust project structure in order to fully utilize the methods introduced here.\n+/**\n+ * Represent a application which is using Dubbo and store basic metadata info for using\n+ * during the processing of RPC invoking.\n+ *\n+ * ApplicationModel includes many ProviderModel which is about published services\n+ * and many Consumer Model which is about subscribed services.\n+ *\n+ * adjust project structure in order to fully utilize the methods introduced here.\n+ */\n public class ApplicationModel {\n \n     protected static final Logger LOGGER = LoggerFactory.getLogger(ApplicationModel.class);",
                "changes": 10
            },
            {
                "status": "modified",
                "additions": 83,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java",
                "deletions": 1,
                "sha": "5a871cecc635413af5d499ead0e3cd166726b62c",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java",
                "patch": "@@ -19,6 +19,7 @@\n import org.apache.dubbo.common.Constants;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n \n public class ConsumerMethodModel {\n     private final Method method;\n@@ -30,13 +31,22 @@\n     private final String methodName;\n     private final boolean generic;\n \n-    public ConsumerMethodModel(Method method) {\n+    private final AsyncMethodInfo asyncInfo;\n+\n+\n+    public ConsumerMethodModel(Method method, Map<String, Object> attributes) {\n         this.method = method;\n         this.parameterClasses = method.getParameterTypes();\n         this.returnClass = method.getReturnType();\n         this.parameterTypes = this.createParamSignature(parameterClasses);\n         this.methodName = method.getName();\n         this.generic = methodName.equals(Constants.$INVOKE) && parameterTypes != null && parameterTypes.length == 3;\n+\n+        if (attributes != null) {\n+            asyncInfo = (AsyncMethodInfo) attributes.get(methodName);\n+        } else {\n+            asyncInfo = null;\n+        }\n     }\n \n     public Method getMethod() {\n@@ -47,6 +57,9 @@ public Method getMethod() {\n         return returnClass;\n     }\n \n+    public AsyncMethodInfo getAsyncInfo() {\n+        return asyncInfo;\n+    }\n \n     public String getMethodName() {\n         return methodName;\n@@ -75,4 +88,73 @@ public boolean isGeneric() {\n     public Class<?>[] getParameterClasses() {\n         return parameterClasses;\n     }\n+\n+\n+    public static class AsyncMethodInfo {\n+        // callback instance when async-call is invoked\n+        private Object oninvokeInstance;\n+\n+        // callback method when async-call is invoked\n+        private Method oninvokeMethod;\n+\n+        // callback instance when async-call is returned\n+        private Object onreturnInstance;\n+\n+        // callback method when async-call is returned\n+        private Method onreturnMethod;\n+\n+        // callback instance when async-call has exception thrown\n+        private Object onthrowInstance;\n+\n+        // callback method when async-call has exception thrown\n+        private Method onthrowMethod;\n+\n+        public Object getOninvokeInstance() {\n+            return oninvokeInstance;\n+        }\n+\n+        public void setOninvokeInstance(Object oninvokeInstance) {\n+            this.oninvokeInstance = oninvokeInstance;\n+        }\n+\n+        public Method getOninvokeMethod() {\n+            return oninvokeMethod;\n+        }\n+\n+        public void setOninvokeMethod(Method oninvokeMethod) {\n+            this.oninvokeMethod = oninvokeMethod;\n+        }\n+\n+        public Object getOnreturnInstance() {\n+            return onreturnInstance;\n+        }\n+\n+        public void setOnreturnInstance(Object onreturnInstance) {\n+            this.onreturnInstance = onreturnInstance;\n+        }\n+\n+        public Method getOnreturnMethod() {\n+            return onreturnMethod;\n+        }\n+\n+        public void setOnreturnMethod(Method onreturnMethod) {\n+            this.onreturnMethod = onreturnMethod;\n+        }\n+\n+        public Object getOnthrowInstance() {\n+            return onthrowInstance;\n+        }\n+\n+        public void setOnthrowInstance(Object onthrowInstance) {\n+            this.onthrowInstance = onthrowInstance;\n+        }\n+\n+        public Method getOnthrowMethod() {\n+            return onthrowMethod;\n+        }\n+\n+        public void setOnthrowMethod(Method onthrowMethod) {\n+            this.onthrowMethod = onthrowMethod;\n+        }\n+    }\n }",
                "changes": 84
            },
            {
                "status": "modified",
                "additions": 17,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java",
                "deletions": 2,
                "sha": "398bc91bd21df56014d02f1e5c5fab1caa88c3a4",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java",
                "patch": "@@ -21,20 +21,24 @@\n import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n \n+/**\n+ * Consumer Model which is about subscribed services.\n+ */\n public class ConsumerModel {\n     private final Object proxyObject;\n     private final String serviceName;\n \n     private final Map<Method, ConsumerMethodModel> methodModels = new IdentityHashMap<Method, ConsumerMethodModel>();\n \n-    public ConsumerModel(String serviceName, Object proxyObject, Method[] methods) {\n+    public ConsumerModel(String serviceName, Object proxyObject, Method[] methods, Map<String, Object> attributes) {\n         this.serviceName = serviceName;\n         this.proxyObject = proxyObject;\n \n         if (proxyObject != null) {\n             for (Method method : methods) {\n-                methodModels.put(method, new ConsumerMethodModel(method));\n+                methodModels.put(method, new ConsumerMethodModel(method, attributes));\n             }\n         }\n     }\n@@ -53,6 +57,17 @@ public ConsumerMethodModel getMethodModel(Method method) {\n         return methodModels.get(method);\n     }\n \n+    /**\n+     * Return method model for the given method on consumer side\n+     *\n+     * @param method method object\n+     * @return method model\n+     */\n+    public ConsumerMethodModel getMethodModel(String method) {\n+        Optional<Map.Entry<Method, ConsumerMethodModel>> consumerMethodModelEntry = methodModels.entrySet().stream().filter(entry -> entry.getKey().getName().equals(method)).findFirst();\n+        return consumerMethodModelEntry.map(Map.Entry::getValue).orElse(null);\n+    }\n+\n     /**\n      * Return all method models for the current service\n      *",
                "changes": 19
            },
            {
                "status": "modified",
                "additions": 3,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java",
                "deletions": 0,
                "sha": "6fb9bebd7ea2688a71772beedd742e6c59831872",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java",
                "patch": "@@ -23,6 +23,9 @@\n import java.util.List;\n import java.util.Map;\n \n+/**\n+ * ProviderModel which is about published services\n+ */\n public class ProviderModel {\n     private final String serviceName;\n     private final Object serviceInstance;",
                "changes": 3
            },
            {
                "status": "removed",
                "additions": 0,
                "raw_url": "https://github.com/apache/dubbo/raw/99a00ba72b53d6f740899ddb76c858b8f99683ac/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/StaticContextTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/StaticContextTest.java?ref=99a00ba72b53d6f740899ddb76c858b8f99683ac",
                "filename": "dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/StaticContextTest.java",
                "deletions": 64,
                "sha": "723b1be1e4639a0fd6ecd3edfb96d45e10b004a7",
                "blob_url": "https://github.com/apache/dubbo/blob/99a00ba72b53d6f740899ddb76c858b8f99683ac/dubbo-rpc/dubbo-rpc-api/src/test/java/org/apache/dubbo/rpc/StaticContextTest.java",
                "patch": "@@ -1,64 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.rpc;\n-\n-import org.apache.dubbo.common.Constants;\n-import org.apache.dubbo.common.URL;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class StaticContextTest {\n-\n-    @Test\n-    public void testGetContext() {\n-        String name = \"custom\";\n-\n-        StaticContext context = StaticContext.getContext(name);\n-        Assert.assertTrue(context != null);\n-        Assert.assertEquals(name, context.getName());\n-\n-        StaticContext.remove(name);\n-\n-        StaticContext sysContext = StaticContext.getSystemContext();\n-        Assert.assertTrue(sysContext != null);\n-\n-    }\n-\n-    @Test\n-    public void testGetKey() {\n-        String interfaceName = \"interface\";\n-        String method = \"method\";\n-        String group = \"group\";\n-        String version = \"1.0\";\n-\n-        String suffix = \"suffix\";\n-\n-        Map<String, String> para = new HashMap<>();\n-        para.put(Constants.INTERFACE_KEY, interfaceName);\n-        para.put(Constants.GROUP_KEY, group);\n-        para.put(Constants.VERSION_KEY, version);\n-\n-        URL url = new URL(\"dubbo\", \"localhost\", 20880, interfaceName, para);\n-\n-        Assert.assertEquals(StaticContext.getKey(url, method, suffix),\n-                StaticContext.getKey(para, method, suffix));\n-\n-    }\n-}",
                "changes": 64
            },
            {
                "status": "modified",
                "additions": 40,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java",
                "deletions": 8,
                "sha": "f101ed84277b2ec583338bab58688df7edfb2483",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java",
                "patch": "@@ -26,7 +26,9 @@\n import org.apache.dubbo.rpc.PostProcessFilter;\n import org.apache.dubbo.rpc.Result;\n import org.apache.dubbo.rpc.RpcException;\n-import org.apache.dubbo.rpc.StaticContext;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n+import org.apache.dubbo.rpc.model.ConsumerModel;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n@@ -79,14 +81,18 @@ private void asyncCallback(final Invoker<?> invoker, final Invocation invocation\n     }\n \n     private void fireInvokeCallback(final Invoker<?> invoker, final Invocation invocation) {\n-        final Method onInvokeMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_METHOD_KEY));\n-        final Object onInvokeInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_INSTANCE_KEY));\n+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = getAsyncMethodInfo(invoker, invocation);\n+        if (asyncMethodInfo == null) {\n+            return;\n+        }\n+        final Method onInvokeMethod = asyncMethodInfo.getOninvokeMethod();\n+        final Object onInvokeInst = asyncMethodInfo.getOninvokeInstance();\n \n         if (onInvokeMethod == null && onInvokeInst == null) {\n             return;\n         }\n         if (onInvokeMethod == null || onInvokeInst == null) {\n-            throw new IllegalStateException(\"service:\" + invoker.getUrl().getServiceKey() + \" has a onreturn callback config , but no such \" + (onInvokeMethod == null ? \"method\" : \"instance\") + \" found. url:\" + invoker.getUrl());\n+            throw new IllegalStateException(\"service:\" + invoker.getUrl().getServiceKey() + \" has a oninvoke callback config , but no such \" + (onInvokeMethod == null ? \"method\" : \"instance\") + \" found. url:\" + invoker.getUrl());\n         }\n         if (!onInvokeMethod.isAccessible()) {\n             onInvokeMethod.setAccessible(true);\n@@ -103,8 +109,13 @@ private void fireInvokeCallback(final Invoker<?> invoker, final Invocation invoc\n     }\n \n     private void fireReturnCallback(final Invoker<?> invoker, final Invocation invocation, final Object result) {\n-        final Method onReturnMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_METHOD_KEY));\n-        final Object onReturnInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_INSTANCE_KEY));\n+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = getAsyncMethodInfo(invoker, invocation);\n+        if (asyncMethodInfo == null) {\n+            return;\n+        }\n+\n+        final Method onReturnMethod = asyncMethodInfo.getOnreturnMethod();\n+        final Object onReturnInst = asyncMethodInfo.getOnreturnInstance();\n \n         //not set onreturn callback\n         if (onReturnMethod == null && onReturnInst == null) {\n@@ -144,8 +155,13 @@ private void fireReturnCallback(final Invoker<?> invoker, final Invocation invoc\n     }\n \n     private void fireThrowCallback(final Invoker<?> invoker, final Invocation invocation, final Throwable exception) {\n-        final Method onthrowMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_METHOD_KEY));\n-        final Object onthrowInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_INSTANCE_KEY));\n+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = getAsyncMethodInfo(invoker, invocation);\n+        if (asyncMethodInfo == null) {\n+            return;\n+        }\n+\n+        final Method onthrowMethod = asyncMethodInfo.getOnthrowMethod();\n+        final Object onthrowInst = asyncMethodInfo.getOnthrowInstance();\n \n         //onthrow callback not configured\n         if (onthrowMethod == null && onthrowInst == null) {\n@@ -184,4 +200,20 @@ private void fireThrowCallback(final Invoker<?> invoker, final Invocation invoca\n             logger.error(invocation.getMethodName() + \".call back method invoke error . callback method :\" + onthrowMethod + \", url:\" + invoker.getUrl(), exception);\n         }\n     }\n+\n+    private ConsumerMethodModel.AsyncMethodInfo getAsyncMethodInfo(Invoker<?> invoker, Invocation invocation) {\n+        final ConsumerModel consumerModel = ApplicationModel.getConsumerModel(invoker.getUrl().getServiceKey());\n+        if (consumerModel == null) {\n+            return null;\n+        }\n+        ConsumerMethodModel methodModel = consumerModel.getMethodModel(invocation.getMethodName());\n+        if (methodModel == null) {\n+            return null;\n+        }\n+        final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = methodModel.getAsyncInfo();\n+        if (asyncMethodInfo == null) {\n+            return null;\n+        }\n+        return asyncMethodInfo;\n+    }\n }",
                "changes": 48
            },
            {
                "status": "modified",
                "additions": 38,
                "raw_url": "https://github.com/apache/dubbo/raw/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java",
                "contents_url": "https://api.github.com/repos/apache/dubbo/contents/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java?ref=36a1155bbed8cb31d2b6b4a10908fdef0acd02c9",
                "filename": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java",
                "deletions": 37,
                "sha": "4c5308caf2eb69b156eb607f5ed1f31302d0ff68",
                "blob_url": "https://github.com/apache/dubbo/blob/36a1155bbed8cb31d2b6b4a10908fdef0acd02c9/dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/ImplicitCallBackTest.java",
                "patch": "@@ -23,7 +23,9 @@\n import org.apache.dubbo.rpc.Exporter;\n import org.apache.dubbo.rpc.Invoker;\n import org.apache.dubbo.rpc.RpcContext;\n-import org.apache.dubbo.rpc.StaticContext;\n+import org.apache.dubbo.rpc.model.ApplicationModel;\n+import org.apache.dubbo.rpc.model.ConsumerMethodModel;\n+import org.apache.dubbo.rpc.model.ConsumerModel;\n import org.apache.dubbo.rpc.protocol.dubbo.support.ProtocolUtils;\n import org.junit.After;\n import org.junit.Assert;\n@@ -72,6 +74,12 @@ public void initOrResetService() {\n         referService();\n     }\n \n+    public void initOrResetExService() {\n+        destroyService();\n+        exportExService();\n+        referService();\n+    }\n+\n     public void destroyService() {\n         demoProxy = null;\n         try {\n@@ -95,26 +103,36 @@ public void exportExService() {\n \n     public void initOrResetUrl(boolean isAsync) throws Exception {\n         int port = NetUtils.getAvailablePort();\n-        consumerUrl = serviceURL = URL.valueOf(\"dubbo://127.0.0.1:\" + port + \"/\" + IDemoService.class.getName() + \"?group=test&async=\" + isAsync + \"&timeout=100000&reference.filter=future\");\n-        StaticContext.getSystemContext().clear();\n+        consumerUrl = serviceURL = URL.valueOf(\"dubbo://127.0.0.1:\" + port + \"/\" + IDemoService.class.getName() + \"?group=\" + System.nanoTime() + \"&async=\" + isAsync + \"&timeout=100000&reference.filter=future\");\n     }\n \n     public void initImplicitCallBackURL_onlyOnthrow() throws Exception {\n-        StaticContext.getSystemContext().put(StaticContext.getKey(consumerUrl, \"get\", Constants.ON_THROW_METHOD_KEY), onThrowMethod);\n-        StaticContext.getSystemContext().put(StaticContext.getKey(consumerUrl, \"get\", Constants.ON_THROW_INSTANCE_KEY), notify);\n+        Map<String, Object> attitudes = new HashMap<>();\n+        ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = new ConsumerMethodModel.AsyncMethodInfo();\n+        asyncMethodInfo.setOnthrowInstance(notify);\n+        asyncMethodInfo.setOnthrowMethod(onThrowMethod);\n+        attitudes.put(\"get\", asyncMethodInfo);\n+        ApplicationModel.initConsumerModel(consumerUrl.getServiceKey(), new ConsumerModel(consumerUrl.getServiceKey(), demoProxy, IDemoService.class.getMethods(), attitudes));\n     }\n \n     //================================================================================================\n \n     public void initImplicitCallBackURL_onlyOnreturn() throws Exception {\n-        StaticContext.getSystemContext().put(StaticContext.getKey(consumerUrl, \"get\", Constants.ON_RETURN_METHOD_KEY), onReturnMethod);\n-        StaticContext.getSystemContext().put(StaticContext.getKey(consumerUrl, \"get\", Constants.ON_RETURN_INSTANCE_KEY), notify);\n-\n+        Map<String, Object> attitudes = new HashMap<>();\n+        ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = new ConsumerMethodModel.AsyncMethodInfo();\n+        asyncMethodInfo.setOnreturnInstance(notify);\n+        asyncMethodInfo.setOnreturnMethod(onReturnMethod);\n+        attitudes.put(\"get\", asyncMethodInfo);\n+        ApplicationModel.initConsumerModel(consumerUrl.getServiceKey(), new ConsumerModel(consumerUrl.getServiceKey(), demoProxy, IDemoService.class.getMethods(), attitudes));\n     }\n \n     public void initImplicitCallBackURL_onlyOninvoke() throws Exception {\n-        StaticContext.getSystemContext().put(StaticContext.getKey(consumerUrl, \"get\", Constants.ON_INVOKE_METHOD_KEY), onInvokeMethod);\n-        StaticContext.getSystemContext().put(StaticContext.getKey(consumerUrl, \"get\", Constants.ON_INVOKE_INSTANCE_KEY), notify);\n+        Map<String, Object> attitudes = new HashMap<>();\n+        ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo = new ConsumerMethodModel.AsyncMethodInfo();\n+        asyncMethodInfo.setOninvokeInstance(notify);\n+        asyncMethodInfo.setOninvokeMethod(onInvokeMethod);\n+        attitudes.put(\"get\", asyncMethodInfo);\n+        ApplicationModel.initConsumerModel(consumerUrl.getServiceKey(), new ConsumerModel(consumerUrl.getServiceKey(), demoProxy, IDemoService.class.getMethods(), attitudes));\n     }\n \n     @Test\n@@ -129,8 +147,9 @@ public void test_CloseCallback() throws Exception {\n     @Test\n     public void test_Sync_Onreturn() throws Exception {\n         initOrResetUrl(false);\n-        initImplicitCallBackURL_onlyOnreturn();\n         initOrResetService();\n+        initImplicitCallBackURL_onlyOnreturn();\n+\n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);\n         Assert.assertEquals(requestId, ret.getId());\n@@ -148,11 +167,9 @@ public void test_Sync_Onreturn() throws Exception {\n     @Test\n     public void test_Ex_OnReturn() throws Exception {\n         initOrResetUrl(true);\n+        initOrResetExService();\n         initImplicitCallBackURL_onlyOnreturn();\n \n-        destroyService();\n-        exportExService();\n-        referService();\n \n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);\n@@ -171,12 +188,9 @@ public void test_Ex_OnReturn() throws Exception {\n     @Test\n     public void test_Ex_OnInvoke() throws Exception {\n         initOrResetUrl(true);\n+        initOrResetExService();\n         initImplicitCallBackURL_onlyOninvoke();\n \n-        destroyService();\n-        exportExService();\n-        referService();\n-\n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);\n         Assert.assertEquals(null, ret);\n@@ -194,12 +208,9 @@ public void test_Ex_OnInvoke() throws Exception {\n     @Test\n     public void test_Ex_Onthrow() throws Exception {\n         initOrResetUrl(true);\n+        initOrResetExService();\n         initImplicitCallBackURL_onlyOnthrow();\n \n-        destroyService();\n-        exportExService();\n-        referService();\n-\n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);\n         Assert.assertEquals(null, ret);\n@@ -218,10 +229,8 @@ public void test_Ex_Onthrow() throws Exception {\n     @Test\n     public void test_Sync_NoFuture() throws Exception {\n         initOrResetUrl(false);\n+        initOrResetService();\n         initImplicitCallBackURL_onlyOnreturn();\n-        destroyService();\n-        exportService();\n-        referService();\n \n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);\n@@ -234,9 +243,7 @@ public void test_Sync_NoFuture() throws Exception {\n     @Test\n     public void test_Async_Future() throws Exception {\n         initOrResetUrl(true);\n-        destroyService();\n-        exportService();\n-        referService();\n+        initOrResetService();\n \n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);\n@@ -250,9 +257,7 @@ public void test_Async_Future() throws Exception {\n     @Test\n     public void test_Async_Future_Multi() throws Exception {\n         initOrResetUrl(true);\n-        destroyService();\n-        exportService();\n-        referService();\n+        initOrResetService();\n \n         int requestId1 = 1;\n         Person ret = demoProxy.get(requestId1);\n@@ -275,9 +280,7 @@ public void test_Async_Future_Multi() throws Exception {\n     public void test_Async_Future_Ex() throws Throwable {\n         try {\n             initOrResetUrl(true);\n-            destroyService();\n-            exportExService();\n-            referService();\n+            initOrResetExService();\n \n             int requestId = 2;\n             Person ret = demoProxy.get(requestId);\n@@ -295,9 +298,7 @@ public void test_Async_Future_Ex() throws Throwable {\n     @Test(expected = RuntimeException.class)\n     public void test_Normal_Ex() throws Exception {\n         initOrResetUrl(false);\n-        destroyService();\n-        exportExService();\n-        referService();\n+        initOrResetExService();\n \n         int requestId = 2;\n         Person ret = demoProxy.get(requestId);",
                "changes": 75
            }
        ],
        "unit_tests": [
            "AbstractConfigTest.java",
            "MethodConfigTest.java",
            "ImplicitCallBackTest.java",
            "AbstractClusterInvokerTest.java",
            "ReferenceConfigTest.java",
            "TagRouterTest.java",
            "FutureFilterTest.java",
            "StaticContextTest.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/AbstractConfigTest.java",
        "buggy_files": [
            "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java",
            "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/MethodConfig.java",
            "dubbo-compatible/src/main/java/com/alibaba/dubbo/config/MethodConfig.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java",
            "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java",
            "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java",
            "dubbo-compatible/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java",
            "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java",
            "dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java"
        ],
        "fixed": true
    },
    {
        "buggy": false,
        "test_file": "dubbo-compatible/src/test/java/org/apache/dubbo/config/ReferenceConfigTest.java",
        "buggy_files": [
            "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AbstractClusterInvoker.java",
            "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/MethodConfig.java",
            "dubbo-compatible/src/main/java/com/alibaba/dubbo/config/MethodConfig.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerMethodModel.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ConsumerModel.java",
            "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagRouter.java",
            "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java",
            "dubbo-compatible/src/main/java/com/alibaba/dubbo/config/ReferenceConfig.java",
            "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/AbstractConfig.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java",
            "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/model/ProviderModel.java",
            "dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java"
        ],
        "fixed": true
    }
]