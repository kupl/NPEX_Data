{
    "mina_2eb3067": {
        "bug_id": "mina_2eb3067",
        "commit": "https://github.com/apache/mina/commit/2eb3067109a5661951862f9ebf199ccec8ed007c",
        "file": [
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/mina/blob/2eb3067109a5661951862f9ebf199ccec8ed007c/core/src/main/java/org/apache/mina/common/AbstractIoSession.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/mina/contents/core/src/main/java/org/apache/mina/common/AbstractIoSession.java?ref=2eb3067109a5661951862f9ebf199ccec8ed007c",
                "deletions": 6,
                "filename": "core/src/main/java/org/apache/mina/common/AbstractIoSession.java",
                "patch": "@@ -245,18 +245,25 @@ private ReadFuture newReadFuture() {\n             if (oldReadyReadFutures != null) {\n                 readyReadFutures = oldReadyReadFutures;\n             }\n-\n-            // Initialize waitingReadFutures together.\n-            Queue<ReadFuture> waitingReadFutures =\n-                new CircularQueue<ReadFuture>();\n-            setAttributeIfAbsent(WAITING_READ_FUTURES, waitingReadFutures);\n         }\n         return readyReadFutures;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     private Queue<ReadFuture> getWaitingReadFutures() {\n-        return (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES);\n+        Queue<ReadFuture> waitingReadyReadFutures =\n+            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES);\n+        if (waitingReadyReadFutures == null) {\n+            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n+\n+            Queue<ReadFuture> oldWaitingReadyReadFutures =\n+                (Queue<ReadFuture>) setAttributeIfAbsent(\n+                        WAITING_READ_FUTURES, waitingReadyReadFutures);\n+            if (oldWaitingReadyReadFutures != null) {\n+                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n+            }\n+        }\n+        return waitingReadyReadFutures;\n     }\n \n     public final WriteFuture write(Object message) {",
                "raw_url": "https://github.com/apache/mina/raw/2eb3067109a5661951862f9ebf199ccec8ed007c/core/src/main/java/org/apache/mina/common/AbstractIoSession.java",
                "sha": "ae2f77c86bc3af25bc63b05ec47f7ce3fd304dfa",
                "status": "modified"
            }
        ],
        "message": "Fixed issue: DIRMINA-567 - NPE in AbstractIoSession after getWaitingReadFutures\n* Applied the same lazy initialization technique to getWaitingReadFutures as I did in getReadFutures\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/trunk@645798 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/mina/commit/42eb2517c086fe67ac56b5c5705812851f6a3aa4",
        "patched_files": [
            "AbstractIoSession.java"
        ],
        "repo": "mina",
        "unit_tests": [
            "AbstractIoSessionTest.java"
        ]
    },
    "mina_d1667c1": {
        "bug_id": "mina_d1667c1",
        "commit": "https://github.com/apache/mina/commit/d1667c18bddf6527aa8a920db7947489fcb4fe53",
        "file": [
            {
                "additions": 187,
                "blob_url": "https://github.com/apache/mina/blob/d1667c18bddf6527aa8a920db7947489fcb4fe53/core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java",
                "changes": 211,
                "contents_url": "https://api.github.com/repos/apache/mina/contents/core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java?ref=d1667c18bddf6527aa8a920db7947489fcb4fe53",
                "deletions": 24,
                "filename": "core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java",
                "patch": "@@ -55,17 +55,35 @@\n     private final AttributeKey ENCODER = new AttributeKey(getClass(), \"encoder\");\n     private final AttributeKey DECODER = new AttributeKey(getClass(), \"decoder\");\n     private final AttributeKey DECODER_OUT = new AttributeKey(getClass(), \"decoderOut\");\n+    \n+    /** The factory responsible for creating the encoder and decoder */\n     private final ProtocolCodecFactory factory;\n \n     private final Logger logger = LoggerFactory.getLogger(getClass());\n \n+    /**\n+     * \n+     * Creates a new instance of ProtocolCodecFilter, associating a factory\n+     * for the creation of the encoder and decoder.\n+     *\n+     * @param factory The associated factory\n+     */\n     public ProtocolCodecFilter(ProtocolCodecFactory factory) {\n         if (factory == null) {\n             throw new NullPointerException(\"factory\");\n         }\n         this.factory = factory;\n     }\n \n+    \n+    /**\n+     * Creates a new instance of ProtocolCodecFilter, without any factory.\n+     * The encoder/decoder factory will be created as an inner class, using\n+     * the two parameters (encoder and decoder). \n+     * \n+     * @param encoder The class responsible for encoding the message\n+     * @param decoder The class responsible for decoding the message\n+     */\n     public ProtocolCodecFilter(final ProtocolEncoder encoder,\n             final ProtocolDecoder decoder) {\n         if (encoder == null) {\n@@ -75,6 +93,7 @@ public ProtocolCodecFilter(final ProtocolEncoder encoder,\n             throw new NullPointerException(\"decoder\");\n         }\n \n+        // Create the inner Factory based on the two parameters\n         this.factory = new ProtocolCodecFactory() {\n             public ProtocolEncoder getEncoder(IoSession session) {\n                 return encoder;\n@@ -86,6 +105,15 @@ public ProtocolDecoder getDecoder(IoSession session) {\n         };\n     }\n \n+    /**\n+     * Creates a new instance of ProtocolCodecFilter, without any factory.\n+     * The encoder/decoder factory will be created as an inner class, using\n+     * the two parameters (encoder and decoder), which are class names. Instances\n+     * for those classes will be created in this constructor.\n+     * \n+     * @param encoder The class responsible for encoding the message\n+     * @param decoder The class responsible for decoding the message\n+     */\n     public ProtocolCodecFilter(\n             final Class<? extends ProtocolEncoder> encoderClass,\n             final Class<? extends ProtocolDecoder> decoderClass) {\n@@ -116,6 +144,8 @@ public ProtocolCodecFilter(\n                     \"decoderClass doesn't have a public default constructor.\");\n         }\n \n+        // Create the inner Factory based on the two parameters. We instanciate\n+        // the encoder and decoder locally.\n         this.factory = new ProtocolCodecFactory() {\n             public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n                 return encoderClass.newInstance();\n@@ -127,10 +157,23 @@ public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n         };\n     }\n \n+    \n+    /**\n+     * Get the encoder instance from a given session.\n+     *\n+     * @param session The associated session we will get the encoder from\n+     * @return The encoder instance, if any\n+     */\n     public ProtocolEncoder getEncoder(IoSession session) {\n         return (ProtocolEncoder) session.getAttribute(ENCODER);\n     }\n \n+    /**\n+     * Get the decoder instance from a given session.\n+     *\n+     * @param session The associated session we will get the decoder from\n+     * @return The decoder instance\n+     */\n     public ProtocolDecoder getDecoder(IoSession session) {\n         return (ProtocolDecoder) session.getAttribute(DECODER);\n     }\n@@ -147,11 +190,27 @@ public void onPreAdd(IoFilterChain parent, String name,\n     @Override\n     public void onPostRemove(IoFilterChain parent, String name,\n             NextFilter nextFilter) throws Exception {\n+        // We just remove the two instances of encoder/decoder to release resources\n+        // from the session\n         disposeEncoder(parent.getSession());\n         disposeDecoder(parent.getSession());\n+        \n+        // We also remove the callback  \n         disposeDecoderOut(parent.getSession());\n     }\n \n+    /**\n+     * Process the incoming message, calling the session decoder. As the incoming\n+     * buffer might contains more than one messages, we have to loop until the decoder\n+     * throws an exception.\n+     * \n+     *  while ( buffer not empty )\n+     *    try \n+     *      decode ( buffer )\n+     *    catch\n+     *      break;\n+     *    \n+     */\n     @Override\n     public void messageReceived(NextFilter nextFilter, IoSession session,\n             Object message) throws Exception {\n@@ -161,17 +220,52 @@ public void messageReceived(NextFilter nextFilter, IoSession session,\n         }\n \n         IoBuffer in = (IoBuffer) message;\n-        ProtocolDecoder decoder = getDecoder0(session);\n+        ProtocolDecoder decoder = getDecoder(session);\n+        \n+        if ( decoder == null) {\n+            // The decoder must not be null. It's null if\n+            // the sessionCreated message has not be called, for\n+            // instance if the filter has been added after the \n+            // first session is created.\n+            ProtocolDecoderException pde = new ProtocolDecoderException(\n+                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n+                \"before the first session is created\" ); \n+            nextFilter.exceptionCaught(session, pde);\n+            return;\n+        }\n+        \n         ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n+        \n+        if ( decoderOut == null) {\n+            // The decoderOut must not be null. It's null if\n+            // the sessionCreated message has not be called, for\n+            // instance if the filter has been added after the \n+            // first session is created.\n+            ProtocolDecoderException pde = new ProtocolDecoderException(\n+                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n+                \"before the first session is created\" ); \n+            nextFilter.exceptionCaught(session, pde);\n+            return;\n+        }\n+        \n \n+        // Loop until we don't have anymore byte in the buffer,\n+        // or until the decoder throws an unrecoverable exception or \n+        // can't decoder a message, because there are not enough \n+        // data in the buffer\n         while (in.hasRemaining()) {\n             int oldPos = in.position();\n             try {\n                 synchronized (decoderOut) {\n+                    // Call the decoder with the read bytes\n                     decoder.decode(session, in, decoderOut);\n                 }\n                 // Finish decoding if no exception was thrown.\n                 decoderOut.flush();\n+                \n+                // TODO :\n+                // here, we shouldn't break,\n+                // we should loop to decode the next portion of the buffer.\n                 break;\n             } catch (Throwable t) {\n                 ProtocolDecoderException pde;\n@@ -182,6 +276,7 @@ public void messageReceived(NextFilter nextFilter, IoSession session,\n                 }\n                 \n                 if (pde.getHexdump() == null) {\n+                    // Generate a message hex dump\n                     int curPos = in.position();\n                     in.position(oldPos);\n                     pde.setHexdump(in.getHexDump());\n@@ -197,7 +292,7 @@ public void messageReceived(NextFilter nextFilter, IoSession session,\n                 // We check buffer position additionally to prevent an\n                 // infinite loop.\n                 if (!(t instanceof RecoverableProtocolDecoderException) ||\n-                        in.position() == oldPos) {\n+                        (in.position() == oldPos)) {\n                     break;\n                 }\n             }\n@@ -224,37 +319,125 @@ public void messageSent(NextFilter nextFilter, IoSession session,\n     public void filterWrite(NextFilter nextFilter, IoSession session,\n             WriteRequest writeRequest) throws Exception {\n         Object message = writeRequest.getMessage();\n+        \n+        // Bypass the encoding if the message is contained in a ByteBuffer,\n+        // as it has already been encoded before\n         if (message instanceof IoBuffer || message instanceof FileRegion) {\n             nextFilter.filterWrite(session, writeRequest);\n             return;\n         }\n \n-        ProtocolEncoder encoder = getEncoder0(session);\n+        // Get the encoder in the session\n+        ProtocolEncoder encoder = getEncoder(session);\n+\n+        if ( encoder == null) {\n+            // The encoder must not be null. It's null if\n+            // the sessionCreated message has not be called, for\n+            // instance if the filter has been added after the \n+            // first session is created.\n+            ProtocolDecoderException pde = new ProtocolDecoderException(\n+                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n+                \"before the first session is created\" ); \n+            nextFilter.exceptionCaught(session, pde);\n+            return;\n+        }\n+        \n         ProtocolEncoderOutputImpl encoderOut = getEncoderOut(session,\n                 nextFilter, writeRequest);\n \n+        if ( encoderOut == null) {\n+            // The encoder must not be null. It's null if\n+            // the sessionCreated message has not be called, for\n+            // instance if the filter has been added after the \n+            // first session is created.\n+            ProtocolDecoderException pde = new ProtocolDecoderException(\n+                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n+                \"before the first session is created\" ); \n+            nextFilter.exceptionCaught(session, pde);\n+            return;\n+        }\n+        \n         try {\n+            // Now we can try to encode the response\n             encoder.encode(session, message, encoderOut);\n+            \n+            // Send it directly\n             encoderOut.flushWithoutFuture();\n+            \n+            // Call the next filter\n             nextFilter.filterWrite(session, new MessageWriteRequest(\n                     writeRequest));\n         } catch (Throwable t) {\n             ProtocolEncoderException pee;\n+            \n+            // Generate the correct exception\n             if (t instanceof ProtocolEncoderException) {\n                 pee = (ProtocolEncoderException) t;\n             } else {\n                 pee = new ProtocolEncoderException(t);\n             }\n+            \n             throw pee;\n         }\n     }\n+    \n+    /**\n+     * Associate a decoder and encoder instances to the newly created session.\n+     * <br>\n+     * <br>\n+     * In order to get the encoder and decoder crea\n+     * \n+     * @param nextFilter The next filter to invoke when having processed the current \n+     * method\n+     * @param session The newly created session\n+     * @throws Exception if we can't create instances of the decoder or encoder\n+     */\n+    @Override\n+    public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception {\n+        // Creates the decoder and stores it into the newly created session \n+        ProtocolDecoder decoder = factory.getDecoder(session);\n+        session.setAttribute(DECODER, decoder);\n+\n+        // Creates the encoder and stores it into the newly created session \n+        ProtocolEncoder encoder = factory.getEncoder(session);\n+        session.setAttribute(ENCODER, encoder);\n+\n+        // Call the next filter\n+        nextFilter.sessionCreated(session);\n+    }\n \n     @Override\n     public void sessionClosed(NextFilter nextFilter, IoSession session)\n             throws Exception {\n         // Call finishDecode() first when a connection is closed.\n-        ProtocolDecoder decoder = getDecoder0(session);\n+        ProtocolDecoder decoder = getDecoder(session);\n+        \n+        if ( decoder == null) {\n+            // The decoder must not be null. It's null if\n+            // the sessionCreated message has not be called, for\n+            // instance if the filter has been added after the \n+            // first session is created.\n+            ProtocolDecoderException pde = new ProtocolDecoderException(\n+                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n+                \"before the first session is created\" ); \n+            nextFilter.exceptionCaught(session, pde);\n+            return;\n+        }\n+        \n         ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n+        \n+        if ( decoderOut == null) {\n+            // The decoder must not be null. It's null if\n+            // the sessionCreated message has not be called, for\n+            // instance if the filter has been added after the \n+            // first session is created.\n+            ProtocolDecoderException pde = new ProtocolDecoderException(\n+                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n+                \"before the first session is created\" ); \n+            nextFilter.exceptionCaught(session, pde);\n+            return;\n+        }\n+        \n         try {\n             decoder.finishDecode(session, decoderOut);\n         } catch (Throwable t) {\n@@ -276,31 +459,11 @@ public void sessionClosed(NextFilter nextFilter, IoSession session)\n         nextFilter.sessionClosed(session);\n     }\n \n-    private ProtocolEncoder getEncoder0(IoSession session) throws Exception {\n-        ProtocolEncoder encoder = (ProtocolEncoder) session\n-                .getAttribute(ENCODER);\n-        if (encoder == null) {\n-            encoder = factory.getEncoder(session);\n-            session.setAttribute(ENCODER, encoder);\n-        }\n-        return encoder;\n-    }\n-\n     private ProtocolEncoderOutputImpl getEncoderOut(IoSession session,\n             NextFilter nextFilter, WriteRequest writeRequest) {\n         return new ProtocolEncoderOutputImpl(session, nextFilter, writeRequest);\n     }\n \n-    private ProtocolDecoder getDecoder0(IoSession session) throws Exception {\n-        ProtocolDecoder decoder = (ProtocolDecoder) session\n-                .getAttribute(DECODER);\n-        if (decoder == null) {\n-            decoder = factory.getDecoder(session);\n-            session.setAttribute(DECODER, decoder);\n-        }\n-        return decoder;\n-    }\n-\n     private ProtocolDecoderOutput getDecoderOut(IoSession session,\n             NextFilter nextFilter) {\n         ProtocolDecoderOutput out = (ProtocolDecoderOutput) session.getAttribute(DECODER_OUT);",
                "raw_url": "https://github.com/apache/mina/raw/d1667c18bddf6527aa8a920db7947489fcb4fe53/core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java",
                "sha": "4da9146a76529edc9bb733c68c098300e1672aa0",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/mina/blob/d1667c18bddf6527aa8a920db7947489fcb4fe53/example/src/main/java/org/apache/mina/example/chat/client/ChatClientSupport.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/mina/contents/example/src/main/java/org/apache/mina/example/chat/client/ChatClientSupport.java?ref=d1667c18bddf6527aa8a920db7947489fcb4fe53",
                "deletions": 0,
                "filename": "example/src/main/java/org/apache/mina/example/chat/client/ChatClientSupport.java",
                "patch": "@@ -23,11 +23,15 @@\n \n import javax.net.ssl.SSLContext;\n \n+import org.apache.mina.core.filterchain.IoFilter;\n import org.apache.mina.core.future.ConnectFuture;\n import org.apache.mina.core.service.IoHandler;\n import org.apache.mina.core.session.IoSession;\n import org.apache.mina.example.echoserver.ssl.BogusSslContextFactory;\n import org.apache.mina.filter.ssl.SslFilter;\n+import org.apache.mina.filter.codec.ProtocolCodecFilter;\n+import org.apache.mina.filter.codec.textline.TextLineCodecFactory;\n+import org.apache.mina.filter.logging.LoggingFilter;\n import org.apache.mina.filter.logging.MdcInjectionFilter;\n import org.apache.mina.transport.socket.nio.NioSocketConnector;\n \n@@ -60,7 +64,14 @@ public boolean connect(NioSocketConnector connector, SocketAddress address,\n         }\n \n         try {\n+            IoFilter LOGGING_FILTER = new LoggingFilter();\n+\n+            IoFilter CODEC_FILTER = new ProtocolCodecFilter(\n+                    new TextLineCodecFactory());\n+            \n             connector.getFilterChain().addLast(\"mdc\", new MdcInjectionFilter());\n+            connector.getFilterChain().addLast(\"codec\", CODEC_FILTER);\n+            connector.getFilterChain().addLast(\"logger\", LOGGING_FILTER);\n \n             if (useSsl) {\n                 SSLContext sslContext = BogusSslContextFactory",
                "raw_url": "https://github.com/apache/mina/raw/d1667c18bddf6527aa8a920db7947489fcb4fe53/example/src/main/java/org/apache/mina/example/chat/client/ChatClientSupport.java",
                "sha": "f3249326ea47bcca94261e1ee0f4efa57ab55371",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/mina/blob/d1667c18bddf6527aa8a920db7947489fcb4fe53/example/src/main/java/org/apache/mina/example/chat/client/SwingChatClientHandler.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/mina/contents/example/src/main/java/org/apache/mina/example/chat/client/SwingChatClientHandler.java?ref=d1667c18bddf6527aa8a920db7947489fcb4fe53",
                "deletions": 15,
                "filename": "example/src/main/java/org/apache/mina/example/chat/client/SwingChatClientHandler.java",
                "patch": "@@ -19,14 +19,10 @@\n  */\n package org.apache.mina.example.chat.client;\n \n-import org.apache.mina.core.filterchain.IoFilter;\n import org.apache.mina.core.service.IoHandler;\n import org.apache.mina.core.service.IoHandlerAdapter;\n import org.apache.mina.core.session.IoSession;\n import org.apache.mina.example.chat.ChatCommand;\n-import org.apache.mina.filter.codec.ProtocolCodecFilter;\n-import org.apache.mina.filter.codec.textline.TextLineCodecFactory;\n-import org.apache.mina.filter.logging.LoggingFilter;\n \n /**\n  * {@link IoHandler} implementation of the client side of the simple chat protocol.\n@@ -50,23 +46,12 @@\n         void error(String message);\n     }\n \n-    private static final IoFilter LOGGING_FILTER = new LoggingFilter();\n-\n-    private static final IoFilter CODEC_FILTER = new ProtocolCodecFilter(\n-            new TextLineCodecFactory());\n-\n     private final Callback callback;\n \n     public SwingChatClientHandler(Callback callback) {\n         this.callback = callback;\n     }\n \n-    @Override\n-    public void sessionCreated(IoSession session) throws Exception {\n-        session.getFilterChain().addLast(\"codec\", CODEC_FILTER);\n-        session.getFilterChain().addLast(\"logger\", LOGGING_FILTER);\n-    }\n-\n     @Override\n     public void sessionOpened(IoSession session) throws Exception {\n         callback.connected();",
                "raw_url": "https://github.com/apache/mina/raw/d1667c18bddf6527aa8a920db7947489fcb4fe53/example/src/main/java/org/apache/mina/example/chat/client/SwingChatClientHandler.java",
                "sha": "cc907014fa4c6efe4a6886c6dc5aaa2769a44bb1",
                "status": "modified"
            }
        ],
        "message": "o Added Javadoc and comments\no The encoder/decoder are now stored into the session, instead of being created on the fly.\no Added a sessionCreated() handler to create the encoder/decoder when the session is created\no Removed the useless getEncoder0() and getDecoder0() methods.\no Added defensive tests to avoid a NPE if the encoders/decoders are not present in the session\no The messageReceive() should loop until there are no more bytes to decode, instead of just getting out. Aded a TODO: check this part \no Modified the chat example to inject the codec filter before creating the session.\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/trunk@694277 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/mina/commit/3c35a90e45caa751d46d4fcab647819e0f34b0f1",
        "patched_files": [
            "ProtocolCodecFilter.java"
        ],
        "repo": "mina",
        "unit_tests": [
            "ProtocolCodecFilterTest.java"
        ]
    },
    "mina_fa036dd": {
        "bug_id": "mina_fa036dd",
        "commit": "https://github.com/apache/mina/commit/fa036dd376076be7224022a49bcd90830b5782ed",
        "file": [
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/mina/blob/fa036dd376076be7224022a49bcd90830b5782ed/core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/mina/contents/core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java?ref=fa036dd376076be7224022a49bcd90830b5782ed",
                "deletions": 1,
                "filename": "core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java",
                "patch": "@@ -292,7 +292,15 @@ public void filterWrite(NextFilter nextFilter, IoSession session,\n \n         ProtocolEncoderOutput encoderOut = getEncoderOut(session,\n                 nextFilter, writeRequest);\n-\n+        \n+        if (encoder == null) {\n+            throw new ProtocolEncoderException(\"The encoder is null for the session \" + session);\n+        }\n+        \n+        if (encoderOut == null) {\n+            throw new ProtocolEncoderException(\"The encoderOut is null for the session \" + session);\n+        }\n+        \n         try {\n             // Now we can try to encode the response\n             encoder.encode(session, message, encoderOut);",
                "raw_url": "https://github.com/apache/mina/raw/fa036dd376076be7224022a49bcd90830b5782ed/core/src/main/java/org/apache/mina/filter/codec/ProtocolCodecFilter.java",
                "sha": "e12f795f1cdcbf96c1fce8466752109769b631c0",
                "status": "modified"
            }
        ],
        "message": "Added some protection against some NPE in the ProtocolCodecFilter. Not sure it's enough though...\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/trunk@898592 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/mina/commit/7bb118214fad995b1c9da49180d2c82058bacbe9",
        "patched_files": [
            "ProtocolCodecFilter.java"
        ],
        "repo": "mina",
        "unit_tests": [
            "ProtocolCodecFilterTest.java"
        ]
    }
}