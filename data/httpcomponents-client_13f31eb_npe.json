[
    {
        "repo": "httpcomponents-client",
        "commit": "https://github.com/apache/httpcomponents-client/commit/13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
        "bug_id": "httpcomponents-client_13f31eb",
        "message": "HTTPCLIENT-936: Fixed bug causing NPE or an infinite loop in the authentication code in case of a SPNEGO authentication failure\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk@943620 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/httpcomponents-client/commit/bb0ecdbcb43d8c36e3df95f67c6b1f3fe77e1d84",
        "patched_files": [
            "NTLMScheme.java",
            "RELEASE_NOTES.txt",
            "HttpTestUtils.java",
            "CacheEntry.java",
            "AuthSchemeBase.java",
            "NegotiateScheme.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 4,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/RELEASE_NOTES.txt",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/RELEASE_NOTES.txt?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "RELEASE_NOTES.txt",
                "deletions": 0,
                "sha": "4ace86fd2a2e14d5fe948a9080f2b48a410e9079",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/RELEASE_NOTES.txt",
                "patch": "@@ -22,6 +22,10 @@ maintained as of 4.1 GA release.\n Changelog\n -------------------\n \n+* [HTTPCLIENT-936] Fixed bug causing NPE or an infinite loop in \n+  the authentication code in case of a SPNEGO authentication failure. \n+  Contributed by Oleg Kalnichevski <olegk at apache.org>\n+\n * [HTTPCLIENT-427] HTTP caching support\n   Contributed by Joe Campbell, David Cleaver, David Mays, Jon Moore, Brad Spenla\n ",
                "changes": 4
            },
            {
                "status": "modified",
                "additions": 11,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient-cache/src/test/java/org/apache/http/client/cache/impl/HttpTestUtils.java",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/httpclient-cache/src/test/java/org/apache/http/client/cache/impl/HttpTestUtils.java?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "httpclient-cache/src/test/java/org/apache/http/client/cache/impl/HttpTestUtils.java",
                "deletions": 1,
                "sha": "74b458c3f78e33af48ac08007d297fc4996f550c",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient-cache/src/test/java/org/apache/http/client/cache/impl/HttpTestUtils.java",
                "patch": "@@ -78,6 +78,17 @@ public static boolean isHopByHopHeader(String name) {\n         return false;\n     }\n \n+    /*\n+     * Determines whether a given header name may appear multiple times.\n+     */\n+    public static boolean isMultiHeader(String name) {\n+        for (String s : MULTI_HEADERS) {\n+            if (s.equalsIgnoreCase(name))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n     /*\n      * Determines whether a given header name may only appear once in a message.\n      */\n@@ -88,7 +99,6 @@ public static boolean isSingleHeader(String name) {\n         }\n         return false;\n     }\n-\n     /*\n      * Assert.asserts that two request or response bodies are byte-equivalent.\n      */",
                "changes": 12
            },
            {
                "status": "modified",
                "additions": 1,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient-cache/src/test/java/org/apache/http/client/cache/impl/TestCacheEntry.java",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/httpclient-cache/src/test/java/org/apache/http/client/cache/impl/TestCacheEntry.java?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "httpclient-cache/src/test/java/org/apache/http/client/cache/impl/TestCacheEntry.java",
                "deletions": 4,
                "sha": "2a458a7a8633be69ff037b798e17003a6de240ee",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient-cache/src/test/java/org/apache/http/client/cache/impl/TestCacheEntry.java",
                "patch": "@@ -26,8 +26,6 @@\n  */\n package org.apache.http.client.cache.impl;\n \n-import static junit.framework.Assert.assertFalse;\n-\n import java.util.Date;\n import java.util.Set;\n \n@@ -376,8 +374,7 @@ public void testCacheEntryIsNotRevalidatableIfNoAppropriateHeaders() {\n                 new BasicHeader(\"Cache-Control\", \"public\") };\n \n         CacheEntry entry = getEntry(headers);\n-\n-        assertFalse(entry.isRevalidatable());\n+        Assert.assertFalse(entry.isRevalidatable());\n     }\n \n ",
                "changes": 5
            },
            {
                "status": "modified",
                "additions": 1,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/main/java/org/apache/http/impl/auth/AuthSchemeBase.java",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/httpclient/src/main/java/org/apache/http/impl/auth/AuthSchemeBase.java?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "httpclient/src/main/java/org/apache/http/impl/auth/AuthSchemeBase.java",
                "deletions": 1,
                "sha": "c790f3ebae66b9eb1003c1eef9027bb693034f07",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/main/java/org/apache/http/impl/auth/AuthSchemeBase.java",
                "patch": "@@ -125,7 +125,7 @@ public Header authenticate(\n     }\n \n     protected abstract void parseChallenge(\n-            CharArrayBuffer buffer, int pos, int len) throws MalformedChallengeException;\n+            CharArrayBuffer buffer, int beginIndex, int endIndex) throws MalformedChallengeException;\n \n     /**\n      * Returns <code>true</code> if authenticating against a proxy, <code>false</code>",
                "changes": 2
            },
            {
                "status": "modified",
                "additions": 3,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/main/java/org/apache/http/impl/auth/NTLMScheme.java",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/httpclient/src/main/java/org/apache/http/impl/auth/NTLMScheme.java?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "httpclient/src/main/java/org/apache/http/impl/auth/NTLMScheme.java",
                "deletions": 2,
                "sha": "4f616a5c2bdc2aaab54f9037f13c8c6f896f5314",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/main/java/org/apache/http/impl/auth/NTLMScheme.java",
                "patch": "@@ -99,8 +99,9 @@ public boolean isConnectionBased() {\n \n     @Override\n     protected void parseChallenge(\n-            final CharArrayBuffer buffer, int pos, int len) throws MalformedChallengeException {\n-        String challenge = buffer.substringTrimmed(pos, len);\n+            final CharArrayBuffer buffer, \n+            int beginIndex, int endIndex) throws MalformedChallengeException {\n+        String challenge = buffer.substringTrimmed(beginIndex, endIndex);\n         if (challenge.length() == 0) {\n             if (this.state == State.UNINITIATED) {\n                 this.state = State.CHALLENGE_RECEIVED;",
                "changes": 5
            },
            {
                "status": "modified",
                "additions": 35,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/main/java/org/apache/http/impl/auth/NegotiateScheme.java",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/httpclient/src/main/java/org/apache/http/impl/auth/NegotiateScheme.java?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "httpclient/src/main/java/org/apache/http/impl/auth/NegotiateScheme.java",
                "deletions": 61,
                "sha": "df2e9c326b06b9bfd9eb4076feee1daa34baefba",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/main/java/org/apache/http/impl/auth/NegotiateScheme.java",
                "patch": "@@ -33,15 +33,14 @@\n import org.apache.http.Header;\n import org.apache.http.HttpHost;\n import org.apache.http.HttpRequest;\n-import org.apache.http.auth.AUTH;\n import org.apache.http.auth.AuthenticationException;\n-import org.apache.http.auth.ContextAwareAuthScheme;\n import org.apache.http.auth.Credentials;\n import org.apache.http.auth.InvalidCredentialsException;\n import org.apache.http.auth.MalformedChallengeException;\n import org.apache.http.message.BasicHeader;\n import org.apache.http.protocol.ExecutionContext;\n import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.CharArrayBuffer;\n import org.ietf.jgss.GSSContext;\n import org.ietf.jgss.GSSException;\n import org.ietf.jgss.GSSManager;\n@@ -54,28 +53,28 @@\n  *\n  * @since 4.1\n  */\n-public class NegotiateScheme implements ContextAwareAuthScheme {\n+public class NegotiateScheme extends AuthSchemeBase {\n \n-    private static final int UNINITIATED         = 0;\n-    private static final int INITIATED           = 1;\n-    private static final int NEGOTIATING         = 3;\n-    private static final int ESTABLISHED         = 4;\n-    private static final int FAILED              = Integer.MAX_VALUE;\n-    private static final String SPNEGO_OID        = \"1.3.6.1.5.5.2\";\n-    private static final String KERBEROS_OID        = \"1.2.840.113554.1.2.2\";\n+    enum State {\n+        UNINITIATED,\n+        CHALLENGE_RECEIVED,\n+        TOKEN_GENERATED,\n+        FAILED,\n+    }\n+    \n+    private static final String SPNEGO_OID       = \"1.3.6.1.5.5.2\";\n+    private static final String KERBEROS_OID     = \"1.2.840.113554.1.2.2\";\n \n     private final Log log = LogFactory.getLog(getClass());\n \n     private final SpnegoTokenGenerator spengoGenerator;\n \n     private final boolean stripPort;\n \n-    private boolean proxy;\n-\n     private GSSContext gssContext = null;\n \n     /** Authentication process state */\n-    private int state;\n+    private State state;\n \n     /** base64 decoded challenge **/\n     private byte[] token;\n@@ -88,7 +87,7 @@\n      */\n     public NegotiateScheme(final SpnegoTokenGenerator spengoGenerator, boolean stripPort) {\n         super();\n-        this.state = UNINITIATED;\n+        this.state = State.UNINITIATED;\n         this.spengoGenerator = spengoGenerator;\n         this.stripPort = stripPort;\n     }\n@@ -109,7 +108,7 @@ public NegotiateScheme() {\n      *\n      */\n     public boolean isComplete() {\n-        return this.state == ESTABLISHED || this.state == FAILED;\n+        return this.state == State.TOKEN_GENERATED || this.state == State.FAILED;\n     }\n \n     /**\n@@ -152,7 +151,7 @@ public Header authenticate(\n         if (request == null) {\n             throw new IllegalArgumentException(\"HTTP request may not be null\");\n         }\n-        if (state == UNINITIATED) {\n+        if (state != State.CHALLENGE_RECEIVED) {\n             throw new IllegalStateException(\n                     \"Negotiation authentication process has not been initiated\");\n         }\n@@ -227,19 +226,13 @@ public Header authenticate(\n                 gssContext.requestMutualAuth(true);\n                 gssContext.requestCredDeleg(true);\n             }\n-            state = INITIATED;\n-\n             if (token == null) {\n                 token = new byte[0];                \n             }\n-            // HTTP 1.1 issue:\n-            // Mutual auth will never complete to do 200 instead of 401 in\n-            // return from server. \"state\" will never reach ESTABLISHED\n-            // but it works anyway\n-\n             token = gssContext.initSecContext(token, 0, token.length);\n             if (token == null) {\n-                throw new AuthenticationException(\"Failed to initialize security context\");\n+                state = State.FAILED;\n+                throw new AuthenticationException(\"GSS security context initialization failed\");\n             }\n \n             /*\n@@ -250,11 +243,14 @@ public Header authenticate(\n                 token = spengoGenerator.generateSpnegoDERObject(token);\n             }\n \n+            state = State.TOKEN_GENERATED;\n+            String tokenstr = new String(Base64.encodeBase64(token, false));\n             if (log.isDebugEnabled()) {\n-                log.debug(\"got token, sending \" + token.length + \" bytes to server\");\n+                log.debug(\"Sending response '\" + tokenstr + \"' back to the auth server\");\n             }\n+            return new BasicHeader(\"Authorization\", \"Negotiate \" + tokenstr);\n         } catch (GSSException gsse) {\n-            state = FAILED;\n+            state = State.FAILED;\n             if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL\n                     || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)\n                 throw new InvalidCredentialsException(gsse.getMessage(), gsse);\n@@ -267,11 +263,9 @@ public Header authenticate(\n             // other error\n             throw new AuthenticationException(gsse.getMessage());\n         } catch (IOException ex){\n-            state = FAILED;\n+            state = State.FAILED;\n             throw new AuthenticationException(ex.getMessage());\n         }\n-        return new BasicHeader(\"Authorization\", \"Negotiate \" +\n-                new String(Base64.encodeBase64(token, false)) );\n     }\n \n \n@@ -312,41 +306,21 @@ public boolean isConnectionBased() {\n         return true;\n     }\n \n-    /**\n-     * Processes the Negotiate challenge.\n-     *\n-     */\n-    public void processChallenge(final Header header) throws MalformedChallengeException {\n+    @Override\n+    protected void parseChallenge(\n+            final CharArrayBuffer buffer, \n+            int beginIndex, int endIndex) throws MalformedChallengeException {\n+        String challenge = buffer.substringTrimmed(beginIndex, endIndex);\n         if (log.isDebugEnabled()) {\n-            log.debug(\"Challenge header: \" + header);\n+            log.debug(\"Received challenge '\" + challenge + \"' from the auth server\");\n         }\n-        String authheader = header.getName();\n-        String challenge = header.getValue();\n-        if (authheader.equalsIgnoreCase(AUTH.WWW_AUTH)) {\n-            this.proxy = false;\n-        } else if (authheader.equalsIgnoreCase(AUTH.PROXY_AUTH)) {\n-            this.proxy = true;\n+        if (state == State.UNINITIATED) {\n+            token = new Base64().decode(challenge.getBytes());\n+            state = State.CHALLENGE_RECEIVED;\n         } else {\n-            throw new MalformedChallengeException(\"Unexpected header name: \" + authheader);\n-        }\n-\n-        if (challenge.startsWith(\"Negotiate\")) {\n-            if(isComplete() == false)\n-                state = NEGOTIATING;\n-\n-            if (challenge.startsWith(\"Negotiate \")){\n-                token = new Base64().decode(challenge.substring(10).getBytes());\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"challenge = \" + challenge.substring(10));\n-                }\n-            } else {\n-                token = new byte[0];\n-            }\n+            log.debug(\"Authentication already attempted\");\n+            state = State.FAILED;\n         }\n     }\n-\n-    public boolean isProxy() {\n-        return this.proxy;\n-    }\n-\n+    \n }",
                "changes": 96
            },
            {
                "status": "modified",
                "additions": 42,
                "raw_url": "https://github.com/apache/httpcomponents-client/raw/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/test/java/org/apache/http/impl/auth/TestNegotiateScheme.java",
                "contents_url": "https://api.github.com/repos/apache/httpcomponents-client/contents/httpclient/src/test/java/org/apache/http/impl/auth/TestNegotiateScheme.java?ref=13f31eb2dbeee32367558692ee9ab0a59d7b2d14",
                "filename": "httpclient/src/test/java/org/apache/http/impl/auth/TestNegotiateScheme.java",
                "deletions": 28,
                "sha": "315d032697b9f1de89c2115831fd4d1d4ac0b5fe",
                "blob_url": "https://github.com/apache/httpcomponents-client/blob/13f31eb2dbeee32367558692ee9ab0a59d7b2d14/httpclient/src/test/java/org/apache/http/impl/auth/TestNegotiateScheme.java",
                "patch": "@@ -26,26 +26,24 @@\n  */\n package org.apache.http.impl.auth;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n import java.io.IOException;\n import java.security.Principal;\n \n+import junit.framework.Assert;\n+\n import org.apache.http.HttpEntity;\n import org.apache.http.HttpException;\n import org.apache.http.HttpHost;\n import org.apache.http.HttpRequest;\n import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n import org.apache.http.auth.AuthScheme;\n import org.apache.http.auth.AuthScope;\n import org.apache.http.auth.Credentials;\n import org.apache.http.client.methods.HttpGet;\n import org.apache.http.client.params.AuthPolicy;\n import org.apache.http.client.params.ClientPNames;\n import org.apache.http.entity.StringEntity;\n-import org.apache.http.impl.auth.NegotiateScheme;\n-import org.apache.http.impl.auth.NegotiateSchemeFactory;\n import org.apache.http.impl.client.DefaultHttpClient;\n import org.apache.http.localserver.BasicServerTestBase;\n import org.apache.http.localserver.LocalTestServer;\n@@ -59,8 +57,9 @@\n import org.ietf.jgss.GSSName;\n import org.ietf.jgss.Oid;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n \n /**\n  * Tests for {@link NegotiateScheme}.\n@@ -79,13 +78,15 @@ public void setUp() throws Exception {\n      * This service will continue to ask for authentication.\n      */\n     private static class PleaseNegotiateService implements HttpRequestHandler {\n-        public void handle(final HttpRequest request,\n+\n+        public void handle(\n+                final HttpRequest request,\n                 final HttpResponse response,\n                 final HttpContext context) throws HttpException, IOException {\n-            response.setStatusCode(401);\n+            response.setStatusCode(HttpStatus.SC_UNAUTHORIZED);\n             response.addHeader(new BasicHeader(\"WWW-Authenticate\", \"Negotiate blablabla\"));\n-            response.setEntity(new StringEntity(\"auth required \"));\n             response.addHeader(new BasicHeader(\"Connection\", \"Keep-Alive\"));\n+            response.setEntity(new StringEntity(\"auth required \"));\n         }\n     }\n \n@@ -96,55 +97,64 @@ public void handle(final HttpRequest request,\n      *\n      */\n     private static class NegotiateSchemeWithMockGssManager extends NegotiateScheme {\n-        GSSManager manager = mock(GSSManager.class);\n-        GSSName name = mock(GSSName.class);\n-        GSSContext context = mock(GSSContext.class);\n+        \n+        GSSManager manager = Mockito.mock(GSSManager.class);\n+        GSSName name = Mockito.mock(GSSName.class);\n+        GSSContext context = Mockito.mock(GSSContext.class);\n \n         NegotiateSchemeWithMockGssManager() throws Exception {\n             super(null, true);\n-\n-            when(context.initSecContext(any(byte[].class), anyInt(), anyInt()))\n-                .thenReturn(\"12345678\".getBytes());\n-            when(manager.createName(any(String.class), any(Oid.class)))\n-                .thenReturn(name);\n-            when(manager.createContext(any(GSSName.class), any(Oid.class), any(GSSCredential.class), anyInt()))\n-                .thenReturn(context);\n-\n+            Mockito.when(context.initSecContext(\n+                    Matchers.any(byte[].class), Matchers.anyInt(), Matchers.anyInt()))\n+                    .thenReturn(\"12345678\".getBytes());\n+            Mockito.when(manager.createName(\n+                    Matchers.any(String.class), Matchers.any(Oid.class)))\n+                    .thenReturn(name);\n+            Mockito.when(manager.createContext(\n+                    Matchers.any(GSSName.class), Matchers.any(Oid.class), \n+                    Matchers.any(GSSCredential.class), Matchers.anyInt()))\n+                    .thenReturn(context);\n         }\n \n         @Override\n         protected GSSManager getManager() {\n             return manager;\n         }\n+        \n     }\n \n     private static class UseJaasCredentials implements Credentials {\n+        \n         public String getPassword() {\n             return null;\n         }\n \n         public Principal getUserPrincipal() {\n             return null;\n         }\n+        \n     }\n \n     private static class NegotiateSchemeFactoryWithMockGssManager extends NegotiateSchemeFactory {\n+        \n         NegotiateSchemeWithMockGssManager scheme;\n+        \n         NegotiateSchemeFactoryWithMockGssManager() throws Exception {\n             scheme = new NegotiateSchemeWithMockGssManager();\n         }\n+        \n         @Override\n         public AuthScheme newInstance(HttpParams params) {\n             return scheme;\n         }\n+        \n     }\n \n     /**\n      * Tests that the client will stop connecting to the server if\n      * the server still keep asking for a valid ticket.\n      */\n     @Test\n-    @Ignore\n     public void testDontTryToAuthenticateEndlessly() throws Exception {\n         int port = this.localServer.getServiceAddress().getPort();\n         this.localServer.register(\"*\", new PleaseNegotiateService());\n@@ -163,25 +173,26 @@ public void testDontTryToAuthenticateEndlessly() throws Exception {\n         HttpGet httpget = new HttpGet(s);\n         HttpResponse response = client.execute(httpget);\n         HttpEntity e = response.getEntity();\n-        e.consumeContent();\n+        if (e != null) {\n+            e.consumeContent();\n+        }\n+        Assert.assertEquals(HttpStatus.SC_UNAUTHORIZED, response.getStatusLine().getStatusCode());\n     }\n \n-\n     /**\n      * Javadoc specifies that {@link GSSContext#initSecContext(byte[], int, int)} can return null\n      * if no token is generated. Client should be able to deal with this response.\n-     *\n      */\n     @Test\n-    @Ignore\n-    public void testNoTokenGeneratedGenerateAnError() throws Exception {\n+    public void testNoTokenGeneratedError() throws Exception {\n         int port = this.localServer.getServiceAddress().getPort();\n         this.localServer.register(\"*\", new PleaseNegotiateService());\n \n         HttpHost target = new HttpHost(\"localhost\", port);\n         DefaultHttpClient client = new DefaultHttpClient();\n         NegotiateSchemeFactoryWithMockGssManager nsf = new NegotiateSchemeFactoryWithMockGssManager();\n-        when(nsf.scheme.context.initSecContext(any(byte[].class), anyInt(), anyInt())).thenReturn(null);\n+        Mockito.when(nsf.scheme.context.initSecContext(\n+                Matchers.any(byte[].class), Matchers.anyInt(), Matchers.anyInt())).thenReturn(null);\n         client.getAuthSchemes().register(AuthPolicy.SPNEGO, nsf);\n \n         Credentials use_jaas_creds = new UseJaasCredentials();\n@@ -193,7 +204,10 @@ public void testNoTokenGeneratedGenerateAnError() throws Exception {\n         HttpGet httpget = new HttpGet(s);\n         HttpResponse response = client.execute(httpget);\n         HttpEntity e = response.getEntity();\n-        e.consumeContent();\n+        if (e != null) {\n+            e.consumeContent();\n+        }\n+        Assert.assertEquals(HttpStatus.SC_UNAUTHORIZED, response.getStatusLine().getStatusCode());\n     }\n \n }",
                "changes": 70
            }
        ],
        "unit_tests": [
            "TestNegotiateScheme.java",
            "TestCacheEntry.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "httpclient/src/test/java/org/apache/http/impl/auth/TestNegotiateScheme.java",
        "buggy_files": [
            "httpclient/src/main/java/org/apache/http/impl/auth/NTLMScheme.java",
            "RELEASE_NOTES.txt",
            "httpclient-cache/src/test/java/org/apache/http/client/cache/impl/HttpTestUtils.java",
            "httpclient-cache/src/main/java/org/apache/http/client/cache/impl/CacheEntry.java",
            "httpclient/src/main/java/org/apache/http/impl/auth/AuthSchemeBase.java",
            "httpclient/src/main/java/org/apache/http/impl/auth/NegotiateScheme.java"
        ],
        "fixed": true
    }
]