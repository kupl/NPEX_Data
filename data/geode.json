{
    "geode_1726669": {
        "bug_id": "geode_1726669",
        "commit": "https://github.com/apache/geode/commit/1726669bf1a0d304d962071da6cc69b7455c2f10",
        "file": [
            {
                "additions": 105,
                "blob_url": "https://github.com/apache/geode/blob/1726669bf1a0d304d962071da6cc69b7455c2f10/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java",
                "changes": 105,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java?ref=1726669bf1a0d304d962071da6cc69b7455c2f10",
                "deletions": 0,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java",
                "patch": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TestName;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.DistributionConfig;\n+\n+\n+/**\n+ * junit test for detecting read conflicts\n+ */\n+public class TXDetectReadConflictJUnitTest {\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Rule\n+  public TestName name = new TestName();\n+\n+  protected Cache cache = null;\n+  protected Region region = null;\n+  protected Region regionpr = null;\n+\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(DistributionConfig.GEMFIRE_PREFIX + \"detectReadConflicts\", \"true\");\n+    createCache();\n+  }\n+\n+  protected void createCache() {\n+    Properties props = new Properties();\n+    props.put(MCAST_PORT, \"0\");\n+    props.put(LOCATORS, \"\");\n+    cache = new CacheFactory(props).create();\n+    region = cache.createRegionFactory(RegionShortcut.REPLICATE).create(\"testRegionRR\");\n+  }\n+\n+  protected void createCachePR() {\n+    Properties props = new Properties();\n+    props.put(MCAST_PORT, \"0\");\n+    props.put(LOCATORS, \"\");\n+    cache = new CacheFactory(props).create();\n+    regionpr = cache.createRegionFactory(RegionShortcut.PARTITION).create(\"testRegionPR\");\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    cache.close();\n+  }\n+\n+  @Test\n+  public void testReadConflictsRR() throws Exception {\n+    cache.close();\n+    createCache();\n+    region.put(\"key\", \"value\");\n+    region.put(\"key1\", \"value1\");\n+    TXManagerImpl mgr = (TXManagerImpl) cache.getCacheTransactionManager();\n+    mgr.begin();\n+    assertEquals(\"value\", region.get(\"key\"));\n+    assertEquals(\"value1\", region.get(\"key1\"));\n+    mgr.commit();\n+  }\n+\n+  @Test\n+  public void testReadConflictsPR() throws Exception {\n+    cache.close();\n+    createCachePR();\n+    regionpr.put(\"key\", \"value\");\n+    regionpr.put(\"key1\", \"value1\");\n+    TXManagerImpl mgr = (TXManagerImpl) cache.getCacheTransactionManager();\n+    mgr.begin();\n+    assertEquals(\"value\", regionpr.get(\"key\"));\n+    assertEquals(\"value1\", regionpr.get(\"key1\"));\n+    mgr.commit();\n+  }\n+}",
                "raw_url": "https://github.com/apache/geode/raw/1726669bf1a0d304d962071da6cc69b7455c2f10/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java",
                "sha": "810f148796fdb2f1bd849ff844963077bb42b7e5",
                "status": "added"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/geode/blob/1726669bf1a0d304d962071da6cc69b7455c2f10/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java?ref=1726669bf1a0d304d962071da6cc69b7455c2f10",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java",
                "patch": "@@ -1882,6 +1882,9 @@ void performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,\n       Set<InternalDistributedMember> cacheOpReceivers, Set<InternalDistributedMember> twoMessages,\n       FilterRoutingInfo routing) {\n     Operation op = event.getOperation();\n+    if (op == null) {\n+      return Collections.emptySet();\n+    }\n     if (op.isUpdate() || op.isCreate() || op.isDestroy() || op.isInvalidate()) {\n       // this method can safely assume that the operation is being distributed from\n       // the primary bucket holder to other nodes",
                "raw_url": "https://github.com/apache/geode/raw/1726669bf1a0d304d962071da6cc69b7455c2f10/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java",
                "sha": "48530907cce9d69539155cafed2e8b79c50d046c",
                "status": "modified"
            }
        ],
        "message": "GEODE-6651: Fixed NPE",
        "parent": "https://github.com/apache/geode/commit/2b2fda692868b0096b17ce55bc084b2f3f9637f2",
        "repo": "geode",
        "unit_tests": [
            "BucketRegionTest.java"
        ]
    },
    "geode_1dfbffa": {
        "bug_id": "geode_1dfbffa",
        "commit": "https://github.com/apache/geode/commit/1dfbffa71a377aa276729c80c35f0c25a2886b25",
        "file": [
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/geode/blob/1dfbffa71a377aa276729c80c35f0c25a2886b25/geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java",
                "changes": 114,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java?ref=1dfbffa71a377aa276729c80c35f0c25a2886b25",
                "deletions": 76,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java",
                "patch": "@@ -2107,40 +2107,23 @@ public Object updateHAEventWrapper(InternalDistributedMember sender,\n             continue;\n           }\n           synchronized (entryHaEventWrapper) {\n-            if (haContainer.getKey(entryHaEventWrapper) != null) {\n+            if ((HAEventWrapper) haContainer.getKey(entryHaEventWrapper) != null) {\n               entryHaEventWrapper.incAndGetReferenceCount();\n-              // If the input and entry HAEventWrappers are not the same (which is the normal\n-              // case), add the CQs and interest list from the input to the entry and create a new\n-              // value from the entry.\n-              if (entryHaEventWrapper != inputHaEventWrapper) { // See GEODE-4957\n-                addClientCQsAndInterestList(entryMessage, inputHaEventWrapper, haContainer,\n-                    regionName);\n-                inputHaEventWrapper.setClientUpdateMessage(null);\n-                newValueCd =\n-                    new VMCachedDeserializable(entryHaEventWrapper, newValueCd.getSizeInBytes());\n-              }\n-            } else {\n-              entryHaEventWrapper = null;\n-            }\n-          }\n-        } else { // putIfAbsent successful\n-          entryHaEventWrapper = (HAEventWrapper) haContainer.getKey(inputHaEventWrapper);\n-          synchronized (entryHaEventWrapper) {\n-            entryHaEventWrapper.incAndGetReferenceCount();\n-            entryHaEventWrapper.setHAContainer(haContainer);\n-            // If the input and entry HAEventWrappers are not the same (which is not the normal\n-            // case), get the entry message, add the CQs and interest list from the input to the\n-            // entry and create a new value from the entry.\n-            if (entryHaEventWrapper != inputHaEventWrapper) { // See GEODE-4957\n-              entryMessage = (ClientUpdateMessageImpl) haContainer.get(inputHaEventWrapper);\n               addClientCQsAndInterestList(entryMessage, inputHaEventWrapper, haContainer,\n                   regionName);\n               inputHaEventWrapper.setClientUpdateMessage(null);\n               newValueCd =\n                   new VMCachedDeserializable(entryHaEventWrapper, newValueCd.getSizeInBytes());\n+            } else {\n+              entryHaEventWrapper = null;\n             }\n-            entryHaEventWrapper.setClientUpdateMessage(null);\n-            entryHaEventWrapper.setIsRefFromHAContainer(true);\n+          }\n+        } else { // putIfAbsent successful\n+          synchronized (inputHaEventWrapper) {\n+            inputHaEventWrapper.incAndGetReferenceCount();\n+            inputHaEventWrapper.setHAContainer(haContainer);\n+            inputHaEventWrapper.setClientUpdateMessage(null);\n+            inputHaEventWrapper.setIsRefFromHAContainer(true);\n           }\n           break;\n         }\n@@ -3443,76 +3426,55 @@ public void destroy() throws CacheWriterException {\n    */\n   protected void putEventInHARegion(Conflatable event, Long position) {\n     if (event instanceof HAEventWrapper) {\n-      HAEventWrapper haEventWrapper = (HAEventWrapper) event;\n+      HAEventWrapper inputHaEventWrapper = (HAEventWrapper) event;\n       if (this.isQueueInitialized()) {\n-        if (haEventWrapper.getIsRefFromHAContainer()) {\n-          putEntryConditionallyIntoHAContainer(haEventWrapper);\n+        if (inputHaEventWrapper.getIsRefFromHAContainer()) {\n+          putEntryConditionallyIntoHAContainer(inputHaEventWrapper);\n         } else {\n-          // This means that the haEvenWrapper reference we have is not\n+          // This means that the haEventWrapper reference we have is not\n           // authentic, i.e. it doesn't refer to the HAEventWrapper instance\n           // in the haContainer, but to the one outside it.\n-          boolean entryFound;\n-          // synchronized (this.haContainer) {\n-          HAEventWrapper original = null;\n+          HAEventWrapper haContainerKey = null;\n           do {\n-            ClientUpdateMessageImpl old =\n+            ClientUpdateMessageImpl haContainerEntry =\n                 (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer)\n-                    .putIfAbsent(haEventWrapper, haEventWrapper.getClientUpdateMessage());\n-            if (old != null) {\n-              original =\n-                  (HAEventWrapper) ((HAContainerWrapper) this.haContainer).getKey(haEventWrapper);\n-              if (original == null) {\n+                    .putIfAbsent(inputHaEventWrapper, inputHaEventWrapper.getClientUpdateMessage());\n+            if (haContainerEntry != null) {\n+              haContainerKey = (HAEventWrapper) ((HAContainerWrapper) this.haContainer)\n+                  .getKey(inputHaEventWrapper);\n+              if (haContainerKey == null) {\n                 continue;\n               }\n-              synchronized (original) {\n+              synchronized (haContainerKey) {\n                 // assert the entry is still present\n-                if (((HAContainerWrapper) this.haContainer).getKey(original) != null) {\n-                  original.incAndGetReferenceCount();\n-                  addClientCQsAndInterestList(old, haEventWrapper, this.haContainer,\n-                      this.regionName);\n-                  haEventWrapper = original;\n+                if (((HAContainerWrapper) this.haContainer).getKey(haContainerKey) != null) {\n+                  haContainerKey.incAndGetReferenceCount();\n+                  addClientCQsAndInterestList(haContainerEntry, inputHaEventWrapper,\n+                      this.haContainer, this.regionName);\n+                  inputHaEventWrapper = haContainerKey;\n                 } else {\n-                  original = null;\n+                  haContainerKey = null;\n                 }\n               }\n             } else {\n-              synchronized (haEventWrapper) {\n-                haEventWrapper.incAndGetReferenceCount();\n-                haEventWrapper.setHAContainer(this.haContainer);\n-                if (!haEventWrapper.getPutInProgress()) {\n+              synchronized (inputHaEventWrapper) {\n+                inputHaEventWrapper.incAndGetReferenceCount();\n+                inputHaEventWrapper.setHAContainer(this.haContainer);\n+                if (!inputHaEventWrapper.getPutInProgress()) {\n                   // This means that this is a GII'ed event. Hence we must\n                   // explicitly set 'clientUpdateMessage' to null.\n-                  haEventWrapper.setClientUpdateMessage(null);\n+                  inputHaEventWrapper.setClientUpdateMessage(null);\n                 }\n-                haEventWrapper.setIsRefFromHAContainer(true);\n+                inputHaEventWrapper.setIsRefFromHAContainer(true);\n               }\n               break;\n             }\n-          } while (original == null);\n-          /*\n-           * entry = (Map.Entry)((HAContainerWrapper)this.haContainer) .getEntry(haEventWrapper); if\n-           * (entry == null) { entryFound = false;\n-           * putEntryConditionallyIntoHAContainer(haEventWrapper); } else { entryFound = true; // Do\n-           * not assign entry.getKey() to haEventWrapper right now.\n-           * ((HAEventWrapper)entry.getKey()).incAndGetReferenceCount(); } }//haContainer\n-           * synchronized ends if (entryFound) { addClientCQsAndInterestList(entry, haEventWrapper,\n-           * haContainer, regionName); haEventWrapper = (HAEventWrapper)entry.getKey(); } else { //\n-           * entry not found if (!haEventWrapper.getPutInProgress()) { // This means that this is a\n-           * GII'ed event. Hence we must // explicitly set 'clientUpdateMessage' to null.\n-           * haEventWrapper.setClientUpdateMessage(null); }\n-           * haEventWrapper.setIsRefFromHAContainer(true); }\n-           */\n-        }\n-      }\n-      // This has now been taken care of in AbstractRegionMap.initialImagePut()\n-      // else{\n-      // if(!haEventWrapper.getIsRefFromHAContainer()){\n-      // haEventWrapper =(HAEventWrapper)((HAContainerWrapper)haContainer).getKey(haEventWrapper);\n-      // }\n-      // }\n+          } while (haContainerKey == null);\n+        }\n+      }\n       // Put the reference to the HAEventWrapper instance into the\n       // HA queue.\n-      this.region.put(position, haEventWrapper);\n+      this.region.put(position, inputHaEventWrapper);\n       // logger.info(LocalizedStrings.DEBUG, \"added message at position \" + position);\n     } else { // (event instanceof ClientMarkerMessageImpl OR ConflatableObject OR\n              // ClientInstantiatorMessage)",
                "raw_url": "https://github.com/apache/geode/raw/1dfbffa71a377aa276729c80c35f0c25a2886b25/geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java",
                "sha": "a49adfb8ec0b04a1a409ded7332b30e9d27fe694",
                "status": "modified"
            }
        ],
        "message": "GEODE-5166: NPE thrown while processing InitialImage of subscription region\n\n* Fix NPE in updateHAEventWrapper\n* Clean up code (renaming variables) in putEventInHARegion\n* Removing old/commented out code",
        "parent": "https://github.com/apache/geode/commit/4e53223979761a23a9e73a68ffbbe40d9ae75aaf",
        "repo": "geode",
        "unit_tests": [
            "HARegionQueueTest.java"
        ]
    },
    "geode_29c71c9": {
        "bug_id": "geode_29c71c9",
        "commit": "https://github.com/apache/geode/commit/29c71c96f2933e8380e412e9d14b42beb30ae96b",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java",
                "patch": "@@ -100,6 +100,11 @@ public FederatingManager(MBeanJMXAdapter jmxAdapter, ManagementResourceRepo repo\n     this.messenger = new MemberMessenger(jmxAdapter, repo, system);\n   }\n \n+  @TestingOnly\n+  void setProxyFactory(MBeanProxyFactory newProxyFactory) {\n+    this.proxyFactory = newProxyFactory;\n+  }\n+\n   /**\n    * This method will be invoked whenever a member wants to be a managing node. The exception\n    * Management exception has to be handled by the caller.",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java",
                "sha": "fde2cd032ff010eacf92097c106a43d9ae4f39be",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/MBeanJMXAdapter.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/MBeanJMXAdapter.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/MBeanJMXAdapter.java",
                "patch": "@@ -97,6 +97,11 @@ public ObjectName registerMBean(Object object, ObjectName objectName, boolean is\n         newObjectName = ObjectName.getInstance(\n             OBJECTNAME__PREFIX + objectKeyProperty + KEYVAL_SEPARATOR + \"member=\" + member);\n       }\n+\n+      if (isRegistered(newObjectName)) {\n+        return newObjectName;\n+      }\n+\n       mbeanServer.registerMBean(object, newObjectName);\n       this.localGemFireMBean.put(newObjectName, object);\n ",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/MBeanJMXAdapter.java",
                "sha": "42a10509b6184d6ad194dbd4af604b350fa3e635",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 8,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java",
                "patch": "@@ -16,6 +16,7 @@\n \n import java.beans.IntrospectionException;\n import java.util.Iterator;\n+import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Set;\n \n@@ -78,14 +79,13 @@ public void createProxy(DistributedMember member, ObjectName objectName,\n       Region<String, Object> monitoringRegion, Object newVal) {\n \n     try {\n-      String name = objectName.toString();\n-      FederationComponent federationComponent = (FederationComponent) monitoringRegion.get(name);\n+      FederationComponent federationComponent = (FederationComponent) newVal;\n       String interfaceClassName = federationComponent.getMBeanInterfaceClass();\n \n       Class interfaceClass = ClassLoadUtil.classFromName(interfaceClassName);\n \n       Object object = MBeanProxyInvocationHandler.newProxyInstance(member, monitoringRegion,\n-          objectName, interfaceClass);\n+          objectName, federationComponent, interfaceClass);\n \n       jmxAdapter.registerMBeanProxy(object, objectName);\n \n@@ -123,19 +123,18 @@ public void createAllProxies(DistributedMember member, Region<String, Object> mo\n       logger.debug(\"Creating proxy for: {}\", member.getId());\n     }\n \n-    Set<String> mbeanNames = monitoringRegion.keySet();\n+    Set<Map.Entry<String, Object>> mbeans = monitoringRegion.entrySet();\n \n-    for (String mbeanName : mbeanNames) {\n+    for (Map.Entry<String, Object> mbean : mbeans) {\n \n       ObjectName objectName = null;\n       try {\n-        objectName = ObjectName.getInstance(mbeanName);\n+        objectName = ObjectName.getInstance(mbean.getKey());\n         if (logger.isDebugEnabled()) {\n           logger.debug(\"Creating proxy for ObjectName: \" + objectName.toString());\n         }\n \n-        createProxy(member, objectName, monitoringRegion,\n-            monitoringRegion.get(objectName.toString()));\n+        createProxy(member, objectName, monitoringRegion, mbean.getValue());\n       } catch (Exception e) {\n         logger.warn(\"Create Proxy failed for {} with exception {}\", objectName, e.getMessage(), e);\n       }",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java",
                "sha": "212ac65a7472dbda00f2335cbb723e6fd46248ec",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyInvocationHandler.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyInvocationHandler.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 3,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyInvocationHandler.java",
                "patch": "@@ -94,11 +94,11 @@\n    * @param interfaceClass on which interface the proxy to be exposed\n    */\n   public static Object newProxyInstance(DistributedMember member,\n-      Region<String, Object> monitoringRegion, ObjectName objectName, Class interfaceClass)\n+      Region<String, Object> monitoringRegion, ObjectName objectName,\n+      FederationComponent federationComponent, Class interfaceClass)\n       throws ClassNotFoundException, IntrospectionException {\n     boolean isMXBean = JMX.isMXBeanInterface(interfaceClass);\n-    boolean notificationBroadcaster =\n-        ((FederationComponent) monitoringRegion.get(objectName.toString())).isNotificationEmitter();\n+    boolean notificationBroadcaster = federationComponent.isNotificationEmitter();\n \n     InvocationHandler handler =\n         new MBeanProxyInvocationHandler(member, objectName, monitoringRegion, isMXBean);",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyInvocationHandler.java",
                "sha": "7855fffebc1e1622a83f13a2f54d5e72289bf68d",
                "status": "modified"
            },
            {
                "additions": 189,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/test/java/org/apache/geode/management/internal/JMXMBeanFederationDUnitTest.java",
                "changes": 189,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/management/internal/JMXMBeanFederationDUnitTest.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 0,
                "filename": "geode-core/src/test/java/org/apache/geode/management/internal/JMXMBeanFederationDUnitTest.java",
                "patch": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+import javax.management.remote.JMXConnector;\n+import javax.management.remote.JMXConnectorFactory;\n+import javax.management.remote.JMXServiceURL;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.ConfigurationProperties;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.internal.InternalBlackboard;\n+import org.apache.geode.test.dunit.internal.InternalBlackboardImpl;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.DistributedTest;\n+import org.apache.geode.test.junit.categories.JMXTest;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.MBeanServerConnectionRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+@Category({DistributedTest.class, JMXTest.class})\n+public class JMXMBeanFederationDUnitTest {\n+  private static final String LOCATOR_1_NAME = \"locator-one\";\n+  private static final String LOCATOR_2_NAME = \"locator-two\";\n+  private static final String REGION_PATH = \"/test-region-1\";\n+  private static final int LOCATOR_1_VM_INDEX = 0;\n+  private static final int LOCATOR_2_VM_INDEX = 4;\n+  private static final int LOCATOR_COUNT = 1;\n+  private static final int SERVER_1_VM_INDEX = 1;\n+  private static final int SERVER_2_VM_INDEX = 2;\n+  private static final int SERVER_3_VM_INDEX = 3;\n+  private static int SERVER_COUNT = 2;\n+\n+  private int locator1JmxPort;\n+  private int locator2JmxPort;\n+\n+  private MemberVM locator1, locator2, server1, server2, server3;\n+\n+  private InternalBlackboard bb;\n+\n+  @Rule\n+  public ClusterStartupRule lsRule = new ClusterStartupRule();\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public MBeanServerConnectionRule jmxConnectionRule = new MBeanServerConnectionRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Before\n+  public void before() throws Exception {\n+    locator1JmxPort = AvailablePortHelper.getRandomAvailableTCPPorts(LOCATOR_COUNT)[0];\n+    locator1 = lsRule.startLocatorVM(LOCATOR_1_VM_INDEX, locator1Properties());\n+\n+    server1 = lsRule.startServerVM(SERVER_1_VM_INDEX, locator1.getPort());\n+    server2 = lsRule.startServerVM(SERVER_2_VM_INDEX, locator1.getPort());\n+\n+    gfsh.connectAndVerify(locator1);\n+    gfsh.executeAndAssertThat(\n+        \"create region --type=REPLICATE --name=\" + REGION_PATH + \" --enable-statistics=true\")\n+        .statusIsSuccess();\n+    gfsh.disconnect();\n+\n+    locator1.waitTillRegionsAreReadyOnServers(REGION_PATH, SERVER_COUNT);\n+\n+    bb = InternalBlackboardImpl.getInstance();\n+  }\n+\n+  @Test\n+  public void MBeanFederationAddRemoveServer() throws IOException {\n+    List<String> initialMBeans = getFederatedGemfireBeansFrom(locator1);\n+\n+    server3 = lsRule.startServerVM(SERVER_3_VM_INDEX, locator1.getPort());\n+    SERVER_COUNT++;\n+    locator1.waitTillRegionsAreReadyOnServers(REGION_PATH, SERVER_COUNT);\n+    List keyset = server3.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      DistributedMember member =\n+          InternalDistributedSystem.getConnectedInstance().getDistributedMember();\n+      String appender = MBeanJMXAdapter.getUniqueIDForMember(member);\n+      Region monitoringRegion =\n+          cache.getRegion(ManagementConstants.MONITORING_REGION + \"_\" + appender);\n+      List l = (List<String>) monitoringRegion.keySet().stream().collect(Collectors.toList());\n+      return l;\n+    });\n+\n+    List<String> intermediateMBeans = getFederatedGemfireBeansFrom(locator1);\n+    List<String> expectedMBeans = new ArrayList<>();\n+    expectedMBeans.addAll(initialMBeans);\n+    expectedMBeans.addAll(keyset);\n+    expectedMBeans = expectedMBeans.stream().sorted().collect(Collectors.toList());\n+    intermediateMBeans = intermediateMBeans.stream().sorted().collect(Collectors.toList());\n+    assertThat(intermediateMBeans).containsExactlyElementsOf(expectedMBeans);\n+\n+    lsRule.stopMember(SERVER_3_VM_INDEX);\n+    SERVER_COUNT--;\n+    locator1.waitTillRegionsAreReadyOnServers(REGION_PATH, SERVER_COUNT);\n+\n+    List<String> finalMBeans = getFederatedGemfireBeansFrom(locator1);\n+\n+    assertThat(finalMBeans).containsExactlyElementsOf(initialMBeans);\n+  }\n+\n+  private static List<String> getFederatedGemfireBeansFrom(MemberVM member)\n+      throws IOException {\n+    String url = jmxBeanLocalhostUrlString(member.getJmxPort());\n+    MBeanServerConnection remoteMBS = connectToMBeanServer(url);\n+    Set<ObjectName> allBeanNames = remoteMBS.queryNames(null, null);\n+    // Each locator will have a \"Manager\" bean that is a part of the above query,\n+    // representing the ManagementAdapter.\n+    // This bean is registered (and so included in its own queries),\n+    // but *not* federated (and so is not included in another locator's bean queries).\n+    // For the scope of this test, we do not consider these \"service=Manager\" beans.\n+    Set<String> allBeans = new HashSet<>();\n+    for (ObjectName bean : allBeanNames) {\n+      allBeans.add(bean.toString());\n+    }\n+\n+    return allBeans.stream()\n+        .filter(b -> b.contains(\"GemFire\"))\n+        .sorted()\n+        .collect(toList());\n+  }\n+\n+  private static MBeanServerConnection connectToMBeanServer(String url) throws IOException {\n+    final JMXServiceURL serviceURL = new JMXServiceURL(url);\n+    JMXConnector conn = JMXConnectorFactory.connect(serviceURL);\n+    return conn.getMBeanServerConnection();\n+  }\n+\n+  private static String jmxBeanLocalhostUrlString(int port) {\n+    return \"service:jmx:rmi:///jndi/rmi://localhost\"\n+        + \":\" + port + \"/jmxrmi\";\n+  }\n+\n+  private Properties locator1Properties() {\n+    Properties props = new Properties();\n+    props.setProperty(ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, \"localhost\");\n+    props.setProperty(ConfigurationProperties.JMX_MANAGER_PORT, \"\" + locator1JmxPort);\n+    props.setProperty(ConfigurationProperties.NAME, LOCATOR_1_NAME);\n+    return props;\n+  }\n+\n+  private Properties locator2Properties() {\n+    locator2JmxPort = AvailablePortHelper.getRandomAvailableTCPPorts(LOCATOR_COUNT)[0];\n+    Properties props = new Properties();\n+    props.setProperty(ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, \"localhost\");\n+    props.setProperty(ConfigurationProperties.JMX_MANAGER_PORT, \"\" + locator2JmxPort);\n+    props.setProperty(ConfigurationProperties.NAME, LOCATOR_2_NAME);\n+    return props;\n+  }\n+}",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/test/java/org/apache/geode/management/internal/JMXMBeanFederationDUnitTest.java",
                "sha": "e08975d505970f370fe9fd1b1cfaf91106d42a48",
                "status": "added"
            },
            {
                "additions": 128,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/test/java/org/apache/geode/management/internal/MBeanFederationErrorPathDUnitTest.java",
                "changes": 128,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/management/internal/MBeanFederationErrorPathDUnitTest.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 0,
                "filename": "geode-core/src/test/java/org/apache/geode/management/internal/MBeanFederationErrorPathDUnitTest.java",
                "patch": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.spy;\n+\n+import java.rmi.RemoteException;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.internal.InternalBlackboard;\n+import org.apache.geode.test.dunit.internal.InternalBlackboardImpl;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.DistributedTest;\n+import org.apache.geode.test.junit.categories.JMXTest;\n+import org.apache.geode.test.junit.rules.LocatorStarterRule;\n+\n+@Category({DistributedTest.class, JMXTest.class})\n+public class MBeanFederationErrorPathDUnitTest {\n+  private static final int SERVER_1_VM_INDEX = 1;\n+  private static final String REGION_NAME = \"test-region-1\";\n+\n+  public MemberVM server1, server2, server3;\n+\n+  @Rule\n+  public LocatorStarterRule locator1 = new LocatorStarterRule();\n+\n+  @Rule\n+  public ClusterStartupRule lsRule = new ClusterStartupRule();\n+\n+\n+  private InternalBlackboard bb;\n+\n+  @Before\n+  public void before() throws Exception {\n+    locator1.withJMXManager().startLocator();\n+\n+    bb = InternalBlackboardImpl.getInstance();\n+  }\n+\n+  @Test\n+  public void destroyMBeanBeforeFederationCompletes()\n+      throws MalformedObjectNameException, RemoteException {\n+    String bbKey = \"sync1\";\n+\n+    String beanName = \"GemFire:service=Region,name=\\\"/test-region-1\\\",type=Member,member=server-1\";\n+    ObjectName objectName = new ObjectName(beanName);\n+\n+    InternalCache cache = locator1.getCache();\n+    SystemManagementService service =\n+        (SystemManagementService) ManagementService.getManagementService(cache);\n+    FederatingManager federatingManager = service.getFederatingManager();\n+    MBeanProxyFactory mBeanProxyFactory = federatingManager.getProxyFactory();\n+    MBeanProxyFactory spy = spy(mBeanProxyFactory);\n+    service.getFederatingManager().setProxyFactory(spy);\n+\n+    Answer answer1 = new Answer<Object>() {\n+      @Override\n+      public Object answer(InvocationOnMock invocation) throws Throwable {\n+        server1.invoke(() -> {\n+          InternalCache serverCache = ClusterStartupRule.getCache();\n+          Region region = serverCache.getRegionByPath(\"/\" + REGION_NAME);\n+          region.destroyRegion();\n+        });\n+\n+        Region<String, Object> monitoringRegion = invocation.getArgument(2);\n+        monitoringRegion.destroy(objectName.toString());\n+\n+        assertThat((monitoringRegion).get(objectName.toString())).isNull();\n+\n+        try {\n+          invocation.callRealMethod();\n+        } catch (Exception e) {\n+          bb.setMailbox(bbKey, e);\n+          return null;\n+        }\n+        bb.setMailbox(bbKey, \"this is fine\");\n+        return null;\n+      }\n+    };\n+\n+    doAnswer(answer1).when(spy).createProxy(any(), eq(objectName), any(), any());\n+\n+    server1 = lsRule.startServerVM(SERVER_1_VM_INDEX, locator1.getPort());\n+\n+    server1.invoke(() -> {\n+      InternalCache cache1 = ClusterStartupRule.getCache();\n+      cache1.createRegionFactory(RegionShortcut.REPLICATE).create(REGION_NAME);\n+    });\n+\n+    Awaitility.waitAtMost(10, TimeUnit.SECONDS).until(() -> bb.getMailbox(bbKey) != null);\n+    Object e = bb.getMailbox(\"sync1\");\n+\n+    assertThat(e).isNotInstanceOf(NullPointerException.class);\n+    assertThat((String) e).contains(\"this is fine\");\n+  }\n+}",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/test/java/org/apache/geode/management/internal/MBeanFederationErrorPathDUnitTest.java",
                "sha": "26e083ea56726c1a08de996ff4e34101446ae871",
                "status": "added"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/geode/blob/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java?ref=29c71c96f2933e8380e412e9d14b42beb30ae96b",
                "deletions": 1,
                "filename": "geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java",
                "patch": "@@ -264,7 +264,8 @@ public ManagementService getManagementService() {\n   public void waitTillRegionIsReadyOnServers(String regionName, int serverCount) {\n     await().atMost(30, TimeUnit.SECONDS).until(() -> getRegionMBean(regionName) != null);\n     await().atMost(30, TimeUnit.SECONDS)\n-        .until(() -> getRegionMBean(regionName).getMembers().length == serverCount);\n+        .until(() -> getRegionMBean(regionName).getMembers() != null\n+            && getRegionMBean(regionName).getMembers().length == serverCount);\n   }\n \n   private long getDiskStoreCount(String diskStoreName) {",
                "raw_url": "https://github.com/apache/geode/raw/29c71c96f2933e8380e412e9d14b42beb30ae96b/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java",
                "sha": "684f94b1298d9fbaf4f30ed7d6ab48e59bebf7ba",
                "status": "modified"
            }
        ],
        "message": "GEODE-5281: replicate failure and fix bug (#2096)\n\n* GEODE-5281: replicate failure and fix bug\r\n\r\n- replicate the bad timing using a DUnit test\r\n- fix the bug by only doing one lookup of MBeans\r\n- add more tests\r\n- fix potential NPE in waiting for regions to be ready on servers\r\n\r\nCo-authored-by: Kenneth Howe <khowe@pivotal.io>\r\n\r\n* add TestingOnly annotation to setter\r\n\r\nadd a TestingOnly annotation to setter for ProxyFactory in the\r\nFederatingManager for injecting test spies.",
        "parent": "https://github.com/apache/geode/commit/935743586a874dce4b4b780aefe0c653d42f8902",
        "repo": "geode",
        "unit_tests": [
            "MemberStarterRuleTest.java"
        ]
    },
    "geode_2f69575": {
        "bug_id": "geode_2f69575",
        "commit": "https://github.com/apache/geode/commit/2f695753cf145fca5f927cd0935cf2b82e5cf942",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/2f695753cf145fca5f927cd0935cf2b82e5cf942/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/TXState.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/TXState.java?ref=2f695753cf145fca5f927cd0935cf2b82e5cf942",
                "deletions": 1,
                "filename": "geode-core/src/main/java/com/gemstone/gemfire/internal/cache/TXState.java",
                "patch": "@@ -1351,7 +1351,7 @@ protected TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion,\n       boolean rememberRead, Object expectedOldValue, boolean createIfAbsent)\n   throws EntryNotFoundException\n   {\n-    LocalRegion dataReg = localRegion.getDataRegionForRead(keyInfo);\n+    LocalRegion dataReg = localRegion.getDataRegionForWrite(keyInfo);\n     TXRegionState txr = txReadRegion(dataReg);\n     TXEntryState result = null;\n     if (txr != null) {",
                "raw_url": "https://github.com/apache/geode/raw/2f695753cf145fca5f927cd0935cf2b82e5cf942/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/TXState.java",
                "sha": "9b38d56f55bd585140737c63cc54ae3d72e2dd08",
                "status": "modified"
            }
        ],
        "message": "GEODE-983: NPE with transactions on PR with overflow\n\nmaking sure that the BucketRegion is created before trying to read/write from it.\nFixes tests failing in nightly build.",
        "parent": "https://github.com/apache/geode/commit/3676826a227ce0fe22a7d5cda184185a4c3c1c1e",
        "repo": "geode",
        "unit_tests": [
            "TXStateTest.java"
        ]
    },
    "geode_4290946": {
        "bug_id": "geode_4290946",
        "commit": "https://github.com/apache/geode/commit/4290946d9dab98450964bbf498beea2bee650a3f",
        "file": [
            {
                "additions": 413,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionAttributesIntegrationTest.java",
                "changes": 413,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionAttributesIntegrationTest.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 0,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionAttributesIntegrationTest.java",
                "patch": "@@ -0,0 +1,413 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.cache.EvictionAction.OVERFLOW_TO_DISK;\n+import static org.apache.geode.cache.EvictionAttributes.createLRUEntryAttributes;\n+import static org.apache.geode.cache.RegionShortcut.LOCAL;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.ErrorCollector;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestName;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.EvictionAttributes;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+\n+/**\n+ * Extracted and exploded {@code testDiskRegDWAttrbts} from {@link DiskRegionJUnitTest}.\n+ */\n+public class DiskRegionAttributesIntegrationTest {\n+\n+  private static final long MAX_OPLOG_SIZE_IN_BYTES = 1024 * 1024 * 1024 * 10L;\n+\n+  private InternalCache cache;\n+  private EvictionAttributes evictionAttributes;\n+\n+  private File[] diskDirs;\n+  private int[] diskDirSizes;\n+\n+  private String regionName;\n+  private String diskStoreName;\n+\n+  @Rule\n+  public ErrorCollector errorCollector = new ErrorCollector();\n+\n+  @Rule\n+  public ExecutorServiceRule executorServiceRule = new ExecutorServiceRule();\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Rule\n+  public TestName testName = new TestName();\n+\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    String uniqueName = getClass().getSimpleName() + \"_\" + testName.getMethodName();\n+    regionName = uniqueName + \"_region\";\n+    diskStoreName = uniqueName + \"_diskStore\";\n+\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"\");\n+\n+    cache = (InternalCache) new CacheFactory(config).create();\n+\n+    diskDirs = new File[4];\n+    diskDirs[0] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"1\");\n+    diskDirs[1] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"2\");\n+    diskDirs[2] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"3\");\n+    diskDirs[3] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"4\");\n+\n+    // set default values of disk dir sizes here\n+    diskDirSizes = new int[4];\n+    diskDirSizes[0] = Integer.MAX_VALUE;\n+    diskDirSizes[1] = Integer.MAX_VALUE;\n+    diskDirSizes[2] = Integer.MAX_VALUE;\n+    diskDirSizes[3] = Integer.MAX_VALUE;\n+\n+    evictionAttributes = createLRUEntryAttributes(1000, OVERFLOW_TO_DISK);\n+\n+    DiskStoreImpl.SET_IGNORE_PREALLOCATE = true;\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    try {\n+      if (cache != null) {\n+        cache.close();\n+      }\n+    } finally {\n+      DiskStoreImpl.SET_IGNORE_PREALLOCATE = false;\n+    }\n+  }\n+\n+  @Test\n+  public void syncPersistentWithAutoCompact() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(true);\n+    verifyRegionAndDiskStoreAttributes(true, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void syncPersistent() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(false);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(true);\n+    verifyRegionAndDiskStoreAttributes(false, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void asyncPersistentWithAutoCompact() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(false);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(false);\n+    verifyRegionAndDiskStoreAttributes(true, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void asyncPersistent() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(false);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(false);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(false);\n+    verifyRegionAndDiskStoreAttributes(false, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void syncOverflowWithAutoCompact() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(true);\n+    verifyRegionAndDiskStoreAttributes(true, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void syncOverflow() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(false);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(true);\n+    verifyRegionAndDiskStoreAttributes(false, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void asyncOverflowWithAutoCompact() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+    diskStoreFactory.setQueueSize(10_000);\n+    diskStoreFactory.setTimeInterval(15);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(false);\n+\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(false);\n+    verifyRegionAndDiskStoreAttributes(true, MAX_OPLOG_SIZE_IN_BYTES, 10_000, 15);\n+  }\n+\n+  @Test\n+  public void asyncOverflowWithEviction() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(false);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+    diskStoreFactory.setTimeInterval(15);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(false);\n+\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(false);\n+    verifyRegionAndDiskStoreAttributes(false, MAX_OPLOG_SIZE_IN_BYTES, 0, 15);\n+  }\n+\n+  @Test\n+  public void syncPersistentWithOverflowAndAutoCompact() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(true);\n+    verifyRegionAndDiskStoreAttributes(true, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void syncPersistentWithOverflow() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(false);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(true);\n+    verifyRegionAndDiskStoreAttributes(false, MAX_OPLOG_SIZE_IN_BYTES, 0, -1);\n+  }\n+\n+  @Test\n+  public void asyncPersistentWithOverflowAndAutoCompactAndBuffer() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+    diskStoreFactory.setQueueSize(10_000);\n+    diskStoreFactory.setTimeInterval(15);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(false);\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(false);\n+    verifyRegionAndDiskStoreAttributes(true, MAX_OPLOG_SIZE_IN_BYTES, 10_000, 15);\n+  }\n+\n+  @Test\n+  public void asyncPersistentWithOverflowAndBuffer() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(false);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+    diskStoreFactory.setTimeInterval(15);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, MAX_OPLOG_SIZE_IN_BYTES);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(false);\n+    regionFactory.setEvictionAttributes(evictionAttributes);\n+\n+    Region region = regionFactory.create(regionName);\n+\n+    assertThat(region.getAttributes().isDiskSynchronous()).isEqualTo(false);\n+    verifyRegionAndDiskStoreAttributes(false, MAX_OPLOG_SIZE_IN_BYTES, 0, 15);\n+  }\n+\n+  private File createDirectory(File parentDirectory, String name) {\n+    File file = new File(parentDirectory, name);\n+    assertThat(file.mkdir()).isTrue();\n+    return file;\n+  }\n+\n+  private void createDiskStoreWithSizeInBytes(String diskStoreName,\n+      DiskStoreFactory diskStoreFactory, long maxOplogSizeInBytes) {\n+    ((DiskStoreFactoryImpl) diskStoreFactory).setMaxOplogSizeInBytes(maxOplogSizeInBytes);\n+    DirectoryHolder.SET_DIRECTORY_SIZE_IN_BYTES_FOR_TESTING_PURPOSES = true;\n+    try {\n+      diskStoreFactory.create(diskStoreName);\n+    } finally {\n+      DirectoryHolder.SET_DIRECTORY_SIZE_IN_BYTES_FOR_TESTING_PURPOSES = false;\n+    }\n+  }\n+\n+  private void verifyRegionAndDiskStoreAttributes(boolean autoCompact, long maxOplogSizeInBytes,\n+      int bytesThreshold, int timeInterval) {\n+    DiskStore diskStore = cache.findDiskStore(diskStoreName);\n+\n+    assertThat(diskStore.getAutoCompact()).isEqualTo(autoCompact);\n+\n+    int expectedDiskDirsCount = diskDirs.length;\n+    int actualDiskDirsCount = diskStore.getDiskDirs().length;\n+    assertThat(actualDiskDirsCount).isEqualTo(expectedDiskDirsCount);\n+\n+    int[] expectedDiskDirSizes = diskDirSizes;\n+    if (expectedDiskDirSizes == null) {\n+      expectedDiskDirSizes = new int[expectedDiskDirsCount];\n+      Arrays.fill(expectedDiskDirSizes, Integer.MAX_VALUE);\n+    }\n+\n+    int[] actualDiskDirSizes = diskStore.getDiskDirSizes();\n+    for (int i = 0; i < expectedDiskDirsCount; i++) {\n+      assertThat(actualDiskDirSizes[i]).isEqualTo(expectedDiskDirSizes[i]);\n+    }\n+\n+    assertThat(diskStore.getDiskUsageWarningPercentage())\n+        .isEqualTo(DiskStoreFactory.DEFAULT_DISK_USAGE_WARNING_PERCENTAGE);\n+    assertThat(diskStore.getDiskUsageCriticalPercentage())\n+        .isEqualTo(DiskStoreFactory.DEFAULT_DISK_USAGE_CRITICAL_PERCENTAGE);\n+    assertThat(diskStore.getMaxOplogSize()).isEqualTo(maxOplogSizeInBytes / (1024 * 1024));\n+    assertThat(diskStore.getQueueSize()).isEqualTo(bytesThreshold);\n+\n+    if (timeInterval != -1) {\n+      assertThat(diskStore.getTimeInterval()).isEqualTo(timeInterval);\n+    } else {\n+      assertThat(diskStore.getTimeInterval()).isEqualTo(DiskStoreFactory.DEFAULT_TIME_INTERVAL);\n+    }\n+  }\n+}",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionAttributesIntegrationTest.java",
                "sha": "8996aacaad92c088e714a94878c8584185460a08",
                "status": "added"
            },
            {
                "additions": 189,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionCompactorCloseIntegrationTest.java",
                "changes": 189,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionCompactorCloseIntegrationTest.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 0,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionCompactorCloseIntegrationTest.java",
                "patch": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.apache.geode.cache.RegionShortcut.LOCAL;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ErrorCollector;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestName;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.DiskAccessException;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+\n+/**\n+ * Extracted {@code testCompactorClose} from {@link DiskRegionJUnitTest}.\n+ */\n+public class DiskRegionCompactorCloseIntegrationTest {\n+\n+  private final CountDownLatch beforeGoingToCompactLatch = new CountDownLatch(1);\n+  private final AtomicBoolean afterStoppingCompactor = new AtomicBoolean();\n+\n+  private final Properties config = new Properties();\n+  private Cache cache;\n+\n+  private File[] diskDirs;\n+  private int[] diskDirSizes;\n+\n+  private String uniqueName;\n+  private String regionName;\n+  private String diskStoreName;\n+\n+  @Rule\n+  public ErrorCollector errorCollector = new ErrorCollector();\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Rule\n+  public TestName testName = new TestName();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    uniqueName = getClass().getSimpleName() + \"_\" + testName.getMethodName();\n+    regionName = uniqueName + \"_region\";\n+    diskStoreName = uniqueName + \"_diskStore\";\n+\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"\");\n+\n+    cache = new CacheFactory(config).create();\n+\n+    diskDirs = new File[4];\n+    diskDirs[0] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"1\");\n+    diskDirs[1] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"2\");\n+    diskDirs[2] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"3\");\n+    diskDirs[3] = createDirectory(temporaryFolder.getRoot(), testName.getMethodName() + \"4\");\n+\n+    diskDirSizes = new int[4];\n+    Arrays.fill(diskDirSizes, Integer.MAX_VALUE);\n+\n+    DiskStoreImpl.SET_IGNORE_PREALLOCATE = true;\n+    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    try {\n+      beforeGoingToCompactLatch.countDown();\n+      cache.close();\n+    } finally {\n+      CacheObserverHolder.setInstance(null);\n+      DiskStoreImpl.SET_IGNORE_PREALLOCATE = false;\n+      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n+      disconnectAllFromDS();\n+    }\n+  }\n+\n+  @Test\n+  public void testCompactorClose() {\n+    DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setCompactionThreshold(100);\n+    diskStoreFactory.setDiskDirsAndSizes(diskDirs, diskDirSizes);\n+\n+    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n+\n+    RegionFactory<Object, Object> regionFactory = cache.createRegionFactory(LOCAL);\n+    regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n+    regionFactory.setDiskStoreName(diskStoreName);\n+    regionFactory.setDiskSynchronous(true);\n+\n+    Region<Object, Object> region = regionFactory.create(regionName);\n+\n+    CacheObserverHolder.setInstance(new CompactorCacheObserver(region));\n+\n+    for (int i = 0; i < 10; ++i) {\n+      region.put(i, new byte[10]);\n+    }\n+\n+    beforeGoingToCompactLatch.countDown();\n+\n+    await().atMost(5, MINUTES).untilAsserted(() -> assertThat(afterStoppingCompactor).isTrue());\n+\n+    assertThat(region.isDestroyed()).isTrue();\n+  }\n+\n+  private File createDirectory(File parentDirectory, String name) {\n+    File file = new File(parentDirectory, name);\n+    assertThat(file.mkdir()).isTrue();\n+    return file;\n+  }\n+\n+  private void createDiskStoreWithSizeInBytes(String diskStoreName,\n+      DiskStoreFactory diskStoreFactory,\n+      long maxOplogSizeInBytes) {\n+    ((DiskStoreFactoryImpl) diskStoreFactory).setMaxOplogSizeInBytes(maxOplogSizeInBytes);\n+    DirectoryHolder.SET_DIRECTORY_SIZE_IN_BYTES_FOR_TESTING_PURPOSES = true;\n+    try {\n+      diskStoreFactory.create(diskStoreName);\n+    } finally {\n+      DirectoryHolder.SET_DIRECTORY_SIZE_IN_BYTES_FOR_TESTING_PURPOSES = false;\n+    }\n+  }\n+\n+  private class CompactorCacheObserver extends CacheObserverAdapter {\n+\n+    private final Region<?, ?> region;\n+\n+    CompactorCacheObserver(Region<?, ?> region) {\n+      this.region = region;\n+    }\n+\n+    @Override\n+    public void beforeGoingToCompact() {\n+      try {\n+        beforeGoingToCompactLatch.await(5, MINUTES);\n+      } catch (Exception e) {\n+        errorCollector.addError(e);\n+      }\n+    }\n+\n+    @Override\n+    public void beforeDeletingCompactedOplog(Oplog compactedOplog) {\n+      // compactor will attempt to destroy the region\n+      throw new DiskAccessException(uniqueName + \"_IGNORE_EXCEPTION\", region);\n+    }\n+\n+    @Override\n+    public void afterStoppingCompactor() {\n+      // compactor destroyed the region and stopped\n+      afterStoppingCompactor.set(true);\n+    }\n+  }\n+}",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionCompactorCloseIntegrationTest.java",
                "sha": "e2af22d4136390f7de31be109c411897bcdf1270",
                "status": "added"
            },
            {
                "additions": 1934,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java",
                "changes": 4040,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 2106,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java",
                "sha": "af60aca498efb0c3f81d3920a2383310bdff6ec0",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/AbstractRegion.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/AbstractRegion.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/AbstractRegion.java",
                "patch": "@@ -1793,6 +1793,11 @@ public InternalCache getGemFireCache() {\n     return this.cache;\n   }\n \n+  @Override\n+  public InternalCache getInternalCache() {\n+    return cache;\n+  }\n+\n   @Override\n   public RegionSnapshotService getSnapshotService() {\n     return new RegionSnapshotServiceImpl(this);",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/AbstractRegion.java",
                "sha": "c313c830ee6c20af0a92c8f8c5276f3b8a5347cc",
                "status": "modified"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/InternalPersistentRegion.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/InternalPersistentRegion.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalPersistentRegion.java",
                "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import org.apache.geode.cache.EntryNotFoundException;\n+import org.apache.geode.internal.cache.persistence.DiskRecoveryStore;\n+\n+public interface InternalPersistentRegion extends InternalRegion, DiskRecoveryStore {\n+\n+  Object getValueOnDiskOrBuffer(Object key) throws EntryNotFoundException;\n+}",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/InternalPersistentRegion.java",
                "sha": "7989cf0a9724e5aefe31e0ab39ff40839d9f43b3",
                "status": "added"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java",
                "patch": "@@ -410,4 +410,5 @@ default void handleWANEvent(EntryEventImpl event) {}\n \n   MemoryThresholdInfo getAtomicThresholdInfo();\n \n+  InternalCache getInternalCache();\n }",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java",
                "sha": "d21d1304663ac141f4ae49156053f3cd757ca82c",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java?ref=4290946d9dab98450964bbf498beea2bee650a3f",
                "deletions": 2,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java",
                "patch": "@@ -185,7 +185,6 @@\n import org.apache.geode.internal.cache.partitioned.RedundancyAlreadyMetException;\n import org.apache.geode.internal.cache.persistence.DefaultDiskDirs;\n import org.apache.geode.internal.cache.persistence.DiskExceptionHandler;\n-import org.apache.geode.internal.cache.persistence.DiskRecoveryStore;\n import org.apache.geode.internal.cache.persistence.DiskRegionView;\n import org.apache.geode.internal.cache.persistence.PersistentMemberID;\n import org.apache.geode.internal.cache.persistence.query.IndexMap;\n@@ -233,7 +232,7 @@\n  */\n @SuppressWarnings(\"deprecation\")\n public class LocalRegion extends AbstractRegion implements LoaderHelperFactory,\n-    ResourceListener<MemoryEvent>, DiskExceptionHandler, DiskRecoveryStore {\n+    ResourceListener<MemoryEvent>, DiskExceptionHandler, InternalPersistentRegion {\n \n   // package-private to avoid synthetic accessor\n   static final Logger logger = LogService.getLogger();",
                "raw_url": "https://github.com/apache/geode/raw/4290946d9dab98450964bbf498beea2bee650a3f/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java",
                "sha": "d6ce8a285268ada3cb26d8d72731aebb8a7ce5f5",
                "status": "modified"
            }
        ],
        "message": "GEODE-4273: overhaul DiskRegionJUnitTest (#2449)\n\n* Remove use of base class\r\n* Extract testCompactorClose to DiskRegionCompactorCloseIntegrationTest\r\n* Extract testDiskRegDWAttrbts to DiskRegionAttributesIntegrationTest\r\n* GEODE-3900: Use TemporaryFolder for all disk dirs and files\r\n* Ensure Cache and DS have proper tearDown\r\n* Use Rules, Awaitility, and AssertJ\r\n* Use CountDownLatch instead of verbose synchronization tricks\r\n* Minimize usage of non-User APIs\r\n* Fix usage of deprecated APIs\r\n* Use proper variable names\r\n* Use MAX_OPLOG_SIZE_IN_BYTES instead of literal value\r\n* Protect AtomicReferences with Awaitility to prevent NPEs",
        "parent": "https://github.com/apache/geode/commit/d9bb24d95bd7d310ae0ce693fe1d84774c2f521c",
        "repo": "geode",
        "unit_tests": [
            "LocalRegionTest.java"
        ]
    },
    "geode_4339918": {
        "bug_id": "geode_4339918",
        "commit": "https://github.com/apache/geode/commit/43399189db2a122e0cc17191636a61a1b5ddc094",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/43399189db2a122e0cc17191636a61a1b5ddc094/geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java?ref=43399189db2a122e0cc17191636a61a1b5ddc094",
                "deletions": 1,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java",
                "patch": "@@ -466,7 +466,7 @@ void putGIIDataInRegion() throws CacheException, InterruptedException {\n           while (iterator.hasNext()) {\n             mapEntry = (Map.Entry) iterator.next();\n             Conflatable val = (Conflatable) mapEntry.getValue();\n-            if (val.getEventId() != null) { // bug #44959 null event ID caused NPE\n+            if (val != null && val.getEventId() != null) {\n               counterInRegion = ((Long) mapEntry.getKey()).intValue();\n               // TODO: remove this assertion\n               Assert.assertTrue(counterInRegion > max);",
                "raw_url": "https://github.com/apache/geode/raw/43399189db2a122e0cc17191636a61a1b5ddc094/geode-core/src/main/java/org/apache/geode/internal/cache/ha/HARegionQueue.java",
                "sha": "70224f2e4884cf9769ab9dce3b8c4a248aba7ef2",
                "status": "modified"
            }
        ],
        "message": "GEODE-2287: Fixed possible conflation NPE in HARegionQueue during gii",
        "parent": "https://github.com/apache/geode/commit/35d123f235f75a6aab298ed2f4dbb8be4c1740da",
        "repo": "geode",
        "unit_tests": [
            "HARegionQueueTest.java"
        ]
    },
    "geode_5eca360": {
        "bug_id": "geode_5eca360",
        "commit": "https://github.com/apache/geode/commit/5eca360b9fc7e637457d60a65091f1a036135a06",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/geode/blob/5eca360b9fc7e637457d60a65091f1a036135a06/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/unsafe/GfshSignalHandler.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/unsafe/GfshSignalHandler.java?ref=5eca360b9fc7e637457d60a65091f1a036135a06",
                "deletions": 3,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/unsafe/GfshSignalHandler.java",
                "patch": "@@ -67,9 +67,10 @@ protected void handleDefault(final sun.misc.Signal sig, final ConsoleReader cons\n     final Signal signal = Signal.valueOfName(sig.getName());\n     switch (signal) {\n       case SIGINT:\n-        String prompt = consoleReader.getPrompt();\n-        consoleReader.resetPromptLine(prompt, \"\", -1);\n-\n+        if (consoleReader != null) {\n+          String prompt = consoleReader.getPrompt();\n+          consoleReader.resetPromptLine(prompt, \"\", -1);\n+        }\n         break;\n       default:\n         final SignalHandler handler = getOriginalSignalHandler(signal);",
                "raw_url": "https://github.com/apache/geode/raw/5eca360b9fc7e637457d60a65091f1a036135a06/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/unsafe/GfshSignalHandler.java",
                "sha": "d95c976d076d8dca0009459825ed56ce85e787c1",
                "status": "modified"
            }
        ],
        "message": "GEODE-6112: Improve robustness for SIGINT handling\n\n- A NPE was being thrown when trying to Ctrl-C a process running `gfsh start\n  locator`. i.e. a non-interactive gfsh session.",
        "parent": "https://github.com/apache/geode/commit/9529403261ec19ecb7e03b27799c33f621fc0452",
        "repo": "geode",
        "unit_tests": [
            "GfshSignalHandlerTest.java"
        ]
    },
    "geode_68e8b7e": {
        "bug_id": "geode_68e8b7e",
        "commit": "https://github.com/apache/geode/commit/68e8b7e7ffe3d337f947f212c35b9a35305a8346",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/geode/blob/68e8b7e7ffe3d337f947f212c35b9a35305a8346/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java?ref=68e8b7e7ffe3d337f947f212c35b9a35305a8346",
                "deletions": 9,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java",
                "patch": "@@ -32,14 +32,12 @@\n \n /**\n  * Instance of this class is responsible for proxy creation/deletion etc.\n- * \n+ *\n  * If a member is added/removed proxy factory is responsible for creating removing the corresponding\n  * proxies for that member.\n- * \n+ *\n  * It also maintains a proxy repository {@link MBeanProxyInfoRepository} for quick access to the\n  * proxy instances\n- * \n- * \n  */\n public class MBeanProxyFactory {\n   private static final Logger logger = LogService.getLogger();\n@@ -80,10 +78,11 @@ public void createProxy(DistributedMember member, ObjectName objectName,\n       Region<String, Object> monitoringRegion, Object newVal) {\n \n     try {\n+      String name = objectName.toString();\n+      FederationComponent federationComponent = (FederationComponent) monitoringRegion.get(name);\n+      String interfaceClassName = federationComponent.getMBeanInterfaceClass();\n \n-      Class interfaceClass = ClassLoadUtil\n-          .classFromName(((FederationComponent) monitoringRegion.get(objectName.toString()))\n-              .getMBeanInterfaceClass());\n+      Class interfaceClass = ClassLoadUtil.classFromName(interfaceClassName);\n \n       Object object = MBeanProxyInvocationHandler.newProxyInstance(member, monitoringRegion,\n           objectName, interfaceClass);\n@@ -112,7 +111,7 @@ public void createProxy(DistributedMember member, ObjectName objectName,\n   /**\n    * This method will create all the proxies for a given DistributedMember. It does not throw any\n    * exception to its caller. It handles the error and logs error messages\n-   * \n+   *\n    * It will be called from GII or when a member joins the system\n    * \n    * @param member {@link org.apache.geode.distributed.DistributedMember}\n@@ -234,7 +233,6 @@ public void updateProxy(ObjectName objectName, ProxyInfo proxyInfo, Object newOb\n    */\n   public <T> T findProxy(ObjectName objectName, Class<T> interfaceClass) {\n \n-\n     return proxyRepo.findProxyByName(objectName, interfaceClass);\n \n ",
                "raw_url": "https://github.com/apache/geode/raw/68e8b7e7ffe3d337f947f212c35b9a35305a8346/geode-core/src/main/java/org/apache/geode/management/internal/MBeanProxyFactory.java",
                "sha": "4f8366a841d6e0fdaec20965042c8f7eaac26dbd",
                "status": "modified"
            }
        ],
        "message": "GEODE-3471: Identify NPE in MBeanProxyFactory",
        "parent": "https://github.com/apache/geode/commit/6a7f3625e08875eb6ab886e6ff11f50e76393bec",
        "repo": "geode",
        "unit_tests": [
            "MBeanProxyFactoryTest.java"
        ]
    },
    "geode_7482c00": {
        "bug_id": "geode_7482c00",
        "commit": "https://github.com/apache/geode/commit/7482c00bfe838414825cbd0d2a39b8c00fa476d5",
        "file": [
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/geode/blob/7482c00bfe838414825cbd0d2a39b8c00fa476d5/geode-core/src/main/java/org/apache/geode/internal/ClassPathLoader.java",
                "changes": 49,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/ClassPathLoader.java?ref=7482c00bfe838414825cbd0d2a39b8c00fa476d5",
                "deletions": 27,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/ClassPathLoader.java",
                "patch": "@@ -16,7 +16,6 @@\n \n import static java.util.stream.Collectors.joining;\n \n-import org.apache.commons.io.FileUtils;\n import org.apache.geode.distributed.internal.DistributionConfig;\n import org.apache.geode.internal.logging.LogService;\n import org.apache.geode.internal.util.CollectionUtils;\n@@ -26,13 +25,13 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.lang.reflect.Proxy;\n-import java.net.MalformedURLException;\n import java.net.URL;\n import java.net.URLClassLoader;\n-import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n \n /**\n  * The delegating <tt>ClassLoader</tt> used by GemFire to load classes and other resources. This\n@@ -57,30 +56,27 @@\n  * <li>4. <tt>ClassLoader.getSystemClassLoader()</tt> If the attempt to acquire any of the above\n  * class loaders results in either a {@link java.lang.SecurityException SecurityException} or a\n  * null, then that class loader is quietly skipped. Duplicate class loaders will be skipped.\n- * \n+ * <p>\n+ * This class it not an extension of ClassLoader due to #43080. See also\n+ * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html\n+ *\n  * @since GemFire 6.5.1.4\n  */\n-public final class ClassPathLoader {\n-  /*\n-   * This class it not an extension of ClassLoader due to reasons outlined in\n-   * https://svn.gemstone.com/trac/gemfire/ticket/43080\n-   * \n-   * See also http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html\n-   */\n+public class ClassPathLoader {\n   private static final Logger logger = LogService.getLogger();\n \n-  public static final String EXCLUDE_TCCL_PROPERTY =\n+  static final String EXCLUDE_TCCL_PROPERTY =\n       DistributionConfig.GEMFIRE_PREFIX + \"excludeThreadContextClassLoader\";\n-  public static final boolean EXCLUDE_TCCL_DEFAULT_VALUE = false;\n \n   private static volatile ClassPathLoader latest;\n \n   private volatile URLClassLoader classLoaderForDeployedJars;\n+\n   private final JarDeployer jarDeployer;\n \n   private boolean excludeTCCL;\n \n-  public void rebuildClassLoaderForDeployedJars() {\n+  void rebuildClassLoaderForDeployedJars() {\n     ClassLoader parent = ClassPathLoader.class.getClassLoader();\n \n     this.classLoaderForDeployedJars = new URLClassLoader(jarDeployer.getDeployedJarURLs(), parent);\n@@ -98,7 +94,7 @@ public ClassPathLoader(boolean excludeTCCL, File workingDir) {\n     rebuildClassLoaderForDeployedJars();\n   }\n \n-  public static ClassPathLoader setLatestToDefault() {\n+  static ClassPathLoader setLatestToDefault() {\n     latest = new ClassPathLoader(Boolean.getBoolean(EXCLUDE_TCCL_PROPERTY));\n     return latest;\n   }\n@@ -112,7 +108,9 @@ public JarDeployer getJarDeployer() {\n     return this.jarDeployer;\n   }\n \n-  // This is exposed for testing.\n+  /**\n+   * createWithDefaults is exposed for testing.\n+   */\n   static ClassPathLoader createWithDefaults(final boolean excludeTCCL) {\n     return new ClassPathLoader(excludeTCCL);\n   }\n@@ -174,7 +172,7 @@ public URL getResource(final String name) {\n   /**\n    * See {@link Proxy#getProxyClass(ClassLoader, Class...)}\n    */\n-  public Class<?> getProxyClass(final Class<?>[] classObjs) {\n+  Class<?> getProxyClass(final Class<?>... classObjs) {\n     IllegalArgumentException ex = null;\n \n     for (ClassLoader classLoader : this.getClassLoaders()) {\n@@ -227,11 +225,9 @@ public URL getResource(final Class<?> contextClass, final String name) {\n \n   /**\n    * Returns an input stream for reading the specified resource.\n-   *\n    * <p>\n    * The search order is described in the documentation for {@link #getResource(String)}.\n-   * </p>\n-   * \n+   *\n    * @param name The resource name\n    * @return An input stream for reading the resource, or <tt>null</tt> if the resource could not be\n    *         found\n@@ -265,7 +261,6 @@ public InputStream getResourceAsStream(final Class<?> contextClass, final String\n     return getResourceAsStream(name);\n   }\n \n-\n   /**\n    * Finds all the resources with the given name. This method will first search the class loader of\n    * the context class for the resource before searching all other {@link ClassLoader}s.\n@@ -278,7 +273,7 @@ public InputStream getResourceAsStream(final Class<?> contextClass, final String\n    * @throws IOException If I/O errors occur\n    * @see ClassLoader#getResources(String)\n    */\n-  public Enumeration<URL> getResources(final Class<?> contextClass, final String name)\n+  private Enumeration<URL> getResources(final Class<?> contextClass, final String name)\n       throws IOException {\n     final LinkedHashSet<URL> urls = new LinkedHashSet<URL>();\n \n@@ -369,8 +364,8 @@ public static ClassPathLoader getLatest() {\n    * @return {@link ClassLoader} for current {@link ClassPathLoader}.\n    * @since GemFire 8.1\n    */\n-  public static final ClassLoader getLatestAsClassLoader() {\n-    return latest.asClassLoader();\n+  public static ClassLoader getLatestAsClassLoader() {\n+    return getLatest().asClassLoader();\n   }\n \n }",
                "raw_url": "https://github.com/apache/geode/raw/7482c00bfe838414825cbd0d2a39b8c00fa476d5/geode-core/src/main/java/org/apache/geode/internal/ClassPathLoader.java",
                "sha": "b272f8a35d26d5b4b8967c1b5eb3a814a36a5eff",
                "status": "modified"
            }
        ],
        "message": "GEODE-2884: fix NPE when calling getLatestAsClassLoader before getLatest\n\nWithout this fix, CacheXmlParserJUnitTest.testGetDelegate() fails when\nrun in isolation but passes when run with all tests.",
        "parent": "https://github.com/apache/geode/commit/34deeabb9474a47052d06e8f25de018524f188e5",
        "repo": "geode",
        "unit_tests": [
            "ClassPathLoaderTest.java"
        ]
    },
    "geode_7661eca": {
        "bug_id": "geode_7661eca",
        "commit": "https://github.com/apache/geode/commit/7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/distributedTest/java/org/apache/geode/ClusterCommunicationsDUnitTest.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/distributedTest/java/org/apache/geode/ClusterCommunicationsDUnitTest.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 1,
                "filename": "geode-core/src/distributedTest/java/org/apache/geode/ClusterCommunicationsDUnitTest.java",
                "patch": "@@ -30,6 +30,7 @@\n import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;\n import static org.apache.geode.internal.DataSerializableFixedID.SERIAL_ACKED_MESSAGE;\n import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import java.io.DataInput;\n@@ -216,7 +217,7 @@ public void performARollingUpgrade() {\n       // System.setProperty(\"javax.net.debug\", \"all\");\n       Properties props = getDistributedSystemProperties();\n       // locator must restart with the same port so that it reconnects to the server\n-      await().atMost(15, TimeUnit.SECONDS)\n+      await().atMost(getTimeout().getValueInMS(), TimeUnit.MILLISECONDS)\n           .until(() -> Locator.startLocatorAndDS(locatorPort, new File(\"\"), props) != null);\n       assertThat(Locator.getLocator().getDistributedSystem().getAllOtherMembers().size())\n           .isGreaterThan(0);",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/distributedTest/java/org/apache/geode/ClusterCommunicationsDUnitTest.java",
                "sha": "c970f778735c2f1f5560520b9398ad82c018d50c",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectDUnitTest.java",
                "changes": 39,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectDUnitTest.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 16,
                "filename": "geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectDUnitTest.java",
                "patch": "@@ -15,6 +15,8 @@\n package org.apache.geode.cache30;\n \n import static java.lang.System.out;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n import static java.util.concurrent.TimeUnit.SECONDS;\n import static org.apache.geode.cache.DataPolicy.REPLICATE;\n import static org.apache.geode.cache.LossAction.RECONNECT;\n@@ -37,9 +39,11 @@\n import static org.apache.geode.distributed.internal.membership.gms.MembershipManagerHelper.getMembershipManager;\n import static org.apache.geode.internal.cache.xmlcache.CacheXmlGenerator.generate;\n import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n import static org.apache.geode.test.dunit.Host.getHost;\n import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n import static org.apache.geode.test.dunit.ThreadUtils.join;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n@@ -63,6 +67,7 @@\n \n import org.apache.geode.CancelException;\n import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.CacheClosedException;\n import org.apache.geode.cache.CacheException;\n import org.apache.geode.cache.CacheFactory;\n import org.apache.geode.cache.DataPolicy;\n@@ -80,6 +85,7 @@\n import org.apache.geode.cache.util.CacheListenerAdapter;\n import org.apache.geode.distributed.DistributedMember;\n import org.apache.geode.distributed.DistributedSystem;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n import org.apache.geode.distributed.Locator;\n import org.apache.geode.distributed.internal.InternalDistributedSystem;\n import org.apache.geode.distributed.internal.InternalDistributedSystem.ReconnectListener;\n@@ -401,7 +407,7 @@ public String description() {\n             System.out.println(\"ds.isReconnecting() = \" + ds.isReconnecting());\n             boolean failure = true;\n             try {\n-              ds.waitUntilReconnected(60, SECONDS);\n+              ds.waitUntilReconnected(getTimeout().getValueInMS(), MILLISECONDS);\n               savedSystem = ds.getReconnectedSystem();\n               locator = (InternalLocator) getLocator();\n               assertTrue(\"Expected system to be restarted\", ds.getReconnectedSystem() != null);\n@@ -480,15 +486,14 @@ public Object call() {\n \n   /** this will throw an exception if location services aren't running */\n   private void ensureLocationServiceRunning(VM vm) {\n-    vm.invoke(new SerializableRunnable(\"ensureLocationServiceRunning\") {\n-      @Override\n-      public void run() {\n+    vm.invoke(\"ensureLocationServiceRunning\", () -> {\n+      await().untilAsserted(() -> {\n         InternalLocator intloc = (InternalLocator) locator;\n         ServerLocator serverLocator = intloc.getServerLocatorAdvisee();\n         // the initialization flag in the locator's ControllerAdvisor will\n         // be set if a handshake has been performed\n         assertTrue(serverLocator.getDistributionAdvisor().isInitialized());\n-      }\n+      });\n     });\n   }\n \n@@ -511,7 +516,7 @@ public String description() {\n                 return \"waiting for ds to begin reconnecting\";\n               }\n             });\n-            long waitTime = 120;\n+            long waitTime = 600;\n             System.out.println(\"VM\" + VM.getCurrentVMNum() + \" waiting up to \"\n                 + waitTime + \" seconds for reconnect to complete\");\n             try {\n@@ -1070,7 +1075,8 @@ public void run() {\n         ReconnectDUnitTest.savedCache = (GemFireCacheImpl) getCache();\n         Region myRegion = createRegion(\"myRegion\", createAtts());\n         myRegion.put(\"MyKey\", \"MyValue\");\n-        myRegion.getAttributesMutator().addCacheListener(new CacheKillingListener());\n+        myRegion.getAttributesMutator()\n+            .addCacheListener(new CacheListenerTriggeringForcedDisconnect());\n       }\n     };\n \n@@ -1098,7 +1104,7 @@ public String description() {\n         });\n         out.println(\"entering reconnect wait for \" + cache);\n         try {\n-          cache.waitUntilReconnected(20, SECONDS);\n+          cache.waitUntilReconnected(5, MINUTES);\n         } catch (InterruptedException e) {\n           fail(\"interrupted\");\n         }\n@@ -1155,11 +1161,10 @@ public String description() {\n         return \"waiting for cache to begin reconnecting\";\n       }\n     });\n-    try {\n-      cache.waitUntilReconnected(20, SECONDS);\n-    } catch (InterruptedException e) {\n-      fail(\"interrupted\");\n-    }\n+    assertThatThrownBy(() -> cache.waitUntilReconnected(getTimeout().getValueInMS(), MILLISECONDS))\n+        .isInstanceOf(CacheClosedException.class)\n+        .hasMessageContaining(\"Cache could not be recreated\")\n+        .hasCauseExactlyInstanceOf(DistributedSystemDisconnectedException.class);\n     assertTrue(cache.getInternalDistributedSystem().isReconnectCancelled());\n     assertNull(cache.getReconnectedCache());\n   }\n@@ -1290,7 +1295,7 @@ public Object call() throws Exception {\n           WaitCriterion wc = new WaitCriterion() {\n             @Override\n             public boolean done() {\n-              return msys.isReconnecting();\n+              return msys.isReconnecting() || msys.getReconnectedSystem() != null;\n             }\n \n             @Override\n@@ -1323,10 +1328,12 @@ public void init(Properties props) {\n   }\n \n   /**\n-   * CacheKillingListener crashes the distributed system when it is invoked for the first time.\n+   * CacheListenerTriggeringForcedDisconnect crashes the distributed system when it is invoked for\n+   * the first time.\n    * After that it ignores any notifications.\n    */\n-  public static class CacheKillingListener extends CacheListenerAdapter implements Declarable {\n+  public static class CacheListenerTriggeringForcedDisconnect extends CacheListenerAdapter\n+      implements Declarable {\n     public static int crashCount = 0;\n \n     @Override",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectDUnitTest.java",
                "sha": "232d72985c5591017790e497c97291171e41c554",
                "status": "modified"
            },
            {
                "additions": 193,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectWithClusterConfigurationDUnitTest.java",
                "changes": 193,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectWithClusterConfigurationDUnitTest.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectWithClusterConfigurationDUnitTest.java",
                "patch": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache30;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISABLE_AUTO_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;\n+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_NETWORK_PARTITION_DETECTION;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.ConfigurationProperties.NAME;\n+import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.distributed.DistributedSystem;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.gms.MembershipManagerHelper;\n+import org.apache.geode.internal.AvailablePort;\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.Assert;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.Disconnect;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.Invoke;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+public class ReconnectWithClusterConfigurationDUnitTest implements Serializable {\n+  static final int NUM_LOCATORS = 2;\n+  static final int NUM_VMS = 4;\n+  static DistributedSystem system;\n+  static Cache cache;\n+  static Locator locator;\n+  static int[] locatorPorts = new int[NUM_LOCATORS];\n+  static Properties dsProperties;\n+\n+  @Rule\n+  public DistributedRule distributedRule = DistributedRule.builder().withVMCount(NUM_VMS).build();\n+\n+  @Before\n+  public void setup() {\n+    List<AvailablePort.Keeper> randomAvailableTCPPortKeepers =\n+        AvailablePortHelper.getRandomAvailableTCPPortKeepers(NUM_LOCATORS);\n+    for (int i = 0; i < NUM_LOCATORS; i++) {\n+      AvailablePort.Keeper keeper = randomAvailableTCPPortKeepers.get(i);\n+      locatorPorts[i] = keeper.getPort();\n+    }\n+    final int[] locPorts = locatorPorts;\n+    Invoke.invokeInEveryVM(\"set locator ports\", () -> locatorPorts = locPorts);\n+    for (int i = 0; i < NUM_LOCATORS; i++) {\n+      final int locatorNumber = i;\n+      randomAvailableTCPPortKeepers.get(locatorNumber).release();\n+      VM.getVM(i).invoke(\"start locator\", () -> {\n+        try {\n+          Disconnect.disconnectFromDS();\n+          dsProperties = null;\n+          Properties props = getDistributedSystemProperties();\n+          locator = Locator.startLocatorAndDS(locatorPorts[locatorNumber], new File(\"\"), props);\n+          system = locator.getDistributedSystem();\n+          cache = ((InternalLocator) locator).getCache();\n+          ReconnectDUnitTest.savedSystem = locator.getDistributedSystem();\n+          IgnoredException.addIgnoredException(\n+              \"org.apache.geode.ForcedDisconnectException||Possible loss of quorum\");\n+        } catch (IOException e) {\n+          Assert.fail(\"unable to start locator\", e);\n+        }\n+      });\n+    }\n+  }\n+\n+  @After\n+  public void teardown() {\n+    for (int i = 0; i < NUM_LOCATORS; i++) {\n+      VM.getVM(i).invoke(() -> {\n+        InternalLocator locator = InternalLocator.getLocator();\n+        if (locator != null) {\n+          InternalConfigurationPersistenceService sharedConfig =\n+              locator.getConfigurationPersistenceService();\n+          if (sharedConfig != null) {\n+            sharedConfig.destroySharedConfiguration();\n+          }\n+          locator.stop();\n+        }\n+      });\n+    }\n+    Invoke.invokeInEveryVM(() -> {\n+      if (system != null) {\n+        system.disconnect();\n+      }\n+      system = null;\n+      cache = null;\n+    });\n+  }\n+\n+  public Properties getDistributedSystemProperties() {\n+    dsProperties = new Properties();\n+    dsProperties.put(MAX_WAIT_TIME_RECONNECT, \"\" + (5000 * NUM_VMS));\n+    dsProperties.put(ENABLE_NETWORK_PARTITION_DETECTION, \"true\");\n+    dsProperties.put(DISABLE_AUTO_RECONNECT, \"false\");\n+    dsProperties.put(ENABLE_CLUSTER_CONFIGURATION, \"true\");\n+    dsProperties.put(USE_CLUSTER_CONFIGURATION, \"true\");\n+    dsProperties.put(HTTP_SERVICE_PORT, \"0\");\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"localHost[\")\n+        .append(locatorPorts[0])\n+        .append(']');\n+    for (int i = 1; i < NUM_LOCATORS; i++) {\n+      stringBuilder.append(\",localHost[\")\n+          .append(locatorPorts[0])\n+          .append(']');\n+    }\n+    dsProperties.put(LOCATORS, stringBuilder.toString());\n+    dsProperties.put(MCAST_PORT, \"0\");\n+    dsProperties.put(MEMBER_TIMEOUT, \"5000\");\n+    dsProperties.put(LOG_LEVEL, \"info\");\n+    int vmNumber = VM.getCurrentVMNum();\n+    if (vmNumber < NUM_LOCATORS) {\n+      dsProperties.put(NAME, \"loc\" + VM.getCurrentVMNum());\n+    } else {\n+      dsProperties.put(NAME, \"vm\" + VM.getCurrentVMNum());\n+    }\n+    return dsProperties;\n+  }\n+\n+\n+  @Test\n+  public void testReconnectAfterMeltdown() throws InterruptedException {\n+\n+    for (int i = NUM_LOCATORS; i < NUM_VMS; i++) {\n+      VM.getVM(i).invoke(\"create cache\", () -> {\n+        cache = new CacheFactory(getDistributedSystemProperties()).create();\n+        system = cache.getDistributedSystem();\n+      });\n+    }\n+    AsyncInvocation[] crashers = new AsyncInvocation[NUM_VMS];\n+    for (int i = 0; i < NUM_VMS; i++) {\n+      crashers[i] = VM.getVM(i).invokeAsync(\"crash\",\n+          () -> MembershipManagerHelper.crashDistributedSystem(system));\n+    }\n+    for (AsyncInvocation crasher : crashers) {\n+      crasher.join();\n+    }\n+    AsyncInvocation[] waiters = new AsyncInvocation[NUM_VMS];\n+    for (int i = NUM_VMS - 1; i >= 0; i--) {\n+      waiters[i] = VM.getVM(i).invokeAsync(\"wait for reconnect\", () -> {\n+        system.waitUntilReconnected(GeodeAwaitility.getTimeout().getValueInMS(),\n+            TimeUnit.MILLISECONDS);\n+        system = system.getReconnectedSystem();\n+        cache = cache.getReconnectedCache();\n+        await().untilAsserted(() -> assertThat(system.getAllOtherMembers().size())\n+            .withFailMessage(\"wrong number of members: \" + system.getAllOtherMembers())\n+            .isEqualTo(NUM_VMS - 1));\n+      });\n+    }\n+    for (AsyncInvocation waiter : waiters) {\n+      waiter.join();\n+    }\n+  }\n+\n+}",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/distributedTest/java/org/apache/geode/cache30/ReconnectWithClusterConfigurationDUnitTest.java",
                "sha": "964383acc336c51f0b0b217facaa4650dd7ee5fe",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/MembershipJUnitTest.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/MembershipJUnitTest.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 15,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/MembershipJUnitTest.java",
                "patch": "@@ -47,7 +47,6 @@\n import org.apache.geode.distributed.internal.InternalDistributedSystem;\n import org.apache.geode.distributed.internal.InternalLocator;\n import org.apache.geode.distributed.internal.SerialAckedMessage;\n-import org.apache.geode.distributed.internal.membership.gms.GMSUtil;\n import org.apache.geode.distributed.internal.membership.gms.ServiceConfig;\n import org.apache.geode.distributed.internal.membership.gms.Services;\n import org.apache.geode.distributed.internal.membership.gms.interfaces.JoinLeave;\n@@ -450,20 +449,6 @@ public void testMulticastDiscoveryNotAllowed() {\n     }\n   }\n \n-  /**\n-   * test the GMSUtil.formatBytes() method\n-   */\n-  @Test\n-  public void testFormatBytes() throws Exception {\n-    byte[] bytes = new byte[200];\n-    for (int i = 0; i < bytes.length; i++) {\n-      bytes[i] = (byte) (i % 255);\n-    }\n-    String str = GMSUtil.formatBytes(bytes, 0, bytes.length);\n-    System.out.println(str);\n-    assertEquals(600 + 4, str.length());\n-  }\n-\n   @Test\n   public void testMessagesThrowExceptionIfProcessed() throws Exception {\n     ClusterDistributionManager dm = null;",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/MembershipJUnitTest.java",
                "sha": "69184ffe68cff99467c347d7c541ba15d8a0b4d8",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java",
                "changes": 33,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 31,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java",
                "patch": "@@ -165,6 +165,7 @@ public void initMocks(boolean enableNetworkPartition, boolean useTestGMSJoinLeav\n     gmsJoinLeave.init(services);\n     gmsJoinLeave.start();\n     gmsJoinLeave.started();\n+    gmsJoinLeave.setLocalAddress(gmsJoinLeaveMemberId);\n   }\n \n   @After\n@@ -333,13 +334,6 @@ public void testProcessJoinResponseIsRecorded() throws IOException {\n     gmsJoinLeave.processMessage(jrm);\n     // this should log..\n     Assert.assertEquals(jrm, joinResponse[0]);\n-\n-    gmsJoinLeave.setJoinResponseMessage(null);\n-\n-    jrm = new JoinResponseMessage(mockMembers[0], new NetView(), 0);\n-    gmsJoinLeave.processMessage(jrm);\n-    // this should log..\n-    Assert.assertEquals(jrm, joinResponse[0]);\n   }\n \n   /**\n@@ -622,7 +616,7 @@ public void testRemoveRequestCausesForcedDisconnectInRogue() throws Exception {\n     previousMemberId.setVmViewId(0);\n     NetView view = new NetView(mockMembers[0], 1,\n         createMemberList(mockMembers[0], previousMemberId, mockMembers[1]));\n-    InstallViewMessage viewMessage = new InstallViewMessage(view, 0, true);\n+    InstallViewMessage viewMessage = new InstallViewMessage(view, 0, false);\n     viewMessage.setSender(mockMembers[0]);\n     gmsJoinLeave.processMessage(viewMessage);\n     assertEquals(0, gmsJoinLeaveMemberId.getVmViewId());\n@@ -634,29 +628,6 @@ public void testRemoveRequestCausesForcedDisconnectInRogue() throws Exception {\n     verify(manager).forceDisconnect(\"removing for test\");\n   }\n \n-  @Test\n-  public void testViewWithOldIDNotAcceptedAsJoinResponse() throws Exception {\n-    initMocks();\n-    when(messenger.isOldMembershipIdentifier(any(DistributedMember.class)))\n-        .thenReturn(Boolean.TRUE);\n-    List<InternalDistributedMember> mbrs = new LinkedList<>();\n-    Set<InternalDistributedMember> shutdowns = new HashSet<>();\n-    Set<InternalDistributedMember> crashes = new HashSet<>();\n-    mbrs.add(mockMembers[0]);\n-    mbrs.add(mockMembers[1]);\n-    mbrs.add(mockMembers[2]);\n-    InternalDistributedMember oldId = new InternalDistributedMember(\n-        gmsJoinLeaveMemberId.getInetAddress(), gmsJoinLeaveMemberId.getPort());\n-    oldId.setVmViewId(0);\n-    mbrs.add(oldId);\n-\n-    // prepare the view\n-    NetView netView = new NetView(mockMembers[0], 1, mbrs, shutdowns, crashes);\n-    gmsJoinLeave.processMessage(new InstallViewMessage(netView, null, true));\n-    assertEquals(-1, gmsJoinLeaveMemberId.getVmViewId());\n-    verify(messenger).isOldMembershipIdentifier(isA(DistributedMember.class));\n-  }\n-\n   @Test\n   public void testRemoveCausesForcedDisconnect() throws Exception {\n     String reason = \"testing\";",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java",
                "sha": "b0481e7dae66de24cfc41bdc965f2fcb025c3a7f",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 1,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java",
                "patch": "@@ -52,6 +52,7 @@\n import java.util.Map;\n import java.util.Properties;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.apache.commons.lang3.SerializationException;\n import org.jgroups.Address;\n@@ -877,7 +878,8 @@ public void testUseOldJChannel() throws Exception {\n     initMocks(false);\n     JChannel channel = messenger.myChannel;\n     services.getConfig().getTransport().setOldDSMembershipInfo(new MembershipInformation(channel,\n-        Collections.singleton(new InternalDistributedMember(\"localhost\", 10000))));\n+        Collections.singleton(new InternalDistributedMember(\"localhost\", 10000)),\n+        new ConcurrentLinkedQueue<>()));\n     JGroupsMessenger newMessenger = new JGroupsMessenger();\n     newMessenger.init(services);\n     newMessenger.start();",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java",
                "sha": "d5239e8a1e254e9cd8218f1326c30533721a714e",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/cache/Cache.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/Cache.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/cache/Cache.java",
                "patch": "@@ -413,6 +413,8 @@\n \n   /**\n    * Wait for the Cache to finish reconnecting to the distributed system and recreate a new Cache.\n+   * This may throw a CacheClosedException if reconnect attempts fail due to an exception. The\n+   * exception will detail what went wrong.\n    *\n    * @see #getReconnectedCache\n    * @param time amount of time to wait, or -1 to wait forever",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/cache/Cache.java",
                "sha": "fc7f4f3fd47e00be491d9fbeefd211194b294406",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/DistributedSystem.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/DistributedSystem.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/DistributedSystem.java",
                "patch": "@@ -650,6 +650,8 @@ private static URL getFileURL(String fileName) {\n \n   /**\n    * Wait for the DistributedSystem to finish reconnecting to the system and recreate the cache.\n+   * This may throw a DistributedSystemDisconnectedException if reconnect fails. The exception\n+   * will detail what went wrong.\n    *\n    * @param time amount of time to wait, or -1 to wait forever\n    * @return true if the system was reconnected",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/DistributedSystem.java",
                "sha": "bc913d22baa28b95e82628d4d65a7ed3548056eb",
                "status": "modified"
            },
            {
                "additions": 58,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalDistributedSystem.java",
                "changes": 95,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalDistributedSystem.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 37,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/InternalDistributedSystem.java",
                "patch": "@@ -61,7 +61,6 @@\n import org.apache.geode.annotations.internal.MutableForTesting;\n import org.apache.geode.cache.CacheClosedException;\n import org.apache.geode.cache.CacheFactory;\n-import org.apache.geode.cache.CacheXmlException;\n import org.apache.geode.cache.server.CacheServer;\n import org.apache.geode.distributed.DistributedMember;\n import org.apache.geode.distributed.DistributedSystem;\n@@ -93,6 +92,7 @@\n import org.apache.geode.internal.cache.execute.InternalFunctionService;\n import org.apache.geode.internal.cache.tier.sockets.EncryptorImpl;\n import org.apache.geode.internal.cache.xmlcache.CacheServerCreation;\n+import org.apache.geode.internal.config.ClusterConfigurationNotAvailableException;\n import org.apache.geode.internal.logging.InternalLogWriter;\n import org.apache.geode.internal.logging.LogConfig;\n import org.apache.geode.internal.logging.LogConfigListener;\n@@ -1271,7 +1271,7 @@ public void disconnect(String reason, Throwable cause, boolean shunned) {\n     boolean isForcedDisconnect = dm.getRootCause() instanceof ForcedDisconnectException;\n     boolean rejoined = false;\n     this.reconnected = false;\n-    if (isForcedDisconnect) {\n+    if (isForcedDisconnect && !this.isReconnectingDS) {\n       this.forcedDisconnect = true;\n       resetReconnectAttemptCounter();\n       rejoined = tryReconnect(true, reason, GemFireCacheImpl.getInstance());\n@@ -2325,6 +2325,11 @@ public Properties getSecurityProperties() {\n    */\n   private volatile boolean reconnected = false;\n \n+  /**\n+   * If reconnect fails due to an exception it will be in this field\n+   */\n+  private Exception reconnectException;\n+\n   /**\n    * Boolean indicating that this member has been shunned by other members or a network partition\n    * has occurred\n@@ -2655,20 +2660,19 @@ private void reconnect(boolean forcedDisconnect, String reason) {\n             logger.warn(\"Exception occurred while trying to connect the system during reconnect\",\n                 e);\n             attemptingToReconnect = false;\n+            reconnectException = e;\n             return;\n           }\n           logger.warn(\"Caught SystemConnectException in reconnect\", e);\n           continue;\n         } catch (GemFireConfigException e) {\n-          if (isDebugEnabled) {\n-            logger.debug(\"Attempt to reconnect failed with GemFireConfigException\");\n-          }\n           logger.warn(\"Caught GemFireConfigException in reconnect\", e);\n           continue;\n-        } catch (Exception ee) {\n+        } catch (Exception e) {\n           logger.warn(\"Exception occurred while trying to connect the system during reconnect\",\n-              ee);\n+              e);\n           attemptingToReconnect = false;\n+          reconnectException = e;\n           return;\n         } finally {\n           if (this.locatorDMTypeForced) {\n@@ -2683,41 +2687,47 @@ private void reconnect(boolean forcedDisconnect, String reason) {\n           // Admin systems don't carry a cache, but for others we can now create\n           // a cache\n           if (newDM.getDMType() != ClusterDistributionManager.ADMIN_ONLY_DM_TYPE) {\n-            try {\n-              CacheConfig config = new CacheConfig();\n-              if (cacheXML != null) {\n-                config.setCacheXMLDescription(cacheXML);\n-              }\n-              cache = GemFireCacheImpl.create(this.reconnectDS, config);\n+            boolean retry;\n+            do {\n+              retry = false;\n+              try {\n+                CacheConfig config = new CacheConfig();\n+                if (cacheXML != null) {\n+                  config.setCacheXMLDescription(cacheXML);\n+                }\n+                cache = GemFireCacheImpl.create(this.reconnectDS, config);\n \n-              if (!cache.isClosed()) {\n-                createAndStartCacheServers(cacheServerCreation, cache);\n-                if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {\n-                  reconnectAttemptCounter = 0;\n+                if (!cache.isClosed()) {\n+                  createAndStartCacheServers(cacheServerCreation, cache);\n+                  if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {\n+                    reconnectAttemptCounter = 0;\n+                  }\n                 }\n-              }\n \n-            } catch (CacheXmlException e) {\n-              logger.warn(\"Exception occurred while trying to create the cache during reconnect\",\n-                  e);\n-              reconnectDS.disconnect();\n-              reconnectDS = null;\n-              reconnectCancelled = true;\n-              break;\n-            } catch (CancelException ignor) {\n-              // If this reconnect is for required-roles the algorithm is recursive and we\n-              // shouldn't retry at this level\n-              if (!forcedDisconnect) {\n+              } catch (GemFireConfigException e) {\n+                if (e.getCause() instanceof ClusterConfigurationNotAvailableException) {\n+                  retry = true;\n+                  logger.info(\"Reconnected to the cluster but the cluster configuration service \"\n+                      + \"isn't available - will retry creating the cache\");\n+                  try {\n+                    Thread.sleep(5000);\n+                  } catch (InterruptedException e1) {\n+                    reconnectCancelled = true;\n+                    reconnectException = e;\n+                    break;\n+                  }\n+                }\n+              } catch (Exception e) {\n+                // We need to give up because we'll probably get the same exception in\n+                // the next attempt to build the cache.\n+                logger.warn(\n+                    \"Exception occurred while trying to create the cache during reconnect.  Auto-reconnect is terminating.\",\n+                    e);\n+                reconnectCancelled = true;\n+                reconnectException = e;\n                 break;\n               }\n-              logger.warn(\"Exception occurred while trying to create the cache during reconnect\",\n-                  ignor);\n-              reconnectDS.disconnect();\n-              reconnectDS = null;\n-            } catch (Exception e) {\n-              logger.warn(\"Exception occurred while trying to create the cache during reconnect\",\n-                  e);\n-            }\n+            } while (retry);\n           }\n         }\n \n@@ -2728,6 +2738,8 @@ private void reconnect(boolean forcedDisconnect, String reason) {\n           } catch (InterruptedException e) {\n             logger.info(\"Reconnect thread has been interrupted - exiting\");\n             Thread.currentThread().interrupt();\n+            reconnectCancelled = true;\n+            reconnectException = e;\n             return;\n           }\n         }\n@@ -2757,6 +2769,11 @@ private void reconnect(boolean forcedDisconnect, String reason) {\n       } else {\n         System.setProperty(InternalLocator.INHIBIT_DM_BANNER, inhibitBanner);\n       }\n+      dm.getMembershipManager().setReconnectCompleted(true);\n+      InternalDistributedSystem newds = reconnectDS;\n+      if (newds != null) {\n+        newds.getDM().getMembershipManager().setReconnectCompleted(true);\n+      }\n       if (quorumChecker != null) {\n         mbrMgr.releaseQuorumChecker(quorumChecker, reconnectDS);\n       }\n@@ -2941,6 +2958,10 @@ public boolean waitUntilReconnected(long time, TimeUnit units) throws Interrupte\n         }\n       }\n \n+      if (reconnectException != null) {\n+        throw new DistributedSystemDisconnectedException(\n+            \"Reconnect attempts terminated due to exception\", reconnectException);\n+      }\n       InternalDistributedSystem recon = this.reconnectDS;\n       return !attemptingToReconnect && recon != null && recon.isConnected();\n     }",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalDistributedSystem.java",
                "sha": "4011669d3fd7696cba073137cf02b5fa3b7eeda6",
                "status": "modified"
            },
            {
                "additions": 29,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalLocator.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalLocator.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 3,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/InternalLocator.java",
                "patch": "@@ -952,7 +952,11 @@ public void waitToStop() throws InterruptedException {\n           Thread.sleep(5000);\n         }\n         logger.info(\"waiting for distributed system to reconnect...\");\n-        restarted = ds.waitUntilReconnected(-1, TimeUnit.SECONDS);\n+        try {\n+          restarted = ds.waitUntilReconnected(-1, TimeUnit.SECONDS);\n+        } catch (CancelException e) {\n+          // reconnect attempt failed\n+        }\n         if (restarted) {\n           logger.info(\"system restarted\");\n         } else {\n@@ -1049,7 +1053,12 @@ private boolean attemptReconnect() throws InterruptedException, IOException {\n           }\n           this.stoppedForReconnect = false;\n         }\n-        restartWithDS(newSystem, GemFireCacheImpl.getInstance());\n+        try {\n+          restartWithDS(newSystem, GemFireCacheImpl.getInstance());\n+        } catch (CancelException e) {\n+          this.stoppedForReconnect = true;\n+          return false;\n+        }\n         setLocator(this);\n         restarted = true;\n       }\n@@ -1091,7 +1100,14 @@ private void restartWithDS(InternalDistributedSystem newSystem, InternalCache ne\n       this.myDs.setDependentLocator(this);\n       logger.info(\"Locator restart: initializing TcpServer\");\n \n-      this.server.restarting(newSystem, newCache, this.configurationPersistenceService);\n+      try {\n+        this.server.restarting(newSystem, newCache, this.configurationPersistenceService);\n+      } catch (CancelException e) {\n+        this.myDs = null;\n+        this.myCache = null;\n+        logger.info(\"Locator restart: attempt to restart location services failed\", e);\n+        throw e;\n+      }\n       if (this.productUseLog.isClosed()) {\n         this.productUseLog.reopen();\n       }\n@@ -1110,6 +1126,7 @@ private void restartWithDS(InternalDistributedSystem newSystem, InternalCache ne\n       endStartLocator(this.myDs);\n       logger.info(\"Locator restart completed\");\n     }\n+    this.server.restartCompleted(newSystem);\n   }\n \n   public ClusterManagementService getClusterManagementService() {\n@@ -1262,6 +1279,15 @@ public void restarting(DistributedSystem ds, GemFireCache cache,\n       }\n     }\n \n+    @Override\n+    public void restartCompleted(DistributedSystem ds) {\n+      if (ds != null) {\n+        for (TcpHandler handler : this.allHandlers) {\n+          handler.restartCompleted(ds);\n+        }\n+      }\n+    }\n+\n     @Override\n     public Object processRequest(Object request) throws IOException {\n       long giveup = 0;",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalLocator.java",
                "sha": "788d71b9dab10cb7dd65357bb80b6d0c902b43fb",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocator.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocator.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 4,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocator.java",
                "patch": "@@ -290,10 +290,12 @@ public void restarting(DistributedSystem ds, GemFireCache cache,\n       this.loadSnapshot = new LocatorLoadSnapshot();\n       this.ds = (InternalDistributedSystem) ds;\n       this.advisor = ControllerAdvisor.createControllerAdvisor(this); // escapes constructor but\n-                                                                      // allows field to be final\n-      if (ds.isConnected()) {\n-        this.advisor.handshake(); // GEODE-1393: need to get server information during restart\n-      }\n+    }\n+  }\n+\n+  public void restartCompleted(DistributedSystem ds) {\n+    if (ds.isConnected()) {\n+      this.advisor.handshake(); // GEODE-1393: need to get server information during restart\n     }\n   }\n ",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocator.java",
                "sha": "2ed366efc2685548b4bd9c1fba0543654c6f6c1e",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/MembershipManager.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/MembershipManager.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/MembershipManager.java",
                "patch": "@@ -149,6 +149,12 @@\n   void setShutdown();\n \n \n+  /**\n+   * informs the membership manager that a reconnect has been completed\n+   */\n+  public void setReconnectCompleted(boolean reconnectCompleted);\n+\n+\n   /**\n    * Determine whether GCS shutdown has commenced\n    *",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/MembershipManager.java",
                "sha": "0a3b0b092d82d4f0c9c7745233d1e8528e4b569e",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/GMSUtil.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/GMSUtil.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 21,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/GMSUtil.java",
                "patch": "@@ -128,25 +128,4 @@ public static String replaceStrings(String properties, String property, String v\n     return sb.toString();\n   }\n \n-\n-  /**\n-   * Formats the bytes in a buffer into hex octets, 50 per line\n-   */\n-  public static String formatBytes(byte[] buf, int startIndex, int length) {\n-    StringBuilder w = new StringBuilder(20000);\n-    int count = 0;\n-    for (int i = startIndex; i < length; i++, count++) {\n-      String s = Integer.toHexString(buf[i] & 0xff);\n-      if (s.length() == 1) {\n-        w.append('0');\n-      }\n-      w.append(s).append(' ');\n-      if ((count % 50) == 49) {\n-        w.append(\"\\n\");\n-      }\n-    }\n-    return w.toString();\n-  }\n-\n-\n }",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/GMSUtil.java",
                "sha": "0e1491849059e6fea993a42383d3a0e9aaf15b98",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/Services.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/Services.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/Services.java",
                "patch": "@@ -180,6 +180,14 @@ protected void start() {\n     }\n   }\n \n+  public void setLocalAddress(InternalDistributedMember address) {\n+    this.auth.setLocalAddress(address);\n+    this.messenger.setLocalAddress(address);\n+    this.joinLeave.setLocalAddress(address);\n+    this.healthMon.setLocalAddress(address);\n+    this.manager.setLocalAddress(address);\n+  }\n+\n   public void emergencyClose() {\n     if (this.stopping) {\n       return;",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/Services.java",
                "sha": "e8bc0b9db5dc47614995be6c78db5a9b797746a9",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 3,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java",
                "patch": "@@ -317,7 +317,8 @@ public void run() {\n         if (playingDead) {\n           logger.debug(\"HealthMonitor: simulating sick member in health check\");\n         } else if (uuidLSBs == myUUID.getLeastSignificantBits()\n-            && uuidMSBs == myUUID.getMostSignificantBits() && vmViewId == myVmViewId) {\n+            && uuidMSBs == myUUID.getMostSignificantBits()\n+            && (vmViewId == myVmViewId || myVmViewId < 0)) {\n           logger.debug(\"HealthMonitor: sending OK reply\");\n           out.write(OK);\n           out.flush();\n@@ -1009,7 +1010,8 @@ public void emergencyClose() {\n     stopServices();\n   }\n \n-  void setLocalAddress(InternalDistributedMember idm) {\n+  @Override\n+  public void setLocalAddress(InternalDistributedMember idm) {\n     this.localAddress = idm;\n   }\n \n@@ -1062,7 +1064,7 @@ private void processHeartbeatRequest(HeartbeatRequestMessage m) {\n     // only respond if the intended recipient is this member\n     InternalDistributedMember me = localAddress;\n \n-    if (me.getVmViewId() >= 0 && m.getTarget().equals(me)) {\n+    if (me == null || me.getVmViewId() >= 0 && m.getTarget().equals(me)) {\n       HeartbeatMessage hm = new HeartbeatMessage(m.getRequestId());\n       hm.setRecipient(m.getSender());\n       Set<InternalDistributedMember> membersNotReceivedMsg = services.getMessenger().send(hm);",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java",
                "sha": "ab72a07c59159f67b5cb88c4eb252f51dcae3e81",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Manager.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Manager.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Manager.java",
                "patch": "@@ -110,4 +110,10 @@\n    */\n   boolean isReconnectingDS();\n \n+  /**\n+   * If this.isReconnectingDS() then this method will inform whether the reconnect\n+   * has completed\n+   */\n+  boolean isReconnectCompleted();\n+\n }",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Manager.java",
                "sha": "4a0ef6bbc0ba12a108ed1c9c01f91190e0367244",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Service.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Service.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Service.java",
                "patch": "@@ -78,4 +78,5 @@ void memberSuspected(InternalDistributedMember initiator, InternalDistributedMem\n       String reason);\n \n \n+  default void setLocalAddress(InternalDistributedMember address) {}\n }",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/interfaces/Service.java",
                "sha": "403518d2122e02fa9f6be49c3207d29a4d5d295e",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/locator/GMSLocator.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/locator/GMSLocator.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 2,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/locator/GMSLocator.java",
                "patch": "@@ -178,6 +178,10 @@ public void installView(NetView view) {\n \n   @Override\n   public void setIsCoordinator(boolean isCoordinator) {\n+    if (isCoordinator) {\n+      logger.info(\"Location services has received notification that this node is becoming\"\n+          + \" membership coordinator\");\n+    }\n     this.isCoordinator = isCoordinator;\n   }\n \n@@ -250,6 +254,9 @@ private FindCoordinatorResponse processFindCoordinatorRequest(\n \n     synchronized (registrants) {\n       registrants.add(findRequest.getMemberID());\n+      if (recoveredView != null) {\n+        recoveredView.remove(findRequest.getMemberID());\n+      }\n     }\n \n     if (v != null) {\n@@ -299,9 +306,7 @@ private FindCoordinatorResponse processFindCoordinatorRequest(\n     synchronized (registrants) {\n       if (isCoordinator) {\n         coordinator = localAddress;\n-\n         if (v != null && localAddress != null && !localAddress.equals(v.getCoordinator())) {\n-          logger.info(\"This member is becoming coordinator since view {}\", v);\n           v = null;\n           fromView = false;\n         }",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/locator/GMSLocator.java",
                "sha": "407cff1bb4c16659e20456448662c9c95f9be2c5",
                "status": "modified"
            },
            {
                "additions": 61,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeave.java",
                "changes": 102,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeave.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 41,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeave.java",
                "patch": "@@ -264,6 +264,7 @@\n     int locatorsContacted = 0;\n     boolean hasContactedAJoinedLocator;\n     NetView view;\n+    int lastFindCoordinatorInViewId = -1000;\n     final Set<FindCoordinatorResponse> responses = new HashSet<>();\n     public int responsesExpected;\n \n@@ -459,8 +460,7 @@ boolean attemptToJoin() {\n       throw new GemFireSecurityException(failReason);\n     }\n \n-    // there is no way we can rech here right now\n-    throw new RuntimeException(\"Join Request Failed with response \" + joinResponse[0]);\n+    throw new RuntimeException(\"Join Request Failed with response \" + response);\n   }\n \n   private JoinResponseMessage waitForJoinResponse() throws InterruptedException {\n@@ -476,29 +476,31 @@ private JoinResponseMessage waitForJoinResponse() throws InterruptedException {\n       }\n       response = joinResponse[0];\n \n-      if (response != null && response.getCurrentView() != null && !isJoined) {\n-        // reset joinResponse[0]\n-        joinResponse[0] = null;\n-        // we got view here that means either we have to wait for\n-        NetView v = response.getCurrentView();\n-        InternalDistributedMember coord = v.getCoordinator();\n-        if (searchState.alreadyTried.contains(coord)) {\n-          searchState.view = response.getCurrentView();\n-          // we already sent join request to it..so lets wait some more time here\n-          // assuming we got this response immediately, so wait for same timeout here..\n-          long timeout = Math.max(services.getConfig().getMemberTimeout(),\n-              services.getConfig().getJoinTimeout() / 5);\n-          joinResponse.wait(timeout);\n-          response = joinResponse[0];\n-        } else {\n-          // try on this coordinator\n-          searchState.view = response.getCurrentView();\n-          response = null;\n+      if (services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo().length() > 0) {\n+        if (response != null && response.getCurrentView() != null && !isJoined) {\n+          // reset joinResponse[0]\n+          joinResponse[0] = null;\n+          // we got view here that means either we have to wait for\n+          NetView v = response.getCurrentView();\n+          InternalDistributedMember coord = v.getCoordinator();\n+          if (searchState.alreadyTried.contains(coord)) {\n+            searchState.view = response.getCurrentView();\n+            // we already sent join request to it..so lets wait some more time here\n+            // assuming we got this response immediately, so wait for same timeout here..\n+            long timeout = Math.max(services.getConfig().getMemberTimeout(),\n+                services.getConfig().getJoinTimeout() / 5);\n+            joinResponse.wait(timeout);\n+            response = joinResponse[0];\n+          } else {\n+            // try on this coordinator\n+            searchState.view = response.getCurrentView();\n+            response = null;\n+          }\n+          searchState.view = v;\n+        }\n+        if (isJoined) {\n+          return null;\n         }\n-        searchState.view = v;\n-      }\n-      if (isJoined) {\n-        return null;\n       }\n     }\n     return response;\n@@ -616,7 +618,7 @@ private void processLeaveRequest(LeaveRequestMessage incomingRequest) {\n           services.getHealthMonitor().getMembersFailingAvailabilityCheck();\n       check.removeAll(suspectMembers);\n       logger.info(\n-          \"View with removed and left members removed is {}\\nremoved members: {}\\nleft members: {}\\nsuspect members: {}\",\n+          \"View with removed and left members removed is {}; removed members: {}; left members: {}; suspect members: {}\",\n           check, removedMembers, leftMembers, suspectMembers);\n       if (check.getCoordinator().equals(localAddress)) {\n         synchronized (viewInstallationLock) {\n@@ -995,6 +997,7 @@ private void addPublicKeysToView(NetView view) {\n   }\n \n   private void processViewMessage(final InstallViewMessage m) {\n+    logger.debug(\"processing membership view message {}\", m);\n \n     NetView view = m.getView();\n \n@@ -1016,12 +1019,11 @@ private void processViewMessage(final InstallViewMessage m) {\n     }\n \n     boolean viewContainsMyNewAddress = false;\n-    if (!this.isJoined) {\n+    if (!this.isJoined && !m.isPreparing()) {\n       // if we're still waiting for a join response and we're in this view we\n       // should install the view so join() can finish its work\n       for (InternalDistributedMember mbr : view.getMembers()) {\n-        if (localAddress.equals(mbr)\n-            && !services.getMessenger().isOldMembershipIdentifier(mbr)) {\n+        if (localAddress.equals(mbr)) {\n           viewContainsMyNewAddress = true;\n           break;\n         }\n@@ -1030,12 +1032,24 @@ private void processViewMessage(final InstallViewMessage m) {\n \n     if (m.isPreparing()) {\n       if (this.preparedView != null && this.preparedView.getViewId() >= view.getViewId()) {\n-        services.getMessenger()\n-            .send(new ViewAckMessage(view.getViewId(), m.getSender(), this.preparedView));\n+        if (this.preparedView.getViewId() == view.getViewId() &&\n+            this.preparedView.getCreator().equals(view.getCreator())) {\n+          // this can happen if we received two prepares during auto-reconnect\n+        } else {\n+          services.getMessenger()\n+              .send(new ViewAckMessage(view.getViewId(), m.getSender(), this.preparedView));\n+        }\n       } else {\n         this.preparedView = view;\n-        if (viewContainsMyNewAddress) {\n-          installView(view); // this will notifyAll the joinResponse\n+        // complete filling in the member ID of this node, if possible\n+        for (InternalDistributedMember mbr : view.getMembers()) {\n+          if (this.localAddress.equals(mbr)) {\n+            this.birthViewId = mbr.getVmViewId();\n+            this.localAddress.setVmViewId(this.birthViewId);\n+            GMSMember me = (GMSMember) this.localAddress.getNetMember();\n+            me.setBirthViewId(birthViewId);\n+            break;\n+          }\n         }\n         ackView(m);\n       }\n@@ -1096,12 +1110,10 @@ boolean findCoordinator() {\n \n     assert this.localAddress != null;\n \n-    // If we've already tried to bootstrap from locators that\n-    // haven't joined the system (e.g., a collocated locator)\n-    // then jump to using the membership view to try to find\n-    // the coordinator\n     if (!state.hasContactedAJoinedLocator && state.registrants.size() >= locators.size()\n-        && state.view != null) {\n+        && state.view != null && state.viewId > state.lastFindCoordinatorInViewId) {\n+      state.lastFindCoordinatorInViewId = state.viewId;\n+      logger.info(\"using findCoordinatorFromView\");\n       return findCoordinatorFromView();\n     }\n \n@@ -1163,7 +1175,8 @@ boolean findCoordinator() {\n               // the QuorumChecker would have contacted a quorum of live nodes and one of\n               // them should already be the coordinator, or should become the coordinator soon\n               boolean isMyOldAddress =\n-                  services.getConfig().isReconnecting() && localAddress.equals(responseCoordinator);\n+                  services.getConfig().isReconnecting() && localAddress.equals(responseCoordinator)\n+                      && responseCoordinator.getVmViewId() >= 0;\n               if (!isMyOldAddress) {\n                 possibleCoordinators.add(response.getCoordinator());\n               }\n@@ -1224,6 +1237,8 @@ boolean findCoordinator() {\n         }\n       }\n     }\n+    logger.info(\"findCoordinator chose {} out of these possible coordinators: {}\",\n+        state.possibleCoordinator, possibleCoordinators);\n     return true;\n   }\n \n@@ -1348,9 +1363,12 @@ private void processJoinResponse(JoinResponseMessage rsp) {\n         // 2. Member which was coordinator but just now some other member became coordinator\n         // 3. we got message with secret key, but still view is coming and that will inform the\n         // joining thread\n-        if (rsp.getRejectionMessage() != null || rsp.getCurrentView() != null) {\n+        if (rsp.getRejectionMessage() != null) {\n           joinResponse[0] = rsp;\n           joinResponse.notifyAll();\n+        } else if (rsp.getCurrentView() != null) {\n+          // ignore - we get to join when we receive a view. Joining earlier may\n+          // confuse other members if we've reused an old address\n         } else {\n           // we got secret key lets add it\n           services.getMessenger().setClusterSecretKey(rsp.getSecretPk());\n@@ -1646,8 +1664,10 @@ public void beHealthy() {\n   public void start() {}\n \n   @Override\n-  public void started() {\n-    this.localAddress = services.getMessenger().getMemberID();\n+  public void started() {}\n+\n+  public void setLocalAddress(InternalDistributedMember address) {\n+    this.localAddress = address;\n     GMSMember mbr = (GMSMember) this.localAddress.getNetMember();\n \n     if (services.getConfig().areLocatorsPreferredAsCoordinators()) {",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeave.java",
                "sha": "261bb70d536d37a1ffc11596726f23ec34fd7205",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/GMSQuorumChecker.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/GMSQuorumChecker.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 1,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/GMSQuorumChecker.java",
                "patch": "@@ -23,6 +23,7 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.apache.logging.log4j.Logger;\n import org.jgroups.Address;\n@@ -55,6 +56,7 @@\n   private JGAddress myAddress;\n   private final long partitionThreshold;\n   private Set<DistributedMember> oldDistributedMemberIdentifiers;\n+  private ConcurrentLinkedQueue<Message> messageQueue = new ConcurrentLinkedQueue<>();\n \n   public GMSQuorumChecker(NetView jgView, int partitionThreshold, JChannel channel,\n       Set<DistributedMember> oldDistributedMemberIdentifiers) {\n@@ -125,7 +127,7 @@ public NetView getView() {\n \n   @Override\n   public MembershipInformation getMembershipInfo() {\n-    return new MembershipInformation(channel, oldDistributedMemberIdentifiers);\n+    return new MembershipInformation(channel, oldDistributedMemberIdentifiers, messageQueue);\n   }\n \n   private boolean calculateQuorum() {\n@@ -219,9 +221,15 @@ public void receive(Message msg) {\n         }\n       } else if (pingPonger.isPongMessage(msgBytes)) {\n         pongReceived(msg.getSrc());\n+      } else {\n+        queueMessage(msg);\n       }\n     }\n \n+    private void queueMessage(Message msg) {\n+      messageQueue.add(msg);\n+    }\n+\n     @Override\n     public void getState(OutputStream output) throws Exception {}\n ",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/GMSQuorumChecker.java",
                "sha": "14adc8d1231ea0fd5bf5a3c204c751c01554d15e",
                "status": "modified"
            },
            {
                "additions": 42,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 3,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java",
                "patch": "@@ -38,6 +38,7 @@\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Random;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -86,6 +87,7 @@\n import org.apache.geode.distributed.internal.membership.QuorumChecker;\n import org.apache.geode.distributed.internal.membership.gms.GMSMember;\n import org.apache.geode.distributed.internal.membership.gms.Services;\n+import org.apache.geode.distributed.internal.membership.gms.interfaces.HealthMonitor;\n import org.apache.geode.distributed.internal.membership.gms.interfaces.MessageHandler;\n import org.apache.geode.distributed.internal.membership.gms.interfaces.Messenger;\n import org.apache.geode.distributed.internal.membership.gms.locator.FindCoordinatorRequest;\n@@ -173,6 +175,19 @@\n    */\n   private Set<DistributedMember> usedDistributedMemberIdentifiers = new HashSet<>();\n \n+  /**\n+   * During reconnect a QuorumChecker holds the JGroups channel and responds to Ping\n+   * and Pong messages but also queues any messages it doesn't recognize. These need\n+   * to be delivered to handlers after membership services have been rebuilt.\n+   */\n+  private Queue<Message> queuedMessagesFromReconnect;\n+\n+  /**\n+   * The JGroupsReceiver is handed messages by the JGroups Channel. It is responsible\n+   * for deserializating and dispatching those messages to the appropriate handler\n+   */\n+  private JGroupsReceiver jgroupsReceiver;\n+\n   @Override\n   @edu.umd.cs.findbugs.annotations.SuppressWarnings(\n       value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n@@ -309,6 +324,7 @@ public void start() {\n         MembershipInformation oldInfo = (MembershipInformation) oldDSMembershipInfo;\n         myChannel = oldInfo.getChannel();\n         usedDistributedMemberIdentifiers = oldInfo.getMembershipIdentifiers();\n+        queuedMessagesFromReconnect = oldInfo.getQueuedMessages();\n \n         // scrub the old channel\n         ViewId vid = new ViewId(new JGAddress(), 0);\n@@ -345,7 +361,8 @@ public void start() {\n \n     try {\n       myChannel.setReceiver(null);\n-      myChannel.setReceiver(new JGroupsReceiver());\n+      jgroupsReceiver = new JGroupsReceiver();\n+      myChannel.setReceiver(jgroupsReceiver);\n       if (!reconnecting) {\n         myChannel.connect(\"AG\"); // apache g***** (whatever we end up calling it)\n       }\n@@ -387,7 +404,17 @@ private void checkForIPv6() throws Exception {\n   }\n \n   @Override\n-  public void started() {}\n+  public void started() {\n+    if (queuedMessagesFromReconnect != null) {\n+      logger.info(\"Delivering {} messages queued by quorum checker\",\n+          queuedMessagesFromReconnect.size());\n+      for (Message message : queuedMessagesFromReconnect) {\n+        jgroupsReceiver.receive(message, true);\n+      }\n+      queuedMessagesFromReconnect.clear();\n+      queuedMessagesFromReconnect = null;\n+    }\n+  }\n \n   @Override\n   public void stop() {\n@@ -529,6 +556,8 @@ private void establishLocalAddress() {\n     gmsMember.setMemberWeight((byte) (services.getConfig().getMemberWeight() & 0xff));\n     gmsMember.setNetworkPartitionDetectionEnabled(\n         services.getConfig().getDistributionConfig().getEnableNetworkPartitionDetection());\n+\n+    services.setLocalAddress(localAddress);\n   }\n \n   @Override\n@@ -1226,6 +1255,10 @@ public QuorumChecker getQuorumChecker() {\n \n     @Override\n     public void receive(Message jgmsg) {\n+      receive(jgmsg, false);\n+    }\n+\n+    private void receive(Message jgmsg, boolean fromQuorumChecker) {\n       long startTime = DistributionStats.getStatTime();\n       try {\n         if (services.getManager().shutdownInProgress()) {\n@@ -1279,7 +1312,13 @@ public void receive(Message jgmsg) {\n             logger.trace(\"JGroupsMessenger dispatching {} from {}\", msg, msg.getSender());\n           }\n           filterIncomingMessage(msg);\n-          getMessageHandler(msg).processMessage(msg);\n+          MessageHandler handler = getMessageHandler(msg);\n+          if (fromQuorumChecker && handler instanceof HealthMonitor) {\n+            // ignore suspect / heartbeat messages that happened during\n+            // auto-reconnect because they very likely have old member IDs in them\n+          } else {\n+            handler.processMessage(msg);\n+          }\n \n           // record the scheduling of broadcast messages\n           NakAckHeader2 header = (NakAckHeader2) jgmsg.getHeader(nackack2HeaderId);",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java",
                "sha": "8475bcbee5ceb9d8d5c5dfc5293d3edb20b0de42",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/MembershipInformation.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/MembershipInformation.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 1,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/MembershipInformation.java",
                "patch": "@@ -14,9 +14,11 @@\n  */\n package org.apache.geode.distributed.internal.membership.gms.messenger;\n \n+import java.util.Queue;\n import java.util.Set;\n \n import org.jgroups.JChannel;\n+import org.jgroups.Message;\n \n import org.apache.geode.distributed.DistributedMember;\n \n@@ -27,12 +29,15 @@\n public class MembershipInformation {\n   private final JChannel channel;\n   private final Set<DistributedMember> membershipIdentifiers;\n+  private final Queue<Message> queuedMessages;\n \n   protected MembershipInformation(JChannel channel,\n-      Set<DistributedMember> oldMembershipIdentifiers) {\n+      Set<DistributedMember> oldMembershipIdentifiers,\n+      Queue<Message> queuedMessages) {\n \n     this.channel = channel;\n     this.membershipIdentifiers = oldMembershipIdentifiers;\n+    this.queuedMessages = queuedMessages;\n   }\n \n   public JChannel getChannel() {\n@@ -42,4 +47,8 @@ public JChannel getChannel() {\n   public Set<DistributedMember> getMembershipIdentifiers() {\n     return membershipIdentifiers;\n   }\n+\n+  public Queue<Message> getQueuedMessages() {\n+    return this.queuedMessages;\n+  }\n }",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/MembershipInformation.java",
                "sha": "80bc6e71a116d8c8f6d5ed3d038381dafd08cc08",
                "status": "modified"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/mgr/GMSMembershipManager.java",
                "changes": 27,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/mgr/GMSMembershipManager.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 2,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/mgr/GMSMembershipManager.java",
                "patch": "@@ -107,6 +107,12 @@\n    */\n   private boolean wasReconnectingSystem;\n \n+  /**\n+   * This indicates that the DistributedSystem using this membership manager performed\n+   * a successful auto-reconnect. This may include successful recreation of a Cache\n+   */\n+  private boolean reconnectCompleted;\n+\n   /**\n    * A quorum checker is created during reconnect and is held here so it is available to the UDP\n    * protocol for passing off the ping-pong responses used in the quorum-checking algorithm.\n@@ -1788,7 +1794,7 @@ public boolean isConnected() {\n    */\n   @Override\n   public boolean isReconnectingDS() {\n-    return !this.hasJoined && this.wasReconnectingSystem;\n+    return this.wasReconnectingSystem && !this.reconnectCompleted;\n   }\n \n   @Override\n@@ -2183,6 +2189,17 @@ void setDirectChannel(DirectChannel dc) {\n     this.tcpDisabled = false;\n   }\n \n+  @Override\n+  public void setReconnectCompleted(boolean reconnectCompleted) {\n+    this.reconnectCompleted = reconnectCompleted;\n+  }\n+\n+  @Override\n+  public boolean isReconnectCompleted() {\n+    return reconnectCompleted;\n+  }\n+\n+\n   /*\n    * non-thread-owned serial channels and high priority channels are not included\n    */\n@@ -2546,11 +2563,17 @@ public void forceDisconnect(final String reason) {\n           shutdownCause);\n     }\n \n+    if (this.isReconnectingDS()) {\n+      logger.info(\"Reconnecting system failed to connect\");\n+      uncleanShutdown(reason,\n+          new ForcedDisconnectException(\"reconnecting system failed to connect\"));\n+      return;\n+    }\n+\n     if (!services.getConfig().getDistributionConfig().getDisableAutoReconnect()) {\n       saveCacheXmlForReconnect();\n     }\n \n-\n     Thread reconnectThread = new LoggingThread(\"DisconnectThread\", false, () -> {\n       // stop server locators immediately since they may not have correct\n       // information. This has caused client failures in bridge/wan",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/gms/mgr/GMSMembershipManager.java",
                "sha": "592c749a27c932eaac3a3b514527de38e49670cf",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpHandler.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpHandler.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpHandler.java",
                "patch": "@@ -50,6 +50,11 @@\n   void restarting(DistributedSystem ds, GemFireCache cache,\n       InternalConfigurationPersistenceService sharedConfig);\n \n+  /**\n+   * Informs the handler that restart has completed\n+   */\n+  default void restartCompleted(DistributedSystem ds) {}\n+\n   /**\n    * Initialize the handler with the TcpServer. Called before the TcpServer starts accepting\n    * connections.",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpHandler.java",
                "sha": "1d19bf5f2750832bc4ea9abe1c1b735b0d0698ef",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpServer.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpServer.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpServer.java",
                "patch": "@@ -205,6 +205,10 @@ public void restarting(InternalDistributedSystem ds, InternalCache cache,\n         + System.identityHashCode(this.serverThread) + \";alive=\" + this.serverThread.isAlive());\n   }\n \n+  public void restartCompleted(InternalDistributedSystem ds) {\n+    this.handler.restartCompleted(ds);\n+  }\n+\n   public void start() throws IOException {\n     this.shuttingDown = false;\n     startServerThread();",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpServer.java",
                "sha": "c91a04d378c15b67efb29dcafba99b3aacdd5563",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/internal/cache/CacheServerLauncher.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/CacheServerLauncher.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 1,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/CacheServerLauncher.java",
                "patch": "@@ -35,6 +35,7 @@\n import java.util.Properties;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.geode.CancelException;\n import org.apache.geode.LogWriter;\n import org.apache.geode.SystemFailure;\n import org.apache.geode.annotations.internal.MakeNotStatic;\n@@ -730,7 +731,11 @@ public void server(final String[] args) throws Exception {\n         // system.isReconnecting());\n         boolean reconnected = false;\n         if (system.isReconnecting()) {\n-          reconnected = system.waitUntilReconnected(-1, TimeUnit.SECONDS);\n+          try {\n+            reconnected = system.waitUntilReconnected(-1, TimeUnit.SECONDS);\n+          } catch (CancelException e) {\n+            // reconnect failed\n+          }\n           if (reconnected) {\n             system = (InternalDistributedSystem) system.getReconnectedSystem();\n             cache = system.getCache();",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/internal/cache/CacheServerLauncher.java",
                "sha": "30dc64054d6185ffac549ae9ad6706cd330ff1a5",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 5,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java",
                "patch": "@@ -2470,12 +2470,16 @@ public boolean isReconnecting() {\n \n   @Override\n   public boolean waitUntilReconnected(long time, TimeUnit units) throws InterruptedException {\n-    boolean systemReconnected = this.system.waitUntilReconnected(time, units);\n-    if (!systemReconnected) {\n-      return false;\n+    try {\n+      boolean systemReconnected = this.system.waitUntilReconnected(time, units);\n+      if (!systemReconnected) {\n+        return false;\n+      }\n+      GemFireCacheImpl cache = getInstance();\n+      return cache != null && cache.isInitialized();\n+    } catch (CancelException e) {\n+      throw new CacheClosedException(\"Cache could not be recreated\", e);\n     }\n-    GemFireCacheImpl cache = getInstance();\n-    return cache != null && cache.isInitialized();\n   }\n \n   @Override",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java",
                "sha": "2fa37ae0b521aceb86a8c639d65f19b220f8a8ff",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/geode/blob/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java?ref=7661eca53df6fa5c71ec21dc3de35eba5cb3e202",
                "deletions": 4,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java",
                "patch": "@@ -46,6 +46,7 @@\n import org.apache.logging.log4j.Logger;\n \n import org.apache.geode.CancelException;\n+import org.apache.geode.SerializationException;\n import org.apache.geode.SystemFailure;\n import org.apache.geode.annotations.internal.MakeNotStatic;\n import org.apache.geode.annotations.internal.MutableForTesting;\n@@ -2831,7 +2832,7 @@ public void readAck(final DirectReplyProcessor processor)\n \n       Header header = msgReader.readHeader();\n \n-      ReplyMessage msg;\n+      ReplyMessage msg = null;\n       int len;\n       if (header.getMessageType() == NORMAL_MSG_TYPE) {\n         msg = (ReplyMessage) msgReader.readMessage(header);\n@@ -2941,8 +2942,12 @@ private void processInputBuffer() throws ConnectionException, IOException {\n           peerDataBuffer.limit(startPos + messageLength);\n \n           if (this.handshakeRead) {\n-            readMessage(peerDataBuffer);\n-\n+            try {\n+              readMessage(peerDataBuffer);\n+            } catch (SerializationException e) {\n+              logger.info(\"input buffer startPos {} oldLimit {}\", startPos, oldLimit);\n+              throw e;\n+            }\n           } else {\n             ByteBufferInputStream bbis = new ByteBufferInputStream(peerDataBuffer);\n             DataInputStream dis = new DataInputStream(bbis);\n@@ -3127,7 +3132,16 @@ private void readMessage(ByteBuffer peerDataBuffer) {\n         ReplyProcessor21.initMessageRPId();\n         // add serialization stats\n         long startSer = this.owner.getConduit().getStats().startMsgDeserialization();\n-        msg = (DistributionMessage) InternalDataSerializer.readDSFID(bbis);\n+        int startingPosition = peerDataBuffer.position();\n+        try {\n+          msg = (DistributionMessage) InternalDataSerializer.readDSFID(bbis);\n+        } catch (SerializationException e) {\n+          logger.info(\"input buffer starting position {} \"\n+              + \" current position {} limit {} capacity {} message length {}\",\n+              startingPosition, peerDataBuffer.position(), peerDataBuffer.limit(),\n+              peerDataBuffer.capacity(), messageLength);\n+          throw e;\n+        }\n         this.owner.getConduit().getStats().endMsgDeserialization(startSer);\n         if (bbis.available() != 0) {\n           logger.warn(\"Message deserialization of {} did not read {} bytes.\",",
                "raw_url": "https://github.com/apache/geode/raw/7661eca53df6fa5c71ec21dc3de35eba5cb3e202/geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java",
                "sha": "7fcbee5efb69428b24c46b3d3287f836b99c7f5d",
                "status": "modified"
            }
        ],
        "message": "GEODE-6369 Cache-creation failure after a successful auto-reconnect causes subsequent NPE\n\nIf an error occurs while rebuilding the cache on auto-reconnect & we can't\ncontinue we should throw an exception to any thread waiting for the\nreconnect to complete.\n\nIf we're unable to contact the cluster configuration service we do not\nterminate auto-reconnect attempts.\n\nNew members are now only allowed to join after view preparation has\ncompleted.  This will reduce the number of \"surprise members\" and also\nensures that any old member IDs have been removed from the view.\n\nWe now only attempt to use findCoordinatorFromView multiple times if the\nview actually changes.  Instead we contact locators again to see if\nthere are new registrants.\n\nfixing the above exposed other problems in auto-reconnect:\n\n* messages were being thrown away by the location service quorum checker\nduring auto-reconnect.  some of these were \"join\" messages that needed\nto be delivered to the new membership service\n\n* registrants weren't being removed from the recovered membership view\nin the locator.  This confused restarting nodes because the recovered\nmembership view has stale info in it that they don't want to use\n\n* locator services restart were hanging due to profile interchange being\ndone under synchronization",
        "parent": "https://github.com/apache/geode/commit/49696f83c70606673758a19cf904b544d1df4346",
        "repo": "geode",
        "unit_tests": [
            "ConnectionTest.java"
        ]
    },
    "geode_adaa01a": {
        "bug_id": "geode_adaa01a",
        "commit": "https://github.com/apache/geode/commit/adaa01a27f523886d3121044a9fad9e3cac47e42",
        "file": [
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/geode/blob/adaa01a27f523886d3121044a9fad9e3cac47e42/geode-core/src/main/java/org/apache/geode/cache/client/internal/pooling/ConnectionManagerImpl.java",
                "changes": 30,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/client/internal/pooling/ConnectionManagerImpl.java?ref=adaa01a27f523886d3121044a9fad9e3cac47e42",
                "deletions": 14,
                "filename": "geode-core/src/main/java/org/apache/geode/cache/client/internal/pooling/ConnectionManagerImpl.java",
                "patch": "@@ -1064,24 +1064,26 @@ public synchronized void addConnection(PooledConnection connection) {\n       if (this.closing) {\n         throw new CacheClosedException(\"This pool is closing\");\n       }\n+      synchronized (this) {\n \n-      getPoolStats().incPoolConnections(1);\n+        getPoolStats().incPoolConnections(1);\n \n-      // we want the smallest birthDate (e.g. oldest cnx) at the front of the list\n-      this.allConnections.add(connection);\n+        // we want the smallest birthDate (e.g. oldest cnx) at the front of the list\n+        this.allConnections.add(connection);\n \n-      addToEndpointMap(connection);\n+        addToEndpointMap(connection);\n \n-      if (isIdleExpirePossible()) {\n-        startBackgroundExpiration();\n-      }\n-      if (lifetimeTimeout != -1 && !haveLifetimeExpireConnectionsTask) {\n-        if (checkForReschedule(true)) {\n-          // something has already expired so start processing with no delay\n-          // logger.info(\"DEBUG: rescheduling lifetime expire to be now\");\n-          startBackgroundLifetimeExpiration(0);\n-        } else {\n-          // either no possible lifetime expires or we scheduled one\n+        if (isIdleExpirePossible()) {\n+          startBackgroundExpiration();\n+        }\n+        if (lifetimeTimeout != -1 && !haveLifetimeExpireConnectionsTask) {\n+          if (checkForReschedule(true)) {\n+            // something has already expired so start processing with no delay\n+            // logger.info(\"DEBUG: rescheduling lifetime expire to be now\");\n+            startBackgroundLifetimeExpiration(0);\n+          } else {\n+            // either no possible lifetime expires or we scheduled one\n+          }\n         }\n       }\n     }",
                "raw_url": "https://github.com/apache/geode/raw/adaa01a27f523886d3121044a9fad9e3cac47e42/geode-core/src/main/java/org/apache/geode/cache/client/internal/pooling/ConnectionManagerImpl.java",
                "sha": "2d73f595ccdd67a263f1a269e57b994e94f8bf6d",
                "status": "modified"
            }
        ],
        "message": "GEODE-4615 Deadlock shutting down client cache\n\nAdding synchronization back to the connection map's addConnection\nmethod.  Removing the synch caused NPE suspect strings in some\nregression tests.",
        "parent": "https://github.com/apache/geode/commit/6181a936b6466ccfe03cc839ee534ac5fc3ccfe1",
        "repo": "geode",
        "unit_tests": [
            "ConnectionManagerImplTest.java"
        ]
    },
    "geode_c3fb776": {
        "bug_id": "geode_c3fb776",
        "commit": "https://github.com/apache/geode/commit/c3fb77604f1b2566048e48ce9c8b7383c3b176ef",
        "file": [
            {
                "additions": 105,
                "blob_url": "https://github.com/apache/geode/blob/c3fb77604f1b2566048e48ce9c8b7383c3b176ef/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java",
                "changes": 105,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java?ref=c3fb77604f1b2566048e48ce9c8b7383c3b176ef",
                "deletions": 0,
                "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java",
                "patch": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TestName;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.DistributionConfig;\n+\n+\n+/**\n+ * junit test for detecting read conflicts\n+ */\n+public class TXDetectReadConflictJUnitTest {\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Rule\n+  public TestName name = new TestName();\n+\n+  protected Cache cache = null;\n+  protected Region region = null;\n+  protected Region regionpr = null;\n+\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(DistributionConfig.GEMFIRE_PREFIX + \"detectReadConflicts\", \"true\");\n+    createCache();\n+  }\n+\n+  protected void createCache() {\n+    Properties props = new Properties();\n+    props.put(MCAST_PORT, \"0\");\n+    props.put(LOCATORS, \"\");\n+    cache = new CacheFactory(props).create();\n+    region = cache.createRegionFactory(RegionShortcut.REPLICATE).create(\"testRegionRR\");\n+  }\n+\n+  protected void createCachePR() {\n+    Properties props = new Properties();\n+    props.put(MCAST_PORT, \"0\");\n+    props.put(LOCATORS, \"\");\n+    cache = new CacheFactory(props).create();\n+    regionpr = cache.createRegionFactory(RegionShortcut.PARTITION).create(\"testRegionPR\");\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    cache.close();\n+  }\n+\n+  @Test\n+  public void testReadConflictsRR() throws Exception {\n+    cache.close();\n+    createCache();\n+    region.put(\"key\", \"value\");\n+    region.put(\"key1\", \"value1\");\n+    TXManagerImpl mgr = (TXManagerImpl) cache.getCacheTransactionManager();\n+    mgr.begin();\n+    assertEquals(\"value\", region.get(\"key\"));\n+    assertEquals(\"value1\", region.get(\"key1\"));\n+    mgr.commit();\n+  }\n+\n+  @Test\n+  public void testReadConflictsPR() throws Exception {\n+    cache.close();\n+    createCachePR();\n+    regionpr.put(\"key\", \"value\");\n+    regionpr.put(\"key1\", \"value1\");\n+    TXManagerImpl mgr = (TXManagerImpl) cache.getCacheTransactionManager();\n+    mgr.begin();\n+    assertEquals(\"value\", regionpr.get(\"key\"));\n+    assertEquals(\"value1\", regionpr.get(\"key1\"));\n+    mgr.commit();\n+  }\n+}",
                "raw_url": "https://github.com/apache/geode/raw/c3fb77604f1b2566048e48ce9c8b7383c3b176ef/geode-core/src/integrationTest/java/org/apache/geode/internal/cache/TXDetectReadConflictJUnitTest.java",
                "sha": "810f148796fdb2f1bd849ff844963077bb42b7e5",
                "status": "added"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/geode/blob/c3fb77604f1b2566048e48ce9c8b7383c3b176ef/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java?ref=c3fb77604f1b2566048e48ce9c8b7383c3b176ef",
                "deletions": 0,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java",
                "patch": "@@ -1882,6 +1882,9 @@ void performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,\n       Set<InternalDistributedMember> cacheOpReceivers, Set<InternalDistributedMember> twoMessages,\n       FilterRoutingInfo routing) {\n     Operation op = event.getOperation();\n+    if (op == null) {\n+      return Collections.emptySet();\n+    }\n     if (op.isUpdate() || op.isCreate() || op.isDestroy() || op.isInvalidate()) {\n       // this method can safely assume that the operation is being distributed from\n       // the primary bucket holder to other nodes",
                "raw_url": "https://github.com/apache/geode/raw/c3fb77604f1b2566048e48ce9c8b7383c3b176ef/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java",
                "sha": "48530907cce9d69539155cafed2e8b79c50d046c",
                "status": "modified"
            }
        ],
        "message": "Merge pull request #3459 from Nordix/feature/GEODE-6651\n\nGEODE-6651: Fixed NPE",
        "parent": "https://github.com/apache/geode/commit/2b2fda692868b0096b17ce55bc084b2f3f9637f2",
        "repo": "geode",
        "unit_tests": [
            "BucketRegionTest.java"
        ]
    },
    "geode_cd295f5": {
        "bug_id": "geode_cd295f5",
        "commit": "https://github.com/apache/geode/commit/cd295f5b369176b6ddae15acf224cf288e2e30bf",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/geode/blob/cd295f5b369176b6ddae15acf224cf288e2e30bf/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/AbstractRegionMap.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/AbstractRegionMap.java?ref=cd295f5b369176b6ddae15acf224cf288e2e30bf",
                "deletions": 0,
                "filename": "geode-core/src/main/java/com/gemstone/gemfire/internal/cache/AbstractRegionMap.java",
                "patch": "@@ -804,6 +804,9 @@ public final boolean initialImagePut(final Object key,\n         // server in the VM\n         HAContainerWrapper haContainer = (HAContainerWrapper)CacheClientNotifier\n             .getInstance().getHaContainer();\n+        if (haContainer == null) {\n+          return false;\n+        }\n         Map.Entry entry = null;\n         HAEventWrapper original = null;\n         synchronized (haContainer) {",
                "raw_url": "https://github.com/apache/geode/raw/cd295f5b369176b6ddae15acf224cf288e2e30bf/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/AbstractRegionMap.java",
                "sha": "0cbec19408198a5d4fc7f975b43ad4075e29a580",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/geode/blob/cd295f5b369176b6ddae15acf224cf288e2e30bf/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheClientNotifier.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheClientNotifier.java?ref=cd295f5b369176b6ddae15acf224cf288e2e30bf",
                "deletions": 1,
                "filename": "geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheClientNotifier.java",
                "patch": "@@ -1433,6 +1433,9 @@ public void unregisterClientInterest(String regionName, List keysOfInterest,\n    * @since 5.7\n    */\n   private void checkAndRemoveFromClientMsgsRegion(Conflatable conflatable) {\n+    if (haContainer == null) {\n+      return;\n+    }\n     if (conflatable instanceof HAEventWrapper) {\n       HAEventWrapper wrapper = (HAEventWrapper)conflatable;\n       if (!wrapper.getIsRefFromHAContainer()) {\n@@ -2536,7 +2539,7 @@ public void run2() {\n    * (in case of eviction policy \"none\"). In both the cases, it'll store\n    * HAEventWrapper as its key and ClientUpdateMessage as its value.\n    */\n-  private HAContainerWrapper haContainer;\n+  private volatile HAContainerWrapper haContainer;\n \n   //   /**\n   //    * The singleton <code>CacheClientNotifier</code> instance",
                "raw_url": "https://github.com/apache/geode/raw/cd295f5b369176b6ddae15acf224cf288e2e30bf/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheClientNotifier.java",
                "sha": "712244be152e3e45f43e9bbcea11525ab473c330",
                "status": "modified"
            }
        ],
        "message": "GEODE-1460 RemoveAll fails with NPE in com.gemstone.gemfire.internal.cache.tier.sockets.CacheClientNotifier.checkAndRemoveFromClientMsgsRegion()\n\nMake haContainer volatile.",
        "parent": "https://github.com/apache/geode/commit/11e4b25613a9af24c2f7efff70c8bccbde7d0a7f",
        "repo": "geode",
        "unit_tests": [
            "CacheClientNotifierTest.java"
        ]
    },
    "geode_cf48212": {
        "bug_id": "geode_cf48212",
        "commit": "https://github.com/apache/geode/commit/cf482124e9e4844e785f9a785993635532a5e89b",
        "file": [
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/geode/blob/cf482124e9e4844e785f9a785993635532a5e89b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java",
                "changes": 78,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java?ref=cf482124e9e4844e785f9a785993635532a5e89b",
                "deletions": 40,
                "filename": "geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java",
                "patch": "@@ -119,56 +119,54 @@ void executeAndGetResults(String functionId, String filterString, String resultC\n       String[] arguments, DistributedMember member, TabularResultData resultTable,\n       String onRegion) {\n     StringBuilder resultMessage = new StringBuilder();\n-    try {\n-      Function function = new UserFunctionExecution();\n-      Object[] args = new Object[6];\n-      args[0] = functionId;\n-      if (filterString != null) {\n-        args[1] = filterString;\n-      }\n-      if (resultCollector != null) {\n-        args[2] = resultCollector;\n-      }\n-      if (arguments != null && arguments.length > 0) {\n-        args[3] = \"\";\n-        for (String str : arguments) {\n-          // send via CSV separated value format\n-          if (str != null) {\n-            args[3] = args[3] + str + \",\";\n-          }\n+\n+    Function function = new UserFunctionExecution();\n+    Object[] args = new Object[6];\n+    args[0] = functionId;\n+    if (filterString != null) {\n+      args[1] = filterString;\n+    }\n+    if (resultCollector != null) {\n+      args[2] = resultCollector;\n+    }\n+    if (arguments != null && arguments.length > 0) {\n+      args[3] = \"\";\n+      for (String str : arguments) {\n+        // send via CSV separated value format\n+        if (str != null) {\n+          args[3] = args[3] + str + \",\";\n         }\n       }\n-      args[4] = onRegion;\n+    }\n+    args[4] = onRegion;\n \n-      Subject currentUser = getSecurityService().getSubject();\n+    Subject currentUser = getSecurityService().getSubject();\n+    if (currentUser != null) {\n       args[5] = currentUser.getSession().getAttribute(CREDENTIALS_SESSION_ATTRIBUTE);\n+    } else {\n+      args[5] = null;\n+    }\n \n-      Execution execution = FunctionService.onMember(member).setArguments(args);\n-      if (execution != null) {\n-        List<Object> results = (List<Object>) execution.execute(function).getResult();\n-        if (results != null) {\n-          for (Object resultObj : results) {\n-            if (resultObj != null) {\n-              if (resultObj instanceof String) {\n-                resultMessage.append(((String) resultObj));\n-              } else if (resultObj instanceof Exception) {\n-                resultMessage.append(((Exception) resultObj).getMessage());\n-              } else {\n-                resultMessage.append(resultObj);\n-              }\n+    Execution execution = FunctionService.onMember(member).setArguments(args);\n+    if (execution != null) {\n+      List<Object> results = (List<Object>) execution.execute(function).getResult();\n+      if (results != null) {\n+        for (Object resultObj : results) {\n+          if (resultObj != null) {\n+            if (resultObj instanceof String) {\n+              resultMessage.append(((String) resultObj));\n+            } else if (resultObj instanceof Exception) {\n+              resultMessage.append(((Exception) resultObj).getMessage());\n+            } else {\n+              resultMessage.append(resultObj);\n             }\n           }\n         }\n-        toTabularResultData(resultTable, member.getId(), resultMessage.toString());\n-      } else {\n-        toTabularResultData(resultTable, member.getId(),\n-            CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_RETRIEVING_EXECUTOR);\n       }\n-    } catch (Exception e) {\n-      resultMessage.append(CliStrings.format(\n-          CliStrings.EXECUTE_FUNCTION__MSG__COULD_NOT_EXECUTE_FUNCTION_0_ON_MEMBER_1_ERROR_2,\n-          functionId, member.getId(), e.getMessage()));\n       toTabularResultData(resultTable, member.getId(), resultMessage.toString());\n+    } else {\n+      toTabularResultData(resultTable, member.getId(),\n+          CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_RETRIEVING_EXECUTOR);\n     }\n   }\n ",
                "raw_url": "https://github.com/apache/geode/raw/cf482124e9e4844e785f9a785993635532a5e89b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java",
                "sha": "c5a0e78facad8a390ae33946b564a05d39d71021",
                "status": "modified"
            }
        ],
        "message": "GEODE-3704: fix NPE when executing function with no security manager.",
        "parent": "https://github.com/apache/geode/commit/9eae75870f9b51bc19c06920cd2b7cffedf6e0aa",
        "repo": "geode",
        "unit_tests": [
            "ExecuteFunctionCommandTest.java"
        ]
    },
    "geode_d4f7a28": {
        "bug_id": "geode_d4f7a28",
        "commit": "https://github.com/apache/geode/commit/d4f7a2808f4814217c00d396cb1d3037b81f6def",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/d4f7a2808f4814217c00d396cb1d3037b81f6def/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java?ref=d4f7a2808f4814217c00d396cb1d3037b81f6def",
                "deletions": 1,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java",
                "patch": "@@ -72,9 +72,9 @@ public static void deployJarsReceivedFromClusterConfiguration(Cache cache,\n \n     String[] jarFileNames = response.getJarNames();\n     byte[][] jarBytes = response.getJars();\n-    logger.info(\"Got response with jars: {}\", Stream.of(jarFileNames).collect(joining(\",\")));\n \n     if (jarFileNames != null && jarBytes != null) {\n+      logger.info(\"Got response with jars: {}\", Stream.of(jarFileNames).collect(joining(\",\")));\n       JarDeployer jarDeployer = ClassPathLoader.getLatest().getJarDeployer();\n       jarDeployer.suspendAll();\n       try {",
                "raw_url": "https://github.com/apache/geode/raw/d4f7a2808f4814217c00d396cb1d3037b81f6def/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java",
                "sha": "4f4881fe39116faa505bc2fbec74efd669efe0ef",
                "status": "modified"
            }
        ],
        "message": "GEODE-3033: Fixing NPE when jarFileNames is null in ClusterConfigurationLoader\n\n* this closes #561\n\n(cherry picked from commit f8c5048)",
        "parent": "https://github.com/apache/geode/commit/a91bbf4986415e85d7bdce8818df206f2effa1f4",
        "repo": "geode",
        "unit_tests": [
            "ClusterConfigurationLoaderTest.java"
        ]
    },
    "geode_d632bfb": {
        "bug_id": "geode_d632bfb",
        "commit": "https://github.com/apache/geode/commit/d632bfb73155673b2ee06be0e3657033901e114d",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/geode/blob/d632bfb73155673b2ee06be0e3657033901e114d/gemfire-core/src/main/java/com/gemstone/gemfire/internal/tcp/Connection.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/gemfire-core/src/main/java/com/gemstone/gemfire/internal/tcp/Connection.java?ref=d632bfb73155673b2ee06be0e3657033901e114d",
                "deletions": 2,
                "filename": "gemfire-core/src/main/java/com/gemstone/gemfire/internal/tcp/Connection.java",
                "patch": "@@ -2673,11 +2673,12 @@ public void run2() {\n               }\n             }\n           }\n-          if (sentAlert) {\n+          List group = ackConnectionGroup;\n+          if (sentAlert && group != null) {\n             // since transmission and ack-receipt are performed serially, we don't\n             // want to complain about all receivers out just because one was slow.  We therefore reset\n             // the time stamps and give others more time\n-            for (Iterator it=ackConnectionGroup.iterator(); it.hasNext(); ) {\n+            for (Iterator it=group.iterator(); it.hasNext(); ) {\n               Connection con = (Connection)it.next();\n               if (con != Connection.this) {\n                 con.transmissionStartTime += con.ackSATimeout;",
                "raw_url": "https://github.com/apache/geode/raw/d632bfb73155673b2ee06be0e3657033901e114d/gemfire-core/src/main/java/com/gemstone/gemfire/internal/tcp/Connection.java",
                "sha": "988ca33c06774bc8edae8dab1f630ea4c71c6e8c",
                "status": "modified"
            }
        ],
        "message": "Fixing a suspect NPE string\n\nOnce in a while a test fails with an NPE in method\nConnection.scheduleAckTimeouts() using the variable ackConnectionGroup.\nThis variable is set to null in setInUse().",
        "parent": "https://github.com/apache/geode/commit/23edf7e1353f76a4df5f6e3de496c82eeed632a4",
        "repo": "geode",
        "unit_tests": [
            "ConnectionTest.java"
        ]
    },
    "geode_e92bf70": {
        "bug_id": "geode_e92bf70",
        "commit": "https://github.com/apache/geode/commit/e92bf70738384c5998de5e3fe86d37d7aed738e6",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/e92bf70738384c5998de5e3fe86d37d7aed738e6/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/execute/ServerToClientFunctionResultSender.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/execute/ServerToClientFunctionResultSender.java?ref=e92bf70738384c5998de5e3fe86d37d7aed738e6",
                "deletions": 1,
                "filename": "geode-core/src/main/java/com/gemstone/gemfire/internal/cache/execute/ServerToClientFunctionResultSender.java",
                "patch": "@@ -239,7 +239,7 @@ public synchronized void sendResult(Object oneResult,\n     }\n   }\n \n-  protected void authorizeResult(Object oneResult) {\n+  protected void authorizeResult(Object oneResult) throws IOException {\n     // check if the caller is authorised to receive these function execution\n     // results from server\n     AuthorizeRequestPP authzRequestPP = this.sc.getPostAuthzRequest();",
                "raw_url": "https://github.com/apache/geode/raw/e92bf70738384c5998de5e3fe86d37d7aed738e6/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/execute/ServerToClientFunctionResultSender.java",
                "sha": "14b81a19a618ad997d5fc389508c01f199d3c138",
                "status": "modified"
            },
            {
                "additions": 47,
                "blob_url": "https://github.com/apache/geode/blob/e92bf70738384c5998de5e3fe86d37d7aed738e6/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/ServerConnection.java",
                "changes": 61,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/ServerConnection.java?ref=e92bf70738384c5998de5e3fe86d37d7aed738e6",
                "deletions": 14,
                "filename": "geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/ServerConnection.java",
                "patch": "@@ -438,12 +438,22 @@ protected void setPostAuthorizeRequest(AuthorizeRequestPP postAuthzRequest) {\n   }\n   \n   //hitesh:this is for backward compability\n-  public long setUserAuthorizeAndPostAuthorizeRequest(AuthorizeRequest authzRequest, AuthorizeRequestPP postAuthzRequest)\n-  {\n+  public long setUserAuthorizeAndPostAuthorizeRequest(\n+      AuthorizeRequest authzRequest, AuthorizeRequestPP postAuthzRequest)\n+      throws IOException {\n     UserAuthAttributes userAuthAttr = new UserAuthAttributes(authzRequest, postAuthzRequest);\n-    if (this.clientUserAuths == null )\n+    if (this.clientUserAuths == null) {\n       this.initializeClientUserAuths();\n-    return this.clientUserAuths.putUserAuth(userAuthAttr);\n+    }\n+    try {\n+      return this.clientUserAuths.putUserAuth(userAuthAttr);\n+    } catch (NullPointerException npe) {\n+      if (this.isTerminated()) {\n+        // Bug #52023.\n+        throw new IOException(\"Server connection is terminated.\");\n+      }\n+      throw npe;\n+    }\n   }\n   //this is backward compability only, if any race condition happens.\n   //where server is unregistering the client and client is creating new connection.\n@@ -967,11 +977,15 @@ public boolean removeUserAuth(Message msg, boolean keepalive)\n         throw new  AuthenticationFailedException(\"Authentication failed\");\n       }\n       \n-      return this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepalive);      \n-    }\n-    catch(Exception ex)\n-    {\n-      throw new  AuthenticationFailedException(\"Authentication failed\");\n+      try {\n+        return this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepalive);\n+      } catch (NullPointerException npe) {\n+        // Bug #52023.\n+        logger.debug(\"Exception {}\", npe);\n+        return false;\n+      }\n+    } catch (Exception ex) {\n+      throw new AuthenticationFailedException(\"Authentication failed\", ex);\n     }\n   }\n   public byte[] setCredentials(Message msg)\n@@ -1940,7 +1954,7 @@ public long getUniqueId() {\n   }\n   \n   public AuthorizeRequest getAuthzRequest() \n-      throws AuthenticationRequiredException {\n+      throws AuthenticationRequiredException, IOException {\n     //look client version and return authzrequest\n     //for backward client it will be store in member variable userAuthId \n     //for other look \"requestMsg\" here and get unique-id from this to get the authzrequest\n@@ -1983,8 +1997,17 @@ public AuthorizeRequest getAuthzRequest()\n                 .toLocalizedString());\n         }\n       }\n-      \n-      UserAuthAttributes uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);\n+      UserAuthAttributes uaa = null;\n+      try {\n+        uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);\n+      } catch (NullPointerException npe) {\n+        if (this.isTerminated()) {\n+          // Bug #52023.\n+          throw new IOException(\"Server connection is terminated.\");\n+        } else {\n+          logger.debug(\"Unexpected exception {}\", npe);\n+        }\n+      }\n       if (uaa == null) {\n         throw new AuthenticationRequiredException(\n             \"User authorization attributes not found.\");\n@@ -2002,7 +2025,7 @@ public AuthorizeRequest getAuthzRequest()\n   }\n \n   public AuthorizeRequestPP getPostAuthzRequest() \n-  throws AuthenticationRequiredException{\n+  throws AuthenticationRequiredException, IOException {\n   //look client version and return authzrequest\n   //for backward client it will be store in member variable userAuthId \n   //for other look \"requestMsg\" here and get unique-id from this to get the authzrequest\n@@ -2045,7 +2068,17 @@ public AuthorizeRequestPP getPostAuthzRequest()\n         }\n       }\n       \n-      UserAuthAttributes uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);\n+      UserAuthAttributes uaa = null;\n+      try {\n+        uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);\n+      } catch (NullPointerException npe) {\n+        if (this.isTerminated()) {\n+          // Bug #52023.\n+          throw new IOException(\"Server connection is terminated.\");\n+        } else {\n+          logger.debug(\"Unexpected exception {}\", npe);\n+        }\n+      }\n       if (uaa == null) {\n         throw new AuthenticationRequiredException(\n             \"User authorization attributes not found.\");",
                "raw_url": "https://github.com/apache/geode/raw/e92bf70738384c5998de5e3fe86d37d7aed738e6/geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/ServerConnection.java",
                "sha": "1dd2562dbcda007e90908c7e21714b26f5b9bbe7",
                "status": "modified"
            }
        ],
        "message": "GEODE-1173: NPE thrown from ServerConnection method getPostAuthzRequest()",
        "parent": "https://github.com/apache/geode/commit/49e3f523d16389f5e84847c6dcfd6ab45427f8c2",
        "repo": "geode",
        "unit_tests": [
            "ServerConnectionTest.java"
        ]
    },
    "geode_f8c5048": {
        "bug_id": "geode_f8c5048",
        "commit": "https://github.com/apache/geode/commit/f8c504847279bd71da9e193445a66b58af1aeb4d",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/geode/blob/f8c504847279bd71da9e193445a66b58af1aeb4d/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java?ref=f8c504847279bd71da9e193445a66b58af1aeb4d",
                "deletions": 1,
                "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java",
                "patch": "@@ -72,9 +72,9 @@ public static void deployJarsReceivedFromClusterConfiguration(Cache cache,\n \n     String[] jarFileNames = response.getJarNames();\n     byte[][] jarBytes = response.getJars();\n-    logger.info(\"Got response with jars: {}\", Stream.of(jarFileNames).collect(joining(\",\")));\n \n     if (jarFileNames != null && jarBytes != null) {\n+      logger.info(\"Got response with jars: {}\", Stream.of(jarFileNames).collect(joining(\",\")));\n       JarDeployer jarDeployer = ClassPathLoader.getLatest().getJarDeployer();\n       jarDeployer.suspendAll();\n       try {",
                "raw_url": "https://github.com/apache/geode/raw/f8c504847279bd71da9e193445a66b58af1aeb4d/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java",
                "sha": "4f4881fe39116faa505bc2fbec74efd669efe0ef",
                "status": "modified"
            }
        ],
        "message": "GEODE-3033: Fixing NPE when jarFileNames is null in ClusterConfigurationLoader\n\n* this closes #561",
        "parent": "https://github.com/apache/geode/commit/1e11c5cc96c22123988e8d3480c0ebb2f2c2df6a",
        "repo": "geode",
        "unit_tests": [
            "ClusterConfigurationLoaderTest.java"
        ]
    },
    "geode_fd88a6a": {
        "bug_id": "geode_fd88a6a",
        "commit": "https://github.com/apache/geode/commit/fd88a6a9a55a4ac06cb083698313bcb7a09973ea",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/geode/blob/fd88a6a9a55a4ac06cb083698313bcb7a09973ea/gemfire-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalDistributedSystem.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/geode/contents/gemfire-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalDistributedSystem.java?ref=fd88a6a9a55a4ac06cb083698313bcb7a09973ea",
                "deletions": 4,
                "filename": "gemfire-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalDistributedSystem.java",
                "patch": "@@ -778,7 +778,8 @@ private void startInitLocator() throws InterruptedException {\n    * @since 5.7\n    */\n   private void endInitLocator() throws IOException {\n-    if (startedLocator != null) {\n+    InternalLocator loc = this.startedLocator;\n+    if (loc != null) {\n       String locatorString = this.originalConfig.getStartLocator();\n //      DistributionLocatorId locId = new DistributionLocatorId(locatorString);\n       boolean finished = false;\n@@ -787,14 +788,14 @@ private void endInitLocator() throws IOException {\n         // start server location services in order to be able to log information\n         // about the use of cache servers\n         //      if(locId.isServerLocator()) {\n-        this.startedLocator.startServerLocation(this);\n+        loc.startServerLocation(this);\n         //      }\n       \n-        this.startedLocator.endStartLocator(this);\n+        loc.endStartLocator(this);\n         finished = true;\n       } finally {\n         if (!finished) {\n-          this.startedLocator.stop();\n+          loc.stop();\n         }\n       }\n     }",
                "raw_url": "https://github.com/apache/geode/raw/fd88a6a9a55a4ac06cb083698313bcb7a09973ea/gemfire-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalDistributedSystem.java",
                "sha": "276efec40b088bf7b6f71d418940591a51dd20e2",
                "status": "modified"
            }
        ],
        "message": "Fixing an NPE that showed up in an integration test.",
        "parent": "https://github.com/apache/geode/commit/c8c26e610e1c691628a2226bc66f77248a4b3284",
        "repo": "geode",
        "unit_tests": [
            "InternalDistributedSystemTest.java"
        ]
    }
}