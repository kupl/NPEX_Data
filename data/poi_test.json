{
    "poi_0167a32": {
        "bug_id": "poi_0167a32",
        "commit": "https://github.com/apache/poi/commit/0167a32f7fe195a9bcaa5ea9227dd96e3de7d4eb",
        "file": [
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/0167a32f7fe195a9bcaa5ea9227dd96e3de7d4eb/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextParagraph.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextParagraph.java?ref=0167a32f7fe195a9bcaa5ea9227dd96e3de7d4eb",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextParagraph.java",
                "patch": "@@ -752,6 +752,10 @@ public String toString(){\n     }\r\n \r\n \r\n+    /**\r\n+     * @return master style text paragraph properties, or <code>null</code> if \r\n+     * there are no master slides or the master slides do not contain a text paragraph\r\n+     */\r\n     /* package */ CTTextParagraphProperties getDefaultMasterStyle(){\r\n         CTPlaceholder ph = _shape.getCTPlaceholder();\r\n         String defaultStyleSelector;  \r\n@@ -932,7 +936,11 @@ private static boolean doubleEquals(Double d1, Double d2) {\n     public Double getDefaultFontSize() {\r\n         CTTextCharacterProperties endPr = _p.getEndParaRPr();\r\n         if (endPr == null || !endPr.isSetSz()) {\r\n-            endPr = getDefaultMasterStyle().getDefRPr();\r\n+            // inherit the font size from the master style\r\n+            CTTextParagraphProperties masterStyle = getDefaultMasterStyle();\r\n+            if (masterStyle != null) {\r\n+                endPr = masterStyle.getDefRPr();\r\n+            }\r\n         }\r\n         return (endPr == null || !endPr.isSetSz()) ? 12 : (endPr.getSz() / 100.);\r\n     }\r\n@@ -1068,4 +1076,4 @@ public boolean isHeaderOrFooter() {\n     protected XSLFTextRun newTextRun(CTRegularTextRun r) {\r\n         return new XSLFTextRun(r, this);\r\n     }\r\n-}\n\\ No newline at end of file\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/0167a32f7fe195a9bcaa5ea9227dd96e3de7d4eb/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextParagraph.java",
                "sha": "c5a2ce069ded361ad49af6c818c70ea4c2f30ff9",
                "status": "modified"
            }
        ],
        "message": "bug 60005: fix NPE in XSLFTextParagraph.getDefaultFontSize()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1756397 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/d4e3df319246882118d3970daec3c9ccb56e8b0e",
        "patched_files": [
            "XSLFTextParagraph.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSLFTextParagraph.java"
        ]
    },
    "poi_0591f0e": {
        "bug_id": "poi_0591f0e",
        "commit": "https://github.com/apache/poi/commit/0591f0edbebddaaa37afc8e8259be1fda37882af",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/0591f0edbebddaaa37afc8e8259be1fda37882af/src/java/org/apache/poi/poifs/crypt/Decryptor.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/poifs/crypt/Decryptor.java?ref=0591f0edbebddaaa37afc8e8259be1fda37882af",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/poifs/crypt/Decryptor.java",
                "patch": "@@ -96,6 +96,11 @@ protected static int getBlockSize(int algorithm) {\n \n     protected byte[] hashPassword(EncryptionInfo info,\n                                   String password) throws NoSuchAlgorithmException {\n+        // If no password was given, use the default\n+        if (password == null) {\n+            password = DEFAULT_PASSWORD;\n+        }\n+        \n         MessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n         byte[] bytes;\n         try {",
                "raw_url": "https://github.com/apache/poi/raw/0591f0edbebddaaa37afc8e8259be1fda37882af/src/java/org/apache/poi/poifs/crypt/Decryptor.java",
                "sha": "9832ccea4079a675ce61aa75c68f970562246967",
                "status": "modified"
            }
        ],
        "message": "Avoid a NPE if no password was given - use the default office one instead\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1494571 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/b1e02dea83b58a77a860cfa257940522224679cf",
        "patched_files": [
            "Decryptor.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestDecryptor.java"
        ]
    },
    "poi_062cf73": {
        "bug_id": "poi_062cf73",
        "commit": "https://github.com/apache/poi/commit/062cf73c0788702253ed9be4622c39af343b3f63",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/062cf73c0788702253ed9be4622c39af343b3f63/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java?ref=062cf73c0788702253ed9be4622c39af343b3f63",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java",
                "patch": "@@ -435,6 +435,11 @@ protected void setStylesTableReference(StylesTable tbl){\n     protected static CTFont toCTFont(CTRPrElt pr){\n         CTFont ctFont =  CTFont.Factory.newInstance();\n \n+        // Bug 58315: there are files where there is no pr-entry for a RichTextString\n+        if(pr == null) {\n+            return ctFont;\n+        }\n+\n         if(pr.sizeOfBArray() > 0) ctFont.addNewB().setVal(pr.getBArray(0).getVal());\n         if(pr.sizeOfUArray() > 0) ctFont.addNewU().setVal(pr.getUArray(0).getVal());\n         if(pr.sizeOfIArray() > 0) ctFont.addNewI().setVal(pr.getIArray(0).getVal());",
                "raw_url": "https://github.com/apache/poi/raw/062cf73c0788702253ed9be4622c39af343b3f63/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java",
                "sha": "63f7a3ba8fd2c6fcda409e54e7b081aaecacd76e",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/poi/blob/062cf73c0788702253ed9be4622c39af343b3f63/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java?ref=062cf73c0788702253ed9be4622c39af343b3f63",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "patch": "@@ -2636,4 +2636,25 @@ public void test53105() throws IOException {\n     \n         wb.close();\n     }\n+\n+\n+    @Test\n+    public void test58315() throws IOException {\n+        Workbook wb = XSSFTestDataSamples.openSampleWorkbook(\"58315.xlsx\");\n+        Cell cell = wb.getSheetAt(0).getRow(0).getCell(0);\n+        assertNotNull(cell);\n+        StringBuilder tmpCellContent = new StringBuilder(cell.getStringCellValue());\n+        XSSFRichTextString richText = (XSSFRichTextString) cell.getRichStringCellValue();\n+\n+        for (int i = richText.length() - 1; i >= 0; i--) {\n+            Font f = richText.getFontAtIndex(i);\n+            if (f != null && f.getStrikeout()) {\n+                tmpCellContent.deleteCharAt(i);\n+            }\n+        }\n+        String result = tmpCellContent.toString();\n+        assertEquals(\"320 350\", result);\n+\n+        wb.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/062cf73c0788702253ed9be4622c39af343b3f63/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "sha": "f487726c95a2b661d32a256a347dda99a57d4fa2",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/062cf73c0788702253ed9be4622c39af343b3f63/test-data/spreadsheet/58315.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/58315.xlsx?ref=062cf73c0788702253ed9be4622c39af343b3f63",
                "deletions": 0,
                "filename": "test-data/spreadsheet/58315.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/062cf73c0788702253ed9be4622c39af343b3f63/test-data/spreadsheet/58315.xlsx",
                "sha": "0da751ed656f42ed445671241a3db64ae35d1b99",
                "status": "added"
            }
        ],
        "message": "Bug 58315: Avoid NPE for RichTextString without font-details\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1701382 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/7da84c99f2eb406119eb0d63daa41be62d8faa67",
        "patched_files": [
            "58315.java",
            "XSSFRichTextString.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFBugs.java",
            "TestXSSFRichTextString.java"
        ]
    },
    "poi_0736691": {
        "bug_id": "poi_0736691",
        "commit": "https://github.com/apache/poi/commit/0736691ba1ffb6a2318165331f7ef2ee9fda374f",
        "file": [
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/0736691ba1ffb6a2318165331f7ef2ee9fda374f/src/scratchpad/src/org/apache/poi/hwpf/usermodel/ListEntry.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/usermodel/ListEntry.java?ref=0736691ba1ffb6a2318165331f7ef2ee9fda374f",
                "deletions": 7,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/usermodel/ListEntry.java",
                "patch": "@@ -23,21 +23,28 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hwpf.model.ListLevel;\n import org.apache.poi.hwpf.model.ListTables;\n import org.apache.poi.hwpf.model.PAPX;\n-\n-import org.apache.poi.hwpf.sprm.SprmBuffer;\n+import org.apache.poi.util.POILogFactory;\n+import org.apache.poi.util.POILogger;\n \n public class ListEntry\n   extends Paragraph\n {\n-  ListLevel _level;\n-  ListFormatOverrideLevel _overrideLevel;\n+\tprivate static POILogger log = POILogFactory.getLogger(ListEntry.class);\n+\t\n+\tListLevel _level;\n+\tListFormatOverrideLevel _overrideLevel;\n \n   ListEntry(PAPX papx, Range parent, ListTables tables)\n   {\n     super(papx, parent);\n-    ListFormatOverride override = tables.getOverride(_props.getIlfo());\n-    _overrideLevel = override.getOverrideLevel(_props.getIlvl());\n-    _level = tables.getLevel(override.getLsid(), _props.getIlvl());\n+    \n+    if(tables != null) {\n+\t    ListFormatOverride override = tables.getOverride(_props.getIlfo());\n+\t    _overrideLevel = override.getOverrideLevel(_props.getIlvl());\n+\t    _level = tables.getLevel(override.getLsid(), _props.getIlvl());\n+    } else {\n+    \tlog.log(POILogger.WARN, \"No ListTables found for ListEntry - document probably partly corrupt, and you may experience problems\");\n+    }\n   }\n \n   public int type()",
                "raw_url": "https://github.com/apache/poi/raw/0736691ba1ffb6a2318165331f7ef2ee9fda374f/src/scratchpad/src/org/apache/poi/hwpf/usermodel/ListEntry.java",
                "sha": "9bafce792761a3e6c6fb604d28e7f4b0693632f3",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/0736691ba1ffb6a2318165331f7ef2ee9fda374f/src/scratchpad/testcases/org/apache/poi/hwpf/data/ListEntryNoListTable.doc",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hwpf/data/ListEntryNoListTable.doc?ref=0736691ba1ffb6a2318165331f7ef2ee9fda374f",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hwpf/data/ListEntryNoListTable.doc",
                "raw_url": "https://github.com/apache/poi/raw/0736691ba1ffb6a2318165331f7ef2ee9fda374f/src/scratchpad/testcases/org/apache/poi/hwpf/data/ListEntryNoListTable.doc",
                "sha": "939f5a4a9efe5b99586e4b96935700306c392ec8",
                "status": "added"
            },
            {
                "additions": 60,
                "blob_url": "https://github.com/apache/poi/blob/0736691ba1ffb6a2318165331f7ef2ee9fda374f/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestProblems.java",
                "changes": 60,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestProblems.java?ref=0736691ba1ffb6a2318165331f7ef2ee9fda374f",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestProblems.java",
                "patch": "@@ -0,0 +1,60 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.poi.hwpf.usermodel;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.poi.hwpf.HWPFDocument;\n+import org.apache.poi.hwpf.model.StyleSheet;\n+import org.apache.poi.hwpf.model.TextPiece;\n+import org.apache.poi.hwpf.usermodel.Paragraph;\n+import org.apache.poi.hwpf.usermodel.Range;\n+import org.apache.poi.util.LittleEndian;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test various problem documents\n+ *\n+ * @author Nick Burch (nick at torchbox dot com)\n+ */\n+public class TestProblems extends TestCase {\n+\tprivate String dirname = System.getProperty(\"HWPF.testdata.path\");\n+\t\n+    protected void setUp() throws Exception {\n+    }\t\t\t\n+    \n+    /**\n+     * ListEntry passed no ListTable\n+     */\n+    public void testListEntryNoListTable() throws Exception {\n+    \tHWPFDocument doc = new HWPFDocument(new FileInputStream(dirname + \"/ListEntryNoListTable.doc\"));\n+    \t\n+    \tRange r = doc.getRange();\n+    \tStyleSheet styleSheet = doc.getStyleSheet();\n+    \tfor (int x = 0; x < r.numSections(); x++) {\n+    \t\tSection s = r.getSection(x);\n+    \t\tfor (int y = 0; y < s.numParagraphs(); y++) {\n+    \t\t\tParagraph paragraph = s.getParagraph(y);\n+    \t\t\tSystem.out.println(paragraph.getCharacterRun(0).text());\n+    \t\t}\n+    \t}\n+    }\n+}",
                "raw_url": "https://github.com/apache/poi/raw/0736691ba1ffb6a2318165331f7ef2ee9fda374f/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestProblems.java",
                "sha": "87b9754a623d4f285244141bb68b4a2ed71e7c0d",
                "status": "added"
            }
        ],
        "message": "Workaround to avoid a NPE for Word Documents that are missing their ListTable (bug #44003)\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@600896 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e86b6bbaa35f3ea1967e1bcfe5857e0f11c4baea",
        "patched_files": [
            "ListEntryNoListTable.java",
            "ListEntry.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestProblems.java"
        ]
    },
    "poi_1102414": {
        "bug_id": "poi_1102414",
        "commit": "https://github.com/apache/poi/commit/1102414559fdfe86cb3af5a11a94490aa928f704",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFConnectorShape.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFConnectorShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFConnectorShape.java",
                "patch": "@@ -19,6 +19,7 @@\n \r\n package org.apache.poi.xslf.usermodel;\r\n \r\n+import org.apache.poi.sl.usermodel.ConnectorShape;\r\n import org.apache.poi.util.Beta;\r\n import org.openxmlformats.schemas.drawingml.x2006.main.CTLineProperties;\r\n import org.openxmlformats.schemas.drawingml.x2006.main.CTNonVisualDrawingProps;\r\n@@ -34,7 +35,7 @@\n  * @author Yegor Kozlov\r\n  */\r\n @Beta\r\n-public class XSLFConnectorShape extends XSLFSimpleShape {\r\n+public class XSLFConnectorShape extends XSLFSimpleShape implements ConnectorShape {\r\n \r\n     /*package*/ XSLFConnectorShape(CTConnector shape, XSLFSheet sheet) {\r\n         super(shape, sheet);\r\n@@ -43,6 +44,7 @@\n     /**\r\n      * @param shapeId 1-based shapeId\r\n      */\r\n+    @SuppressWarnings(\"unused\")\r\n     static CTConnector prototype(int shapeId) {\r\n         CTConnector ct = CTConnector.Factory.newInstance();\r\n         CTConnectorNonVisual nvSpPr = ct.addNewNvCxnSpPr();\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFConnectorShape.java",
                "sha": "b894cd080df28c39bc29beeb77ce32cbbc4aeed9",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "patch": "@@ -77,7 +77,7 @@ protected CTTransform2D getSafeXfrm() {\n     protected CTTransform2D getXfrm() {\r\n         PropertyFetcher<CTTransform2D> fetcher = new PropertyFetcher<CTTransform2D>() {\r\n             public boolean fetch(XSLFShape shape) {\r\n-                CTShapeProperties pr = getSpPr();\r\n+                CTShapeProperties pr = shape.getSpPr();\r\n                 if (pr.isSetXfrm()) {\r\n                     setValue(pr.getXfrm());\r\n                     return true;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "sha": "ee374602e1add5f8924c487c777ac28d16c507b0",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTable.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTable.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTable.java",
                "patch": "@@ -27,6 +27,7 @@\n import javax.xml.namespace.QName;\r\n \r\n import org.apache.poi.POIXMLException;\r\n+import org.apache.poi.sl.usermodel.TableShape;\r\n import org.apache.poi.util.Internal;\r\n import org.apache.poi.util.Units;\r\n import org.apache.xmlbeans.XmlCursor;\r\n@@ -45,7 +46,7 @@\n  *\r\n  * @author Yegor Kozlov\r\n  */\r\n-public class XSLFTable extends XSLFGraphicFrame implements Iterable<XSLFTableRow> {\r\n+public class XSLFTable extends XSLFGraphicFrame implements Iterable<XSLFTableRow>, TableShape {\r\n     static String TABLE_URI = \"http://schemas.openxmlformats.org/drawingml/2006/table\";\r\n \r\n     private CTTable _table;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTable.java",
                "sha": "9f2bb490327f1258209cf78762a378ee4580f0a4",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/hslf/usermodel/HSLFTable.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/usermodel/HSLFTable.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/usermodel/HSLFTable.java",
                "patch": "@@ -21,6 +21,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hslf.model.Line;\n import org.apache.poi.hslf.usermodel.*;\n import org.apache.poi.sl.usermodel.ShapeContainer;\n+import org.apache.poi.sl.usermodel.TableShape;\n import org.apache.poi.util.LittleEndian;\n \n import java.util.*;\n@@ -32,7 +33,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  *\n  * @author Yegor Kozlov\n  */\n-public final class HSLFTable extends HSLFGroupShape {\n+public final class HSLFTable extends HSLFGroupShape implements TableShape {\n \n     protected static final int BORDER_TOP = 1;\n     protected static final int BORDER_RIGHT = 2;",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/hslf/usermodel/HSLFTable.java",
                "sha": "29fdee2dc5e16354eb0621cbf6fb1dad1e442506",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawAutoShape.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawAutoShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawAutoShape.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import org.apache.poi.sl.usermodel.*;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawAutoShape.java",
                "sha": "6af2b4b9c18d56669483edee04e7c9504f98b8d9",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawBackground.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawBackground.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawBackground.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.*;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawBackground.java",
                "sha": "35c844d8d053682810a9136ff6f9cc095df7af08",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawConnectorShape.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawConnectorShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawConnectorShape.java",
                "patch": "@@ -0,0 +1,26 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.sl.draw;\r\n+\r\n+import org.apache.poi.sl.usermodel.*;\r\n+\r\n+public class DrawConnectorShape<T extends ConnectorShape> extends DrawSimpleShape<T> {\r\n+    public DrawConnectorShape(T shape) {\r\n+        super(shape);\r\n+    }\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawConnectorShape.java",
                "sha": "0fee07cf6dd01284b9358bab42d9a7652e76a867",
                "status": "added"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawFactory.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawFactory.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawFactory.java",
                "patch": "@@ -75,6 +75,10 @@ public Drawable getDrawable(Shape shape) {\n             return getDrawable((PictureShape)shape);\r\n         } else if (shape instanceof Background) {\r\n             return getDrawable((Background)shape);\r\n+        } else if (shape instanceof ConnectorShape) {\r\n+            return getDrawable((ConnectorShape)shape);\r\n+        } else if (shape instanceof TableShape) {\r\n+            return getDrawable((TableShape)shape);\r\n         } else if (shape instanceof Slide) {\r\n             return getDrawable((Slide<? extends Shape, ? extends SlideShow, ? extends Notes<?,?>>)shape);\r\n         } else if (shape instanceof MasterSheet) {\r\n@@ -106,6 +110,14 @@ public Drawable getDrawable(Shape shape) {\n         return new DrawFreeformShape<T>(shape);\r\n     }\r\n \r\n+    public <T extends ConnectorShape> DrawConnectorShape<T> getDrawable(T shape) {\r\n+        return new DrawConnectorShape<T>(shape);\r\n+    }\r\n+    \r\n+    public <T extends TableShape> DrawTableShape<T> getDrawable(T shape) {\r\n+        return new DrawTableShape<T>(shape);\r\n+    }\r\n+    \r\n     public <T extends TextShape<? extends TextParagraph<? extends TextRun>>> DrawTextShape<T> getDrawable(T shape) {\r\n         return new DrawTextShape<T>(shape);\r\n     }\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawFactory.java",
                "sha": "97b3f52147c678c8f92024596a6c3346c4e37495",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawFreeformShape.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawFreeformShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawFreeformShape.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import org.apache.poi.sl.usermodel.*;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawFreeformShape.java",
                "sha": "b8dd7c3f203948e794b1e3ceb03dc37632988987",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawGroupShape.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawGroupShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawGroupShape.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Graphics2D;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawGroupShape.java",
                "sha": "60af5f710e636c6cc4c2a12b545d628e3f9c8878",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawMasterSheet.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawMasterSheet.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawMasterSheet.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import org.apache.poi.sl.usermodel.*;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawMasterSheet.java",
                "sha": "6b5d0781dfec2cc9a7415ad1b7324b7db07b116e",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawPictureShape.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawPictureShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawPictureShape.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Graphics2D;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawPictureShape.java",
                "sha": "3d00b4ec6bfdf69beb52996004add0d278a0e9ee",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawShape.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawShape.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Graphics2D;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawShape.java",
                "sha": "c2c9b5f680dc54d17302dbd85ad7947cb09cdbb6",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawSheet.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawSheet.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawSheet.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Dimension;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawSheet.java",
                "sha": "e4c7e185e8a4e09818338841a79ddcccc3254700",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawSimpleShape.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawSimpleShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawSimpleShape.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.*;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawSimpleShape.java",
                "sha": "bdd65df6b22f89251fe8465a3fe76fea394cd410",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawSlide.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawSlide.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawSlide.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Graphics2D;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawSlide.java",
                "sha": "70c54d18f7dea8c31aedda9a2cfba44ea71faafc",
                "status": "modified"
            },
            {
                "additions": 27,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTableShape.java",
                "changes": 27,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawTableShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawTableShape.java",
                "patch": "@@ -0,0 +1,27 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.sl.draw;\r\n+\r\n+import org.apache.poi.sl.usermodel.*;\r\n+\r\n+public class DrawTableShape<T extends TableShape> extends DrawShape<T> {\r\n+    // to be implemented ...\r\n+    public DrawTableShape(T shape) {\r\n+        super(shape);\r\n+    }\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTableShape.java",
                "sha": "ceb6450d0b6430caaf994befc82c0f6dc46c6720",
                "status": "added"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextBox.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextBox.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawTextBox.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import org.apache.poi.sl.usermodel.*;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextBox.java",
                "sha": "89d69223ff10537acdd274aa85966c9d63f9f78a",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextFragment.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextFragment.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawTextFragment.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Graphics2D;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextFragment.java",
                "sha": "acb6b4c766fd493c9748a0fafac89731d3c36c13",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextParagraph.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextParagraph.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawTextParagraph.java",
                "patch": "@@ -1,3 +1,20 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Color;\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextParagraph.java",
                "sha": "6b118617e7ba14169e30e26f0947452b15d78c24",
                "status": "modified"
            },
            {
                "additions": 30,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextShape.java",
                "changes": 31,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/sl/draw/DrawTextShape.java",
                "patch": "@@ -1,13 +1,31 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n package org.apache.poi.sl.draw;\r\n \r\n import java.awt.Graphics2D;\r\n import java.awt.geom.AffineTransform;\r\n import java.awt.geom.Rectangle2D;\r\n import java.awt.image.BufferedImage;\r\n-import java.util.Iterator;\r\n+import java.util.*;\r\n \r\n import org.apache.poi.sl.usermodel.*;\r\n import org.apache.poi.sl.usermodel.TextParagraph.BulletStyle;\r\n+import org.apache.poi.util.JvmBugs;\r\n \r\n public class DrawTextShape<T extends TextShape<? extends TextParagraph<? extends TextRun>>> extends DrawSimpleShape<T> {\r\n \r\n@@ -146,6 +164,17 @@ public double getTextHeight(){\n         // dry-run in a 1x1 image and return the vertical advance\r\n         BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\r\n         Graphics2D graphics = img.createGraphics();\r\n+        fixFonts(graphics);\r\n         return drawParagraphs(graphics, 0, 0);\r\n     }\r\n+    \r\n+    @SuppressWarnings(\"unchecked\")\r\n+    private static void fixFonts(Graphics2D graphics) {\r\n+        if (!JvmBugs.hasLineBreakMeasurerBug()) return;\r\n+        Map<String,String> fontMap = (Map<String,String>)graphics.getRenderingHint(Drawable.FONT_MAP);\r\n+        if (fontMap == null) fontMap = new HashMap<String,String>();\r\n+        fontMap.put(\"Calibri\", \"Lucida Sans\");\r\n+        fontMap.put(\"Cambria\", \"Lucida Bright\");\r\n+        graphics.setRenderingHint(Drawable.FONT_MAP, fontMap);        \r\n+    }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/draw/DrawTextShape.java",
                "sha": "77927bdc69b07558fc902f217ad0f50cb38b848e",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/usermodel/ConnectorShape.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/usermodel/ConnectorShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/usermodel/ConnectorShape.java",
                "patch": "@@ -0,0 +1,22 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.sl.usermodel;\r\n+\r\n+public interface ConnectorShape extends SimpleShape {\r\n+\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/usermodel/ConnectorShape.java",
                "sha": "7e2bbf065cbf91beff8dd52a2457f0a69e394c5f",
                "status": "added"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/usermodel/TableShape.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/sl/usermodel/TableShape.java?ref=1102414559fdfe86cb3af5a11a94490aa928f704",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/sl/usermodel/TableShape.java",
                "patch": "@@ -0,0 +1,22 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.sl.usermodel;\r\n+\r\n+public interface TableShape extends Shape {\r\n+    // to be defined ...\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/1102414559fdfe86cb3af5a11a94490aa928f704/src/scratchpad/src/org/apache/poi/sl/usermodel/TableShape.java",
                "sha": "48744ec383dc1ecf8ca910587ac30069b458d8a5",
                "status": "added"
            }
        ],
        "message": "added ASL header to drawing classes\nfixed a few rendering NPEs\nadded dummy interfaces for table / connector shapes\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/common_sl@1690185 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/3cab0825131d36705c058c2e011c9918c8addfdf",
        "patched_files": [
            "DrawPictureShape.java",
            "XSLFSimpleShape.java",
            "XSLFTable.java",
            "XSLFConnectorShape.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestDrawPictureShape.java",
            "TestXSLFConnectorShape.java",
            "TestXSLFTable.java",
            "TestXSLFSimpleShape.java"
        ]
    },
    "poi_12ac00e": {
        "bug_id": "poi_12ac00e",
        "commit": "https://github.com/apache/poi/commit/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e",
        "file": [
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "changes": 31,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java?ref=12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e",
                "deletions": 14,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "patch": "@@ -224,20 +224,23 @@ public void setColor(String rgbStr) {\n         ctshd.setFill(rgbStr);\r\n     }\r\n \r\n-    /**\r\n-     * Get the vertical alignment of the cell.\r\n-     *\r\n-     * @return the cell alignment enum value\r\n-     */\r\n-    public XWPFVertAlign getVerticalAlignment() {\r\n-        XWPFVertAlign vAlign = null;\r\n-        CTTcPr tcpr = ctTc.getTcPr();\r\n-        if (tcpr != null) {\r\n-            CTVerticalJc va = tcpr.getVAlign();\r\n-            vAlign = stVertAlignTypeMap.get(va.getVal().intValue());\r\n-        }\r\n-        return vAlign;\r\n-    }\r\n+    /**\n+     * Get the vertical alignment of the cell.\n+     *\n+     * @return the cell alignment enum value or <code>null</code>\n+     * if no vertical alignment is set.\n+     */\n+    public XWPFVertAlign getVerticalAlignment() {\n+        XWPFVertAlign vAlign = null;\n+        CTTcPr tcpr = ctTc.getTcPr();\n+        if (tcpr != null) {\n+            CTVerticalJc va = tcpr.getVAlign();\n+            if (va != null && va.getVal() != null) {\n+                vAlign = stVertAlignTypeMap.get(va.getVal().intValue());\n+            }\n+        }\n+        return vAlign;\n+    }\n \r\n     /**\r\n      * Set the vertical alignment of the cell.\r",
                "raw_url": "https://github.com/apache/poi/raw/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "sha": "dd011e3679e26defbc4d963d72675a36f85a3b4e",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java?ref=12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java",
                "patch": "@@ -19,8 +19,11 @@\n \n package org.apache.poi.xwpf.usermodel;\n \n+import java.util.List;\n+\n import junit.framework.TestCase;\n \n+import org.apache.poi.xwpf.XWPFTestDataSamples;\n import org.apache.poi.xwpf.usermodel.XWPFTableCell.XWPFVertAlign;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHMerge;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTShd;\n@@ -103,4 +106,20 @@ public void test54099() {\n         CTTcBorders tblBorders = tcPr.addNewTcBorders();\n         CTVMerge vMerge = tcPr.addNewVMerge();\n     }\n+\n+    public void testCellVerticalAlign() throws Exception{\n+        XWPFDocument docx = XWPFTestDataSamples.openSampleDocument(\"59030.docx\");\n+        List<XWPFTable> tables = docx.getTables();\n+        assertEquals(1, tables.size());\n+\n+        XWPFTable table = tables.get(0);\n+\n+        List<XWPFTableRow> tableRows = table.getRows();\n+        assertEquals(2, tableRows.size());\n+\n+        assertNull(tableRows.get(0).getCell(0).getVerticalAlignment());\n+        assertEquals(XWPFVertAlign.BOTTOM, tableRows.get(0).getCell(1).getVerticalAlignment());\n+        assertEquals(XWPFVertAlign.CENTER, tableRows.get(1).getCell(0).getVerticalAlignment());\n+        assertNull(tableRows.get(1).getCell(1).getVerticalAlignment());\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java",
                "sha": "ab2fad84b38574e26c8a54836bfb2aea348a3050",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e/test-data/document/59030.docx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/59030.docx?ref=12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e",
                "deletions": 0,
                "filename": "test-data/document/59030.docx",
                "raw_url": "https://github.com/apache/poi/raw/12ac00eafd677f6e6be10a143a8f2b6ef96a3d2e/test-data/document/59030.docx",
                "sha": "cf40dd2213a44972cce7f1bccdfd6f9db8933386",
                "status": "added"
            }
        ],
        "message": "POI 59030 fix NPE in XWPFTableCell's getVerticalAlignment via Prasad Babu\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1731257 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/36ae29751d6109c781deedb0ede25e677db401c7",
        "patched_files": [
            "XWPFTableCell.java",
            "59030.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFTableCell.java"
        ]
    },
    "poi_12ace59": {
        "bug_id": "poi_12ace59",
        "commit": "https://github.com/apache/poi/commit/12ace59f6e37d6c4dd96609fe9face402474f40b",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/12ace59f6e37d6c4dd96609fe9face402474f40b/src/java/org/apache/poi/ss/formula/OperationEvaluationContext.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/OperationEvaluationContext.java?ref=12ace59f6e37d6c4dd96609fe9face402474f40b",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/ss/formula/OperationEvaluationContext.java",
                "patch": "@@ -94,7 +94,11 @@ SheetRangeEvaluator createExternSheetRefEvaluator(ExternalSheet externalSheet) {\n \t\tif (externalSheet == null || externalSheet.getWorkbookName() == null) {\n \t\t\t// sheet is in same workbook\n \t\t\ttargetEvaluator = _bookEvaluator;\n-\t\t\totherFirstSheetIndex = _workbook.getSheetIndex(externalSheet.getSheetName());\n+\t\t\tif(externalSheet == null) {\n+\t\t\t    otherFirstSheetIndex = 0;\n+\t\t\t} else {\n+\t\t\t    otherFirstSheetIndex = _workbook.getSheetIndex(externalSheet.getSheetName());\n+\t\t\t}\n \t\t\t\n \t\t\tif (externalSheet instanceof ExternalSheetRange) {\n \t\t\t    String lastSheetName = ((ExternalSheetRange)externalSheet).getLastSheetName();",
                "raw_url": "https://github.com/apache/poi/raw/12ace59f6e37d6c4dd96609fe9face402474f40b/src/java/org/apache/poi/ss/formula/OperationEvaluationContext.java",
                "sha": "cc590772de5841ae14ac73e8b28c1dd12677aef9",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/poi/blob/12ace59f6e37d6c4dd96609fe9face402474f40b/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=12ace59f6e37d6c4dd96609fe9face402474f40b",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -2846,4 +2846,22 @@ public void test48043() throws IOException {\n \n         wb.close();\n     }\n+    \n+    @Test\n+    public void test57925() throws IOException {\n+        Workbook wb = HSSFTestDataSamples.openSampleWorkbook(\"57925.xls\");\n+        \n+        wb.getCreationHelper().createFormulaEvaluator().evaluateAll();\n+        \n+        for(int i = 0;i < wb.getNumberOfSheets();i++) {\n+            Sheet sheet = wb.getSheetAt(i);\n+            for(Row row : sheet) {\n+                for(Cell cell : row) {\n+                    new DataFormatter().formatCellValue(cell);\n+                }\n+            }\n+        }\n+        \n+        wb.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/12ace59f6e37d6c4dd96609fe9face402474f40b/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "92661f8aeeb574efb46f5faaf9f7c069e0b03efc",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/12ace59f6e37d6c4dd96609fe9face402474f40b/test-data/spreadsheet/57925.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/57925.xls?ref=12ace59f6e37d6c4dd96609fe9face402474f40b",
                "deletions": 0,
                "filename": "test-data/spreadsheet/57925.xls",
                "raw_url": "https://github.com/apache/poi/raw/12ace59f6e37d6c4dd96609fe9face402474f40b/test-data/spreadsheet/57925.xls",
                "sha": "ef13551ff474875b13b01771bd2ded8f1979b94e",
                "status": "added"
            }
        ],
        "message": "Bug 57925: Add unit test and a simple fix to at least avoid the NPE when Workbooks have invalid external references\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1703999 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e47a129a5bb6a4ef21c44b82668bb981a7a1afac",
        "patched_files": [
            "OperationEvaluationContext.java",
            "57925.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java"
        ]
    },
    "poi_12e9918": {
        "bug_id": "poi_12e9918",
        "commit": "https://github.com/apache/poi/commit/12e99187591d76bf3e47bc2848fec136d9087c22",
        "file": [
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/poi/blob/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java?ref=12e99187591d76bf3e47bc2848fec136d9087c22",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java",
                "patch": "@@ -69,6 +69,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.poifs.filesystem.Entry;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n import org.apache.poi.util.Internal;\n+import org.apache.poi.util.POIUtils;\n \n \n /**\n@@ -947,6 +948,7 @@ public void write(OutputStream out)\n         POIFSFileSystem pfs = new POIFSFileSystem();\n         boolean docWritten = false;\n         boolean dataWritten = false;\n+        boolean objectPoolWritten = false;\n         boolean tableWritten = false;\n         boolean propertiesWritten = false;\n         for ( Iterator<Entry> iter = directory.getEntries(); iter.hasNext(); )\n@@ -961,6 +963,14 @@ public void write(OutputStream out)\n                     docWritten = true;\n                 }\n             }\n+            else if ( entry.getName().equals( STREAM_OBJECT_POOL ) )\n+            {\n+                if ( !objectPoolWritten )\n+                {\n+                    _objectPool.writeTo( pfs.getRoot() );\n+                    objectPoolWritten = true;\n+                }\n+            }\n             else if ( entry.getName().equals( STREAM_TABLE_0 )\n                     || entry.getName().equals( STREAM_TABLE_1 ) )\n             {\n@@ -993,7 +1003,7 @@ else if ( entry.getName().equals( STREAM_DATA ) )\n             }\n             else\n             {\n-                copyNodeRecursively( entry, pfs.getRoot() );\n+                POIUtils.copyNodeRecursively( entry, pfs.getRoot() );\n             }\n         }\n \n@@ -1008,6 +1018,8 @@ else if ( entry.getName().equals( STREAM_DATA ) )\n         if ( !dataWritten )\n             pfs.createDocument( new ByteArrayInputStream( dataBuf ),\n                     STREAM_DATA );\n+        if ( !objectPoolWritten )\n+            _objectPool.writeTo( pfs.getRoot() );\n \n         pfs.writeFilesystem( out );\n         this.directory = pfs.getRoot();",
                "raw_url": "https://github.com/apache/poi/raw/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java",
                "sha": "99ab39c9ac627269e05d850a0cc66f877528decc",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java?ref=12e99187591d76bf3e47bc2848fec136d9087c22",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java",
                "patch": "@@ -158,12 +158,14 @@ public HWPFDocumentCore(DirectoryNode directory) throws IOException {\n       throw new EncryptedDocumentException(\"Cannot process encrypted word files!\");\n     }\n \n+    DirectoryEntry objectPoolEntry;\n     try {\n-      DirectoryEntry objectPoolEntry = (DirectoryEntry) directory\n+      objectPoolEntry = (DirectoryEntry) directory\n               .getEntry(STREAM_OBJECT_POOL);\n-      _objectPool = new ObjectPoolImpl(objectPoolEntry);\n     } catch (FileNotFoundException exc) {\n+      objectPoolEntry = null;\n     }\n+    _objectPool = new ObjectPoolImpl(objectPoolEntry);\n   }\n \n   /**",
                "raw_url": "https://github.com/apache/poi/raw/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java",
                "sha": "4779cad53e754c3b68088dab903ff8e4a0f30f41",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/src/org/apache/poi/hwpf/usermodel/ObjectPoolImpl.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/usermodel/ObjectPoolImpl.java?ref=12e99187591d76bf3e47bc2848fec136d9087c22",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/usermodel/ObjectPoolImpl.java",
                "patch": "@@ -17,10 +17,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n package org.apache.poi.hwpf.usermodel;\n \n import java.io.FileNotFoundException;\n+import java.io.IOException;\n \n import org.apache.poi.poifs.filesystem.DirectoryEntry;\n import org.apache.poi.poifs.filesystem.Entry;\n import org.apache.poi.util.Internal;\n+import org.apache.poi.util.POIUtils;\n \n @Internal\n public class ObjectPoolImpl implements ObjectsPool\n@@ -47,4 +49,11 @@ public Entry getObjectById( String objId )\n             return null;\n         }\n     }\n+\n+    @Internal\n+    public void writeTo( DirectoryEntry directoryEntry ) throws IOException\n+    {\n+        if ( _objectPool != null )\n+            POIUtils.copyNodeRecursively( _objectPool, directoryEntry );\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/src/org/apache/poi/hwpf/usermodel/ObjectPoolImpl.java",
                "sha": "aa33fd504cb4e93f9fa8ebbda5ba7999309a1070",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/testcases/org/apache/poi/hwpf/extractor/TestWordExtractor.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hwpf/extractor/TestWordExtractor.java?ref=12e99187591d76bf3e47bc2848fec136d9087c22",
                "deletions": 1,
                "filename": "src/scratchpad/testcases/org/apache/poi/hwpf/extractor/TestWordExtractor.java",
                "patch": "@@ -362,7 +362,7 @@ public void testDifferentPOIFS() throws Exception {\n      * [RESOLVED FIXED] Bug 51686 - Update to POI 3.8 beta 4 causes\n      * ConcurrentModificationException in Tika's OfficeParser\n      */\n-    public void testRootEntiesNavigation() throws IOException\n+    public void testBug51686() throws IOException\n     {\n         InputStream is = POIDataSamples.getDocumentInstance()\n                 .openResourceAsStream( \"Bug51686.doc\" );",
                "raw_url": "https://github.com/apache/poi/raw/12e99187591d76bf3e47bc2848fec136d9087c22/src/scratchpad/testcases/org/apache/poi/hwpf/extractor/TestWordExtractor.java",
                "sha": "b10076c81567ede31cce20b132a9411ae91ca524",
                "status": "modified"
            }
        ],
        "message": "refix 51686 - fix possible NPE, add writeTo() to ObjectPoolImpl.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1160152 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/fff84f00eedabad5c2d168f29cf954f94ed36982",
        "patched_files": [
            "ObjectPoolImpl.java",
            "WordExtractor.java",
            "HWPFDocument.java",
            "HWPFDocumentCore.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestWordExtractor.java"
        ]
    },
    "poi_13a8979": {
        "bug_id": "poi_13a8979",
        "commit": "https://github.com/apache/poi/commit/13a89798d99de1edb27d35cee1aa366d74e0663a",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/documentation/content/xdocs/changes.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -50,6 +50,8 @@\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Created a common interface for handling Excel files, irrespective of if they are .xls or .xlsx</action>\n         </release>\n         <release version=\"3.1.1-alpha1\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">45322 - Fixed NPE in HSSFSheet.autoSizeColumn() when cell number format was not found</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"add\">45380 - Missing return keyword in ArrayPtg.toFormulaString()</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">44958 - Record level support for Data Tables. (No formula parser support though)</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">35583 - Include a version class, org.apache.poi.Version, to allow easy introspection of the POI version</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Allow the cloning of one HSSFCellStyle onto another, including cloning styles from one HSSFWorkbook onto another</action>",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/documentation/content/xdocs/changes.xml",
                "sha": "1fee98e86e28ddfd867e0ff1902d0ae423d08eb3",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/documentation/content/xdocs/status.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -47,6 +47,8 @@\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Created a common interface for handling Excel files, irrespective of if they are .xls or .xlsx</action>\n         </release>\n         <release version=\"3.1.1-alpha1\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">45322 - Fixed NPE in HSSFSheet.autoSizeColumn() when cell number format was not found</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"add\">45380 - Missing return keyword in ArrayPtg.toFormulaString()</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">44958 - Record level support for Data Tables. (No formula parser support though)</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">35583 - Include a version class, org.apache.poi.Version, to allow easy introspection of the POI version</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Allow the cloning of one HSSFCellStyle onto another, including cloning styles from one HSSFWorkbook onto another</action>",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/documentation/content/xdocs/status.xml",
                "sha": "e6472d6e9a762a982524ce99c315e773d5aa5a92",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java",
                "patch": "@@ -176,7 +176,7 @@ private static String getConstantText(Object o) {\n \t\t\treturn ((Double)o).toString();\n \t\t}\n \t\tif (o instanceof Boolean) {\n-\t\t\t((Boolean)o).toString();\n+\t\t\treturn ((Boolean)o).booleanValue() ? \"TRUE\" : \"FALSE\";\n \t\t}\n \t\tif (o instanceof ErrorConstant) {\n \t\t\treturn ((ErrorConstant)o).getText();",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java",
                "sha": "b38bcd27de628058a0924d3a2437706f057e9bf1",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java",
                "patch": "@@ -280,21 +280,23 @@ public short getDataFormat()\n      * Get the contents of the format string, by looking up\n      *  the DataFormat against the bound workbook\n      * @see org.apache.poi.hssf.usermodel.HSSFDataFormat\n+     * @return the format string or \"General\" if not found\n      */\n     public String getDataFormatString() {\n-    \tHSSFDataFormat format = new HSSFDataFormat(workbook);\n-    \t\n-        return format.getFormat(getDataFormat());\n+        return getDataFormatString(workbook);\n     }\n     /**\n      * Get the contents of the format string, by looking up\n      *  the DataFormat against the supplied workbook\n      * @see org.apache.poi.hssf.usermodel.HSSFDataFormat\n+     *\n+     * @return the format string or \"General\" if not found\n      */\n     public String getDataFormatString(org.apache.poi.ss.usermodel.Workbook workbook) {\n     \tHSSFDataFormat format = new HSSFDataFormat( ((HSSFWorkbook)workbook).getWorkbook() );\n     \t\n-        return format.getFormat(getDataFormat());\n+        int idx = getDataFormat();\n+        return idx == -1 ? \"General\" : format.getFormat(getDataFormat());\n     }\n     /**\n      * Get the contents of the format string, by looking up",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java",
                "sha": "64c5b6df44fe061ef3d177763540f16f1ceaf8da",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 3,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -1868,9 +1868,7 @@ public void autoSizeColumn(short column, boolean useMergedCells) {\n             } else {\n                 String sval = null;\n                 if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC) {\n-                    HSSFDataFormat dataformat = wb.createDataFormat();\n-                    short idx = style.getDataFormat();\n-                    String format = dataformat.getFormat(idx).replaceAll(\"\\\"\", \"\");\n+                    String format = style.getDataFormatString().replaceAll(\"\\\"\", \"\");\n                     double value = cell.getNumericCellValue();\n                     try {\n                         NumberFormat fmt;",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "d4bc9613d04134f2596bb83e2616175073f0d138",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/testcases/org/apache/poi/hssf/data/45322.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/45322.xls?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/45322.xls",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/testcases/org/apache/poi/hssf/data/45322.xls",
                "sha": "711721400e984db67c87bbf23d0b7e579f0218fc",
                "status": "added"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java",
                "patch": "@@ -102,7 +102,7 @@ public void testElementOrdering() {\n \tpublic void testElementOrderingInSpreadsheet() {\n \t\tHSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(\"ex42564-elementOrder.xls\");\n \n-\t\t// The formula has an array with 3 rows and 5 column \n+\t\t// The formula has an array with 3 rows and 5 columns \n \t\tString formula = wb.getSheetAt(0).getRow(0).getCell((short)0).getCellFormula();\n \t\t// TODO - These number literals should not have '.0'. Excel has different number rendering rules\n \n@@ -111,4 +111,21 @@ public void testElementOrderingInSpreadsheet() {\n \t\t}\n \t\tassertEquals(\"SUM({1.0,2.0,3.0;4.0,5.0,6.0;7.0,8.0,9.0;10.0,11.0,12.0;13.0,14.0,15.0})\", formula);\n \t}\n+\n+\tpublic void testToFormulaString() {\n+\t\tArrayPtg ptg = new ArrayPtg(new TestcaseRecordInputStream(ArrayPtg.sid, ENCODED_PTG_DATA));\n+\t\t\n+\t\tptg.readTokenValues(new TestcaseRecordInputStream(0, ENCODED_CONSTANT_DATA));\n+\t\t\n+\t\tString actualFormula;\n+\t\ttry {\n+\t\t\tactualFormula = ptg.toFormulaString(null);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tif (e.getMessage().equals(\"Unexpected constant class (java.lang.Boolean)\")) {\n+\t\t\t\tthrow new AssertionFailedError(\"Identified bug 45380\");\n+\t\t\t}\n+\t\t\tthrow e;\n+\t\t}\n+\t\tassertEquals(\"{TRUE,\\\"ABCD\\\";\\\"E\\\",0.0;FALSE,\\\"FG\\\"}\", actualFormula);\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java",
                "sha": "14bcde38b3f8d2b08773e899f29dbd1a3a60f3df",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/13a89798d99de1edb27d35cee1aa366d74e0663a/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=13a89798d99de1edb27d35cee1aa366d74e0663a",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -1354,4 +1354,13 @@ public void test44958() throws Exception {\n         // TODO - check the formula once tables and\n         //  arrays are properly supported\n     }\n+\n+    /**\n+     * 45322: HSSFSheet.autoSizeColumn fails when style.getDataFormat() returns -1\n+     */\n+    public void test45322() throws Exception {\n+        HSSFWorkbook wb = openSample(\"44958.xls\");\n+        HSSFSheet sh = wb.getSheetAt(0);\n+        for(short i=0; i < 30; i++) sh.autoSizeColumn(i);\n+     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/13a89798d99de1edb27d35cee1aa366d74e0663a/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "40e4bd34dd538b28405b54f67dcc1148c9b7e37f",
                "status": "modified"
            }
        ],
        "message": "Merged revisions 638786-638802,638805-638811,638813-638814,638816-639230,639233-639241,639243-639253,639255-639486,639488-639601,639603-639835,639837-639917,639919-640056,640058-640710,640712-641156,641158-641184,641186-641795,641797-641798,641800-641933,641935-641963,641965-641966,641968-641995,641997-642230,642232-642562,642564-642565,642568-642570,642572-642573,642576-642736,642739-642877,642879,642881-642890,642892-642903,642905-642945,642947-643624,643626-643653,643655-643669,643671,643673-643830,643832-643833,643835-644342,644344-644472,644474-644508,644510-645347,645349-645351,645353-645559,645561-645565,645568-645951,645953-646193,646195-646311,646313-646404,646406-646665,646667-646853,646855-646869,646871-647151,647153-647185,647187-647277,647279-647566,647568-647573,647575,647578-647711,647714-647737,647739-647823,647825-648155,648157-648202,648204-648273,648275,648277-648302,648304-648333,648335-648588,648590-648622,648625-648673,648675-649141,649144,649146-649556,649558-649795,649799,649801-649910,649912-649913,649915-650128,650131-650132,650134-650137,650140-650914,650916-651991,651993-652284,652286-652287,652289,652291,652293-652297,652299-652328,652330-652425,652427-652445,652447-652560,652562-652933,652935,652937-652993,652995-653116,653118-653124,653126-653483,653487-653519,653522-653550,653552-653607,653609-653667,653669-653674,653676-653814,653817-653830,653832-653891,653893-653944,653946-654055,654057-654355,654357-654365,654367-654648,654651-655215,655217-655277,655279-655281,655283-655911,655913-656212,656214,656216-656251,656253-656698,656700-656756,656758-656892,656894-657135,657137-657165,657168-657179,657181-657354,657356-657357,657359-657701,657703-657874,657876-658032,658034-658284,658286,658288-658301,658303-658307,658309-658321,658323-658335,658337-658348,658351,658353-658832,658834-658983,658985,658987-659066,659068-659402,659404-659428,659430-659451,659453-659454,659456-659461,659463-659477,659479-659524,659526-659571,659574,659576-660255,660257-660262,660264-660279,660281-660343,660345-660473,660475-660827,660829-660833,660835-660888,660890-663321,663323-663435,663437-663764,663766-663854,663856-664219,664221-664489,664494-664514,664516-668013,668015-668142,668144-668152,668154,668156-668256,668258,668260-669139,669141-669455,669457-669657,669659-669808,669810-670189,670191-671321,671323-672229,672231-672549,672551-672552,672554-672561,672563-672566,672568,672571-673049,673051-673852,673854-673862,673864-673986,673988-673996,673998-674347,674349-674890,674892-674910,674912-674936,674938-674952,674954-675078,675080-675085,675087-675217,675219-675660,675662-675670,675672-675716,675718-675726,675728-675733,675735-675775,675777-675782,675784,675786-675791,675794-675852,675854-676200,676202,676204,676206-676220,676222-676309,676311-677004 via svnmerge from \nhttps://svn.apache.org/repos/asf/poi/trunk\n\n........\n  r676457 | josh | 2008-07-14 00:23:13 +0100 (Mon, 14 Jul 2008) | 1 line\n  \n  Fix for bug 45380 - added return keyword in ArrayPtg.toFormulaString()\n........\n  r676995 | yegor | 2008-07-15 19:13:50 +0100 (Tue, 15 Jul 2008) | 1 line\n  \n  fixed bug #45322: HSSFSheet.autoSizeColumn() throws NPE when cell number format was not found\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/ooxml@677006 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/70a07e7973447a6ebc1ff4a5bb222c9d6d9ed7db",
        "patched_files": [
            "ArrayPtg.java",
            "status.java",
            "HSSFCellStyle.java",
            "changes.java",
            "HSSFSheet.java",
            "45322.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java",
            "TestHSSFSheet.java",
            "TestArrayPtg.java"
        ]
    },
    "poi_16c68c9": {
        "bug_id": "poi_16c68c9",
        "commit": "https://github.com/apache/poi/commit/16c68c9f05595287f96efeff5cf4ec15fd0795e8",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/16c68c9f05595287f96efeff5cf4ec15fd0795e8/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.java?ref=16c68c9f05595287f96efeff5cf4ec15fd0795e8",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.java",
                "patch": "@@ -421,8 +421,11 @@ public String getMimeType()\n \n         if ( escherRecord instanceof EscherBSERecord )\n         {\n-            return ( (EscherBSERecord) escherRecord ).getBlipRecord()\n-                    .getPicturedata();\n+            EscherBlipRecord blip = ( (EscherBSERecord) escherRecord ).getBlipRecord();\n+            if (blip != null) {\n+                return blip.getPicturedata();\n+            \n+            }\n         }\n         return new byte[0];\n     }",
                "raw_url": "https://github.com/apache/poi/raw/16c68c9f05595287f96efeff5cf4ec15fd0795e8/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.java",
                "sha": "7eb3af2834fdd364a09deaae5ef6e69c45b05cfc",
                "status": "modified"
            }
        ],
        "message": "bug 60484: avoid NPE\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1777063 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/d45616031e9b27859b1f884da1a0891c4def0ba5",
        "patched_files": [
            "Picture.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestPicture.java"
        ]
    },
    "poi_26528d1": {
        "bug_id": "poi_26528d1",
        "commit": "https://github.com/apache/poi/commit/26528d13ca5adb3ed42ef4e65404984002958b37",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/src/org/apache/poi/hslf/model/Notes.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Notes.java?ref=26528d13ca5adb3ed42ef4e65404984002958b37",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Notes.java",
                "patch": "@@ -56,6 +56,10 @@ public Notes (org.apache.poi.hslf.record.Notes notes) {\n \t//  one of TextBytesAtom or TextCharsAtom, found inside \n \t//  EscherTextboxWrapper's in the PPDrawing\n \t_runs = findTextRuns(_notes.getPPDrawing());\n+\n+\t// Set the sheet on each TextRun\n+\tfor (int i = 0; i < _runs.length; i++)\n+\t\t_runs[i].setSheet(this);\n   }\n \n ",
                "raw_url": "https://github.com/apache/poi/raw/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/src/org/apache/poi/hslf/model/Notes.java",
                "sha": "20547571fc0348778f9dd4331f2f5c6c0ddfd548",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java?ref=26528d13ca5adb3ed42ef4e65404984002958b37",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java",
                "patch": "@@ -170,7 +170,8 @@ private boolean isCharFlagsTextPropVal(int index) {\n             Sheet sheet = parentRun.getSheet();\n             int txtype = parentRun.getRunType();\n             SlideMaster master = (SlideMaster)sheet.getMasterSheet();\n-            cftp = (CharFlagsTextProp)master.getStyleAttribute(txtype, getIndentLevel(), \"char_flags\", true);\n+            if (master != null)\n+                cftp = (CharFlagsTextProp)master.getStyleAttribute(txtype, getIndentLevel(), \"char_flags\", true);\n         }\n \n \t\treturn cftp == null ? false : cftp.getSubValue(index);\n@@ -223,7 +224,8 @@ private int getCharTextPropVal(String propName) {\n             Sheet sheet = parentRun.getSheet();\n             int txtype = parentRun.getRunType();\n             SlideMaster master = (SlideMaster)sheet.getMasterSheet();\n-            prop = master.getStyleAttribute(txtype, getIndentLevel(), propName, true);\n+            if (master != null)\n+                prop = master.getStyleAttribute(txtype, getIndentLevel(), propName, true);\n         }\n \t\treturn prop == null ? -1 : prop.getValue();\n \t}\n@@ -242,7 +244,8 @@ private int getParaTextPropVal(String propName) {\n             Sheet sheet = parentRun.getSheet();\n             int txtype = parentRun.getRunType();\n             SlideMaster master = (SlideMaster)sheet.getMasterSheet();\n-            prop = master.getStyleAttribute(txtype, getIndentLevel(), propName, false);\n+            if (master != null)\n+                prop = master.getStyleAttribute(txtype, getIndentLevel(), propName, false);\n         }\n \n \t\treturn prop == null ? -1 : prop.getValue();",
                "raw_url": "https://github.com/apache/poi/raw/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java",
                "sha": "99515198ed1ddec499a6248aee2cf0ea844c3124",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java?ref=26528d13ca5adb3ed42ef4e65404984002958b37",
                "deletions": 27,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java",
                "patch": "@@ -30,21 +30,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.ddf.EscherRecord;\n import org.apache.poi.hslf.*;\n import org.apache.poi.hslf.model.*;\n-import org.apache.poi.hslf.record.Document;\n-import org.apache.poi.hslf.record.DocumentAtom;\n-import org.apache.poi.hslf.record.FontCollection;\n-import org.apache.poi.hslf.record.ParentAwareRecord;\n-import org.apache.poi.hslf.record.PositionDependentRecordContainer;\n-import org.apache.poi.hslf.record.Record;\n-import org.apache.poi.hslf.record.RecordContainer;\n-import org.apache.poi.hslf.record.RecordTypes;\n-import org.apache.poi.hslf.record.SlideAtom;\n-import org.apache.poi.hslf.record.SlideListWithText;\n-import org.apache.poi.hslf.record.SlidePersistAtom;\n-import org.apache.poi.hslf.record.UserEditAtom;\n+import org.apache.poi.hslf.model.Notes;\n+import org.apache.poi.hslf.model.Slide;\n import org.apache.poi.hslf.record.SlideListWithText.*;\n-import org.apache.poi.hslf.record.PersistPtrHolder;\n-import org.apache.poi.hslf.record.PositionDependentRecord;\n+import org.apache.poi.hslf.record.*;\n import org.apache.poi.hslf.exceptions.CorruptPowerPointFileException;\n import org.apache.poi.util.ArrayUtil;\n import org.apache.poi.util.POILogFactory;\n@@ -363,13 +352,14 @@ private void buildSlidesAndNotes() {\n \t\t\tRecord r = getCoreRecordForSAS(notesSets[i]);\n \t\t\t\n \t\t\t// Ensure it really is a notes record\n-\t\t\tif(r != null && r instanceof org.apache.poi.hslf.record.Notes) {\n-\t\t\t\tnotesRecordsL.add( (org.apache.poi.hslf.record.Notes)r );\n+\t\t\tif(r instanceof org.apache.poi.hslf.record.Notes) {\n+                org.apache.poi.hslf.record.Notes notesRecord = (org.apache.poi.hslf.record.Notes)r;\n+\t\t\t\tnotesRecordsL.add( notesRecord );\n \t\t\t\t\n \t\t\t\t// Record the match between slide id and these notes\n-\t\t\t\tSlidePersistAtom spa = notesSets[i].getSlidePersistAtom();\n-\t\t\t\tInteger slideId = new Integer(spa.getSlideIdentifier());\n-\t\t\t\tslideIdToNotes.put(slideId, new Integer(i));\n+                SlidePersistAtom spa = notesSets[i].getSlidePersistAtom();\n+                Integer slideId = new Integer(spa.getSlideIdentifier());\n+                slideIdToNotes.put(slideId, new Integer(i));\n \t\t\t} else {\n \t\t\t\tlogger.log(POILogger.ERROR, \"A Notes SlideAtomSet at \" + i + \" said its record was at refID \" + notesSets[i].getSlidePersistAtom().getRefID() + \", but that was actually a \" + r);\n \t\t\t}\n@@ -397,7 +387,7 @@ private void buildSlidesAndNotes() {\n \t\t\tif(r instanceof org.apache.poi.hslf.record.Slide) {\n \t\t\t\tslidesRecords[i] = (org.apache.poi.hslf.record.Slide)r;\n \t\t\t} else {\n-\t\t\t\tSystem.err.println(\"A Slide SlideAtomSet at \" + i + \" said its record was at refID \" + slidesSets[i].getSlidePersistAtom().getRefID() + \", but that was actually a \" + r);\n+\t\t\t\tlogger.log(POILogger.ERROR, \"A Slide SlideAtomSet at \" + i + \" said its record was at refID \" + slidesSets[i].getSlidePersistAtom().getRefID() + \", but that was actually a \" + r);\n \t\t\t}\n \t\t}\n \t}\n@@ -422,15 +412,17 @@ private void buildSlidesAndNotes() {\n \tfor(int i=0; i<_slides.length; i++) {\n \t\tSlideAtomsSet sas = slidesSets[i];\n \t\tint slideIdentifier = sas.getSlidePersistAtom().getSlideIdentifier();\n-\t\tInteger slideIdentifierI = new Integer(slideIdentifier);\n-\t\t\n+\n \t\t// Do we have a notes for this?\n \t\tNotes notes = null;\n-\t\tif(slideIdToNotes.containsKey(slideIdentifierI)) {\n-\t\t\tInteger notesPos = (Integer)slideIdToNotes.get(slideIdentifierI);\n-\t\t\tnotes = _notes[notesPos.intValue()];\n-\t\t}\n-\t\t\n+        //Slide.SlideAtom.notesId references the corresponding notes slide. 0 if slide has no notes.\n+        int noteId = slidesRecords[i].getSlideAtom().getNotesID();\n+        if (noteId != 0){\n+            Integer notesPos = (Integer)slideIdToNotes.get(new Integer(noteId));\n+            if (notesPos != null) notes = _notes[notesPos.intValue()];\n+            else logger.log(POILogger.ERROR, \"Notes not found for noteId=\" + noteId);\n+        }\n+\n \t\t// Now, build our slide\n \t\t_slides[i] = new Slide(slidesRecords[i], notes, sas, slideIdentifier, (i+1));\n \t\t_slides[i].setSlideShow(this);",
                "raw_url": "https://github.com/apache/poi/raw/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java",
                "sha": "7f201fb7b46d136d44ca2b152816a41a5c5a19e0",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/testcases/org/apache/poi/hslf/data/42474-1.ppt",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/data/42474-1.ppt?ref=26528d13ca5adb3ed42ef4e65404984002958b37",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/data/42474-1.ppt",
                "raw_url": "https://github.com/apache/poi/raw/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/testcases/org/apache/poi/hslf/data/42474-1.ppt",
                "sha": "15b654d26fb971d27d21d99be56e454371f12910",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/testcases/org/apache/poi/hslf/data/42474-2.ppt",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/data/42474-2.ppt?ref=26528d13ca5adb3ed42ef4e65404984002958b37",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/data/42474-2.ppt",
                "raw_url": "https://github.com/apache/poi/raw/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/testcases/org/apache/poi/hslf/data/42474-2.ppt",
                "sha": "5c6f8ca90a03eaa79ac02b5896fe2709fea458f2",
                "status": "added"
            },
            {
                "additions": 68,
                "blob_url": "https://github.com/apache/poi/blob/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java?ref=26528d13ca5adb3ed42ef4e65404984002958b37",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "patch": "@@ -20,8 +20,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.TestCase;\r\n import org.apache.poi.hslf.HSLFSlideShow;\r\n import org.apache.poi.hslf.model.Picture;\r\n+import org.apache.poi.hslf.model.Slide;\r\n+import org.apache.poi.hslf.model.Notes;\r\n+import org.apache.poi.hslf.model.TextRun;\r\n \r\n import java.io.*;\r\n+import java.util.HashSet;\r\n+import java.util.HashMap;\r\n \r\n /**\r\n  * Testcases for bugs entered in bugzilla\r\n@@ -50,4 +55,67 @@ public void test41384() throws Exception {\n         assertEquals(Picture.JPEG, pict[0].getType());\r\n         assertEquals(Picture.JPEG, pict[1].getType());\r\n     }\r\n+\r\n+    /**\r\n+     * First fix from Bug 42474: NPE in RichTextRun.isBold()\r\n+     * when the RichTextRun comes from a Notes model object\r\n+     */\r\n+    public void test42474_1() throws Exception {\r\n+        FileInputStream is = new FileInputStream(new File(cwd, \"42474-1.ppt\"));\r\n+        HSLFSlideShow hslf = new HSLFSlideShow(is);\r\n+        is.close();\r\n+\r\n+        SlideShow ppt = new SlideShow(hslf);\r\n+        assertTrue(\"No Exceptions while reading file\", true);\r\n+        assertEquals(2, ppt.getSlides().length);\r\n+\r\n+        TextRun txrun;\r\n+        Notes notes;\r\n+\r\n+        notes = ppt.getSlides()[0].getNotesSheet();\r\n+        assertNotNull(notes);\r\n+        txrun = notes.getTextRuns()[0];\r\n+        assertEquals(\"Notes-1\", txrun.getRawText());\r\n+        assertEquals(false, txrun.getRichTextRuns()[0].isBold());\r\n+\r\n+        //notes for the second slide are in bold\r\n+        notes = ppt.getSlides()[1].getNotesSheet();\r\n+        assertNotNull(notes);\r\n+        txrun = notes.getTextRuns()[0];\r\n+        assertEquals(\"Notes-2\", txrun.getRawText());\r\n+        assertEquals(true, txrun.getRichTextRuns()[0].isBold());\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Second fix from Bug 42474: Incorrect matching of notes to slides\r\n+     */\r\n+    public void test42474_2() throws Exception {\r\n+        FileInputStream is = new FileInputStream(new File(cwd, \"42474-2.ppt\"));\r\n+        HSLFSlideShow hslf = new HSLFSlideShow(is);\r\n+        is.close();\r\n+\r\n+        SlideShow ppt = new SlideShow(hslf);\r\n+\r\n+        //map slide number and starting phrase of its notes\r\n+        HashMap notesMap = new HashMap();\r\n+        notesMap.put(new Integer(4), \"For  decades before calculators\");\r\n+        notesMap.put(new Integer(5), \"Several commercial applications\");\r\n+        notesMap.put(new Integer(6), \"There are three variations of LNS that are discussed here\");\r\n+        notesMap.put(new Integer(7), \"Although multiply and square root are easier\");\r\n+        notesMap.put(new Integer(8), \"The bus Z is split into Z_H and Z_L\");\r\n+\r\n+        Slide[] slide = ppt.getSlides();\r\n+        for (int i = 0; i < slide.length; i++) {\r\n+            Integer slideNumber = new Integer(slide[i].getSlideNumber());\r\n+            Notes notes = slide[i].getNotesSheet();\r\n+            if (notesMap.containsKey(slideNumber)){\r\n+                assertNotNull(notes);\r\n+                String text = notes.getTextRuns()[0].getRawText();\r\n+                String startingPhrase = (String)notesMap.get(slideNumber);\r\n+                assertTrue(\"Notes for slide \" + slideNumber + \" must start with \" +\r\n+                        startingPhrase , text.startsWith(startingPhrase));\r\n+            }\r\n+        }\r\n+    }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/26528d13ca5adb3ed42ef4e65404984002958b37/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "sha": "e79d05bc545cc1ebf801114fbeb93a04a9e67833",
                "status": "modified"
            }
        ],
        "message": "applied patches from bug 42474: (1) Incorrect matching of notes to slides and (2) NPE in RichTextRun.isBold() when the RichTextRun comes from a Notes model object\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@541219 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/946b6fee5891be896c03c6b62b65bbfeeaed63bd",
        "patched_files": [
            "Notes.java",
            "RichTextRun.java",
            "42474-1.java",
            "SlideShow.java",
            "42474-2.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java",
            "TestRichTextRun.java"
        ]
    },
    "poi_268d7ff": {
        "bug_id": "poi_268d7ff",
        "commit": "https://github.com/apache/poi/commit/268d7ff219fab2b908a76973664a3091273e2130",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/268d7ff219fab2b908a76973664a3091273e2130/src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableRow.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableRow.java?ref=268d7ff219fab2b908a76973664a3091273e2130",
                "deletions": 5,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableRow.java",
                "patch": "@@ -174,12 +174,15 @@ private void initCells()\n             cells.add( tableCell );\n         }\n \n-        TableCell lastCell = cells.get( cells.size() - 1 );\n-        if ( lastCell.numParagraphs() == 1\n-                && ( lastCell.getParagraph( 0 ).isTableRowEnd() ) )\n+        if ( !cells.isEmpty() )\n         {\n-            // remove \"fake\" cell\n-            cells.remove( cells.size() - 1 );\n+            TableCell lastCell = cells.get( cells.size() - 1 );\n+            if ( lastCell.numParagraphs() == 1\n+                    && ( lastCell.getParagraph( 0 ).isTableRowEnd() ) )\n+            {\n+                // remove \"fake\" cell\n+                cells.remove( cells.size() - 1 );\n+            }\n         }\n \n         if ( cells.size() != expectedCellsCount )",
                "raw_url": "https://github.com/apache/poi/raw/268d7ff219fab2b908a76973664a3091273e2130/src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableRow.java",
                "sha": "0d861dac86e306de7e24459e4d4c5fc85562b606",
                "status": "modified"
            }
        ],
        "message": "NPE check\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1145405 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1cd82a49678b443e70df50abd0472ef3dc4f3fa2",
        "patched_files": [
            "TableRow.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestTableRow.java"
        ]
    },
    "poi_2732e72": {
        "bug_id": "poi_2732e72",
        "commit": "https://github.com/apache/poi/commit/2732e72385829cfc1481da94ec0b092ecd01fb88",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/2732e72385829cfc1481da94ec0b092ecd01fb88/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java?ref=2732e72385829cfc1481da94ec0b092ecd01fb88",
                "deletions": 3,
                "filename": "src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "patch": "@@ -257,11 +257,11 @@ public void bug59830() throws IOException {\n \n     @Test\n     public void bug59858() throws IOException {\n-        File f = POIDataSamples.getSpreadSheetInstance().getFile(\"59830.xls\");\n+        File f = POIDataSamples.getSpreadSheetInstance().getFile(\"59858.xls\");\n         VBAMacroReader r = new VBAMacroReader(f);\n         Map<String, String> macros = r.readMacros();\n-        assertNotNull(macros.get(\"Module20\"));\n-        assertContains(macros.get(\"Module20\"), \"start of superscripting\");\n+        assertNotNull(macros.get(\"Sheet4\"));\n+        assertContains(macros.get(\"Sheet4\"), \"intentional constituent\");\n     }\n \n     @Test",
                "raw_url": "https://github.com/apache/poi/raw/2732e72385829cfc1481da94ec0b092ecd01fb88/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "sha": "a001ad9896fdff9b041fae0d70382be1158db1d0",
                "status": "modified"
            }
        ],
        "message": "BUG 59858 -- avoid npe when there's a collision of record names...doh. Fix unit test.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1765482 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/64051349494e0722abd477866483fbae29723fe2",
        "patched_files": [
            "VBAMacroReader.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestVBAMacroReader.java"
        ]
    },
    "poi_2776cf6": {
        "bug_id": "poi_2776cf6",
        "commit": "https://github.com/apache/poi/commit/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a",
        "file": [
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/poi/blob/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java?ref=2776cf6a599ebecb5d135e4e05d7fc995b46ad4a",
                "deletions": 6,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "patch": "@@ -346,11 +346,18 @@ private void setCellType(int cellType, boolean setValue, int row,short col, shor\n                 }\n                 if (setValue) {\n                     String str = convertCellValueToString();\n-                    int sstIndex = _book.getWorkbook().addSSTString(new UnicodeString(str));\n-                    lrec.setSSTIndex(sstIndex);\n-                    UnicodeString us = _book.getWorkbook().getSSTString(sstIndex);\n-                    _stringValue = new HSSFRichTextString();\n-                    _stringValue.setUnicodeString(us);\n+                    if(str == null) {\n+                        // bug 55668: don't try to store null-string when formula\n+                        // results in empty/null value\n+                        setCellType(CELL_TYPE_BLANK, false, row, col, styleIndex);\n+                        return;\n+                    } else {\n+                        int sstIndex = _book.getWorkbook().addSSTString(new UnicodeString(str));\n+                        lrec.setSSTIndex(sstIndex);\n+                        UnicodeString us = _book.getWorkbook().getSSTString(sstIndex);\n+                        _stringValue = new HSSFRichTextString();\n+                        _stringValue.setUnicodeString(us);\n+                    }\n                 }\n                 _record = lrec;\n                 break;\n@@ -884,7 +891,7 @@ public byte getErrorCellValue() {\n      * the HSSFWorkbook.</p>\n      * \n      * <p>To change the style of a cell without affecting other cells that use the same style,\n-     * use {@link org.apache.poi.ss.util.CellUtil#setCellStyleProperties(org.apache.poi.ss.usermodel.Cell, Map)}</p>\n+     * use {@link org.apache.poi.ss.util.CellUtil#setCellStyleProperties(org.apache.poi.ss.usermodel.Cell, java.util.Map)}</p>\n      *\n      * @param style  reference contained in the workbook\n      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#createCellStyle()",
                "raw_url": "https://github.com/apache/poi/raw/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "sha": "e31f2f5808185fe1f361616ce6c06d364975af51",
                "status": "modified"
            },
            {
                "additions": 24,
                "blob_url": "https://github.com/apache/poi/blob/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=2776cf6a599ebecb5d135e4e05d7fc995b46ad4a",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -2977,4 +2977,28 @@ public void test46515() throws IOException {\n \n         wb.close();\n     }\n+\n+    @Test\n+    public void test55668() throws IOException {\n+        Workbook wb = HSSFTestDataSamples.openSampleWorkbook(\"55668.xls\");\n+\n+        Sheet sheet = wb.getSheetAt(0);\n+        Row row = sheet.getRow(0);\n+        Cell cell = row.getCell(0);\n+        assertEquals(Cell.CELL_TYPE_FORMULA, cell.getCellType());\n+        assertEquals(\"IF(TRUE,\\\"\\\",\\\"\\\")\", cell.getCellFormula());\n+        assertEquals(\"\", cell.getStringCellValue());\n+        cell.setCellType(Cell.CELL_TYPE_STRING);\n+\n+        assertEquals(Cell.CELL_TYPE_BLANK, cell.getCellType());\n+        try {\n+            assertNull(cell.getCellFormula());\n+            fail(\"Should throw an exception here\");\n+        } catch (IllegalStateException e) {\n+            // expected here\n+        }\n+        assertEquals(\"\", cell.getStringCellValue());\n+\n+        wb.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "7cc9b4ea59508cec275a59ce23889c07ea2615a3",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a/test-data/spreadsheet/55668.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/55668.xls?ref=2776cf6a599ebecb5d135e4e05d7fc995b46ad4a",
                "deletions": 0,
                "filename": "test-data/spreadsheet/55668.xls",
                "raw_url": "https://github.com/apache/poi/raw/2776cf6a599ebecb5d135e4e05d7fc995b46ad4a/test-data/spreadsheet/55668.xls",
                "sha": "8aa8f5042767b04d4162e8c2cd7c6b96e6831366",
                "status": "added"
            }
        ],
        "message": "Bug 55668: Try to avoid NullPointerException when chaning cell type and formula leads to null-string by seting the cell to BLANK instead\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1734861 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/61a7e000fed8fea71d8f7441676fcf9c703f8c67",
        "patched_files": [
            "HSSFCell.java",
            "55668.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHSSFCell.java",
            "TestBugs.java"
        ]
    },
    "poi_27832ad": {
        "bug_id": "poi_27832ad",
        "commit": "https://github.com/apache/poi/commit/27832ad35675cab8492cb702b952e2636560ea31",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/27832ad35675cab8492cb702b952e2636560ea31/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=27832ad35675cab8492cb702b952e2636560ea31",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -33,6 +33,7 @@\n \n     <changes>\n         <release version=\"3.5-beta7\" date=\"2009-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">47460 - Fixed NPE when retrieving core properties from a newly created workbook</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47498 - Fixed HyperlinkRecord to properly handle URL monikers</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47504 - Fixed XSSFWorkbook to read files with hyperlinks to document locations</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47479 - Fix BoolErrRecord to tolerate incorrect format written by OOO</action>",
                "raw_url": "https://github.com/apache/poi/raw/27832ad35675cab8492cb702b952e2636560ea31/src/documentation/content/xdocs/status.xml",
                "sha": "79993d965f13ebde04f4b37848126307676eeb48",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/27832ad35675cab8492cb702b952e2636560ea31/src/ooxml/java/org/apache/poi/POIXMLProperties.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/POIXMLProperties.java?ref=27832ad35675cab8492cb702b952e2636560ea31",
                "deletions": 8,
                "filename": "src/ooxml/java/org/apache/poi/POIXMLProperties.java",
                "patch": "@@ -38,14 +38,7 @@ public POIXMLProperties(OPCPackage docPackage) throws IOException, OpenXML4JExce\n \t\tthis.pkg = docPackage;\n \t\t\n \t\t// Core properties\n-\t\tPackageRelationshipCollection coreRel =\n-\t\t\tpkg.getRelationshipsByType(POIXMLDocument.CORE_PROPERTIES_REL_TYPE);\n-\t\tif(coreRel.size() == 1) {\n-\t\t\tcore = new CoreProperties( (PackagePropertiesPart)\n-\t\t\t\t\tpkg.getPart(coreRel.getRelationship(0)) );\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\"A document must always have core properties defined!\");\n-\t\t}\n+        core = new CoreProperties((PackagePropertiesPart)pkg.getPackageProperties() );\n \t\t\n \t\t// Extended properties\n \t\tPackageRelationshipCollection extRel =",
                "raw_url": "https://github.com/apache/poi/raw/27832ad35675cab8492cb702b952e2636560ea31/src/ooxml/java/org/apache/poi/POIXMLProperties.java",
                "sha": "9729309bcd28c791fe7906d9900508fe78adbb7f",
                "status": "modified"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/poi/blob/27832ad35675cab8492cb702b952e2636560ea31/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java?ref=27832ad35675cab8492cb702b952e2636560ea31",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "patch": "@@ -33,7 +33,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.openxml4j.opc.OPCPackage;\n import org.apache.poi.openxml4j.opc.PackagePart;\n import org.apache.poi.openxml4j.opc.PackagingURIHelper;\n+import org.apache.poi.openxml4j.opc.internal.PackagePropertiesPart;\n import org.apache.poi.util.TempFile;\n+import org.apache.poi.POIXMLProperties;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTSheet;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorkbook;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorkbookPr;\n@@ -250,4 +252,27 @@ public void testIncrementSheetId() throws Exception {\n         sheetId = (int)wb.createSheet().sheet.getSheetId();\n         assertEquals(lastSheetId+1, sheetId);\n     }\n+\n+    /**\n+     *  Test setting of core properties such as Title and Author\n+     */\n+    public void testWorkbookProperties() throws Exception {\n+        XSSFWorkbook workbook = new XSSFWorkbook();\n+        POIXMLProperties props = workbook.getProperties();\n+        assertNotNull(props);\n+\n+        PackagePropertiesPart opcProps = props.getCoreProperties().getUnderlyingProperties();\n+        assertNotNull(opcProps);\n+\n+        opcProps.setTitleProperty(\"Testing Bugzilla #47460\");\n+        assertEquals(\"Apache POI\", opcProps.getCreatorProperty().getValue());\n+        opcProps.setCreatorProperty(\"poi-dev@poi.apache.org\");\n+\n+        workbook = XSSFTestDataSamples.writeOutAndReadBack(workbook);\n+        opcProps = workbook.getProperties().getCoreProperties().getUnderlyingProperties();\n+        assertEquals(\"Testing Bugzilla #47460\", opcProps.getTitleProperty().getValue());\n+        assertEquals(\"poi-dev@poi.apache.org\", opcProps.getCreatorProperty().getValue());\n+\n+\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/27832ad35675cab8492cb702b952e2636560ea31/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "sha": "6c48e2fb164f4f693fc58763eee3ade5a8454783",
                "status": "modified"
            }
        ],
        "message": "Fixed NPE when retrieving core properties from a newly created workbook, see Bugzilla 47460\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@793291 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/35c4438666b32e4a6579c2e525df66e24818fb81",
        "patched_files": [
            "XSSFWorkbook.java",
            "status.java",
            "POIXMLProperties.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFWorkbook.java",
            "TestPOIXMLProperties.java"
        ]
    },
    "poi_27ece8b": {
        "bug_id": "poi_27ece8b",
        "commit": "https://github.com/apache/poi/commit/27ece8b0480048de716c740f5ef6222aa482c9f1",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/27ece8b0480048de716c740f5ef6222aa482c9f1/src/scratchpad/src/org/apache/poi/hwpf/converter/AbstractWordUtils.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/converter/AbstractWordUtils.java?ref=27ece8b0480048de716c740f5ef6222aa482c9f1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/converter/AbstractWordUtils.java",
                "patch": "@@ -232,7 +232,7 @@ public static String getBulletText( ListTables listTables,\n         final ListLevel listLevel = listTables.getLevel( listId,\n                 paragraph.getIlvl() );\n \n-        if ( listLevel.getNumberText() == null )\n+        if ( listLevel==null || listLevel.getNumberText() == null )\n             return EMPTY;\n \n         StringBuffer bulletBuffer = new StringBuffer();",
                "raw_url": "https://github.com/apache/poi/raw/27ece8b0480048de716c740f5ef6222aa482c9f1/src/scratchpad/src/org/apache/poi/hwpf/converter/AbstractWordUtils.java",
                "sha": "710ca2453d5f20c8bf794afce10b07208001bec5",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/27ece8b0480048de716c740f5ef6222aa482c9f1/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Paragraph.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Paragraph.java?ref=27ece8b0480048de716c740f5ef6222aa482c9f1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/usermodel/Paragraph.java",
                "patch": "@@ -110,7 +110,7 @@ static Paragraph newParagraph( Range parent, PAPX papx )\n             final ListLevel listLevel = listTables.getLevel(\n                     listFormatOverride.getLsid(), properties.getIlvl() );\n \n-            if ( listLevel.getGrpprlPapx() != null )\n+            if ( listLevel!=null && listLevel.getGrpprlPapx() != null )\n             {\n                 properties = ParagraphSprmUncompressor.uncompressPAP(\n                         properties, listLevel.getGrpprlPapx(), 0 );",
                "raw_url": "https://github.com/apache/poi/raw/27ece8b0480048de716c740f5ef6222aa482c9f1/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Paragraph.java",
                "sha": "6d99465abcdb34dfb76b17b926718241bf9f3a93",
                "status": "modified"
            }
        ],
        "message": "HWPF: fix NPE when reading paragraph properties\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1305810 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1a307270bfcfdc776e75ef6b994d90ee48cdffb8",
        "patched_files": [
            "AbstractWordUtils.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "AbstractWordUtilsTest.java"
        ]
    },
    "poi_2809a55": {
        "bug_id": "poi_2809a55",
        "commit": "https://github.com/apache/poi/commit/2809a55dd3afe83dd6d62d13cf588c9e3463d818",
        "file": [
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/2809a55dd3afe83dd6d62d13cf588c9e3463d818/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFHyperlink.java",
                "changes": 28,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFHyperlink.java?ref=2809a55dd3afe83dd6d62d13cf588c9e3463d818",
                "deletions": 14,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFHyperlink.java",
                "patch": "@@ -25,7 +25,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.ss.util.CellReference;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTHyperlink;\n \n-\n /**\n  * XSSF Implementation of a Hyperlink.\n  * Note - unlike with HSSF, many kinds of hyperlink\n@@ -223,9 +222,16 @@ private void validate(String address) {\n     protected void setCellReference(String ref) {\n         _ctHyperlink.setRef(ref);\n     }\n+    protected void setCellReference(CellReference ref) {\n+        setCellReference(ref.formatAsString());\n+    }\n \n     private CellReference buildCellReference() {\n-        return new CellReference(_ctHyperlink.getRef());\n+        String ref = _ctHyperlink.getRef();\n+        if (ref == null) {\n+            ref = \"A1\";\n+        }\n+        return new CellReference(ref);\n     }\n \n \n@@ -273,15 +279,12 @@ public int getLastRow() {\n      * @param col the 0-based column of the first cell that contains the hyperlink\n      */\n     public void setFirstColumn(int col) {\n-        _ctHyperlink.setRef(\n-                new CellReference(\n-                        getFirstRow(), col\n-                ).formatAsString()\n-        );\n+        setCellReference(new CellReference( getFirstRow(), col ));\n     }\n \n     /**\n-     * Set the column of the last cell that contains the hyperlink\n+     * Set the column of the last cell that contains the hyperlink.\n+     * For XSSF, a Hyperlink may only reference one cell\n      *\n      * @param col the 0-based column of the last cell that contains the hyperlink\n      */\n@@ -295,15 +298,12 @@ public void setLastColumn(int col) {\n      * @param row the 0-based row of the first cell that contains the hyperlink\n      */\n     public void setFirstRow(int row) {\n-        _ctHyperlink.setRef(\n-                new CellReference(\n-                        row, getFirstColumn()\n-                ).formatAsString()\n-        );\n+        setCellReference(new CellReference( row, getFirstColumn() ));\n     }\n \n     /**\n-     * Set the row of the last cell that contains the hyperlink\n+     * Set the row of the last cell that contains the hyperlink.\n+     * For XSSF, a Hyperlink may only reference one cell\n      *\n      * @param row the 0-based row of the last cell that contains the hyperlink\n      */",
                "raw_url": "https://github.com/apache/poi/raw/2809a55dd3afe83dd6d62d13cf588c9e3463d818/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFHyperlink.java",
                "sha": "86538fd6812734cae54bd7a8b7749664e76fb235",
                "status": "modified"
            },
            {
                "additions": 57,
                "blob_url": "https://github.com/apache/poi/blob/2809a55dd3afe83dd6d62d13cf588c9e3463d818/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "changes": 59,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java?ref=2809a55dd3afe83dd6d62d13cf588c9e3463d818",
                "deletions": 2,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "patch": "@@ -18,7 +18,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n package org.apache.poi.xssf.usermodel;\n \n import static org.hamcrest.core.IsEqual.equalTo;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n@@ -44,7 +50,26 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.ss.formula.eval.NumberEval;\n import org.apache.poi.ss.formula.eval.ValueEval;\n import org.apache.poi.ss.formula.functions.Function;\n-import org.apache.poi.ss.usermodel.*;\n+import org.apache.poi.ss.usermodel.BaseTestBugzillaIssues;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.CellStyle;\n+import org.apache.poi.ss.usermodel.CellValue;\n+import org.apache.poi.ss.usermodel.ClientAnchor;\n+import org.apache.poi.ss.usermodel.Comment;\n+import org.apache.poi.ss.usermodel.CreationHelper;\n+import org.apache.poi.ss.usermodel.DataFormatter;\n+import org.apache.poi.ss.usermodel.DateUtil;\n+import org.apache.poi.ss.usermodel.Drawing;\n+import org.apache.poi.ss.usermodel.Font;\n+import org.apache.poi.ss.usermodel.FormulaError;\n+import org.apache.poi.ss.usermodel.FormulaEvaluator;\n+import org.apache.poi.ss.usermodel.Hyperlink;\n+import org.apache.poi.ss.usermodel.IndexedColors;\n+import org.apache.poi.ss.usermodel.Name;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Sheet;\n+import org.apache.poi.ss.usermodel.Workbook;\n+import org.apache.poi.ss.usermodel.WorkbookFactory;\n import org.apache.poi.ss.util.AreaReference;\n import org.apache.poi.ss.util.CellRangeAddress;\n import org.apache.poi.ss.util.CellReference;\n@@ -1761,6 +1786,36 @@ public void testBug56688_4() {\n         NumberEval eval = new NumberEval(Math.floor(excelDate));\n         checkValue(excel, eval.getStringValue() + \".0\");\n     }\n+    \n+    @Test\n+    public void testBug56527() {\n+        XSSFWorkbook wb = new XSSFWorkbook();\n+        XSSFSheet sheet = wb.createSheet();\n+        XSSFCreationHelper creationHelper = wb.getCreationHelper();\n+        XSSFHyperlink hyperlink;\n+        \n+        // Try with a cell reference\n+        hyperlink = creationHelper.createHyperlink(Hyperlink.LINK_URL);\n+        sheet.addHyperlink(hyperlink);\n+        hyperlink.setAddress(\"http://myurl\");\n+        hyperlink.setCellReference(\"B4\");\n+        assertEquals(3, hyperlink.getFirstRow());\n+        assertEquals(1, hyperlink.getFirstColumn());\n+        assertEquals(3, hyperlink.getLastRow());\n+        assertEquals(1, hyperlink.getLastColumn());\n+        \n+        // Try with explicit rows / columns\n+        hyperlink = creationHelper.createHyperlink(Hyperlink.LINK_URL);\n+        sheet.addHyperlink(hyperlink);\n+        hyperlink.setAddress(\"http://myurl\");\n+        hyperlink.setFirstRow(5);\n+        hyperlink.setFirstColumn(3);\n+        \n+        assertEquals(5, hyperlink.getFirstRow());\n+        assertEquals(3, hyperlink.getFirstColumn());\n+        assertEquals(5, hyperlink.getLastRow());\n+        assertEquals(3, hyperlink.getLastColumn());\n+    }\n \n     private void checkValue(XSSFWorkbook excel, String expect) {\n         XSSFFormulaEvaluator evaluator = new XSSFFormulaEvaluator(excel);",
                "raw_url": "https://github.com/apache/poi/raw/2809a55dd3afe83dd6d62d13cf588c9e3463d818/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "sha": "162ee4aad17785e88e8ce0556ddd1ad045f82cc9",
                "status": "modified"
            }
        ],
        "message": "Fix bug #56527 - Avoid NPE from XSSFHyperLink when setting the cell\nit references on a new link\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1614914 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/cc5a60f06176ecaa12ffe097d5b2825d98517fff",
        "patched_files": [
            "XSSFHyperlink.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFBugs.java",
            "TestXSSFHyperlink.java"
        ]
    },
    "poi_2963774": {
        "bug_id": "poi_2963774",
        "commit": "https://github.com/apache/poi/commit/2963774c3752202c0686b0223d7dfd8ae1973ca8",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/documentation/content/xdocs/changes.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -37,6 +37,8 @@\n \n \t\t<!-- Don't forget to update status.xml too! -->\n         <release version=\"3.5-beta4\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46033 - fixed TableCell to correctly set text type</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46122 - fixed Picture.draw to skip rendering if picture data was not found</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">15716 - memory usage optimisation - converted Ptg arrays into Formula objects</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">46065 - added implementation for VALUE function</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45966 - added implementation for FIND function</action>",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/documentation/content/xdocs/changes.xml",
                "sha": "eae6071b312a4d01edfab313ed1b75311e39b278",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/documentation/content/xdocs/status.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,8 @@\n \t<!-- Don't forget to update changes.xml too! -->\n     <changes>\n         <release version=\"3.5-beta4\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46033 - fixed TableCell to correctly set text type</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46122 - fixed Picture.draw to skip rendering if picture data was not found</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">15716 - memory usage optimisation - converted Ptg arrays into Formula objects</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">46065 - added implementation for VALUE function</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45966 - added implementation for FIND function</action>",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/documentation/content/xdocs/status.xml",
                "sha": "95d926bb9ac7532aa9b83597dd9228e9f32c81ec",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/model/LinkTable.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/LinkTable.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 5,
                "filename": "src/java/org/apache/poi/hssf/model/LinkTable.java",
                "patch": "@@ -29,8 +29,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hssf.record.NameRecord;\n import org.apache.poi.hssf.record.Record;\n import org.apache.poi.hssf.record.SupBookRecord;\n-import org.apache.poi.hssf.record.UnicodeString;\n+import org.apache.poi.hssf.record.formula.Area3DPtg;\n import org.apache.poi.hssf.record.formula.NameXPtg;\n+import org.apache.poi.hssf.record.formula.Ref3DPtg;\n \n /**\n  * Link Table (OOO pdf reference: 4.10.3 ) <p/>\n@@ -311,10 +312,10 @@ private static boolean isSameSheetNames(NameRecord firstName, NameRecord lastNam\n \t\t\treturn null;\n \t\t}\n \t\tint shIx = _externSheetRecord.getFirstSheetIndexFromRefIndex(extRefIndex);\n-\t\tUnicodeString usSheetName = ebr.getSheetNames()[shIx];\n+\t\tString usSheetName = ebr.getSheetNames()[shIx];\n \t\treturn new String[] {\n \t\t\t\tebr.getURL(),\n-\t\t\t\tusSheetName.getString(),\n+\t\t\t\tusSheetName,\n \t\t};\n \t}\n \n@@ -345,9 +346,9 @@ public int getExternalSheetIndex(String workbookName, String sheetName) {\n \t\treturn result;\n \t}\n \n-\tprivate static int getSheetIndex(UnicodeString[] sheetNames, String sheetName) {\n+\tprivate static int getSheetIndex(String[] sheetNames, String sheetName) {\n \t\tfor (int i = 0; i < sheetNames.length; i++) {\n-\t\t\tif (sheetNames[i].getString().equals(sheetName)) {\n+\t\t\tif (sheetNames[i].equals(sheetName)) {\n \t\t\t\treturn i;\n \t\t\t}\n \t\t\t",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/model/LinkTable.java",
                "sha": "f587f5e375c478b416b79f9b26d91aad2df995c9",
                "status": "modified"
            },
            {
                "additions": 125,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/DrawingSelectionRecord.java",
                "changes": 146,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/DrawingSelectionRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 21,
                "filename": "src/java/org/apache/poi/hssf/record/DrawingSelectionRecord.java",
                "patch": "@@ -17,25 +17,129 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n-public final class DrawingSelectionRecord extends AbstractEscherHolderRecord {\n-    public static final short sid = 0xED;\n-\n-    public DrawingSelectionRecord()\n-    {\n-    }\n-\n-    public DrawingSelectionRecord( RecordInputStream in )\n-    {\n-        super( in );\n-    }\n-\n-    protected String getRecordName()\n-    {\n-        return \"MSODRAWINGSELECTION\";\n-    }\n-\n-    public short getSid()\n-    {\n-        return sid;\n-    }\n+import org.apache.poi.util.HexDump;\n+import org.apache.poi.util.LittleEndianByteArrayOutputStream;\n+import org.apache.poi.util.LittleEndianInput;\n+import org.apache.poi.util.LittleEndianOutput;\n+\n+/**\n+ * MsoDrawingSelection (0x00ED)<p/>\n+ * Reference:\n+ * [MS-OGRAPH].pdf sec 2.4.69\n+ * \n+ * @author Josh Micich\n+ */\n+public final class DrawingSelectionRecord extends Record {\n+\tpublic static final short sid = 0x00ED;\n+\n+\t/**\n+\t * From [MS-ODRAW].pdf sec 2.2.1<br/>\n+\t * TODO - make EscherRecordHeader {@link LittleEndianInput} aware and refactor with this\n+\t */\n+\tprivate static final class OfficeArtRecordHeader {\n+\t\tpublic static final int ENCODED_SIZE = 8;\n+\t\t/**\n+\t\t * lower 4 bits is 'version' usually 0x01 or 0x0F (for containers)<br/>\n+\t\t * upper 12 bits is 'instance'\n+\t\t */\n+\t\tprivate final int _verAndInstance;\n+\t\t/** value should be between 0xF000 and 0xFFFF */\n+\t\tprivate final int _type;\n+\t\tprivate final int _length;\n+\n+\t\tpublic OfficeArtRecordHeader(LittleEndianInput in) {\n+\t\t\t_verAndInstance = in.readUShort();\n+\t\t\t_type = in.readUShort();\n+\t\t\t_length = in.readInt();\n+\t\t}\n+\n+\t\tpublic void serialize(LittleEndianOutput out) {\n+\t\t\tout.writeShort(_verAndInstance);\n+\t\t\tout.writeShort(_type);\n+\t\t\tout.writeInt(_length);\n+\t\t}\n+\n+\t\tpublic String debugFormatAsString() {\n+\t\t\tStringBuffer sb = new StringBuffer(32);\n+\t\t\tsb.append(\"ver+inst=\").append(HexDump.shortToHex(_verAndInstance));\n+\t\t\tsb.append(\" type=\").append(HexDump.shortToHex(_type));\n+\t\t\tsb.append(\" len=\").append(HexDump.intToHex(_length));\n+\t\t\treturn sb.toString();\n+\t\t}\n+\t}\n+\n+\t// [MS-OGRAPH].pdf says that the data of this record is an OfficeArtFDGSL structure\n+\t// as described in[MS-ODRAW].pdf sec 2.2.33\n+\tprivate OfficeArtRecordHeader _header;\n+\tprivate int _cpsp;\n+\t/** a MSODGSLK enum value for the current selection mode */\n+\tprivate int _dgslk;\n+\tprivate int _spidFocus;\n+\t/** selected shape IDs (e.g. from EscherSpRecord.ShapeId) */\n+\tprivate int[] _shapeIds;\n+\n+\tpublic DrawingSelectionRecord(RecordInputStream in) {\n+\t\t_header = new OfficeArtRecordHeader(in);\n+\t\t_cpsp = in.readInt();\n+\t\t_dgslk = in.readInt();\n+\t\t_spidFocus = in.readInt();\n+\t\tint nShapes = in.available() / 4;\n+\t\tint[] shapeIds = new int[nShapes];\n+\t\tfor (int i = 0; i < nShapes; i++) {\n+\t\t\tshapeIds[i] = in.readInt();\n+\t\t}\n+\t\t_shapeIds = shapeIds;\n+\t}\n+\n+\tpublic short getSid() {\n+\t\treturn sid;\n+\t}\n+\n+\tprotected int getDataSize() {\n+\t\treturn OfficeArtRecordHeader.ENCODED_SIZE \n+\t\t\t+ 12 // 3 int fields\n+\t\t\t+ _shapeIds.length * 4;\n+\t}\n+\n+\tpublic int serialize(int offset, byte[] data) {\n+\t\tint dataSize = getDataSize();\n+\t\tint recSize = 4 + dataSize;\n+\t\tLittleEndianOutput out = new LittleEndianByteArrayOutputStream(data, offset, recSize);\n+\t\tout.writeShort(sid);\n+\t\tout.writeShort(dataSize);\n+\t\t_header.serialize(out);\n+\t\tout.writeInt(_cpsp);\n+\t\tout.writeInt(_dgslk);\n+\t\tout.writeInt(_spidFocus);\n+\t\tfor (int i = 0; i < _shapeIds.length; i++) {\n+\t\t\tout.writeInt(_shapeIds[i]);\n+\t\t}\n+\t\treturn recSize;\n+\t}\n+\n+\tpublic Object clone() {\n+\t\t// currently immutable\n+\t\treturn this;\n+\t}\n+\n+\tpublic String toString() {\n+\t\tStringBuffer sb = new StringBuffer();\n+\n+\t\tsb.append(\"[MSODRAWINGSELECTION]\\n\");\n+\t\tsb.append(\"    .rh       =(\").append(_header.debugFormatAsString()).append(\")\\n\");\n+\t\tsb.append(\"    .cpsp     =\").append(HexDump.intToHex(_cpsp)).append('\\n');\n+\t\tsb.append(\"    .dgslk    =\").append(HexDump.intToHex(_dgslk)).append('\\n');\n+\t\tsb.append(\"    .spidFocus=\").append(HexDump.intToHex(_spidFocus)).append('\\n');\n+\t\tsb.append(\"    .shapeIds =(\");\n+\t\tfor (int i = 0; i < _shapeIds.length; i++) {\n+\t\t\tif (i > 0) {\n+\t\t\t\tsb.append(\", \");\n+\t\t\t}\n+\t\t\tsb.append(HexDump.intToHex(_shapeIds[i]));\n+\t\t}\n+\t\tsb.append(\")\\n\");\n+\n+\t\tsb.append(\"[/MSODRAWINGSELECTION]\\n\");\n+\t\treturn sb.toString();\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/DrawingSelectionRecord.java",
                "sha": "85997e91390e84b74f1648a1d27fadd43479ba99",
                "status": "modified"
            },
            {
                "additions": 85,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/RecordFactory.java",
                "changes": 141,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/RecordFactory.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 56,
                "filename": "src/java/org/apache/poi/hssf/record/RecordFactory.java",
                "patch": "@@ -49,7 +49,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t * contains the classes for all the records we want to parse.<br/>\n \t * Note - this most but not *every* subclass of Record.\n \t */\n-\tprivate static final Class[] records = {\n+\tprivate static final Class[] recordClasses = {\n \t\tArrayRecord.class,\n \t\tBackupRecord.class,\n \t\tBlankRecord.class,\n@@ -163,7 +163,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t/**\n \t * cache of the recordsToMap();\n \t */\n-\tprivate static Map recordsMap  = recordsToMap(records);\n+\tprivate static Map recordsMap  = recordsToMap(recordClasses);\n \n \tprivate static short[] _allKnownRecordSIDs;\n \t\n@@ -172,16 +172,33 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t * are returned digested into the non-mul form.\n \t */\n \tpublic static Record [] createRecord(RecordInputStream in) {\n+\t\t\n+\t\tRecord record = createSingleRecord(in);\n+\t\tif (record instanceof DBCellRecord) {\n+\t\t\t// Not needed by POI.  Regenerated from scratch by POI when spreadsheet is written\n+\t\t\treturn new Record[] { null, };\n+\t\t}\n+\t\tif (record instanceof RKRecord) {\n+\t\t\treturn new Record[] { convertToNumberRecord((RKRecord) record), };\n+\t\t}\n+\t\tif (record instanceof MulRKRecord) {\n+\t\t\treturn convertRKRecords((MulRKRecord)record);\n+\t\t}\n+\t\tif (record instanceof MulBlankRecord) {\n+\t\t\treturn convertMulBlankRecords((MulBlankRecord)record);\n+\t\t}\n+\t\treturn new Record[] { record, };\n+\t}\n+\t\n+\tprivate static Record createSingleRecord(RecordInputStream in) {\n \t\tConstructor constructor = (Constructor) recordsMap.get(new Short(in.getSid()));\n \n \t\tif (constructor == null) {\n-\t\t\treturn new Record[] { new UnknownRecord(in), };\n+\t\t\treturn new UnknownRecord(in);\n \t\t}\n \t\t\n-\t\tRecord retval;\n-\n \t\ttry {\n-\t\t\tretval = ( Record ) constructor.newInstance(new Object[] { in });\n+\t\t\treturn (Record) constructor.newInstance(new Object[] { in });\n \t\t} catch (InvocationTargetException e) {\n \t\t\tthrow new RecordFormatException(\"Unable to construct record instance\" , e.getTargetException());\n \t\t} catch (IllegalArgumentException e) {\n@@ -191,54 +208,55 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t\t} catch (IllegalAccessException e) {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n-\t\t\n-\t\tif (retval instanceof RKRecord) {\n-\t\t\t// RK record is a slightly smaller alternative to NumberRecord\n-\t\t\t// POI likes NumberRecord better\n-\t\t\tRKRecord\t rk  = ( RKRecord ) retval;\n-\t\t\tNumberRecord num = new NumberRecord();\n+\t}\n \n-\t\t\tnum.setColumn(rk.getColumn());\n-\t\t\tnum.setRow(rk.getRow());\n-\t\t\tnum.setXFIndex(rk.getXFIndex());\n-\t\t\tnum.setValue(rk.getRKNumber());\n-\t\t\treturn new Record[] { num, };\n-\t\t}\n-\t\tif (retval instanceof DBCellRecord) {\n-\t\t\t// Not needed by POI.  Regenerated from scratch by POI when spreadsheet is written\n-\t\t\treturn new Record[] { null, };\n-\t\t}\n-\t\t// expand multiple records where necessary\n-\t\tif (retval instanceof MulRKRecord) {\n-\t\t\tMulRKRecord mrk = ( MulRKRecord ) retval;\n+\t/**\n+\t * RK record is a slightly smaller alternative to NumberRecord\n+\t * POI likes NumberRecord better\n+\t */\n+\tprivate static NumberRecord convertToNumberRecord(RKRecord rk) {\n+\t\tNumberRecord num = new NumberRecord();\n+\n+\t\tnum.setColumn(rk.getColumn());\n+\t\tnum.setRow(rk.getRow());\n+\t\tnum.setXFIndex(rk.getXFIndex());\n+\t\tnum.setValue(rk.getRKNumber());\n+\t\treturn num;\n+\t}\n \n-\t\t\tRecord[] mulRecs = new Record[ mrk.getNumColumns() ];\n-\t\t\tfor (int k = 0; k < mrk.getNumColumns(); k++) {\n-\t\t\t\tNumberRecord nr = new NumberRecord();\n+\t/**\n+\t * Converts a {@link MulRKRecord} into an equivalent array of {@link NumberRecord}s\n+\t */\n+\tprivate static NumberRecord[] convertRKRecords(MulRKRecord mrk) {\n \n-\t\t\t\tnr.setColumn(( short ) (k + mrk.getFirstColumn()));\n-\t\t\t\tnr.setRow(mrk.getRow());\n-\t\t\t\tnr.setXFIndex(mrk.getXFAt(k));\n-\t\t\t\tnr.setValue(mrk.getRKNumberAt(k));\n-\t\t\t\tmulRecs[ k ] = nr;\n-\t\t\t}\n-\t\t\treturn mulRecs;\n+\t\tNumberRecord[] mulRecs = new NumberRecord[mrk.getNumColumns()];\n+\t\tfor (int k = 0; k < mrk.getNumColumns(); k++) {\n+\t\t\tNumberRecord nr = new NumberRecord();\n+\n+\t\t\tnr.setColumn((short) (k + mrk.getFirstColumn()));\n+\t\t\tnr.setRow(mrk.getRow());\n+\t\t\tnr.setXFIndex(mrk.getXFAt(k));\n+\t\t\tnr.setValue(mrk.getRKNumberAt(k));\n+\t\t\tmulRecs[k] = nr;\n \t\t}\n-\t\tif (retval instanceof MulBlankRecord) {\n-\t\t\tMulBlankRecord mb = ( MulBlankRecord ) retval;\n+\t\treturn mulRecs;\n+\t}\n \n-\t\t\tRecord[] mulRecs = new Record[ mb.getNumColumns() ];\n-\t\t\tfor (int k = 0; k < mb.getNumColumns(); k++) {\n-\t\t\t\tBlankRecord br = new BlankRecord();\n+\t/**\n+\t * Converts a {@link MulBlankRecord} into an equivalent array of {@link BlankRecord}s\n+\t */\n+\tprivate static BlankRecord[] convertMulBlankRecords(MulBlankRecord mb) {\n \n-\t\t\t\tbr.setColumn(( short ) (k + mb.getFirstColumn()));\n-\t\t\t\tbr.setRow(mb.getRow());\n-\t\t\t\tbr.setXFIndex(mb.getXFAt(k));\n-\t\t\t\tmulRecs[ k ] = br;\n-\t\t\t}\n-\t\t\treturn mulRecs;\n+\t\tBlankRecord[] mulRecs = new BlankRecord[mb.getNumColumns()];\n+\t\tfor (int k = 0; k < mb.getNumColumns(); k++) {\n+\t\t\tBlankRecord br = new BlankRecord();\n+\n+\t\t\tbr.setColumn((short) (k + mb.getFirstColumn()));\n+\t\t\tbr.setRow(mb.getRow());\n+\t\t\tbr.setXFIndex(mb.getXFAt(k));\n+\t\t\tmulRecs[k] = br;\n \t\t}\n-\t\treturn new Record[] { retval, };\n+\t\treturn mulRecs;\n \t}\n \n \t/**\n@@ -325,19 +343,26 @@ public static List createRecords(InputStream in) throws RecordFormatException {\n \t\t\t\t// After EOF, Excel seems to pad block with zeros\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tRecord[] recs = createRecord(recStream);   // handle MulRK records\n+\t\t\tRecord record = createSingleRecord(recStream);\n \n-\t\t\tif (recs.length > 1) {\n-\t\t\t\tfor (int k = 0; k < recs.length; k++) {\n-\t\t\t\t\trecords.add(recs[ k ]);\t\t\t   // these will be number records\n-\t\t\t\t}\n+\t\t\tif (record instanceof DBCellRecord) {\n+\t\t\t\t// Not needed by POI.  Regenerated from scratch by POI when spreadsheet is written\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tRecord record = recs[ 0 ];\n \n-\t\t\tif (record == null) {\n+\t\t\tif (record instanceof RKRecord) {\n+\t\t\t\trecords.add(convertToNumberRecord((RKRecord) record));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (record instanceof MulRKRecord) {\n+\t\t\t\taddAll(records, convertRKRecords((MulRKRecord)record));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (record instanceof MulBlankRecord) {\n+\t\t\t\taddAll(records, convertMulBlankRecords((MulBlankRecord)record));\n \t\t\t\tcontinue;\n \t\t\t}\n+\n \t\t\tif (record.getSid() == DrawingGroupRecord.sid\n \t\t\t\t   && lastRecord instanceof DrawingGroupRecord) {\n \t\t\t\tDrawingGroupRecord lastDGRecord = (DrawingGroupRecord) lastRecord;\n@@ -354,8 +379,6 @@ public static List createRecords(InputStream in) throws RecordFormatException {\n \t\t\t\t\trecords.add(record);\n \t\t\t\t} else if (lastRecord instanceof DrawingGroupRecord) {\n \t\t\t\t\t((DrawingGroupRecord)lastRecord).processContinueRecord(contRec.getData());\n-\t\t\t\t} else if (lastRecord instanceof StringRecord) {\n-\t\t\t\t\t((StringRecord)lastRecord).processContinueRecord(contRec.getData());\n \t\t\t\t} else if (lastRecord instanceof UnknownRecord) {\n \t\t\t\t\t//Gracefully handle records that we don't know about,\n \t\t\t\t\t//that happen to be continued\n@@ -373,4 +396,10 @@ public static List createRecords(InputStream in) throws RecordFormatException {\n \t\t}\n \t\treturn records;\n \t}\n+\n+\tprivate static void addAll(List destList, Record[] srcRecs) {\n+\t\tfor (int i = 0; i < srcRecs.length; i++) {\n+\t\t\tdestList.add(srcRecs[i]);\n+\t\t}\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/RecordFactory.java",
                "sha": "bae867e51260607d2893a5fe2fe29dc258d8e1fa",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/RecordInputStream.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/RecordInputStream.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 10,
                "filename": "src/java/org/apache/poi/hssf/record/RecordInputStream.java",
                "patch": "@@ -320,16 +320,6 @@ private String readStringCommon(int requestedLength, boolean pIsCompressedEncodi\n \t\t}\n \t}\n \n-  /** Returns an excel style unicode string from the bytes reminaing in the record.\n-   * <i>Note:</i> Unicode strings differ from <b>normal</b> strings due to the addition of\n-   * formatting information.\n-   *\n-   * @return The unicode string representation of the remaining bytes.\n-   */\n-  public UnicodeString readUnicodeString() {\n-    return new UnicodeString(this);\n-  }\n-\n \t/** Returns the remaining bytes for the current record.\n \t *\n \t  * @return The remaining bytes of the current record.",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/RecordInputStream.java",
                "sha": "2f275ed9283385fa8cd4e3623ce5f5176fe07a9d",
                "status": "modified"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/SSTRecord.java",
                "changes": 89,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/SSTRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 74,
                "filename": "src/java/org/apache/poi/hssf/record/SSTRecord.java",
                "patch": "@@ -17,14 +17,16 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n+import java.util.Iterator;\n+\n+import org.apache.poi.hssf.record.cont.ContinuableRecord;\n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n import org.apache.poi.util.IntMapper;\n import org.apache.poi.util.LittleEndianConsts;\n \n-import java.util.Iterator;\n-\n /**\n- * Title:        Static String Table Record\n- * <P>\n+ * Title:        Static String Table Record (0x00FC)<p/>\n+ *\n  * Description:  This holds all the strings for LabelSSTRecords.\n  * <P>\n  * REFERENCE:    PG 389 Microsoft Excel 97 Developer's Kit (ISBN:\n@@ -37,27 +39,20 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @see org.apache.poi.hssf.record.LabelSSTRecord\n  * @see org.apache.poi.hssf.record.ContinueRecord\n  */\n-public final class SSTRecord extends Record {\n+public final class SSTRecord extends ContinuableRecord {\n     public static final short sid = 0x00FC;\n \n-      private static UnicodeString EMPTY_STRING = new UnicodeString(\"\");\n-\n-    /** how big can an SST record be? As big as any record can be: 8228 bytes */\n-    static final int MAX_RECORD_SIZE = 8228;\n+    private static final UnicodeString EMPTY_STRING = new UnicodeString(\"\");\n \n+    // TODO - move these constants to test class (the only consumer)\n     /** standard record overhead: two shorts (record id plus data space size)*/\n-    static final int STD_RECORD_OVERHEAD =\n-            2 * LittleEndianConsts.SHORT_SIZE;\n+    static final int STD_RECORD_OVERHEAD = 2 * LittleEndianConsts.SHORT_SIZE;\n \n     /** SST overhead: the standard record overhead, plus the number of strings and the number of unique strings -- two ints */\n-    static final int SST_RECORD_OVERHEAD =\n-            ( STD_RECORD_OVERHEAD + ( 2 * LittleEndianConsts.INT_SIZE ) );\n+    static final int SST_RECORD_OVERHEAD = STD_RECORD_OVERHEAD + 2 * LittleEndianConsts.INT_SIZE;\n \n     /** how much data can we stuff into an SST record? That would be _max minus the standard SST record overhead */\n-    static final int MAX_DATA_SPACE = MAX_RECORD_SIZE - SST_RECORD_OVERHEAD;\n-\n-    /** overhead for each string includes the string's character count (a short) and the flag describing its characteristics (a byte) */\n-    static final int STRING_MINIMAL_OVERHEAD = LittleEndianConsts.SHORT_SIZE + LittleEndianConsts.BYTE_SIZE;\n+    static final int MAX_DATA_SPACE = RecordInputStream.MAX_RECORD_DATA_SIZE - 8;\n \n     /** union of strings in the SST and EXTSST */\n     private int field_1_num_strings;\n@@ -133,37 +128,6 @@ public int getNumUniqueStrings()\n         return field_2_num_unique_strings;\n     }\n \n-    /**\n-     * USE THIS METHOD AT YOUR OWN PERIL: THE <code>addString</code>\n-     * METHODS MANIPULATE THE NUMBER OF STRINGS AS A SIDE EFFECT; YOUR\n-     * ATTEMPTS AT MANIPULATING THE STRING COUNT IS LIKELY TO BE VERY\n-     * WRONG AND WILL RESULT IN BAD BEHAVIOR WHEN THIS RECORD IS\n-     * WRITTEN OUT AND ANOTHER PROCESS ATTEMPTS TO READ THE RECORD\n-     *\n-     * @param count  number of strings\n-     *\n-     */\n-\n-    public void setNumStrings( final int count )\n-    {\n-        field_1_num_strings = count;\n-    }\n-\n-    /**\n-     * USE THIS METHOD AT YOUR OWN PERIL: THE <code>addString</code>\n-     * METHODS MANIPULATE THE NUMBER OF UNIQUE STRINGS AS A SIDE\n-     * EFFECT; YOUR ATTEMPTS AT MANIPULATING THE UNIQUE STRING COUNT\n-     * IS LIKELY TO BE VERY WRONG AND WILL RESULT IN BAD BEHAVIOR WHEN\n-     * THIS RECORD IS WRITTEN OUT AND ANOTHER PROCESS ATTEMPTS TO READ\n-     * THE RECORD\n-     *\n-     * @param count  number of strings\n-     */\n-\n-    public void setNumUniqueStrings( final int count )\n-    {\n-        field_2_num_unique_strings = count;\n-    }\n \n     /**\n      * Get a particular string by its index\n@@ -178,11 +142,6 @@ public UnicodeString getString( final int id )\n         return (UnicodeString) field_3_strings.get( id );\n     }\n \n-    public boolean isString16bit( final int id )\n-    {\n-        UnicodeString unicodeString = ( (UnicodeString) field_3_strings.get( id  ) );\n-        return ( ( unicodeString.getOptionFlags() & 0x01 ) == 1 );\n-    }\n \n     /**\n      * Return a debugging string representation\n@@ -350,29 +309,11 @@ int countStrings()\n         return field_3_strings.size();\n     }\n \n-    /**\n-     * called by the class that is responsible for writing this sucker.\n-     * Subclasses should implement this so that their data is passed back in a\n-     * byte array.\n-     *\n-     * @return size\n-     */\n-\n-    public int serialize( int offset, byte[] data )\n-    {\n-        SSTSerializer serializer = new SSTSerializer(\n-               field_3_strings, getNumStrings(), getNumUniqueStrings() );\n-        int bytes = serializer.serialize( offset, data );\n+    protected void serialize(ContinuableRecordOutput out) {\n+        SSTSerializer serializer = new SSTSerializer(field_3_strings, getNumStrings(), getNumUniqueStrings() );\n+        serializer.serialize(out);\n         bucketAbsoluteOffsets = serializer.getBucketAbsoluteOffsets();\n         bucketRelativeOffsets = serializer.getBucketRelativeOffsets();\n-        return bytes;\n-    }\n-\n-\n-    protected int getDataSize() {\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(field_3_strings);\n-        int recordSize = calculator.getRecordSize();\n-        return recordSize-4;\n     }\n \n     SSTDeserializer getDeserializer()",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/SSTRecord.java",
                "sha": "98bd075e348f44ce8b7cdd7f9690588963cc1904",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/75e352f2a073bdda52a2e3c30df63be6c71ff61d/src/java/org/apache/poi/hssf/record/SSTRecordHeader.java",
                "changes": 76,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/SSTRecordHeader.java?ref=75e352f2a073bdda52a2e3c30df63be6c71ff61d",
                "deletions": 76,
                "filename": "src/java/org/apache/poi/hssf/record/SSTRecordHeader.java",
                "patch": "@@ -1,76 +0,0 @@\n-\n-/* ====================================================================\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-==================================================================== */\n-        \n-\n-package org.apache.poi.hssf.record;\n-\n-import org.apache.poi.util.LittleEndian;\n-import org.apache.poi.util.LittleEndianConsts;\n-\n-/**\n- * Write out an SST header record.\n- *\n- * @author Glen Stampoultzis (glens at apache.org)\n- */\n-class SSTRecordHeader\n-{\n-    int numStrings;\n-    int numUniqueStrings;\n-\n-    public SSTRecordHeader( int numStrings, int numUniqueStrings )\n-    {\n-        this.numStrings = numStrings;\n-        this.numUniqueStrings = numUniqueStrings;\n-    }\n-\n-    /**\n-     * Writes out the SST record.  This consists of the sid, the record size, the number of\n-     * strings and the number of unique strings.\n-     *\n-     * @param data          The data buffer to write the header to.\n-     * @param bufferIndex   The index into the data buffer where the header should be written.\n-     * @param recSize       The number of records written.\n-     *\n-     * @return The bufer of bytes modified.\n-     */\n-    public int writeSSTHeader( UnicodeString.UnicodeRecordStats stats, byte[] data, int bufferIndex, int recSize )\n-    {\n-        int offset = bufferIndex;\n-\n-        LittleEndian.putShort( data, offset, SSTRecord.sid );\n-        offset += LittleEndianConsts.SHORT_SIZE;\n-        stats.recordSize += LittleEndianConsts.SHORT_SIZE;\n-        stats.remainingSize -= LittleEndianConsts.SHORT_SIZE;\n-        //Delay writing the length\n-        stats.lastLengthPos = offset;\n-        offset += LittleEndianConsts.SHORT_SIZE;\n-        stats.recordSize += LittleEndianConsts.SHORT_SIZE;\n-        stats.remainingSize -= LittleEndianConsts.SHORT_SIZE;\n-        LittleEndian.putInt( data, offset, numStrings );\n-        offset += LittleEndianConsts.INT_SIZE;\n-        stats.recordSize += LittleEndianConsts.INT_SIZE;\n-        stats.remainingSize -= LittleEndianConsts.INT_SIZE;\n-        LittleEndian.putInt( data, offset, numUniqueStrings );\n-        offset += LittleEndianConsts.INT_SIZE;\n-        stats.recordSize += LittleEndianConsts.INT_SIZE;\n-        stats.remainingSize -= LittleEndianConsts.INT_SIZE;\n-\n-        return offset - bufferIndex;\n-    }\n-\n-}",
                "raw_url": "https://github.com/apache/poi/raw/75e352f2a073bdda52a2e3c30df63be6c71ff61d/src/java/org/apache/poi/hssf/record/SSTRecordHeader.java",
                "sha": "e5696111f8bcd81c9b07f4670021ebe0a12b7a89",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/75e352f2a073bdda52a2e3c30df63be6c71ff61d/src/java/org/apache/poi/hssf/record/SSTRecordSizeCalculator.java",
                "changes": 51,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/SSTRecordSizeCalculator.java?ref=75e352f2a073bdda52a2e3c30df63be6c71ff61d",
                "deletions": 51,
                "filename": "src/java/org/apache/poi/hssf/record/SSTRecordSizeCalculator.java",
                "patch": "@@ -1,51 +0,0 @@\n-/* ====================================================================\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-==================================================================== */\n-        \n-\n-package org.apache.poi.hssf.record;\n-\n-import org.apache.poi.util.IntMapper;\n-\n-/**\n- * Used to calculate the record sizes for a particular record.  This kind of\n- * sucks because it's similar to the SST serialization code.  In general\n- * the SST serialization code needs to be rewritten.\n- *\n- * @author Glen Stampoultzis (glens at apache.org)\n- * @author Jason Height (jheight at apache.org)\n- */\n-class SSTRecordSizeCalculator\n-{\n-    private IntMapper strings;\n-\n-    public SSTRecordSizeCalculator(IntMapper strings)\n-    {\n-        this.strings = strings;\n-    }\n-\n-    public int getRecordSize() {\n-        UnicodeString.UnicodeRecordStats rs = new UnicodeString.UnicodeRecordStats();\n-        rs.remainingSize -= SSTRecord.SST_RECORD_OVERHEAD;\n-        rs.recordSize += SSTRecord.SST_RECORD_OVERHEAD;\n-        for (int i=0; i < strings.size(); i++ )\n-        {\n-          UnicodeString unistr = ( (UnicodeString) strings.get(i));\n-          unistr.getRecordSize(rs);\n-    }\n-        return rs.recordSize;\n-    }\n-}",
                "raw_url": "https://github.com/apache/poi/raw/75e352f2a073bdda52a2e3c30df63be6c71ff61d/src/java/org/apache/poi/hssf/record/SSTRecordSizeCalculator.java",
                "sha": "c10c21d83db877118aafa05a0447b3d5cc139d30",
                "status": "removed"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/SSTSerializer.java",
                "changes": 61,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/SSTSerializer.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 42,
                "filename": "src/java/org/apache/poi/hssf/record/SSTSerializer.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -15,84 +14,62 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.hssf.record;\n \n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n import org.apache.poi.util.IntMapper;\n-import org.apache.poi.util.LittleEndian;\n \n /**\n  * This class handles serialization of SST records.  It utilizes the record processor\n  * class write individual records. This has been refactored from the SSTRecord class.\n  *\n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n-class SSTSerializer\n-{\n+final class SSTSerializer {\n \n-    // todo: make private again\n-    private IntMapper strings;\n+\tprivate final int _numStrings;\n+\tprivate final int _numUniqueStrings;\n \n-    private SSTRecordHeader sstRecordHeader;\n+    private final IntMapper strings;\n \n     /** Offsets from the beginning of the SST record (even across continuations) */\n-    int[] bucketAbsoluteOffsets;\n+    private final int[] bucketAbsoluteOffsets;\n     /** Offsets relative the start of the current SST or continue record */\n-    int[] bucketRelativeOffsets;\n+    private final int[] bucketRelativeOffsets;\n     int startOfSST, startOfRecord;\n \n     public SSTSerializer( IntMapper strings, int numStrings, int numUniqueStrings )\n     {\n         this.strings = strings;\n-        this.sstRecordHeader = new SSTRecordHeader( numStrings, numUniqueStrings );\n+\t\t_numStrings = numStrings;\n+\t\t_numUniqueStrings = numUniqueStrings;\n \n         int infoRecs = ExtSSTRecord.getNumberOfInfoRecsForStrings(strings.size());\n         this.bucketAbsoluteOffsets = new int[infoRecs];\n         this.bucketRelativeOffsets = new int[infoRecs];\n     }\n \n-    /**\n-     * Create a byte array consisting of an SST record and any\n-     * required Continue records, ready to be written out.\n-     * <p>\n-     * If an SST record and any subsequent Continue records are read\n-     * in to create this instance, this method should produce a byte\n-     * array that is identical to the byte array produced by\n-     * concatenating the input records' data.\n-     *\n-     * @return the byte array\n-     */\n-    public int serialize(int offset, byte[] data )\n-    {\n-      UnicodeString.UnicodeRecordStats stats = new UnicodeString.UnicodeRecordStats();\n-      sstRecordHeader.writeSSTHeader( stats, data, 0 + offset, 0 );\n-      int pos = offset + SSTRecord.SST_RECORD_OVERHEAD;\n+    public void serialize(ContinuableRecordOutput out) {\n+        out.writeInt(_numStrings);\n+        out.writeInt(_numUniqueStrings);\n \n         for ( int k = 0; k < strings.size(); k++ )\n         {\n             if (k % ExtSSTRecord.DEFAULT_BUCKET_SIZE == 0)\n             {\n+                int rOff = out.getTotalSize();\n               int index = k/ExtSSTRecord.DEFAULT_BUCKET_SIZE;\n               if (index < ExtSSTRecord.MAX_BUCKETS) {\n                 //Excel only indexes the first 128 buckets.\n-              bucketAbsoluteOffsets[index] = pos-offset;\n-              bucketRelativeOffsets[index] = pos-offset;\n-              }\n+                    bucketAbsoluteOffsets[index] = rOff;\n+                    bucketRelativeOffsets[index] = rOff;\n+                }\n             }\n           UnicodeString s = getUnicodeString(k);\n-          pos += s.serialize(stats, pos, data);\n-            }\n-      //Check to see if there is a hanging continue record length\n-      if (stats.lastLengthPos != -1) {\n-        short lastRecordLength = (short)(pos - stats.lastLengthPos-2);\n-        if (lastRecordLength > 8224)\n-          throw new InternalError();\n-\n-        LittleEndian.putShort(data, stats.lastLengthPos, lastRecordLength);\n-                  }\n-      return pos - offset;\n-                }\n+          s.serialize(out);\n+        }\n+    }\n \n \n     private UnicodeString getUnicodeString( int index )",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/SSTSerializer.java",
                "sha": "78844deb3071d04bb100871392789c6af64b7377",
                "status": "modified"
            },
            {
                "additions": 29,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/StringRecord.java",
                "changes": 118,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/StringRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 89,
                "filename": "src/java/org/apache/poi/hssf/record/StringRecord.java",
                "patch": "@@ -17,19 +17,23 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n-import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.hssf.record.cont.ContinuableRecord;\n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n import org.apache.poi.util.StringUtil;\n \n /**\n- * Supports the STRING record structure. (0x0207)\n+ * STRING (0x0207)<p/>\n+ * \n+ * Stores the cached result of a text formula\n  *\n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n-public class StringRecord extends Record {\n-    public final static short   sid = 0x0207;\n-    private int                 field_1_string_length;\n-    private byte                field_2_unicode_flag;\n-    private String              field_3_string;\n+public final class StringRecord extends ContinuableRecord {\n+\n+\tpublic final static short sid = 0x0207;\n+\n+\tprivate boolean _is16bitUnicode;\n+\tprivate String _text;\n \n \n     public StringRecord()\n@@ -39,77 +43,24 @@ public StringRecord()\n     /**\n      * @param in the RecordInputstream to read the record from\n      */\n-    public StringRecord( RecordInputStream in)\n-    {\n-        field_1_string_length           = in.readShort();\n-        field_2_unicode_flag            = in.readByte();\n-        byte[] data = in.readRemainder();\n-        //Why isn't this using the in.readString methods???\n-        if (isUnCompressedUnicode())\n-        {\n-            field_3_string = StringUtil.getFromUnicodeLE(data, 0, field_1_string_length );\n-        }\n-        else\n-        {\n-            field_3_string = StringUtil.getFromCompressedUnicode(data, 0, field_1_string_length);\n+    public StringRecord( RecordInputStream in) {\n+        int field_1_string_length           = in.readUShort();\n+        _is16bitUnicode            = in.readByte() != 0x00;\n+        \n+        if (_is16bitUnicode){\n+            _text = in.readUnicodeLEString(field_1_string_length);\n+        } else {\n+            _text = in.readCompressedUnicode(field_1_string_length);\n         }\n     }\n-    \n-    public void processContinueRecord(byte[] data) {\n-    \tif(isUnCompressedUnicode()) {\n-    \t\tfield_3_string += StringUtil.getFromUnicodeLE(data, 0, field_1_string_length - field_3_string.length());\n-    \t} else {\n-    \t\tfield_3_string += StringUtil.getFromCompressedUnicode(data, 0, field_1_string_length - field_3_string.length());\n-    \t}\n-    }\n \n-    private int getStringByteLength()\n-    {\n-        return isUnCompressedUnicode() ? field_1_string_length * 2 : field_1_string_length;\n-    }\n-\n-    protected int getDataSize() {\n-        return 2 + 1 + getStringByteLength();\n-    }\n \n-    /**\n-     * is this uncompressed unicode (16bit)?  Or just 8-bit compressed?\n-     * @return isUnicode - True for 16bit- false for 8bit\n-     */\n-    public boolean isUnCompressedUnicode()\n-    {\n-        return (field_2_unicode_flag == 1);\n+    protected void serialize(ContinuableRecordOutput out) {\n+        out.writeShort(_text.length());\n+        out.writeStringData(_text);\n     }\n \n-    /**\n-     * called by the class that is responsible for writing this sucker.\n-     * Subclasses should implement this so that their data is passed back in a\n-     * byte array.\n-     *\n-     * @param offset to begin writing at\n-     * @param data byte array containing instance data\n-     * @return number of bytes written\n-     */\n-    public int serialize( int offset, byte[] data )\n-    {\n-        LittleEndian.putUShort(data, 0 + offset, sid);\n-        LittleEndian.putUShort(data, 2 + offset, 3 + getStringByteLength());\n-        LittleEndian.putUShort(data, 4 + offset, field_1_string_length);\n-        data[6 + offset] = field_2_unicode_flag;\n-        if (isUnCompressedUnicode())\n-        {\n-            StringUtil.putUnicodeLE(field_3_string, data, 7 + offset);\n-        }\n-        else\n-        {\n-            StringUtil.putCompressedUnicode(field_3_string, data, 7 + offset);\n-        }\n-        return getRecordSize();\n-    }\n \n-    /**\n-     * return the non static version of the id for this record.\n-     */\n     public short getSid()\n     {\n         return sid;\n@@ -120,26 +71,16 @@ public short getSid()\n      */\n     public String getString()\n     {\n-        return field_3_string;\n+        return _text;\n     }\n \n-    /**\n-     * Sets whether the string is compressed or not\n-     * @param unicode_flag   1 = uncompressed, 0 = compressed\n-     */\n-    public void setCompressedFlag( byte unicode_flag )\n-    {\n-        this.field_2_unicode_flag = unicode_flag;\n-    }\n \n     /**\n      * Sets the string represented by this record.\n      */\n-    public void setString( String string )\n-    {\n-        this.field_1_string_length = string.length();\n-        this.field_3_string = string;\n-        setCompressedFlag(StringUtil.hasMultibyte(string) ?  (byte)1 : (byte)0);        \n+    public void setString(String string) {\n+        _text = string;\n+        _is16bitUnicode = StringUtil.hasMultibyte(string);        \n     }\n \n     public String toString()\n@@ -148,16 +89,15 @@ public String toString()\n \n         buffer.append(\"[STRING]\\n\");\n         buffer.append(\"    .string            = \")\n-            .append(field_3_string).append(\"\\n\");\n+            .append(_text).append(\"\\n\");\n         buffer.append(\"[/STRING]\\n\");\n         return buffer.toString();\n     }\n     \n     public Object clone() {\n         StringRecord rec = new StringRecord();\n-        rec.field_1_string_length = this.field_1_string_length;\n-        rec.field_2_unicode_flag= this.field_2_unicode_flag;\n-        rec.field_3_string = this.field_3_string;\n+        rec._is16bitUnicode= _is16bitUnicode;\n+        rec._text = _text;\n         return rec;\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/StringRecord.java",
                "sha": "45322bea4bd20bd52063d2463107c08b11d86660",
                "status": "modified"
            },
            {
                "additions": 47,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/SupBookRecord.java",
                "changes": 100,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/SupBookRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 53,
                "filename": "src/java/org/apache/poi/hssf/record/SupBookRecord.java",
                "patch": "@@ -17,11 +17,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n-import org.apache.poi.hssf.record.UnicodeString.UnicodeRecordStats;\n-import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.util.LittleEndianByteArrayOutputStream;\n+import org.apache.poi.util.LittleEndianOutput;\n+import org.apache.poi.util.StringUtil;\n \n /**\n- * Title:        Sup Book (EXTERNALBOOK) <P>\n+ * Title:        Sup Book - EXTERNALBOOK (0x01AE) <p/>\n  * Description:  A External Workbook Description (Supplemental Book)\n  *               Its only a dummy record for making new ExternSheet Record <P>\n  * REFERENCE:  5.38<P>\n@@ -31,25 +32,25 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public final class SupBookRecord extends Record {\n \n-    public final static short sid = 0x1AE;\n+    public final static short sid = 0x01AE;\n \n     private static final short SMALL_RECORD_SIZE = 4;\n     private static final short TAG_INTERNAL_REFERENCES = 0x0401;\n     private static final short TAG_ADD_IN_FUNCTIONS = 0x3A01;\n \n-    private short             field_1_number_of_sheets;\n-    private UnicodeString     field_2_encoded_url;\n-    private UnicodeString[]   field_3_sheet_names;\n-    private boolean           _isAddInFunctions;\n+    private short field_1_number_of_sheets;\n+    private String field_2_encoded_url;\n+    private String[] field_3_sheet_names;\n+    private boolean _isAddInFunctions;\n+\n \n-    \n     public static SupBookRecord createInternalReferences(short numberOfSheets) {\n         return new SupBookRecord(false, numberOfSheets);\n     }\n     public static SupBookRecord createAddInFunctions() {\n         return new SupBookRecord(true, (short)0);\n     }\n-    public static SupBookRecord createExternalReferences(UnicodeString url, UnicodeString[] sheetNames) {\n+    public static SupBookRecord createExternalReferences(String url, String[] sheetNames) {\n         return new SupBookRecord(url, sheetNames);\n     }\n     private SupBookRecord(boolean isAddInFuncs, short numberOfSheets) {\n@@ -59,7 +60,7 @@ private SupBookRecord(boolean isAddInFuncs, short numberOfSheets) {\n         field_3_sheet_names = null;\n         _isAddInFunctions = isAddInFuncs;\n     }\n-    public SupBookRecord(UnicodeString url, UnicodeString[] sheetNames) {\n+    public SupBookRecord(String url, String[] sheetNames) {\n         field_1_number_of_sheets = (short) sheetNames.length;\n         field_2_encoded_url = url;\n         field_3_sheet_names = sheetNames;\n@@ -84,26 +85,26 @@ public boolean isAddInFunctions() {\n      * @param offset of the record's data (provided a big array of the file)\n      */\n     public SupBookRecord(RecordInputStream in) {\n-    \tint recLen = in.remaining();\n-    \t\n+        int recLen = in.remaining();\n+\n         field_1_number_of_sheets = in.readShort();\n-        \n+\n         if(recLen > SMALL_RECORD_SIZE) {\n             // 5.38.1 External References\n             _isAddInFunctions = false;\n \n-            field_2_encoded_url = in.readUnicodeString();\n-            UnicodeString[] sheetNames = new UnicodeString[field_1_number_of_sheets];\n+            field_2_encoded_url = in.readString();\n+            String[] sheetNames = new String[field_1_number_of_sheets];\n             for (int i = 0; i < sheetNames.length; i++) {\n-                sheetNames[i] = in.readUnicodeString();\n+                sheetNames[i] = in.readString();\n             }\n             field_3_sheet_names = sheetNames;\n             return;\n         }\n         // else not 'External References'\n         field_2_encoded_url = null;\n         field_3_sheet_names = null;\n-      \n+\n         short nextShort = in.readShort();\n         if(nextShort == TAG_INTERNAL_REFERENCES) {\n             // 5.38.2 'Internal References'\n@@ -116,15 +117,15 @@ public SupBookRecord(RecordInputStream in) {\n                      + field_1_number_of_sheets + \")\");\n             }\n         } else {\n-            throw new RuntimeException(\"invalid EXTERNALBOOK code (\" \n+            throw new RuntimeException(\"invalid EXTERNALBOOK code (\"\n                      + Integer.toHexString(nextShort) + \")\");\n         }\n      }\n \n     public String toString() {\n         StringBuffer sb = new StringBuffer();\n         sb.append(getClass().getName()).append(\" [SUPBOOK \");\n-        \n+\n         if(isExternalReferences()) {\n             sb.append(\"External References\");\n             sb.append(\" nSheets=\").append(field_1_number_of_sheets);\n@@ -143,18 +144,14 @@ protected int getDataSize() {\n             return SMALL_RECORD_SIZE;\n         }\n         int sum = 2; // u16 number of sheets\n-        UnicodeRecordStats urs = new UnicodeRecordStats();\n-        field_2_encoded_url.getRecordSize(urs);\n-        sum += urs.recordSize;\n-        \n+\n+        sum += StringUtil.getEncodedSize(field_2_encoded_url);\n+\n         for(int i=0; i<field_3_sheet_names.length; i++) {\n-            urs = new UnicodeRecordStats();\n-            field_3_sheet_names[i].getRecordSize(urs);\n-            sum += urs.recordSize;\n+            sum += StringUtil.getEncodedSize(field_3_sheet_names[i]);\n         }\n         return sum;\n     }\n-\n     /**\n      * called by the class that is responsible for writing this sucker.\n      * Subclasses should implement this so that their data is passed back in a\n@@ -165,29 +162,26 @@ protected int getDataSize() {\n      * @return number of bytes written\n      */\n     public int serialize(int offset, byte [] data) {\n-        LittleEndian.putShort(data, 0 + offset, sid);\n         int dataSize = getDataSize();\n-        LittleEndian.putShort(data, 2 + offset, (short) dataSize);\n-        LittleEndian.putShort(data, 4 + offset, field_1_number_of_sheets);\n-               \n+        int recordSize = 4 + dataSize;\n+        LittleEndianOutput out = new LittleEndianByteArrayOutputStream(data, offset, recordSize);\n+\n+        out.writeShort(sid);\n+        out.writeShort(dataSize);\n+        out.writeShort(field_1_number_of_sheets);\n+\n         if(isExternalReferences()) {\n-            \n-            int currentOffset = 6 + offset;\n-            UnicodeRecordStats urs = new UnicodeRecordStats();\n-            field_2_encoded_url.serialize(urs, currentOffset, data);\n-            currentOffset += urs.recordSize;\n-            \n+            StringUtil.writeUnicodeString(out, field_2_encoded_url);\n+\n             for(int i=0; i<field_3_sheet_names.length; i++) {\n-                urs = new UnicodeRecordStats();\n-                field_3_sheet_names[i].serialize(urs, currentOffset, data);\n-                currentOffset += urs.recordSize;\n+                StringUtil.writeUnicodeString(out, field_3_sheet_names[i]);\n             }\n         } else {\n-            short field2val = _isAddInFunctions ? TAG_ADD_IN_FUNCTIONS : TAG_INTERNAL_REFERENCES;\n-            \n-            LittleEndian.putShort(data, 6 + offset, field2val);\n+            int field2val = _isAddInFunctions ? TAG_ADD_IN_FUNCTIONS : TAG_INTERNAL_REFERENCES;\n+\n+            out.writeShort(field2val);\n         }\n-        return dataSize + 4;\n+        return recordSize;\n     }\n \n     public void setNumberOfSheets(short number){\n@@ -203,34 +197,34 @@ public short getSid()\n         return sid;\n     }\n     public String getURL() {\n-        String encodedUrl = field_2_encoded_url.getString();\n+        String encodedUrl = field_2_encoded_url;\n         switch(encodedUrl.charAt(0)) {\n             case 0: // Reference to an empty workbook name\n                 return encodedUrl.substring(1); // will this just be empty string?\n             case 1: // encoded file name\n                 return decodeFileName(encodedUrl);\n             case 2: // Self-referential external reference\n                 return encodedUrl.substring(1);\n-                \n+\n         }\n         return encodedUrl;\n     }\n     private static String decodeFileName(String encodedUrl) {\n         return encodedUrl.substring(1);\n         // TODO the following special characters may appear in the rest of the string, and need to get interpreted\n         /* see \"MICROSOFT OFFICE EXCEL 97-2007  BINARY FILE FORMAT SPECIFICATION\"\n-        chVolume  1 \n-        chSameVolume  2 \n+        chVolume  1\n+        chSameVolume  2\n         chDownDir  3\n-        chUpDir  4 \n+        chUpDir  4\n         chLongVolume  5\n         chStartupDir  6\n         chAltStartupDir 7\n         chLibDir  8\n-        \n+\n         */\n     }\n-    public UnicodeString[] getSheetNames() {\n-        return (UnicodeString[]) field_3_sheet_names.clone();\n+    public String[] getSheetNames() {\n+        return (String[]) field_3_sheet_names.clone();\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/SupBookRecord.java",
                "sha": "5cbfd42d6a17e3511e9737320cb513cb6a3296aa",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/TextObjectRecord.java",
                "changes": 128,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/TextObjectRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 109,
                "filename": "src/java/org/apache/poi/hssf/record/TextObjectRecord.java",
                "patch": "@@ -17,16 +17,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n-import java.io.UnsupportedEncodingException;\n-\n+import org.apache.poi.hssf.record.cont.ContinuableRecord;\n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n import org.apache.poi.hssf.record.formula.Ptg;\n import org.apache.poi.hssf.usermodel.HSSFRichTextString;\n import org.apache.poi.util.BitField;\n import org.apache.poi.util.BitFieldFactory;\n import org.apache.poi.util.HexDump;\n-import org.apache.poi.util.LittleEndian;\n-import org.apache.poi.util.LittleEndianByteArrayOutputStream;\n-import org.apache.poi.util.LittleEndianOutput;\n \n /**\n  * The TXO record (0x01B6) is used to define the properties of a text box. It is\n@@ -36,7 +33,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * \n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n-public final class TextObjectRecord extends Record {\n+public final class TextObjectRecord extends ContinuableRecord {\n \tpublic final static short sid = 0x01B6;\n \n \tprivate static final int FORMAT_RUN_ENCODED_SIZE = 8; // 2 shorts and 4 bytes reserved\n@@ -163,30 +160,7 @@ public short getSid() {\n \t\treturn sid;\n \t}\n \n-\t/**\n-\t * Only for the current record. does not include any subsequent Continue\n-\t * records\n-\t */\n-\tprivate int getCurrentRecordDataSize() {\n-\t\tint result = 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4;\n-\t\tif (_linkRefPtg != null) {\n-\t\t\tresult += 2 // formula size\n-\t\t\t\t+ 4  // unknownInt\n-\t\t\t\t+_linkRefPtg.getSize();\n-\t\t\tif (_unknownPostFormulaByte != null) {\n-\t\t\t\tresult += 1;\n-\t\t\t}\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\tprivate int serializeTXORecord(int offset, byte[] data) {\n-\t\tint dataSize = getCurrentRecordDataSize();\n-\t\tint recSize = dataSize+4;\n-\t\tLittleEndianOutput out = new LittleEndianByteArrayOutputStream(data, offset, recSize);\n-\t\t\n-\t\tout.writeShort(TextObjectRecord.sid);\n-\t\tout.writeShort(dataSize);\n+\tprivate void serializeTXORecord(ContinuableRecordOutput out) {\n \t\t\n \t\tout.writeShort(field_1_options);\n \t\tout.writeShort(field_2_textOrientation);\n@@ -206,79 +180,23 @@ private int serializeTXORecord(int offset, byte[] data) {\n \t\t\t\tout.writeByte(_unknownPostFormulaByte.byteValue());\n \t\t\t}\n \t\t}\n-\t\treturn recSize;\n \t}\n \n-\tprivate int serializeTrailingRecords(int offset, byte[] data) {\n-\t\tbyte[] textBytes;\n-\t\ttry {\n-\t\t\ttextBytes = _text.getString().getBytes(\"UTF-16LE\");\n-\t\t} catch (UnsupportedEncodingException e) {\n-\t\t\tthrow new RuntimeException(e.getMessage(), e);\n-\t\t}\n-\t\tint remainingLength = textBytes.length;\n-\n-\t\tint countTextBytesWritten = 0;\n-\t\tint pos = offset;\n-\t\t// (regardless what was read, we always serialize double-byte\n-\t\t// unicode characters (UTF-16LE).\n-\t\tByte unicodeFlag = new Byte((byte)1);\n-\t\twhile (remainingLength > 0) {\n-\t\t\tint chunkSize = Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE - 2, remainingLength);\n-\t\t\tremainingLength -= chunkSize;\n-\t\t\tpos += ContinueRecord.write(data, pos, unicodeFlag, textBytes, countTextBytesWritten, chunkSize);\n-\t\t\tcountTextBytesWritten += chunkSize;\n-\t\t}\n-\n-\t\tbyte[] formatData = createFormatData(_text);\n-\t\tpos += ContinueRecord.write(data, pos, null, formatData);\n-\t\treturn pos - offset;\n+\tprivate void serializeTrailingRecords(ContinuableRecordOutput out) {\n+\t\tout.writeContinue();\n+\t\tout.writeStringData(_text.getString());\n+\t\tout.writeContinue();\n+\t\twriteFormatData(out, _text);\n \t}\n \n-\tprivate int getTrailingRecordsSize() {\n-\t\tif (_text.length() < 1) {\n-\t\t\treturn 0;\n-\t\t}\n-\t\tint encodedTextSize = 0;\n-\t\tint textBytesLength = _text.length() * LittleEndian.SHORT_SIZE;\n-\t\twhile (textBytesLength > 0) {\n-\t\t\tint chunkSize = Math.min(RecordInputStream.MAX_RECORD_DATA_SIZE - 2, textBytesLength);\n-\t\t\ttextBytesLength -= chunkSize;\n-\n-\t\t\tencodedTextSize += 4;           // +4 for ContinueRecord sid+size\n-\t\t\tencodedTextSize += 1+chunkSize; // +1 for compressed unicode flag, \n-\t\t}\n-\n-\t\tint encodedFormatSize = (_text.numFormattingRuns() + 1) * FORMAT_RUN_ENCODED_SIZE\n-\t\t\t+ 4;  // +4 for ContinueRecord sid+size\n-\t\treturn encodedTextSize + encodedFormatSize;\n-\t}\n+\tprotected void serialize(ContinuableRecordOutput out) {\n \n-\n-\tpublic int serialize(int offset, byte[] data) {\n-\n-\t\tint expectedTotalSize = getRecordSize();\n-\t\tint totalSize = serializeTXORecord(offset, data);\n-\t\t\n+\t\tserializeTXORecord(out);\n \t\tif (_text.getString().length() > 0) {\n-\t\t\ttotalSize += serializeTrailingRecords(offset+totalSize, data);\n+\t\t\tserializeTrailingRecords(out);\n \t\t} \n-\t\t\n-\t\tif (totalSize != expectedTotalSize)\n-\t\t\tthrow new RecordFormatException(totalSize\n-\t\t\t\t\t+ \" bytes written but getRecordSize() reports \" + expectedTotalSize);\n-\t\treturn totalSize;\n \t}\n \n-\t/**\n-\t * Note - this total size includes all potential {@link ContinueRecord}s written\n-\t * but it is not the \"ushort size\" value to be written at the start of the first BIFF record \n-\t */\n-\tprotected int getDataSize() {\n-\t\treturn getCurrentRecordDataSize() + getTrailingRecordsSize();\n-\t}\n-\n-\t\n \tprivate int getFormattingDataLength() {\n \t\tif (_text.length() < 1) {\n \t\t\t// important - no formatting data if text is empty \n@@ -287,25 +205,17 @@ private int getFormattingDataLength() {\n \t\treturn (_text.numFormattingRuns() + 1) * FORMAT_RUN_ENCODED_SIZE;\n \t}\n \n-\tprivate static byte[] createFormatData(HSSFRichTextString str) {\n+\tprivate static void writeFormatData(ContinuableRecordOutput out , HSSFRichTextString str) {\n \t\tint nRuns = str.numFormattingRuns();\n-\t\tbyte[] result = new byte[(nRuns + 1) * FORMAT_RUN_ENCODED_SIZE];\n-\t\tint pos = 0;\n \t\tfor (int i = 0; i < nRuns; i++) {\n-\t\t\tLittleEndian.putUShort(result, pos, str.getIndexOfFormattingRun(i));\n-\t\t\tpos += 2;\n+\t\t\tout.writeShort(str.getIndexOfFormattingRun(i));\n \t\t\tint fontIndex = str.getFontOfFormattingRun(i);\n-\t\t\tLittleEndian.putUShort(result, pos, fontIndex == str.NO_FONT ? 0 : fontIndex);\n-\t\t\tpos += 2;\n-\t\t\tpos += 4; // skip reserved\n+\t\t\tout.writeShort(fontIndex == str.NO_FONT ? 0 : fontIndex);\n+\t\t\tout.writeInt(0); // skip reserved\n \t\t}\n-\t\tLittleEndian.putUShort(result, pos, str.length());\n-\t\tpos += 2;\n-\t\tLittleEndian.putUShort(result, pos, 0);\n-\t\tpos += 2;\n-\t\tpos += 4; // skip reserved\n-\n-\t\treturn result;\n+\t\tout.writeShort(str.length());\n+\t\tout.writeShort(0);\n+\t\tout.writeInt(0); // skip reserved\n \t}\n \n \t/**",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/TextObjectRecord.java",
                "sha": "019aab09e804f8597570cc453dcd00c86f4f3323",
                "status": "modified"
            },
            {
                "additions": 107,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/UnicodeString.java",
                "changes": 521,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/UnicodeString.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 414,
                "filename": "src/java/org/apache/poi/hssf/record/UnicodeString.java",
                "patch": "@@ -17,75 +17,84 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n import org.apache.poi.util.BitField;\n import org.apache.poi.util.BitFieldFactory;\n-import org.apache.poi.util.LittleEndian;\n import org.apache.poi.util.HexDump;\n-\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Collections;\n+import org.apache.poi.util.LittleEndianInput;\n+import org.apache.poi.util.LittleEndianOutput;\n \n /**\n- * Title: Unicode String<P>\n- * Description:  Unicode String record.  We implement these as a record, although\n- *               they are really just standard fields that are in several records.\n- *               It is considered more desirable then repeating it in all of them.<P>\n- * REFERENCE:  PG 264 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)<P>\n+ * Title: Unicode String<p/>\n+ * Description:  Unicode String - just standard fields that are in several records.\n+ *               It is considered more desirable then repeating it in all of them.<p/>\n+ * REFERENCE:  PG 264 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)<p/>\n  * @author  Andrew C. Oliver\n  * @author Marc Johnson (mjohnson at apache dot org)\n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n public final class UnicodeString implements Comparable {\n-    private short             field_1_charCount;     // = 0;\n-    private byte              field_2_optionflags;   // = 0;\n-    private String            field_3_string;        // = null;\n+    private short             field_1_charCount;\n+    private byte              field_2_optionflags;\n+    private String            field_3_string;\n     private List field_4_format_runs;\n     private byte[] field_5_ext_rst;\n-    private  static final BitField   highByte  = BitFieldFactory.getInstance(0x1);\n-    private  static final BitField   extBit    = BitFieldFactory.getInstance(0x4);\n-    private  static final BitField   richText  = BitFieldFactory.getInstance(0x8);\n+    private static final BitField   highByte  = BitFieldFactory.getInstance(0x1);\n+    private static final BitField   extBit    = BitFieldFactory.getInstance(0x4);\n+    private static final BitField   richText  = BitFieldFactory.getInstance(0x8);\n \n     public static class FormatRun implements Comparable {\n-      short character;\n-      short fontIndex;\n+        short character;\n+        short fontIndex;\n \n-      public FormatRun(short character, short fontIndex) {\n-        this.character = character;\n-        this.fontIndex = fontIndex;\n-      }\n+        public FormatRun(short character, short fontIndex) {\n+            this.character = character;\n+            this.fontIndex = fontIndex;\n+        }\n \n-      public short getCharacterPos() {\n-        return character;\n-      }\n+        public FormatRun(LittleEndianInput in) {\n+            this(in.readShort(), in.readShort());\n+        }\n \n-      public short getFontIndex() {\n-        return fontIndex;\n-      }\n+        public short getCharacterPos() {\n+            return character;\n+        }\n \n-      public boolean equals(Object o) {\n-        if ((o == null) || (o.getClass() != this.getClass()))\n-    {\n-            return false;\n+        public short getFontIndex() {\n+            return fontIndex;\n         }\n-        FormatRun other = ( FormatRun ) o;\n \n-        return ((character == other.character) && (fontIndex == other.fontIndex));\n-      }\n+        public boolean equals(Object o) {\n+            if (!(o instanceof FormatRun)) {\n+                return false;\n+            }\n+            FormatRun other = ( FormatRun ) o;\n \n-      public int compareTo(Object obj) {\n-        FormatRun r = (FormatRun)obj;\n-        if ((character == r.character) && (fontIndex == r.fontIndex))\n-          return 0;\n-        if (character == r.character)\n-          return fontIndex - r.fontIndex;\n-        else return character - r.character;\n-      }\n+            return character == other.character && fontIndex == other.fontIndex;\n+        }\n \n-      public String toString() {\n-        return \"character=\"+character+\",fontIndex=\"+fontIndex;\n-      }\n+        public int compareTo(Object obj) {\n+            FormatRun r = (FormatRun)obj;\n+            if ((character == r.character) && (fontIndex == r.fontIndex))\n+                return 0;\n+            if (character == r.character)\n+                return fontIndex - r.fontIndex;\n+            else return character - r.character;\n+        }\n+\n+        public String toString() {\n+            return \"character=\"+character+\",fontIndex=\"+fontIndex;\n+        }\n+\n+        public void serialize(LittleEndianOutput out) {\n+            out.writeShort(character);\n+            out.writeShort(fontIndex);\n+        }\n     }\n \n     private UnicodeString() {\n@@ -116,13 +125,12 @@ public int hashCode()\n      */\n     public boolean equals(Object o)\n     {\n-        if ((o == null) || (o.getClass() != this.getClass()))\n-        {\n+        if (!(o instanceof UnicodeString)) {\n             return false;\n         }\n-        UnicodeString other = ( UnicodeString ) o;\n+        UnicodeString other = (UnicodeString) o;\n \n-        //Ok lets do this in stages to return a quickly, first check the actual string\n+        //OK lets do this in stages to return a quickly, first check the actual string\n         boolean eq = ((field_1_charCount == other.field_1_charCount)\n                 && (field_2_optionflags == other.field_2_optionflags)\n                 && field_3_string.equals(other.field_3_string));\n@@ -148,7 +156,7 @@ public boolean equals(Object o)\n \n           if (!run1.equals(run2))\n             return false;\n-    }\n+        }\n \n         //Well the format runs are equal as well!, better check the ExtRst data\n         //Which by the way we dont know how to decode!\n@@ -194,19 +202,17 @@ public UnicodeString(RecordInputStream in) {\n \n         boolean isCompressed = ((field_2_optionflags & 1) == 0);\n         if (isCompressed) {\n-        \tfield_3_string = in.readCompressedUnicode(field_1_charCount);\n+            field_3_string = in.readCompressedUnicode(field_1_charCount);\n         } else {\n-        \tfield_3_string = in.readUnicodeLEString(field_1_charCount);\n+            field_3_string = in.readUnicodeLEString(field_1_charCount);\n         }\n  \n \n         if (isRichText() && (runCount > 0)) {\n           field_4_format_runs = new ArrayList(runCount);\n           for (int i=0;i<runCount;i++) {\n-            field_4_format_runs.add(new FormatRun(in.readShort(), in.readShort()));\n-            //read reserved\n-            //in.readInt();\n-            }\n+            field_4_format_runs.add(new FormatRun(in));\n+          }\n         }\n \n         if (isExtendedText() && (extensionLength > 0)) {\n@@ -372,11 +378,8 @@ public void clearFormatting() {\n       field_2_optionflags = richText.clearByte(field_2_optionflags);\n     }\n \n-    public byte[] getExtendedRst() {\n-       return this.field_5_ext_rst;\n-    }\n \n-    public void setExtendedRst(byte[] ext_rst) {\n+    void setExtendedRst(byte[] ext_rst) {\n       if (ext_rst != null)\n         field_2_optionflags = extBit.setByte(field_2_optionflags);\n       else field_2_optionflags = extBit.clearByte(field_2_optionflags);\n@@ -391,13 +394,13 @@ public void setExtendedRst(byte[] ext_rst) {\n      *  removed / re-ordered\n      */\n     public void swapFontUse(short oldFontIndex, short newFontIndex) {\n-    \tIterator i = field_4_format_runs.iterator();\n-    \twhile(i.hasNext()) {\n-    \t\tFormatRun run = (FormatRun)i.next();\n-    \t\tif(run.fontIndex == oldFontIndex) {\n-    \t\t\trun.fontIndex = newFontIndex;\n-    \t\t}\n-    \t}\n+        Iterator i = field_4_format_runs.iterator();\n+        while(i.hasNext()) {\n+            FormatRun run = (FormatRun)i.next();\n+            if(run.fontIndex == oldFontIndex) {\n+                run.fontIndex = newFontIndex;\n+            }\n+        }\n     }\n     \n     /**\n@@ -442,353 +445,45 @@ public String getDebugInfo()\n         return buffer.toString();\n     }\n \n-    private int writeContinueIfRequired(UnicodeRecordStats stats, final int requiredSize, int offset, byte[] data) {\n-      //Basic string overhead\n-      if (stats.remainingSize < requiredSize) {\n-        //Check if be are already in a continue record, if so make sure that\n-        //we go back and write out our length\n-        if (stats.lastLengthPos != -1) {\n-          short lastRecordLength = (short)(offset - stats.lastLengthPos - 2);\n-          if (lastRecordLength > 8224)\n-            throw new InternalError();\n-          LittleEndian.putShort(data, stats.lastLengthPos, lastRecordLength);\n-        }\n-\n-        LittleEndian.putShort(data, offset, ContinueRecord.sid);\n-        offset+=2;\n-        //Record the location of the last continue length position, but don't write\n-        //anything there yet (since we don't know what it will be!)\n-        stats.lastLengthPos = offset;\n-        offset += 2;\n-\n-        stats.recordSize += 4;\n-        stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-      }\n-      return offset;\n-    }\n-\n-    public int serialize(UnicodeRecordStats stats, final int offset, byte [] data)\n-    {\n-      int pos = offset;\n-\n-      //Basic string overhead\n-      pos = writeContinueIfRequired(stats, 3, pos, data);\n-      LittleEndian.putShort(data, pos, getCharCount());\n-      pos += 2;\n-      data[ pos ] = getOptionFlags();\n-      pos += 1;\n-      stats.recordSize += 3;\n-      stats.remainingSize-= 3;\n-\n-      if (isRichText()) {\n-        if (field_4_format_runs != null) {\n-          pos = writeContinueIfRequired(stats, 2, pos, data);\n-\n-          LittleEndian.putShort(data, pos, (short) field_4_format_runs.size());\n-          pos += 2;\n-          stats.recordSize += 2;\n-          stats.remainingSize -= 2;\n-        }\n-      }\n-      if ( isExtendedText() )\n-      {\n-        if (this.field_5_ext_rst != null) {\n-          pos = writeContinueIfRequired(stats, 4, pos, data);\n-\n-          LittleEndian.putInt(data, pos, field_5_ext_rst.length);\n-          pos += 4;\n-          stats.recordSize += 4;\n-          stats.remainingSize -= 4;\n-        }\n-      }\n-\n-      int charsize = isUncompressedUnicode() ? 2 : 1;\n-      int strSize = (getString().length() * charsize);\n-\n-      byte[] strBytes = null;\n-        try {\n-            String unicodeString = getString();\n-              if (!isUncompressedUnicode())\n-            {\n-                strBytes = unicodeString.getBytes(\"ISO-8859-1\");\n-            }\n-            else\n-            {\n-                  strBytes = unicodeString.getBytes(\"UTF-16LE\");\n-            }\n-        }\n-        catch (Exception e) {\n-              throw new InternalError();\n-        }\n-          if (strSize != strBytes.length)\n-            throw new InternalError(\"That shouldnt have happened!\");\n-\n-      //Check to see if the offset occurs mid string, if so then we need to add\n-      //the byte to start with that represents the first byte of the continue record.\n-      if (strSize > stats.remainingSize) {\n-        //OK the offset occurs half way through the string, that means that\n-        //we need an extra byte after the continue record ie we didnt finish\n-        //writing out the string the 1st time through\n-\n-        //But hang on, how many continue records did we span? What if this is\n-        //a REALLY long string. We need to work this all out.\n-        int amountThatCantFit = strSize;\n-        int strPos = 0;\n-        while (amountThatCantFit > 0) {\n-          int amountWritten = Math.min(stats.remainingSize, amountThatCantFit);\n-          //Make sure that the amount that can't fit takes into account\n-          //whether we are writing double byte unicode\n-          if (isUncompressedUnicode()) {\n-            //We have the '-1' here because whether this is the first record or\n-            //subsequent continue records, there is always the case that the\n-            //number of bytes in a string on double byte boundaries is actually odd.\n-            if ( ( (amountWritten ) % 2) == 1)\n-              amountWritten--;\n-          }\n-          System.arraycopy(strBytes, strPos, data, pos, amountWritten);\n-          pos += amountWritten;\n-          strPos += amountWritten;\n-          stats.recordSize += amountWritten;\n-          stats.remainingSize -= amountWritten;\n-\n-          //Ok lets subtract what we can write\n-          amountThatCantFit -= amountWritten;\n-\n-          //Each iteration of this while loop is another continue record, unless\n-          //everything  now fits.\n-          if (amountThatCantFit > 0) {\n-            //We know that a continue WILL be requied, but use this common method\n-            pos = writeContinueIfRequired(stats, amountThatCantFit, pos, data);\n-\n-            //The first byte after a continue mid string is the extra byte to\n-            //indicate if this run is compressed or not.\n-            data[pos] = (byte) (isUncompressedUnicode() ? 0x1 : 0x0);\n-            pos++;\n-            stats.recordSize++;\n-            stats.remainingSize --;\n-          }\n-        }\n-      } else {\n-        if (strSize > (data.length-pos))\n-          System.out.println(\"Hmm shouldnt happen\");\n-        //Ok the string fits nicely in the remaining size\n-        System.arraycopy(strBytes, 0, data, pos, strSize);\n-        pos += strSize;\n-        stats.recordSize += strSize;\n-        stats.remainingSize -= strSize;\n-      }\n-\n-\n-      if (isRichText() && (field_4_format_runs != null)) {\n-        int count = field_4_format_runs.size();\n-\n-        //This will ensure that a run does not split a continue\n-        for (int i=0;i<count;i++) {\n-          pos = writeContinueIfRequired(stats, 4, pos, data);\n-          FormatRun r = (FormatRun)field_4_format_runs.get(i);\n-          LittleEndian.putShort(data, pos, r.character);\n-          pos += 2;\n-          LittleEndian.putShort(data, pos, r.fontIndex);\n-          pos += 2;\n-\n-          //Each run count is four bytes\n-          stats.recordSize += 4;\n-          stats.remainingSize -=4;\n+    public void serialize(ContinuableRecordOutput out) {\n+        int numberOfRichTextRuns = 0;\n+        int extendedDataSize = 0;\n+        if (isRichText() && field_4_format_runs != null) {\n+            numberOfRichTextRuns = field_4_format_runs.size();\n         }\n-      }\n-\n-      if (isExtendedText() && (field_5_ext_rst != null)) {\n-        //Ok ExtRst is actually not documented, so i am going to hope\n-        //that we can actually continue on byte boundaries\n-        int ammountThatCantFit = field_5_ext_rst.length - stats.remainingSize;\n-        int extPos = 0;\n-        if (ammountThatCantFit > 0) {\n-          while (ammountThatCantFit > 0) {\n-            //So for this record we have already written\n-            int ammountWritten = Math.min(stats.remainingSize, ammountThatCantFit);\n-            System.arraycopy(field_5_ext_rst, extPos, data, pos, ammountWritten);\n-            pos += ammountWritten;\n-            extPos += ammountWritten;\n-            stats.recordSize += ammountWritten;\n-            stats.remainingSize -= ammountWritten;\n-\n-            //Ok lets subtract what we can write\n-            ammountThatCantFit -= ammountWritten;\n-            if (ammountThatCantFit > 0) {\n-              pos = writeContinueIfRequired(stats, 1, pos, data);\n-            }\n-          }\n-        } else {\n-          //We can fit wholey in what remains.\n-          System.arraycopy(field_5_ext_rst, 0, data, pos, field_5_ext_rst.length);\n-          pos +=  field_5_ext_rst.length;\n-          stats.remainingSize -= field_5_ext_rst.length;\n-          stats.recordSize += field_5_ext_rst.length;\n+        if (isExtendedText() && field_5_ext_rst != null) {\n+            extendedDataSize = field_5_ext_rst.length;\n         }\n-      }\n-\n-        return pos - offset;\n-    }\n-\n-\n-    public void setCompressedUnicode() {\n-      field_2_optionflags = highByte.setByte(field_2_optionflags);\n-    }\n-\n-    public void setUncompressedUnicode() {\n-      field_2_optionflags = highByte.clearByte(field_2_optionflags);\n-    }\n-\n-    private boolean isUncompressedUnicode()\n-    {\n-        return highByte.isSet(getOptionFlags());\n-    }\n-\n-    /** Returns the size of this record, given the amount of record space\n-     * remaining, it will also include the size of writing a continue record.\n-     */\n-\n-    public static class UnicodeRecordStats {\n-      public int recordSize;\n-      public int remainingSize = SSTRecord.MAX_RECORD_SIZE;\n-      public int lastLengthPos = -1;\n-    }\n-    public void getRecordSize(UnicodeRecordStats stats) {\n-      //Basic string overhead\n-      if (stats.remainingSize < 3) {\n-        //Needs a continue\n-         stats.recordSize += 4;\n-         stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-      }\n-      stats.recordSize += 3;\n-      stats.remainingSize-= 3;\n-\n-      //Read the number of rich runs if rich text.\n-      if ( isRichText() )\n-    {\n-          //Run count\n-          if (stats.remainingSize < 2) {\n-            //Needs a continue\n-            //Reset the available space.\n-            stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-            //continue record overhead\n-            stats.recordSize+=4;\n-    }\n-\n-          stats.recordSize += 2;\n-          stats.remainingSize -=2;\n-      }\n-      //Read the size of extended data if present.\n-      if ( isExtendedText() )\n-    {\n-        //Needs a continue\n-          //extension length\n-          if (stats.remainingSize < 4) {\n-            //Reset the available space.\n-            stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-            //continue record overhead\n-            stats.recordSize+=4;\n-          }\n-\n-          stats.recordSize += 4;\n-          stats.remainingSize -=4;\n-      }\n-\n-      int charsize = isUncompressedUnicode() ? 2 : 1;\n-      int strSize = (getString().length() * charsize);\n-      //Check to see if the offset occurs mid string, if so then we need to add\n-      //the byte to start with that represents the first byte of the continue record.\n-      if (strSize > stats.remainingSize) {\n-        //Ok the offset occurs half way through the string, that means that\n-        //we need an extra byte after the continue record ie we didnt finish\n-        //writing out the string the 1st time through\n-\n-        //But hang on, how many continue records did we span? What if this is\n-        //a REALLY long string. We need to work this all out.\n-        int ammountThatCantFit = strSize;\n-        while (ammountThatCantFit > 0) {\n-          int ammountWritten = Math.min(stats.remainingSize, ammountThatCantFit);\n-          //Make sure that the ammount that cant fit takes into account\n-          //whether we are writing double byte unicode\n-          if (isUncompressedUnicode()) {\n-            //We have the '-1' here because whether this is the first record or\n-            //subsequent continue records, there is always the case that the\n-            //number of bytes in a string on doube byte boundaries is actually odd.\n-            if ( ( (ammountWritten) % 2) == 1)\n-              ammountWritten--;\n-          }\n-          stats.recordSize += ammountWritten;\n-          stats.remainingSize -= ammountWritten;\n-\n-          //Ok lets subtract what we can write\n-          ammountThatCantFit -= ammountWritten;\n-\n-          //Each iteration of this while loop is another continue record, unless\n-          //everything  now fits.\n-          if (ammountThatCantFit > 0) {\n-            //Reset the available space.\n-            stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-            //continue record overhead\n-            stats.recordSize+=4;\n-\n-            //The first byte after a continue mid string is the extra byte to\n-            //indicate if this run is compressed or not.\n-            stats.recordSize++;\n-            stats.remainingSize --;\n-          }\n-        }\n-      } else {\n-        //Ok the string fits nicely in the remaining size\n-        stats.recordSize += strSize;\n-        stats.remainingSize -= strSize;\n-      }\n+    \n+        out.writeString(field_3_string, numberOfRichTextRuns, extendedDataSize);\n \n-      if (isRichText() && (field_4_format_runs != null)) {\n-        int count = field_4_format_runs.size();\n+        if (numberOfRichTextRuns > 0) {\n \n-        //This will ensure that a run does not split a continue\n-        for (int i=0;i<count;i++) {\n-          if (stats.remainingSize < 4) {\n-            //Reset the available space.\n-            stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-            //continue record overhead\n-            stats.recordSize+=4;\n+          //This will ensure that a run does not split a continue\n+          for (int i=0;i<numberOfRichTextRuns;i++) {\n+              if (out.getAvailableSpace() < 4) {\n+                  out.writeContinue();\n+              }\n+                FormatRun r = (FormatRun)field_4_format_runs.get(i);\n+                r.serialize(out);\n           }\n-\n-          //Each run count is four bytes\n-          stats.recordSize += 4;\n-          stats.remainingSize -=4;\n         }\n-      }\n \n-      if (isExtendedText() && (field_5_ext_rst != null)) {\n-        //Ok ExtRst is actually not documented, so i am going to hope\n-        //that we can actually continue on byte boundaries\n-        int ammountThatCantFit = field_5_ext_rst.length - stats.remainingSize;\n-        if (ammountThatCantFit > 0) {\n-          while (ammountThatCantFit > 0) {\n-            //So for this record we have already written\n-            int ammountWritten = Math.min(stats.remainingSize, ammountThatCantFit);\n-            stats.recordSize += ammountWritten;\n-            stats.remainingSize -= ammountWritten;\n-\n-            //Ok lets subtract what we can write\n-            ammountThatCantFit -= ammountWritten;\n-            if (ammountThatCantFit > 0) {\n-              //Each iteration of this while loop is another continue record.\n-\n-              //Reset the available space.\n-              stats.remainingSize = SSTRecord.MAX_RECORD_SIZE-4;\n-              //continue record overhead\n-              stats.recordSize += 4;\n+        if (extendedDataSize > 0) {\n+            // OK ExtRst is actually not documented, so i am going to hope\n+            // that we can actually continue on byte boundaries\n+\n+            int extPos = 0;\n+            while (true) {\n+                int nBytesToWrite = Math.min(extendedDataSize - extPos, out.getAvailableSpace());\n+                out.write(field_5_ext_rst, extPos, nBytesToWrite);\n+                extPos += nBytesToWrite;\n+                if (extPos >= extendedDataSize) {\n+                    break;\n+                }\n+                out.writeContinue();\n             }\n-          }\n-        } else {\n-          //We can fit wholey in what remains.\n-          stats.remainingSize -= field_5_ext_rst.length;\n-          stats.recordSize += field_5_ext_rst.length;\n         }\n-      }\n     }\n \n     public int compareTo(Object obj)\n@@ -801,9 +496,9 @@ public int compareTo(Object obj)\n         if (result != 0)\n           return result;\n \n-        //Ok string appears to be equal but now lets compare formatting runs\n+        //OK string appears to be equal but now lets compare formatting runs\n         if ((field_4_format_runs == null) && (str.field_4_format_runs == null))\n-          //Strings are equal, and there are no formtting runs.\n+          //Strings are equal, and there are no formatting runs.\n           return 0;\n \n         if ((field_4_format_runs == null) && (str.field_4_format_runs != null))\n@@ -850,12 +545,12 @@ public int compareTo(Object obj)\n         return 0;\n     }\n \n-    public boolean isRichText()\n+    private boolean isRichText()\n     {\n       return richText.isSet(getOptionFlags());\n     }\n \n-    public boolean isExtendedText()\n+    private boolean isExtendedText()\n         {\n         return extBit.isSet(getOptionFlags());\n     }\n@@ -877,10 +572,8 @@ public Object clone() {\n           str.field_5_ext_rst = new byte[field_5_ext_rst.length];\n           System.arraycopy(field_5_ext_rst, 0, str.field_5_ext_rst, 0,\n                            field_5_ext_rst.length);\n-    }\n+        }\n \n         return str;\n     }\n-\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/UnicodeString.java",
                "sha": "fc493d434824c6a6bb38906b126a3fcbe8017bdb",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/constant/ConstantValueParser.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/constant/ConstantValueParser.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 10,
                "filename": "src/java/org/apache/poi/hssf/record/constant/ConstantValueParser.java",
                "patch": "@@ -17,8 +17,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record.constant;\n \n-import org.apache.poi.hssf.record.UnicodeString;\n-import org.apache.poi.hssf.record.UnicodeString.UnicodeRecordStats;\n import org.apache.poi.util.LittleEndianInput;\n import org.apache.poi.util.LittleEndianOutput;\n import org.apache.poi.util.StringUtil;\n@@ -65,7 +63,7 @@ private static Object readAConstantValue(LittleEndianInput in) {\n \t\t\tcase TYPE_NUMBER:\n \t\t\t\treturn new Double(in.readDouble());\n \t\t\tcase TYPE_STRING:\n-\t\t\t\treturn new UnicodeString(StringUtil.readUnicodeString(in));\n+\t\t\t\treturn StringUtil.readUnicodeString(in);\n \t\t\tcase TYPE_BOOLEAN:\n \t\t\t\treturn readBoolean(in);\n \t\t\tcase TYPE_ERROR_CODE:\n@@ -111,10 +109,8 @@ private static int getEncodedSize(Object object) {\n \t\tif(cls == Boolean.class || cls == Double.class || cls == ErrorConstant.class) {\n \t\t\treturn 8;\n \t\t}\n-\t\tUnicodeString strVal = (UnicodeString)object;\n-\t\tUnicodeRecordStats urs = new UnicodeRecordStats();\n-\t\tstrVal.getRecordSize(urs);\n-\t\treturn urs.recordSize;\n+\t\tString strVal = (String)object;\n+\t\treturn StringUtil.getEncodedSize(strVal);\n \t}\n \n \tpublic static void encode(LittleEndianOutput out, Object[] values) {\n@@ -142,10 +138,10 @@ private static void encodeSingleValue(LittleEndianOutput out, Object value) {\n \t\t\tout.writeDouble(dVal.doubleValue());\n \t\t\treturn;\n \t\t}\n-\t\tif (value instanceof UnicodeString) {\n-\t\t\tUnicodeString usVal = (UnicodeString) value;\n+\t\tif (value instanceof String) {\n+\t\t\tString val = (String) value;\n \t\t\tout.writeByte(TYPE_STRING);\n-\t\t\tStringUtil.writeUnicodeString(out, usVal.getString());\n+\t\t\tStringUtil.writeUnicodeString(out, val);\n \t\t\treturn;\n \t\t}\n \t\tif (value instanceof ErrorConstant) {",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/constant/ConstantValueParser.java",
                "sha": "3fbbee12ac5383c31c3ba61d4d4da4a26269d77c",
                "status": "modified"
            },
            {
                "additions": 69,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/cont/ContinuableRecord.java",
                "changes": 69,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/cont/ContinuableRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/record/cont/ContinuableRecord.java",
                "patch": "@@ -0,0 +1,69 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.hssf.record.cont;\r\n+\r\n+import org.apache.poi.hssf.record.ContinueRecord;\r\n+import org.apache.poi.hssf.record.Record;\r\n+import org.apache.poi.util.LittleEndianByteArrayOutputStream;\r\n+import org.apache.poi.util.LittleEndianOutput;\r\n+\r\n+/**\r\n+ * Common superclass of all records that can produce {@link ContinueRecord}s while being serialized.\r\n+ * \r\n+ * @author Josh Micich\r\n+ */\r\n+public abstract class ContinuableRecord extends Record {\r\n+\r\n+\tprotected ContinuableRecord() {\r\n+\t\t// no fields to initialise \r\n+\t}\r\n+\t/**\r\n+\t * Serializes this record's content to the supplied data output.<br/>\r\n+\t * The standard BIFF header (ushort sid, ushort size) has been handled by the superclass, so \r\n+\t * only BIFF data should be written by this method.  Simple data types can be written with the\r\n+\t * standard {@link LittleEndianOutput} methods.  Methods from {@link ContinuableRecordOutput} \r\n+\t * can be used to serialize strings (with {@link ContinueRecord}s being written as required).\r\n+\t * If necessary, implementors can explicitly start {@link ContinueRecord}s (regardless of the\r\n+\t * amount of remaining space).\r\n+\t * \r\n+\t * @param out a data output stream\r\n+\t */\r\n+\tprotected abstract void serialize(ContinuableRecordOutput out);\r\n+\r\n+\r\n+\t/**\r\n+\t * @return four less than the total length of the encoded record(s) \r\n+\t * (in the case when no {@link ContinueRecord} is needed, this is the \r\n+\t *  same ushort value that gets encoded after the record sid\r\n+\t */\r\n+\tprotected final int getDataSize() {\r\n+\t\tContinuableRecordOutput out = ContinuableRecordOutput.createForCountingOnly();\r\n+\t\tserialize(out);\r\n+\t\tout.terminate();\r\n+\t\treturn out.getTotalSize() - 4;\r\n+\t}\r\n+\r\n+\tpublic final int serialize(int offset, byte[] data) {\r\n+\r\n+\t\tLittleEndianOutput leo = new LittleEndianByteArrayOutputStream(data, offset);\r\n+\t\tContinuableRecordOutput out = new ContinuableRecordOutput(leo, getSid());\r\n+\t\tserialize(out);\r\n+\t\tout.terminate();\r\n+\t\treturn out.getTotalSize();\r\n+\t}\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/cont/ContinuableRecord.java",
                "sha": "135b93ff44b152b0a5b369b7dccfdc06eadf118f",
                "status": "added"
            },
            {
                "additions": 257,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/cont/ContinuableRecordOutput.java",
                "changes": 257,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/cont/ContinuableRecordOutput.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/record/cont/ContinuableRecordOutput.java",
                "patch": "@@ -0,0 +1,257 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.hssf.record.cont;\r\n+\r\n+import org.apache.poi.hssf.record.ContinueRecord;\r\n+import org.apache.poi.util.DelayableLittleEndianOutput;\r\n+import org.apache.poi.util.LittleEndianOutput;\r\n+import org.apache.poi.util.StringUtil;\r\n+\r\n+/**\r\n+ * An augmented {@link LittleEndianOutput} used for serialization of {@link ContinuableRecord}s.\r\n+ * This class keeps track of how much remaining space is available in the current BIFF record and\r\n+ * can start new {@link ContinueRecord}s as required. \r\n+ * \r\n+ * @author Josh Micich\r\n+ */\r\n+public final class ContinuableRecordOutput implements LittleEndianOutput {\r\n+\t\r\n+\tprivate final LittleEndianOutput _out;\r\n+\tprivate UnknownLengthRecordOutput _ulrOutput;\r\n+\tprivate int _totalPreviousRecordsSize;\r\n+\r\n+\tContinuableRecordOutput(LittleEndianOutput out, int sid) {\r\n+\t\t_ulrOutput = new UnknownLengthRecordOutput(out, sid);\r\n+\t\t_out = out;\r\n+\t\t_totalPreviousRecordsSize = 0;\r\n+\t}\r\n+\t\r\n+\tpublic static ContinuableRecordOutput createForCountingOnly() {\r\n+\t\treturn new ContinuableRecordOutput(NOPOutput, -777); // fake sid\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * @return total number of bytes written so far (including all BIFF headers) \r\n+\t */\r\n+\tpublic int getTotalSize() {\r\n+\t\treturn _totalPreviousRecordsSize + _ulrOutput.getTotalSize();\r\n+\t}\r\n+\t/**\r\n+\t * Terminates the last record (also updates its 'ushort size' field)\r\n+\t */\r\n+\tvoid terminate() {\r\n+\t\t_ulrOutput.terminate();\r\n+\t}\r\n+\t/**\r\n+\t * @return number of remaining bytes of space in current record\r\n+\t */\r\n+\tpublic int getAvailableSpace() {\r\n+\t\treturn _ulrOutput.getAvailableSpace();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Terminates the current record and starts a new {@link ContinueRecord} (regardless\r\n+\t * of how much space is still available in the current record).\r\n+\t */\r\n+\tpublic void writeContinue() {\r\n+\t\t_ulrOutput.terminate();\r\n+\t\t_totalPreviousRecordsSize += _ulrOutput.getTotalSize();\r\n+\t\t_ulrOutput = new UnknownLengthRecordOutput(_out, ContinueRecord.sid);\r\n+\t}\r\n+\tpublic void writeContinueIfRequired(int requiredContinuousSize) {\r\n+\t\tif (_ulrOutput.getAvailableSpace() < requiredContinuousSize) {\r\n+\t\t\twriteContinue();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Writes the 'optionFlags' byte and encoded character data of a unicode string.  This includes:\r\n+\t * <ul>\r\n+\t * <li>byte optionFlags</li>\r\n+\t * <li>encoded character data (in \"ISO-8859-1\" or \"UTF-16LE\" encoding)</li>\r\n+\t * </ul>\r\n+\t * \r\n+\t * Notes:\r\n+\t * <ul>\r\n+\t * <li>The value of the 'is16bitEncoded' flag is determined by the actual character data \r\n+\t * of <tt>text</tt></li>\r\n+\t * <li>The string options flag is never separated (by a {@link ContinueRecord}) from the\r\n+\t * first chunk of character data it refers to.</li>\r\n+\t * <li>The 'ushort length' field is assumed to have been explicitly written earlier.  Hence, \r\n+\t * there may be an intervening {@link ContinueRecord}</li>\r\n+\t * </ul>\r\n+\t */\r\n+\tpublic void writeStringData(String text) {\r\n+\t\tboolean is16bitEncoded = StringUtil.hasMultibyte(text);\r\n+\t\t// calculate total size of the header and first encoded char\r\n+\t\tint keepTogetherSize = 1 + 1; // ushort len, at least one character byte\r\n+\t\tint optionFlags = 0x00;\r\n+\t\tif (is16bitEncoded) {\r\n+\t\t\toptionFlags |= 0x01;\r\n+\t\t\tkeepTogetherSize += 1; // one extra byte for first char\r\n+\t\t}\r\n+\t\twriteContinueIfRequired(keepTogetherSize);\r\n+\t\twriteByte(optionFlags);\r\n+\t\twriteCharacterData(text, is16bitEncoded);\r\n+\t}\r\n+\t/**\r\n+\t * Writes a unicode string complete with header and character data.  This includes:\r\n+\t * <ul>\r\n+\t * <li>ushort length</li>\r\n+\t * <li>byte optionFlags</li>\r\n+\t * <li>ushort numberOfRichTextRuns (optional)</li>\r\n+\t * <li>ushort extendedDataSize (optional)</li>\r\n+\t * <li>encoded character data (in \"ISO-8859-1\" or \"UTF-16LE\" encoding)</li>\r\n+\t * </ul>\r\n+\t * \r\n+\t * The following bits of the 'optionFlags' byte will be set as appropriate:\r\n+\t * <table border='1'>\r\n+\t * <tr><th>Mask</th><th>Description</th></tr>\r\n+\t * <tr><td>0x01</td><td>is16bitEncoded</td></tr>\r\n+\t * <tr><td>0x04</td><td>hasExtendedData</td></tr>\r\n+\t * <tr><td>0x08</td><td>isRichText</td></tr>\r\n+\t * </table>\r\n+\t * Notes:\r\n+\t * <ul> \r\n+\t * <li>The value of the 'is16bitEncoded' flag is determined by the actual character data \r\n+\t * of <tt>text</tt></li>\r\n+\t * <li>The string header fields are never separated (by a {@link ContinueRecord}) from the\r\n+\t * first chunk of character data (i.e. the first character is always encoded in the same\r\n+\t * record as the string header).</li>\r\n+\t * </ul>\r\n+\t */\r\n+\tpublic void writeString(String text, int numberOfRichTextRuns, int extendedDataSize) {\r\n+\t\tboolean is16bitEncoded = StringUtil.hasMultibyte(text);\r\n+\t\t// calculate total size of the header and first encoded char\r\n+\t\tint keepTogetherSize = 2 + 1 + 1; // ushort len, byte optionFlags, at least one character byte\r\n+\t\tint optionFlags = 0x00;\r\n+\t\tif (is16bitEncoded) {\r\n+\t\t\toptionFlags |= 0x01;\r\n+\t\t\tkeepTogetherSize += 1; // one extra byte for first char\r\n+\t\t}\r\n+\t\tif (numberOfRichTextRuns > 0) {\r\n+\t\t\toptionFlags |= 0x08;\r\n+\t\t\tkeepTogetherSize += 2;\r\n+\t\t}\r\n+\t\tif (extendedDataSize > 0) {\r\n+\t\t\toptionFlags |= 0x04;\r\n+\t\t\tkeepTogetherSize += 4;\r\n+\t\t}\r\n+\t\twriteContinueIfRequired(keepTogetherSize);\r\n+\t\twriteShort(text.length());\r\n+\t\twriteByte(optionFlags);\r\n+\t\tif (numberOfRichTextRuns > 0) {\r\n+\t\t\twriteShort(numberOfRichTextRuns);\r\n+\t\t}\r\n+\t\tif (extendedDataSize > 0) {\r\n+\t\t\twriteInt(extendedDataSize);\r\n+\t\t}\r\n+\t\twriteCharacterData(text, is16bitEncoded);\r\n+\t}\r\n+\r\n+\r\n+\tprivate void writeCharacterData(String text, boolean is16bitEncoded) {\r\n+\t\tint nChars = text.length();\r\n+\t\tint i=0;\r\n+\t\tif (is16bitEncoded) {\r\n+\t\t\twhile(true) {\r\n+\t\t\t\tint nWritableChars = Math.min(nChars-i, _ulrOutput.getAvailableSpace() / 2);\r\n+\t\t\t\tfor ( ; nWritableChars > 0; nWritableChars--) {\r\n+\t\t\t\t\t_ulrOutput.writeShort(text.charAt(i++));\r\n+\t\t\t\t}\r\n+\t\t\t\tif (i >= nChars) {\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\twriteContinue();\r\n+\t\t\t\twriteByte(0x01); \r\n+\t\t\t}\r\n+\t\t} else {\r\n+\t\t\twhile(true) {\r\n+\t\t\t\tint nWritableChars = Math.min(nChars-i, _ulrOutput.getAvailableSpace() / 1);\r\n+\t\t\t\tfor ( ; nWritableChars > 0; nWritableChars--) {\r\n+\t\t\t\t\t_ulrOutput.writeByte(text.charAt(i++));\r\n+\t\t\t\t}\r\n+\t\t\t\tif (i >= nChars) {\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\twriteContinue();\r\n+\t\t\t\twriteByte(0x00); \r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tpublic void write(byte[] b) {\r\n+\t\twriteContinueIfRequired(b.length);\r\n+\t\t_ulrOutput.write(b);\r\n+\t}\r\n+\tpublic void write(byte[] b, int offset, int len) {\r\n+\t\twriteContinueIfRequired(len);\r\n+\t\t_ulrOutput.write(b, offset, len);\r\n+\t}\r\n+\tpublic void writeByte(int v) {\r\n+\t\twriteContinueIfRequired(1);\r\n+\t\t_ulrOutput.writeByte(v);\r\n+\t}\r\n+\tpublic void writeDouble(double v) {\r\n+\t\twriteContinueIfRequired(8);\r\n+\t\t_ulrOutput.writeDouble(v);\r\n+\t}\r\n+\tpublic void writeInt(int v) {\r\n+\t\twriteContinueIfRequired(4);\r\n+\t\t_ulrOutput.writeInt(v);\r\n+\t}\r\n+\tpublic void writeLong(long v) {\r\n+\t\twriteContinueIfRequired(8);\r\n+\t\t_ulrOutput.writeLong(v);\r\n+\t}\r\n+\tpublic void writeShort(int v) {\r\n+\t\twriteContinueIfRequired(2);\r\n+\t\t_ulrOutput.writeShort(v);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Allows optimised usage of {@link ContinuableRecordOutput} for sizing purposes only.\r\n+\t */\r\n+    private static final LittleEndianOutput NOPOutput = new DelayableLittleEndianOutput() {\r\n+\r\n+\t\tpublic LittleEndianOutput createDelayedOutput(int size) {\r\n+\t\t\treturn this;\r\n+\t\t}\r\n+\t\tpublic void write(byte[] b) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+\t\tpublic void write(byte[] b, int offset, int len) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+\t\tpublic void writeByte(int v) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+\t\tpublic void writeDouble(double v) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+\t\tpublic void writeInt(int v) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+\t\tpublic void writeLong(long v) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+\t\tpublic void writeShort(int v) {\r\n+\t\t\t// does nothing\r\n+\t\t}\r\n+    };\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/cont/ContinuableRecordOutput.java",
                "sha": "5d540365b7e22a90ab5b6f74dba6a7004fdd4faa",
                "status": "added"
            },
            {
                "additions": 114,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/cont/UnknownLengthRecordOutput.java",
                "changes": 114,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/cont/UnknownLengthRecordOutput.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/record/cont/UnknownLengthRecordOutput.java",
                "patch": "@@ -0,0 +1,114 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.hssf.record.cont;\r\n+\r\n+import org.apache.poi.hssf.record.RecordInputStream;\r\n+import org.apache.poi.util.DelayableLittleEndianOutput;\r\n+import org.apache.poi.util.LittleEndianByteArrayOutputStream;\r\n+import org.apache.poi.util.LittleEndianOutput;\r\n+/**\r\n+ * Allows the writing of BIFF records when the 'ushort size' header field is not known in advance.\r\n+ * When the client is finished writing data, it calls {@link #terminate()}, at which point this \r\n+ * class updates the 'ushort size' with its final value. \r\n+ * \r\n+ * @author Josh Micich\r\n+ */\r\n+final class UnknownLengthRecordOutput implements LittleEndianOutput {\r\n+\tprivate static final int MAX_DATA_SIZE = RecordInputStream.MAX_RECORD_DATA_SIZE;\r\n+\r\n+\tprivate final LittleEndianOutput _originalOut;\r\n+\t/** for writing the 'ushort size'  field once its value is known */\r\n+\tprivate final LittleEndianOutput _dataSizeOutput;\r\n+\tprivate final byte[] _byteBuffer;\r\n+\tprivate LittleEndianOutput _out;\r\n+\tprivate int _size;\r\n+\t\r\n+\tpublic UnknownLengthRecordOutput(LittleEndianOutput out, int sid) {\r\n+\t\t_originalOut = out;\r\n+\t\tout.writeShort(sid);\r\n+\t\tif (out instanceof DelayableLittleEndianOutput) {\r\n+\t\t\t// optimisation\r\n+\t\t\tDelayableLittleEndianOutput dleo = (DelayableLittleEndianOutput) out;\r\n+\t\t\t_dataSizeOutput = dleo.createDelayedOutput(2);\r\n+\t\t\t_byteBuffer = null;\r\n+\t\t\t_out = out;\r\n+\t\t} else {\r\n+\t\t\t// otherwise temporarily write all subsequent data to a buffer\r\n+\t\t\t_dataSizeOutput = out;\r\n+\t\t\t_byteBuffer = new byte[RecordInputStream.MAX_RECORD_DATA_SIZE];\r\n+\t\t\t_out = new LittleEndianByteArrayOutputStream(_byteBuffer, 0);\r\n+\t\t}\r\n+\t}\r\n+\t/**\r\n+\t * includes 4 byte header\r\n+\t */\r\n+\tpublic int getTotalSize() {\r\n+\t\treturn 4 + _size;\r\n+\t}\r\n+\tpublic int getAvailableSpace() {\r\n+\t\tif (_out == null) {\r\n+\t\t\tthrow new IllegalStateException(\"Record already terminated\");\r\n+\t\t}\r\n+\t\treturn MAX_DATA_SIZE - _size;\r\n+\t}\r\n+\t/**\r\n+\t * Finishes writing the current record and updates 'ushort size' field.<br/>\r\n+\t * After this method is called, only {@link #getTotalSize()} may be called.\r\n+\t */\r\n+\tpublic void terminate() {\r\n+\t\tif (_out == null) {\r\n+\t\t\tthrow new IllegalStateException(\"Record already terminated\");\r\n+\t\t}\r\n+\t\t_dataSizeOutput.writeShort(_size);\r\n+\t\tif (_byteBuffer != null) {\r\n+\t\t\t_originalOut.write(_byteBuffer, 0, _size);\r\n+\t\t\t_out = null;\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t_out = null;\r\n+\t}\r\n+\t\r\n+\tpublic void write(byte[] b) {\r\n+\t\t_out.write(b);\r\n+\t\t_size += b.length;\r\n+\t}\r\n+\tpublic void write(byte[] b, int offset, int len) {\r\n+\t\t_out.write(b, offset, len);\r\n+\t\t_size += len;\r\n+\t}\r\n+\tpublic void writeByte(int v) {\r\n+\t\t_out.writeByte(v);\r\n+\t\t_size += 1;\r\n+\t}\r\n+\tpublic void writeDouble(double v) {\r\n+\t\t_out.writeDouble(v);\r\n+\t\t_size += 8;\r\n+\t}\r\n+\tpublic void writeInt(int v) {\r\n+\t\t_out.writeInt(v);\r\n+\t\t_size += 4;\r\n+\t}\r\n+\tpublic void writeLong(long v) {\r\n+\t\t_out.writeLong(v);\r\n+\t\t_size += 8;\r\n+\t}\r\n+\tpublic void writeShort(int v) {\r\n+\t\t_out.writeShort(v);\r\n+\t\t_size += 2;\r\n+\t}\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/cont/UnknownLengthRecordOutput.java",
                "sha": "9209566c239c088cc78811b120c35daf1e8968a4",
                "status": "added"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java",
                "patch": "@@ -206,8 +206,8 @@ private static String getConstantText(Object o) {\n \t\tif (o == null) {\n \t\t\tthrow new RuntimeException(\"Array item cannot be null\");\n \t\t}\n-\t\tif (o instanceof UnicodeString) {\n-\t\t\treturn \"\\\"\" + ((UnicodeString)o).getString() + \"\\\"\";\n+\t\tif (o instanceof String) {\n+\t\t\treturn \"\\\"\" + (String)o + \"\\\"\";\n \t\t}\n \t\tif (o instanceof Double) {\n \t\t\treturn ((Double)o).toString();",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/record/formula/ArrayPtg.java",
                "sha": "7d4f65acd987aae65b6660404dbd48df949b072c",
                "status": "modified"
            },
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "changes": 70,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 32,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "patch": "@@ -43,7 +43,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hssf.record.ObjRecord;\n import org.apache.poi.hssf.record.Record;\n import org.apache.poi.hssf.record.RecordBase;\n-import org.apache.poi.hssf.record.StringRecord;\n import org.apache.poi.hssf.record.SubRecord;\n import org.apache.poi.hssf.record.TextObjectRecord;\n import org.apache.poi.hssf.record.UnicodeString;\n@@ -257,7 +256,7 @@ public short getCellNum() {\n     }\n     \n     public int getColumnIndex() {\n-    \treturn record.getColumn() & 0xFFFF;\n+        return record.getColumn() & 0xFFFF;\n     }\n \n     /**\n@@ -336,38 +335,23 @@ private void setCellType(int cellType, boolean setValue, int row,short col, shor\n                 break;\n \n             case CELL_TYPE_STRING :\n-                LabelSSTRecord lrec = null;\n+                LabelSSTRecord lrec;\n \n-                if (cellType != this.cellType)\n-                {\n+                if (cellType == this.cellType) {\n+                    lrec = (LabelSSTRecord) record;\n+                } else {\n                     lrec = new LabelSSTRecord();\n+                    lrec.setColumn(col);\n+                    lrec.setRow(row);\n+                    lrec.setXFIndex(styleIndex);\n                 }\n-                else\n-                {\n-                    lrec = ( LabelSSTRecord ) record;\n-                }\n-                lrec.setColumn(col);\n-                lrec.setRow(row);\n-                lrec.setXFIndex(styleIndex);\n-                if (setValue)\n-                {\n-                    if ((getStringCellValue() != null)\n-                            && (!getStringCellValue().equals(\"\")))\n-                    {\n-                        int sst = 0;\n-\n-                        UnicodeString str = getRichStringCellValue().getUnicodeString();\n-//jmh                        if (encoding == ENCODING_COMPRESSED_UNICODE)\n-//jmh                        {\n-//                      jmh                            str.setCompressedUnicode();\n-//                      jmh                        } else if (encoding == ENCODING_UTF_16)\n-//                      jmh                        {\n-//                      jmh                            str.setUncompressedUnicode();\n-//                      jmh                        }\n-                        sst = book.getWorkbook().addSSTString(str);\n-                        lrec.setSSTIndex(sst);\n-                        getRichStringCellValue().setUnicodeString(book.getWorkbook().getSSTString(sst));\n-                    }\n+                if (setValue) {\n+                    String str = convertCellValueToString();\n+                    int sstIndex = book.getWorkbook().addSSTString(new UnicodeString(str));\n+                    lrec.setSSTIndex(sstIndex);\n+                    UnicodeString us = book.getWorkbook().getSSTString(sstIndex);\n+                    stringValue = new HSSFRichTextString();\n+                    stringValue.setUnicodeString(us);\n                 }\n                 record = lrec;\n                 break;\n@@ -782,7 +766,9 @@ private boolean convertCellValueToBoolean() {\n             case CELL_TYPE_BOOLEAN:\n                 return (( BoolErrRecord ) record).getBooleanValue();\n             case CELL_TYPE_STRING:\n-                return Boolean.valueOf(((StringRecord)record).getString()).booleanValue();\n+                int sstIndex = ((LabelSSTRecord)record).getSSTIndex();\n+                String text = book.getWorkbook().getSSTString(sstIndex).getString();\n+                return Boolean.valueOf(text).booleanValue();\n             case CELL_TYPE_NUMERIC:\n                 return ((NumberRecord)record).getValue() != 0;\n \n@@ -796,6 +782,26 @@ private boolean convertCellValueToBoolean() {\n         }\n         throw new RuntimeException(\"Unexpected cell type (\" + cellType + \")\");\n     }\n+    private String convertCellValueToString() {\n+\n+        switch (cellType) {\n+            case CELL_TYPE_BLANK:\n+                return \"\";\n+            case CELL_TYPE_BOOLEAN:\n+                return ((BoolErrRecord) record).getBooleanValue() ? \"TRUE\" : \"FALSE\";\n+            case CELL_TYPE_STRING:\n+                int sstIndex = ((LabelSSTRecord)record).getSSTIndex();\n+                return book.getWorkbook().getSSTString(sstIndex).getString();\n+            case CELL_TYPE_NUMERIC:\n+                return String.valueOf(((NumberRecord)record).getValue());\n+            case CELL_TYPE_ERROR:\n+                   return HSSFErrorConstants.getText(((BoolErrRecord) record).getErrorValue());\n+            case CELL_TYPE_FORMULA:\n+                // should really evaluate, but HSSFCell can't call HSSFFormulaEvaluator\n+                return \"\";\n+        }\n+        throw new RuntimeException(\"Unexpected cell type (\" + cellType + \")\");\n+    }\n \n     /**\n      * get the value of the cell as a boolean.  For strings, numbers, and errors, we throw an exception.",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "sha": "6f327b21c3de42b9c247f0904e40aa108418a0f8",
                "status": "modified"
            },
            {
                "additions": 34,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/util/DelayableLittleEndianOutput.java",
                "changes": 34,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/DelayableLittleEndianOutput.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/util/DelayableLittleEndianOutput.java",
                "patch": "@@ -0,0 +1,34 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.util;\r\n+/**\r\n+ * Implementors of this interface allow client code to 'delay' writing to a certain section of a \r\n+ * data output stream.<br/>\r\n+ * A typical application is for writing BIFF records when the size is not known until well after\r\n+ * the header has been written.  The client code can call {@link #createDelayedOutput(int)}\r\n+ * to reserve two bytes of the output for the 'ushort size' header field.  The delayed output can\r\n+ * be written at any stage. \r\n+ * \r\n+ * @author Josh Micich\r\n+ */\r\n+public interface DelayableLittleEndianOutput extends LittleEndianOutput {\r\n+\t/**\r\n+\t * Creates an output stream intended for outputting a sequence of <tt>size</tt> bytes.\r\n+\t */\r\n+\tLittleEndianOutput createDelayedOutput(int size);\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/util/DelayableLittleEndianOutput.java",
                "sha": "d8e4395e6438a3607e5e417b2a17775509aa28d9",
                "status": "added"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/util/LittleEndianByteArrayOutputStream.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/LittleEndianByteArrayOutputStream.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/util/LittleEndianByteArrayOutputStream.java",
                "patch": "@@ -24,7 +24,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * \n  * @author Josh Micich\n  */\n-public final class LittleEndianByteArrayOutputStream implements LittleEndianOutput {\n+public final class LittleEndianByteArrayOutputStream implements LittleEndianOutput, DelayableLittleEndianOutput {\n \tprivate final byte[] _buf;\n \tprivate final int _endIndex;\n \tprivate int _writeIndex;\n@@ -89,4 +89,10 @@ public void write(byte[] b, int offset, int len) {\n \tpublic int getWriteIndex() {\n \t\treturn _writeIndex;\n \t}\n+\tpublic LittleEndianOutput createDelayedOutput(int size) {\n+\t\tcheckPosition(size);\n+\t\tLittleEndianOutput result = new LittleEndianByteArrayOutputStream(_buf, _writeIndex, _writeIndex+size);\n+\t\t_writeIndex += size;\n+\t\treturn result;\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/util/LittleEndianByteArrayOutputStream.java",
                "sha": "b3ded97687eff06cfaf660681b3a55b89e781387",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/util/StringUtil.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/StringUtil.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/util/StringUtil.java",
                "patch": "@@ -162,6 +162,15 @@ public static void writeUnicodeString(LittleEndianOutput out, String value) {\n \t\t}\n \t}\n \n+\t/**\n+\t * @return the number of bytes that would be written by {@link #writeUnicodeString(LittleEndianOutput, String)}\n+\t */\n+\tpublic static int getEncodedSize(String value) {\n+\t\tint result = 2 + 1;\n+\t\tresult += value.length() * (StringUtil.hasMultibyte(value) ? 2 : 1);\n+\t\treturn result;\n+\t}\n+\n \t/**\n \t * Takes a unicode (java) string, and returns it as 8 bit data (in ISO-8859-1\n \t * codepage).",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/java/org/apache/poi/util/StringUtil.java",
                "sha": "263f45e1e53b48758364ee1a0621798cd7219363",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "patch": "@@ -196,10 +196,14 @@ protected EscherBSERecord getEscherBSERecord(){\n         Document doc = ppt.getDocumentRecord();\n         EscherContainerRecord dggContainer = doc.getPPDrawingGroup().getDggContainer();\n         EscherContainerRecord bstore = (EscherContainerRecord)Shape.getEscherChild(dggContainer, EscherContainerRecord.BSTORE_CONTAINER);\n-\n+        if(bstore == null) {\n+            logger.log(POILogger.DEBUG, \"EscherContainerRecord.BSTORE_CONTAINER was not found \");\n+            return null;\n+        }\n         List lst = bstore.getChildRecords();\n         int idx = getPictureIndex();\n         if (idx == 0){\n+            logger.log(POILogger.DEBUG, \"picture index was not found, returning \");\n             return null;\n         } else {\n             return (EscherBSERecord)lst.get(idx-1);\n@@ -263,7 +267,7 @@ public void draw(Graphics2D graphics){\n         ShapePainter.paint(this, graphics);\n \n         PictureData data = getPictureData();\n-        data.draw(graphics, this);\n+        if(data != null) data.draw(graphics, this);\n \n         graphics.setTransform(at);\n     }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "sha": "db86f288115979d558d2632a44d1824cdb936d5e",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/src/org/apache/poi/hslf/model/TableCell.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/TableCell.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/TableCell.java",
                "patch": "@@ -56,8 +56,8 @@ public TableCell(Shape parent){\n         super(parent);\r\n \r\n         setShapeType(ShapeTypes.Rectangle);\r\n-        _txtrun.setRunType(TextHeaderAtom.HALF_BODY_TYPE);\r\n-        _txtrun.getRichTextRuns()[0].setFlag(false, 0, false);\r\n+        //_txtrun.setRunType(TextHeaderAtom.HALF_BODY_TYPE);\r\n+        //_txtrun.getRichTextRuns()[0].setFlag(false, 0, false);\r\n     }\r\n \r\n     protected EscherContainerRecord createSpContainer(boolean isChild){\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/src/org/apache/poi/hslf/model/TableCell.java",
                "sha": "71833678a51a7daf8d78a563811f49e2fac862e7",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java",
                "patch": "@@ -20,9 +20,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \r\n import java.io.FileOutputStream;\r\n import java.io.File;\r\n+import java.io.IOException;\r\n import java.awt.*;\r\n+import java.awt.image.BufferedImage;\r\n \r\n import org.apache.poi.hslf.usermodel.SlideShow;\r\n+import org.apache.poi.hslf.usermodel.PictureData;\r\n import org.apache.poi.hslf.HSLFSlideShow;\r\n import org.apache.poi.ddf.EscherBSERecord;\r\n \r\n@@ -70,4 +73,24 @@ public void testMultiplePictures() throws Exception {\n \r\n     }\r\n \r\n+    /**\r\n+     * Picture#getEscherBSERecord threw NullPointerException if EscherContainerRecord.BSTORE_CONTAINER\r\n+     * was not found. The correct behaviour is to return null.\r\n+     */\r\n+    public void test46122() throws IOException {\r\n+        SlideShow ppt = new SlideShow();\r\n+        Slide slide = ppt.createSlide();\r\n+\r\n+        Picture pict = new Picture(-1); //index to non-existing picture data\r\n+        pict.setSheet(slide);\r\n+        PictureData data = pict.getPictureData();\r\n+        assertNull(data);\r\n+\r\n+        BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);\r\n+        Graphics2D graphics = img.createGraphics();\r\n+        pict.draw(graphics);\r\n+\r\n+        assertTrue(\"no errors rendering Picture with null data\", true);\r\n+    }\r\n+\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java",
                "sha": "b4a362ae8dced821e36ae1817b46df838bb6d0a1",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java",
                "patch": "@@ -24,6 +24,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \r\n import org.apache.poi.hslf.usermodel.SlideShow;\r\n import org.apache.poi.hslf.HSLFSlideShow;\r\n+import org.apache.poi.hslf.record.TextHeaderAtom;\r\n \r\n /**\r\n  * Test <code>Table</code> object.\r\n@@ -43,6 +44,10 @@ public void testShapeFactory() throws Exception {\n         Table tbl = new Table(2, 5);\r\n         slide.addShape(tbl);\r\n \r\n+        TableCell cell = tbl.getCell(0, 0);\r\n+        //table cells have type=TextHeaderAtom.OTHER_TYPE, see bug #46033\r\n+        assertEquals(TextHeaderAtom.OTHER_TYPE, cell.getTextRun().getRunType());\r\n+\r\n         assertTrue(slide.getShapes()[0] instanceof Table);\r\n         Table tbl2 = (Table)slide.getShapes()[0];\r\n         assertEquals(tbl.getNumberOfColumns(), tbl2.getNumberOfColumns());\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java",
                "sha": "8a9cf7da27a36dea4e2e6b09e3b7b93aeed3e320",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestRecordFactory.java",
                "changes": 49,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestRecordFactory.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 26,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestRecordFactory.java",
                "patch": "@@ -48,7 +48,6 @@ public void testBasicRecordConstruction() {\n         byte[]   data    = {\n             0, 6, 5, 0, -2, 28, -51, 7, -55, 64, 0, 0, 6, 1, 0, 0\n         };\n-        short    size    = 16;\n         Record[] record  = RecordFactory.createRecord(TestcaseRecordInputStream.create(recType, data));\n \n         assertEquals(BOFRecord.class.getName(),\n@@ -64,7 +63,6 @@ public void testBasicRecordConstruction() {\n         assertEquals(5, bofRecord.getType());\n         assertEquals(1536, bofRecord.getVersion());\n         recType = MMSRecord.sid;\n-        size    = 2;\n         data    = new byte[]\n         {\n             0, 0\n@@ -93,7 +91,6 @@ public void testSpecial() {\n         byte[]   data    = {\n             0, 0, 0, 0, 21, 0, 0, 0, 0, 0\n         };\n-        short    size    = 10;\n         Record[] record  = RecordFactory.createRecord(TestcaseRecordInputStream.create(recType, data));\n \n         assertEquals(NumberRecord.class.getName(),\n@@ -154,34 +151,34 @@ public void testContinuedUnknownRecord() {\n      */\n     public void testMixedContinue() throws Exception {\n         /**\n-         *  Taken from a real test sample file 39512.xls. See Bug 39512 for details.\n+         *  Adapted from a real test sample file 39512.xls (Offset 0x4854). \n+         *  See Bug 39512 for details.\n          */\n         String dump =\n                 //OBJ\n-                \"5D, 00, 48, 00, 15, 00, 12, 00, 0C, 00, 3C, 00, 11, 00, A0, 2E, 03, 01, CC, 42, \" +\n-                \"CF, 00, 00, 00, 00, 00, 0A, 00, 0C, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, \" +\n-                \"03, 00, 0B, 00, 06, 00, 28, 01, 03, 01, 00, 00, 12, 00, 08, 00, 00, 00, 00, 00, \" +\n-                \"00, 00, 03, 00, 11, 00, 04, 00, 3D, 00, 00, 00, 00, 00, 00, 00, \" +\n+                \"5D 00 48 00 15 00 12 00 0C 00 3C 00 11 00 A0 2E 03 01 CC 42 \" +\n+                \"CF 00 00 00 00 00 0A 00 0C 00 00 00 00 00 00 00 00 00 00 00 \" +\n+                \"03 00 0B 00 06 00 28 01 03 01 00 00 12 00 08 00 00 00 00 00 \" +\n+                \"00 00 03 00 11 00 04 00 3D 00 00 00 00 00 00 00 \" +\n                  //MSODRAWING\n-                \"EC, 00, 08, 00, 00, 00, 0D, F0, 00, 00, 00, 00, \" +\n-                //TXO\n-                \"B6, 01, 12, 00, 22, 02, 00, 00, 00, 00, 00, 00, 00, 00, 10, 00, 10, 00, 00, 00, \" +\n-                \"00, 00, 3C, 00, 21, 00, 01, 4F, 00, 70, 00, 74, 00, 69, 00, 6F, 00, 6E, 00, 20, \" +\n-                \"00, 42, 00, 75, 00, 74, 00, 74, 00, 6F, 00, 6E, 00, 20, 00, 33, 00, 39, 00, 3C, \" +\n-                \"00, 10, 00, 00, 00, 05, 00, 00, 00, 00, 00, 10, 00, 00, 00, 00, 00, 00, 00, \" +\n-                //CONTINUE\n-                \"3C, 00, 7E, 00, 0F, 00, 04, F0, 7E, 00, 00, 00, 92, 0C, 0A, F0, 08, 00, 00, 00, \" +\n-                \"3D, 04, 00, 00, 00, 0A, 00, 00, A3, 00, 0B, F0, 3C, 00, 00, 00, 7F, 00, 00, 01, \" +\n-                \"00, 01, 80, 00, 8C, 01, 03, 01, 85, 00, 01, 00, 00, 00, 8B, 00, 02, 00, 00, 00, \" +\n-                \"BF, 00, 08, 00, 1A, 00, 7F, 01, 29, 00, 29, 00, 81, 01, 41, 00, 00, 08, BF, 01, \" +\n-                \"00, 00, 10, 00, C0, 01, 40, 00, 00, 08, FF, 01, 00, 00, 08, 00, 00, 00, 10, F0, \" +\n-                \"12, 00, 00, 00, 02, 00, 02, 00, A0, 03, 18, 00, B5, 00, 04, 00, 30, 02, 1A, 00, \" +\n-                \"00, 00, 00, 00, 11, F0, 00, 00, 00, 00, \" +\n+                \"EC 00 08 00 00 00 0D F0 00 00 00 00 \" +\n+                //TXO (and 2 trailing CONTINUE records)\n+                \"B6 01 12 00 22 02 00 00 00 00 00 00 00 00 10 00 10 00 00 00 00 00 \" +\n+                \"3C 00 11 00 00 4F 70 74 69 6F 6E 20 42 75 74 74 6F 6E 20 33 39 \" +\n+                \"3C 00 10 00 00 00 05 00 00 00 00 00 10 00 00 00 00 00 00 00 \" +\n+                // another CONTINUE\n+                \"3C 00 7E 00 0F 00 04 F0 7E 00 00 00 92 0C 0A F0 08 00 00 00 \" +\n+                \"3D 04 00 00 00 0A 00 00 A3 00 0B F0 3C 00 00 00 7F 00 00 01 \" +\n+                \"00 01 80 00 8C 01 03 01 85 00 01 00 00 00 8B 00 02 00 00 00 \" +\n+                \"BF 00 08 00 1A 00 7F 01 29 00 29 00 81 01 41 00 00 08 BF 01 \" +\n+                \"00 00 10 00 C0 01 40 00 00 08 FF 01 00 00 08 00 00 00 10 F0 \" +\n+                \"12 00 00 00 02 00 02 00 A0 03 18 00 B5 00 04 00 30 02 1A 00 \" +\n+                \"00 00 00 00 11 F0 00 00 00 00 \" +\n                 //OBJ\n-                \"5D, 00, 48, 00, 15, 00, 12, 00, 0C, 00, 3D, 00, 11, 00, 8C, 01, 03, 01, C8, 59, CF, 00, 00, \" +\n-                \"00, 00, 00, 0A, 00, 0C, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 03, 00, 0B, 00, 06, 00, \" +\n-                \"7C, 16, 03, 01, 00, 00, 12, 00, 08, 00, 00, 00, 00, 00, 00, 00, 03, 00, 11, 00, 04, 00, 01, \" +\n-                \"00, 00, 00, 00, 00, 00, 00\";\n+                \"5D 00 48 00 15 00 12 00 0C 00 3D 00 11 00 8C 01 03 01 C8 59 CF 00 00 \" +\n+                \"00 00 00 0A 00 0C 00 00 00 00 00 00 00 00 00 00 00 03 00 0B 00 06 00 \" +\n+                \"7C 16 03 01 00 00 12 00 08 00 00 00 00 00 00 00 03 00 11 00 04 00 01 \" +\n+                \"00 00 00 00 00 00 00\";\n         byte[] data = HexRead.readFromString(dump);\n \n         List records = RecordFactory.createRecords(new ByteArrayInputStream(data));",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestRecordFactory.java",
                "sha": "b54b4032d6434937b70d2f3a7226602537e83e5c",
                "status": "modified"
            },
            {
                "additions": 91,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestSSTRecordSizeCalculator.java",
                "changes": 210,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestSSTRecordSizeCalculator.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 119,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestSSTRecordSizeCalculator.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -15,133 +14,106 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.hssf.record;\n \n import junit.framework.TestCase;\n \n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n import org.apache.poi.util.IntMapper;\n \n /**\n  * Tests that records size calculates correctly.\n- *\n+ * \n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n-public class TestSSTRecordSizeCalculator\n-        extends TestCase\n-{\n-    private static final String SMALL_STRING = \"Small string\";\n-    private static final int COMPRESSED_PLAIN_STRING_OVERHEAD = 3;\n-//    private List recordLengths;\n-    private IntMapper strings;\n-    private static final int OPTION_FIELD_SIZE = 1;\n-\n-    public TestSSTRecordSizeCalculator( String s )\n-    {\n-        super( s );\n-    }\n-\n-    public void testBasic()\n-            throws Exception\n-    {\n-        strings.add(makeUnicodeString(SMALL_STRING));\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(strings);\n-        assertEquals(SSTRecord.SST_RECORD_OVERHEAD + COMPRESSED_PLAIN_STRING_OVERHEAD + SMALL_STRING.length(),\n-                calculator.getRecordSize());\n-    }\n-\n-    public void testBigStringAcrossUnicode()\n-            throws Exception\n-    {\n-        String bigString = new String(new char[SSTRecord.MAX_DATA_SPACE + 100]);\n-        strings.add(makeUnicodeString(bigString));\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(strings);\n-        assertEquals(SSTRecord.SST_RECORD_OVERHEAD\n-                + COMPRESSED_PLAIN_STRING_OVERHEAD\n-                + SSTRecord.MAX_DATA_SPACE\n-                + SSTRecord.STD_RECORD_OVERHEAD\n-                + OPTION_FIELD_SIZE\n-                + 100,\n-                calculator.getRecordSize());\n-    }\n-\n-    public void testPerfectFit()\n-            throws Exception\n-    {\n-        String perfectFit = new String(new char[SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD]);\n-        strings.add(makeUnicodeString(perfectFit));\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(strings);\n-        assertEquals(SSTRecord.SST_RECORD_OVERHEAD\n-                + COMPRESSED_PLAIN_STRING_OVERHEAD\n-                + perfectFit.length(),\n-                calculator.getRecordSize());\n-    }\n-\n-    public void testJustOversized()\n-            throws Exception\n-    {\n-        String tooBig = new String(new char[SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD + 1]);\n-        strings.add(makeUnicodeString(tooBig));\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(strings);\n-        assertEquals(SSTRecord.SST_RECORD_OVERHEAD\n-                + COMPRESSED_PLAIN_STRING_OVERHEAD\n-                + tooBig.length() - 1\n-                // continue record\n-                + SSTRecord.STD_RECORD_OVERHEAD\n-                + OPTION_FIELD_SIZE\n-                + 1,\n-                calculator.getRecordSize());\n-\n-    }\n-\n-    public void testSecondStringStartsOnNewContinuation()\n-            throws Exception\n-    {\n-        String perfectFit = new String(new char[SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD]);\n-        strings.add(makeUnicodeString(perfectFit));\n-        strings.add(makeUnicodeString(SMALL_STRING));\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(strings);\n-        assertEquals(SSTRecord.SST_RECORD_OVERHEAD\n-                + SSTRecord.MAX_DATA_SPACE\n-                // second string\n-                + SSTRecord.STD_RECORD_OVERHEAD\n-                + COMPRESSED_PLAIN_STRING_OVERHEAD\n-                + SMALL_STRING.length(),\n-                calculator.getRecordSize());\n-    }\n-\n-    public void testHeaderCrossesNormalContinuePoint()\n-            throws Exception\n-    {\n-        String almostPerfectFit = new String(new char[SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD - 2]);\n-        strings.add(makeUnicodeString(almostPerfectFit));\n-        String oneCharString = new String(new char[1]);\n-        strings.add(makeUnicodeString(oneCharString));\n-        SSTRecordSizeCalculator calculator = new SSTRecordSizeCalculator(strings);\n-        assertEquals(SSTRecord.SST_RECORD_OVERHEAD\n-                + COMPRESSED_PLAIN_STRING_OVERHEAD\n-                + almostPerfectFit.length()\n-                // second string\n-                + SSTRecord.STD_RECORD_OVERHEAD\n-                + COMPRESSED_PLAIN_STRING_OVERHEAD\n-                + oneCharString.length(),\n-                calculator.getRecordSize());\n-\n-    }\n-\n-\n-    public void setUp()\n-    {\n-        strings = new IntMapper();\n-    }\n-\n-\n-    private UnicodeString makeUnicodeString( String s )\n-    {\n-      UnicodeString st = new UnicodeString(s);\n-      st.setOptionFlags((byte)0);\n-      return st;\n-    }\n-\n+public final class TestSSTRecordSizeCalculator extends TestCase {\n+\tprivate static final String SMALL_STRING = \"Small string\";\n+\tprivate static final int COMPRESSED_PLAIN_STRING_OVERHEAD = 3;\n+\tprivate static final int OPTION_FIELD_SIZE = 1;\n+\t\n+\tprivate final IntMapper strings = new IntMapper();\n+\n+\t\n+\tprivate void confirmSize(int expectedSize) {\n+\t\tContinuableRecordOutput cro = ContinuableRecordOutput.createForCountingOnly();\n+\t\tSSTSerializer ss = new SSTSerializer(strings, 0, 0);\n+\t\tss.serialize(cro);\n+\t\tassertEquals(expectedSize, cro.getTotalSize());\n+\t}\n+\n+\tpublic void testBasic() {\n+\t\tstrings.add(makeUnicodeString(SMALL_STRING));\n+\t\tconfirmSize(SSTRecord.SST_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ SMALL_STRING.length());\n+\t}\n+\n+\tpublic void testBigStringAcrossUnicode() {\n+\t\tint bigString = SSTRecord.MAX_DATA_SPACE + 100;\n+\t\tstrings.add(makeUnicodeString(bigString));\n+\t\tconfirmSize(SSTRecord.SST_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ SSTRecord.MAX_DATA_SPACE\n+\t\t\t\t+ SSTRecord.STD_RECORD_OVERHEAD\n+\t\t\t\t+ OPTION_FIELD_SIZE\n+\t\t\t\t+ 100);\n+\t}\n+\n+\tpublic void testPerfectFit() {\n+\t\tint perfectFit = SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD;\n+\t\tstrings.add(makeUnicodeString(perfectFit));\n+\t\tconfirmSize(SSTRecord.SST_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ perfectFit);\n+\t}\n+\n+\tpublic void testJustOversized() {\n+\t\tint tooBig = SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD + 1;\n+\t\tstrings.add(makeUnicodeString(tooBig));\n+\t\tconfirmSize(SSTRecord.SST_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ tooBig - 1\n+\t\t\t\t// continue record\n+\t\t\t\t+ SSTRecord.STD_RECORD_OVERHEAD\n+\t\t\t\t+ OPTION_FIELD_SIZE + 1);\n+\n+\t}\n+\n+\tpublic void testSecondStringStartsOnNewContinuation() {\n+\t\tint perfectFit = SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD;\n+\t\tstrings.add(makeUnicodeString(perfectFit));\n+\t\tstrings.add(makeUnicodeString(SMALL_STRING));\n+\t\tconfirmSize(SSTRecord.SST_RECORD_OVERHEAD\n+\t\t\t\t+ SSTRecord.MAX_DATA_SPACE\n+\t\t\t\t// second string\n+\t\t\t\t+ SSTRecord.STD_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ SMALL_STRING.length());\n+\t}\n+\n+\tpublic void testHeaderCrossesNormalContinuePoint() {\n+\t\tint almostPerfectFit = SSTRecord.MAX_DATA_SPACE - COMPRESSED_PLAIN_STRING_OVERHEAD - 2;\n+\t\tstrings.add(makeUnicodeString(almostPerfectFit));\n+\t\tString oneCharString = new String(new char[1]);\n+\t\tstrings.add(makeUnicodeString(oneCharString));\n+\t\tconfirmSize(SSTRecord.SST_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ almostPerfectFit\n+\t\t\t\t// second string\n+\t\t\t\t+ SSTRecord.STD_RECORD_OVERHEAD\n+\t\t\t\t+ COMPRESSED_PLAIN_STRING_OVERHEAD\n+\t\t\t\t+ oneCharString.length());\n+\n+\t}\n+\tprivate static UnicodeString makeUnicodeString(int size) {\n+\t\tString s = new String(new char[size]);\n+\t\treturn makeUnicodeString(s);\n+\t}\n+\n+\tprivate static UnicodeString makeUnicodeString(String s) {\n+\t\tUnicodeString st = new UnicodeString(s);\n+\t\tst.setOptionFlags((byte) 0);\n+\t\treturn st;\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestSSTRecordSizeCalculator.java",
                "sha": "2a0830ac79ddfd582ffdc83ea0fb03aab721955d",
                "status": "modified"
            },
            {
                "additions": 68,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestStringRecord.java",
                "changes": 93,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestStringRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 25,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestStringRecord.java",
                "patch": "@@ -18,6 +18,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n package org.apache.poi.hssf.record;\n \n \n+import org.apache.poi.util.HexRead;\n+import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.util.LittleEndianByteArrayInputStream;\n+import org.apache.poi.util.LittleEndianInput;\n+\n+import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n \n /**\n@@ -28,29 +34,66 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n public final class TestStringRecord extends TestCase {\n-    byte[] data = new byte[] {\n-        (byte)0x0B,(byte)0x00,   // length\n-        (byte)0x00,              // option\n-        // string\n-        (byte)0x46,(byte)0x61,(byte)0x68,(byte)0x72,(byte)0x7A,(byte)0x65,(byte)0x75,(byte)0x67,(byte)0x74,(byte)0x79,(byte)0x70\n-    };\n-\n-    public void testLoad() {\n-\n-        StringRecord record = new StringRecord(TestcaseRecordInputStream.create(0x207, data));\n-        assertEquals( \"Fahrzeugtyp\", record.getString());\n-\n-        assertEquals( 18, record.getRecordSize() );\n-    }\n-\n-    public void testStore()\n-    {\n-        StringRecord record = new StringRecord();\n-        record.setString(\"Fahrzeugtyp\");\n-\n-        byte [] recordBytes = record.serialize();\n-        assertEquals(recordBytes.length - 4, data.length);\n-        for (int i = 0; i < data.length; i++)\n-            assertEquals(\"At offset \" + i, data[i], recordBytes[i+4]);\n-    }\n+\tprivate static final byte[] data = HexRead.readFromString(\n+\t\t\t\"0B 00 \" + // length\n+\t\t\t\"00 \" +    // option\n+\t\t\t// string\n+\t\t\t\"46 61 68 72 7A 65 75 67 74 79 70\"\n+\t);\n+\n+\tpublic void testLoad() {\n+\n+\t\tStringRecord record = new StringRecord(TestcaseRecordInputStream.create(0x207, data));\n+\t\tassertEquals( \"Fahrzeugtyp\", record.getString());\n+\n+\t\tassertEquals( 18, record.getRecordSize() );\n+\t}\n+\n+\tpublic void testStore() {\n+\t\tStringRecord record = new StringRecord();\n+\t\trecord.setString(\"Fahrzeugtyp\");\n+\n+\t\tbyte [] recordBytes = record.serialize();\n+\t\tassertEquals(recordBytes.length - 4, data.length);\n+\t\tfor (int i = 0; i < data.length; i++)\n+\t\t\tassertEquals(\"At offset \" + i, data[i], recordBytes[i+4]);\n+\t}\n+    \n+\tpublic void testContinue() {\n+\t\tint MAX_BIFF_DATA = RecordInputStream.MAX_RECORD_DATA_SIZE;\n+\t\tint TEXT_LEN = MAX_BIFF_DATA + 1000; // deliberately over-size\n+\t\tString textChunk = \"ABCDEGGHIJKLMNOP\"; // 16 chars\n+\t\tStringBuffer sb = new StringBuffer(16384);\n+\t\twhile (sb.length() < TEXT_LEN) {\n+\t\t\tsb.append(textChunk);\n+\t\t}\n+\t\tsb.setLength(TEXT_LEN);\n+\n+\t\tStringRecord sr = new StringRecord();\n+\t\tsr.setString(sb.toString());\n+\t\tbyte[] ser = sr.serialize();\n+\t\tassertEquals(StringRecord.sid, LittleEndian.getUShort(ser, 0));\n+\t\tif (LittleEndian.getUShort(ser, 2) > MAX_BIFF_DATA) {\n+\t\t\tthrow new AssertionFailedError(\n+\t\t\t\t\t\"StringRecord should have been split with a continue record\");\n+\t\t}\n+\t\t// Confirm expected size of first record, and ushort strLen.\n+\t\tassertEquals(MAX_BIFF_DATA, LittleEndian.getUShort(ser, 2));\n+\t\tassertEquals(TEXT_LEN, LittleEndian.getUShort(ser, 4));\n+\n+\t\t// Confirm first few bytes of ContinueRecord\n+\t\tLittleEndianInput crIn = new LittleEndianByteArrayInputStream(ser, (MAX_BIFF_DATA + 4));\n+\t\tint nCharsInFirstRec = MAX_BIFF_DATA - (2 + 1); // strLen, optionFlags\n+\t\tint nCharsInSecondRec = TEXT_LEN - nCharsInFirstRec;\n+\t\tassertEquals(ContinueRecord.sid, crIn.readUShort());\n+\t\tassertEquals(1 + nCharsInSecondRec, crIn.readUShort());\n+\t\tassertEquals(0, crIn.readUByte());\n+\t\tassertEquals('N', crIn.readUByte());\n+\t\tassertEquals('O', crIn.readUByte());\n+\n+\t\t// re-read and make sure string value is the same\n+\t\tRecordInputStream in = TestcaseRecordInputStream.create(ser);\n+\t\tStringRecord sr2 = new StringRecord(in);\n+\t\tassertEquals(sb.toString(), sr2.getString());\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestStringRecord.java",
                "sha": "ec7b84c69374ec2a178bf39252a9b8ddacb5a133",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestSupBookRecord.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestSupBookRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 8,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestSupBookRecord.java",
                "patch": "@@ -69,10 +69,10 @@ public void testLoadER() {\n         assertEquals( 34, record.getRecordSize() );  //sid+size+data\n         \n         assertEquals(\"testURL\", record.getURL());\n-        UnicodeString[] sheetNames = record.getSheetNames();\n+        String[] sheetNames = record.getSheetNames();\n         assertEquals(2, sheetNames.length);\n-        assertEquals(\"Sheet1\", sheetNames[0].getString());\n-        assertEquals(\"Sheet2\", sheetNames[1].getString());\n+        assertEquals(\"Sheet1\", sheetNames[0]);\n+        assertEquals(\"Sheet2\", sheetNames[1]);\n     }\n     \n     /**\n@@ -97,11 +97,8 @@ public void testStoreIR() {\n     }   \n     \n     public void testStoreER() {\n-        UnicodeString url = new UnicodeString(\"testURL\");\n-        UnicodeString[] sheetNames = {\n-                new UnicodeString(\"Sheet1\"),\n-                new UnicodeString(\"Sheet2\"),\n-        };\n+        String url = \"testURL\";\n+        String[] sheetNames = { \"Sheet1\", \"Sheet2\", };\n         SupBookRecord record = SupBookRecord.createExternalReferences(url, sheetNames);\n \n         TestcaseRecordInputStream.confirmRecordEncoding(0x01AE, dataER, record.serialize());",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestSupBookRecord.java",
                "sha": "82ac62f70c80002d63d91baca693b077d35021e1",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestTextObjectBaseRecord.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestTextObjectBaseRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 4,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestTextObjectBaseRecord.java",
                "patch": "@@ -44,9 +44,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n         \"00 00\" +\n         \"00 00 \" +\n         \"3C 00 \" + // ContinueRecord.sid\n-        \"05 00 \" + // size 5\n-        \"01 \" + // unicode uncompressed\n-        \"41 00 42 00 \" + // 'AB'\n+        \"03 00 \" + // size 3\n+        \"00 \" + // unicode compressed\n+        \"41 42 \" + // 'AB'\n         \"3C 00 \" + // ContinueRecord.sid\n         \"10 00 \" + // size 16 \n         \"00 00 18 00 00 00 00 00 \" +\n@@ -63,7 +63,7 @@ public void testLoad() {\n         assertEquals(true, record.isTextLocked());\n         assertEquals(TextObjectRecord.TEXT_ORIENTATION_ROT_RIGHT, record.getTextOrientation());\n \n-        assertEquals(51, record.getRecordSize() );\n+        assertEquals(49, record.getRecordSize() );\n     }\n \n     public void testStore()",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestTextObjectBaseRecord.java",
                "sha": "674279388c4a16b7c555236a2eb5bcddfadb1ad4",
                "status": "modified"
            },
            {
                "additions": 32,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestTextObjectRecord.java",
                "changes": 66,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestTextObjectRecord.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 34,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestTextObjectRecord.java",
                "patch": "@@ -37,16 +37,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n public final class TestTextObjectRecord extends TestCase {\r\n \r\n     private static final byte[] simpleData = HexRead.readFromString(\r\n-    \t\"B6 01 12 00 \" +\r\n-    \t\"12 02 00 00 00 00 00 00\" +\r\n-    \t\"00 00 0D 00 08 00\t00 00\" +\r\n-    \t\"00 00 \" +\r\n-    \t\"3C 00 1B 00 \" +\r\n-    \t\"01 48 00 65 00 6C 00 6C 00 6F 00 \" +\r\n-    \t\"2C 00 20 00 57 00 6F 00 72 00 6C \" +\r\n-    \t\"00 64 00 21 00 \" + \r\n-    \t\"3C 00 08 \" +\r\n-    \t\"00 0D 00 00 00 00 00 00 00\"\r\n+        \"B6 01 12 00 \" +\r\n+        \"12 02 00 00 00 00 00 00\" +\r\n+        \"00 00 0D 00 08 00    00 00\" +\r\n+        \"00 00 \" +\r\n+        \"3C 00 0E 00 \" +\r\n+        \"00 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 \" +\r\n+        \"3C 00 08 \" +\r\n+        \"00 0D 00 00 00 00 00 00 00\"\r\n     );\r\n \r\n \r\n@@ -92,12 +90,12 @@ public void testWriteEmpty() {\n         record.setStr(str);\r\n \r\n         byte [] ser = record.serialize();\r\n-        \r\n+\r\n         int formatDataLen = LittleEndian.getUShort(ser, 16);\r\n         assertEquals(\"formatDataLength\", 0, formatDataLen);\r\n \r\n         assertEquals(22, ser.length); // just the TXO record\r\n-        \r\n+\r\n         //read again\r\n         RecordInputStream is = TestcaseRecordInputStream.create(ser);\r\n         record = new TextObjectRecord(is);\r\n@@ -152,38 +150,38 @@ public void testClone() {\n         byte[] cln = cloned.serialize();\r\n         assertTrue(Arrays.equals(src, cln));\r\n     }\r\n-    \r\n-    /** similar to {@link #simpleData} but with link formula at end of TXO rec*/ \r\n+\r\n+    /** similar to {@link #simpleData} but with link formula at end of TXO rec*/\r\n     private static final byte[] linkData = HexRead.readFromString(\r\n-        \t\"B6 01 \" + // TextObjectRecord.sid\r\n-        \t\"1E 00 \" + // size 18\r\n-    \t    \"44 02 02 00 00 00 00 00\" +\r\n-    \t    \"00 00 \" +\r\n-    \t    \"02 00 \" + // strLen 2\r\n-    \t    \"10 00 \" + // 16 bytes for 2 format runs\r\n-    \t    \"00 00 00 00 \" +\r\n+            \"B6 01 \" + // TextObjectRecord.sid\r\n+            \"1E 00 \" + // size 18\r\n+            \"44 02 02 00 00 00 00 00\" +\r\n+            \"00 00 \" +\r\n+            \"02 00 \" + // strLen 2\r\n+            \"10 00 \" + // 16 bytes for 2 format runs\r\n+            \"00 00 00 00 \" +\r\n \r\n             \"05 00 \" +          // formula size\r\n             \"D4 F0 8A 03 \" +    // unknownInt\r\n             \"24 01 00 13 C0 \" + //tRef(T2)\r\n             \"13 \" +             // ??\r\n \r\n-        \t\"3C 00 \" + // ContinueRecord.sid\r\n-    \t    \"05 00 \" + // size 5\r\n-    \t    \"01 \" + // unicode uncompressed\r\n-    \t    \"41 00 42 00 \" + // 'AB'\r\n-        \t\"3C 00 \" + // ContinueRecord.sid\r\n-    \t    \"10 00 \" + // size 16 \r\n-    \t    \"00 00 18 00 00 00 00 00 \" +\r\n-    \t    \"02 00 00 00 00 00 00 00 \" \r\n+            \"3C 00 \" + // ContinueRecord.sid\r\n+            \"03 00 \" + // size 3\r\n+            \"00 \" + // unicode compressed\r\n+            \"41 42 \" + // 'AB'\r\n+            \"3C 00 \" + // ContinueRecord.sid\r\n+            \"10 00 \" + // size 16\r\n+            \"00 00 18 00 00 00 00 00 \" +\r\n+            \"02 00 00 00 00 00 00 00 \"\r\n         );\r\n-    \r\n-    \r\n+\r\n+\r\n     public void testLinkFormula() {\r\n         RecordInputStream is = new RecordInputStream(new ByteArrayInputStream(linkData));\r\n         is.nextRecord();\r\n         TextObjectRecord rec = new TextObjectRecord(is);\r\n-\t\t\r\n+\r\n         Ptg ptg = rec.getLinkRefPtg();\r\n         assertNotNull(ptg);\r\n         assertEquals(RefPtg.class, ptg.getClass());\r\n@@ -193,6 +191,6 @@ public void testLinkFormula() {\n         byte [] data2 = rec.serialize();\r\n         assertEquals(linkData.length, data2.length);\r\n         assertTrue(Arrays.equals(linkData, data2));\r\n-\t}\r\n-    \r\n+    }\r\n+\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestTextObjectRecord.java",
                "sha": "39ea8ba82039b9f32c64c7e1b538f86538ddcfbd",
                "status": "modified"
            },
            {
                "additions": 65,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestUnicodeString.java",
                "changes": 118,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestUnicodeString.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 53,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestUnicodeString.java",
                "patch": "@@ -15,141 +15,153 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    limitations under the License.\n ==================================================================== */\n \n-\n package org.apache.poi.hssf.record;\n \n-import org.apache.poi.util.HexRead;\n-\n import junit.framework.TestCase;\n \n+import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n+\n /**\n- * Tests that records size calculates correctly.\n+ * Tests that {@link UnicodeString} record size calculates correctly.  The record size\n+ * is used when serializing {@link SSTRecord}s.\n  *\n  * @author Jason Height (jheight at apache.org)\n  */\n public final class TestUnicodeString extends TestCase {\n+    private static final int MAX_DATA_SIZE = RecordInputStream.MAX_RECORD_DATA_SIZE;\n \n+    /** a 4 character string requiring 16 bit encoding */\n+    private static final String STR_16_BIT = \"A\\u591A\\u8A00\\u8A9E\";\n+\n+    private static void confirmSize(int expectedSize, UnicodeString s) {\n+        confirmSize(expectedSize, s, 0);\n+    }\n+    /**\n+     * Note - a value of zero for <tt>amountUsedInCurrentRecord</tt> would only ever occur just\n+     * after a {@link ContinueRecord} had been started.  In the initial {@link SSTRecord} this \n+     * value starts at 8 (for the first {@link UnicodeString} written).  In general, it can be\n+     * any value between 0 and {@link #MAX_DATA_SIZE}\n+     */\n+    private static void confirmSize(int expectedSize, UnicodeString s, int amountUsedInCurrentRecord) {\n+        ContinuableRecordOutput out = ContinuableRecordOutput.createForCountingOnly();\n+        out.writeContinue();\n+        for(int i=amountUsedInCurrentRecord; i>0; i--) {\n+            out.writeByte(0);\n+        }\n+        int size0 = out.getTotalSize();\n+        s.serialize(out);\n+        int size1 = out.getTotalSize();\n+        int actualSize = size1-size0;\n+        assertEquals(expectedSize, actualSize);\n+    }\n \n     public void testSmallStringSize() {\n         //Test a basic string\n         UnicodeString s = makeUnicodeString(\"Test\");\n-        UnicodeString.UnicodeRecordStats stats = new UnicodeString.UnicodeRecordStats();\n-        s.getRecordSize(stats);\n-        assertEquals(7, stats.recordSize);\n+        confirmSize(7, s);\n \n         //Test a small string that is uncompressed\n+        s = makeUnicodeString(STR_16_BIT);\n         s.setOptionFlags((byte)0x01);\n-        stats = new UnicodeString.UnicodeRecordStats();\n-        s.getRecordSize(stats);\n-        assertEquals(11, stats.recordSize);\n+        confirmSize(11, s);\n \n         //Test a compressed small string that has rich text formatting\n+        s.setString(\"Test\");\n         s.setOptionFlags((byte)0x8);\n         UnicodeString.FormatRun r = new UnicodeString.FormatRun((short)0,(short)1);\n         s.addFormatRun(r);\n         UnicodeString.FormatRun r2 = new UnicodeString.FormatRun((short)2,(short)2);\n         s.addFormatRun(r2);\n-        stats = new UnicodeString.UnicodeRecordStats();\n-        s.getRecordSize(stats);\n-        assertEquals(17, stats.recordSize);\n+        confirmSize(17, s);\n \n         //Test a uncompressed small string that has rich text formatting\n+        s.setString(STR_16_BIT);\n         s.setOptionFlags((byte)0x9);\n-        stats = new UnicodeString.UnicodeRecordStats();\n-        s.getRecordSize(stats);\n-        assertEquals(21, stats.recordSize);\n+        confirmSize(21, s);\n \n         //Test a compressed small string that has rich text and extended text\n+        s.setString(\"Test\");\n         s.setOptionFlags((byte)0xC);\n         s.setExtendedRst(new byte[]{(byte)0x1,(byte)0x2,(byte)0x3,(byte)0x4,(byte)0x5});\n-        stats = new UnicodeString.UnicodeRecordStats();\n-        s.getRecordSize(stats);\n-        assertEquals(26, stats.recordSize);\n+        confirmSize(26, s);\n \n         //Test a uncompressed small string that has rich text and extended text\n+        s.setString(STR_16_BIT);\n         s.setOptionFlags((byte)0xD);\n-        stats = new UnicodeString.UnicodeRecordStats();\n-        s.getRecordSize(stats);\n-        assertEquals(30, stats.recordSize);\n+        confirmSize(30, s);\n     }\n \n     public void testPerfectStringSize() {\n       //Test a basic string\n-      UnicodeString s = makeUnicodeString(SSTRecord.MAX_RECORD_SIZE-2-1);\n-      UnicodeString.UnicodeRecordStats stats = new UnicodeString.UnicodeRecordStats();\n-      s.getRecordSize(stats);\n-      assertEquals(SSTRecord.MAX_RECORD_SIZE, stats.recordSize);\n+      UnicodeString s = makeUnicodeString(MAX_DATA_SIZE-2-1);\n+      confirmSize(MAX_DATA_SIZE, s);\n \n       //Test an uncompressed string\n       //Note that we can only ever get to a maximim size of 8227 since an uncompressed\n       //string is writing double bytes.\n-      s = makeUnicodeString((SSTRecord.MAX_RECORD_SIZE-2-1)/2);\n+      s = makeUnicodeString((MAX_DATA_SIZE-2-1)/2, true);\n       s.setOptionFlags((byte)0x1);\n-      stats = new UnicodeString.UnicodeRecordStats();\n-      s.getRecordSize(stats);\n-      assertEquals(SSTRecord.MAX_RECORD_SIZE-1, stats.recordSize);\n+      confirmSize(MAX_DATA_SIZE-1, s);\n     }\n \n     public void testPerfectRichStringSize() {\n       //Test a rich text string\n-      UnicodeString s = makeUnicodeString(SSTRecord.MAX_RECORD_SIZE-2-1-8-2);\n+      UnicodeString s = makeUnicodeString(MAX_DATA_SIZE-2-1-8-2);\n       s.addFormatRun(new UnicodeString.FormatRun((short)1,(short)0));\n       s.addFormatRun(new UnicodeString.FormatRun((short)2,(short)1));\n-      UnicodeString.UnicodeRecordStats stats = new UnicodeString.UnicodeRecordStats();\n       s.setOptionFlags((byte)0x8);\n-      s.getRecordSize(stats);\n-      assertEquals(SSTRecord.MAX_RECORD_SIZE, stats.recordSize);\n+      confirmSize(MAX_DATA_SIZE, s);\n \n       //Test an uncompressed rich text string\n-      //Note that we can only ever get to a maximim size of 8227 since an uncompressed\n+      //Note that we can only ever get to a maximum size of 8227 since an uncompressed\n       //string is writing double bytes.\n-      s = makeUnicodeString((SSTRecord.MAX_RECORD_SIZE-2-1-8-2)/2);\n+      s = makeUnicodeString((MAX_DATA_SIZE-2-1-8-2)/2, true);\n       s.addFormatRun(new UnicodeString.FormatRun((short)1,(short)0));\n       s.addFormatRun(new UnicodeString.FormatRun((short)2,(short)1));\n       s.setOptionFlags((byte)0x9);\n-      stats = new UnicodeString.UnicodeRecordStats();\n-      s.getRecordSize(stats);\n-      assertEquals(SSTRecord.MAX_RECORD_SIZE-1, stats.recordSize);\n+      confirmSize(MAX_DATA_SIZE-1, s);\n     }\n \n     public void testContinuedStringSize() {\n       //Test a basic string\n-      UnicodeString s = makeUnicodeString(SSTRecord.MAX_RECORD_SIZE-2-1+20);\n-      UnicodeString.UnicodeRecordStats stats = new UnicodeString.UnicodeRecordStats();\n-      s.getRecordSize(stats);\n-      assertEquals(SSTRecord.MAX_RECORD_SIZE+4+1+20, stats.recordSize);\n+      UnicodeString s = makeUnicodeString(MAX_DATA_SIZE-2-1+20);\n+      confirmSize(MAX_DATA_SIZE+4+1+20, s);\n     }\n \n     /** Tests that a string size calculation that fits neatly in two records, the second being a continue*/\n     public void testPerfectContinuedStringSize() {\n       //Test a basic string\n-      int strSize = SSTRecord.MAX_RECORD_SIZE*2;\n+      int strSize = MAX_DATA_SIZE*2;\n       //String overhead\n       strSize -= 3;\n       //Continue Record overhead\n       strSize -= 4;\n       //Continue Record additional byte overhead\n       strSize -= 1;\n       UnicodeString s = makeUnicodeString(strSize);\n-      UnicodeString.UnicodeRecordStats stats = new UnicodeString.UnicodeRecordStats();\n-      s.getRecordSize(stats);\n-      assertEquals(SSTRecord.MAX_RECORD_SIZE*2, stats.recordSize);\n+      confirmSize(MAX_DATA_SIZE*2, s);\n     }\n \n \n-\n-\n-    private static UnicodeString makeUnicodeString( String s )\n-    {\n+    private static UnicodeString makeUnicodeString(String s) {\n       UnicodeString st = new UnicodeString(s);\n       st.setOptionFlags((byte)0);\n       return st;\n     }\n \n-    private static UnicodeString makeUnicodeString( int numChars) {\n+    private static UnicodeString makeUnicodeString(int numChars) {\n+        return makeUnicodeString(numChars, false);\n+    }\n+    /**\n+     * @param is16Bit if <code>true</code> the created string will have characters > 0x00FF\n+     * @return a string of the specified number of characters\n+     */\n+    private static UnicodeString makeUnicodeString(int numChars, boolean is16Bit) {\n       StringBuffer b = new StringBuffer(numChars);\n+      int charBase = is16Bit ? 0x8A00 : 'A';\n       for (int i=0;i<numChars;i++) {\n-        b.append(i%10);\n+        char ch = (char) ((i%16)+charBase);\n+        b.append(ch);\n       }\n       return makeUnicodeString(b.toString());\n     }",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/TestUnicodeString.java",
                "sha": "1a80f9e9210dc9c37611da4a2424e897d421b16b",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/constant/TestConstantValueParser.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/constant/TestConstantValueParser.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 2,
                "filename": "src/testcases/org/apache/poi/hssf/record/constant/TestConstantValueParser.java",
                "patch": "@@ -22,7 +22,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.TestCase;\n \n import org.apache.poi.hssf.record.TestcaseRecordInputStream;\n-import org.apache.poi.hssf.record.UnicodeString;\n import org.apache.poi.hssf.usermodel.HSSFErrorConstants;\n import org.apache.poi.util.HexRead;\n import org.apache.poi.util.LittleEndianByteArrayOutputStream;\n@@ -36,7 +35,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t\t\tBoolean.TRUE,\n \t\t\tnull,\n \t\t\tnew Double(1.1),\n-\t\t\tnew UnicodeString(\"Sample text\"),\n+\t\t\t\"Sample text\",\n \t\t\tErrorConstant.valueOf(HSSFErrorConstants.ERROR_DIV_0),\n \t\t};\n \tprivate static final byte[] SAMPLE_ENCODING = HexRead.readFromString(",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/constant/TestConstantValueParser.java",
                "sha": "6ed2c6245ade3fa28c6498e6989b4dbb549d214d",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 2,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java",
                "patch": "@@ -66,10 +66,10 @@ public void testReadWriteTokenValueBytes() {\n \t\t\n \t\t\n \t\tassertEquals(Boolean.TRUE, values[0][0]);\n-\t\tassertEquals(new UnicodeString(\"ABCD\"), values[0][1]);\n+\t\tassertEquals(\"ABCD\", values[0][1]);\n \t\tassertEquals(new Double(0), values[1][0]);\n \t\tassertEquals(Boolean.FALSE, values[1][1]);\n-\t\tassertEquals(new UnicodeString(\"FG\"), values[1][2]);\n+\t\tassertEquals(\"FG\", values[1][2]);\n \t\t\n \t\tbyte[] outBuf = new byte[ENCODED_CONSTANT_DATA.length];\n \t\tptg.writeTokenValueBytes(new LittleEndianByteArrayOutputStream(outBuf, 0));",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/record/formula/TestArrayPtg.java",
                "sha": "5dab4cca141a10b14df175c217a46f65aea93efa",
                "status": "modified"
            },
            {
                "additions": 79,
                "blob_url": "https://github.com/apache/poi/blob/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFCell.java",
                "changes": 117,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFCell.java?ref=2963774c3752202c0686b0223d7dfd8ae1973ca8",
                "deletions": 38,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFCell.java",
                "patch": "@@ -28,8 +28,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hssf.util.HSSFColor;\n \n /**\n- * Tests various functionity having to do with HSSFCell.  For instance support for\n- * paticular datatypes, etc.\n+ * Tests various functionality having to do with {@link HSSFCell}.  For instance support for\n+ * particular datatypes, etc.\n  * @author Andrew C. Oliver (andy at superlinksoftware dot com)\n  * @author  Dan Sherman (dsherman at isisph.com)\n  * @author Alex Jacoby (ajacoby at gmail.com)\n@@ -345,41 +345,82 @@ public void testSetStringInFormulaCell_bug44606() {\n         }\n     }\n \n-    /**\n-     * Test to ensure we can only assign cell styles that belong\n-     *  to our workbook, and not those from other workbooks.\n-     */\n-    public void testCellStyleWorkbookMatch() throws Exception {\n-    \tHSSFWorkbook wbA = new HSSFWorkbook();\n-    \tHSSFWorkbook wbB = new HSSFWorkbook();\n-    \t\n-    \tHSSFCellStyle styA = wbA.createCellStyle();\n-    \tHSSFCellStyle styB = wbB.createCellStyle();\n-    \t\n-    \tstyA.verifyBelongsToWorkbook(wbA);\n-    \tstyB.verifyBelongsToWorkbook(wbB);\n-    \ttry {\n-    \t\tstyA.verifyBelongsToWorkbook(wbB);\n-    \t\tfail();\n-    \t} catch(IllegalArgumentException e) {}\n-    \ttry {\n-    \t\tstyB.verifyBelongsToWorkbook(wbA);\n-    \t\tfail();\n-    \t} catch(IllegalArgumentException e) {}\n-    \t\n-    \tHSSFCell cellA = wbA.createSheet().createRow(0).createCell(0);\n-    \tHSSFCell cellB = wbB.createSheet().createRow(0).createCell(0);\n-    \t\n-    \tcellA.setCellStyle(styA);\n-    \tcellB.setCellStyle(styB);\n-    \ttry {\n-        \tcellA.setCellStyle(styB);\n-    \t\tfail();\n-    \t} catch(IllegalArgumentException e) {}\n-    \ttry {\n-        \tcellB.setCellStyle(styA);\n-    \t\tfail();\n-    \t} catch(IllegalArgumentException e) {}\n-    }\n+\t/**\n+\t * Test to ensure we can only assign cell styles that belong\n+\t *  to our workbook, and not those from other workbooks.\n+\t */\n+\tpublic void testCellStyleWorkbookMatch() {\n+\t\tHSSFWorkbook wbA = new HSSFWorkbook();\n+\t\tHSSFWorkbook wbB = new HSSFWorkbook();\n+\n+\t\tHSSFCellStyle styA = wbA.createCellStyle();\n+\t\tHSSFCellStyle styB = wbB.createCellStyle();\n+\n+\t\tstyA.verifyBelongsToWorkbook(wbA);\n+\t\tstyB.verifyBelongsToWorkbook(wbB);\n+\t\ttry {\n+\t\t\tstyA.verifyBelongsToWorkbook(wbB);\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {}\n+\t\ttry {\n+\t\t\tstyB.verifyBelongsToWorkbook(wbA);\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {}\n+\n+\t\tHSSFCell cellA = wbA.createSheet().createRow(0).createCell(0);\n+\t\tHSSFCell cellB = wbB.createSheet().createRow(0).createCell(0);\n+\n+\t\tcellA.setCellStyle(styA);\n+\t\tcellB.setCellStyle(styB);\n+\t\ttry {\n+\t\t\tcellA.setCellStyle(styB);\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {}\n+\t\ttry {\n+\t\t\tcellB.setCellStyle(styA);\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {}\n+\t}\n+\n+\tpublic void testChangeTypeStringToBool() {\n+\t\tHSSFCell cell = new HSSFWorkbook().createSheet(\"Sheet1\").createRow(0).createCell(0);\n+\n+\t\tcell.setCellValue(new HSSFRichTextString(\"TRUE\"));\n+\t\tassertEquals(HSSFCell.CELL_TYPE_STRING, cell.getCellType());\n+\t\ttry {\n+\t\t\tcell.setCellType(HSSFCell.CELL_TYPE_BOOLEAN);\n+\t\t} catch (ClassCastException e) {\n+\t\t\tthrow new AssertionFailedError(\n+\t\t\t\t\t\"Identified bug in conversion of cell from text to boolean\");\n+\t\t}\n+\n+\t\tassertEquals(HSSFCell.CELL_TYPE_BOOLEAN, cell.getCellType());\n+\t\tassertEquals(true, cell.getBooleanCellValue());\n+\t\tcell.setCellType(HSSFCell.CELL_TYPE_STRING);\n+\t\tassertEquals(\"TRUE\", cell.getRichStringCellValue().getString());\n+\n+\t\t// 'false' text to bool and back\n+\t\tcell.setCellValue(new HSSFRichTextString(\"FALSE\"));\n+\t\tcell.setCellType(HSSFCell.CELL_TYPE_BOOLEAN);\n+\t\tassertEquals(HSSFCell.CELL_TYPE_BOOLEAN, cell.getCellType());\n+\t\tassertEquals(false, cell.getBooleanCellValue());\n+\t\tcell.setCellType(HSSFCell.CELL_TYPE_STRING);\n+\t\tassertEquals(\"FALSE\", cell.getRichStringCellValue().getString());\n+\t}\n+\n+\tpublic void testChangeTypeBoolToString() {\n+\t\tHSSFCell cell = new HSSFWorkbook().createSheet(\"Sheet1\").createRow(0).createCell(0);\n+\t\tcell.setCellValue(true);\n+\t\ttry {\n+\t\t\tcell.setCellType(HSSFCell.CELL_TYPE_STRING);\n+\t\t} catch (IllegalStateException e) {\n+\t\t\tif (e.getMessage().equals(\"Cannot get a text value from a boolean cell\")) {\n+\t\t\t\tthrow new AssertionFailedError(\n+\t\t\t\t\t\t\"Identified bug in conversion of cell from boolean to text\");\n+\t\t\t}\n+\t\t\tthrow e;\n+\t\t}\n+\t\tassertEquals(\"TRUE\", cell.getRichStringCellValue().getString());\n+\t}\n }\n ",
                "raw_url": "https://github.com/apache/poi/raw/2963774c3752202c0686b0223d7dfd8ae1973ca8/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFCell.java",
                "sha": "abb9f1b410b7ed2128a74e84c56f4737ce041700",
                "status": "modified"
            }
        ],
        "message": "Merged revisions 709570,709598,710114,710134,710136,711505,711513-711515,711694,711739,711741,711746,711749 via svnmerge from \nhttps://svn.apache.org/repos/asf/poi/trunk\n\n........\n  r709570 | josh | 2008-10-31 14:17:08 -0700 (Fri, 31 Oct 2008) | 1 line\n  \n  made DrawingSelectionRecord into a plain BIFF record (not an escher holder aggregate). Added some interpretation of fields\n........\n  r709598 | josh | 2008-10-31 16:24:41 -0700 (Fri, 31 Oct 2008) | 1 line\n  \n  Simplified multiple record expansion logic\n........\n  r710114 | yegor | 2008-11-03 09:54:01 -0800 (Mon, 03 Nov 2008) | 1 line\n  \n  fixed #46122: Picture#getEscherBSERecord threw NullPointerException if EscherContainerRecord.BSTORE_CONTAINER was not found\n........\n  r710134 | yegor | 2008-11-03 11:19:39 -0800 (Mon, 03 Nov 2008) | 1 line\n  \n  fixed bug #46033: table cells had incorrect text type resulting in corrupted style info\n........\n  r710136 | yegor | 2008-11-03 11:23:52 -0800 (Mon, 03 Nov 2008) | 1 line\n  \n  updated status of the fixed bug #46033\n........\n  r711505 | josh | 2008-11-04 19:50:31 -0800 (Tue, 04 Nov 2008) | 1 line\n  \n  Refactored test case\n........\n  r711513 | josh | 2008-11-04 21:45:17 -0800 (Tue, 04 Nov 2008) | 1 line\n  \n  Converted ConstantValueParser to use plain Strings instead of UnicodeStrings\n........\n  r711514 | josh | 2008-11-04 21:52:35 -0800 (Tue, 04 Nov 2008) | 1 line\n  \n  Converted SupBookRecord to use plain Strings instead of UnicodeStrings\n........\n  r711515 | josh | 2008-11-04 22:15:59 -0800 (Tue, 04 Nov 2008) | 1 line\n  \n  Refactored test case\n........\n  r711694 | josh | 2008-11-05 12:46:00 -0800 (Wed, 05 Nov 2008) | 1 line\n  \n  Fixed bug in conversion to/from text cells\n........\n  r711739 | josh | 2008-11-05 15:28:55 -0800 (Wed, 05 Nov 2008) | 1 line\n  \n  Refactoring test case\n........\n  r711741 | josh | 2008-11-05 15:35:02 -0800 (Wed, 05 Nov 2008) | 1 line\n  \n  Refactoring test case\n........\n  r711746 | josh | 2008-11-05 15:45:42 -0800 (Wed, 05 Nov 2008) | 1 line\n  \n  Fixed mistake in test case.  Constant value was 4 bytes too large (should be max *data* size not max *record* size).\n........\n  r711749 | josh | 2008-11-05 17:12:41 -0800 (Wed, 05 Nov 2008) | 1 line\n  \n  Introduced ContinuableRecord to help fix serialization of StringRecords with large data.  Fixed TextObjectRecord to only write 16bit unicode when needed.  Simplification in UnicodeString.\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/ooxml@711755 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/75e352f2a073bdda52a2e3c30df63be6c71ff61d",
        "patched_files": [
            "LittleEndianByteArrayOutputStream.java",
            "SSTSerializer.java",
            "ContinuableRecord.java",
            "TableCell.java",
            "Table.java",
            "UnknownLengthRecordOutput.java",
            "DelayableLittleEndianOutput.java",
            "ArrayPtg.java",
            "status.java",
            "DrawingSelectionRecord.java",
            "StringUtil.java",
            "HSSFCell.java",
            "SSTRecordSizeCalculator.java",
            "changes.java",
            "TextObjectRecord.java",
            "SSTRecordHeader.java",
            "SupBookRecord.java",
            "LinkTable.java",
            "Picture.java",
            "RecordInputStream.java",
            "ConstantValueParser.java",
            "ContinuableRecordOutput.java",
            "SSTRecord.java",
            "StringRecord.java",
            "UnicodeString.java",
            "RecordFactory.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestTextObjectBaseRecord.java",
            "TestLinkTable.java",
            "TestRecordFactory.java",
            "TestSupBookRecord.java",
            "TestStringRecord.java",
            "TestRecordInputStream.java",
            "TestStringUtil.java",
            "TestPicture.java",
            "TestTable.java",
            "TestUnicodeString.java",
            "TestArrayPtg.java",
            "TestSSTRecordSizeCalculator.java",
            "TestTextObjectRecord.java",
            "TestSSTRecord.java",
            "TestHSSFCell.java",
            "TestConstantValueParser.java"
        ]
    },
    "poi_2c018cc": {
        "bug_id": "poi_2c018cc",
        "commit": "https://github.com/apache/poi/commit/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6",
        "file": [
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/poi/blob/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/src/java/org/apache/poi/hssf/usermodel/HSSFComment.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFComment.java?ref=2c018cc43ae6bcd95c03621b67b568d50fa2b5e6",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFComment.java",
                "patch": "@@ -16,8 +16,18 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.hssf.usermodel;\n \n-import org.apache.poi.ddf.*;\n-import org.apache.poi.hssf.record.*;\n+import org.apache.poi.ddf.DefaultEscherRecordFactory;\n+import org.apache.poi.ddf.EscherBSERecord;\n+import org.apache.poi.ddf.EscherContainerRecord;\n+import org.apache.poi.ddf.EscherOptRecord;\n+import org.apache.poi.ddf.EscherProperties;\n+import org.apache.poi.ddf.EscherSimpleProperty;\n+import org.apache.poi.hssf.record.CommonObjectDataSubRecord;\n+import org.apache.poi.hssf.record.EndSubRecord;\n+import org.apache.poi.hssf.record.NoteRecord;\n+import org.apache.poi.hssf.record.NoteStructureSubRecord;\n+import org.apache.poi.hssf.record.ObjRecord;\n+import org.apache.poi.hssf.record.TextObjectRecord;\n import org.apache.poi.ss.usermodel.Comment;\n \n /**\n@@ -211,6 +221,15 @@ public void setAuthor(String author) {\n     protected NoteRecord getNoteRecord() {\n         return _note;\n     }\n+    \n+    /**\n+     * Do we know which cell this comment belongs to?\n+     */\n+    public boolean hasPosition() {\n+        if (_note == null) return false;\n+        if (getColumn() < 0 || getRow() < 0) return false;\n+        return true;\n+    }\n \n     @Override\n     public void setShapeType(int shapeType) {",
                "raw_url": "https://github.com/apache/poi/raw/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/src/java/org/apache/poi/hssf/usermodel/HSSFComment.java",
                "sha": "8b4350893c0d8240c28ea7f9bcc9297442eeefce",
                "status": "modified"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/poi/blob/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=2c018cc43ae6bcd95c03621b67b568d50fa2b5e6",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -28,7 +28,20 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hssf.model.HSSFFormulaParser;\n import org.apache.poi.hssf.model.InternalSheet;\n import org.apache.poi.hssf.model.InternalWorkbook;\n-import org.apache.poi.hssf.record.*;\n+import org.apache.poi.hssf.record.AutoFilterInfoRecord;\n+import org.apache.poi.hssf.record.CellValueRecordInterface;\n+import org.apache.poi.hssf.record.DVRecord;\n+import org.apache.poi.hssf.record.DimensionsRecord;\n+import org.apache.poi.hssf.record.DrawingRecord;\n+import org.apache.poi.hssf.record.EscherAggregate;\n+import org.apache.poi.hssf.record.ExtendedFormatRecord;\n+import org.apache.poi.hssf.record.NameRecord;\n+import org.apache.poi.hssf.record.NoteRecord;\n+import org.apache.poi.hssf.record.Record;\n+import org.apache.poi.hssf.record.RowRecord;\n+import org.apache.poi.hssf.record.SCLRecord;\n+import org.apache.poi.hssf.record.WSBoolRecord;\n+import org.apache.poi.hssf.record.WindowTwoRecord;\n import org.apache.poi.hssf.record.aggregates.DataValidityTable;\n import org.apache.poi.hssf.record.aggregates.FormulaRecordAggregate;\n import org.apache.poi.hssf.record.aggregates.WorksheetProtectionBlock;\n@@ -2115,7 +2128,7 @@ private HSSFComment lookForComment(HSSFShapeContainer container, int row, int co\n             }\n             if (shape instanceof HSSFComment) {\n                 HSSFComment comment = (HSSFComment) shape;\n-                if (comment.getColumn() == column && comment.getRow() == row) {\n+                if (comment.hasPosition() && comment.getColumn() == column && comment.getRow() == row) {\n                     return comment;\n                 }\n             }",
                "raw_url": "https://github.com/apache/poi/raw/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "170c015ac532788324f993b41090278209901b8c",
                "status": "modified"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/poi/blob/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=2c018cc43ae6bcd95c03621b67b568d50fa2b5e6",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -2549,4 +2549,20 @@ public void stackoverflow23114397() throws Exception {\n         assertAlmostEquals(1950, s.getColumnWidth(10), fontAccuracy);\n         assertAlmostEquals(2225, s.getColumnWidth(11), fontAccuracy);\n     }\n+    \n+    @Test\n+    public void bug56450() {\n+        HSSFWorkbook wb = openSample(\"56450.xls\");\n+        HSSFSheet sheet = wb.getSheetAt(0);\n+        int comments = 0;\n+        for (Row r : sheet) {\n+            for (Cell c : r) {\n+                if (c.getCellComment() != null) {\n+                    assertNotNull(c.getCellComment().getString().getString());\n+                    comments++;\n+                }\n+            }\n+        }\n+        assertEquals(0, comments);\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "16d8e208b644b351471156d25f5f09c5e5f34238",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/test-data/spreadsheet/56450.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/56450.xls?ref=2c018cc43ae6bcd95c03621b67b568d50fa2b5e6",
                "deletions": 0,
                "filename": "test-data/spreadsheet/56450.xls",
                "raw_url": "https://github.com/apache/poi/raw/2c018cc43ae6bcd95c03621b67b568d50fa2b5e6/test-data/spreadsheet/56450.xls",
                "sha": "66798a8b49520fd9b1db6b49cbd5da76541abb43",
                "status": "added"
            }
        ],
        "message": "Fix bug #56450 - Avoid a NPE if a comment has no associated NoteRecord (but we still don't know where it belongs)\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1589770 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/ed23692537c54b982a78bd37077bc80658a6737e",
        "patched_files": [
            "HSSFComment.java",
            "56450.java",
            "HSSFSheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHSSFSheet.java",
            "TestBugs.java",
            "TestHSSFComment.java"
        ]
    },
    "poi_2c79875": {
        "bug_id": "poi_2c79875",
        "commit": "https://github.com/apache/poi/commit/2c7987545b7f9bc6cab84a9c812c512092ad7fc9",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/2c7987545b7f9bc6cab84a9c812c512092ad7fc9/src/java/org/apache/poi/hssf/model/InternalWorkbook.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/InternalWorkbook.java?ref=2c7987545b7f9bc6cab84a9c812c512092ad7fc9",
                "deletions": 5,
                "filename": "src/java/org/apache/poi/hssf/model/InternalWorkbook.java",
                "patch": "@@ -774,11 +774,12 @@ public void removeSheet(int sheetIndex) {\n             }\n         }\n         \n-        // also tell the LinkTable about the removed sheet\n-        // +1 because we already removed it from the count of sheets!\n-        for(int i = sheetIndex+1;i < getNumSheets()+1;i++) {\n-            // also update the link-table as otherwise references might point at invalid sheets\n-            linkTable.removeSheet(i);\n+        if (linkTable != null) {\n+            // also tell the LinkTable about the removed sheet\n+            // +1 because we already removed it from the count of sheets!\n+            for(int i = sheetIndex+1;i < getNumSheets()+1;i++) {\n+                linkTable.removeSheet(i);\n+            }\n         }\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/2c7987545b7f9bc6cab84a9c812c512092ad7fc9/src/java/org/apache/poi/hssf/model/InternalWorkbook.java",
                "sha": "a2670978eaf6b6798ab7e65e5edfb6995ba78260",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/2c7987545b7f9bc6cab84a9c812c512092ad7fc9/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=2c7987545b7f9bc6cab84a9c812c512092ad7fc9",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -2716,4 +2716,14 @@ public void test57456() throws IOException {\n         Workbook wb = openSample(\"57456.xls\");\n         wb.close();\n     }\n+    \n+    @Test\n+    public void test57163() throws IOException {\n+        Workbook wb = openSample(\"57163.xls\");\n+        \n+        while (wb.getNumberOfSheets() > 1) {\n+            wb.removeSheetAt(1);\n+        }\n+        wb.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/2c7987545b7f9bc6cab84a9c812c512092ad7fc9/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "0bb1de24b48cef7f69f78040202bf8c759c8fe33",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/2c7987545b7f9bc6cab84a9c812c512092ad7fc9/test-data/spreadsheet/57163.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/57163.xls?ref=2c7987545b7f9bc6cab84a9c812c512092ad7fc9",
                "deletions": 0,
                "filename": "test-data/spreadsheet/57163.xls",
                "raw_url": "https://github.com/apache/poi/raw/2c7987545b7f9bc6cab84a9c812c512092ad7fc9/test-data/spreadsheet/57163.xls",
                "sha": "402c954e19b8070b5ae6448700895ab94816868a",
                "status": "added"
            }
        ],
        "message": "Bug 57163: Fix possible NullPointerException when a spreadsheet has no LinkTable and we try to adjust it during sheet removal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1673168 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/690abbe5547df702ce83cf2fe63a3bc4c00f1df6",
        "patched_files": [
            "InternalWorkbook.java",
            "57163.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java"
        ]
    },
    "poi_36b7f44": {
        "bug_id": "poi_36b7f44",
        "commit": "https://github.com/apache/poi/commit/36b7f4413016469dc6292d630b3b5445f2bdcc26",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/36b7f4413016469dc6292d630b3b5445f2bdcc26/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFStyles.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFStyles.java?ref=36b7f4413016469dc6292d630b3b5445f2bdcc26",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFStyles.java",
                "patch": "@@ -194,9 +194,13 @@ public void addStyle(XWPFStyle style) {\n      * @return style\r\n      */\r\n     public XWPFStyle getStyle(String styleID) {\r\n-        for (XWPFStyle style : listStyle) {\r\n-            if (style.getStyleId().equals(styleID))\r\n-                return style;\r\n+        for (XWPFStyle style : listStyle) {\n+            try {\n+                if (style.getStyleId().equals(styleID))\n+                    return style;\n+            } catch (NullPointerException e) {\n+                // Ignore NPE\n+            }\n         }\r\n         return null;\r\n     }\r",
                "raw_url": "https://github.com/apache/poi/raw/36b7f4413016469dc6292d630b3b5445f2bdcc26/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFStyles.java",
                "sha": "5f961ea9ddd2ae91c1ff35a879021890e87bdf31",
                "status": "modified"
            },
            {
                "additions": 34,
                "blob_url": "https://github.com/apache/poi/blob/36b7f4413016469dc6292d630b3b5445f2bdcc26/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFStyles.java",
                "changes": 37,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFStyles.java?ref=36b7f4413016469dc6292d630b3b5445f2bdcc26",
                "deletions": 3,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFStyles.java",
                "patch": "@@ -17,21 +17,27 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xwpf.usermodel;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n \n-import junit.framework.TestCase;\n-\n import org.apache.poi.xwpf.XWPFTestDataSamples;\n+import org.junit.Test;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLatentStyles;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLsdException;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTStyle;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTStyles;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.STStyleType;\n \n-public class TestXWPFStyles extends TestCase {\n+public final class TestXWPFStyles {\n+    @Test\n     public void testGetUsedStyles() throws IOException {\n         XWPFDocument sampleDoc = XWPFTestDataSamples.openSampleDocument(\"Styles.docx\");\n         List<XWPFStyle> testUsedStyleList = new ArrayList<XWPFStyle>();\n@@ -47,6 +53,7 @@ public void testGetUsedStyles() throws IOException {\n         assertEquals(usedStyleList, testUsedStyleList);\n     }\n \n+    @Test\n     public void testAddStylesToDocument() throws IOException {\n         XWPFDocument docOut = new XWPFDocument();\n         XWPFStyles styles = docOut.createStyles();\n@@ -70,6 +77,7 @@ public void testAddStylesToDocument() throws IOException {\n      * Bug #52449 - We should be able to write a file containing\n      * both regular and glossary styles without error\n      */\n+    @Test\n     public void test52449() throws Exception {\n         XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"52449.docx\");\n         XWPFStyles styles = doc.getStyles();\n@@ -86,6 +94,7 @@ public void test52449() throws Exception {\n      * they exist only to copy xml beans to pi-ooxml-schemas.jar\n      */\n     @SuppressWarnings(\"resource\")\n+    @Test\n     public void testLanguages() {\n         XWPFDocument docOut = new XWPFDocument();\n         XWPFStyles styles = docOut.createStyles();\n@@ -97,6 +106,7 @@ public void testLanguages() {\n         styles.setDefaultFonts(def);\n     }\n \n+    @Test\n     public void testType() {\n         CTStyle ctStyle = CTStyle.Factory.newInstance();\n         XWPFStyle style = new XWPFStyle(ctStyle);\n@@ -105,6 +115,7 @@ public void testType() {\n         assertEquals(STStyleType.PARAGRAPH, style.getType());\n     }\n \n+    @Test\n     public void testLatentStyles() {\n         CTLatentStyles latentStyles = CTLatentStyles.Factory.newInstance();\n         CTLsdException ex = latentStyles.addNewLsdException();\n@@ -114,6 +125,7 @@ public void testLatentStyles() {\n         assertEquals(false, ls.isLatentStyle(\"notex1\"));\n     }\n \n+    @Test\n     public void testSetStyles_Bug57254() throws IOException {\n         XWPFDocument docOut = new XWPFDocument();\n         XWPFStyles styles = docOut.createStyles();\n@@ -133,6 +145,7 @@ public void testSetStyles_Bug57254() throws IOException {\n         assertTrue(styles.styleExist(strStyleId));\n     }\n \n+    @Test\n     public void testEasyAccessToStyles() throws IOException {\n         XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"SampleDoc.docx\");\n         XWPFStyles styles = doc.getStyles();\n@@ -188,4 +201,22 @@ public void testEasyAccessToStyles() throws IOException {\n         assertEquals(11, styles.getDefaultRunStyle().getFontSize());\n         assertEquals(200, styles.getDefaultParagraphStyle().getSpacingAfter());\n     }\n+    \n+    // Bug 60329: style with missing StyleID throws NPE\n+    @Test\n+    public void testMissingStyleId() throws IOException {\n+        XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"60329.docx\");\n+        XWPFStyles styles = doc.getStyles();\n+        // Styles exist in the test document in this order, EmptyCellLayoutStyle\n+        // is missing a StyleId\n+        try {\n+            assertNotNull(styles.getStyle(\"NoList\"));\n+            assertNull(styles.getStyle(\"EmptyCellLayoutStyle\"));\n+            assertNotNull(styles.getStyle(\"BalloonText\"));\n+        } catch (NullPointerException e) {\n+            fail(e.toString());\n+        }\n+\n+        doc.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/36b7f4413016469dc6292d630b3b5445f2bdcc26/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFStyles.java",
                "sha": "6210d1178160804706cd5a44d9703bf8d83867dd",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/36b7f4413016469dc6292d630b3b5445f2bdcc26/test-data/document/60329.docx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/60329.docx?ref=36b7f4413016469dc6292d630b3b5445f2bdcc26",
                "deletions": 0,
                "filename": "test-data/document/60329.docx",
                "raw_url": "https://github.com/apache/poi/raw/36b7f4413016469dc6292d630b3b5445f2bdcc26/test-data/document/60329.docx",
                "sha": "c0bb15ca0438b976e01644ece73981c5980e0990",
                "status": "added"
            }
        ],
        "message": "60329: Avoid NPE when styleid is null \n\nTask-Url: https://bz.apache.org/bugzilla/show_bug.cgi?id=60329\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1772138 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/6406553f517c03a5bdc5b055e179615dcab66e21",
        "patched_files": [
            "60329.java",
            "XWPFStyles.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFStyles.java"
        ]
    },
    "poi_3ef803b": {
        "bug_id": "poi_3ef803b",
        "commit": "https://github.com/apache/poi/commit/3ef803b932608d76d19f4c9116f8fdadff61c77d",
        "file": [
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/poi/blob/3ef803b932608d76d19f4c9116f8fdadff61c77d/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 41,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=3ef803b932608d76d19f4c9116f8fdadff61c77d",
                "deletions": 20,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -1748,27 +1748,28 @@ public void autoSizeColumn(short column) {\n                 } else if (cell.getCellType() == HSSFCell.CELL_TYPE_BOOLEAN) {\n                     sval = String.valueOf(cell.getBooleanCellValue());\n                 }\n+                if(sval != null) {\n+                    String txt = sval + defaultChar;\n+                    str = new AttributedString(txt);\n+                    copyAttributes(font, str, 0, txt.length());\n \n-                String txt = sval + defaultChar;\n-                str = new AttributedString(txt);\n-                copyAttributes(font, str, 0, txt.length());\n-\n-                layout = new TextLayout(str.getIterator(), frc);\n-                if(style.getRotation() != 0){\n-                    /*\n-                     * Transform the text using a scale so that it's height is increased by a multiple of the leading,\n-                     * and then rotate the text before computing the bounds. The scale results in some whitespace around\n-                     * the unrotated top and bottom of the text that normally wouldn't be present if unscaled, but\n-                     * is added by the standard Excel autosize.\n-                     */\n-                    AffineTransform trans = new AffineTransform();\n-                    trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n-                    trans.concatenate(\n-                    AffineTransform.getScaleInstance(1, fontHeightMultiple)\n-                    );\n-                    width = Math.max(width, layout.getOutline(trans).getBounds().getWidth() / defaultCharWidth);\n-                } else {\n-                    width = Math.max(width, layout.getBounds().getWidth() / defaultCharWidth);\n+                    layout = new TextLayout(str.getIterator(), frc);\n+                    if(style.getRotation() != 0){\n+                        /*\n+                         * Transform the text using a scale so that it's height is increased by a multiple of the leading,\n+                         * and then rotate the text before computing the bounds. The scale results in some whitespace around\n+                         * the unrotated top and bottom of the text that normally wouldn't be present if unscaled, but\n+                         * is added by the standard Excel autosize.\n+                         */\n+                        AffineTransform trans = new AffineTransform();\n+                        trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n+                        trans.concatenate(\n+                        AffineTransform.getScaleInstance(1, fontHeightMultiple)\n+                        );\n+                        width = Math.max(width, layout.getOutline(trans).getBounds().getWidth() / defaultCharWidth);\n+                    } else {\n+                        width = Math.max(width, layout.getBounds().getWidth() / defaultCharWidth);\n+                    }\n                 }\n             }\n ",
                "raw_url": "https://github.com/apache/poi/raw/3ef803b932608d76d19f4c9116f8fdadff61c77d/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "0250a4cbaab23ea830e847e518fbbb8a01d4d79a",
                "status": "modified"
            }
        ],
        "message": "add a check to prevent NPE in HSSFSheet.autoSizeColumn(). See Bug 44246\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@613396 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/de3e7e7838d0b298c8e3059f45c9ee2b44413c6b",
        "patched_files": [
            "HSSFSheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHSSFSheet.java"
        ]
    },
    "poi_4200581": {
        "bug_id": "poi_4200581",
        "commit": "https://github.com/apache/poi/commit/42005812c44a1eee2f0780b2c101c108a9c2fc6a",
        "file": [
            {
                "additions": 78,
                "blob_url": "https://github.com/apache/poi/blob/42005812c44a1eee2f0780b2c101c108a9c2fc6a/src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableCell.java",
                "changes": 121,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableCell.java?ref=42005812c44a1eee2f0780b2c101c108a9c2fc6a",
                "deletions": 43,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableCell.java",
                "patch": "@@ -18,97 +18,132 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n package org.apache.poi.hwpf.usermodel;\n \n public final class TableCell\n-  extends Range\n-{\n+        extends Range {\n   private int _levelNum;\n   private TableCellDescriptor _tcd;\n   private int _leftEdge;\n   private int _width;\n \n-    public TableCell( int startIdxInclusive, int endIdxExclusive,\n-            TableRow parent, int levelNum, TableCellDescriptor tcd,\n-            int leftEdge, int width )\n-    {\n-        super( startIdxInclusive, endIdxExclusive, parent );\n-        _tcd = tcd;\n-        _leftEdge = leftEdge;\n-        _width = width;\n-        _levelNum = levelNum;\n+  public TableCell(int startIdxInclusive, int endIdxExclusive,\n+                   TableRow parent, int levelNum, TableCellDescriptor tcd,\n+                   int leftEdge, int width) {\n+    super(startIdxInclusive, endIdxExclusive, parent);\n+    _tcd = tcd;\n+    _leftEdge = leftEdge;\n+    _width = width;\n+    _levelNum = levelNum;\n+  }\n+\n+  public boolean isFirstMerged() {\n+    if (_tcd == null) {\n+      return false;\n     }\n \n-  public boolean isFirstMerged()\n-  {\n     return _tcd.isFFirstMerged();\n   }\n \n-  public boolean isMerged()\n-  {\n+  public boolean isMerged() {\n+    if (_tcd == null) {\n+      return false;\n+    }\n+\n     return _tcd.isFMerged();\n   }\n \n-  public boolean isVertical()\n-  {\n+  public boolean isVertical() {\n+    if (_tcd == null) {\n+      return false;\n+    }\n+\n     return _tcd.isFVertical();\n   }\n \n-  public boolean isBackward()\n-  {\n+  public boolean isBackward() {\n+    if (_tcd == null) {\n+      return false;\n+    }\n+\n     return _tcd.isFBackward();\n   }\n \n-    public boolean isRotateFont()\n-  {\n+  public boolean isRotateFont() {\n+    if (_tcd == null) {\n+      return false;\n+    }\n+\n     return _tcd.isFRotateFont();\n   }\n \n-  public boolean isVerticallyMerged()\n-  {\n+  public boolean isVerticallyMerged() {\n+    if (_tcd == null) {\n+      return false;\n+    }\n+\n     return _tcd.isFVertMerge();\n   }\n \n-  public boolean isFirstVerticallyMerged()\n-  {\n+  public boolean isFirstVerticallyMerged() {\n+    if (_tcd == null) {\n+      return false;\n+    }\n+\n     return _tcd.isFVertRestart();\n   }\n \n-  public byte getVertAlign()\n-  {\n+  public byte getVertAlign() {\n+    if (_tcd == null) {\n+      return 0;\n+    }\n+\n     return _tcd.getVertAlign();\n   }\n \n-  public BorderCode getBrcTop()\n-  {\n+  public BorderCode getBrcTop() {\n+    if (_tcd == null) {\n+      return new BorderCode();\n+    }\n+\n     return _tcd.getBrcTop();\n   }\n \n-  public BorderCode getBrcBottom()\n-  {\n+  public BorderCode getBrcBottom() {\n+    if (_tcd == null) {\n+      return new BorderCode();\n+    }\n+\n     return _tcd.getBrcBottom();\n   }\n \n-  public BorderCode getBrcLeft()\n-  {\n+  public BorderCode getBrcLeft() {\n+    if (_tcd == null) {\n+      return new BorderCode();\n+    }\n+\n     return _tcd.getBrcLeft();\n   }\n \n-  public BorderCode getBrcRight()\n-  {\n+  public BorderCode getBrcRight() {\n+    if (_tcd == null) {\n+      return new BorderCode();\n+    }\n+\n     return _tcd.getBrcRight();\n   }\n \n-  public int getLeftEdge() // twips\n-  {\n+  // twips\n+  public int getLeftEdge() {\n     return _leftEdge;\n   }\n \n-  public int getWidth() // twips\n-  {\n+  // twips\n+  public int getWidth() {\n     return _width;\n   }\n \n-  /** Returns the TableCellDescriptor for this cell.*/\n-  public TableCellDescriptor getDescriptor(){\n-  \treturn _tcd;\n+  /**\n+   * Returns the TableCellDescriptor for this cell.\n+   */\n+  public TableCellDescriptor getDescriptor() {\n+    return _tcd;\n   }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/42005812c44a1eee2f0780b2c101c108a9c2fc6a/src/scratchpad/src/org/apache/poi/hwpf/usermodel/TableCell.java",
                "sha": "3dca841c89d4fa67864d789066073c2da8d5d2f2",
                "status": "modified"
            },
            {
                "additions": 32,
                "blob_url": "https://github.com/apache/poi/blob/42005812c44a1eee2f0780b2c101c108a9c2fc6a/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java?ref=42005812c44a1eee2f0780b2c101c108a9c2fc6a",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java",
                "patch": "@@ -24,19 +24,23 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import java.io.ByteArrayOutputStream;\n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n+import javax.xml.parsers.DocumentBuilderFactory;\n \n import org.apache.commons.codec.digest.DigestUtils;\n import org.apache.poi.POIDataSamples;\n import org.apache.poi.hwpf.HWPFDocument;\n+import org.apache.poi.hwpf.HWPFDocumentCore;\n import org.apache.poi.hwpf.HWPFOldDocument;\n import org.apache.poi.hwpf.HWPFTestDataSamples;\n import org.apache.poi.hwpf.converter.AbstractWordUtils;\n+import org.apache.poi.hwpf.converter.WordToHtmlConverter;\n import org.apache.poi.hwpf.converter.WordToTextConverter;\n import org.apache.poi.hwpf.extractor.Word6Extractor;\n import org.apache.poi.hwpf.extractor.WordExtractor;\n@@ -50,6 +54,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.util.POILogFactory;\n import org.apache.poi.util.POILogger;\n import org.junit.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n \n /**\n  * Test different problems reported in the Apache Bugzilla\n@@ -892,4 +899,29 @@ public void test61490CellCountInTable() throws Exception {\n             }\n         }\n     }\n+\n+    @Test\n+    public void test60217() throws Exception {\n+        File file = new File(\"/tmp/word-doc-with-revised-table.doc\");\n+        FileInputStream fileInputStream = new FileInputStream(file);\n+        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+        WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter(document);\n+        HWPFDocumentCore hwpfDocumentCore = new HWPFDocument(HWPFDocumentCore.verifyAndBuildPOIFS(fileInputStream));\n+        wordToHtmlConverter.processDocument(hwpfDocumentCore);\n+        System.out.println(document);\n+\n+        System.out.println(document.getNodeName() + \" -> \" + document.getNodeValue());\n+\n+        printNode(document, \" \");\n+\n+        System.out.println(\"Process Complete\");\n+    }\n+\n+    private void printNode(Node rootNode, String spacer) {\n+        System.out.println(spacer + rootNode.getNodeName() + \" -> \" + rootNode.getNodeValue());\n+        NodeList nl = rootNode.getChildNodes();\n+        for (int i = 0; i < nl.getLength(); i++)\n+            printNode(nl.item(i), spacer + \"   \");\n+    }\n+\n }",
                "raw_url": "https://github.com/apache/poi/raw/42005812c44a1eee2f0780b2c101c108a9c2fc6a/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java",
                "sha": "751813955ed40f4b303f12ee2313574a3319415a",
                "status": "modified"
            }
        ],
        "message": "Fix bug 59322: NullPointerException when converting a certain Word document to HTML\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1866185 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/df64598b127ad910865f31c2e939e8faeff18f17",
        "patched_files": [
            "TableCell.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java"
        ]
    },
    "poi_43710ae": {
        "bug_id": "poi_43710ae",
        "commit": "https://github.com/apache/poi/commit/43710ae5f2895a268437520ed76ff1c293e452b3",
        "file": [
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/43710ae5f2895a268437520ed76ff1c293e452b3/src/java/org/apache/poi/hssf/usermodel/HSSFShapeFactory.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFShapeFactory.java?ref=43710ae5f2895a268437520ed76ff1c293e452b3",
                "deletions": 12,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFShapeFactory.java",
                "patch": "@@ -29,13 +29,6 @@\n  * Factory class for producing Excel Shapes from Escher records\r\n  */\r\n public class HSSFShapeFactory {\r\n-\r\n-    private final static short       OBJECT_TYPE_LINE               = 1;\r\n-    private final static short       OBJECT_TYPE_RECTANGLE          = 2;\r\n-    private final static short       OBJECT_TYPE_OVAL               = 3;\r\n-    private final static short       OBJECT_TYPE_ARC                = 4;\r\n-    private final static short       OBJECT_TYPE_PICTURE            = 8;\r\n-\r\n     /**\r\n      * build shape tree from escher container\r\n      * @param container root escher container from which escher records must be taken\r\n@@ -81,7 +74,7 @@ public static void createShapeTree(EscherContainerRecord container, EscherAggreg\n                 return;\r\n             }\r\n             CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord) objRecord.getSubRecords().get(0);\r\n-            HSSFShape shape;\r\n+            final HSSFShape shape;\r\n             switch (cmo.getObjectType()) {\r\n                 case CommonObjectDataSubRecord.OBJECT_TYPE_PICTURE:\r\n                     shape = new HSSFPicture(container, objRecord);\r\n@@ -97,11 +90,15 @@ public static void createShapeTree(EscherContainerRecord container, EscherAggreg\n                     break;\r\n                 case CommonObjectDataSubRecord.OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING:\r\n                     EscherOptRecord optRecord = container.getChildById(EscherOptRecord.RECORD_ID);\r\n-                    EscherProperty property = optRecord.lookup(EscherProperties.GEOMETRY__VERTICES);\r\n-                    if (null != property) {\r\n-                        shape = new HSSFPolygon(container, objRecord, txtRecord);\r\n+                    if(optRecord == null) {\r\n+                    \tshape = new HSSFSimpleShape(container, objRecord, txtRecord);\r\n                     } else {\r\n-                        shape = new HSSFSimpleShape(container, objRecord, txtRecord);\r\n+                        EscherProperty property = optRecord.lookup(EscherProperties.GEOMETRY__VERTICES);\r\n+                        if (null != property) {\r\n+                            shape = new HSSFPolygon(container, objRecord, txtRecord);\r\n+                        } else {\r\n+                            shape = new HSSFSimpleShape(container, objRecord, txtRecord);\r\n+                        }\r\n                     }\r\n                     break;\r\n                 case CommonObjectDataSubRecord.OBJECT_TYPE_TEXT:\r",
                "raw_url": "https://github.com/apache/poi/raw/43710ae5f2895a268437520ed76ff1c293e452b3/src/java/org/apache/poi/hssf/usermodel/HSSFShapeFactory.java",
                "sha": "ef1b13b22d8b54cd40458e104dff93952b7a946b",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/43710ae5f2895a268437520ed76ff1c293e452b3/src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java?ref=43710ae5f2895a268437520ed76ff1c293e452b3",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java",
                "patch": "@@ -363,4 +363,10 @@ public void testPassword() {\n \n \t\tassertTrue(text.contains(\"ZIP\"));\n \t}\n+\n+\tpublic void testNullPointerException() {\n+\t\tExcelExtractor extractor = createExtractor(\"ar.org.apsme.www_Form%20Inscripcion%20Curso%20NO%20Socios.xls\");\n+\t\tassertNotNull(extractor);\n+\t\tassertNotNull(extractor.getText());\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/43710ae5f2895a268437520ed76ff1c293e452b3/src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java",
                "sha": "793215a0281a13850be29c6b93493e77821d5ff7",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/43710ae5f2895a268437520ed76ff1c293e452b3/src/testcases/org/apache/poi/hssf/model/TestShapes.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/model/TestShapes.java?ref=43710ae5f2895a268437520ed76ff1c293e452b3",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/hssf/model/TestShapes.java",
                "patch": "@@ -20,6 +20,7 @@\n package org.apache.poi.hssf.model;\n \n import junit.framework.TestCase;\n+\n import org.apache.poi.hssf.record.CommonObjectDataSubRecord;\n import org.apache.poi.hssf.usermodel.HSSFClientAnchor;\n import org.apache.poi.hssf.usermodel.HSSFComment;\n@@ -37,7 +38,8 @@\n      *\n      * See Bug 51332\n      */\n-    public void testShapeId(){\n+    @SuppressWarnings(\"deprecation\")\n+\tpublic void testShapeId(){\n \n         HSSFClientAnchor anchor = new HSSFClientAnchor();\n         AbstractShape shape;",
                "raw_url": "https://github.com/apache/poi/raw/43710ae5f2895a268437520ed76ff1c293e452b3/src/testcases/org/apache/poi/hssf/model/TestShapes.java",
                "sha": "beed4a1d3857169e835413b3a947cba56baa3485",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/43710ae5f2895a268437520ed76ff1c293e452b3/test-data/spreadsheet/ar.org.apsme.www_Form%2520Inscripcion%2520Curso%2520NO%2520Socios.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/ar.org.apsme.www_Form%2520Inscripcion%2520Curso%2520NO%2520Socios.xls?ref=43710ae5f2895a268437520ed76ff1c293e452b3",
                "deletions": 0,
                "filename": "test-data/spreadsheet/ar.org.apsme.www_Form%20Inscripcion%20Curso%20NO%20Socios.xls",
                "raw_url": "https://github.com/apache/poi/raw/43710ae5f2895a268437520ed76ff1c293e452b3/test-data/spreadsheet/ar.org.apsme.www_Form%2520Inscripcion%2520Curso%2520NO%2520Socios.xls",
                "sha": "5554ab9f9f6ba51adde3ff6f1345054c98c6c66c",
                "status": "added"
            }
        ],
        "message": "Avoid possible NPE found via CommonCrawl files\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1678811 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/4df135705847177e67a73bf5b62045e813a1a041",
        "patched_files": [
            "HSSFShapeFactory.java",
            "ExcelExtractor.java",
            "ar.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestExcelExtractor.java",
            "TestShapes.java"
        ]
    },
    "poi_43c981a": {
        "bug_id": "poi_43c981a",
        "commit": "https://github.com/apache/poi/commit/43c981a497a760dd9e1118a9c317a66a8e48f190",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/43c981a497a760dd9e1118a9c317a66a8e48f190/src/java/org/apache/poi/hssf/model/Sheet.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/Sheet.java?ref=43c981a497a760dd9e1118a9c317a66a8e48f190",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/model/Sheet.java",
                "patch": "@@ -482,7 +482,7 @@ public void removeMergedRegion(int index)\n     public MergeCellsRecord.MergedRegion getMergedRegionAt(int index)\n     {\n         //safety checks\n-        if (index < numMergedRegions || mergedRecords.size() == 0)\n+        if (index >= numMergedRegions || mergedRecords.size() == 0)\n             return null;\n             \n         int pos = 0;",
                "raw_url": "https://github.com/apache/poi/raw/43c981a497a760dd9e1118a9c317a66a8e48f190/src/java/org/apache/poi/hssf/model/Sheet.java",
                "sha": "63127a08701afee49525d7f4a19097808f44d862",
                "status": "modified"
            }
        ],
        "message": "Fixes NullPointerException for getMergedRegionAt(index) when the index provided is valid (ie, 2 merged regions, request for index 0 would return null).\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@353023 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/01065fee5ecadc286d052786ded92e79f3f8927c",
        "patched_files": [
            "Sheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestSheet.java"
        ]
    },
    "poi_489bebb": {
        "bug_id": "poi_489bebb",
        "commit": "https://github.com/apache/poi/commit/489bebba0ee749cc961ce092bb4007d7c23343d2",
        "file": [
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/poi/blob/489bebba0ee749cc961ce092bb4007d7c23343d2/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java?ref=489bebba0ee749cc961ce092bb4007d7c23343d2",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "patch": "@@ -47,6 +47,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.xmlbeans.XmlException;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTSheet;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorkbook;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.STSheetState;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.WorkbookDocument;\n \n /**\n@@ -226,7 +227,16 @@ private SheetIterator(PackagePart wb) throws IOException {\n                 //step 2. Read array of CTSheet elements, wrap it in a ArayList and construct an iterator\n                 //Note, using XMLBeans might be expensive, consider refactoring to use SAX or a plain regexp search\n                 CTWorkbook wbBean = WorkbookDocument.Factory.parse(wb.getInputStream(), DEFAULT_XML_OPTIONS).getWorkbook();\n-                sheetIterator = wbBean.getSheets().getSheetList().iterator(); \n+                List<CTSheet> validSheets = new ArrayList<CTSheet>();\n+                for (CTSheet ctSheet : wbBean.getSheets().getSheetList()) {\n+                    //if there's no relationship id, silently skip the sheet\n+                     if (\"\".equals(ctSheet.getId())) {\n+                        //skip it\n+                    } else {\n+                        validSheets.add(ctSheet);\n+                    }\n+                }\n+                sheetIterator = validSheets.iterator();\n             } catch (InvalidFormatException e){\n                 throw new POIXMLException(e);\n             } catch (XmlException e){",
                "raw_url": "https://github.com/apache/poi/raw/489bebba0ee749cc961ce092bb4007d7c23343d2/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "sha": "2accb026571507f3fcf66e0edb529f56b0f5d869",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/489bebba0ee749cc961ce092bb4007d7c23343d2/src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java?ref=489bebba0ee749cc961ce092bb4007d7c23343d2",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java",
                "patch": "@@ -246,4 +246,23 @@ public void test58747() throws Exception {\n        \n        pkg.close();\n    }\n+\n+    /**\n+     * NPE when sheet has no relationship id in the workbook\n+     * 60825\n+     */\n+    public void testSheetWithNoRelationshipId() throws Exception {\n+        OPCPackage pkg =  XSSFTestDataSamples.openSamplePackage(\"60825.xlsx\");\n+        ReadOnlySharedStringsTable strings = new ReadOnlySharedStringsTable(pkg);\n+        assertNotNull(strings);\n+        XSSFReader reader = new XSSFReader(pkg);\n+        StylesTable styles = reader.getStylesTable();\n+        assertNotNull(styles);\n+\n+        XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) reader.getSheetsData();\n+        assertNotNull(iter.next());\n+        assertFalse(iter.hasNext());\n+\n+        pkg.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/489bebba0ee749cc961ce092bb4007d7c23343d2/src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java",
                "sha": "49742dc9d92b117ad8424e810c85f184a5ce238d",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/489bebba0ee749cc961ce092bb4007d7c23343d2/test-data/spreadsheet/60825.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/60825.xlsx?ref=489bebba0ee749cc961ce092bb4007d7c23343d2",
                "deletions": 0,
                "filename": "test-data/spreadsheet/60825.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/489bebba0ee749cc961ce092bb4007d7c23343d2/test-data/spreadsheet/60825.xlsx",
                "sha": "ffcfe08e619a852608f2692c7516ba5ca2261e04",
                "status": "added"
            }
        ],
        "message": "BUG-60285 avoid NPE if missing relationship id\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1765861 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e816f0f79faa290571b17c1140a6a393fe88e058",
        "patched_files": [
            "60825.java",
            "XSSFReader.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFReader.java"
        ]
    },
    "poi_48ef63e": {
        "bug_id": "poi_48ef63e",
        "commit": "https://github.com/apache/poi/commit/48ef63e2c50e528d8dacab929a214293f27bcb23",
        "file": [
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/POIXMLDocumentPart.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/POIXMLDocumentPart.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/POIXMLDocumentPart.java",
                "patch": "@@ -37,7 +37,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author Yegor Kozlov\n  */\n public class POIXMLDocumentPart {\n-    private static POILogger logger = POILogFactory.getLogger(POIXMLDocumentPart.class);\n+    private static final POILogger logger = POILogFactory.getLogger(POIXMLDocumentPart.class);\n \n     public static final XmlOptions DEFAULT_XML_OPTIONS;\n     static {\n@@ -86,7 +86,23 @@ public POIXMLDocumentPart(PackagePart part, PackageRelationship rel){\n         this.packagePart = part;\n         this.packageRel = rel;\n     }\n-    \n+\n+    /**\n+     * Creates an POIXMLDocumentPart representing the given package part, relationship and parent\n+     * Called by {@link #read(POIXMLFactory, java.util.Map)} when reading in an exisiting file.\n+     *\n+     * @param parent - Parent part\n+     * @param part - The package part that holds xml data represenring this sheet.\n+     * @param rel - the relationship of the given package part\n+     * @see #read(POIXMLFactory, java.util.Map)\n+     */\n+    public POIXMLDocumentPart(POIXMLDocumentPart parent, PackagePart part, PackageRelationship rel){\n+        this.relations = new LinkedList<POIXMLDocumentPart>();\n+        this.packagePart = part;\n+        this.packageRel = rel;\n+        this.parent = parent;\n+    }\n+\n     /**\n      * When you open something like a theme, call this to\n      *  re-base the XML Document onto the core child of the\n@@ -274,7 +290,7 @@ protected void read(POIXMLFactory factory, Map<PackagePart, POIXMLDocumentPart>\n                 }\n \n                 if (!context.containsKey(p)) {\n-    \t\t\t\tPOIXMLDocumentPart childPart = factory.createDocumentPart(rel, p);\n+    \t\t\t\tPOIXMLDocumentPart childPart = factory.createDocumentPart(this, rel, p);\n     \t\t\t\tchildPart.parent = this;\n     \t\t\t\taddRelation(childPart);\n                     if(p != null){",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/POIXMLDocumentPart.java",
                "sha": "993413c1b0d74dcc612d39ebb5c9152792cefbd7",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/POIXMLFactory.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/POIXMLFactory.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/POIXMLFactory.java",
                "patch": "@@ -30,11 +30,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * Create a POIXMLDocumentPart from existing package part and relation. This method is called\n      * from {@link POIXMLDocument#load(POIXMLFactory)} when parsing a document\n      *\n+     * @param parent parent part\n      * @param rel   the package part relationship\n      * @param part  the PackagePart representing the created instance\n      * @return A new instance of a POIXMLDocumentPart.\n      */\n-     public abstract POIXMLDocumentPart createDocumentPart(PackageRelationship rel, PackagePart part);\n+     public abstract POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackageRelationship rel, PackagePart part);\n \n     /**\n      * Create a new POIXMLDocumentPart using the supplied descriptor. This method is used when adding new parts",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/POIXMLFactory.java",
                "sha": "6eebbd9c2e89eb2a6c177b7175e959fbe7a40965",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFFactory.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFFactory.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFFactory.java",
                "patch": "@@ -34,7 +34,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author Yegor Kozlov\n  */\n public final class XSSFFactory extends POIXMLFactory  {\n-    private static POILogger logger = POILogFactory.getLogger(XSSFFactory.class);\n+    private static final POILogger logger = POILogFactory.getLogger(XSSFFactory.class);\n \n     private XSSFFactory(){\n \n@@ -46,7 +46,8 @@ public static XSSFFactory getInstance(){\n         return inst;\n     }\n \n-    public POIXMLDocumentPart createDocumentPart(PackageRelationship rel, PackagePart part){\n+    @Override\n+    public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackageRelationship rel, PackagePart part){\n         POIXMLRelation descriptor = XSSFRelation.getInstance(rel.getRelationshipType());\n         if(descriptor == null || descriptor.getRelationClass() == null){\n             logger.log(POILogger.DEBUG, \"using default POIXMLDocumentPart for \" + rel.getRelationshipType());\n@@ -62,6 +63,7 @@ public POIXMLDocumentPart createDocumentPart(PackageRelationship rel, PackagePar\n         }\n     }\n \n+    @Override\n     public POIXMLDocumentPart newDocumentPart(POIXMLRelation descriptor){\n         try {\n             Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFFactory.java",
                "sha": "7855e424583878914535eae1e4001baf8320d0fa",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/model/XWPFHeaderFooterPolicy.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/model/XWPFHeaderFooterPolicy.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/model/XWPFHeaderFooterPolicy.java",
                "patch": "@@ -109,7 +109,7 @@ public XWPFHeaderFooterPolicy(XWPFDocument doc, CTSectPr sectPr) throws IOExcept\n \t\t\tPackagePart hdrPart = doc.getPartById(ref.getId());\n \t\t\tHdrDocument hdrDoc = HdrDocument.Factory.parse(hdrPart.getInputStream());\n \t\t\tCTHdrFtr hdrFtr = hdrDoc.getHdr();\n-\t\t\tXWPFHeader hdr = new XWPFHeader(hdrFtr);\n+\t\t\tXWPFHeader hdr = new XWPFHeader(doc, hdrFtr);\n \n \t\t\t// Assign it\n \t\t\tEnum type = ref.getType();\n@@ -119,7 +119,7 @@ public XWPFHeaderFooterPolicy(XWPFDocument doc, CTSectPr sectPr) throws IOExcept\n \t\t\t// Get the footer\n \t\t\tCTHdrFtrRef ref = sectPr.getFooterReferenceArray(i);\n \t\t\tPackagePart ftrPart = doc.getPartById(ref.getId());\n-\t\t\tXWPFFooter ftr = new XWPFFooter(\n+\t\t\tXWPFFooter ftr = new XWPFFooter(doc, \n \t\t\t\t\tFtrDocument.Factory.parse(ftrPart.getInputStream()).getFtr());\n \n \t\t\t// Assign it\n@@ -460,6 +460,6 @@ private XWPFParagraph getWatermarkParagraph(String text, int idx) {\n \t\tshapeTextPath.setString(text);\n \t\tpict.set(group);\n \t\t// end watermark paragraph\n-\t\treturn new XWPFParagraph(p, null);\n+\t\treturn new XWPFParagraph(p, doc);\n \t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/model/XWPFHeaderFooterPolicy.java",
                "sha": "3a5b77effd94336474883fd9e559168ecded9a45",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/IBody.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/IBody.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/IBody.java",
                "patch": "@@ -62,8 +62,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t *  the text of the header or footer.\n \t */\n     public List<XWPFParagraph> getParagraphs();\n-\t\n-\t\n+\n \t/**\n \t * Return the table(s) that holds the text\n \t *  of the IBodyPart, for complex cases\n@@ -123,6 +122,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t * @param cell\n \t */\n \tXWPFTableCell getTableCell(CTTc cell);\n-\t\n+\n+    /**\n+     * Return XWPFDocument\n+     */\n+    public XWPFDocument getXWPFDocument();\n+\n }\n ",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/IBody.java",
                "sha": "a85ec7408acedd5e31b2bca602e0f13e6d6ba89b",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFComment.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFComment.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFComment.java",
                "patch": "@@ -31,15 +31,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     protected String author;\n     protected StringBuffer text;\n     \n-    public XWPFComment(CTComment comment)\n+    public XWPFComment(CTComment comment, XWPFDocument document)\n     {\n         text = new StringBuffer();\n         id = comment.getId().toString();\n         author = comment.getAuthor();\n         \n         for(CTP ctp : comment.getPList())\n         {\n-            XWPFParagraph p = new XWPFParagraph(ctp, null);\n+            XWPFParagraph p = new XWPFParagraph(ctp, document);\n             text.append(p.getText());\n         }\n     }",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFComment.java",
                "sha": "d193983c7918468209b8561cc08b65cb29aa811a",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 13,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java",
                "patch": "@@ -165,25 +165,18 @@ protected void onDocumentRead() throws IOException {\n                 String relation = p.getPackageRelationship().getRelationshipType();\n                 if(relation.equals(XWPFRelation.STYLES.getRelation())){\n                 \tthis.styles = (XWPFStyles) p;\n-                }\n-                else if(relation.equals(XWPFRelation.NUMBERING.getRelation())){\n+                } else if (relation.equals(XWPFRelation.NUMBERING.getRelation())){\n                 \tthis.numbering = (XWPFNumbering) p;\n-\n-                }\n-                else if(relation.equals(XWPFRelation.FOOTER.getRelation())){\n+                } else if (relation.equals(XWPFRelation.FOOTER.getRelation())){\n                 \tfooters.add((XWPFFooter)p);\n-                }\n-                else if(relation.equals(XWPFRelation.HEADER.getRelation())){\n+                } else if (relation.equals(XWPFRelation.HEADER.getRelation())){\n                 \theaders.add((XWPFHeader)p);\n-                }\n-\n-                else if(relation.equals(XWPFRelation.COMMENT.getRelation())){\n+                } else if (relation.equals(XWPFRelation.COMMENT.getRelation())){\n                     CommentsDocument cmntdoc = CommentsDocument.Factory.parse(p.getPackagePart().getInputStream());\n                     for(CTComment ctcomment : cmntdoc.getComments().getCommentList()) {\n-                        comments.add(new XWPFComment(ctcomment));\n+                        comments.add(new XWPFComment(ctcomment, this));\n                     }\n-                }\n-                else if(relation.equals(XWPFRelation.SETTINGS.getRelation())){\n+                } else if (relation.equals(XWPFRelation.SETTINGS.getRelation())){\n                 \tsettings = (XWPFSettings)p;\n                 }\n             }\n@@ -254,6 +247,7 @@ protected static OPCPackage newPackage() {\n     /**\n      * Create a new CTWorkbook with all values set to default\n      */\n+    @Override\n     protected void onDocumentCreate() {\n         hyperlinks = new ArrayList<XWPFHyperlink>();\n         comments = new ArrayList<XWPFComment>();\n@@ -429,6 +423,7 @@ public CTStyles getStyle() throws XmlException, IOException {\n     /**\n      * Get the document's embedded files.\n      */\n+    @Override\n     public List<PackagePart> getAllEmbedds() throws OpenXML4JException {\n         List<PackagePart> embedds = new LinkedList<PackagePart>();\n \n@@ -1116,4 +1111,8 @@ public XWPFTableCell getTableCell(CTTc cell) {\n \t\t}\n \t\treturn tableRow.getTableCell(cell);\n \t}\n+\n+    public XWPFDocument getXWPFDocument() {\n+        return this;\n+    }\n }//end class",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java",
                "sha": "d4c22045918b35609502144b6508ff10432f8f5e",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFactory.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFactory.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 4,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFactory.java",
                "patch": "@@ -33,7 +33,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public final class XWPFFactory extends POIXMLFactory  {\n \n-    private static POILogger logger = POILogFactory.getLogger(XWPFFactory.class);\n+    private static final POILogger logger = POILogFactory.getLogger(XWPFFactory.class);\n \n     private XWPFFactory(){\n \n@@ -45,7 +45,8 @@ public static XWPFFactory getInstance(){\n         return inst;\n     }\n \n-    public POIXMLDocumentPart createDocumentPart(PackageRelationship rel, PackagePart part){\n+    @Override\n+    public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackageRelationship rel, PackagePart part){\n         POIXMLRelation descriptor = XWPFRelation.getInstance(rel.getRelationshipType());\n         if(descriptor == null || descriptor.getRelationClass() == null){\n             logger.log(POILogger.DEBUG, \"using default POIXMLDocumentPart for \" + rel.getRelationshipType());\n@@ -54,13 +55,19 @@ public POIXMLDocumentPart createDocumentPart(PackageRelationship rel, PackagePar\n \n         try {\n             Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();\n-            Constructor<? extends POIXMLDocumentPart> constructor = cls.getDeclaredConstructor(PackagePart.class, PackageRelationship.class);\n-            return constructor.newInstance(part, rel);\n+            try {\n+                Constructor<? extends POIXMLDocumentPart> constructor = cls.getDeclaredConstructor(POIXMLDocumentPart.class, PackagePart.class, PackageRelationship.class);\n+                return constructor.newInstance(parent, part, rel);\n+            } catch (NoSuchMethodException e) {\n+                Constructor<? extends POIXMLDocumentPart> constructor = cls.getDeclaredConstructor(PackagePart.class, PackageRelationship.class);\n+                return constructor.newInstance(part, rel);\n+            }\n         } catch (Exception e){\n             throw new POIXMLException(e);\n         }\n     }\n \n+    @Override\n     public POIXMLDocumentPart newDocumentPart(POIXMLRelation descriptor){\n         try {\n             Class<? extends POIXMLDocumentPart> cls = descriptor.getRelationClass();",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFactory.java",
                "sha": "c6b2c2d3e4ccf484db59a3dc2a09965fe45c25bb",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFooter.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFooter.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 10,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFooter.java",
                "patch": "@@ -25,6 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import javax.xml.namespace.QName;\n \n+import org.apache.poi.POIXMLDocumentPart;\n import org.apache.poi.openxml4j.opc.PackagePart;\n import org.apache.poi.openxml4j.opc.PackageRelationship;\n import org.apache.xmlbeans.XmlCursor;\n@@ -41,13 +42,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * Sketch of XWPF footer class\n  */\n public class XWPFFooter extends XWPFHeaderFooter {\n-\tpublic XWPFFooter() {\n-\t\tsuper();\n-\t}\n-\t\n-\t\n-\tpublic XWPFFooter(CTHdrFtr hdrFtr) throws IOException {\n-\t\tsuper(hdrFtr);\n+    public XWPFFooter() {\n+        super();\n+    }\n+\n+\tpublic XWPFFooter(XWPFDocument doc, CTHdrFtr hdrFtr) throws IOException {\n+\t\tsuper(doc, hdrFtr);\n \t\tbodyElements = new ArrayList<IBodyElement>();\n \t\tparagraphs = new ArrayList<XWPFParagraph>();\n \t\ttables = new ArrayList<XWPFTable>();\n@@ -69,8 +69,8 @@ public XWPFFooter(CTHdrFtr hdrFtr) throws IOException {\n         getAllPictures();\n \t}\n \n-\tpublic XWPFFooter(PackagePart part, PackageRelationship rel) throws IOException {\n-\t\tsuper(part, rel);\n+\tpublic XWPFFooter(POIXMLDocumentPart parent, PackagePart part, PackageRelationship rel) throws IOException {\n+\t\tsuper(parent, part, rel);\n \t}\n \t\n \t/**\n@@ -149,5 +149,4 @@ public IBody getPart() {\n \t\tpublic BodyType getPartType() {\n \t\t\treturn BodyType.FOOTER;\n \t\t}\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFFooter.java",
                "sha": "73834d767216417814c294e2c42e92854f67e68d",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeader.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeader.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 9,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeader.java",
                "patch": "@@ -42,17 +42,16 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * Sketch of XWPF header class\n  */\n public class XWPFHeader extends XWPFHeaderFooter {\n-\t\n-\tpublic XWPFHeader() {\n-\t\tsuper();\n-\t}\n-\t\n-\tpublic XWPFHeader(PackagePart part, PackageRelationship rel) throws IOException {\n-\t\tsuper(part, rel);\n+    public XWPFHeader() {\n+        super();\n+    }\n+\n+    public XWPFHeader(POIXMLDocumentPart parent, PackagePart part, PackageRelationship rel) throws IOException {\n+\t\tsuper(parent, part, rel);\n \t}\n \t\n-\tpublic XWPFHeader(CTHdrFtr hdrFtr) throws IOException {\n-\t\tsuper(hdrFtr);\n+\tpublic XWPFHeader(XWPFDocument doc, CTHdrFtr hdrFtr) throws IOException {\n+\t\tsuper(doc, hdrFtr);\n \t\tparagraphs = new ArrayList<XWPFParagraph>();\n \t\ttables = new ArrayList<XWPFTable>();\n \t\tXmlCursor cursor = headerFooter.newCursor();",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeader.java",
                "sha": "d49aa5d7ecdbc7c1e5463380c3bd8b00c76988ae",
                "status": "modified"
            },
            {
                "additions": 27,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java",
                "changes": 35,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 8,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java",
                "patch": "@@ -51,18 +51,31 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tprotected XWPFDocument document;\n \tprotected List<IBodyElement> bodyElements;\n \t\n-\tprotected XWPFHeaderFooter(CTHdrFtr hdrFtr){\n+\tprotected XWPFHeaderFooter(XWPFDocument doc, CTHdrFtr hdrFtr){\n+        if (doc==null) {\n+            throw new NullPointerException();\n+        }\n+\n+        document = doc;\n \t\theaderFooter = hdrFtr;\n \t\treadHdrFtr();\n \t}\n-\tprotected XWPFHeaderFooter() {\n-\t   this(CTHdrFtr.Factory.newInstance());\n-\t}\n \n-\tpublic XWPFHeaderFooter(PackagePart part, PackageRelationship rel) throws IOException {\n-\t\tsuper(part, rel);\n+    protected XWPFHeaderFooter() {\n+        headerFooter = CTHdrFtr.Factory.newInstance();\n+        readHdrFtr();\n+    }\n+\n+\n+    public XWPFHeaderFooter(POIXMLDocumentPart parent, PackagePart part, PackageRelationship rel) throws IOException {\n+\t\tsuper(parent, part, rel);\n \t\tthis.document = (XWPFDocument)getParent();\n-      onDocumentRead();\n+\n+        if (this.document==null) {\n+            throw new NullPointerException();\n+        }\n+\n+        onDocumentRead();\n \t}\n \t\n     @Internal\n@@ -523,5 +536,11 @@ public XWPFTableCell getTableCell(CTTc cell) {\n \t\treturn tableRow.getTableCell(cell);\n \t}\n   \t\n-    \n+    public XWPFDocument getXWPFDocument() {\n+        if (document!=null) {\n+            return document;\n+        } else {\n+            return (XWPFDocument)getParent();\n+        }\n+    }\n }//end class",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java",
                "sha": "5aedc15f9b98cc2eef866d7598497314726ab9e9",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 12,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "patch": "@@ -55,30 +55,24 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * Sketch of XWPF paragraph class\n  */\n public class XWPFParagraph implements IBodyElement{\n-    private CTP paragraph;\n+    private final CTP paragraph;\n     protected IBody part;\n     /** For access to the document's hyperlink, comments, tables etc */\n     protected XWPFDocument document;\n     protected List<XWPFRun> runs;\n     \n     private StringBuffer footnoteText = new StringBuffer();\n \n-    public XWPFParagraph(CTP prgrph) {\n-        this(prgrph, null);\n-    }\n-\n-\n     public XWPFParagraph(CTP prgrph, IBody part) {\n         this.paragraph = prgrph;\n         this.part = part;\n         \n-        // We only care about the document (for comments,\n-        //  hyperlinks etc) if we're attached to the\n-        //  core document\n-        if(part instanceof XWPFDocument) {\n-           this.document = (XWPFDocument)part;\n+        this.document = part.getXWPFDocument();\n+\n+        if (document==null) {\n+            throw new NullPointerException();\n         }\n-        \n+\n         runs = new ArrayList<XWPFRun>();\n \n        // Get all our child nodes in order, and process them",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "sha": "7b33d48c0480ee473afa2c976d991f402e274322",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "patch": "@@ -30,8 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n \n public class XWPFTableCell implements IBody {\n-\n-    private CTTc ctTc;\n+    private final CTTc ctTc;\n     protected List<XWPFParagraph> paragraphs = null;\n     protected List<XWPFTable> tables = null;\n     protected List<IBodyElement> bodyElements = null;\n@@ -256,7 +255,7 @@ public XWPFParagraph getParagraphArray(int pos) {\n \t * @see org.apache.poi.xwpf.usermodel.IBody#getPart()\n \t */\n \tpublic IBody getPart() {\n-\t\treturn (IBody) tableRow.getTable().getPart();\n+\t\treturn tableRow.getTable().getPart();\n \t}\n \n \n@@ -351,4 +350,8 @@ public XWPFTableCell getTableCell(CTTc cell) {\n \t\t}\n \t\treturn tableRow.getTableCell(cell);\n \t}\n+\n+    public XWPFDocument getXWPFDocument() {\n+        return part.getXWPFDocument();\n+    }\n }// end class",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "sha": "656bf307a8680f514bbd1c40db2d2945a5a49541",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/testcases/org/apache/poi/TestPOIXMLDocument.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/TestPOIXMLDocument.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 1,
                "filename": "src/ooxml/testcases/org/apache/poi/TestPOIXMLDocument.java",
                "patch": "@@ -57,7 +57,7 @@ public void parse(POIXMLFactory factory) throws IOException{\n         public TestFactory() {\n             //\n         }\n-        public POIXMLDocumentPart createDocumentPart(PackageRelationship rel, PackagePart part){\n+        public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackageRelationship rel, PackagePart part){\n             return new POIXMLDocumentPart(part, rel);\n         }\n ",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/testcases/org/apache/poi/TestPOIXMLDocument.java",
                "sha": "4e7f788e67d4e27d1c96a6103bf2585469794108",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFHeader.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFHeader.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 7,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFHeader.java",
                "patch": "@@ -76,12 +76,12 @@ public void testSetHeader() throws IOException {\n \t\tCTText t3 = ctR3.addNewT();\n \t\tt3.setStringValue(\"Second paragraph for the footer\");\n \n-\t\tXWPFParagraph p1 = new XWPFParagraph(ctP1);\n+\t\tXWPFParagraph p1 = new XWPFParagraph(ctP1, sampleDoc);\n \t\tXWPFParagraph[] pars = new XWPFParagraph[1];\n \t\tpars[0] = p1;\n \n-\t\tXWPFParagraph p2 = new XWPFParagraph(ctP2);\n-\t\tXWPFParagraph p3 = new XWPFParagraph(ctP3, null);\n+\t\tXWPFParagraph p2 = new XWPFParagraph(ctP2, sampleDoc);\n+\t\tXWPFParagraph p3 = new XWPFParagraph(ctP3, sampleDoc);\n \t\tXWPFParagraph[] pars2 = new XWPFParagraph[2];\n \t\tpars2[0] = p2;\n \t\tpars2[1] = p3;\n@@ -98,7 +98,7 @@ public void testSetHeader() throws IOException {\n \t\tassertNotNull(policy.getDefaultFooter());\n \t\t// ....and that the footer object captured above contains two\n \t\t// paragraphs of text.\n-\t\tassertEquals(footer.getParagraphs().size(), 2);\n+\t\tassertEquals(2, footer.getParagraphs().size());\n \t\t\n \t\t// As an additional check, recover the defauls footer and\n \t\t// make sure that it contains two paragraphs of text and that\n@@ -111,9 +111,9 @@ public void testSetHeader() throws IOException {\n \t\t   paras[i++] = p;\n \t\t}\n \t\t\n-\t\tassertEquals(paras.length, 2);\n-\t\tassertEquals(paras[0].getText(), \"First paragraph for the footer\");\n-\t\tassertEquals(paras[1].getText(), \"Second paragraph for the footer\");\n+\t\tassertEquals(2, paras.length);\n+\t\tassertEquals(\"First paragraph for the footer\", paras[0].getText());\n+\t\tassertEquals(\"Second paragraph for the footer\", paras[1].getText());\n \t}\n \n \tpublic void testSetWatermark() {",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFHeader.java",
                "sha": "b46f8d32acca0a68704b3082cda492bb155e4a3d",
                "status": "modified"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/poi/blob/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTable.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTable.java?ref=48ef63e2c50e528d8dacab929a214293f27bcb23",
                "deletions": 7,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTable.java",
                "patch": "@@ -42,15 +42,16 @@ protected void setUp() {\n     }\n \n     public void testConstructor() {\n+        XWPFDocument doc = new XWPFDocument();\n         CTTbl ctTable = CTTbl.Factory.newInstance();\n-        XWPFTable xtab = new XWPFTable(ctTable, null);\n+        XWPFTable xtab = new XWPFTable(ctTable, doc);\n         assertNotNull(xtab);\n         assertEquals(1, ctTable.sizeOfTrArray());\n         assertEquals(1, ctTable.getTrArray(0).sizeOfTcArray());\n         assertNotNull(ctTable.getTrArray(0).getTcArray(0).getPArray(0));\n \n         ctTable = CTTbl.Factory.newInstance();\n-        xtab = new XWPFTable(ctTable, null, 3, 2);\n+        xtab = new XWPFTable(ctTable, doc, 3, 2);\n         assertNotNull(xtab);\n         assertEquals(3, ctTable.sizeOfTrArray());\n         assertEquals(2, ctTable.getTrArray(0).sizeOfTcArray());\n@@ -59,6 +60,7 @@ public void testConstructor() {\n \n \n     public void testGetText() {\n+        XWPFDocument doc = new XWPFDocument();\n         CTTbl table = CTTbl.Factory.newInstance();\n         CTRow row = table.addNewTr();\n         CTTc cell = row.addNewTc();\n@@ -67,12 +69,14 @@ public void testGetText() {\n         CTText text = run.addNewT();\n         text.setStringValue(\"finally I can write!\");\n \n-        XWPFTable xtab = new XWPFTable(table, null);\n+        XWPFTable xtab = new XWPFTable(table, doc);\n         assertEquals(\"finally I can write!\\n\", xtab.getText());\n     }\n \n \n     public void testCreateRow() {\n+        XWPFDocument doc = new XWPFDocument();\n+\n         CTTbl table = CTTbl.Factory.newInstance();\n         CTRow r1 = table.addNewTr();\n         r1.addNewTc().addNewP();\n@@ -84,7 +88,7 @@ public void testCreateRow() {\n         r3.addNewTc().addNewP();\n         r3.addNewTc().addNewP();\n \n-        XWPFTable xtab = new XWPFTable(table, null);\n+        XWPFTable xtab = new XWPFTable(table, doc);\n         assertEquals(3, xtab.getNumberOfRows());\n         assertNotNull(xtab.getRow(2));\n \n@@ -95,16 +99,18 @@ public void testCreateRow() {\n         assertEquals(2, table.getTrArray(0).sizeOfTcArray());\n \n         //check creation of first row\n-        xtab = new XWPFTable(CTTbl.Factory.newInstance(), null);\n+        xtab = new XWPFTable(CTTbl.Factory.newInstance(), doc);\n         assertEquals(1, xtab.getCTTbl().getTrArray(0).sizeOfTcArray());\n     }\n \n \n     public void testSetGetWidth() {\n+        XWPFDocument doc = new XWPFDocument();\n+        \n         CTTbl table = CTTbl.Factory.newInstance();\n         table.addNewTblPr().addNewTblW().setW(new BigInteger(\"1000\"));\n \n-        XWPFTable xtab = new XWPFTable(table, null);\n+        XWPFTable xtab = new XWPFTable(table, doc);\n \n         assertEquals(1000, xtab.getWidth());\n \n@@ -113,9 +119,11 @@ public void testSetGetWidth() {\n     }\n \n     public void testSetGetHeight() {\n+        XWPFDocument doc = new XWPFDocument();\n+\n         CTTbl table = CTTbl.Factory.newInstance();\n \n-        XWPFTable xtab = new XWPFTable(table, null);\n+        XWPFTable xtab = new XWPFTable(table, doc);\n         XWPFTableRow row = xtab.createRow();\n         row.setHeight(20);\n         assertEquals(20, row.getHeight());",
                "raw_url": "https://github.com/apache/poi/raw/48ef63e2c50e528d8dacab929a214293f27bcb23/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTable.java",
                "sha": "91f43f4dffc64efd976a14abb0c692a319e546d2",
                "status": "modified"
            }
        ],
        "message": "    Ensure that XWPFParagraph.getDocument() is not null\n    (Null getDocument() causes NPE when looking for comments in XWPFWordExtractorDecorator)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1028283 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1f49e93b24b9d4790717b1464ef7ce4aec619a0b",
        "patched_files": [
            "XWPFHeaderFooter.java",
            "POIXMLFactory.java",
            "XWPFFactory.java",
            "XWPFComment.java",
            "XWPFParagraph.java",
            "XWPFFooter.java",
            "XWPFHeaderFooterPolicy.java",
            "XWPFDocument.java",
            "XWPFTable.java",
            "POIXMLDocumentPart.java",
            "XSSFFactory.java",
            "IBody.java",
            "XWPFTableCell.java",
            "POIXMLDocument.java",
            "XWPFHeader.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFHeader.java",
            "TestXWPFComment.java",
            "TestXWPFTable.java",
            "TestXWPFTableCell.java",
            "TestXWPFHeaderFooterPolicy.java",
            "TestXWPFParagraph.java",
            "TestPOIXMLDocument.java",
            "TestXWPFDocument.java"
        ]
    },
    "poi_4ce3e5d": {
        "bug_id": "poi_4ce3e5d",
        "commit": "https://github.com/apache/poi/commit/4ce3e5def53c893012d6ba709e9beff95a149d48",
        "file": [
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/4ce3e5def53c893012d6ba709e9beff95a149d48/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java?ref=4ce3e5def53c893012d6ba709e9beff95a149d48",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "patch": "@@ -37,6 +37,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.openxml4j.opc.PackageRelationshipCollection;\n import org.apache.poi.openxml4j.opc.PackageRelationshipTypes;\n import org.apache.poi.openxml4j.opc.PackagingURIHelper;\n+import org.apache.poi.util.POILogFactory;\n+import org.apache.poi.util.POILogger;\n import org.apache.poi.xssf.model.CommentsTable;\n import org.apache.poi.xssf.model.SharedStringsTable;\n import org.apache.poi.xssf.model.StylesTable;\n@@ -57,6 +59,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  *  for XSSF.\n  */\n public class XSSFReader {\n+\n+    private static final POILogger LOGGER = POILogFactory.getLogger(XSSFReader.class);\n+\n     private OPCPackage pkg;\n     private PackagePart workbookPart;\n \n@@ -318,6 +323,11 @@ public CommentsTable getSheetComments() {\n                   PackageRelationship drawings = drawingsList.getRelationship(i);\n                   PackagePartName drawingsName = PackagingURIHelper.createPartName(drawings.getTargetURI());\n                   PackagePart drawingsPart = sheetPkg.getPackage().getPart(drawingsName);\n+                  if (drawingsPart == null) {\n+                      //parts can go missing; Excel ignores them silently -- TIKA-2134\n+                      LOGGER.log(POILogger.WARN, \"Missing drawing: \"+drawingsName +\". Skipping it.\");\n+                      continue;\n+                  }\n                   XSSFDrawing drawing = new XSSFDrawing(drawingsPart);\n                   for (XSSFShape shape : drawing.getShapes()){\n                       shapes.add(shape);",
                "raw_url": "https://github.com/apache/poi/raw/4ce3e5def53c893012d6ba709e9beff95a149d48/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "sha": "e5c9cb25b10333e922d7fa51b3c2c7af0e7be1e4",
                "status": "modified"
            }
        ],
        "message": "bug 60584 -- avoid NPE by checking for null/missing image in XSSFReader's getShapes().\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1778664 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/bdc2e2fe04bcf322d790c1c633fcc4c392b07458",
        "patched_files": [
            "XSSFReader.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFReader.java"
        ]
    },
    "poi_4eb322b": {
        "bug_id": "poi_4eb322b",
        "commit": "https://github.com/apache/poi/commit/4eb322bae7e3fc8353f3a1f5290562ccf019a9e4",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/4eb322bae7e3fc8353f3a1f5290562ccf019a9e4/src/scratchpad/src/org/apache/poi/hwpf/model/StyleSheet.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/StyleSheet.java?ref=4eb322bae7e3fc8353f3a1f5290562ccf019a9e4",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/StyleSheet.java",
                "patch": "@@ -278,14 +278,15 @@ private void createChp(int istd)\n           CharacterProperties parentCHP = new CharacterProperties();\n           if(baseIndex != NIL_STYLE)\n           {\n-\n               parentCHP = _styleDescriptions[baseIndex].getCHP();\n               if(parentCHP == null)\n               {\n                   createChp(baseIndex);\n                   parentCHP = _styleDescriptions[baseIndex].getCHP();\n               }\n-\n+              if(parentCHP == null) {\n+                  parentCHP = new CharacterProperties();\n+              }\n           }\n \n           chp = CharacterSprmUncompressor.uncompressCHP(parentCHP, chpx, 0);",
                "raw_url": "https://github.com/apache/poi/raw/4eb322bae7e3fc8353f3a1f5290562ccf019a9e4/src/scratchpad/src/org/apache/poi/hwpf/model/StyleSheet.java",
                "sha": "ba213b7a4e477181db205ed6718700699ca89498",
                "status": "modified"
            }
        ],
        "message": "Fix bug 54725 - HWPF where no parent style CHP exists, use an empty\n set when processing the style to avoid a NPE\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1614926 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/a4e29760f894f8af8a1b7225cbcc3df3eb000251",
        "patched_files": [
            "StyleSheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestStyleSheet.java"
        ]
    },
    "poi_5112fb2": {
        "bug_id": "poi_5112fb2",
        "commit": "https://github.com/apache/poi/commit/5112fb2cc89151f78a9abf1f8b46075bdbc285bf",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/5112fb2cc89151f78a9abf1f8b46075bdbc285bf/src/java/org/apache/poi/hssf/model/Sheet.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/Sheet.java?ref=5112fb2cc89151f78a9abf1f8b46075bdbc285bf",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/model/Sheet.java",
                "patch": "@@ -783,7 +783,7 @@ private int serializeIndexRecord(final int BOFRecordIndex, final int offset, byt\n       int dbCellOffset = 0;\n       for (int block=0;block<blockCount;block++) {\n         rowBlockOffset += rows.getRowBlockSize(block);\n-        cellBlockOffset += cells.getRowCellBlockSize(rows.getStartRowNumberForBlock(block),\n+        cellBlockOffset += null == cells ? 0 : cells.getRowCellBlockSize(rows.getStartRowNumberForBlock(block),\n                                                      rows.getEndRowNumberForBlock(block));\n         //Note: The offsets are relative to the Workbook BOF. Assume that this is\n         //0 for now.....",
                "raw_url": "https://github.com/apache/poi/raw/5112fb2cc89151f78a9abf1f8b46075bdbc285bf/src/java/org/apache/poi/hssf/model/Sheet.java",
                "sha": "140b5c17155517354c375fd597e0ef500b886150",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/5112fb2cc89151f78a9abf1f8b46075bdbc285bf/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java?ref=5112fb2cc89151f78a9abf1f8b46075bdbc285bf",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "patch": "@@ -213,7 +213,7 @@ public int serialize(int offset, byte [] data, ValueRecordsAggregate cells)\n           //Note: Cell references start from the second row...\n           int cellRefOffset = (rowBlockSize-20);\n           for (int row=startRowNumber;row<=endRowNumber;row++) {\n-            if (cells.rowHasCells(row)) {\n+            if (null != cells && cells.rowHasCells(row)) {\n               final int rowCellSize = cells.serializeCellRow(row, pos, data);\n               pos += rowCellSize;\n               //Add the offset to the first cell for the row into the DBCellRecord.",
                "raw_url": "https://github.com/apache/poi/raw/5112fb2cc89151f78a9abf1f8b46075bdbc285bf/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "sha": "abef0159c5a0cb3311888959cb4bf7c753a452e6",
                "status": "modified"
            },
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/poi/blob/5112fb2cc89151f78a9abf1f8b46075bdbc285bf/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "changes": 43,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java?ref=5112fb2cc89151f78a9abf1f8b46075bdbc285bf",
                "deletions": 5,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "patch": "@@ -19,9 +19,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.usermodel;\n \n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n+import java.io.*;\n \n import junit.framework.TestCase;\n \n@@ -481,8 +479,43 @@ public void testDefaultColumnStyle() {\n \tHSSFCell c = r.createCell((short)0);\n \tassertEquals(\"style should match\", style.getIndex(), c.getCellStyle().getIndex());\n     }\n-\t \n-\t \n+\n+\n+    /**\n+     *\n+     */\n+    public void testAddEmptyRow() throws Exception {\n+        //try to add 5 empty rows to a new sheet\n+        HSSFWorkbook workbook = new HSSFWorkbook();\n+        HSSFSheet sheet = workbook.createSheet();\n+        for (int i = 0; i < 5; i++) sheet.createRow(i);\n+\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        workbook.write(out);\n+        out.close();\n+\n+        workbook = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n+        assertTrue(\"No Exceptions while reading file\", true);\n+\n+        //try adding empty rows in an existing worksheet\n+        String cwd = System.getProperty(\"HSSF.testdata.path\");\n+        FileInputStream in = new FileInputStream(new File(cwd, \"Simple.xls\"));\n+        workbook = new HSSFWorkbook(in);\n+        in.close();\n+        assertTrue(\"No Exceptions while reading file\", true);\n+\n+        sheet = workbook.getSheetAt(0);\n+        for (int i = 3; i < 10; i++) sheet.createRow(i);\n+\n+        out = new ByteArrayOutputStream();\n+        workbook.write(out);\n+        out.close();\n+\n+        workbook = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n+        assertTrue(\"No Exceptions while reading file\", true);\n+\n+    }\n+\n \tpublic static void main(java.lang.String[] args) {\n \t\t junit.textui.TestRunner.run(TestHSSFSheet.class);\n \t}    ",
                "raw_url": "https://github.com/apache/poi/raw/5112fb2cc89151f78a9abf1f8b46075bdbc285bf/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "sha": "2a8561ebd68ce5bb83c092c8a730c6cdb93fcc00",
                "status": "modified"
            }
        ],
        "message": "fixed bug 41761: NPE when serializing a workbook with empty rows \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@520416 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/c08c5658baefe6378bab2f7486d2428447e7181a",
        "patched_files": [
            "RowRecordsAggregate.java",
            "HSSFSheet.java",
            "Sheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHSSFSheet.java",
            "TestSheet.java",
            "TestRowRecordsAggregate.java"
        ]
    },
    "poi_5165372": {
        "bug_id": "poi_5165372",
        "commit": "https://github.com/apache/poi/commit/51653729ce39bab500b910cfc4ee07e21fe2beaf",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/51653729ce39bab500b910cfc4ee07e21fe2beaf/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=51653729ce39bab500b910cfc4ee07e21fe2beaf",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.8-beta1\" date=\"2010-??-??\">\n+           <action dev=\"poi-developers\" type=\"fix\">50795 - Avoid NPE from xmlbeans when moving XSSF Comments from one cell to another</action>\n            <action dev=\"poi-developers\" type=\"fix\">46664 - When creating HSSF Print Areas, ensure the named range is reference based not value based</action>\n            <action dev=\"poi-developers\" type=\"fix\">50756 - When formatting numbers based on their Cell Style, treat GENERAL the same as the more typical General</action>\n            <action dev=\"poi-developers\" type=\"fix\">fixed HSSFWorkbook.createCellStyle to throw exception if the maximum number of cell styles was exceeded</action>",
                "raw_url": "https://github.com/apache/poi/raw/51653729ce39bab500b910cfc4ee07e21fe2beaf/src/documentation/content/xdocs/status.xml",
                "sha": "44524a32ae4203707dc9288689df7ad0365e05ef",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/51653729ce39bab500b910cfc4ee07e21fe2beaf/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFComment.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFComment.java?ref=51653729ce39bab500b910cfc4ee07e21fe2beaf",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFComment.java",
                "patch": "@@ -116,7 +116,16 @@ public void setColumn(int col) {\n         _comment.setRef(ref.formatAsString());\n         _comments.referenceUpdated(oldRef, _comment);\n         \n-        if(_vmlShape != null) _vmlShape.getClientDataArray(0).setColumnArray(0, new BigInteger(String.valueOf(col)));\n+        if(_vmlShape != null) {\n+           _vmlShape.getClientDataArray(0).setColumnArray(\n+                 new BigInteger[] { new BigInteger(String.valueOf(col)) }\n+           );\n+           \n+           // There is a very odd xmlbeans bug when changing the column\n+           //  arrays which can lead to corrupt pointer\n+           // This call seems to fix them again... See bug #50795\n+           _vmlShape.getClientDataList().toString();\n+        }\n \t}\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/51653729ce39bab500b910cfc4ee07e21fe2beaf/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFComment.java",
                "sha": "f75b250624e58009a7ba3b203f5db322b4da658e",
                "status": "modified"
            },
            {
                "additions": 52,
                "blob_url": "https://github.com/apache/poi/blob/51653729ce39bab500b910cfc4ee07e21fe2beaf/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "changes": 52,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java?ref=51653729ce39bab500b910cfc4ee07e21fe2beaf",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "patch": "@@ -620,4 +620,56 @@ public void test50440() throws Exception {\n        assertEquals(\"SUM(\\n1,2\\n)\", c.getCellFormula());\n        assertEquals(3.0, c.getNumericCellValue());\n     }\n+    \n+    /**\n+     * Moving a cell comment from one cell to another\n+     */\n+    public void test50795() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"50795.xlsx\");\n+       XSSFSheet sheet = wb.getSheetAt(0);\n+       XSSFRow row = sheet.getRow(0);\n+\n+       XSSFCell cellWith = row.getCell(0);\n+       XSSFCell cellWithoutComment = row.getCell(1);\n+       \n+       assertNotNull(cellWith.getCellComment());\n+       assertNull(cellWithoutComment.getCellComment());\n+       \n+       String exp = \"\\u0410\\u0432\\u0442\\u043e\\u0440:\\ncomment\";\n+       XSSFComment comment = cellWith.getCellComment();\n+       assertEquals(exp, comment.getString().getString());\n+       \n+       \n+       // Check we can write it out and read it back as-is\n+       wb = XSSFTestDataSamples.writeOutAndReadBack(wb);\n+       sheet = wb.getSheetAt(0);\n+       row = sheet.getRow(0);\n+       cellWith = row.getCell(0);\n+       cellWithoutComment = row.getCell(1);\n+       \n+       // Double check things are as expected\n+       assertNotNull(cellWith.getCellComment());\n+       assertNull(cellWithoutComment.getCellComment());\n+       comment = cellWith.getCellComment();\n+       assertEquals(exp, comment.getString().getString());\n+\n+       \n+       // Move the comment\n+       cellWithoutComment.setCellComment(comment);\n+       \n+       \n+       // Write out and re-check\n+       wb = XSSFTestDataSamples.writeOutAndReadBack(wb);\n+       sheet = wb.getSheetAt(0);\n+       row = sheet.getRow(0);\n+       \n+       // Ensure it swapped over\n+       cellWith = row.getCell(0);\n+       cellWithoutComment = row.getCell(1);\n+       assertNull(cellWith.getCellComment());\n+       assertNotNull(cellWithoutComment.getCellComment());\n+       \n+       comment = cellWithoutComment.getCellComment();\n+       assertEquals(exp, comment.getString().getString());\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/51653729ce39bab500b910cfc4ee07e21fe2beaf/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "sha": "abc9fc73bc5ca44c5ac299feda458ed3204213a8",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/51653729ce39bab500b910cfc4ee07e21fe2beaf/test-data/spreadsheet/50795.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/50795.xlsx?ref=51653729ce39bab500b910cfc4ee07e21fe2beaf",
                "deletions": 0,
                "filename": "test-data/spreadsheet/50795.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/51653729ce39bab500b910cfc4ee07e21fe2beaf/test-data/spreadsheet/50795.xlsx",
                "sha": "a58aeec7cc564bdf18b9bfe0a4325826955e81b4",
                "status": "added"
            }
        ],
        "message": "Fix bug #50795 - Avoid NPE from xmlbeans when moving XSSF Comments from one cell to another\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1072022 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/b585dd59a6e02a56cd18bf7510531cb7854d6d79",
        "patched_files": [
            "XSSFComment.java",
            "50795.java",
            "status.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFBugs.java",
            "TestXSSFComment.java"
        ]
    },
    "poi_5335dd7": {
        "bug_id": "poi_5335dd7",
        "commit": "https://github.com/apache/poi/commit/5335dd775fcebfba6cee380f95bf5d1c6871e78d",
        "file": [
            {
                "additions": 33,
                "blob_url": "https://github.com/apache/poi/blob/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/java/org/apache/poi/xwpf/model/WMLHelper.java",
                "changes": 33,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/model/WMLHelper.java?ref=5335dd775fcebfba6cee380f95bf5d1c6871e78d",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/model/WMLHelper.java",
                "patch": "@@ -0,0 +1,33 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+package org.apache.poi.xwpf.model;\n+\n+import org.openxmlformats.schemas.wordprocessingml.x2006.main.STOnOff;\n+\n+public final class WMLHelper {\n+    \n+    public static boolean STOnOffToBoolean (STOnOff.Enum value) {\n+        if (value == STOnOff.TRUE || value == STOnOff.ON || value == STOnOff.X_1) {\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    public static STOnOff.Enum BooleanToSTOnOff (boolean value) {\n+        return (value ? STOnOff.TRUE : STOnOff.FALSE);\n+    }\n+}",
                "raw_url": "https://github.com/apache/poi/raw/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/java/org/apache/poi/xwpf/model/WMLHelper.java",
                "sha": "7c30d21b01140f24de1f9cf55e1012c12ae325b5",
                "status": "added"
            },
            {
                "additions": 42,
                "blob_url": "https://github.com/apache/poi/blob/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableRow.java",
                "changes": 64,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableRow.java?ref=5335dd775fcebfba6cee380f95bf5d1c6871e78d",
                "deletions": 22,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableRow.java",
                "patch": "@@ -21,6 +21,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.List;\n \n import org.apache.poi.util.Internal;\n+import org.apache.poi.xwpf.model.WMLHelper;\n import org.apache.xmlbeans.XmlCursor;\n import org.apache.xmlbeans.XmlObject;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHeight;\n@@ -190,57 +191,76 @@ public XWPFTableCell getTableCell(CTTc cell) {\n      *\r\n      * @return true if rows can't be split, false otherwise.\r\n      */\r\n-    public boolean isCantSplitRow() {\r\n-        boolean isCant = false;\r\n-        CTTrPr trpr = getTrPr();\r\n-        if (trpr.sizeOfCantSplitArray() > 0) {\r\n-            CTOnOff onoff = trpr.getCantSplitArray(0);\r\n-            isCant = onoff.getVal().equals(STOnOff.ON);\r\n-        }\r\n-        return isCant;\r\n+    public boolean isCantSplitRow() {\n+        boolean isCant = false;\n+        if (ctRow.isSetTrPr()) {\n+            CTTrPr trpr = getTrPr();\n+            if (trpr.sizeOfCantSplitArray() > 0) {\n+                CTOnOff onoff = trpr.getCantSplitArray(0);\n+                isCant = (onoff.isSetVal() ? WMLHelper.STOnOffToBoolean(onoff.getVal()) : true);\n+            }\n+        }\n+        return isCant;\n     }\r\n \r\n     /**\r\n-     * This attribute controls whether to allow table rows to split across pages.\r\n+     * Controls whether to allow this table row to split across pages.\r\n      * The logic for this attribute is a little unusual: a true value means\r\n      * DON'T allow rows to split, false means allow rows to split.\r\n      *\r\n-     * @param split - if true, don't allow rows to be split. If false, allow\r\n-     *              rows to be split.\r\n+     * @param split - if true, don't allow row to be split. If false, allow\r\n+     *              row to be split.\r\n      */\r\n     public void setCantSplitRow(boolean split) {\r\n         CTTrPr trpr = getTrPr();\r\n-        CTOnOff onoff = trpr.addNewCantSplit();\r\n-        onoff.setVal(split ? STOnOff.ON : STOnOff.OFF);\r\n+        CTOnOff onoff = (trpr.sizeOfCantSplitArray() > 0 ? trpr.getCantSplitArray(0) : trpr.addNewCantSplit());\r\n+        onoff.setVal(WMLHelper.BooleanToSTOnOff(split));\r\n     }\r\n \r\n     /**\r\n      * Return true if a table's header row should be repeated at the top of a\r\n-     * table split across pages.\r\n+     * table split across pages. NOTE - Word will not repeat a table row unless\n+     * all preceding rows of the table are also repeated. This function returns\n+     * false if the row will not be repeated even if the repeat tag is present\n+     * for this row. \r\n      *\r\n      * @return true if table's header row should be repeated at the top of each\r\n      * page of table, false otherwise.\r\n      */\r\n     public boolean isRepeatHeader() {\r\n-        boolean repeat = false;\r\n-        CTTrPr trpr = getTrPr();\r\n-        if (trpr.sizeOfTblHeaderArray() > 0) {\r\n-            CTOnOff rpt = trpr.getTblHeaderArray(0);\r\n-            repeat = rpt.getVal().equals(STOnOff.ON);\r\n+        boolean repeat = false;\n+        for (XWPFTableRow row : table.getRows()) {\n+            repeat = row.getRepeat();\n+            if (row == this || !repeat) {\n+                break;\n+            }\n         }\r\n         return repeat;\r\n+    }\n+    \n+    private boolean getRepeat() {\n+        boolean repeat = false;\n+        if (ctRow.isSetTrPr()) {\n+            CTTrPr trpr = getTrPr();\n+            if (trpr.sizeOfTblHeaderArray() > 0) {\n+                CTOnOff rpt = trpr.getTblHeaderArray(0);\n+                repeat = (rpt.isSetVal() ? WMLHelper.STOnOffToBoolean(rpt.getVal()) : true);\n+            }\n+        }\n+        return repeat;\n     }\r\n \r\n     /**\r\n      * This attribute controls whether to repeat a table's header row at the top\r\n-     * of a table split across pages.\r\n+     * of a table split across pages. NOTE - for a row to be repeated, all preceding\n+     * rows in the table must also be repeated.\r\n      *\r\n      * @param repeat - if TRUE, repeat header row at the top of each page of table;\r\n      *               if FALSE, don't repeat header row.\r\n      */\r\n     public void setRepeatHeader(boolean repeat) {\r\n         CTTrPr trpr = getTrPr();\r\n-        CTOnOff onoff = trpr.addNewTblHeader();\r\n-        onoff.setVal(repeat ? STOnOff.ON : STOnOff.OFF);\r\n+        CTOnOff onoff = (trpr.sizeOfTblHeaderArray() > 0 ? trpr.getTblHeaderArray(0) : trpr.addNewTblHeader());\r\n+        onoff.setVal(WMLHelper.BooleanToSTOnOff(repeat));\r\n     }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableRow.java",
                "sha": "3f530df7659b12faca9b4a3dd84361704113bbeb",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/poi/blob/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java?ref=5335dd775fcebfba6cee380f95bf5d1c6871e78d",
                "deletions": 3,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java",
                "patch": "@@ -17,21 +17,26 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xwpf.usermodel;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n \n-import junit.framework.TestCase;\n import org.apache.poi.xwpf.XWPFTestDataSamples;\n+import org.junit.Ignore;\n+import org.junit.Test;\n \n-public final class TestXWPFSDT extends TestCase {\n+public final class TestXWPFSDT {\n \n     /**\n      * Test simple tag and title extraction from SDT\n      *\n      * @throws Exception\n      */\n+    @Test\n     public void testTagTitle() throws Exception {\n         XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Bug54849.docx\");\n         String tag = null;\n@@ -51,7 +56,7 @@ public void testTagTitle() throws Exception {\n         assertEquals(\"title\", \"MyTitle\", title);\n     }\n \n-\n+    @Test\n     public void testGetSDTs() throws Exception {\n         String[] contents = new String[]{\n                 \"header_rich_text\",\n@@ -83,6 +88,7 @@ public void testGetSDTs() throws Exception {\n     /**\n      * POI-54771 and TIKA-1317\n      */\n+    @Test\n     public void testSDTAsCell() throws Exception {\n         //Bug54771a.docx and Bug54771b.docx test slightly \n         //different recursion patterns. Keep both!\n@@ -110,6 +116,7 @@ public void testSDTAsCell() throws Exception {\n     /**\n      * POI-55142 and Tika 1130\n      */\n+    @Test\n     public void testNewLinesBetweenRuns() throws Exception {\n         XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Bug55142.docx\");\n         List<AbstractXWPFSDT> sdts = extractAllSDTs(doc);\n@@ -132,6 +139,7 @@ public void testNewLinesBetweenRuns() throws Exception {\n         }\n     }\n \n+    @Ignore\n     public void test60341() throws IOException {\n         //handle sdtbody without an sdtpr\n         XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Bug60341.docx\");",
                "raw_url": "https://github.com/apache/poi/raw/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java",
                "sha": "c9d12bddce493ac12b6a1339ad57467915dd6ca4",
                "status": "modified"
            },
            {
                "additions": 97,
                "blob_url": "https://github.com/apache/poi/blob/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableRow.java",
                "changes": 121,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableRow.java?ref=5335dd775fcebfba6cee380f95bf5d1c6871e78d",
                "deletions": 24,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableRow.java",
                "patch": "@@ -17,51 +17,124 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xwpf.usermodel;\n \n-import junit.framework.TestCase;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n \n-public class TestXWPFTableRow extends TestCase {\n-    @Override\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-    }\n+import java.io.IOException;\n \n-    public void testCreateRow() throws Exception {\n-        CTRow ctRow = CTRow.Factory.newInstance();\n-        assertNotNull(ctRow);\n-    }\n+import org.apache.poi.xwpf.XWPFTestDataSamples;\n+import org.junit.Test;\n \n-    @Override\n-    protected void tearDown() throws Exception {\n-        super.tearDown();\n+public class TestXWPFTableRow {\n+\n+    @Test\n+    public void testCreateRow() throws IOException {\n+        XWPFDocument doc = new XWPFDocument();\n+        XWPFTable table = doc.createTable(1, 1);\n+        XWPFTableRow tr = table.createRow();\n+        assertNotNull(tr);\n+        doc.close();\n     }\n \n-    public void testSetGetCantSplitRow() {\n+    @Test\n+    public void testSetGetCantSplitRow() throws IOException {\n         // create a table\n         XWPFDocument doc = new XWPFDocument();\n-        CTTbl ctTable = CTTbl.Factory.newInstance();\n-        XWPFTable table = new XWPFTable(ctTable, doc);\n+        XWPFTable table = doc.createTable(1, 1);\n         // table has a single row by default; grab it\n         XWPFTableRow tr = table.getRow(0);\n         assertNotNull(tr);\n \n+        // Assert the repeat header is false by default\n+        boolean isCantSplit = tr.isCantSplitRow();\n+        assertFalse(isCantSplit);\n+        \n+        // Repeat the header\n         tr.setCantSplitRow(true);\n-        boolean isCant = tr.isCantSplitRow();\n-        assert (isCant);\n+        isCantSplit = tr.isCantSplitRow();\n+        assertTrue(isCantSplit);\n+\n+        // Make the header no longer repeating\n+        tr.setCantSplitRow(false);\n+        isCantSplit = tr.isCantSplitRow();\n+        assertFalse(isCantSplit);\n+        \n+        doc.close();\n     }\n \n-    public void testSetGetRepeatHeader() {\n+    @Test\n+    public void testSetGetRepeatHeader() throws IOException {\n         // create a table\n         XWPFDocument doc = new XWPFDocument();\n-        CTTbl ctTable = CTTbl.Factory.newInstance();\n-        XWPFTable table = new XWPFTable(ctTable, doc);\n+        XWPFTable table = doc.createTable(3, 1);\n         // table has a single row by default; grab it\n         XWPFTableRow tr = table.getRow(0);\n         assertNotNull(tr);\n+        \n+        // Assert the repeat header is false by default\n+        boolean isRpt = tr.isRepeatHeader();\n+        assertFalse(isRpt);\n+        \n+        // Repeat the header\n+        tr.setRepeatHeader(true);\n+        isRpt = tr.isRepeatHeader();\n+        assertTrue(isRpt);\n \n+        // Make the header no longer repeating\n+        tr.setRepeatHeader(false);\n+        isRpt = tr.isRepeatHeader();\n+        assertFalse(isRpt);\n+        \n+        // If the third row is set to repeat, but not the second,\n+        // isRepeatHeader should report false because Word will\n+        // ignore it.\n+        tr = table.getRow(2);\n         tr.setRepeatHeader(true);\n+        isRpt = tr.isRepeatHeader();\n+        assertFalse(isRpt);\n+        \n+        doc.close();\n+    }\n+    \n+    // Test that validates the table header value can be parsed from a document\n+    // generated in Word\n+    @Test\n+    public void testIsRepeatHeader() throws Exception {\n+        XWPFDocument doc = XWPFTestDataSamples\n+                .openSampleDocument(\"Bug60337.docx\");\n+        XWPFTable table = doc.getTables().get(0);\n+        XWPFTableRow tr = table.getRow(0);\n         boolean isRpt = tr.isRepeatHeader();\n-        assert (isRpt);\n+        assertTrue(isRpt);\n+        \n+        tr = table.getRow(1);\n+        isRpt = tr.isRepeatHeader();\n+        assertFalse(isRpt);\n+        \n+        tr = table.getRow(2);\n+        isRpt = tr.isRepeatHeader();\n+        assertFalse(isRpt);\n+    }\n+    \n+    \n+    // Test that validates the table header value can be parsed from a document\n+    // generated in Word\n+    @Test\n+    public void testIsCantSplit() throws Exception {\n+        XWPFDocument doc = XWPFTestDataSamples\n+                .openSampleDocument(\"Bug60337.docx\");\n+        XWPFTable table = doc.getTables().get(0);\n+        XWPFTableRow tr = table.getRow(0);\n+        boolean isCantSplit = tr.isCantSplitRow();\n+        assertFalse(isCantSplit);\n+        \n+        tr = table.getRow(1);\n+        isCantSplit = tr.isCantSplitRow();\n+        assertFalse(isCantSplit);\n+\n+        tr = table.getRow(2);\n+        isCantSplit = tr.isCantSplitRow();\n+        assertTrue(isCantSplit);\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/5335dd775fcebfba6cee380f95bf5d1c6871e78d/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableRow.java",
                "sha": "57ed435320368c27a9719d56c7f923876f9cf9df",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/5335dd775fcebfba6cee380f95bf5d1c6871e78d/test-data/document/Bug60337.docx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/Bug60337.docx?ref=5335dd775fcebfba6cee380f95bf5d1c6871e78d",
                "deletions": 0,
                "filename": "test-data/document/Bug60337.docx",
                "raw_url": "https://github.com/apache/poi/raw/5335dd775fcebfba6cee380f95bf5d1c6871e78d/test-data/document/Bug60337.docx",
                "sha": "06d0339fc5f854d90fe6721d991c512c815da4c5",
                "status": "added"
            }
        ],
        "message": "60337: XWPFTableRow.isRepeatHeader throws NullPointerException, setRepeatHeader does not overwrite old value \n\nTask-Url: https://bz.apache.org/bugzilla/show_bug.cgi?id=60337\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1768153 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e23110968c9b94048eec7abcabdd0efee9c7cf4e",
        "patched_files": [
            "XWPFSDT.java",
            "WMLHelper.java",
            "XWPFTableRow.java",
            "Bug60337.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFSDT.java",
            "TestXWPFTableRow.java"
        ]
    },
    "poi_6405134": {
        "bug_id": "poi_6405134",
        "commit": "https://github.com/apache/poi/commit/64051349494e0722abd477866483fbae29723fe2",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/64051349494e0722abd477866483fbae29723fe2/src/java/org/apache/poi/poifs/macros/VBAMacroReader.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/poifs/macros/VBAMacroReader.java?ref=64051349494e0722abd477866483fbae29723fe2",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/poifs/macros/VBAMacroReader.java",
                "patch": "@@ -218,7 +218,7 @@ private static void readModule(DocumentInputStream dis, String name, ModuleMap m\n             module = new Module();\n             modules.put(name, module);\n             module.read(dis);\n-        } else {\n+        } else if (module.buf == null) { //if we haven't already read the bytes for the module keyed off this name...\n             if (module.offset == null) {\n                 //This should not happen. bug 59858\n                 throw new IOException(\"Module offset for '\" + name + \"' was never read.\");",
                "raw_url": "https://github.com/apache/poi/raw/64051349494e0722abd477866483fbae29723fe2/src/java/org/apache/poi/poifs/macros/VBAMacroReader.java",
                "sha": "21b535b104ba681783315397ef1214736899e247",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/64051349494e0722abd477866483fbae29723fe2/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java?ref=64051349494e0722abd477866483fbae29723fe2",
                "deletions": 16,
                "filename": "src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "patch": "@@ -254,24 +254,14 @@ public void bug59830() throws IOException {\n         assertNotNull(macros.get(\"Module20\"));\n         assertContains(macros.get(\"Module20\"), \"here start of superscripting\");\n     }\n-    \n-    // This test is written as expected-to-fail and should be rewritten\n-    // as expected-to-pass when the bug is fixed.\n+\n     @Test\n     public void bug59858() throws IOException {\n-        try {\n-            fromFile(POIDataSamples.getSpreadSheetInstance(), \"59858.xls\");\n-            testPassesNow(59858);\n-        } catch (IOException e) {\n-            if (e.getMessage().matches(\"Module offset for '.+' was never read.\")) {\n-                //e.printStackTrace();\n-                // NPE when reading module.offset in VBAMacroReader.readMacros (approx line 258)\n-                skipTest(e);\n-            } else {\n-                // something unexpected failed\n-                throw e;\n-            }\n-        }\n+        File f = POIDataSamples.getSpreadSheetInstance().getFile(\"59830.xls\");\n+        VBAMacroReader r = new VBAMacroReader(f);\n+        Map<String, String> macros = r.readMacros();\n+        assertNotNull(macros.get(\"Module20\"));\n+        assertContains(macros.get(\"Module20\"), \"start of superscripting\");\n     }\n \n     @Test",
                "raw_url": "https://github.com/apache/poi/raw/64051349494e0722abd477866483fbae29723fe2/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "sha": "3a4c47361ddc36f581c010e47dad139e58957032",
                "status": "modified"
            }
        ],
        "message": "BUG 59858 -- avoid npe when there's a collision of record names\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1765479 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1ec787c3562dcb91f1ddd8581efe393ceea75a51",
        "patched_files": [
            "VBAMacroReader.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestVBAMacroReader.java"
        ]
    },
    "poi_65d9d90": {
        "bug_id": "poi_65d9d90",
        "commit": "https://github.com/apache/poi/commit/65d9d900b92ea59e6a8fd5cbe93d19004df7d05a",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/65d9d900b92ea59e6a8fd5cbe93d19004df7d05a/src/java/org/apache/poi/hssf/record/HyperlinkRecord.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/HyperlinkRecord.java?ref=65d9d900b92ea59e6a8fd5cbe93d19004df7d05a",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/HyperlinkRecord.java",
                "patch": "@@ -628,7 +628,7 @@ public String toString() {\n         if ((_linkOpts & HLINK_TARGET_FRAME) != 0) {\n             buffer.append(\"    .targetFrame= \").append(getTargetFrame()).append(\"\\n\");\n         }\n-        if((_linkOpts & HLINK_URL) != 0) {\n+        if((_linkOpts & HLINK_URL) != 0 && _moniker != null) {\n             buffer.append(\"    .moniker   = \").append(_moniker.formatAsString()).append(\"\\n\");\n         }\n         if ((_linkOpts & HLINK_PLACE) != 0) {",
                "raw_url": "https://github.com/apache/poi/raw/65d9d900b92ea59e6a8fd5cbe93d19004df7d05a/src/java/org/apache/poi/hssf/record/HyperlinkRecord.java",
                "sha": "46c84b5e22f7e21fc60e4bd367feca7b2435a151",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/65d9d900b92ea59e6a8fd5cbe93d19004df7d05a/src/testcases/org/apache/poi/hssf/record/TestHyperlinkRecord.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestHyperlinkRecord.java?ref=65d9d900b92ea59e6a8fd5cbe93d19004df7d05a",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestHyperlinkRecord.java",
                "patch": "@@ -435,6 +435,11 @@ public void testReserializeUNC() {\n \t\tHyperlinkRecord hr = new HyperlinkRecord(in);\n \t\tbyte[] ser = hr.serialize();\n \t\tTestcaseRecordInputStream.confirmRecordEncoding(HyperlinkRecord.sid, dataUNC, ser);\n+\t\ttry {\n+\t\t\thr.toString();\n+\t\t} catch (NullPointerException e) {\n+\t\t\tthrow new AssertionFailedError(\"Identified bug with option URL and UNC set at same time\");\n+\t\t}\n \t}\n \t\n \tpublic void testGUID() {",
                "raw_url": "https://github.com/apache/poi/raw/65d9d900b92ea59e6a8fd5cbe93d19004df7d05a/src/testcases/org/apache/poi/hssf/record/TestHyperlinkRecord.java",
                "sha": "7bb05f4f1225f654ab6ca53274d68dec8b366b07",
                "status": "modified"
            }
        ],
        "message": "fixed NPE in HyperlinkRecord.toString()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@720997 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/7c56a088161cb0a629788bd94680b4e31063944e",
        "patched_files": [
            "HyperlinkRecord.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHyperlinkRecord.java"
        ]
    },
    "poi_6b6f924": {
        "bug_id": "poi_6b6f924",
        "commit": "https://github.com/apache/poi/commit/6b6f924c299bae2ee80c1aee644a9c174a75c39b",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/documentation/content/xdocs/changes.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=6b6f924c299bae2ee80c1aee644a9c174a75c39b",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -37,6 +37,7 @@\n \n \t\t<!-- Don't forget to update status.xml too! -->\n         <release version=\"3.1.1-alpha1\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">45322 - Fixed NPE in HSSFSheet.autoSizeColumn() when cell number format was not found</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45380 - Missing return keyword in ArrayPtg.toFormulaString()</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">44958 - Record level support for Data Tables. (No formula parser support though)</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">35583 - Include a version class, org.apache.poi.Version, to allow easy introspection of the POI version</action>",
                "raw_url": "https://github.com/apache/poi/raw/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/documentation/content/xdocs/changes.xml",
                "sha": "12f62cb8b9a504bcb4708f00883443d0e4a90c15",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=6b6f924c299bae2ee80c1aee644a9c174a75c39b",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \t<!-- Don't forget to update changes.xml too! -->\n     <changes>\n         <release version=\"3.1.1-alpha1\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">45322 - Fixed NPE in HSSFSheet.autoSizeColumn() when cell number format was not found</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45380 - Missing return keyword in ArrayPtg.toFormulaString()</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">44958 - Record level support for Data Tables. (No formula parser support though)</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">35583 - Include a version class, org.apache.poi.Version, to allow easy introspection of the POI version</action>",
                "raw_url": "https://github.com/apache/poi/raw/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/documentation/content/xdocs/status.xml",
                "sha": "a62ee3ddebc3496da69febdaf76a395e0818c0c9",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java?ref=6b6f924c299bae2ee80c1aee644a9c174a75c39b",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java",
                "patch": "@@ -278,21 +278,23 @@ public short getDataFormat()\n      * Get the contents of the format string, by looking up\n      *  the DataFormat against the bound workbook\n      * @see org.apache.poi.hssf.usermodel.HSSFDataFormat\n+     * @return the format string or \"General\" if not found\n      */\n     public String getDataFormatString() {\n-    \tHSSFDataFormat format = new HSSFDataFormat(workbook);\n-    \t\n-        return format.getFormat(getDataFormat());\n+        return getDataFormatString(workbook);\n     }\n     /**\n      * Get the contents of the format string, by looking up\n      *  the DataFormat against the supplied workbook\n      * @see org.apache.poi.hssf.usermodel.HSSFDataFormat\n+     *\n+     * @return the format string or \"General\" if not found\n      */\n     public String getDataFormatString(Workbook workbook) {\n     \tHSSFDataFormat format = new HSSFDataFormat(workbook);\n     \t\n-        return format.getFormat(getDataFormat());\n+        int idx = getDataFormat();\n+        return idx == -1 ? \"General\" : format.getFormat(getDataFormat());\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/java/org/apache/poi/hssf/usermodel/HSSFCellStyle.java",
                "sha": "6d8ae33b689416b30afb8005985156db00bd6e97",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=6b6f924c299bae2ee80c1aee644a9c174a75c39b",
                "deletions": 3,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -1851,9 +1851,7 @@ public void autoSizeColumn(short column, boolean useMergedCells) {\n             } else {\n                 String sval = null;\n                 if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC) {\n-                    HSSFDataFormat dataformat = wb.createDataFormat();\n-                    short idx = style.getDataFormat();\n-                    String format = dataformat.getFormat(idx).replaceAll(\"\\\"\", \"\");\n+                    String format = style.getDataFormatString().replaceAll(\"\\\"\", \"\");\n                     double value = cell.getNumericCellValue();\n                     try {\n                         NumberFormat fmt;",
                "raw_url": "https://github.com/apache/poi/raw/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "e2973df232f2f77e9ad9fe30dbde1db2d22c1d3f",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/testcases/org/apache/poi/hssf/data/45322.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/45322.xls?ref=6b6f924c299bae2ee80c1aee644a9c174a75c39b",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/45322.xls",
                "raw_url": "https://github.com/apache/poi/raw/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/testcases/org/apache/poi/hssf/data/45322.xls",
                "sha": "711721400e984db67c87bbf23d0b7e579f0218fc",
                "status": "added"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=6b6f924c299bae2ee80c1aee644a9c174a75c39b",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -1353,4 +1353,13 @@ public void test44958() throws Exception {\n         // TODO - check the formula once tables and\n         //  arrays are properly supported\n     }\n+\n+    /**\n+     * 45322: HSSFSheet.autoSizeColumn fails when style.getDataFormat() returns -1\n+     */\n+    public void test45322() throws Exception {\n+        HSSFWorkbook wb = openSample(\"44958.xls\");\n+        HSSFSheet sh = wb.getSheetAt(0);\n+        for(short i=0; i < 30; i++) sh.autoSizeColumn(i);\n+     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/6b6f924c299bae2ee80c1aee644a9c174a75c39b/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "6e92f6e3deff0ca90f54a80c0d1c07befb2564c5",
                "status": "modified"
            }
        ],
        "message": "fixed bug #45322: HSSFSheet.autoSizeColumn() throws NPE when cell number format was not found\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@676995 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/197b6cab7f2d1c44350ac730b5210e7ee48bb111",
        "patched_files": [
            "HSSFCellStyle.java",
            "status.java",
            "changes.java",
            "HSSFSheet.java",
            "45322.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java",
            "TestHSSFSheet.java"
        ]
    },
    "poi_70e9580": {
        "bug_id": "poi_70e9580",
        "commit": "https://github.com/apache/poi/commit/70e958022610fd290c05f5c1ba4d1e20d4b90a7f",
        "file": [
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/poi/blob/70e958022610fd290c05f5c1ba4d1e20d4b90a7f/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFChartSheet.java",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFChartSheet.java?ref=70e958022610fd290c05f5c1ba4d1e20d4b90a7f",
                "deletions": 8,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFChartSheet.java",
                "patch": "@@ -17,32 +17,44 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xssf.usermodel;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.io.*;\n+import java.util.Map;\n+import java.util.HashMap;\n+\n \n import org.apache.poi.POIXMLException;\n import org.apache.poi.openxml4j.opc.PackagePart;\n import org.apache.poi.openxml4j.opc.PackageRelationship;\n import org.apache.xmlbeans.XmlException;\n+import org.apache.xmlbeans.XmlOptions;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTChartsheet;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.ChartsheetDocument;\n+import org.openxmlformats.schemas.officeDocument.x2006.relationships.STRelationshipId;\n+\n+import javax.xml.namespace.QName;\n \n /**\n- * High level representation of of Sheet Parts that are of type 'chartsheet'.\n- *\n- * TODO: current verion extends XSSFSheet although both should extend AbstractSheet\n+ * High level representation of Sheet Parts that are of type 'chartsheet'.\n+ * <p>\n+ *  Chart sheet is a special kind of Sheet that contains only chart and no data.\n+ * </p>\n  *\n  * @author Yegor Kozlov\n  */\n public class XSSFChartSheet extends XSSFSheet  {\n \n+    private static final byte[] BLANK_WORKSHEET = blankWorksheet();\n+\n     protected CTChartsheet chartsheet;\n \n     protected XSSFChartSheet(PackagePart part, PackageRelationship rel) {\n         super(part, rel);\n     }\n \n     protected void read(InputStream is) throws IOException {\n+        //initialize the supeclass with a blank worksheet\n+        super.read(new ByteArrayInputStream(BLANK_WORKSHEET));\n+\n         try {\n             chartsheet = ChartsheetDocument.Factory.parse(is).getChartsheet();\n         } catch (XmlException e){\n@@ -51,17 +63,35 @@ protected void read(InputStream is) throws IOException {\n     }\n \n     /**\n-     * Provide access to the CTWorksheet bean holding this sheet's data\n+     * Provide access to the CTChartsheet bean holding this sheet's data\n      *\n-     * @return the CTWorksheet bean holding this sheet's data\n+     * @return the CTChartsheet bean holding this sheet's data\n      */\n     public CTChartsheet getCTChartsheet() {\n         return chartsheet;\n     }\n \n     @Override\n-    protected void commit() throws IOException {\n+    protected void write(OutputStream out) throws IOException {\n+        XmlOptions xmlOptions = new XmlOptions(DEFAULT_XML_OPTIONS);\n+        xmlOptions.setSaveSyntheticDocumentElement(\n+                new QName(CTChartsheet.type.getName().getNamespaceURI(), \"chartsheet\"));\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(STRelationshipId.type.getName().getNamespaceURI(), \"r\");\n+        xmlOptions.setSaveSuggestedPrefixes(map);\n \n+        chartsheet.save(out, xmlOptions);\n+\n+    }\n+\n+    private static byte[] blankWorksheet(){\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try {\n+            new XSSFSheet().write(out);\n+        } catch (IOException e){\n+            throw new RuntimeException(e);\n+        }\n+        return out.toByteArray();\n     }\n \n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/70e958022610fd290c05f5c1ba4d1e20d4b90a7f/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFChartSheet.java",
                "sha": "f9aeb40c924cc94d902363e707f9e94f38d5a1ef",
                "status": "modified"
            },
            {
                "additions": 84,
                "blob_url": "https://github.com/apache/poi/blob/70e958022610fd290c05f5c1ba4d1e20d4b90a7f/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFChartSheet.java",
                "changes": 84,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFChartSheet.java?ref=70e958022610fd290c05f5c1ba4d1e20d4b90a7f",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFChartSheet.java",
                "patch": "@@ -0,0 +1,84 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.xssf.usermodel;\n+\n+import org.apache.poi.ss.usermodel.BaseTestSheet;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.Workbook;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.util.CellRangeAddress;\n+import org.apache.poi.xssf.XSSFITestDataProvider;\n+import org.apache.poi.xssf.XSSFTestDataSamples;\n+import org.apache.poi.xssf.model.CommentsTable;\n+import org.apache.poi.xssf.model.StylesTable;\n+import org.apache.poi.xssf.usermodel.helpers.ColumnHelper;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTCol;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTCols;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTComments;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTRow;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorksheet;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTXf;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.STPane;\n+\n+\n+public class TestXSSFChartSheet extends BaseTestSheet {\n+\n+    @Override\n+    protected XSSFITestDataProvider getTestDataProvider() {\n+        return XSSFITestDataProvider.getInstance();\n+    }\n+\n+    public void testXSSFFactory() {\n+        XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"chart_sheet.xlsx\");\n+        assertEquals(4, wb.getNumberOfSheets());\n+\n+        //the third sheet is of type 'chartsheet'\n+        assertEquals(\"Chart1\", wb.getSheetName(2));\n+        assertTrue(wb.getSheetAt(2) instanceof XSSFChartSheet);\n+        assertEquals(\"Chart1\", wb.getSheetAt(2).getSheetName());\n+\n+    }\n+\n+    public void testGetAccessors() {\n+        XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"chart_sheet.xlsx\");\n+        XSSFChartSheet sheet = (XSSFChartSheet)wb.getSheetAt(2);\n+        for(Row row : sheet) {\n+            fail(\"Row iterator for chart sheets should return zero rows\");\n+        }\n+        //access to a arbitrary row\n+        assertEquals(null, sheet.getRow(1));\n+\n+        //some basic get* accessors\n+        assertEquals(0, sheet.getNumberOfComments());\n+        assertEquals(0, sheet.getNumHyperlinks());\n+        assertEquals(0, sheet.getNumMergedRegions());\n+        assertEquals(null, sheet.getActiveCell());\n+        assertEquals(true, sheet.getAutobreaks());\n+        assertEquals(null, sheet.getCellComment(0, 0));\n+        assertEquals(0, sheet.getColumnBreaks().length);\n+        assertEquals(true, sheet.getRowSumsBelow());\n+    }\n+\n+    /**\n+     * YK: disable failing test from the superclass \n+     */\n+    @Override\n+    public void testDefaultColumnStyle() {\n+\n+    }\n+}\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/70e958022610fd290c05f5c1ba4d1e20d4b90a7f/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFChartSheet.java",
                "sha": "5ecb187547c98ae2ba910c4aee8ae12aa0f4255e",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/70e958022610fd290c05f5c1ba4d1e20d4b90a7f/test-data/spreadsheet/chart_sheet.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/chart_sheet.xlsx?ref=70e958022610fd290c05f5c1ba4d1e20d4b90a7f",
                "deletions": 0,
                "filename": "test-data/spreadsheet/chart_sheet.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/70e958022610fd290c05f5c1ba4d1e20d4b90a7f/test-data/spreadsheet/chart_sheet.xlsx",
                "sha": "44d771b06af6747af40b72f3ec9098150cb17b6a",
                "status": "added"
            }
        ],
        "message": "avoid NPE when calling methods from the superclass and initialize XSSFChartSheet with a blank sheet, see Bugzilla 48087\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@832622 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/08da3a6bfa1a83131c7aee3300fb39929ba18b4b",
        "patched_files": [
            "XSSFChartSheet.java",
            "chart_sheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFChartSheet.java"
        ]
    },
    "poi_73217ce": {
        "bug_id": "poi_73217ce",
        "commit": "https://github.com/apache/poi/commit/73217cecaec4b61a0d41892076fbca58e9f34ad6",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/73217cecaec4b61a0d41892076fbca58e9f34ad6/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTableCell.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTableCell.java?ref=73217cecaec4b61a0d41892076fbca58e9f34ad6",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTableCell.java",
                "patch": "@@ -756,4 +756,4 @@ private CTTableStyleTextStyle getTextStyle() {\n             return (tps == null) ? null : tps.getTcTxStyle();\r\n         }\r\n     }\r\n-}\n\\ No newline at end of file\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/73217cecaec4b61a0d41892076fbca58e9f34ad6/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTableCell.java",
                "sha": "7b13e5842a252ce629ed99cfffcc58f7480c5b9b",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/73217cecaec4b61a0d41892076fbca58e9f34ad6/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTable.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTable.java?ref=73217cecaec4b61a0d41892076fbca58e9f34ad6",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTable.java",
                "patch": "@@ -24,10 +24,16 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import static org.junit.Assert.assertTrue;\r\n \r\n import java.awt.Color;\r\n+import java.awt.Dimension;\r\n+import java.awt.Graphics2D;\r\n+import java.awt.RenderingHints;\r\n import java.awt.geom.Rectangle2D;\r\n+import java.awt.image.BufferedImage;\r\n import java.io.IOException;\r\n import java.util.List;\r\n \r\n+import org.apache.poi.sl.draw.DrawFactory;\r\n+import org.apache.poi.sl.usermodel.Slide;\r\n import org.apache.poi.sl.usermodel.TableCell.BorderEdge;\r\n import org.apache.poi.sl.usermodel.VerticalAlignment;\r\n import org.apache.poi.xslf.XSLFTestDataSamples;\r\n@@ -193,4 +199,20 @@ public void checkTextHeight() throws IOException {\n         \r\n         ppt.close();\r\n     }\r\n+\r\n+    @Test\r\n+    public void checkNullPointerException() {\r\n+        XMLSlideShow ss = XSLFTestDataSamples.openSampleDocument(\"au.asn.aes.www_conferences_2011_presentations_Fri_20Room4Level4_20930_20Maloney.pptx\");\r\n+        Dimension pgsize = ss.getPageSize();\r\n+        for (Slide<?, ?> s : ss.getSlides()) {\r\n+            BufferedImage img = new BufferedImage(pgsize.width, pgsize.height, BufferedImage.TYPE_INT_ARGB);\r\n+            Graphics2D graphics = img.createGraphics();\r\n+\r\n+            // draw stuff\r\n+            s.draw(graphics);\r\n+\r\n+            graphics.dispose();\r\n+            img.flush();\r\n+        }\r\n+    }\r\n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/73217cecaec4b61a0d41892076fbca58e9f34ad6/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTable.java",
                "sha": "1d77a019df17cd54eeef5557018baa7f0adfdcba",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/73217cecaec4b61a0d41892076fbca58e9f34ad6/test-data/slideshow/au.asn.aes.www_conferences_2011_presentations_Fri_20Room4Level4_20930_20Maloney.pptx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/slideshow/au.asn.aes.www_conferences_2011_presentations_Fri_20Room4Level4_20930_20Maloney.pptx?ref=73217cecaec4b61a0d41892076fbca58e9f34ad6",
                "deletions": 0,
                "filename": "test-data/slideshow/au.asn.aes.www_conferences_2011_presentations_Fri_20Room4Level4_20930_20Maloney.pptx",
                "raw_url": "https://github.com/apache/poi/raw/73217cecaec4b61a0d41892076fbca58e9f34ad6/test-data/slideshow/au.asn.aes.www_conferences_2011_presentations_Fri_20Room4Level4_20930_20Maloney.pptx",
                "sha": "e287ffe0e4a00e817338e7062523e9facc2bb72d",
                "status": "added"
            }
        ],
        "message": "Add a test to check for a NullPointerException in XSLFTableCell\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1752862 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/45fc872dded21830ee3852b5d5e18d85d2cbfbaf",
        "patched_files": [
            "au.java",
            "XSLFTableCell.java",
            "XSLFTable.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSLFTable.java"
        ]
    },
    "poi_735760f": {
        "bug_id": "poi_735760f",
        "commit": "https://github.com/apache/poi/commit/735760f21e91a0e40efe7bff30477099b7d31de0",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/735760f21e91a0e40efe7bff30477099b7d31de0/src/scratchpad/src/org/apache/poi/hsmf/extractor/OutlookTextExtactor.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hsmf/extractor/OutlookTextExtactor.java?ref=735760f21e91a0e40efe7bff30477099b7d31de0",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hsmf/extractor/OutlookTextExtactor.java",
                "patch": "@@ -25,6 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.POIOLE2TextExtractor;\n import org.apache.poi.hsmf.MAPIMessage;\n import org.apache.poi.hsmf.datatypes.AttachmentChunks;\n+import org.apache.poi.hsmf.datatypes.StringChunk;\n import org.apache.poi.hsmf.exceptions.ChunkNotFoundException;\n import org.apache.poi.poifs.filesystem.DirectoryNode;\n import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;\n@@ -65,6 +66,7 @@ public static void main(String[] args) throws Exception {\n                new NPOIFSFileSystem(new File(filename))\n          );\n          System.out.println( extractor.getText() );\n+         extractor.close();\n       }\n    }\n \n@@ -146,12 +148,15 @@ public String getText() {\n       // Display attachment names\n       // To get the attachments, use ExtractorFactory\n       for(AttachmentChunks att : msg.getAttachmentFiles()) {\n-         String ats = att.attachLongFileName.getValue();\n+         StringChunk name = att.attachLongFileName;\n+         if (name == null) name = att.attachFileName;\n+         String attName = name.getValue();\n+          \n          if(att.attachMimeTag != null && \n                att.attachMimeTag.getValue() != null) {\n-            ats = att.attachMimeTag.getValue() + \" = \" + ats; \n+             attName = att.attachMimeTag.getValue() + \" = \" + attName; \n          }\n-         s.append(\"Attachment: \" + ats + \"\\n\");\n+         s.append(\"Attachment: \" + attName + \"\\n\");\n       }\n       \n       try {",
                "raw_url": "https://github.com/apache/poi/raw/735760f21e91a0e40efe7bff30477099b7d31de0/src/scratchpad/src/org/apache/poi/hsmf/extractor/OutlookTextExtactor.java",
                "sha": "4cdaf16f82d661a859b9f1fd6ed983758f1099fd",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/735760f21e91a0e40efe7bff30477099b7d31de0/src/scratchpad/testcases/org/apache/poi/hsmf/extractor/TestOutlookTextExtractor.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hsmf/extractor/TestOutlookTextExtractor.java?ref=735760f21e91a0e40efe7bff30477099b7d31de0",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hsmf/extractor/TestOutlookTextExtractor.java",
                "patch": "@@ -209,6 +209,25 @@ public void testWithAttachments() throws Exception {\n       ext.close();\n    }\n    \n+   public void testWithAttachedMessage() throws Exception {\n+       POIFSFileSystem simple = new POIFSFileSystem(\n+               new FileInputStream(samples.getFile(\"58214_with_attachment.msg\"))\n+         );\n+         MAPIMessage msg = new MAPIMessage(simple);\n+         OutlookTextExtactor ext = new OutlookTextExtactor(msg);\n+         String text = ext.getText();\n+         \n+         // Check we got bits from the main message\n+         assertContains(text, \"Master mail\");\n+         assertContains(text, \"ante in lacinia euismod\");\n+         \n+         // But not the attached message\n+         assertNotContained(text, \"Test mail attachment\");\n+         assertNotContained(text, \"Lorem ipsum dolor sit\");\n+         \n+         ext.close();\n+   }\n+   \n    public void testEncodings() throws Exception {\n       POIFSFileSystem simple = new POIFSFileSystem(\n             new FileInputStream(samples.getFile(\"chinese-traditional.msg\"))",
                "raw_url": "https://github.com/apache/poi/raw/735760f21e91a0e40efe7bff30477099b7d31de0/src/scratchpad/testcases/org/apache/poi/hsmf/extractor/TestOutlookTextExtractor.java",
                "sha": "5550adbb619c2778d4b66cf21837d76b7c9218f8",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/735760f21e91a0e40efe7bff30477099b7d31de0/src/testcases/org/apache/poi/POITestCase.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/POITestCase.java?ref=735760f21e91a0e40efe7bff30477099b7d31de0",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/POITestCase.java",
                "patch": "@@ -33,6 +33,12 @@ public static void assertContains(String haystack, String needle) {\n               haystack.contains(needle)\n         );\n      }\n+    public static void assertNotContained(String haystack, String needle) {\n+        assertFalse(\n+              \"Unexpectedly found text '\" + needle + \"' in text:\\n\" + haystack,\n+              haystack.contains(needle)\n+        );\n+     }\n     \n     public static <T> void assertEquals(T[] expected, T[] actual)\n     {",
                "raw_url": "https://github.com/apache/poi/raw/735760f21e91a0e40efe7bff30477099b7d31de0/src/testcases/org/apache/poi/POITestCase.java",
                "sha": "3d0cea51dc30983cc2e58d7a6c1a665054e6493f",
                "status": "modified"
            }
        ],
        "message": "NPE fix for text extraction from MSG files with only a short name\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1694255 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/c90272d65ecb7167f9ed0dd271a9ce6f26692293",
        "patched_files": [
            "OutlookTextExtractor.java",
            "OutlookTextExtactor.java",
            "POITestCase.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestPOITestCase.java",
            "TestOutlookTextExtractor.java"
        ]
    },
    "poi_76307fe": {
        "bug_id": "poi_76307fe",
        "commit": "https://github.com/apache/poi/commit/76307fe94bb6a3555967372ff7879a6adcb0f0f7",
        "file": [
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/TestAllFiles.java",
                "changes": 36,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/TestAllFiles.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 13,
                "filename": "src/integrationtest/org/apache/poi/TestAllFiles.java",
                "patch": "@@ -253,20 +253,26 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     @Test\n     public void testAllFiles() throws Exception {\n \t\tassertNotNull(\"Unknown file extension for file: \" + file + \": \" + getExtension(file), handler);\n-\t\tInputStream stream = new BufferedInputStream(new FileInputStream(new File(ROOT_DIR, file)),100);\n+\t\tFile inputFile = new File(ROOT_DIR, file);\n+\t\t\n \t\ttry {\n-\t\t\thandler.handleFile(stream);\n-\t\t\t\n-\t\t\tassertFalse(\"Expected to fail for file \" + file + \" and handler \" + handler + \", but did not fail!\", \n-\t\t\t        EXPECTED_FAILURES.contains(file));\n-\t\t} catch (Exception e) {\n-\t\t    // check if we expect failure for this file\n-\t\t\tif(!EXPECTED_FAILURES.contains(file)) {\n-\t\t\t    throw new Exception(\"While handling \" + file, e);\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tstream.close();\n-\t\t}\n+            InputStream stream = new BufferedInputStream(new FileInputStream(inputFile),100);\n+    \t\ttry {\n+    \t\t\thandler.handleFile(stream);\n+    \n+    \t\t\tassertFalse(\"Expected to fail for file \" + file + \" and handler \" + handler + \", but did not fail!\", \n+    \t\t\t        EXPECTED_FAILURES.contains(file));\n+    \t\t} finally {\n+    \t\t\tstream.close();\n+    \t\t}\n+\n+            handler.handleExtracting(inputFile);\n+        } catch (Exception e) {\n+            // check if we expect failure for this file\n+            if(!EXPECTED_FAILURES.contains(file) && !AbstractFileHandler.EXPECTED_EXTRACTOR_FAILURES.contains(file)) {\n+                throw new Exception(\"While handling \" + file, e);\n+            }\n+        }\n \t}\n \n \tprivate static String getExtension(String file) {\n@@ -282,5 +288,9 @@ private static String getExtension(String file) {\n \t\t@Override\n         public void handleFile(InputStream stream) throws Exception {\n \t\t}\n+\n+\t\t@Override\n+        public void handleExtracting(File file) throws Exception {\n+        }\n \t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/TestAllFiles.java",
                "sha": "d0439b40fd51a40814cb8b9ac785cd0786b2afcd",
                "status": "modified"
            },
            {
                "additions": 55,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java",
                "changes": 55,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 0,
                "filename": "src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java",
                "patch": "@@ -0,0 +1,55 @@\n+package org.apache.poi.stress;\r\n+\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertNotNull;\r\n+\r\n+import java.io.File;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.poi.POITextExtractor;\r\n+import org.apache.poi.extractor.ExtractorFactory;\r\n+\r\n+public abstract class AbstractFileHandler implements FileHandler {\r\n+    public static final Set<String> EXPECTED_EXTRACTOR_FAILURES = new HashSet<String>();\r\n+    static {\r\n+        // password protected files\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"document/bug53475-password-is-pass.docx\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"poifs/extenxls_pwd123.xlsx\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"poifs/protect.xlsx\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"poifs/protected_agile.docx\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"poifs/protected_sha512.xlsx\");\r\n+        \r\n+        // unsupported file-types, no supported OLE2 parts\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"hmef/quick-winmail.dat\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"hmef/winmail-sample1.dat\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"hmef/bug52400-winmail-simple.dat\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"hmef/bug52400-winmail-with-attachments.dat\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"hpsf/Test0313rur.adm\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"hsmf/attachment_msg_pdf.msg\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"poifs/Notes.ole2\");\r\n+        EXPECTED_EXTRACTOR_FAILURES.add(\"slideshow/testPPT.thmx\");\r\n+    }\r\n+\r\n+    public void handleExtracting(File file) throws Exception {\r\n+        POITextExtractor extractor = ExtractorFactory.createExtractor(file);\r\n+        try  {\r\n+            assertNotNull(extractor);\r\n+\r\n+            assertNotNull(extractor.getText());\r\n+            \r\n+            // also try metadata\r\n+            POITextExtractor metadataExtractor = extractor.getMetadataTextExtractor();\r\n+            assertNotNull(metadataExtractor.getText());\r\n+\r\n+            assertFalse(\"Expected Extraction to fail for file \" + file + \" and handler \" + this + \", but did not fail!\", \r\n+                    EXPECTED_EXTRACTOR_FAILURES.contains(file));\r\n+        } catch (IllegalArgumentException e) {\r\n+            if(!EXPECTED_EXTRACTOR_FAILURES.contains(file)) {\r\n+                throw new Exception(\"While handling \" + file, e);\r\n+            }\r\n+        } finally {\r\n+            extractor.close();\r\n+        }\r\n+    }\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java",
                "sha": "85ebb1b45155f92765bf7526e36c31c55aa4102c",
                "status": "added"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/FileHandler.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/FileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 0,
                "filename": "src/integrationtest/org/apache/poi/stress/FileHandler.java",
                "patch": "@@ -16,6 +16,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.stress;\n \n+import java.io.File;\n import java.io.InputStream;\n \n /**\n@@ -34,4 +35,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t * @throws Exception\n \t */\n \tvoid handleFile(InputStream stream) throws Exception;\n+\t\n+\t/**\n+\t * Ensures that extracting text from the given file\n+\t * is returning some text. \n+\t */\n+\tvoid handleExtracting(File file) throws Exception;\n }",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/FileHandler.java",
                "sha": "ce2991b0bc3b8e7f9a9cd93901e79fde87c08cd6",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/HMEFFileHandler.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/HMEFFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/HMEFFileHandler.java",
                "patch": "@@ -26,7 +26,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hmef.attribute.MAPIStringAttribute;\n import org.junit.Test;\n \n-public class HMEFFileHandler implements FileHandler {\n+public class HMEFFileHandler extends AbstractFileHandler {\n \n \t@Override\n     public void handleFile(InputStream stream) throws Exception {",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/HMEFFileHandler.java",
                "sha": "9f492bf0edda1ab00d0c37b7b62ffcac28d05e02",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java",
                "patch": "@@ -25,7 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n import org.junit.Test;\n \n-public class HPSFFileHandler implements FileHandler {\n+public class HPSFFileHandler extends AbstractFileHandler {\n \t@Override\n     public void handleFile(InputStream stream) throws Exception {\n \t\tHPSFPropertiesOnlyDocument hpsf = new HPSFPropertiesOnlyDocument(new POIFSFileSystem(stream));",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java",
                "sha": "477ee859cb9ed848cd61d9cd81614a1f8af867b4",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 0,
                "filename": "src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java",
                "patch": "@@ -16,6 +16,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.stress;\n \n+import java.io.File;\n import java.io.FileInputStream;\n import java.io.InputStream;\n \n@@ -49,4 +50,10 @@ public void test() throws Exception {\n \t\t\tstream.close();\n \t\t}\n \t}\n+\n+\t// a test-case to test this locally without executing the full TestAllFiles\n+    @Test\n+    public void testExtractor() throws Exception {\n+        handleExtracting(new File(\"test-data/spreadsheet/BOOK_in_capitals.xls\"));\n+    }\n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java",
                "sha": "dd579c4dba891a98a0ff9e3f3e89bad5672ff78b",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/POIFSFileHandler.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/POIFSFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/POIFSFileHandler.java",
                "patch": "@@ -25,7 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.POIDocument;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n \n-public class POIFSFileHandler implements FileHandler {\n+public class POIFSFileHandler extends AbstractFileHandler {\n \n \t@Override\n     public void handleFile(InputStream stream) throws Exception {",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/POIFSFileHandler.java",
                "sha": "5c4a36e3caef0212f41e3d6443db2f7a32524fbe",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java",
                "patch": "@@ -30,7 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.ss.usermodel.Workbook;\n import org.apache.poi.ss.usermodel.WorkbookFactory;\n \n-public abstract class SpreadsheetHandler implements FileHandler {\n+public abstract class SpreadsheetHandler extends AbstractFileHandler {\n \tpublic void handleWorkbook(Workbook wb, String extension) throws IOException {\n \t\t// try to access some of the content\n \t\treadContent(wb);",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java",
                "sha": "f12bbd2de55bc55acfa80b06388752b2c2d1d04b",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/XSLFFileHandler.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/XSLFFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/XSLFFileHandler.java",
                "patch": "@@ -25,7 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.xslf.XSLFSlideShow;\n import org.junit.Test;\n \n-public class XSLFFileHandler implements FileHandler {\n+public class XSLFFileHandler extends AbstractFileHandler {\n \t@Override\n     public void handleFile(InputStream stream) throws Exception {\n         // ignore password protected files",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/XSLFFileHandler.java",
                "sha": "e6cbb184b207eff7d27e2bf75e4a3de562ec9bab",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/XWPFFileHandler.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/XWPFFileHandler.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/XWPFFileHandler.java",
                "patch": "@@ -22,7 +22,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.xwpf.usermodel.XWPFDocument;\n import org.junit.Test;\n \n-public class XWPFFileHandler implements FileHandler {\n+public class XWPFFileHandler extends AbstractFileHandler {\n \t@Override\n     public void handleFile(InputStream stream) throws Exception {\n         // ignore password protected files",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/integrationtest/org/apache/poi/stress/XWPFFileHandler.java",
                "sha": "47c18d8aa051f0da9712acfe701e8b88dbb25e94",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java",
                "patch": "@@ -213,7 +213,9 @@ public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IO\n     {\n         // Look for certain entries in the stream, to figure it\n         // out from\n-        if (poifsDir.hasEntry(\"Workbook\")) {\n+        if (poifsDir.hasEntry(\"Workbook\") ||\n+                // some XLS files have different entry-names\n+                poifsDir.hasEntry(\"WORKBOOK\") || poifsDir.hasEntry(\"BOOK\")) {\n             if (getPreferEventExtractor()) {\n                 return new EventBasedExcelExtractor(poifsDir);\n             }",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java",
                "sha": "a0b6b5db17480330fd264d5fccf135e5ecec76e6",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExcelExtractor.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExcelExtractor.java?ref=76307fe94bb6a3555967372ff7879a6adcb0f0f7",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExcelExtractor.java",
                "patch": "@@ -80,7 +80,11 @@ public static void main(String[] args) throws Exception {\n         }\n         POIXMLTextExtractor extractor =\n                 new XSSFExcelExtractor(args[0]);\n-        System.out.println(extractor.getText());\n+        try {\n+            System.out.println(extractor.getText());\n+        } finally {\n+            extractor.close();\n+        }\n     }\n \n     /**\n@@ -237,7 +241,7 @@ private void handleNonStringCell(StringBuffer text, Cell cell, DataFormatter for\n         if (type == Cell.CELL_TYPE_NUMERIC) {\n             CellStyle cs = cell.getCellStyle();\n \n-            if (cs.getDataFormatString() != null) {\n+            if (cs != null && cs.getDataFormatString() != null) {\n                 text.append(formatter.formatRawCellContents(\n                         cell.getNumericCellValue(), cs.getDataFormat(), cs.getDataFormatString()\n                         ));",
                "raw_url": "https://github.com/apache/poi/raw/76307fe94bb6a3555967372ff7879a6adcb0f0f7/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExcelExtractor.java",
                "sha": "39ef5be8a4bb90fb0a5a246f671146e02481910d",
                "status": "modified"
            }
        ],
        "message": "* Add text-extraction verification to integration-tests via a new abstract base FileHandler\n* Fix NullPointerException found in some documents when running against the test-data\n* Add support for extracting text from Dir-Entries WORKBOOK and BOOK to support some old/strangely formatted XLS files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1662652 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/51a428c5eefa78d5a18cca919748089d6fe2b62d",
        "patched_files": [
            "ExtractorFactory.java",
            "XSSFExcelExtractor.java",
            "HMEFFileHandler.java",
            "POIFSFileHandler.java",
            "FileHandler.java",
            "SpreadsheetHandler.java",
            "HSSFFileHandler.java",
            "HPSFFileHandler.java",
            "AbstractFileHandler.java",
            "XSLFFileHandler.java",
            "XWPFFileHandler.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestAllFiles.java",
            "TestXSSFExcelExtractor.java",
            "TestExtractorFactory.java"
        ]
    },
    "poi_76998bc": {
        "bug_id": "poi_76998bc",
        "commit": "https://github.com/apache/poi/commit/76998bc75c9965cad0af3e79b3082945bb5fbd14",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/76998bc75c9965cad0af3e79b3082945bb5fbd14/src/testcases/org/apache/poi/ss/util/TestAreaReference.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/util/TestAreaReference.java?ref=76998bc75c9965cad0af3e79b3082945bb5fbd14",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/ss/util/TestAreaReference.java",
                "patch": "@@ -47,4 +47,9 @@ public void testWholeRow() {\n         assertEquals(1, newStyle.getLastCell().getRow());\n     }\n \n+    @SuppressWarnings(\"deprecation\") // deliberate test for behaviour if deprecated constructor used.\n+    public void testFallbackToExcel97IfVersionNotSupplied() {\n+        assertTrue(new AreaReference(\"A:B\").isWholeColumnReference());\n+        assertTrue(AreaReference.isWholeColumnReference(null, new CellReference(\"A$1\"), new CellReference(\"A$\" + SpreadsheetVersion.EXCEL97.getMaxRows())));\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/76998bc75c9965cad0af3e79b3082945bb5fbd14/src/testcases/org/apache/poi/ss/util/TestAreaReference.java",
                "sha": "525abc9891c9e2e6cc08b5224eb7d427eb5e883f",
                "status": "modified"
            }
        ],
        "message": "Add explicit test for NPE only caught by other tests. Test '97 fallback behaviour generally.\n\nhttps://bz.apache.org/bugzilla/show_bug.cgi?id=56328\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1685104 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/26dda73341d98dfec6026c72666640003832dcb1",
        "patched_files": [
            "AreaReference.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestAreaReference.java"
        ]
    },
    "poi_7744fd9": {
        "bug_id": "poi_7744fd9",
        "commit": "https://github.com/apache/poi/commit/7744fd96c1e3570de630d150344f7d9065c685d7",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/7744fd96c1e3570de630d150344f7d9065c685d7/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java?ref=7744fd96c1e3570de630d150344f7d9065c685d7",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java",
                "patch": "@@ -346,7 +346,7 @@ public XSSFFont getFontOfFormattingRun(int index) {\n \n         for(int i = 0; i < st.sizeOfRArray(); i++){\n             CTRElt r = st.getRArray(i);\n-            if(i == index) {\n+            if(i == index && r.getRPr() != null) {\n                XSSFFont fnt = new XSSFFont(toCTFont(r.getRPr()));\n                fnt.setThemesTable(getThemesTable());\n                return fnt;",
                "raw_url": "https://github.com/apache/poi/raw/7744fd96c1e3570de630d150344f7d9065c685d7/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFRichTextString.java",
                "sha": "89568f0b520e144bb38bc4bdf4f60775b167c22c",
                "status": "modified"
            },
            {
                "additions": 57,
                "blob_url": "https://github.com/apache/poi/blob/7744fd96c1e3570de630d150344f7d9065c685d7/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFRichTextString.java",
                "changes": 57,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFRichTextString.java?ref=7744fd96c1e3570de630d150344f7d9065c685d7",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFRichTextString.java",
                "patch": "@@ -22,6 +22,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import junit.framework.TestCase;\n \n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Sheet;\n+import org.apache.poi.xssf.XSSFTestDataSamples;\n+import org.junit.Test;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTRPrElt;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTRst;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.STXstring;\n@@ -357,4 +361,57 @@ public void testLineBreaks_bug48877() throws IOException{\n         assertEquals(\"<xml-fragment>New Line</xml-fragment>\", t2.xmlText());\n         assertEquals(\"<xml-fragment xml:space=\\\"preserve\\\">\\n\\n</xml-fragment>\", t3.xmlText());\n     }\n+\n+    \n+    @Test\n+    public void testBug56511() {\n+        XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"56511.xlsx\");\n+        for (XSSFSheet sheet : wb) {\n+            int lastRow = sheet.getLastRowNum();\n+            for (int rowIdx = sheet.getFirstRowNum(); rowIdx <= lastRow; rowIdx++) {\n+                XSSFRow row = sheet.getRow(rowIdx);\n+                if(row != null) {\n+                    int lastCell = row.getLastCellNum();\n+    \n+                    for (int cellIdx = row.getFirstCellNum(); cellIdx <= lastCell; cellIdx++) {\n+    \n+                        XSSFCell cell = row.getCell(cellIdx);\n+                        if (cell != null) {\n+                            //System.out.println(\"row \" + rowIdx + \" column \" + cellIdx + \": \" + cell.getCellType() + \": \" + cell.toString());\n+                            \n+                            XSSFRichTextString richText = cell.getRichStringCellValue();\n+                            int anzFormattingRuns = richText.numFormattingRuns();\n+                            for (int run = 0; run < anzFormattingRuns; run++) {\n+                                /*XSSFFont font =*/ richText.getFontOfFormattingRun(run);\n+                                //System.out.println(\"  run \" + run\n+                                //        + \" font \" + (font == null ? \"<null>\" : font.getFontName()));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testBug56511_values() {\n+        XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"56511.xlsx\");\n+        Sheet sheet = wb.getSheetAt(0);\n+        Row row = sheet.getRow(0);\n+\n+        // verify the values to ensure future changes keep the returned information equal \n+        assertEquals(0, row.getCell(0).getRichStringCellValue().numFormattingRuns());\n+        assertEquals(0, row.getCell(1).getRichStringCellValue().numFormattingRuns());\n+        \n+        XSSFRichTextString rt = (XSSFRichTextString) row.getCell(2).getRichStringCellValue();\n+        assertEquals(2, rt.numFormattingRuns());\n+        assertNotNull(rt.getFontOfFormattingRun(0));\n+        assertNotNull(rt.getFontOfFormattingRun(1));\n+        \n+        rt = (XSSFRichTextString) row.getCell(3).getRichStringCellValue();\n+        assertEquals(3, rt.numFormattingRuns());\n+        assertNull(rt.getFontOfFormattingRun(0));\n+        assertNotNull(rt.getFontOfFormattingRun(1));\n+        assertNotNull(rt.getFontOfFormattingRun(2));\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/7744fd96c1e3570de630d150344f7d9065c685d7/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFRichTextString.java",
                "sha": "6d053bea133ba76615550b55950e5290db7cac4f",
                "status": "modified"
            }
        ],
        "message": "Bug 56511: Add a null-check to ensure that the run actually has a font to not cause a NullPointerException but rather return null as documented\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1647308 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/b3149076f6719b71fe4efce6c7105349fc9f7ebd",
        "patched_files": [
            "XSSFRichTextString.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFRichTextString.java"
        ]
    },
    "poi_78e643f": {
        "bug_id": "poi_78e643f",
        "commit": "https://github.com/apache/poi/commit/78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableCellEditor.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableCellEditor.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableCellEditor.java",
                "patch": "@@ -15,7 +15,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n+\n package org.apache.poi.hssf.contrib.view;\n \n import java.awt.*;\n@@ -33,7 +33,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * nearly completely consists of overridden methods.\n  *\n  * @author     Jason Height\n- * @since      16 July 2002\n  */\n public class SVTableCellEditor extends AbstractCellEditor implements TableCellEditor, ActionListener {\n   private static final Color black = getAWTColor(new HSSFColor.BLACK());\n@@ -192,7 +191,7 @@ public Component getTableCellEditorComponent(JTable table, Object value,\n      *\n      */\n     private final Color getAWTColor(int index, Color deflt) {\n-      HSSFColor clr = (HSSFColor)colors.get(new Integer(index));\n+      HSSFColor clr = (HSSFColor)colors.get(Integer.valueOf(index));\n       if (clr == null) return deflt;\n       return getAWTColor(clr);\n     }\n@@ -201,5 +200,4 @@ private static final Color getAWTColor(HSSFColor clr) {\n       short[] rgb = clr.getTriplet();\n       return new Color(rgb[0],rgb[1],rgb[2]);\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableCellEditor.java",
                "sha": "e7a2a5ded3d4e5d3386d9394303e6cbe9cf418db",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableUtils.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableUtils.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableUtils.java",
                "patch": "@@ -15,7 +15,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n+\n package org.apache.poi.hssf.contrib.view;\n \n import java.util.*;\n@@ -29,7 +29,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * SVTableCell Editor and Renderer helper functions.\n  *\n  * @author     Jason Height\n- * @since      16 July 2002\n  */\n public class SVTableUtils {\n   private final static Hashtable colors = HSSFColor.getIndexHash();\n@@ -73,7 +72,7 @@ public static Font makeFont(HSSFFont font) {\n    * @return        The aWTColor value\n    */\n   public final static Color getAWTColor(int index, Color deflt) {\n-    HSSFColor clr = (HSSFColor) colors.get(new Integer(index));\n+    HSSFColor clr = (HSSFColor) colors.get(Integer.valueOf(index));\n     if (clr == null) {\n       return deflt;\n     }\n@@ -91,5 +90,4 @@ public final static Color getAWTColor(HSSFColor clr) {\n     short[] rgb = clr.getTriplet();\n     return new Color(rgb[0], rgb[1], rgb[2]);\n   }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/hssf/contrib/view/SVTableUtils.java",
                "sha": "5815ea0a591e3883fa3cdf953d47af732a63e08d",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/ss/usermodel/contrib/CellUtil.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/contrib/src/org/apache/poi/ss/usermodel/contrib/CellUtil.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/contrib/src/org/apache/poi/ss/usermodel/contrib/CellUtil.java",
                "patch": "@@ -154,7 +154,7 @@ public static Cell createCell(Row row, int column, String value) {\n \t * @see CellStyle for alignment options\n \t */\n \tpublic static void setAlignment(Cell cell, Workbook workbook, short align) {\n-\t\tsetCellStyleProperty(cell, workbook, ALIGNMENT, new Short(align));\n+\t\tsetCellStyleProperty(cell, workbook, ALIGNMENT, Short.valueOf(align));\n \t}\n \n \t/**\n@@ -311,7 +311,7 @@ private static boolean getBoolean(Map<String, Object> properties, String name) {\n \t * @param value property value\n \t */\n \tprivate static void putShort(Map<String, Object> properties, String name, short value) {\n-\t\tproperties.put(name, new Short(value));\n+\t\tproperties.put(name, Short.valueOf(value));\n \t}\n \n \t/**\n@@ -322,7 +322,7 @@ private static void putShort(Map<String, Object> properties, String name, short\n \t * @param value property value\n \t */\n \tprivate static void putBoolean(Map<String, Object> properties, String name, boolean value) {\n-\t\tproperties.put(name, new Boolean(value));\n+\t\tproperties.put(name, Boolean.valueOf(value));\n \t}\n \n \t/**",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/ss/usermodel/contrib/CellUtil.java",
                "sha": "d18cd4159b570da318211602bb13ca4ae0f8ddfa",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/ss/usermodel/contrib/RegionUtil.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/contrib/src/org/apache/poi/ss/usermodel/contrib/RegionUtil.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/contrib/src/org/apache/poi/ss/usermodel/contrib/RegionUtil.java",
                "patch": "@@ -48,7 +48,7 @@ private RegionUtil() {\n \t\tpublic CellPropertySetter(Workbook workbook, String propertyName, int value) {\n \t\t\t_workbook = workbook;\n \t\t\t_propertyName = propertyName;\n-\t\t\t_propertyValue = new Short((short) value);\n+\t\t\t_propertyValue = Short.valueOf((short) value);\n \t\t}\n \n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/contrib/src/org/apache/poi/ss/usermodel/contrib/RegionUtil.java",
                "sha": "612d72aac1f42e035d13284ae31b519d0dfd57d3",
                "status": "modified"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/examples/src/org/apache/poi/hpsf/examples/ModifyDocumentSummaryInformation.java",
                "changes": 52,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/examples/src/org/apache/poi/hpsf/examples/ModifyDocumentSummaryInformation.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 27,
                "filename": "src/examples/src/org/apache/poi/hpsf/examples/ModifyDocumentSummaryInformation.java",
                "patch": "@@ -45,53 +45,52 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * the summary information and in the document summary information. The\n  * application reads the name of a POI filesystem from the command line and\n  * performs the following actions:</p>\n- * \n+ *\n  * <ul>\n- * \n+ *\n  * <li><p>Open the POI filesystem.</p></li>\n- * \n+ *\n  * <li><p>Read the summary information.</p></li>\n- * \n+ *\n  * <li><p>Read and print the \"author\" property.</p></li>\n- * \n+ *\n  * <li><p>Change the author to \"Rainer Klute\".</p></li>\n- * \n+ *\n  * <li><p>Read the document summary information.</p></li>\n- * \n+ *\n  * <li><p>Read and print the \"category\" property.</p></li>\n- * \n+ *\n  * <li><p>Change the category to \"POI example\".</p></li>\n- * \n+ *\n  * <li><p>Read the custom properties (if available).</p></li>\n- * \n+ *\n  * <li><p>Insert a new custom property.</p></li>\n- * \n+ *\n  * <li><p>Write the custom properties back to the document summary\n  * information.</p></li>\n- * \n+ *\n  * <li><p>Write the summary information to the POI filesystem.</p></li>\n- * \n+ *\n  * <li><p>Write the document summary information to the POI filesystem.</p></li>\n- * \n+ *\n  * <li><p>Write the POI filesystem back to the original file.</p></li>\n- * \n+ *\n  * </ol>\n- * \n+ *\n  * @author Rainer Klute <a\n  *         href=\"mailto:klute@rainer-klute.de\">klute@rainer-klute.de</a>\n  */\n-public class ModifyDocumentSummaryInformation\n-{\n+public class ModifyDocumentSummaryInformation {\n \n     /**\n      * <p>Main method - see class description.</p>\n      *\n      * @param args The command-line parameters.\n-     * @throws IOException \n-     * @throws MarkUnsupportedException \n-     * @throws NoPropertySetStreamException \n-     * @throws UnexpectedPropertySetTypeException \n-     * @throws WritingNotSupportedException \n+     * @throws IOException\n+     * @throws MarkUnsupportedException\n+     * @throws NoPropertySetStreamException\n+     * @throws UnexpectedPropertySetTypeException\n+     * @throws WritingNotSupportedException\n      */\n     public static void main(final String[] args) throws IOException,\n             NoPropertySetStreamException, MarkUnsupportedException,\n@@ -165,12 +164,12 @@ public static void main(final String[] args) throws IOException,\n         CustomProperties customProperties = dsi.getCustomProperties();\n         if (customProperties == null)\n             customProperties = new CustomProperties();\n-        \n+\n         /* Insert some custom properties into the container. */\n         customProperties.put(\"Key 1\", \"Value 1\");\n         customProperties.put(\"Schl\\u00fcssel 2\", \"Wert 2\");\n         customProperties.put(\"Sample Number\", new Integer(12345));\n-        customProperties.put(\"Sample Boolean\", new Boolean(true));\n+        customProperties.put(\"Sample Boolean\", Boolean.TRUE);\n         customProperties.put(\"Sample Date\", new Date());\n \n         /* Read a custom property. */\n@@ -191,6 +190,5 @@ public static void main(final String[] args) throws IOException,\n         OutputStream out = new FileOutputStream(poiFilesystem);\n         poifs.writeFilesystem(out);\n         out.close();\n-        }\n-\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/examples/src/org/apache/poi/hpsf/examples/ModifyDocumentSummaryInformation.java",
                "sha": "66c1cbdb0eae2b3208578230bb7ff791622fa0d0",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ddf/DefaultEscherRecordFactory.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ddf/DefaultEscherRecordFactory.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/ddf/DefaultEscherRecordFactory.java",
                "patch": "@@ -89,7 +89,7 @@ else if (header.getRecordId() == EscherMetafileBlip.RECORD_ID_EMF ||\n             return r;\n         }\n \n-        Constructor<? extends EscherRecord> recordConstructor = recordsMap.get(new Short(header.getRecordId()));\n+        Constructor<? extends EscherRecord> recordConstructor = recordsMap.get(Short.valueOf(header.getRecordId()));\n         EscherRecord escherRecord = null;\n         if (recordConstructor == null) {\n             return new UnknownEscherRecord();\n@@ -135,7 +135,7 @@ else if (header.getRecordId() == EscherMetafileBlip.RECORD_ID_EMF ||\n             } catch (NoSuchMethodException e) {\n                 throw new RuntimeException(e);\n             }\n-            result.put(new Short(sid), constructor);\n+            result.put(Short.valueOf(sid), constructor);\n         }\n         return result;\n     }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ddf/DefaultEscherRecordFactory.java",
                "sha": "c5d21edd236b9ba0af20ae49ce1165de16625bfb",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ddf/EscherOptRecord.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ddf/EscherOptRecord.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/ddf/EscherOptRecord.java",
                "patch": "@@ -158,7 +158,7 @@ public int compare( Object o1, Object o2 )\n             {\n                 EscherProperty p1 = (EscherProperty) o1;\n                 EscherProperty p2 = (EscherProperty) o2;\n-                return new Short( p1.getPropertyNumber() ).compareTo( new Short( p2.getPropertyNumber() ) );\n+                return Short.valueOf( p1.getPropertyNumber() ).compareTo( Short.valueOf( p2.getPropertyNumber() ) );\n             }\n         } );\n     }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ddf/EscherOptRecord.java",
                "sha": "916afb985a437273ded143bba2e396bb1d4cfed1",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ddf/EscherProperties.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ddf/EscherProperties.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/ddf/EscherProperties.java",
                "patch": "@@ -586,20 +586,20 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t}\n \n \tprivate static void addProp(Map<Short, EscherPropertyMetaData> m, int s, String propName) {\n-\t\tm.put(new Short((short) s), new EscherPropertyMetaData(propName));\n+\t\tm.put(Short.valueOf((short) s), new EscherPropertyMetaData(propName));\n \t}\n \n \tprivate static void addProp(Map<Short, EscherPropertyMetaData> m, int s, String propName, byte type) {\n-\t\tm.put(new Short((short) s), new EscherPropertyMetaData(propName, type));\n+\t\tm.put(Short.valueOf((short) s), new EscherPropertyMetaData(propName, type));\n \t}\n \n \tpublic static String getPropertyName(short propertyId) {\n-\t\tEscherPropertyMetaData o = properties.get(new Short(propertyId));\n+\t\tEscherPropertyMetaData o = properties.get(Short.valueOf(propertyId));\n \t\treturn o == null ? \"unknown\" : o.getDescription();\n \t}\n \n \tpublic static byte getPropertyType(short propertyId) {\n-\t\tEscherPropertyMetaData escherPropertyMetaData = properties.get(new Short(propertyId));\n+\t\tEscherPropertyMetaData escherPropertyMetaData = properties.get(Short.valueOf(propertyId));\n \t\treturn escherPropertyMetaData == null ? 0 : escherPropertyMetaData.getType();\n \t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ddf/EscherProperties.java",
                "sha": "767e92be981e9fcb4a66b8e79353323f283ab9de",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/CustomProperties.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/CustomProperties.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 23,
                "filename": "src/java/org/apache/poi/hpsf/CustomProperties.java",
                "patch": "@@ -33,22 +33,22 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * name is the key that maps to a typed value. This implementation hides\n  * property IDs from the developer and regards the property names as keys to\n  * typed values.</p>\n- * \n+ *\n  * <p>While this class provides a simple API to custom properties, it ignores\n  * the fact that not names, but IDs are the real keys to properties. Under the\n  * hood this class maintains a 1:1 relationship between IDs and names. Therefore\n  * you should not use this class to process property sets with several IDs\n  * mapping to the same name or with properties without a name: the result will\n  * contain only a subset of the original properties. If you really need to deal\n  * such property sets, use HPSF's low-level access methods.</p>\n- * \n+ *\n  * <p>An application can call the {@link #isPure} method to check whether a\n  * property set parsed by {@link CustomProperties} is still pure (i.e.\n  * unmodified) or whether one or more properties have been dropped.</p>\n- * \n+ *\n  * <p>This class is not thread-safe; concurrent access to instances of this\n  * class must be synchronized.</p>\n- * \n+ *\n  * @author Rainer Klute <a\n  *         href=\"mailto:klute@rainer-klute.de\">&lt;klute@rainer-klute.de&gt;</a>\n  */\n@@ -64,7 +64,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * <p>Maps property names to property IDs.</p>\n      */\n     private Map dictionaryNameToID = new HashMap();\n-    \n+\n     /**\n      * <p>Tells whether this object is pure or not.</p>\n      */\n@@ -96,7 +96,7 @@ public Object put(final Object name, final Object customProperty) throws ClassCa\n                     \") do not match.\");\n \n         /* Register name and ID in the dictionary. Mapping in both directions is possible. If there is already a  */\n-        final Long idKey = new Long(cp.getID());\n+        final Long idKey = Long.valueOf(cp.getID());\n         final Object oldID = dictionaryNameToID.get(name);\n         dictionaryIDToName.remove(oldID);\n         dictionaryNameToID.put(name, idKey);\n@@ -113,16 +113,16 @@ public Object put(final Object name, final Object customProperty) throws ClassCa\n     /**\n      * <p>Puts a {@link CustomProperty} that has not yet a valid ID into this\n      * map. The method will allocate a suitable ID for the custom property:</p>\n-     * \n+     *\n      * <ul>\n-     * \n+     *\n      * <li><p>If there is already a property with the same name, take the ID\n      * of that property.</p></li>\n-     * \n+     *\n      * <li><p>Otherwise find the highest ID and use its value plus one.</p></li>\n-     * \n+     *\n      * </ul>\n-     * \n+     *\n      * @param customProperty\n      * @return If the was already a property with the same name, the\n      * @throws ClassCastException\n@@ -153,7 +153,7 @@ private Object put(final CustomProperty customProperty) throws ClassCastExceptio\n \n     /**\n      * <p>Removes a custom property.</p>\n-     * @param name The name of the custom property to remove \n+     * @param name The name of the custom property to remove\n      * @return The removed property or <code>null</code> if the specified property was not found.\n      *\n      * @see java.util.HashSet#remove(java.lang.Object)\n@@ -170,7 +170,7 @@ public Object remove(final String name)\n \n     /**\n      * <p>Adds a named string property.</p>\n-     * \n+     *\n      * @param name The property's name.\n      * @param value The property's value.\n      * @return the property that was stored under the specified name before, or\n@@ -258,10 +258,10 @@ public Object put(final String name, final Boolean value)\n         return put(cp);\n     }\n \n-    \n+\n     /**\n      * <p>Gets a named value from the custom properties.</p>\n-     * \n+     *\n      * @param name the name of the value to get\n      * @return the value or <code>null</code> if a value with the specified\n      *         name is not found in the custom properties.\n@@ -292,18 +292,18 @@ public Object put(final String name, final Date value)\n         final CustomProperty cp = new CustomProperty(p, name);\n         return put(cp);\n     }\n-    \n+\n     /**\n      * Returns a set of all the names of our\n      *  custom properties\n      */\n     public Set keySet() {\n-    \treturn dictionaryNameToID.keySet();\n-\t}\n+        return dictionaryNameToID.keySet();\n+    }\n \n \n \n-\t/**\n+    /**\n      * <p>Sets the codepage.</p>\n      *\n      * @param codepage the codepage\n@@ -313,7 +313,7 @@ public void setCodepage(final int codepage)\n         final MutableProperty p = new MutableProperty();\n         p.setID(PropertyIDMap.PID_CODEPAGE);\n         p.setType(Variant.VT_I2);\n-        p.setValue(new Integer(codepage));\n+        p.setValue(Integer.valueOf(codepage));\n         put(new CustomProperty(p));\n     }\n \n@@ -322,7 +322,7 @@ public void setCodepage(final int codepage)\n     /**\n      * <p>Gets the dictionary which contains IDs and names of the named custom\n      * properties.\n-     * \n+     *\n      * @return the dictionary.\n      */\n     Map getDictionary()\n@@ -355,7 +355,7 @@ public int getCodepage()\n      * <p>Tells whether this {@link CustomProperties} instance is pure or one or\n      * more properties of the underlying low-level property set has been\n      * dropped.</p>\n-     * \n+     *\n      * @return <code>true</code> if the {@link CustomProperties} is pure, else\n      *         <code>false</code>.\n      */\n@@ -373,5 +373,4 @@ public void setPure(final boolean isPure)\n     {\n         this.isPure = isPure;\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/CustomProperties.java",
                "sha": "a3242057ba63949b75177f55954f723af9f5006f",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/DocumentSummaryInformation.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/DocumentSummaryInformation.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 8,
                "filename": "src/java/org/apache/poi/hpsf/DocumentSummaryInformation.java",
                "patch": "@@ -567,9 +567,8 @@ public void removeLinksDirty()\n \n     /**\n      * <p>Gets the custom properties.</p>\n-     * \n+     *\n      * @return The custom properties.\n-     * @since 2006-02-09\n      */\n     public CustomProperties getCustomProperties()\n     {\n@@ -589,7 +588,7 @@ public CustomProperties getCustomProperties()\n                 {\n                     propertyCount++;\n                     final CustomProperty cp = new CustomProperty(p,\n-                            (String) dictionary.get(new Long(id)));\n+                            (String) dictionary.get(Long.valueOf(id)));\n                     cps.put(cp.getName(), cp);\n                 }\n             }\n@@ -601,9 +600,8 @@ public CustomProperties getCustomProperties()\n \n     /**\n      * <p>Sets the custom properties.</p>\n-     * \n+     *\n      * @param customProperties The custom properties\n-     * @since 2006-02-07\n      */\n     public void setCustomProperties(final CustomProperties customProperties)\n     {\n@@ -650,8 +648,6 @@ private void ensureSection2()\n \n     /**\n      * <p>Removes the custom properties.</p>\n-     * \n-     * @since 2006-02-08\n      */\n     public void removeCustomProperties()\n     {\n@@ -674,5 +670,4 @@ private void notYetImplemented(final String msg)\n     {\n         throw new UnsupportedOperationException(msg + \" is not yet implemented.\");\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/DocumentSummaryInformation.java",
                "sha": "bfee086e45cee0e572d26d8275deebec58a74876",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/MutableSection.java",
                "changes": 53,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/MutableSection.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 27,
                "filename": "src/java/org/apache/poi/hpsf/MutableSection.java",
                "patch": "@@ -80,11 +80,11 @@ public MutableSection()\n \n \n     /**\n-     * <p>Constructs a <code>MutableSection</code> by doing a deep copy of an \n-     * existing <code>Section</code>. All nested <code>Property</code> \n+     * <p>Constructs a <code>MutableSection</code> by doing a deep copy of an\n+     * existing <code>Section</code>. All nested <code>Property</code>\n      * instances, will be their mutable counterparts in the new\n      * <code>MutableSection</code>.</p>\n-     * \n+     *\n      * @param s The section set to copy\n      */\n     public MutableSection(final Section s)\n@@ -182,7 +182,7 @@ public void setProperty(final int id, final String value)\n      */\n     public void setProperty(final int id, final int value)\n     {\n-        setProperty(id, Variant.VT_I4, new Integer(value));\n+        setProperty(id, Variant.VT_I4, Integer.valueOf(value));\n         dirty = true;\n     }\n \n@@ -199,7 +199,7 @@ public void setProperty(final int id, final int value)\n      */\n     public void setProperty(final int id, final long value)\n     {\n-        setProperty(id, Variant.VT_I8, new Long(value));\n+        setProperty(id, Variant.VT_I8, Long.valueOf(value));\n         dirty = true;\n     }\n \n@@ -216,7 +216,7 @@ public void setProperty(final int id, final long value)\n      */\n     public void setProperty(final int id, final boolean value)\n     {\n-        setProperty(id, Variant.VT_BOOL, new Boolean(value));\n+        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));\n         dirty = true;\n     }\n \n@@ -300,7 +300,7 @@ public void removeProperty(final long id)\n      */\n     protected void setPropertyBooleanValue(final int id, final boolean value)\n     {\n-        setProperty(id, Variant.VT_BOOL, new Boolean(value));\n+        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));\n     }\n \n \n@@ -339,10 +339,10 @@ public int getSize()\n      * properties) and the properties themselves.</p>\n      *\n      * @return the section's length in bytes.\n-     * @throws WritingNotSupportedException \n-     * @throws IOException \n+     * @throws WritingNotSupportedException\n+     * @throws IOException\n      */\n-    private int calcSize() throws WritingNotSupportedException, IOException \n+    private int calcSize() throws WritingNotSupportedException, IOException\n     {\n         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n         write(out);\n@@ -357,7 +357,7 @@ private int calcSize() throws WritingNotSupportedException, IOException\n \n     /**\n      * <p>Writes this section into an output stream.</p>\n-     * \n+     *\n      * <p>Internally this is done by writing into three byte array output\n      * streams: one for the properties, one for the property list and one for\n      * the section as such. The two former are appended to the latter when they\n@@ -390,7 +390,7 @@ public int write(final OutputStream out)\n          * \"propertyListStream\". */\n         final ByteArrayOutputStream propertyListStream =\n             new ByteArrayOutputStream();\n- \n+\n         /* Maintain the current position in the list. */\n         int position = 0;\n \n@@ -418,7 +418,7 @@ public int write(final OutputStream out)\n                  * dictionary is present. In order to cope with this problem we\n                  * add the codepage property and set it to Unicode. */\n                 setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,\n-                            new Integer(Constants.CP_UNICODE));\n+                            Integer.valueOf(Constants.CP_UNICODE));\n             codepage = getCodepage();\n         }\n \n@@ -444,7 +444,7 @@ else if (p1.getID() == p2.getID())\n         {\n             final MutableProperty p = (MutableProperty) i.next();\n             final long id = p.getID();\n-            \n+\n             /* Write the property list entry. */\n             TypeWriter.writeUIntToStream(propertyListStream, p.getID());\n             TypeWriter.writeUIntToStream(propertyListStream, position);\n@@ -472,17 +472,17 @@ else if (p1.getID() == p2.getID())\n         /* Write the section: */\n         byte[] pb1 = propertyListStream.toByteArray();\n         byte[] pb2 = propertyStream.toByteArray();\n-        \n+\n         /* Write the section's length: */\n         TypeWriter.writeToStream(out, LittleEndian.INT_SIZE * 2 +\n                                       pb1.length + pb2.length);\n-        \n+\n         /* Write the section's number of properties: */\n         TypeWriter.writeToStream(out, getPropertyCount());\n-        \n+\n         /* Write the property list: */\n         out.write(pb1);\n-        \n+\n         /* Write the properties: */\n         out.write(pb2);\n \n@@ -562,7 +562,7 @@ private static int writeDictionary(final OutputStream out,\n      * <p>Overwrites the super class' method to cope with a redundancy:\n      * the property count is maintained in a separate member variable, but\n      * shouldn't.</p>\n-     * \n+     *\n      * @return The number of properties in this section\n      */\n     public int getPropertyCount()\n@@ -574,7 +574,7 @@ public int getPropertyCount()\n \n     /**\n      * <p>Gets this section's properties.</p>\n-     * \n+     *\n      * @return this section's properties.\n      */\n     public Property[] getProperties()\n@@ -587,7 +587,7 @@ public int getPropertyCount()\n \n     /**\n      * <p>Gets a property.</p>\n-     * \n+     *\n      * @param id The ID of the property to get\n      * @return The property or <code>null</code> if there is no such property\n      */\n@@ -611,10 +611,10 @@ public Object getProperty(final long id)\n      * method.</p>\n      *\n      * @param dictionary The dictionary\n-     * \n+     *\n      * @exception IllegalPropertySetDataException if the dictionary's key and\n      * value types are not correct.\n-     * \n+     *\n      * @see Section#getDictionary()\n      */\n     public void setDictionary(final Map dictionary)\n@@ -646,7 +646,7 @@ public void setDictionary(final Map dictionary)\n                 (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);\n             if (codepage == null)\n                 setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,\n-                            new Integer(Constants.CP_UNICODE));\n+                            Integer.valueOf(Constants.CP_UNICODE));\n         }\n         else\n             /* Setting the dictionary to null means to remove property 0.\n@@ -658,7 +658,7 @@ public void setDictionary(final Map dictionary)\n \n     /**\n      * <p>Sets a property.</p>\n-     * \n+     *\n      * @param id The property ID.\n      * @param value The property's value. The value's class must be one of those\n      *        supported by HPSF.\n@@ -707,7 +707,6 @@ public void clear()\n     public void setCodepage(final int codepage)\n     {\n         setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,\n-                new Integer(codepage));\n+                Integer.valueOf(codepage));\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/MutableSection.java",
                "sha": "0e521dc44d40973f5ff2a7225fdba74199e9318f",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/Property.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/Property.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hpsf/Property.java",
                "patch": "@@ -217,7 +217,7 @@ protected Map readDictionary(final byte[] src, final long offset,\n             for (int i = 0; i < nrEntries; i++)\n             {\n                 /* The key. */\n-                final Long id = new Long(LittleEndian.getUInt(src, o));\n+                final Long id = Long.valueOf(LittleEndian.getUInt(src, o));\n                 o += LittleEndian.INT_SIZE;\n \n                 /* The value (a string). The length is the either the",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/Property.java",
                "sha": "c06a807ef379634bf0f4f44f6f48d79c706c92fa",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/Section.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/Section.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hpsf/Section.java",
                "patch": "@@ -278,7 +278,7 @@ public Section(final byte[] src, final int offset)\n                     this.offset + ple.offset,\n                     ple.length, codepage);\n             if (p.getID() == PropertyIDMap.PID_CODEPAGE)\n-                p = new Property(p.getID(), p.getType(), new Integer(codepage));\n+                p = new Property(p.getID(), p.getType(), Integer.valueOf(codepage));\n             properties[i1++] = p;\n         }\n \n@@ -450,7 +450,7 @@ public String getPIDString(final long pid)\n     {\n         String s = null;\n         if (dictionary != null)\n-            s = (String) dictionary.get(new Long(pid));\n+            s = (String) dictionary.get(Long.valueOf(pid));\n         if (s == null)\n             s = SectionIDMap.getPIDString(getFormatID().getBytes(), pid);\n         if (s == null)",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/Section.java",
                "sha": "917929a64a20bcdec7956d4ea284282060251a9b",
                "status": "modified"
            },
            {
                "additions": 88,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/Variant.java",
                "changes": 176,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/Variant.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 88,
                "filename": "src/java/org/apache/poi/hpsf/Variant.java",
                "patch": "@@ -351,125 +351,125 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     /**\n      * <p>Denotes a variant type with a length that is unknown to HPSF yet.</p>\n      */\n-    public static final Integer LENGTH_UNKNOWN = new Integer(-2);\n+    public static final Integer LENGTH_UNKNOWN = Integer.valueOf(-2);\n \n     /**\n      * <p>Denotes a variant type with a variable length.</p>\n      */\n-    public static final Integer LENGTH_VARIABLE = new Integer(-1);\n+    public static final Integer LENGTH_VARIABLE = Integer.valueOf(-1);\n \n     /**\n      * <p>Denotes a variant type with a length of 0 bytes.</p>\n      */\n-    public static final Integer LENGTH_0 = new Integer(0);\n+    public static final Integer LENGTH_0 = Integer.valueOf(0);\n \n     /**\n      * <p>Denotes a variant type with a length of 2 bytes.</p>\n      */\n-    public static final Integer LENGTH_2 = new Integer(2);\n+    public static final Integer LENGTH_2 = Integer.valueOf(2);\n \n     /**\n      * <p>Denotes a variant type with a length of 4 bytes.</p>\n      */\n-    public static final Integer LENGTH_4 = new Integer(4);\n+    public static final Integer LENGTH_4 = Integer.valueOf(4);\n \n     /**\n      * <p>Denotes a variant type with a length of 8 bytes.</p>\n      */\n-    public static final Integer LENGTH_8 = new Integer(8);\n+    public static final Integer LENGTH_8 = Integer.valueOf(8);\n \n \n \n     static\n     {\n         /* Initialize the number-to-name map: */\n         Map tm1 = new HashMap();\n-        tm1.put(new Long(0), \"VT_EMPTY\");\n-        tm1.put(new Long(1), \"VT_NULL\");\n-        tm1.put(new Long(2), \"VT_I2\");\n-        tm1.put(new Long(3), \"VT_I4\");\n-        tm1.put(new Long(4), \"VT_R4\");\n-        tm1.put(new Long(5), \"VT_R8\");\n-        tm1.put(new Long(6), \"VT_CY\");\n-        tm1.put(new Long(7), \"VT_DATE\");\n-        tm1.put(new Long(8), \"VT_BSTR\");\n-        tm1.put(new Long(9), \"VT_DISPATCH\");\n-        tm1.put(new Long(10), \"VT_ERROR\");\n-        tm1.put(new Long(11), \"VT_BOOL\");\n-        tm1.put(new Long(12), \"VT_VARIANT\");\n-        tm1.put(new Long(13), \"VT_UNKNOWN\");\n-        tm1.put(new Long(14), \"VT_DECIMAL\");\n-        tm1.put(new Long(16), \"VT_I1\");\n-        tm1.put(new Long(17), \"VT_UI1\");\n-        tm1.put(new Long(18), \"VT_UI2\");\n-        tm1.put(new Long(19), \"VT_UI4\");\n-        tm1.put(new Long(20), \"VT_I8\");\n-        tm1.put(new Long(21), \"VT_UI8\");\n-        tm1.put(new Long(22), \"VT_INT\");\n-        tm1.put(new Long(23), \"VT_UINT\");\n-        tm1.put(new Long(24), \"VT_VOID\");\n-        tm1.put(new Long(25), \"VT_HRESULT\");\n-        tm1.put(new Long(26), \"VT_PTR\");\n-        tm1.put(new Long(27), \"VT_SAFEARRAY\");\n-        tm1.put(new Long(28), \"VT_CARRAY\");\n-        tm1.put(new Long(29), \"VT_USERDEFINED\");\n-        tm1.put(new Long(30), \"VT_LPSTR\");\n-        tm1.put(new Long(31), \"VT_LPWSTR\");\n-        tm1.put(new Long(64), \"VT_FILETIME\");\n-        tm1.put(new Long(65), \"VT_BLOB\");\n-        tm1.put(new Long(66), \"VT_STREAM\");\n-        tm1.put(new Long(67), \"VT_STORAGE\");\n-        tm1.put(new Long(68), \"VT_STREAMED_OBJECT\");\n-        tm1.put(new Long(69), \"VT_STORED_OBJECT\");\n-        tm1.put(new Long(70), \"VT_BLOB_OBJECT\");\n-        tm1.put(new Long(71), \"VT_CF\");\n-        tm1.put(new Long(72), \"VT_CLSID\");\n+        tm1.put(Long.valueOf(0), \"VT_EMPTY\");\n+        tm1.put(Long.valueOf(1), \"VT_NULL\");\n+        tm1.put(Long.valueOf(2), \"VT_I2\");\n+        tm1.put(Long.valueOf(3), \"VT_I4\");\n+        tm1.put(Long.valueOf(4), \"VT_R4\");\n+        tm1.put(Long.valueOf(5), \"VT_R8\");\n+        tm1.put(Long.valueOf(6), \"VT_CY\");\n+        tm1.put(Long.valueOf(7), \"VT_DATE\");\n+        tm1.put(Long.valueOf(8), \"VT_BSTR\");\n+        tm1.put(Long.valueOf(9), \"VT_DISPATCH\");\n+        tm1.put(Long.valueOf(10), \"VT_ERROR\");\n+        tm1.put(Long.valueOf(11), \"VT_BOOL\");\n+        tm1.put(Long.valueOf(12), \"VT_VARIANT\");\n+        tm1.put(Long.valueOf(13), \"VT_UNKNOWN\");\n+        tm1.put(Long.valueOf(14), \"VT_DECIMAL\");\n+        tm1.put(Long.valueOf(16), \"VT_I1\");\n+        tm1.put(Long.valueOf(17), \"VT_UI1\");\n+        tm1.put(Long.valueOf(18), \"VT_UI2\");\n+        tm1.put(Long.valueOf(19), \"VT_UI4\");\n+        tm1.put(Long.valueOf(20), \"VT_I8\");\n+        tm1.put(Long.valueOf(21), \"VT_UI8\");\n+        tm1.put(Long.valueOf(22), \"VT_INT\");\n+        tm1.put(Long.valueOf(23), \"VT_UINT\");\n+        tm1.put(Long.valueOf(24), \"VT_VOID\");\n+        tm1.put(Long.valueOf(25), \"VT_HRESULT\");\n+        tm1.put(Long.valueOf(26), \"VT_PTR\");\n+        tm1.put(Long.valueOf(27), \"VT_SAFEARRAY\");\n+        tm1.put(Long.valueOf(28), \"VT_CARRAY\");\n+        tm1.put(Long.valueOf(29), \"VT_USERDEFINED\");\n+        tm1.put(Long.valueOf(30), \"VT_LPSTR\");\n+        tm1.put(Long.valueOf(31), \"VT_LPWSTR\");\n+        tm1.put(Long.valueOf(64), \"VT_FILETIME\");\n+        tm1.put(Long.valueOf(65), \"VT_BLOB\");\n+        tm1.put(Long.valueOf(66), \"VT_STREAM\");\n+        tm1.put(Long.valueOf(67), \"VT_STORAGE\");\n+        tm1.put(Long.valueOf(68), \"VT_STREAMED_OBJECT\");\n+        tm1.put(Long.valueOf(69), \"VT_STORED_OBJECT\");\n+        tm1.put(Long.valueOf(70), \"VT_BLOB_OBJECT\");\n+        tm1.put(Long.valueOf(71), \"VT_CF\");\n+        tm1.put(Long.valueOf(72), \"VT_CLSID\");\n         Map tm2 = new HashMap(tm1.size(), 1.0F);\n         tm2.putAll(tm1);\n         numberToName = Collections.unmodifiableMap(tm2);\n \n         /* Initialize the number-to-length map: */\n         tm1.clear();\n-        tm1.put(new Long(0), LENGTH_0);\n-        tm1.put(new Long(1), LENGTH_UNKNOWN);\n-        tm1.put(new Long(2), LENGTH_2);\n-        tm1.put(new Long(3), LENGTH_4);\n-        tm1.put(new Long(4), LENGTH_4);\n-        tm1.put(new Long(5), LENGTH_8);\n-        tm1.put(new Long(6), LENGTH_UNKNOWN);\n-        tm1.put(new Long(7), LENGTH_UNKNOWN);\n-        tm1.put(new Long(8), LENGTH_UNKNOWN);\n-        tm1.put(new Long(9), LENGTH_UNKNOWN);\n-        tm1.put(new Long(10), LENGTH_UNKNOWN);\n-        tm1.put(new Long(11), LENGTH_UNKNOWN);\n-        tm1.put(new Long(12), LENGTH_UNKNOWN);\n-        tm1.put(new Long(13), LENGTH_UNKNOWN);\n-        tm1.put(new Long(14), LENGTH_UNKNOWN);\n-        tm1.put(new Long(16), LENGTH_UNKNOWN);\n-        tm1.put(new Long(17), LENGTH_UNKNOWN);\n-        tm1.put(new Long(18), LENGTH_UNKNOWN);\n-        tm1.put(new Long(19), LENGTH_UNKNOWN);\n-        tm1.put(new Long(20), LENGTH_UNKNOWN);\n-        tm1.put(new Long(21), LENGTH_UNKNOWN);\n-        tm1.put(new Long(22), LENGTH_UNKNOWN);\n-        tm1.put(new Long(23), LENGTH_UNKNOWN);\n-        tm1.put(new Long(24), LENGTH_UNKNOWN);\n-        tm1.put(new Long(25), LENGTH_UNKNOWN);\n-        tm1.put(new Long(26), LENGTH_UNKNOWN);\n-        tm1.put(new Long(27), LENGTH_UNKNOWN);\n-        tm1.put(new Long(28), LENGTH_UNKNOWN);\n-        tm1.put(new Long(29), LENGTH_UNKNOWN);\n-        tm1.put(new Long(30), LENGTH_VARIABLE);\n-        tm1.put(new Long(31), LENGTH_UNKNOWN);\n-        tm1.put(new Long(64), LENGTH_8);\n-        tm1.put(new Long(65), LENGTH_UNKNOWN);\n-        tm1.put(new Long(66), LENGTH_UNKNOWN);\n-        tm1.put(new Long(67), LENGTH_UNKNOWN);\n-        tm1.put(new Long(68), LENGTH_UNKNOWN);\n-        tm1.put(new Long(69), LENGTH_UNKNOWN);\n-        tm1.put(new Long(70), LENGTH_UNKNOWN);\n-        tm1.put(new Long(71), LENGTH_UNKNOWN);\n-        tm1.put(new Long(72), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(0), LENGTH_0);\n+        tm1.put(Long.valueOf(1), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(2), LENGTH_2);\n+        tm1.put(Long.valueOf(3), LENGTH_4);\n+        tm1.put(Long.valueOf(4), LENGTH_4);\n+        tm1.put(Long.valueOf(5), LENGTH_8);\n+        tm1.put(Long.valueOf(6), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(7), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(8), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(9), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(10), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(11), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(12), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(13), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(14), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(16), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(17), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(18), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(19), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(20), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(21), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(22), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(23), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(24), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(25), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(26), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(27), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(28), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(29), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(30), LENGTH_VARIABLE);\n+        tm1.put(Long.valueOf(31), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(64), LENGTH_8);\n+        tm1.put(Long.valueOf(65), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(66), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(67), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(68), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(69), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(70), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(71), LENGTH_UNKNOWN);\n+        tm1.put(Long.valueOf(72), LENGTH_UNKNOWN);\n         tm2 = new HashMap(tm1.size(), 1.0F);\n         tm2.putAll(tm1);\n         numberToLength = Collections.unmodifiableMap(tm2);\n@@ -486,7 +486,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      */\n     public static String getVariantName(final long variantType)\n     {\n-        final String name = (String) numberToName.get(new Long(variantType));\n+        final String name = (String) numberToName.get(Long.valueOf(variantType));\n         return name != null ? name : \"unknown variant type\";\n     }\n \n@@ -501,7 +501,7 @@ public static String getVariantName(final long variantType)\n      */\n     public static int getVariantLength(final long variantType)\n     {\n-        final Long key = new Long((int) variantType);\n+        final Long key = Long.valueOf((int) variantType);\n         final Long length = (Long) numberToLength.get(key);\n         if (length == null)\n             return -2;",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/Variant.java",
                "sha": "a37cbf0479c8e150ec4cf1a8cf913d18bbe775bb",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/VariantSupport.java",
                "changes": 39,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/VariantSupport.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 20,
                "filename": "src/java/org/apache/poi/hpsf/VariantSupport.java",
                "patch": "@@ -29,10 +29,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n /**\n  * <p>Supports reading and writing of variant data.</p>\n- * \n+ *\n  * <p><strong>FIXME (3):</strong> Reading and writing should be made more\n  * uniform than it is now. The following items should be resolved:\n- * \n+ *\n  * <ul>\n  *\n  * <li><p>Reading requires a length parameter that is 4 byte greater than the\n@@ -68,7 +68,7 @@ public static void setLogUnsupportedTypes(final boolean logUnsupportedTypes)\n      * on or off.</p>\n      *\n      * @return <code>true</code> if logging is turned on, else\n-     * <code>false</code>. \n+     * <code>false</code>.\n      */\n     public static boolean isLogUnsupportedTypes()\n     {\n@@ -97,7 +97,7 @@ public static boolean isLogUnsupportedTypes()\n         {\n             if (unsupportedMessage == null)\n                 unsupportedMessage = new LinkedList();\n-            Long vt = new Long(ex.getVariantType());\n+            Long vt = Long.valueOf(ex.getVariantType());\n             if (!unsupportedMessage.contains(vt))\n             {\n                 System.err.println(ex.getMessage());\n@@ -121,7 +121,7 @@ public static boolean isLogUnsupportedTypes()\n      * <p>Checks whether HPSF supports the specified variant type. Unsupported\n      * types should be implemented included in the {@link #SUPPORTED_TYPES}\n      * array.</p>\n-     * \n+     *\n      * @see Variant\n      * @param variantType the variant type to check\n      * @return <code>true</code> if HPFS supports this type, else\n@@ -139,7 +139,7 @@ public boolean isSupportedType(final int variantType)\n \n     /**\n      * <p>Reads a variant type from a byte array.</p>\n-     * \n+     *\n      * @param src The byte array\n      * @param offset The offset in the byte array where the variant starts\n      * @param length The length of the variant including the variant type field\n@@ -182,7 +182,7 @@ public static Object read(final byte[] src, final int offset,\n                  * Read a short. In Java it is represented as an\n                  * Integer object.\n                  */\n-                value = new Integer(LittleEndian.getShort(src, o1));\n+                value = Integer.valueOf(LittleEndian.getShort(src, o1));\n                 break;\n             }\n             case Variant.VT_I4:\n@@ -191,7 +191,7 @@ public static Object read(final byte[] src, final int offset,\n                  * Read a word. In Java it is represented as an\n                  * Integer object.\n                  */\n-                value = new Integer(LittleEndian.getInt(src, o1));\n+                value = Integer.valueOf(LittleEndian.getInt(src, o1));\n                 break;\n             }\n             case Variant.VT_I8:\n@@ -200,7 +200,7 @@ public static Object read(final byte[] src, final int offset,\n                  * Read a double word. In Java it is represented as a\n                  * Long object.\n                  */\n-                value = new Long(LittleEndian.getLong(src, o1));\n+                value = Long.valueOf(LittleEndian.getLong(src, o1));\n                 break;\n             }\n             case Variant.VT_R8:\n@@ -279,7 +279,7 @@ public static Object read(final byte[] src, final int offset,\n                      *  while the current implementation calculates it in the Section constructor.\n                      *  Test files in Bugzilla 42726 and 45583 clearly show that this approach does not always work.\n                      *  The workaround below attempts to gracefully handle such cases instead of throwing exceptions.\n-                     * \n+                     *\n                      *  August 20, 2009\n                      */\n                     l1 = LittleEndian.getInt(src, o1); o1 += LittleEndian.INT_SIZE;\n@@ -318,16 +318,16 @@ public static Object read(final byte[] src, final int offset,\n \n \n     /**\n-     * <p>Turns a codepage number into the equivalent character encoding's \n+     * <p>Turns a codepage number into the equivalent character encoding's\n      * name.</p>\n      *\n      * @param codepage The codepage number\n-     * \n-     * @return The character encoding's name. If the codepage number is 65001, \n+     *\n+     * @return The character encoding's name. If the codepage number is 65001,\n      * the encoding name is \"UTF-8\". All other positive numbers are mapped to\n-     * \"cp\" followed by the number, e.g. if the codepage number is 1252 the \n+     * \"cp\" followed by the number, e.g. if the codepage number is 1252 the\n      * returned character encoding name will be \"cp1252\".\n-     * \n+     *\n      * @exception UnsupportedEncodingException if the specified codepage is\n      * less than zero.\n      */\n@@ -500,7 +500,7 @@ public static int write(final OutputStream out, final long type,\n             }\n             case Variant.VT_LPWSTR:\n             {\n-                final int nrOfChars = ((String) value).length() + 1; \n+                final int nrOfChars = ((String) value).length() + 1;\n                 length += TypeWriter.writeUIntToStream(out, nrOfChars);\n                 char[] s = Util.pad4((String) value);\n                 for (int i = 0; i < s.length; i++)\n@@ -546,7 +546,7 @@ public static int write(final OutputStream out, final long type,\n                             + value.getClass().toString() + \", \"\n                             + value.toString());\n                 }\n-                length += TypeWriter.writeToStream(out, \n+                length += TypeWriter.writeToStream(out,\n                           ((Integer) value).intValue());\n                 break;\n             }\n@@ -558,7 +558,7 @@ public static int write(final OutputStream out, final long type,\n             }\n             case Variant.VT_R8:\n             {\n-                length += TypeWriter.writeToStream(out, \n+                length += TypeWriter.writeToStream(out,\n                           ((Double) value).doubleValue());\n                 break;\n             }\n@@ -579,7 +579,7 @@ public static int write(final OutputStream out, final long type,\n                  * is a byte array we can write it nevertheless. */\n                 if (value instanceof byte[])\n                 {\n-                    final byte[] b = (byte[]) value; \n+                    final byte[] b = (byte[]) value;\n                     out.write(b);\n                     length = b.length;\n                     writeUnsupportedTypeMessage\n@@ -593,5 +593,4 @@ public static int write(final OutputStream out, final long type,\n \n         return length;\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/VariantSupport.java",
                "sha": "c01b3c57c54a988027c5c1d35179d12eefd478e5",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/wellknown/PropertyIDMap.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/wellknown/PropertyIDMap.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 23,
                "filename": "src/java/org/apache/poi/hpsf/wellknown/PropertyIDMap.java",
                "patch": "@@ -102,7 +102,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     /** <p>ID of the property that denotes whether read/write access to the\n      * document is allowed or whether is should be opened as read-only. It can\n      * have the following values:</p>\n-     * \n+     *\n      * <table>\n      *  <tbody>\n      *   <tr>\n@@ -133,7 +133,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * section of the Document Summary Information property set.\n      */\n \n-    /** \n+    /**\n      * <p>The entry is a dictionary.</p>\n      */\n     public static final int PID_DICTIONARY = 0;\n@@ -143,61 +143,61 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      */\n     public static final int PID_CODEPAGE = 1;\n \n-    /** \n+    /**\n      * <p>The entry is a string denoting the category the file belongs\n      * to, e.g. review, memo, etc. This is useful to find documents of\n      * same type.</p>\n      */\n     public static final int PID_CATEGORY = 2;\n \n-    /** \n+    /**\n      * <p>Target format for power point presentation, e.g. 35mm,\n      * printer, video etc.</p>\n      */\n     public static final int PID_PRESFORMAT = 3;\n \n-    /** \n+    /**\n      * <p>Number of bytes.</p>\n      */\n     public static final int PID_BYTECOUNT = 4;\n \n-    /** \n+    /**\n      * <p>Number of lines.</p>\n      */\n     public static final int PID_LINECOUNT = 5;\n \n-    /** \n+    /**\n      * <p>Number of paragraphs.</p>\n      */\n     public static final int PID_PARCOUNT = 6;\n \n-    /** \n+    /**\n      * <p>Number of slides in a power point presentation.</p>\n      */\n     public static final int PID_SLIDECOUNT = 7;\n \n-    /** \n+    /**\n      * <p>Number of slides with notes.</p>\n      */\n     public static final int PID_NOTECOUNT = 8;\n \n-    /** \n+    /**\n      * <p>Number of hidden slides.</p>\n      */\n     public static final int PID_HIDDENCOUNT = 9;\n \n-    /** \n+    /**\n      * <p>Number of multimedia clips, e.g. sound or video.</p>\n      */\n     public static final int PID_MMCLIPCOUNT = 10;\n \n-    /** \n+    /**\n      * <p>This entry is set to -1 when scaling of the thumbnail is\n      * desired. Otherwise the thumbnail should be cropped.</p>\n      */\n     public static final int PID_SCALE = 11;\n \n-    /** \n+    /**\n      * <p>This entry denotes an internally used property. It is a\n      * vector of variants consisting of pairs of a string (VT_LPSTR)\n      * and a number (VT_I4). The string is a heading name, and the\n@@ -206,29 +206,29 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      */\n     public static final int PID_HEADINGPAIR = 12;\n \n-    /** \n+    /**\n      * <p>This entry contains the names of document parts (word: names\n      * of the documents in the master document, excel: sheet names,\n      * power point: slide titles, binder: document names).</p>\n      */\n     public static final int PID_DOCPARTS = 13;\n \n-    /** \n+    /**\n      * <p>This entry contains the name of the project manager.</p>\n      */\n     public static final int PID_MANAGER = 14;\n \n-    /** \n+    /**\n      * <p>This entry contains the company name.</p>\n      */\n     public static final int PID_COMPANY = 15;\n \n-    /** \n+    /**\n      * <p>If this entry is -1 the links are dirty and should be\n      * re-evaluated.</p>\n      */\n     public static final int PID_LINKSDIRTY = 16;\n-    \n+\n     /**\n      * <p>The highest well-known property ID. Applications are free to use higher values for custom purposes.</p>\n      */\n@@ -254,7 +254,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n     /**\n      * <p>Creates a {@link PropertyIDMap}.</p>\n-     * \n+     *\n      * @param initialCapacity The initial capacity as defined for\n      * {@link HashMap}\n      * @param loadFactor The load factor as defined for {@link HashMap}\n@@ -268,7 +268,7 @@ public PropertyIDMap(final int initialCapacity, final float loadFactor)\n \n     /**\n      * <p>Creates a {@link PropertyIDMap} backed by another map.</p>\n-     * \n+     *\n      * @param map The instance to be created is backed by this map.\n      */\n     public PropertyIDMap(final Map map)\n@@ -291,7 +291,7 @@ public PropertyIDMap(final Map map)\n      */\n     public Object put(final long id, final String idString)\n     {\n-        return put(new Long(id), idString);\n+        return put(Long.valueOf(id), idString);\n     }\n \n \n@@ -305,7 +305,7 @@ public Object put(final long id, final String idString)\n      */\n     public Object get(final long id)\n     {\n-        return get(new Long(id));\n+        return get(Long.valueOf(id));\n     }\n \n \n@@ -392,5 +392,4 @@ public static void main(final String[] args)\n         System.out.println(\"s1: \" + s1);\n         System.out.println(\"s2: \" + s2);\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hpsf/wellknown/PropertyIDMap.java",
                "sha": "4eef8c4b02ad74d093dd4ead8ebdfeeff0af10d0",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/eventusermodel/FormatTrackingHSSFListener.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/eventusermodel/FormatTrackingHSSFListener.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/eventusermodel/FormatTrackingHSSFListener.java",
                "patch": "@@ -73,7 +73,7 @@ public void processRecord(Record record) {\n \tpublic void processRecordInternally(Record record) {\n \t\tif (record instanceof FormatRecord) {\n \t\t\tFormatRecord fr = (FormatRecord) record;\n-\t\t\t_customFormatRecords.put(new Integer(fr.getIndexCode()), fr);\n+\t\t\t_customFormatRecords.put(Integer.valueOf(fr.getIndexCode()), fr);\n \t\t}\n \t\tif (record instanceof ExtendedFormatRecord) {\n \t\t\tExtendedFormatRecord xr = (ExtendedFormatRecord) record;\n@@ -117,7 +117,7 @@ public String formatNumberDateCell(CellValueRecordInterface cell) {\n \tpublic String getFormatString(int formatIndex) {\n \t\tString format = null;\n \t\tif (formatIndex >= HSSFDataFormat.getNumberOfBuiltinBuiltinFormats()) {\n-\t\t\tFormatRecord tfr = _customFormatRecords.get(new Integer(formatIndex));\n+\t\t\tFormatRecord tfr = _customFormatRecords.get(Integer.valueOf(formatIndex));\n \t\t\tif (tfr == null) {\n \t\t\t\tSystem.err.println(\"Requested format at index \" + formatIndex\n \t\t\t\t\t\t+ \", but it wasn't found\");",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/eventusermodel/FormatTrackingHSSFListener.java",
                "sha": "5e21bdf58e0b808bffec856c235d92744413cef0",
                "status": "modified"
            },
            {
                "additions": 64,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/eventusermodel/HSSFRequest.java",
                "changes": 152,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/eventusermodel/HSSFRequest.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 88,
                "filename": "src/java/org/apache/poi/hssf/eventusermodel/HSSFRequest.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -16,12 +15,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    limitations under the License.\n ==================================================================== */\n \n-\n package org.apache.poi.hssf.eventusermodel;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.ArrayList;\n+import java.util.Map;\n \n import org.apache.poi.hssf.record.Record;\n import org.apache.poi.hssf.record.RecordFactory;\n@@ -37,71 +36,54 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author  Andrew C. Oliver (acoliver at apache dot org)\n  * @author Carey Sublette (careysub@earthling.net)\n  */\n+public class HSSFRequest {\n+\tprivate final Map<Short, List<HSSFListener>> _records;\n \n-public class HSSFRequest\n-{\n-    private HashMap records;\n-\n-    /** Creates a new instance of HSSFRequest */\n-\n-    public HSSFRequest()\n-    {\n-        records =\n-            new HashMap(50);   // most folks won't listen for too many of these\n-    }\n-\n-    /**\n-     * add an event listener for a particular record type.  The trick is you have to know\n-     * what the records are for or just start with our examples and build on them.  Alternatively,\n-     * you CAN call addListenerForAllRecords and you'll recieve ALL record events in one listener,\n-     * but if you like to squeeze every last byte of efficiency out of life you my not like this.\n-     * (its sure as heck what I plan to do)\n-     *\n-     * @see #addListenerForAllRecords(HSSFListener)\n-     *\n-     * @param lsnr      for the event\n-     * @param sid       identifier for the record type this is the .sid static member on the individual records\n-     *        for example req.addListener(myListener, BOFRecord.sid)\n-     */\n+\t/** Creates a new instance of HSSFRequest */\n+\tpublic HSSFRequest() {\n+\t\t_records = new HashMap<Short, List<HSSFListener>>(50); // most folks won't listen for too many of these\n+\t}\n \n-    public void addListener(HSSFListener lsnr, short sid)\n-    {\n-        List   list = null;\n-        Object obj  = records.get(new Short(sid));\n-\n-        if (obj != null)\n-        {\n-            list = ( List ) obj;\n-        }\n-        else\n-        {\n-            list = new ArrayList(\n-                1);   // probably most people will use one listener\n-            list.add(lsnr);\n-            records.put(new Short(sid), list);\n-        }\n-    }\n+\t/**\n+\t * add an event listener for a particular record type.  The trick is you have to know\n+\t * what the records are for or just start with our examples and build on them.  Alternatively,\n+\t * you CAN call addListenerForAllRecords and you'll receive ALL record events in one listener,\n+\t * but if you like to squeeze every last byte of efficiency out of life you my not like this.\n+\t * (its sure as heck what I plan to do)\n+\t *\n+\t * @see #addListenerForAllRecords(HSSFListener)\n+\t *\n+\t * @param lsnr for the event\n+\t * @param sid identifier for the record type this is the .sid static member on the individual records\n+\t *        for example req.addListener(myListener, BOFRecord.sid)\n+\t */\n+\tpublic void addListener(HSSFListener lsnr, short sid) {\n+\t\tList<HSSFListener> list = _records.get(Short.valueOf(sid));\n \n-    /**\n-     * This is the equivilent of calling addListener(myListener, sid) for EVERY\n-     * record in the org.apache.poi.hssf.record package. This is for lazy\n-     * people like me. You can call this more than once with more than one listener, but\n-     * that seems like a bad thing to do from a practice-perspective unless you have a\n-     * compelling reason to do so (like maybe you send the event two places or log it or\n-     * something?).\n-     *\n-     * @param lsnr      a single listener to associate with ALL records\n-     */\n+\t\tif (list == null) {\n+\t\t\tlist = new ArrayList<HSSFListener>(1); // probably most people will use one listener\n+\t\t\t_records.put(Short.valueOf(sid), list);\n+\t\t}\n+\t\tlist.add(lsnr);\n+\t}\n \n-    public void addListenerForAllRecords(HSSFListener lsnr)\n-    {\n-        short[] rectypes = RecordFactory.getAllKnownRecordSIDs();\n+\t/**\n+\t * This is the equivalent of calling addListener(myListener, sid) for EVERY\n+\t * record in the org.apache.poi.hssf.record package. This is for lazy\n+\t * people like me. You can call this more than once with more than one listener, but\n+\t * that seems like a bad thing to do from a practice-perspective unless you have a\n+\t * compelling reason to do so (like maybe you send the event two places or log it or\n+\t * something?).\n+\t *\n+\t * @param lsnr a single listener to associate with ALL records\n+\t */\n+\tpublic void addListenerForAllRecords(HSSFListener lsnr) {\n+\t\tshort[] rectypes = RecordFactory.getAllKnownRecordSIDs();\n \n-        for (int k = 0; k < rectypes.length; k++)\n-        {\n-            addListener(lsnr, rectypes[ k ]);\n-        }\n-    }\n+\t\tfor (int k = 0; k < rectypes.length; k++) {\n+\t\t\taddListener(lsnr, rectypes[k]);\n+\t\t}\n+\t}\n \n \t/**\n \t * Called by HSSFEventFactory, passes the Record to each listener associated with\n@@ -112,32 +94,26 @@ public void addListenerForAllRecords(HSSFListener lsnr)\n \t * @return numeric user-specified result code. If zero continue processing.\n \t * @throws HSSFUserException User exception condition\n \t */\n-\n-    protected short processRecord(Record rec) throws HSSFUserException\n-    {\n-        Object obj = records.get(new Short(rec.getSid()));\n-        short userCode = 0;\n-\n-        if (obj != null)\n-        {\n-            List listeners = ( List ) obj;\n-\n-            for (int k = 0; k < listeners.size(); k++)\n-            {\n-                Object listenObj = listeners.get(k);\n-                if (listenObj instanceof AbortableHSSFListener)\n-                {\n-\t\t\t\t\tAbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj;\n-                \tuserCode = listener.abortableProcessRecord(rec);\n-                \tif (userCode!=0) break;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{ \n-\t\t\t\t\tHSSFListener listener = ( HSSFListener ) listenObj;\n+\tprotected short processRecord(Record rec) throws HSSFUserException {\n+\t\tObject obj = _records.get(Short.valueOf(rec.getSid()));\n+\t\tshort userCode = 0;\n+\n+\t\tif (obj != null) {\n+\t\t\tList listeners = (List) obj;\n+\n+\t\t\tfor (int k = 0; k < listeners.size(); k++) {\n+\t\t\t\tObject listenObj = listeners.get(k);\n+\t\t\t\tif (listenObj instanceof AbortableHSSFListener) {\n+\t\t\t\t\tAbortableHSSFListener listener = (AbortableHSSFListener) listenObj;\n+\t\t\t\t\tuserCode = listener.abortableProcessRecord(rec);\n+\t\t\t\t\tif (userCode != 0)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tHSSFListener listener = (HSSFListener) listenObj;\n \t\t\t\t\tlistener.processRecord(rec);\n \t\t\t\t}\n-            }\n-        }\n-        return userCode;\n-    }\n+\t\t\t}\n+\t\t}\n+\t\treturn userCode;\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/eventusermodel/HSSFRequest.java",
                "sha": "af23a2c495f4976938fc01d10b72ea19f0f68245",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/model/DrawingManager.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/DrawingManager.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/model/DrawingManager.java",
                "patch": "@@ -48,7 +48,7 @@ public EscherDgRecord createDgRecord()\n         dg.setLastMSOSPID( -1 );\n         dgg.addCluster( dgId, 0 );\n         dgg.setDrawingsSaved( dgg.getDrawingsSaved() + 1 );\n-        dgMap.put( new Short( dgId ), dg );\n+        dgMap.put( Short.valueOf( dgId ), dg );\n         return dg;\n     }\n \n@@ -60,7 +60,7 @@ public EscherDgRecord createDgRecord()\n     public int allocateShapeId(short drawingGroupId)\n     {\n         // Get the last shape id for this drawing group.\n-        EscherDgRecord dg = (EscherDgRecord) dgMap.get(new Short(drawingGroupId));\n+        EscherDgRecord dg = (EscherDgRecord) dgMap.get(Short.valueOf(drawingGroupId));\n         int lastShapeId = dg.getLastMSOSPID();\n \n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/model/DrawingManager.java",
                "sha": "8229b40a5b57eec512b4a02b4cd1dcf13e1152aa",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/model/Sheet.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/Sheet.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/model/Sheet.java",
                "patch": "@@ -1031,7 +1031,7 @@ public short getXFIndexForColAt(short columnIndex) {\n     public void setColumnWidth(int column, int width) {\n         if(width > 255*256) throw new IllegalArgumentException(\"The maximum column width for an individual cell is 255 characters.\");\n \n-        setColumn(column, null, new Integer(width), null, null, null);\n+        setColumn(column, null, Integer.valueOf(width), null, null, null);\n     }\n \n     /**\n@@ -1059,7 +1059,7 @@ public void setColumnHidden(int column, boolean hidden) {\n         setColumn( column, null, null, null, Boolean.valueOf(hidden), null);\n     }\n     public void setDefaultColumnStyle(int column, int styleIndex) {\n-        setColumn(column, new Short((short)styleIndex), null, null, null, null);\n+        setColumn(column, Short.valueOf((short)styleIndex), null, null, null, null);\n     }\n \n     private void setColumn(int column, Short xfStyle, Integer width, Integer level, Boolean hidden, Boolean collapsed) {",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/model/Sheet.java",
                "sha": "df8d616d898d2d972e79ce508371c6788bf0e328",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/model/Workbook.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/Workbook.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 6,
                "filename": "src/java/org/apache/poi/hssf/model/Workbook.java",
                "patch": "@@ -180,7 +180,7 @@ public Workbook() {\n     public static Workbook createWorkbook(List<Record> recs) {\n         if (log.check( POILogger.DEBUG ))\n             log.log(DEBUG, \"Workbook (readfile) created with reclen=\",\n-                    new Integer(recs.size()));\n+                    Integer.valueOf(recs.size()));\n         Workbook retval = new Workbook();\n         List<Record> records = new ArrayList<Record>(recs.size() / 3);\n         retval.records.setRecords(records);\n@@ -517,8 +517,8 @@ public int getNumberOfFontRecords() {\n \n     public void setSheetBof(int sheetIndex, int pos) {\n         if (log.check( POILogger.DEBUG ))\n-            log.log(DEBUG, \"setting bof for sheetnum =\", new Integer(sheetIndex),\n-                \" at pos=\", new Integer(pos));\n+            log.log(DEBUG, \"setting bof for sheetnum =\", Integer.valueOf(sheetIndex),\n+                \" at pos=\", Integer.valueOf(pos));\n         checkSheets(sheetIndex);\n         getBoundSheetRec(sheetIndex)\n         .setPositionOfBof(pos);\n@@ -757,7 +757,7 @@ private void fixTabIdRecord() {\n \n     public int getNumSheets() {\n         if (log.check( POILogger.DEBUG ))\n-            log.log(DEBUG, \"getNumSheets=\", new Integer(boundsheets.size()));\n+            log.log(DEBUG, \"getNumSheets=\", Integer.valueOf(boundsheets.size()));\n         return boundsheets.size();\n     }\n \n@@ -769,7 +769,7 @@ public int getNumSheets() {\n \n     public int getNumExFormats() {\n         if (log.check( POILogger.DEBUG ))\n-            log.log(DEBUG, \"getXF=\", new Integer(numxfs));\n+            log.log(DEBUG, \"getXF=\", Integer.valueOf(numxfs));\n         return numxfs;\n     }\n \n@@ -903,7 +903,7 @@ public UnicodeString getSSTString(int str) {\n         UnicodeString retval = sst.getString(str);\n \n         if (log.check( POILogger.DEBUG ))\n-            log.log(DEBUG, \"Returning SST for index=\", new Integer(str),\n+            log.log(DEBUG, \"Returning SST for index=\", Integer.valueOf(str),\n                 \" String= \", retval);\n         return retval;\n     }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/model/Workbook.java",
                "sha": "812f719e8dd8f8ceb2e55383f626195522896411",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/EmbeddedObjectRefSubRecord.java",
                "changes": 52,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/EmbeddedObjectRefSubRecord.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 26,
                "filename": "src/java/org/apache/poi/hssf/record/EmbeddedObjectRefSubRecord.java",
                "patch": "@@ -6,7 +6,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    (the \"License\"); you may not use this file except in compliance with\n    the License.  You may obtain a copy of the License at\n \n-       http://www.apache.org/licenses/LICENSE-2.0\n+\t   http://www.apache.org/licenses/LICENSE-2.0\n \n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -48,15 +48,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tprivate Ptg field_2_refPtg;\n \t/** for when the 'formula' doesn't parse properly */\n \tprivate byte[] field_2_unknownFormulaData;\n-\t/** note- this byte is not present in the encoding if the string length is zero */ \n+\t/** note- this byte is not present in the encoding if the string length is zero */\n \tprivate boolean field_3_unicode_flag;  // Flags whether the string is Unicode.\n \tprivate String  field_4_ole_classname; // Classname of the embedded OLE document (e.g. Word.Document.8)\n \t/** Formulas often have a single non-zero trailing byte.\n \t * This is in a similar position to he pre-streamId padding\n-\t * It is unknown if the value is important (it seems to mirror a value a few bytes earlier) \n+\t * It is unknown if the value is important (it seems to mirror a value a few bytes earlier)\n \t *  */\n \tprivate Byte  field_4_unknownByte;\n-\tprivate Integer field_5_stream_id;     // ID of the OLE stream containing the actual data.\n+\tprivate Integer field_5_stream_id;\t // ID of the OLE stream containing the actual data.\n \tprivate byte[] field_6_unknown;\n \n \n@@ -131,7 +131,7 @@ public EmbeddedObjectRefSubRecord(LittleEndianInput in, int size) {\n \t\t\tint b = in.readByte();\n \t\t\tremaining -= LittleEndian.BYTE_SIZE;\n \t\t\tif (field_2_refPtg != null && field_4_ole_classname == null) {\n-\t\t\t\tfield_4_unknownByte = new Byte((byte)b);\n+\t\t\t\tfield_4_unknownByte = Byte.valueOf((byte)b);\n \t\t\t}\n \t\t}\n \t\tint nUnexpectedPadding = remaining - dataLenAfterFormula;\n@@ -144,7 +144,7 @@ public EmbeddedObjectRefSubRecord(LittleEndianInput in, int size) {\n \n \t\t// Fetch the stream ID\n \t\tif (dataLenAfterFormula >= 4) {\n-\t\t\tfield_5_stream_id = new Integer(in.readInt());\n+\t\t\tfield_5_stream_id = Integer.valueOf(in.readInt());\n \t\t\tremaining -= LittleEndian.INT_SIZE;\n \t\t} else {\n \t\t\tfield_5_stream_id = null;\n@@ -158,7 +158,7 @@ private static Ptg readRefPtg(byte[] formulaRawBytes) {\n \t\tswitch(ptgSid) {\n \t\t\tcase AreaPtg.sid:   return new AreaPtg(in);\n \t\t\tcase Area3DPtg.sid: return new Area3DPtg(in);\n-\t\t\tcase RefPtg.sid:    return new RefPtg(in);\n+\t\t\tcase RefPtg.sid:\treturn new RefPtg(in);\n \t\t\tcase Ref3DPtg.sid:  return new Ref3DPtg(in);\n \t\t}\n \t\treturn null;\n@@ -175,11 +175,11 @@ private static Ptg readRefPtg(byte[] formulaRawBytes) {\n \t\tin.readFully(result);\n \t\treturn result;\n \t}\n-\t\n+\n \tprivate int getStreamIDOffset(int formulaSize) {\n \t\tint result = 2 + 4; // formulaSize + f2unknown_int\n \t\tresult += formulaSize;\n-\t\t\n+\n \t\tint stringLen;\n \t\tif (field_4_ole_classname == null) {\n \t\t\t// don't write 0x03, stringLen, flag, text\n@@ -198,16 +198,16 @@ private int getStreamIDOffset(int formulaSize) {\n \t\t}\n \t\t// pad to next 2 byte boundary\n \t\tif ((result % 2) != 0) {\n-\t\t\tresult ++; \n+\t\t\tresult ++;\n \t\t}\n \t\treturn result;\n \t}\n-\t\n+\n \tprivate int getDataSize(int idOffset) {\n \n \t\tint result = 2 + idOffset; // 2 for idOffset short field itself\n \t\tif (field_5_stream_id != null) {\n-    \t\tresult += 4;\n+\t\t\tresult += 4;\n \t\t}\n \t\treturn result +  field_6_unknown.length;\n \t}\n@@ -222,7 +222,7 @@ public void serialize(LittleEndianOutput out) {\n \t\tint formulaSize = field_2_refPtg == null ? field_2_unknownFormulaData.length : field_2_refPtg.getSize();\n \t\tint idOffset = getStreamIDOffset(formulaSize);\n \t\tint dataSize = getDataSize(idOffset);\n-\t\t\n+\n \n \t\tout.writeShort(sid);\n \t\tout.writeShort(dataSize);\n@@ -238,7 +238,7 @@ public void serialize(LittleEndianOutput out) {\n \t\t} else {\n \t\t\tfield_2_refPtg.write(out);\n \t\t}\n-\t   \tpos += formulaSize;\n+\t\tpos += formulaSize;\n \n \t\tint stringLen;\n \t\tif (field_4_ole_classname == null) {\n@@ -251,16 +251,16 @@ public void serialize(LittleEndianOutput out) {\n \t\t\tout.writeShort(stringLen);\n \t\t\tpos+=2;\n \t\t\tif (stringLen > 0) {\n-    \t\t\tout.writeByte(field_3_unicode_flag ? 0x01 : 0x00);\n-    \t\t\tpos+=1;\n-    \n-    \t\t\tif (field_3_unicode_flag) {\n-    \t\t\t\tStringUtil.putUnicodeLE(field_4_ole_classname, out);\n-    \t\t\t\tpos += stringLen * 2;\n-    \t\t\t} else {\n-    \t\t\t\tStringUtil.putCompressedUnicode(field_4_ole_classname, out);\n-    \t\t\t\tpos += stringLen;\n-    \t\t\t}\n+\t\t\t\tout.writeByte(field_3_unicode_flag ? 0x01 : 0x00);\n+\t\t\t\tpos+=1;\n+\n+\t\t\t\tif (field_3_unicode_flag) {\n+\t\t\t\t\tStringUtil.putUnicodeLE(field_4_ole_classname, out);\n+\t\t\t\t\tpos += stringLen * 2;\n+\t\t\t\t} else {\n+\t\t\t\t\tStringUtil.putCompressedUnicode(field_4_ole_classname, out);\n+\t\t\t\t\tpos += stringLen;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -272,12 +272,12 @@ public void serialize(LittleEndianOutput out) {\n \t\t\tcase 0:\n \t\t\t\tbreak;\n \t\t\tdefault:\n-\t\t\t\tthrow new IllegalStateException(\"Bad padding calculation (\" + idOffset + \", \" + pos + \")\");\t\n+\t\t\t\tthrow new IllegalStateException(\"Bad padding calculation (\" + idOffset + \", \" + pos + \")\");\n \t\t}\n \n \t\tif (field_5_stream_id != null) {\n \t\t\tout.writeInt(field_5_stream_id.intValue());\n-    \t\tpos += 4;\n+\t\t\tpos += 4;\n \t\t}\n \t\tout.write(field_6_unknown);\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/EmbeddedObjectRefSubRecord.java",
                "sha": "cebae812820b0e4ad30c13d0d2cf24484b09b31a",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/EscherAggregate.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/EscherAggregate.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/EscherAggregate.java",
                "patch": "@@ -434,7 +434,7 @@ public void afterRecordSerialize( int offset, short recordId, int size, EscherRe\n \t\t\t\t{\n \t\t\t\t\tif ( recordId == EscherClientDataRecord.RECORD_ID || recordId == EscherTextboxRecord.RECORD_ID )\n \t\t\t\t\t{\n-\t\t\t\t\t\tspEndingOffsets.add( new Integer( offset ) );\n+\t\t\t\t\t\tspEndingOffsets.add( Integer.valueOf( offset ) );\n \t\t\t\t\t\tshapes.add( record );\n \t\t\t\t\t}\n \t\t\t\t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/EscherAggregate.java",
                "sha": "811daa57388a5e67f6372a3dc74bf48fb242ae0a",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/NoteRecord.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/NoteRecord.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/hssf/record/NoteRecord.java",
                "patch": "@@ -40,7 +40,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t */\n \tpublic final static short NOTE_VISIBLE = 0x2;\n \n-\tprivate static final Byte DEFAULT_PADDING = new Byte((byte)0);\n+\tprivate static final Byte DEFAULT_PADDING = Byte.valueOf((byte)0);\n \n \tprivate int field_1_row;\n \tprivate int field_2_col;\n@@ -50,9 +50,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tprivate String field_6_author;\n \t/**\n \t * Saves padding byte value to reduce delta during round-trip serialization.<br/>\n-\t * \n+\t *\n \t * The documentation is not clear about how padding should work.  In any case\n-\t * Excel(2007) does something different. \n+\t * Excel(2007) does something different.\n \t */\n \tprivate Byte field_7_padding;\n \n@@ -89,7 +89,7 @@ public NoteRecord(RecordInputStream in) {\n \t\t\tfield_6_author = StringUtil.readCompressedUnicode(in, length);\n \t\t}\n  \t\tif (in.available() == 1) {\n-\t\t\tfield_7_padding = new Byte(in.readByte());\n+\t\t\tfield_7_padding = Byte.valueOf(in.readByte());\n \t\t}\n \t}\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/NoteRecord.java",
                "sha": "35f81ebfe787dc1d2a60960c7e11429c817de0e9",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/PageBreakRecord.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/PageBreakRecord.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/hssf/record/PageBreakRecord.java",
                "patch": "@@ -90,7 +90,7 @@ public PageBreakRecord(RecordInputStream in)\n         for(int k = 0; k < nBreaks; k++) {\n             Break br = new Break(in);\n             _breaks.add(br);\n-            _breakMap.put(new Integer(br.main), br);\n+            _breakMap.put(Integer.valueOf(br.main), br);\n         }\n \n     }\n@@ -160,7 +160,7 @@ public String toString() {\n     */\n     public void addBreak(int main, int subFrom, int subTo) {\n \n-        Integer key = new Integer(main);\n+        Integer key = Integer.valueOf(main);\n         Break region = _breakMap.get(key);\n         if(region == null) {\n             region = new Break(main, subFrom, subTo);\n@@ -178,7 +178,7 @@ public void addBreak(int main, int subFrom, int subTo) {\n      * @param main (zero-based)\n      */\n     public final void removeBreak(int main) {\n-        Integer rowKey = new Integer(main);\n+        Integer rowKey = Integer.valueOf(main);\n         Break region = _breakMap.get(rowKey);\n         _breaks.remove(region);\n         _breakMap.remove(rowKey);\n@@ -190,7 +190,7 @@ public final void removeBreak(int main) {\n      * @return The Break or null if no break exists at the row/col specified.\n      */\n     public final Break getBreak(int main) {\n-        Integer rowKey = new Integer(main);\n+        Integer rowKey = Integer.valueOf(main);\n         return _breakMap.get(rowKey);\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/PageBreakRecord.java",
                "sha": "fe182d05c083efa0d316e4ee2606f6f2b038c187",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/RecordFactory.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/RecordFactory.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/hssf/record/RecordFactory.java",
                "patch": "@@ -227,7 +227,7 @@ public Record create(RecordInputStream in) {\n \t * <code>null</code> if the specified record is not interpreted by POI.\n \t */\n \tpublic static Class<? extends Record> getRecordClass(int sid) {\n-\t\tI_RecordCreator rc = _recordCreatorsById.get(new Integer(sid));\n+\t\tI_RecordCreator rc = _recordCreatorsById.get(Integer.valueOf(sid));\n \t\tif (rc == null) {\n \t\t\treturn null;\n \t\t}\n@@ -254,7 +254,7 @@ public Record create(RecordInputStream in) {\n \t}\n \n \tpublic static Record createSingleRecord(RecordInputStream in) {\n-\t\tI_RecordCreator constructor = _recordCreatorsById.get(new Integer(in.getSid()));\n+\t\tI_RecordCreator constructor = _recordCreatorsById.get(Integer.valueOf(in.getSid()));\n \n \t\tif (constructor == null) {\n \t\t\treturn new UnknownRecord(in);\n@@ -346,15 +346,15 @@ public static NumberRecord convertToNumberRecord(RKRecord rk) {\n \t\t\t\tthrow new RecordFormatException(\n \t\t\t\t\t\"Unable to determine record types\");\n \t\t\t}\n-\t\t\tInteger key = new Integer(sid);\n+\t\t\tInteger key = Integer.valueOf(sid);\n \t\t\tif (result.containsKey(key)) {\n \t\t\t\tClass<?> prevClass = result.get(key).getRecordClass();\n \t\t\t\tthrow new RuntimeException(\"duplicate record sid 0x\" + Integer.toHexString(sid).toUpperCase()\n \t\t\t\t\t\t+ \" for classes (\" + recClass.getName() + \") and (\" + prevClass.getName() + \")\");\n \t\t\t}\n \t\t\tresult.put(key, new ReflectionRecordCreator(constructor));\n \t\t}\n-//\t\tresult.put(new Integer(0x0406), result.get(new Integer(0x06)));\n+//\t\tresult.put(Integer.valueOf(0x0406), result.get(Integer.valueOf(0x06)));\n \t\treturn result;\n \t}\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/RecordFactory.java",
                "sha": "3d200e7ef4ec945503a976a248cb8b68c30e7e07",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/SubRecord.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/SubRecord.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/SubRecord.java",
                "patch": "@@ -143,7 +143,7 @@ public LbsDataSubRecord(LittleEndianInput in, int unknownShort1) {\n \t\t\t\t_linkPtg = readRefPtg(buf);\n \t\t\t\tswitch (linkSize - formulaSize - 6) {\n \t\t\t\t\tcase 1:\n-\t\t\t\t\t\t_unknownByte6 = new Byte(in.readByte());\n+\t\t\t\t\t\t_unknownByte6 = Byte.valueOf(in.readByte());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase 0:\n \t\t\t\t\t\t_unknownByte6 = null;",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/SubRecord.java",
                "sha": "108a847dbde07234a0627c80c2aa8b33a68aff79",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/TextObjectRecord.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/TextObjectRecord.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 11,
                "filename": "src/java/org/apache/poi/hssf/record/TextObjectRecord.java",
                "patch": "@@ -30,7 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * followed by two or more continue records unless there is no actual text. The\n  * first continue records contain the text data and the last continue record\n  * contains the formatting runs.<p/>\n- * \n+ *\n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n public final class TextObjectRecord extends ContinuableRecord {\n@@ -68,15 +68,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t/*\n \t * Note - the next three fields are very similar to those on\n \t * EmbededObjectRefSubRecord(ftPictFmla 0x0009)\n-\t * \n+\t *\n \t * some observed values for the 4 bytes preceding the formula: C0 5E 86 03\n \t * C0 11 AC 02 80 F1 8A 03 D4 F0 8A 03\n \t */\n \tprivate int _unknownPreFormulaInt;\n \t/** expect tRef, tRef3D, tArea, tArea3D or tName */\n \tprivate Ptg _linkRefPtg;\n \t/**\n-\t * Not clear if needed .  Excel seems to be OK if this byte is not present. \n+\t * Not clear if needed .  Excel seems to be OK if this byte is not present.\n \t * Value is often the same as the earlier firstColumn byte. */\n \tprivate Byte _unknownPostFormulaByte;\n \n@@ -108,7 +108,7 @@ public TextObjectRecord(RecordInputStream in) {\n \t\t\t}\n \t\t\t_linkRefPtg = ptgs[0];\n \t\t\tif (in.remaining() > 0) {\n-\t\t\t\t_unknownPostFormulaByte = new Byte(in.readByte());\n+\t\t\t\t_unknownPostFormulaByte = Byte.valueOf(in.readByte());\n \t\t\t} else {\n \t\t\t\t_unknownPostFormulaByte = null;\n \t\t\t}\n@@ -161,7 +161,7 @@ public short getSid() {\n \t}\n \n \tprivate void serializeTXORecord(ContinuableRecordOutput out) {\n-\t\t\n+\n \t\tout.writeShort(field_1_options);\n \t\tout.writeShort(field_2_textOrientation);\n \t\tout.writeShort(field_3_reserved4);\n@@ -170,7 +170,7 @@ private void serializeTXORecord(ContinuableRecordOutput out) {\n \t\tout.writeShort(_text.length());\n \t\tout.writeShort(getFormattingDataLength());\n \t\tout.writeInt(field_8_reserved7);\n-\t\t\n+\n \t\tif (_linkRefPtg != null) {\n \t\t\tint formulaSize = _linkRefPtg.getSize();\n \t\t\tout.writeShort(formulaSize);\n@@ -194,12 +194,12 @@ protected void serialize(ContinuableRecordOutput out) {\n \t\tserializeTXORecord(out);\n \t\tif (_text.getString().length() > 0) {\n \t\t\tserializeTrailingRecords(out);\n-\t\t} \n+\t\t}\n \t}\n \n \tprivate int getFormattingDataLength() {\n \t\tif (_text.length() < 1) {\n-\t\t\t// important - no formatting data if text is empty \n+\t\t\t// important - no formatting data if text is empty\n \t\t\treturn 0;\n \t\t}\n \t\treturn (_text.numFormattingRuns() + 1) * FORMAT_RUN_ENCODED_SIZE;\n@@ -262,7 +262,7 @@ public boolean isTextLocked() {\n \n \t/**\n \t * Get the text orientation field for the TextObjectBase record.\n-\t * \n+\t *\n \t * @return One of TEXT_ORIENTATION_NONE TEXT_ORIENTATION_TOP_TO_BOTTOM\n \t *         TEXT_ORIENTATION_ROT_RIGHT TEXT_ORIENTATION_ROT_LEFT\n \t */\n@@ -272,7 +272,7 @@ public int getTextOrientation() {\n \n \t/**\n \t * Set the text orientation field for the TextObjectBase record.\n-\t * \n+\t *\n \t * @param textOrientation\n \t *            One of TEXT_ORIENTATION_NONE TEXT_ORIENTATION_TOP_TO_BOTTOM\n \t *            TEXT_ORIENTATION_ROT_RIGHT TEXT_ORIENTATION_ROT_LEFT\n@@ -288,7 +288,7 @@ public HSSFRichTextString getStr() {\n \tpublic void setStr(HSSFRichTextString str) {\n \t\t_text = str;\n \t}\n-\t\n+\n \tpublic Ptg getLinkRefPtg() {\n \t\treturn _linkRefPtg;\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/TextObjectRecord.java",
                "sha": "06fb3e431956fb3aa7feb2f46607c9600f3543a1",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/aggregates/ColumnInfoRecordsAggregate.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/aggregates/ColumnInfoRecordsAggregate.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 12,
                "filename": "src/java/org/apache/poi/hssf/record/aggregates/ColumnInfoRecordsAggregate.java",
                "patch": "@@ -30,11 +30,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public final class ColumnInfoRecordsAggregate extends RecordAggregate {\n \t/**\n-\t * List of {@link ColumnInfoRecord}s assumed to be in order \n+\t * List of {@link ColumnInfoRecord}s assumed to be in order\n \t */\n \tprivate final List records;\n-\t\n-\t\n+\n+\n \tprivate static final class CIRComparator implements Comparator {\n \t\tpublic static final Comparator instance = new CIRComparator();\n \t\tprivate CIRComparator() {\n@@ -299,7 +299,7 @@ private static ColumnInfoRecord copyColInfo(ColumnInfoRecord ci) {\n \t}\n \n \n-\tpublic void setColumn(int targetColumnIx, Short xfIndex, Integer width, \n+\tpublic void setColumn(int targetColumnIx, Short xfIndex, Integer width,\n \t\t\t\t\tInteger level, Boolean hidden, Boolean collapsed) {\n \t\tColumnInfoRecord ci = null;\n \t\tint k  = 0;\n@@ -370,26 +370,26 @@ public void setColumn(int targetColumnIx, Short xfIndex, Integer width,\n \t\t\tColumnInfoRecord ciMid = copyColInfo(ci);\n \t\t\tColumnInfoRecord ciEnd = copyColInfo(ci);\n \t\t\tint lastcolumn = ci.getLastColumn();\n-\t\t\t\n+\n \t\t\tciStart.setLastColumn(targetColumnIx - 1);\n \n \t\t\tciMid.setFirstColumn(targetColumnIx);\n \t\t\tciMid.setLastColumn(targetColumnIx);\n \t\t\tsetColumnInfoFields(ciMid, xfIndex, width, level, hidden, collapsed);\n \t\t\tinsertColumn(++k, ciMid);\n-\t\t\t\n+\n \t\t\tciEnd.setFirstColumn(targetColumnIx+1);\n \t\t\tciEnd.setLastColumn(lastcolumn);\n \t\t\tinsertColumn(++k, ciEnd);\n-\t\t\t// no need to attemptMergeColInfoRecords because we \n+\t\t\t// no need to attemptMergeColInfoRecords because we\n \t\t\t// know both on each side are different\n \t\t}\n \t}\n \n \t/**\n \t * Sets all non null fields into the <code>ci</code> parameter.\n \t */\n-\tprivate static void setColumnInfoFields(ColumnInfoRecord ci, Short xfStyle, Integer width, \n+\tprivate static void setColumnInfoFields(ColumnInfoRecord ci, Short xfStyle, Integer width,\n \t\t\t\tInteger level, Boolean hidden, Boolean collapsed) {\n \t\tif (xfStyle != null) {\n \t\t\tci.setXFIndex(xfStyle.shortValue());\n@@ -429,13 +429,13 @@ private int findColInfoIdx(int columnIx, int fromColInfoIdx) {\n \t}\n \n \t/**\n-\t * Attempts to merge the col info record at the specified index \n+\t * Attempts to merge the col info record at the specified index\n \t * with either or both of its neighbours\n \t */\n \tprivate void attemptMergeColInfoRecords(int colInfoIx) {\n \t\tint nRecords = records.size();\n \t\tif (colInfoIx < 0 || colInfoIx >= nRecords) {\n-\t\t\tthrow new IllegalArgumentException(\"colInfoIx \" + colInfoIx \n+\t\t\tthrow new IllegalArgumentException(\"colInfoIx \" + colInfoIx\n \t\t\t\t\t+ \" is out of range (0..\" + (nRecords-1) + \")\");\n \t\t}\n \t\tColumnInfoRecord currentCol = getColInfo(colInfoIx);\n@@ -466,7 +466,7 @@ private static boolean mergeColInfoRecords(ColumnInfoRecord ciA, ColumnInfoRecor\n \t * Creates an outline group for the specified columns, by setting the level\n \t * field for each col info record in the range. {@link ColumnInfoRecord}s\n \t * may be created, split or merged as a result of this operation.\n-\t * \n+\t *\n \t * @param fromColumnIx\n \t *            group from this column (inclusive)\n \t * @param toColumnIx\n@@ -493,7 +493,7 @@ public void groupColumnRange(int fromColumnIx, int toColumnIx, boolean indent) {\n \t\t\t\tlevel = Math.min(7, level);\n \t\t\t\tcolInfoSearchStartIdx = Math.max(0, colInfoIdx - 1); // -1 just in case this column is collapsed later.\n \t\t\t}\n-\t\t\tsetColumn(i, null, null, new Integer(level), null, null);\n+\t\t\tsetColumn(i, null, null, Integer.valueOf(level), null, null);\n \t\t}\n \t}\n \t/**",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/aggregates/ColumnInfoRecordsAggregate.java",
                "sha": "1b356fb3e57a8fb938a7083b1b65cbbd7cf37356",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "patch": "@@ -114,8 +114,8 @@ private void addUnknownRecord(Record rec) {\n \t\t_unknownRecords.add(rec);\n \t}\n \tpublic void insertRow(RowRecord row) {\n-\t\t// Integer integer = new Integer(row.getRowNumber());\n-\t\t_rowRecords.put(new Integer(row.getRowNumber()), row);\n+\t\t// Integer integer = Integer.valueOf(row.getRowNumber());\n+\t\t_rowRecords.put(Integer.valueOf(row.getRowNumber()), row);\n \t\tif ((row.getRowNumber() < _firstrow) || (_firstrow == -1)) {\n \t\t\t_firstrow = row.getRowNumber();\n \t\t}\n@@ -127,7 +127,7 @@ public void insertRow(RowRecord row) {\n \tpublic void removeRow(RowRecord row) {\n \t\tint rowIndex = row.getRowNumber();\n \t\t_valuesAgg.removeAllCellsValuesForRow(rowIndex);\n-\t\tInteger key = new Integer(rowIndex);\n+\t\tInteger key = Integer.valueOf(rowIndex);\n \t\tRowRecord rr = _rowRecords.remove(key);\n \t\tif (rr == null) {\n \t\t\tthrow new RuntimeException(\"Invalid row index (\" + key.intValue() + \")\");\n@@ -143,7 +143,7 @@ public RowRecord getRow(int rowIndex) {\n         if (rowIndex < 0 || rowIndex > maxrow) {\n \t\t\tthrow new IllegalArgumentException(\"The row number must be between 0 and \" + maxrow);\n \t\t}\n-\t\treturn _rowRecords.get(new Integer(rowIndex));\n+\t\treturn _rowRecords.get(Integer.valueOf(rowIndex));\n \t}\n \n \tpublic int getPhysicalNumberOfRows()",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "sha": "5b9393719afc87d4f90f501e833c6de4fa0e4f87",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/formula/function/FunctionDataBuilder.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/function/FunctionDataBuilder.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 8,
                "filename": "src/java/org/apache/poi/hssf/record/formula/function/FunctionDataBuilder.java",
                "patch": "@@ -25,7 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n /**\n  * Temporarily collects <tt>FunctionMetadata</tt> instances for creation of a\n  * <tt>FunctionMetadataRegistry</tt>.\n- * \n+ *\n  * @author Josh Micich\n  */\n final class FunctionDataBuilder {\n@@ -46,10 +46,10 @@ public void add(int functionIndex, String functionName, int minParams, int maxPa\n \t\t\tbyte returnClassCode, byte[] parameterClassCodes, boolean hasFootnote) {\n \t\tFunctionMetadata fm = new FunctionMetadata(functionIndex, functionName, minParams, maxParams,\n \t\t\t\treturnClassCode, parameterClassCodes);\n-\t\t\n-\t\tInteger indexKey = new Integer(functionIndex);\n-\t\t\n-\t\t\n+\n+\t\tInteger indexKey = Integer.valueOf(functionIndex);\n+\n+\n \t\tif(functionIndex > _maxFunctionIndex) {\n \t\t\t_maxFunctionIndex = functionIndex;\n \t\t}\n@@ -60,7 +60,7 @@ public void add(int functionIndex, String functionName, int minParams, int maxPa\n \t\t\tif(!hasFootnote || !_mutatingFunctionIndexes.contains(indexKey)) {\n \t\t\t\tthrow new RuntimeException(\"Multiple entries for function name '\" + functionName + \"'\");\n \t\t\t}\n-\t\t\t_functionDataByIndex.remove(new Integer(prevFM.getIndex()));\n+\t\t\t_functionDataByIndex.remove(Integer.valueOf(prevFM.getIndex()));\n \t\t}\n \t\tprevFM = (FunctionMetadata) _functionDataByIndex.get(indexKey);\n \t\tif(prevFM != null) {\n@@ -85,7 +85,7 @@ public FunctionMetadataRegistry build() {\n \t\t\tFunctionMetadata fd = jumbledArray[i];\n \t\t\tfdIndexArray[fd.getIndex()] = fd;\n \t\t}\n-\t\t\n+\n \t\treturn new FunctionMetadataRegistry(fdIndexArray, _functionDataByName);\n \t}\n-}\n\\ No newline at end of file\n+}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/record/formula/function/FunctionDataBuilder.java",
                "sha": "5f173a12db1cdda8f62e9b408e58a2fefd4989dc",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/FontDetails.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/FontDetails.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/usermodel/FontDetails.java",
                "patch": "@@ -57,7 +57,7 @@ public int getHeight()\n \n     public void addChar( char c, int width )\n     {\n-        charWidths.put(new Character(c), new Integer(width));\n+        charWidths.put(new Character(c), Integer.valueOf(width));\n     }\n \n     /**\n@@ -78,7 +78,7 @@ public void addChars( char[] characters, int[] widths )\n     {\n         for ( int i = 0; i < characters.length; i++ )\n         {\n-            charWidths.put( new Character(characters[i]), new Integer(widths[i]));\n+            charWidths.put( new Character(characters[i]), Integer.valueOf(widths[i]));\n         }\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/FontDetails.java",
                "sha": "f9b2bc8138c2373b8d94403920d2636722ea5439",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/HSSFPictureData.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFPictureData.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFPictureData.java",
                "patch": "@@ -79,6 +79,7 @@ public int getFormat(){\n \n     /**\n     * @see #getFormat\n+    * @return 'wmf', 'jpeg' etc depending on the format. never <code>null</code>\n     */\n     public String suggestFileExtension()\n     {",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/HSSFPictureData.java",
                "sha": "8ee20103002dd484aae8fb26d450da7087e42bf7",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 6,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -149,7 +149,7 @@ private void setPropertiesFromSheet(Sheet sheet) {\n \n         if (log.check( POILogger.DEBUG ))\n             log.log(DEBUG, \"Time at start of cell creating in HSSF sheet = \",\n-                new Long(timestart));\n+                Long.valueOf(timestart));\n         HSSFRow lastrow = null;\n \n         // Add every cell to its row\n@@ -180,12 +180,12 @@ private void setPropertiesFromSheet(Sheet sheet) {\n             hrow.createCellFromRecord( cval );\n             if (log.check( POILogger.DEBUG ))\n                 log.log( DEBUG, \"record took \",\n-                    new Long( System.currentTimeMillis() - cellstart ) );\n+                    Long.valueOf( System.currentTimeMillis() - cellstart ) );\n \n         }\n         if (log.check( POILogger.DEBUG ))\n             log.log(DEBUG, \"total sheet cell creation took \",\n-                new Long(System.currentTimeMillis() - timestart));\n+                Long.valueOf(System.currentTimeMillis() - timestart));\n     }\n \n     /**\n@@ -231,7 +231,7 @@ public void removeRow(Row row) {\n         }\n \n         if (_rows.size() > 0) {\n-            Integer key = new Integer(row.getRowNum());\n+            Integer key = Integer.valueOf(row.getRowNum());\n             HSSFRow removedRow = _rows.remove(key);\n             if (removedRow != row) {\n                 //should not happen if the input argument is valid\n@@ -296,7 +296,7 @@ private int findFirstRow(int firstrow)\n \n     private void addRow(HSSFRow row, boolean addLow)\n     {\n-        _rows.put(new Integer(row.getRowNum()), row);\n+        _rows.put(Integer.valueOf(row.getRowNum()), row);\n         if (addLow)\n         {\n             _sheet.addRow(row.getRowRecord());\n@@ -319,7 +319,7 @@ private void addRow(HSSFRow row, boolean addLow)\n      * @return HSSFRow representing the row number or null if its not defined on the sheet\n      */\n     public HSSFRow getRow(int rowIndex) {\n-        return _rows.get(new Integer(rowIndex));\n+        return _rows.get(Integer.valueOf(rowIndex));\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "d526d6de9df76a9a0b8634605556486a6ea79c3d",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java",
                "patch": "@@ -1081,7 +1081,7 @@ public HSSFFont getFontAt(short idx) {\n         // So we don't confuse users, give them back\n         //  the same object every time, but create\n         //  them lazily\n-        Short sIdx = new Short(idx);\n+        Short sIdx = Short.valueOf(idx);\n         if(fonts.containsKey(sIdx)) {\n             return (HSSFFont)fonts.get(sIdx);\n         }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java",
                "sha": "3d81c478f4aa254a9f330bee252587628ef41a2f",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/util/HSSFColor.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/util/HSSFColor.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/util/HSSFColor.java",
                "patch": "@@ -63,7 +63,7 @@ private static Hashtable createColorsByIndexMap() {\n         for (int i = 0; i < colors.length; i++) {\n             HSSFColor color = colors[i];\n \n-            Integer index1 = new Integer(color.getIndex());\n+            Integer index1 = Integer.valueOf(color.getIndex());\n             if (result.containsKey(index1)) {\n                 HSSFColor prevColor = (HSSFColor)result.get(index1);\n                 throw new RuntimeException(\"Dup color index (\" + index1\n@@ -111,7 +111,7 @@ private static Integer getIndex2(HSSFColor color) {\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(e);\n         }\n-        return new Integer(s.intValue());\n+        return Integer.valueOf(s.intValue());\n     }\n \n     private static HSSFColor[] getAllColors() {",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/hssf/util/HSSFColor.java",
                "sha": "6c1e77ec6e3c3241175bdf0599775ac9d70e6fa7",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/formula/WorkbookEvaluator.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/WorkbookEvaluator.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/ss/formula/WorkbookEvaluator.java",
                "patch": "@@ -192,7 +192,7 @@ private int getSheetIndex(EvaluationSheet sheet) {\n \t\t\tif (sheetIndex < 0) {\n \t\t\t\tthrow new RuntimeException(\"Specified sheet from a different book\");\n \t\t\t}\n-\t\t\tresult = new Integer(sheetIndex);\n+\t\t\tresult = Integer.valueOf(sheetIndex);\n \t\t\t_sheetIndexesBySheet.put(sheet, result);\n \t\t}\n \t\treturn result.intValue();\n@@ -214,7 +214,7 @@ public ValueEval evaluate(EvaluationCell srcCell) {\n \t\t\tif (sheetIndex < 0) {\n \t\t\t\treturn -1;\n \t\t\t}\n-\t\t\tresult = new Integer(sheetIndex);\n+\t\t\tresult = Integer.valueOf(sheetIndex);\n \t\t\t_sheetIndexesByName.put(sheetName, result);\n \t\t}\n \t\treturn result.intValue();",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/formula/WorkbookEvaluator.java",
                "sha": "66da4ca252cda19ead20a8aec895152c41b6dc8c",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/usermodel/BuiltinFormats.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/usermodel/BuiltinFormats.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/ss/usermodel/BuiltinFormats.java",
                "patch": "@@ -67,9 +67,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * <p/>\n  *\n  * @author Yegor Kozlov\n- *  \n- * Modified 6/17/09 by Stanislav Shor - positive formats don't need starting '(' \n- *  \n+ *\n+ * Modified 6/17/09 by Stanislav Shor - positive formats don't need starting '('\n+ *\n  */\n public final class BuiltinFormats {\n \t/**\n@@ -142,7 +142,7 @@ private static void putFormat(List<String> m, int index, String value) {\n \tpublic static Map<Integer, String> getBuiltinFormats() {\n \t\tMap<Integer, String> result = new LinkedHashMap<Integer, String>();\n \t\tfor (int i=0; i<_formats.length; i++) {\n-\t\t\tresult.put(new Integer(i), _formats[i]);\n+\t\t\tresult.put(Integer.valueOf(i), _formats[i]);\n \t\t}\n \t\treturn result;\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/usermodel/BuiltinFormats.java",
                "sha": "e9eebaff41c5eb09dbae2e7cb6f656f409a9c1be",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/usermodel/DataFormatter.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/usermodel/DataFormatter.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/ss/usermodel/DataFormatter.java",
                "patch": "@@ -147,7 +147,7 @@ private Format getFormat(double cellValue, int formatIndex, String formatStr) {\n         if (format != null) {\n             return format;\n         }\n-        if (formatStr.equals(\"General\") || formatStr.equals(\"@\")) {\n+        if (\"General\".equals(formatStr) || \"@\".equals(formatStr)) {\n             if (DataFormatter.isWholeNumber(cellValue)) {\n                 return generalWholeNumFormat;\n             }\n@@ -257,7 +257,7 @@ else if (c == 'm') {\n                 if(mIsMonth) {\n                     sb.append('M');\n                     ms.add(\n-                            new Integer(sb.length() -1)\n+                            Integer.valueOf(sb.length() -1)\n                     );\n                 } else {\n                     sb.append('m');",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/usermodel/DataFormatter.java",
                "sha": "bb7ef000e4149e04f677e888c15bc78687e7bd04",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/util/SheetReferences.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/util/SheetReferences.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 5,
                "filename": "src/java/org/apache/poi/ss/util/SheetReferences.java",
                "patch": "@@ -34,13 +34,12 @@ public SheetReferences()\n     {\n       map = new HashMap(5);\n     }\n- \n+\n     public void addSheetReference(String sheetName, int number) {\n-       map.put(new Integer(number), sheetName);\n-    } \n+       map.put(Integer.valueOf(number), sheetName);\n+    }\n \n     public String getSheetName(int number) {\n-       return (String)map.get(new Integer(number));\n+       return (String)map.get(Integer.valueOf(number));\n     }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/ss/util/SheetReferences.java",
                "sha": "028538a89d792b18cd4a4b15bcbf4acf28cb04d5",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/BitFieldFactory.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/BitFieldFactory.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 10,
                "filename": "src/java/org/apache/poi/util/BitFieldFactory.java",
                "patch": "@@ -15,7 +15,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.util;\n \n@@ -27,18 +26,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author Jason Height (jheight at apache dot org)\n  */\n \n-public class BitFieldFactory\n-{\n+public class BitFieldFactory {\n     private static Map instances = new HashMap();\n-    \n-    public static BitField getInstance(final int mask) {\n-      BitField f = (BitField)instances.get(new Integer(mask));\n+\n+    public static BitField getInstance(int mask) {\n+      BitField f = (BitField)instances.get(Integer.valueOf(mask));\n       if (f == null) {\n         f = new BitField(mask);\n-        instances.put(new Integer(mask), f);        \n+        instances.put(Integer.valueOf(mask), f);\n       }\n       return f;\n     }\n-\n-}   // end public class BitFieldFactory\n-\n+}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/BitFieldFactory.java",
                "sha": "d022ee66ce1b402a43da4c4808db76745d9020cc",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/HexRead.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/HexRead.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/java/org/apache/poi/util/HexRead.java",
                "patch": "@@ -62,7 +62,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * @see #readData(String)\n      */\n     public static byte[] readData(InputStream stream, String section ) throws IOException {\n-    \t\n+\n         try\n         {\n             StringBuffer sectionText = new StringBuffer();\n@@ -128,7 +128,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n                     characterCount++;\n                     if ( characterCount == 2 )\n                     {\n-                        bytes.add( new Byte( b ) );\n+                        bytes.add( Byte.valueOf( b ) );\n                         characterCount = 0;\n                         b = (byte) 0;\n                     }\n@@ -151,7 +151,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n                     characterCount++;\n                     if ( characterCount == 2 )\n                     {\n-                        bytes.add( new Byte( b ) );\n+                        bytes.add( Byte.valueOf( b ) );\n                         characterCount = 0;\n                         b = (byte) 0;\n                     }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/HexRead.java",
                "sha": "fa7ecb5c4b51debf38f0a2c519118dc0316bd1a4",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/IntMapper.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/IntMapper.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/util/IntMapper.java",
                "patch": "@@ -69,7 +69,7 @@ public boolean add(final Object value)\n     {\n       int index = elements.size();\n       elements.add(value);\n-      valueKeyMap.put(value, new Integer(index));\n+      valueKeyMap.put(value, Integer.valueOf(index));\n       return true;\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/IntMapper.java",
                "sha": "e4b7d345079e159c90c379d5f75b6731330da2d3",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/POILogger.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/POILogger.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/java/org/apache/poi/util/POILogger.java",
                "patch": "@@ -601,7 +601,7 @@ private void commonLogFormatted(int level, String message,\n \n             for (int j = 0; j < array.length; j++)\n             {\n-                results.add(new Byte(array[ j ]));\n+                results.add(Byte.valueOf(array[ j ]));\n             }\n         }\n         if (object instanceof char [])\n@@ -619,7 +619,7 @@ else if (object instanceof short [])\n \n             for (int j = 0; j < array.length; j++)\n             {\n-                results.add(new Short(array[ j ]));\n+                results.add(Short.valueOf(array[ j ]));\n             }\n         }\n         else if (object instanceof int [])\n@@ -628,7 +628,7 @@ else if (object instanceof int [])\n \n             for (int j = 0; j < array.length; j++)\n             {\n-                results.add(new Integer(array[ j ]));\n+                results.add(Integer.valueOf(array[ j ]));\n             }\n         }\n         else if (object instanceof long [])\n@@ -637,7 +637,7 @@ else if (object instanceof long [])\n \n             for (int j = 0; j < array.length; j++)\n             {\n-                results.add(new Long(array[ j ]));\n+                results.add(Long.valueOf(array[ j ]));\n             }\n         }\n         else if (object instanceof float [])",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/POILogger.java",
                "sha": "241196ec640911e26ae26f4cd67b51dbbea09df6",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/StringUtil.java",
                "changes": 36,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/util/StringUtil.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 18,
                "filename": "src/java/org/apache/poi/util/StringUtil.java",
                "patch": "@@ -24,7 +24,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hssf.record.RecordInputStream;\n /**\n  *  Title: String Utility Description: Collection of string handling utilities<p/>\n- *  \n+ *\n  * Note - none of the methods in this class deals with {@link org.apache.poi.hssf.record.ContinueRecord}s.  For such\n  * functionality, consider using {@link RecordInputStream\n } *\n@@ -52,7 +52,7 @@ private StringUtil() {\n \t *                 byte array. it is assumed that string[ offset ] and string[ offset +\n \t *                 1 ] contain the first 16-bit unicode character\n      * @param len the length of the final string\n-\t * @return                                     the converted string\n+\t * @return the converted string, never <code>null</code>.\n \t * @exception  ArrayIndexOutOfBoundsException  if offset is out of bounds for\n \t *      the byte array (i.e., is negative or is greater than or equal to\n \t *      string.length)\n@@ -87,7 +87,7 @@ public static String getFromUnicodeLE(\n \t * { 0x16, 0x00 } -0x16\n \t *\n \t * @param  string  the byte array to be converted\n-\t * @return         the converted string\n+\t * @return the converted string, never <code>null</code>\n \t */\n \tpublic static String getFromUnicodeLE(byte[] string) {\n \t\tif(string.length == 0) { return \"\"; }\n@@ -132,7 +132,7 @@ public static String readCompressedUnicode(LittleEndianInput in, int nChars) {\n \t * For this encoding, the is16BitFlag is always present even if nChars==0.\n \t */\n \tpublic static String readUnicodeString(LittleEndianInput in) {\n-\t\t\n+\n \t\tint nChars = in.readUShort();\n \t\tbyte flag = in.readByte();\n \t\tif ((flag & 0x01) == 0) {\n@@ -148,17 +148,17 @@ public static String readUnicodeString(LittleEndianInput in) {\n \t * </ol>\n \t * For this encoding, the is16BitFlag is always present even if nChars==0.\n \t * <br/>\n-\t * This method should be used when the nChars field is <em>not</em> stored \n-\t * as a ushort immediately before the is16BitFlag. Otherwise, {@link \n-\t * #readUnicodeString(LittleEndianInput)} can be used. \n+\t * This method should be used when the nChars field is <em>not</em> stored\n+\t * as a ushort immediately before the is16BitFlag. Otherwise, {@link\n+\t * #readUnicodeString(LittleEndianInput)} can be used.\n \t */\n \tpublic static String readUnicodeString(LittleEndianInput in, int nChars) {\n \t\tbyte is16Bit = in.readByte();\n \t\tif ((is16Bit & 0x01) == 0) {\n \t\t\treturn readCompressedUnicode(in, nChars);\n \t\t}\n-\t\treturn readUnicodeLE(in, nChars);\t\t\n-\t}\t\n+\t\treturn readUnicodeLE(in, nChars);\n+\t}\n \t/**\n \t * OutputStream <tt>out</tt> will get:\n \t * <ol>\n@@ -169,7 +169,7 @@ public static String readUnicodeString(LittleEndianInput in, int nChars) {\n \t * For this encoding, the is16BitFlag is always present even if nChars==0.\n \t */\n \tpublic static void writeUnicodeString(LittleEndianOutput out, String value) {\n-\t\t\n+\n \t\tint nChars = value.length();\n \t\tout.writeShort(nChars);\n \t\tboolean is16Bit = hasMultibyte(value);\n@@ -188,11 +188,11 @@ public static void writeUnicodeString(LittleEndianOutput out, String value) {\n \t * </ol>\n \t * For this encoding, the is16BitFlag is always present even if nChars==0.\n \t * <br/>\n-\t * This method should be used when the nChars field is <em>not</em> stored \n-\t * as a ushort immediately before the is16BitFlag. Otherwise, {@link \n-\t * #writeUnicodeString(LittleEndianOutput, String)} can be used. \n+\t * This method should be used when the nChars field is <em>not</em> stored\n+\t * as a ushort immediately before the is16BitFlag. Otherwise, {@link\n+\t * #writeUnicodeString(LittleEndianOutput, String)} can be used.\n \t */\n-\tpublic static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String value) {\t\t\n+\tpublic static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String value) {\n \t\tboolean is16Bit = hasMultibyte(value);\n \t\tout.writeByte(is16Bit ? 0x01 : 0x00);\n \t\tif (is16Bit) {\n@@ -201,7 +201,7 @@ public static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String\n \t\t\tputCompressedUnicode(value, out);\n \t\t}\n \t}\n-\t\n+\n \t/**\n \t * @return the number of bytes that would be written by {@link #writeUnicodeString(LittleEndianOutput, String)}\n \t */\n@@ -267,7 +267,7 @@ public static void putUnicodeLE(String input, LittleEndianOutput out) {\n \t\t}\n \t\tout.write(bytes);\n \t}\n-\t\n+\n \tpublic static String readUnicodeLE(LittleEndianInput in, int nChars) {\n \t\tchar[] buf = new char[nChars];\n \t\tfor (int i = 0; i < buf.length; i++) {\n@@ -360,7 +360,7 @@ public static String getPreferredEncoding() {\n \n \t/**\n \t * check the parameter has multibyte character\n-\t * \n+\t *\n \t * @param value string to check\n \t * @return boolean result true:string has at least one multibyte character\n \t */\n@@ -378,7 +378,7 @@ public static boolean hasMultibyte(String value) {\n \n \t/**\n \t * Checks to see if a given String needs to be represented as Unicode\n-\t * \n+\t *\n \t * @param value\n \t * @return true if string needs Unicode to be represented.\n \t */",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/java/org/apache/poi/util/StringUtil.java",
                "sha": "4a2cbabc72c39c20bfce7f29deb4049ee0635e76",
                "status": "modified"
            },
            {
                "additions": 170,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/POIXMLProperties.java",
                "changes": 340,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/POIXMLProperties.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 170,
                "filename": "src/ooxml/java/org/apache/poi/POIXMLProperties.java",
                "patch": "@@ -37,7 +37,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.openxmlformats.schemas.officeDocument.x2006.customProperties.CTProperty;\n \n /**\n- * Wrapper around the two different kinds of OOXML properties \n+ * Wrapper around the two different kinds of OOXML properties\n  *  a document can have\n  */\n public class POIXMLProperties {\n@@ -46,123 +46,123 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tprivate ExtendedProperties ext;\n \tprivate CustomProperties cust;\n \n-    private PackagePart extPart;\n-    private PackagePart custPart;\n+\tprivate PackagePart extPart;\n+\tprivate PackagePart custPart;\n \n \n-    private static final org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument NEW_EXT_INSTANCE;\n-    private static final org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument NEW_CUST_INSTANCE;\n-    static {\n-        NEW_EXT_INSTANCE = org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument.Factory.newInstance();\n-        NEW_EXT_INSTANCE.addNewProperties();\n+\tprivate static final org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument NEW_EXT_INSTANCE;\n+\tprivate static final org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument NEW_CUST_INSTANCE;\n+\tstatic {\n+\t\tNEW_EXT_INSTANCE = org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument.Factory.newInstance();\n+\t\tNEW_EXT_INSTANCE.addNewProperties();\n \n-        NEW_CUST_INSTANCE = org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument.Factory.newInstance();\n-        NEW_CUST_INSTANCE.addNewProperties();\n-    }\n+\t\tNEW_CUST_INSTANCE = org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument.Factory.newInstance();\n+\t\tNEW_CUST_INSTANCE.addNewProperties();\n+\t}\n \n-    public POIXMLProperties(OPCPackage docPackage) throws IOException, OpenXML4JException, XmlException {\n+\tpublic POIXMLProperties(OPCPackage docPackage) throws IOException, OpenXML4JException, XmlException {\n \t\tthis.pkg = docPackage;\n-\t\t\n+\n \t\t// Core properties\n-        core = new CoreProperties((PackagePropertiesPart)pkg.getPackageProperties() );\n-\t\t\n+\t\tcore = new CoreProperties((PackagePropertiesPart)pkg.getPackageProperties() );\n+\n \t\t// Extended properties\n \t\tPackageRelationshipCollection extRel =\n \t\t\tpkg.getRelationshipsByType(POIXMLDocument.EXTENDED_PROPERTIES_REL_TYPE);\n \t\tif(extRel.size() == 1) {\n-            extPart = pkg.getPart( extRel.getRelationship(0));\n-            org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument.Factory.parse(\n-        \t\t extPart.getInputStream()\n+\t\t\textPart = pkg.getPart( extRel.getRelationship(0));\n+\t\t\torg.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument.Factory.parse(\n+\t\t\t\t extPart.getInputStream()\n \t\t\t);\n \t\t\text = new ExtendedProperties(props);\n \t\t} else {\n-            extPart = null;\n-            ext = new ExtendedProperties((org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument)NEW_EXT_INSTANCE.copy());\n-        }\n-\t\t\n+\t\t\textPart = null;\n+\t\t\text = new ExtendedProperties((org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument)NEW_EXT_INSTANCE.copy());\n+\t\t}\n+\n \t\t// Custom properties\n \t\tPackageRelationshipCollection custRel =\n \t\t\tpkg.getRelationshipsByType(POIXMLDocument.CUSTOM_PROPERTIES_REL_TYPE);\n \t\tif(custRel.size() == 1) {\n-            custPart = pkg.getPart( custRel.getRelationship(0));\n-            org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument.Factory.parse(\n+\t\t\tcustPart = pkg.getPart( custRel.getRelationship(0));\n+\t\t\torg.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument.Factory.parse(\n \t\t\t\t\tcustPart.getInputStream()\n \t\t\t);\n \t\t\tcust = new CustomProperties(props);\n \t\t} else {\n-            custPart = null;\n-            cust = new CustomProperties((org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument)NEW_CUST_INSTANCE.copy());\n+\t\t\tcustPart = null;\n+\t\t\tcust = new CustomProperties((org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument)NEW_CUST_INSTANCE.copy());\n \t\t}\n \t}\n-\t\n+\n \t/**\n \t * Returns the core document properties\n \t */\n \tpublic CoreProperties getCoreProperties() {\n \t\treturn core;\n \t}\n-\t\n+\n \t/**\n \t * Returns the extended document properties\n \t */\n \tpublic ExtendedProperties getExtendedProperties() {\n \t\treturn ext;\n \t}\n-\t\n+\n \t/**\n \t * Returns the custom document properties\n \t */\n \tpublic CustomProperties getCustomProperties() {\n \t\treturn cust;\n \t}\n-\t\n+\n \t/**\n \t * Commit changes to the underlying OPC package\n \t */\n \tpublic void commit() throws IOException{\n \n-        if(extPart == null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n-            try {\n-                PackagePartName prtname = PackagingURIHelper.createPartName(\"/docProps/app.xml\");\n-                pkg.addRelationship(prtname, TargetMode.INTERNAL, \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\");\n-                extPart = pkg.createPart(prtname, \"application/vnd.openxmlformats-officedocument.extended-properties+xml\");\n-            } catch (InvalidFormatException e){\n-                throw new POIXMLException(e);\n-            }\n-        }\n-        if(custPart == null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n-            try {\n-                PackagePartName prtname = PackagingURIHelper.createPartName(\"/docProps/custom.xml\");\n-                pkg.addRelationship(prtname, TargetMode.INTERNAL, \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties\");\n-                custPart = pkg.createPart(prtname, \"application/vnd.openxmlformats-officedocument.custom-properties+xml\");\n-            } catch (InvalidFormatException e){\n-                throw new POIXMLException(e);\n-            }\n-        }\n-        if(extPart != null){\n-            XmlOptions xmlOptions = new XmlOptions(POIXMLDocumentPart.DEFAULT_XML_OPTIONS);\n-\n-            Map<String, String> map = new HashMap<String, String>();\n-            map.put(\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\", \"vt\");\n-            xmlOptions.setSaveSuggestedPrefixes(map);\n-\n-            OutputStream out = extPart.getOutputStream();\n-            ext.props.save(out, xmlOptions);\n-            out.close();\n-        }\n-        if(custPart != null){\n-            XmlOptions xmlOptions = new XmlOptions(POIXMLDocumentPart.DEFAULT_XML_OPTIONS);\n-\n-            Map<String, String> map = new HashMap<String, String>();\n-            map.put(\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\", \"vt\");\n-            xmlOptions.setSaveSuggestedPrefixes(map);\n-\n-            OutputStream out = custPart.getOutputStream();\n-            cust.props.save(out, xmlOptions);\n-            out.close();\n-        }\n+\t\tif(extPart == null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n+\t\t\ttry {\n+\t\t\t\tPackagePartName prtname = PackagingURIHelper.createPartName(\"/docProps/app.xml\");\n+\t\t\t\tpkg.addRelationship(prtname, TargetMode.INTERNAL, \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\");\n+\t\t\t\textPart = pkg.createPart(prtname, \"application/vnd.openxmlformats-officedocument.extended-properties+xml\");\n+\t\t\t} catch (InvalidFormatException e){\n+\t\t\t\tthrow new POIXMLException(e);\n+\t\t\t}\n+\t\t}\n+\t\tif(custPart == null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n+\t\t\ttry {\n+\t\t\t\tPackagePartName prtname = PackagingURIHelper.createPartName(\"/docProps/custom.xml\");\n+\t\t\t\tpkg.addRelationship(prtname, TargetMode.INTERNAL, \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties\");\n+\t\t\t\tcustPart = pkg.createPart(prtname, \"application/vnd.openxmlformats-officedocument.custom-properties+xml\");\n+\t\t\t} catch (InvalidFormatException e){\n+\t\t\t\tthrow new POIXMLException(e);\n+\t\t\t}\n+\t\t}\n+\t\tif(extPart != null){\n+\t\t\tXmlOptions xmlOptions = new XmlOptions(POIXMLDocumentPart.DEFAULT_XML_OPTIONS);\n+\n+\t\t\tMap<String, String> map = new HashMap<String, String>();\n+\t\t\tmap.put(\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\", \"vt\");\n+\t\t\txmlOptions.setSaveSuggestedPrefixes(map);\n+\n+\t\t\tOutputStream out = extPart.getOutputStream();\n+\t\t\text.props.save(out, xmlOptions);\n+\t\t\tout.close();\n+\t\t}\n+\t\tif(custPart != null){\n+\t\t\tXmlOptions xmlOptions = new XmlOptions(POIXMLDocumentPart.DEFAULT_XML_OPTIONS);\n+\n+\t\t\tMap<String, String> map = new HashMap<String, String>();\n+\t\t\tmap.put(\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\", \"vt\");\n+\t\t\txmlOptions.setSaveSuggestedPrefixes(map);\n+\n+\t\t\tOutputStream out = custPart.getOutputStream();\n+\t\t\tcust.props.save(out, xmlOptions);\n+\t\t\tout.close();\n+\t\t}\n \t}\n-\t\n+\n \t/**\n \t * The core document properties\n \t */\n@@ -171,7 +171,7 @@ public void commit() throws IOException{\n \t\tprivate CoreProperties(PackagePropertiesPart part) {\n \t\t\tthis.part = part;\n \t\t}\n-\t\t\n+\n \t\tpublic String getCategory() {\n \t\t\treturn part.getCategoryProperty().getValue();\n \t\t}\n@@ -252,17 +252,17 @@ public String getRevision() {\n \t\t}\n \t\tpublic void setRevision(String revision) {\n \t\t\ttry {\n-\t\t\t\tnew Long(revision);\n+\t\t\t\tLong.valueOf(revision);\n \t\t\t\tpart.setRevisionProperty(revision);\n \t\t\t}\n \t\t\tcatch (NumberFormatException e) {}\n \t\t}\n-\t\t\n+\n \t\tpublic PackagePropertiesPart getUnderlyingProperties() {\n \t\t\treturn part;\n \t\t}\n \t}\n-\t\n+\n \t/**\n \t * Extended document properties\n \t */\n@@ -271,115 +271,115 @@ public PackagePropertiesPart getUnderlyingProperties() {\n \t\tprivate ExtendedProperties(org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props) {\n \t\t\tthis.props = props;\n \t\t}\n-\t\t\n+\n \t\tpublic org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.CTProperties getUnderlyingProperties() {\n \t\t\treturn props.getProperties();\n \t\t}\n \t}\n-\t\n+\n \t/**\n \t *  Custom document properties\n \t */\n \tpublic class CustomProperties {\n-        /**\n-         *  Each custom property element contains an fmtid attribute\n-         *  with the same GUID value ({D5CDD505-2E9C-101B-9397-08002B2CF9AE}).\n-         */\n-        public static final String FORMAT_ID = \"{D5CDD505-2E9C-101B-9397-08002B2CF9AE}\";\n+\t\t/**\n+\t\t *  Each custom property element contains an fmtid attribute\n+\t\t *  with the same GUID value ({D5CDD505-2E9C-101B-9397-08002B2CF9AE}).\n+\t\t */\n+\t\tpublic static final String FORMAT_ID = \"{D5CDD505-2E9C-101B-9397-08002B2CF9AE}\";\n \n-        private org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props;\n+\t\tprivate org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props;\n \t\tprivate CustomProperties(org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props) {\n \t\t\tthis.props = props;\n \t\t}\n-\t\t\n+\n \t\tpublic org.openxmlformats.schemas.officeDocument.x2006.customProperties.CTProperties getUnderlyingProperties() {\n \t\t\treturn props.getProperties();\n \t\t}\n \n-        /**\n-         * Add a new property\n-         *\n-         * @param name the property name\n-         * @throws IllegalArgumentException if a property with this name already exists\n-         */\n-        private CTProperty add(String name) {\n-            if(contains(name)) {\n-                throw new IllegalArgumentException(\"A property with this name \" +\n-                        \"already exists in the custom properties\");\n-            }\n-\n-            CTProperty p = props.getProperties().addNewProperty();\n-            int pid = nextPid();\n-            p.setPid(pid);\n-            p.setFmtid(FORMAT_ID);\n-            p.setName(name);\n-            return p;\n-        }\n-\n-        /**\n-         * Add a new string property\n-         *\n-         * @throws IllegalArgumentException if a property with this name already exists\n-         */\n-         public void addProperty(String name, String value){\n-            CTProperty p = add(name);\n-            p.setLpwstr(value);\n-        }\n-\n-        /**\n-         * Add a new double property\n-         *\n-         * @throws IllegalArgumentException if a property with this name already exists\n-         */\n-        public void addProperty(String name, double value){\n-            CTProperty p = add(name);\n-            p.setR8(value);\n-        }\n-\n-        /**\n-         * Add a new integer property\n-         *\n-         * @throws IllegalArgumentException if a property with this name already exists\n-         */\n-        public void addProperty(String name, int value){\n-            CTProperty p = add(name);\n-            p.setI4(value);\n-        }\n-\n-        /**\n-         * Add a new boolean property\n-         *\n-         * @throws IllegalArgumentException if a property with this name already exists\n-         */\n-        public void addProperty(String name, boolean value){\n-            CTProperty p = add(name);\n-            p.setBool(value);\n-        }\n-\n-        /**\n-         * Generate next id that uniquely relates a custom property\n-         *\n-         * @return next property id starting with 2\n-         */\n-        protected int nextPid(){\n-            int propid = 1;\n-            for(CTProperty p : props.getProperties().getPropertyArray()){\n-                if(p.getPid() > propid) propid = p.getPid();\n-            }\n-            return propid + 1;\n-        }\n-\n-        /**\n-         * Check if a property with this name already exists in the collection of custom properties\n-         *\n-         * @param name the name to check\n-         * @return whether a property with the given name exists in the custom properties\n-         */\n-        public boolean contains(String name){\n-            for(CTProperty p : props.getProperties().getPropertyArray()){\n-                if(p.getName().equals(name)) return true;\n-            }\n-            return false;\n-        }\n-    }\n+\t\t/**\n+\t\t * Add a new property\n+\t\t *\n+\t\t * @param name the property name\n+\t\t * @throws IllegalArgumentException if a property with this name already exists\n+\t\t */\n+\t\tprivate CTProperty add(String name) {\n+\t\t\tif(contains(name)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"A property with this name \" +\n+\t\t\t\t\t\t\"already exists in the custom properties\");\n+\t\t\t}\n+\n+\t\t\tCTProperty p = props.getProperties().addNewProperty();\n+\t\t\tint pid = nextPid();\n+\t\t\tp.setPid(pid);\n+\t\t\tp.setFmtid(FORMAT_ID);\n+\t\t\tp.setName(name);\n+\t\t\treturn p;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Add a new string property\n+\t\t *\n+\t\t * @throws IllegalArgumentException if a property with this name already exists\n+\t\t */\n+\t\t public void addProperty(String name, String value){\n+\t\t\tCTProperty p = add(name);\n+\t\t\tp.setLpwstr(value);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Add a new double property\n+\t\t *\n+\t\t * @throws IllegalArgumentException if a property with this name already exists\n+\t\t */\n+\t\tpublic void addProperty(String name, double value){\n+\t\t\tCTProperty p = add(name);\n+\t\t\tp.setR8(value);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Add a new integer property\n+\t\t *\n+\t\t * @throws IllegalArgumentException if a property with this name already exists\n+\t\t */\n+\t\tpublic void addProperty(String name, int value){\n+\t\t\tCTProperty p = add(name);\n+\t\t\tp.setI4(value);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Add a new boolean property\n+\t\t *\n+\t\t * @throws IllegalArgumentException if a property with this name already exists\n+\t\t */\n+\t\tpublic void addProperty(String name, boolean value){\n+\t\t\tCTProperty p = add(name);\n+\t\t\tp.setBool(value);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Generate next id that uniquely relates a custom property\n+\t\t *\n+\t\t * @return next property id starting with 2\n+\t\t */\n+\t\tprotected int nextPid(){\n+\t\t\tint propid = 1;\n+\t\t\tfor(CTProperty p : props.getProperties().getPropertyArray()){\n+\t\t\t\tif(p.getPid() > propid) propid = p.getPid();\n+\t\t\t}\n+\t\t\treturn propid + 1;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Check if a property with this name already exists in the collection of custom properties\n+\t\t *\n+\t\t * @param name the name to check\n+\t\t * @return whether a property with the given name exists in the custom properties\n+\t\t */\n+\t\tpublic boolean contains(String name){\n+\t\t\tfor(CTProperty p : props.getProperties().getPropertyArray()){\n+\t\t\t\tif(p.getName().equals(name)) return true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/POIXMLProperties.java",
                "sha": "45e17a2df65c0ee6b7675c5a933dc226cefc0102",
                "status": "modified"
            },
            {
                "additions": 260,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "changes": 550,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 290,
                "filename": "src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "patch": "@@ -58,300 +58,285 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.xml.sax.SAXException;\n \n /**\n- * \n+ *\n  * Maps an XLSX to an XML according to one of the mapping defined.\n- * \n- * \n+ *\n+ *\n  * The output XML Schema must respect this limitations:\n- * \n+ *\n  * <ul>\n  * <li> all mandatory elements and attributes must be mapped (enable validation to check this)</li>\n- * \n+ *\n  * <li> no &lt;any&gt; in complex type/element declaration </li>\n  * <li> no &lt;anyAttribute&gt; attributes declaration </li>\n  * <li> no recursive structures: recursive structures can't be nested more than one level </li>\n  * <li> no abstract elements: abstract complex types can be declared but must not be used in elements. </li>\n  * <li> no mixed content: an element can't contain simple text and child element(s) together </li>\n  * <li> no &lt;substitutionGroup&gt; in complex type/element declaration </li>\n  * </ul>\n- * \n- * @author Roberto Manicardi\n- * \n- * \n  *\n+ * @author Roberto Manicardi\n  */\n-\n-\n public class XSSFExportToXml implements Comparator<String>{\n-\t\n+\n \tprivate XSSFMap map;\n-\t\n+\n \t/**\n \t * Creates a new exporter and sets the mapping to be used when generating the XML output document\n-\t * \n+\t *\n \t * @param map the mapping rule to be used\n \t */\n-\tpublic XSSFExportToXml(XSSFMap map){\n+\tpublic XSSFExportToXml(XSSFMap map) {\n \t\tthis.map = map;\n \t}\n-\t\n+\n \t/**\n-\t * \n-\t * Exports the data in an XML stream \n-\t * \n+\t *\n+\t * Exports the data in an XML stream\n+\t *\n \t * @param os OutputStream in which will contain the output XML\n \t * @param validate if true, validates the XML againts the XML Schema\n \t * @throws SAXException\n \t */\n \tpublic void exportToXML(OutputStream os, boolean validate) throws SAXException{\n \t\texportToXML(os,\"UTF-8\", validate);\n \t}\n-\t\n+\n \tprivate Document getEmptyDocument() throws ParserConfigurationException{\n-\t\t\n-\t\n+\n \t\tDocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();\n-        DocumentBuilder docBuilder = dbfac.newDocumentBuilder();\n-        Document doc = docBuilder.newDocument();\n+\t\tDocumentBuilder docBuilder = dbfac.newDocumentBuilder();\n+\t\tDocument doc = docBuilder.newDocument();\n \n-\t\t\n-        \n-        return doc;\n+\t\treturn doc;\n \t}\n-\t\n+\n \t/**\n \t * Exports the data in an XML stream\n-\t * \n+\t *\n \t * @param os OutputStream in which will contain the output XML\n-\t * @param encoding the output charset encoding \n+\t * @param encoding the output charset encoding\n \t * @param validate if true, validates the XML againts the XML Schema\n \t * @throws SAXException\n \t * @throws InvalidFormatException\n \t */\n-\t\n \tpublic void exportToXML(OutputStream os, String encoding, boolean validate) throws SAXException{\n \t\tList<XSSFSingleXmlCell> singleXMLCells = map.getRelatedSingleXMLCell();\n \t\tList<Table> tables = map.getRelatedTables();\n-\t\t\n+\n \t\tString rootElement = map.getCtMap().getRootElement();\n-\t\t\n+\n \t\ttry{\n-\t\t\t\n+\n \t\t\tDocument doc = getEmptyDocument();\n-\t\t\t\n-\t        Element root = null;\n-\t\n-\t        if(isNamespaceDeclared()){\n-\t        \t root=doc.createElementNS(getNamespace(),rootElement);        \t\n-\t        }else{ \n-\t        \troot=doc.createElement(rootElement);\n-\t        }\n-\t        doc.appendChild(root);\n-\t        \n-\t        \n-\t        List<String> xpaths = new Vector<String>();\n-\t        Map<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<String,XSSFSingleXmlCell>();\n-\t        Map<String,Table> tableMappings = new HashMap<String,Table>();\n-\t        \n-\t        for(XSSFSingleXmlCell simpleXmlCell : singleXMLCells){\n-\t        \txpaths.add(simpleXmlCell.getXpath());\n-\t        \tsingleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);\n-\t        }\n-\t        for(Table table : tables){\n-\t        \tString commonXPath = table.getCommonXpath();\n-\t        \txpaths.add(commonXPath);\n-\t        \ttableMappings.put(commonXPath, table);\n-\t        }\n-\t        \n-\t        \n-\t        Collections.sort(xpaths,this);\n-\t        \n-\t        for(String xpath : xpaths){\n-\t        \t\n-\t        \t\tXSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);\n-\t        \t\tTable table = tableMappings.get(xpath);\t\t\n-\t        \t\t\n-\t        \t\tif(!xpath.matches(\".*\\\\[.*\")){\n-\t        \t\t\t\n-\t        \t\t\t// Exports elements and attributes mapped with simpleXmlCell\n-\t        \t\t\tif(simpleXmlCell!=null){\n-\t        \t\t\t\tXSSFCell cell = simpleXmlCell.getReferencedCell();\n-\t        \t\t\t\tif(cell!=null){\n-\t\t\t\t        \t\tNode currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);\n-\t\t\t\t        \t\tSTXmlDataType.Enum dataType = simpleXmlCell.getXmlDataType();        \t\t\n-\t\t\t\t        \t\tmapCellOnNode(cell,currentNode,dataType);\t\n-\t        \t\t\t\t}\n-\t        \t\t\t}\n-\t        \t\t\t\n-\t        \t\t\t// Exports elements and attributes mapped with tables\n-\t        \t\t\tif(table!=null){\n-\t        \t\t\t\t\n-\t        \t\t\t\tList<XSSFXmlColumnPr> tableColumns = table.getXmlColumnPrs();\n-\t        \t\t\t\t\n-\t        \t\t\t\tXSSFSheet sheet = table.getXSSFSheet();\n-\t        \t\t\t\t\n-\t        \t\t\t\tint startRow = table.getStartCellReference().getRow();\n-\t        \t\t\t\t// In mappings created with Microsoft Excel the first row contains the table header and must be skipped\n-\t        \t\t\t\tstartRow +=1;\n-\t        \t\t\t\t\n-\t        \t\t\t\tint endRow = table.getEndCellReference().getRow();\n-\t        \t\t\t\t\n-\t        \t\t\t\tfor(int i = startRow; i<= endRow; i++){\n-\t        \t\t\t\t\tXSSFRow row = sheet.getRow(i);\n-\t        \t\t\t\t\t\n-\t        \t\t\t\t\tNode tableRootNode = getNodeByXPath(table.getCommonXpath(),doc.getFirstChild(),doc,true);\n-\t        \t\t\t\t\t\n-\t        \t\t\t\t\tshort startColumnIndex = table.getStartCellReference().getCol();\n-\t        \t\t\t\t\tfor(int j = startColumnIndex; j<= table.getEndCellReference().getCol();j++){\n-\t        \t\t\t\t\t\tXSSFCell cell = row.getCell(j);\n-\t        \t\t\t\t\t\tif(cell!=null){\n-\t\t        \t\t\t\t\t\tXSSFXmlColumnPr pointer = tableColumns.get(j-startColumnIndex);\n-\t\t        \t\t\t\t\t\tString localXPath = pointer.getLocalXPath();\n-\t\t        \t\t\t\t\t\tNode currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);\n-\t\t        \t\t\t\t\t\tSTXmlDataType.Enum dataType = pointer.getXmlDataType();\n-\t\t        \t\t\t\t\t\t\n-\t\t        \t\t\t\t\t\t\n-\t\t        \t\t\t\t\t\tmapCellOnNode(cell,currentNode,dataType);\n-\t        \t\t\t\t\t\t}\n-\t        \t\t\t\t\t\n-\t        \t\t\t\t\t}\n-\t        \t\t\t\t\t\n-\t        \t\t\t\t}\n-\t        \t\t\t\t\n-\t        \t\t\t\t\n-\t        \t\t\t\t\n-\t        \t\t\t}\n-\t        \t\t}else{\n-\t        \t\t\t// TODO:  implement filtering management in xpath\n-\t        \t\t}\n-\t        }\n-\t        \n-\t        boolean isValid = true;\n-\t        if(validate){\n-\t        \tisValid =isValid(doc);\n-\t        }\n-\t        \n-\t   \n-\t\n-\t        if(isValid){\n-\t\t\t\t\n+\n+\t\t\tElement root = null;\n+\n+\t\t\tif (isNamespaceDeclared()) {\n+\t\t\t\t root=doc.createElementNS(getNamespace(),rootElement);\n+\t\t\t} else {\n+\t\t\t\troot=doc.createElement(rootElement);\n+\t\t\t}\n+\t\t\tdoc.appendChild(root);\n+\n+\n+\t\t\tList<String> xpaths = new Vector<String>();\n+\t\t\tMap<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<String,XSSFSingleXmlCell>();\n+\t\t\tMap<String,Table> tableMappings = new HashMap<String,Table>();\n+\n+\t\t\tfor(XSSFSingleXmlCell simpleXmlCell : singleXMLCells) {\n+\t\t\t\txpaths.add(simpleXmlCell.getXpath());\n+\t\t\t\tsingleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);\n+\t\t\t}\n+\t\t\tfor(Table table : tables) {\n+\t\t\t\tString commonXPath = table.getCommonXpath();\n+\t\t\t\txpaths.add(commonXPath);\n+\t\t\t\ttableMappings.put(commonXPath, table);\n+\t\t\t}\n+\n+\n+\t\t\tCollections.sort(xpaths,this);\n+\n+\t\t\tfor(String xpath : xpaths) {\n+\n+\t\t\t\t\tXSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);\n+\t\t\t\t\tTable table = tableMappings.get(xpath);\n+\n+\t\t\t\t\tif (!xpath.matches(\".*\\\\[.*\")) {\n+\n+\t\t\t\t\t\t// Exports elements and attributes mapped with simpleXmlCell\n+\t\t\t\t\t\tif (simpleXmlCell!=null) {\n+\t\t\t\t\t\t\tXSSFCell cell = simpleXmlCell.getReferencedCell();\n+\t\t\t\t\t\t\tif (cell!=null) {\n+\t\t\t\t\t\t\t\tNode currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);\n+\t\t\t\t\t\t\t\tSTXmlDataType.Enum dataType = simpleXmlCell.getXmlDataType();\n+\t\t\t\t\t\t\t\tmapCellOnNode(cell,currentNode,dataType);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Exports elements and attributes mapped with tables\n+\t\t\t\t\t\tif (table!=null) {\n+\n+\t\t\t\t\t\t\tList<XSSFXmlColumnPr> tableColumns = table.getXmlColumnPrs();\n+\n+\t\t\t\t\t\t\tXSSFSheet sheet = table.getXSSFSheet();\n+\n+\t\t\t\t\t\t\tint startRow = table.getStartCellReference().getRow();\n+\t\t\t\t\t\t\t// In mappings created with Microsoft Excel the first row contains the table header and must be skipped\n+\t\t\t\t\t\t\tstartRow +=1;\n+\n+\t\t\t\t\t\t\tint endRow = table.getEndCellReference().getRow();\n+\n+\t\t\t\t\t\t\tfor(int i = startRow; i<= endRow; i++) {\n+\t\t\t\t\t\t\t\tXSSFRow row = sheet.getRow(i);\n+\n+\t\t\t\t\t\t\t\tNode tableRootNode = getNodeByXPath(table.getCommonXpath(),doc.getFirstChild(),doc,true);\n+\n+\t\t\t\t\t\t\t\tshort startColumnIndex = table.getStartCellReference().getCol();\n+\t\t\t\t\t\t\t\tfor(int j = startColumnIndex; j<= table.getEndCellReference().getCol();j++) {\n+\t\t\t\t\t\t\t\t\tXSSFCell cell = row.getCell(j);\n+\t\t\t\t\t\t\t\t\tif (cell!=null) {\n+\t\t\t\t\t\t\t\t\t\tXSSFXmlColumnPr pointer = tableColumns.get(j-startColumnIndex);\n+\t\t\t\t\t\t\t\t\t\tString localXPath = pointer.getLocalXPath();\n+\t\t\t\t\t\t\t\t\t\tNode currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);\n+\t\t\t\t\t\t\t\t\t\tSTXmlDataType.Enum dataType = pointer.getXmlDataType();\n+\n+\n+\t\t\t\t\t\t\t\t\t\tmapCellOnNode(cell,currentNode,dataType);\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t}\n+\n+\n+\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// TODO:  implement filtering management in xpath\n+\t\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tboolean isValid = true;\n+\t\t\tif (validate) {\n+\t\t\t\tisValid =isValid(doc);\n+\t\t\t}\n+\n+\n+\n+\t\t\tif (isValid) {\n+\n \t\t\t\t/////////////////\n-\t\t        //Output the XML\n-\t\t\n-\t\t        //set up a transformer\n-\t\t        TransformerFactory transfac = TransformerFactory.newInstance();\n-\t\t        Transformer trans = transfac.newTransformer();\n-\t\t        trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n-\t\t        trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-\t\t        trans.setOutputProperty(OutputKeys.ENCODING, encoding);\n-\t\t        \n-\t\t        //create string from xml tree\n-\t\t       \n-\t\t        StreamResult result = new StreamResult(os);\n-\t\t        DOMSource source = new DOMSource(doc);\n-\t\t        trans.transform(source, result);\n-\t\t\t\n-\t        }\n-        }catch(ParserConfigurationException e){\n+\t\t\t\t//Output the XML\n+\n+\t\t\t\t//set up a transformer\n+\t\t\t\tTransformerFactory transfac = TransformerFactory.newInstance();\n+\t\t\t\tTransformer trans = transfac.newTransformer();\n+\t\t\t\ttrans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n+\t\t\t\ttrans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+\t\t\t\ttrans.setOutputProperty(OutputKeys.ENCODING, encoding);\n+\n+\t\t\t\t//create string from xml tree\n+\n+\t\t\t\tStreamResult result = new StreamResult(os);\n+\t\t\t\tDOMSource source = new DOMSource(doc);\n+\t\t\t\ttrans.transform(source, result);\n+\n+\t\t\t}\n+\t\t}catch(ParserConfigurationException e) {\n \t\t\te.printStackTrace();\n-\t\t}catch(TransformerException e){\n+\t\t}catch(TransformerException e) {\n \t\t\te.printStackTrace();\n \t\t}\n \n-\t\t\n+\n \t}\n-\t\n+\n \t/**\n \t * Validate the generated XML against the XML Schema associated with the XSSFMap\n-\t * \n+\t *\n \t * @param xml the XML to validate\n \t * @return\n \t */\n-\n \tprivate boolean isValid(Document xml) throws SAXException{\n \t\tboolean isValid = false;\n \t\ttry{\n-\t\tString language = XMLConstants.W3C_XML_SCHEMA_NS_URI;\n-\t      SchemaFactory factory = SchemaFactory.newInstance(language);\n-\n-\t      Source source = new DOMSource(map.getSchema());\n-\t      Schema schema = factory.newSchema(source);\n-\t      Validator validator = schema.newValidator();\n-\t      validator.validate(new DOMSource(xml));\n-\t      //if no exceptions where raised, the document is valid\n-\t      isValid=true;\n-\t      \n-\t      \n-\t\t}catch(IOException e){\n+\t\t\tString language = XMLConstants.W3C_XML_SCHEMA_NS_URI;\n+\t\t\tSchemaFactory factory = SchemaFactory.newInstance(language);\n+\n+\t\t\tSource source = new DOMSource(map.getSchema());\n+\t\t\tSchema schema = factory.newSchema(source);\n+\t\t\tValidator validator = schema.newValidator();\n+\t\t\tvalidator.validate(new DOMSource(xml));\n+\t\t\t//if no exceptions where raised, the document is valid\n+\t\t\tisValid=true;\n+\n+\n+\t\t} catch(IOException e) {\n \t\t\te.printStackTrace();\n \t\t}\n-\t    return isValid;\n+\t\treturn isValid;\n \t}\n-\t\n-\t\n-\tprivate void mapCellOnNode(XSSFCell cell, Node node, STXmlDataType.Enum  outputDataType){\n-    \t\t\n-\t\t\n+\n+\n+\tprivate void mapCellOnNode(XSSFCell cell, Node node, STXmlDataType.Enum  outputDataType) {\n+\n \t\tString value =\"\";\n-\t\tswitch (cell.getCellType()){\n-\t\t\n+\t\tswitch (cell.getCellType()) {\n+\n \t\t\tcase XSSFCell.CELL_TYPE_STRING: value = cell.getStringCellValue(); break;\n \t\t\tcase XSSFCell.CELL_TYPE_BOOLEAN: value += cell.getBooleanCellValue(); break;\n \t\t\tcase XSSFCell.CELL_TYPE_ERROR: value = cell.getErrorCellString();  break;\n \t\t\tcase XSSFCell.CELL_TYPE_FORMULA: value = cell.getStringCellValue(); break;\n \t\t\tcase XSSFCell.CELL_TYPE_NUMERIC: value += cell.getRawValue(); break;\n \t\t\tdefault: ;\n-\t\t\n+\n \t\t}\n-\t\tif(node instanceof Element){\n+\t\tif (node instanceof Element) {\n \t\t\tElement currentElement = (Element) node;\n \t\t\tcurrentElement.setTextContent(value);\n-\t\t}else{\n+\t\t} else {\n \t\t\tnode.setNodeValue(value);\n-\t\t}\t\t\n-\t\n-\t\t\n+\t\t}\n \t}\n-\t\n-\tprivate String removeNamespace(String elementName){\n+\n+\tprivate String removeNamespace(String elementName) {\n \t\treturn elementName.matches(\".*:.*\")?elementName.split(\":\")[1]:elementName;\n \t}\n-\t\n-\t\n-\t\n-\tprivate Node getNodeByXPath(String xpath,Node rootNode,Document doc,boolean createMultipleInstances){\n+\n+\n+\n+\tprivate Node getNodeByXPath(String xpath,Node rootNode,Document doc,boolean createMultipleInstances) {\n \t\tString[] xpathTokens = xpath.split(\"/\");\n-\t\t\n-\t\t\n+\n+\n \t\tNode currentNode =rootNode;\n \t\t// The first token is empty, the second is the root node\n-\t\tfor(int i =2; i<xpathTokens.length;i++){\n-\t\t\t\n+\t\tfor(int i =2; i<xpathTokens.length;i++) {\n+\n \t\t\tString axisName = removeNamespace(xpathTokens[i]);\n \n-\t\t\t\n-\t\t\tif(!axisName.startsWith(\"@\")){\n-\t\t\t\n-    \t\t\tNodeList list =currentNode.getChildNodes();\n-    \t\t\t\n-    \t\t\tNode selectedNode = null;\n-    \t\t\tif(!(createMultipleInstances && i==xpathTokens.length-1) ){\n-    \t\t\t\t// select the last child node only if we need to map to a single cell\n-\t    \t\t\tselectedNode = selectNode(axisName, list);\n+\n+\t\t\tif (!axisName.startsWith(\"@\")) {\n+\n+\t\t\t\tNodeList list =currentNode.getChildNodes();\n+\n+\t\t\t\tNode selectedNode = null;\n+\t\t\t\tif (!(createMultipleInstances && i==xpathTokens.length-1) ) {\n+\t\t\t\t\t// select the last child node only if we need to map to a single cell\n+\t\t\t\t\tselectedNode = selectNode(axisName, list);\n \t\t\t\t}\n-    \t\t\tif(selectedNode==null){\n-    \t\t\t\tselectedNode = createElement(doc, currentNode, axisName);\n-    \t\t\t}\n-    \t\t\tcurrentNode = selectedNode;\n-\t\t\t}else{\n-\t\t\t\t\n-\t\t\t\t\n+\t\t\t\tif (selectedNode==null) {\n+\t\t\t\t\tselectedNode = createElement(doc, currentNode, axisName);\n+\t\t\t\t}\n+\t\t\t\tcurrentNode = selectedNode;\n+\t\t\t} else {\n+\n+\n \t\t\t\tNode attribute = createAttribute(doc, currentNode, axisName);\n-\t\t\t\t\t\n-\t\t\t\tcurrentNode = attribute;\t\t\t\n-\t\t\t\t\n+\n+\t\t\t\tcurrentNode = attribute;\n \t\t\t}\n-\t\t\t\n \t\t}\n \t\treturn currentNode;\n \t}\n@@ -360,7 +345,7 @@ private Node createAttribute(Document doc, Node currentNode, String axisName) {\n \t\tString attributeName = axisName.substring(1);\n \t\tNamedNodeMap attributesMap = currentNode.getAttributes();\n \t\tNode attribute = attributesMap.getNamedItem(attributeName);\n-\t\tif(attribute==null){\n+\t\tif (attribute==null) {\n \t\t\tattribute = doc.createAttribute(attributeName);\n \t\t\tattributesMap.setNamedItem(attribute);\n \t\t}\n@@ -369,9 +354,9 @@ private Node createAttribute(Document doc, Node currentNode, String axisName) {\n \n \tprivate Node createElement(Document doc, Node currentNode, String axisName) {\n \t\tNode selectedNode;\n-\t\tif(isNamespaceDeclared()){\n+\t\tif (isNamespaceDeclared()) {\n \t\t\tselectedNode =doc.createElementNS(getNamespace(),axisName);\n-\t\t}else{\n+\t\t} else {\n \t\t\tselectedNode =doc.createElement(axisName);\n \t\t}\n \t\tcurrentNode.appendChild(selectedNode);\n@@ -380,123 +365,113 @@ private Node createElement(Document doc, Node currentNode, String axisName) {\n \n \tprivate Node selectNode(String axisName, NodeList list) {\n \t\tNode selectedNode = null;\n-\t\tfor(int j=0;j<list.getLength();j++){\n+\t\tfor(int j=0;j<list.getLength();j++) {\n \t\t\tNode node = list.item(j);\n-\t\t\tif(node.getNodeName().equals(axisName)){\n+\t\t\tif (node.getNodeName().equals(axisName)) {\n \t\t\t\tselectedNode=node;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn selectedNode;\n \t}\n-\t\n-\t\n-\tprivate boolean isNamespaceDeclared(){\n+\n+\n+\tprivate boolean isNamespaceDeclared() {\n \t\tString schemaNamespace = getNamespace();\n \t\treturn schemaNamespace!=null && !schemaNamespace.equals(\"\");\n \t}\n-\t\n-\tprivate String getNamespace(){\n+\n+\tprivate String getNamespace() {\n \t\treturn map.getCTSchema().getNamespace();\n \t}\n \n-\t\n+\n \t/**\n \t * Compares two xpaths to define an ordering according to the XML Schema\n-\t * \n+\t *\n \t */\n \tpublic int compare(String leftXpath, String rightXpath) {\n-\t\t\n-\t\tint result = 0; \n+\n+\t\tint result = 0;\n \t\tNode xmlSchema = map.getSchema();\n-\t\t\n-\t\t\n-\t\t\n-\t\t\n+\n+\n \t\tString[] leftTokens = leftXpath.split(\"/\");\n \t\tString[] rightTokens = rightXpath.split(\"/\");\n-\t\t\n+\n \t\tint minLenght = leftTokens.length< rightTokens.length? leftTokens.length : rightTokens.length;\n-\t\t\n+\n \t\tNode localComplexTypeRootNode = xmlSchema;\n-\t\t\n-\t\t\n-\t\tfor(int i =1;i <minLenght; i++){\n-\t\t\t\n+\n+\n+\t\tfor(int i =1;i <minLenght; i++) {\n+\n \t\t\tString leftElementName =leftTokens[i];\n \t\t\tString rightElementName = rightTokens[i];\n-\t\t\t\n-\t\t\tif(leftElementName.equals(rightElementName)){\n-\t\t\t\t\n-\t\t\t\t\n+\n+\t\t\tif (leftElementName.equals(rightElementName)) {\n+\n+\n \t\t\t\tNode complexType = getComplexTypeForElement(leftElementName, xmlSchema,localComplexTypeRootNode);\n-\t\t\t\tlocalComplexTypeRootNode = complexType;\t\t\t\n-\t\t\t}else{\n+\t\t\t\tlocalComplexTypeRootNode = complexType;\n+\t\t\t} else {\n \t\t\t\tint leftIndex = indexOfElementInComplexType(leftElementName,localComplexTypeRootNode);\n \t\t\t\tint rightIndex = indexOfElementInComplexType(rightElementName,localComplexTypeRootNode);\n-\t\t\t\tif(leftIndex!=-1 && rightIndex!=-1){\n-\t\t\t\t\tif( leftIndex < rightIndex){\n+\t\t\t\tif (leftIndex!=-1 && rightIndex!=-1) {\n+\t\t\t\t\tif ( leftIndex < rightIndex) {\n \t\t\t\t\t\tresult = -1;\n-\t\t\t\t\t}if( leftIndex > rightIndex){\n-\t\t\t\t\t\tresult = 1;\t\n+\t\t\t\t\t}if ( leftIndex > rightIndex) {\n+\t\t\t\t\t\tresult = 1;\n \t\t\t\t\t}\n-\t\t\t\t}else{\n+\t\t\t\t} else {\n \t\t\t\t\t// NOTE: the xpath doesn't match correctly in the schema\n \t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\n \t\t\t}\n-\t\t\t\n \t\t}\n-\t\t\n-\t\t\n-\t\t\n-\t\n+\n \t\treturn result;\n \t}\n-\t\n-\tprivate int indexOfElementInComplexType(String elementName,Node complexType){\n-\t\t\n+\n+\tprivate int indexOfElementInComplexType(String elementName,Node complexType) {\n+\n \t\tNodeList list  = complexType.getChildNodes();\n \t\tint indexOf = -1;\n-\t\t\n-\t\tfor(int i=0; i< list.getLength();i++){\n+\n+\t\tfor(int i=0; i< list.getLength();i++) {\n \t\t\tNode node = list.item(i);\n-\t\t\tif(node instanceof Element){\n-\t\t\t\tif(node.getLocalName().equals(\"element\")){\n+\t\t\tif (node instanceof Element) {\n+\t\t\t\tif (node.getLocalName().equals(\"element\")) {\n \t\t\t\t\tNode nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n-\t\t\t\t\tif(nameAttribute.getNodeValue().equals(removeNamespace(elementName))){\n+\t\t\t\t\tif (nameAttribute.getNodeValue().equals(removeNamespace(elementName))) {\n \t\t\t\t\t\tindexOf = i;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\t\t\t\n+\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n \t\treturn indexOf;\n-\t\t\n \t}\n-\t\n-\tprivate Node getComplexTypeForElement(String elementName,Node xmlSchema,Node localComplexTypeRootNode){\n+\n+\tprivate Node getComplexTypeForElement(String elementName,Node xmlSchema,Node localComplexTypeRootNode) {\n \t\tNode complexTypeNode = null;\n-\t\t\n+\n \t\tString elementNameWithoutNamespace = removeNamespace(elementName);\n \n-\t\t\n+\n \t\tNodeList  list  = localComplexTypeRootNode.getChildNodes();\n \t\tString complexTypeName = \"\";\n-\t\t\n \n-\t\t\n-\t\tfor(int i=0; i< list.getLength();i++){\n+\n+\n+\t\tfor(int i=0; i< list.getLength();i++) {\n \t\t\tNode node = list.item(i);\n-\t\t\tif( node instanceof Element){\n-\t\t\t\tif(node.getLocalName().equals(\"element\")){\n+\t\t\tif ( node instanceof Element) {\n+\t\t\t\tif (node.getLocalName().equals(\"element\")) {\n \t\t\t\t\tNode nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n-\t\t\t\t\tif(nameAttribute.getNodeValue().equals(elementNameWithoutNamespace)){\n+\t\t\t\t\tif (nameAttribute.getNodeValue().equals(elementNameWithoutNamespace)) {\n \t\t\t\t\t\tNode complexTypeAttribute = node.getAttributes().getNamedItem(\"type\");\n-\t\t\t\t\t\tif(complexTypeAttribute!=null){\n+\t\t\t\t\t\tif (complexTypeAttribute!=null) {\n \t\t\t\t\t\t\tcomplexTypeName = complexTypeAttribute.getNodeValue();\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n@@ -505,40 +480,35 @@ private Node getComplexTypeForElement(String elementName,Node xmlSchema,Node loc\n \t\t\t}\n \t\t}\n \t\t// Note: we expect that all the complex types are defined at root level\n-\t\tif(!complexTypeName.equals(\"\")){\n+\t\tif (!\"\".equals(complexTypeName)) {\n \t\t\tNodeList  complexTypeList  = xmlSchema.getChildNodes();\n-\t\t\tfor(int i=0; i< complexTypeList.getLength();i++){\n+\t\t\tfor(int i=0; i< complexTypeList.getLength();i++) {\n \t\t\t\tNode node = list.item(i);\n-\t\t\t\tif( node instanceof Element){\n-\t\t\t\t\tif(node.getLocalName().equals(\"complexType\")){\n+\t\t\t\tif ( node instanceof Element) {\n+\t\t\t\t\tif (node.getLocalName().equals(\"complexType\")) {\n \t\t\t\t\t\tNode nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n-\t\t\t\t\t\tif(nameAttribute.getNodeValue().equals(complexTypeName)){\n-\t\t\t\t\t\t\t\n+\t\t\t\t\t\tif (nameAttribute.getNodeValue().equals(complexTypeName)) {\n+\n \t\t\t\t\t\t\tNodeList complexTypeChildList  =node.getChildNodes();\n-\t\t\t\t\t\t\tfor(int j=0; j<complexTypeChildList.getLength();j++){\n+\t\t\t\t\t\t\tfor(int j=0; j<complexTypeChildList.getLength();j++) {\n \t\t\t\t\t\t\t\tNode sequence = complexTypeChildList.item(j);\n-\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\tif( sequence instanceof Element){\n-\t\t\t\t\t\t\t\t\tif(sequence.getLocalName().equals(\"sequence\")){\n+\n+\t\t\t\t\t\t\t\tif ( sequence instanceof Element) {\n+\t\t\t\t\t\t\t\t\tif (sequence.getLocalName().equals(\"sequence\")) {\n \t\t\t\t\t\t\t\t\t\tcomplexTypeNode = sequence;\n \t\t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif(complexTypeNode!=null){\n+\t\t\t\t\t\t\tif (complexTypeNode!=null) {\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\n+\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n \t\treturn complexTypeNode;\n-\t\t\n-\t\t\n \t}\n-\t\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "sha": "04272e36ccdeee7e2c123cf35ed7904a0c4aff45",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xwpf/usermodel/Borders.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/Borders.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/Borders.java",
                "patch": "@@ -612,12 +612,12 @@ public int getValue() {\n     private static Map<Integer, Borders> imap = new HashMap<Integer, Borders>();\n     static {\n         for (Borders p : values()) {\n-            imap.put(new Integer(p.getValue()), p);\n+            imap.put(Integer.valueOf(p.getValue()), p);\n         }\n     }\n \n     public static Borders valueOf(int type) {\n-        Borders pBorder = imap.get(new Integer(type));\n+        Borders pBorder = imap.get(Integer.valueOf(type));\n         if (pBorder == null) {\n             throw new IllegalArgumentException(\"Unknown paragraph border: \" + type);\n         }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xwpf/usermodel/Borders.java",
                "sha": "48ea33d2ac5b904f55e6c96b04365a8dc0421ac4",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xwpf/usermodel/TOC.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/TOC.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 8,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/TOC.java",
                "patch": "@@ -23,13 +23,13 @@\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.STTheme;\n \n public class TOC {\n-\t\n+\n \tCTSdtBlock block;\n-\t\n+\n \tpublic TOC() {\n \t\tthis(CTSdtBlock.Factory.newInstance());\n \t}\n-\t\n+\n \tpublic TOC(CTSdtBlock block) {\n \t\tthis.block = block;\n \t\tCTSdtPr sdtPr = block.addNewSdtPr();\n@@ -55,11 +55,11 @@ public TOC(CTSdtBlock block) {\n \t\tp.addNewPPr().addNewPStyle().setVal(\"TOCHeading\");\n \t\tp.addNewR().addNewT().set(\"Table of Contents\");\n \t}\n-\t\n+\n \tpublic CTSdtBlock getBlock() {\n \t\treturn this.block;\n \t}\n-\t\n+\n \tpublic void addRow(int level, String title, int page, String bookmarkRef) {\n \t\tCTSdtContentBlock contentBlock = this.block.getSdtContent();\n \t\tCTP p = contentBlock.addNewP();\n@@ -96,11 +96,9 @@ public void addRow(int level, String title, int page, String bookmarkRef) {\n \t\t// page number run\n \t\trun = p.addNewR();\n \t\trun.addNewRPr().addNewNoProof();\n-\t\trun.addNewT().set(new Integer(page).toString());\n+\t\trun.addNewT().set(Integer.valueOf(page).toString());\n \t\trun = p.addNewR();\n \t\trun.addNewRPr().addNewNoProof();\n \t\trun.addNewFldChar().setFldCharType(STFldCharType.END);\n-\t\t\n \t}\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xwpf/usermodel/TOC.java",
                "sha": "5f44cc638154f8e4f4cec1a378eaeee5c0ff2e76",
                "status": "modified"
            },
            {
                "additions": 24,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java",
                "changes": 49,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 25,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java",
                "patch": "@@ -66,7 +66,7 @@ public XWPFDocument(OPCPackage pkg) throws IOException {\n         //build a tree of POIXMLDocumentParts, this document being the root\n         load(XWPFFactory.getInstance());\n     }\n-    \n+\n     public XWPFDocument(InputStream is) throws IOException {\n         super(PackageHelper.open(is));\n \n@@ -97,7 +97,7 @@ protected void onDocumentRead() throws IOException {\n             initFootnotes();\n \n             // filling paragraph list\n-            for (CTP p : body.getPArray())\t{\n+            for (CTP p : body.getPArray())    {\n                 paragraphs.add(new XWPFParagraph(p, this));\n             }\n \n@@ -128,7 +128,7 @@ protected void onDocumentRead() throws IOException {\n     private void initHyperlinks(){\n         // Get the hyperlinks\n         // TODO: make me optional/separated in private function\n-        try\t{\n+        try    {\n             Iterator <PackageRelationship> relIter =\n                 getPackagePart().getRelationshipsByType(XWPFRelation.HYPERLINK.getRelation()).iterator();\n             while(relIter.hasNext()) {\n@@ -164,7 +164,7 @@ private void initFootnotes() throws XmlException, IOException {\n      */\n     protected static OPCPackage newPackage() {\n         try {\n-        \tOPCPackage pkg = OPCPackage.create(PackageHelper.createTempFile());\n+            OPCPackage pkg = OPCPackage.create(PackageHelper.createTempFile());\n             // Main part\n             PackagePartName corePartName = PackagingURIHelper.createPartName(XWPFRelation.DOCUMENT.getDefaultFileName());\n             // Create main part relationship\n@@ -355,40 +355,39 @@ public XWPFParagraph createParagraph(){\n \n     /**\n      * Create an empty table with one row and one column as default.\n-     * \n+     *\n      * @return a new table\n      */\n     public XWPFTable createTable(){\n         return new XWPFTable(this, ctDocument.getBody().addNewTbl());\n     }\n-    \n+\n     /**\n      * Create an empty table with a number of rows and cols specified\n      * @param rows\n      * @param cols\n      * @return table\n      */\n     public XWPFTable createTable(int rows, int cols) {\n-\treturn new XWPFTable(this, ctDocument.getBody().addNewTbl(), rows, cols);\n+    return new XWPFTable(this, ctDocument.getBody().addNewTbl(), rows, cols);\n     }\n-    \n+\n     public void createTOC() {\n-    \tCTSdtBlock block = this.getDocument().getBody().addNewSdt();\n-    \tTOC toc = new TOC(block);\n-    \tint i = 1;\n-    \tfor (Iterator<XWPFParagraph> iterator = getParagraphsIterator() ; iterator.hasNext() ; ) {\n-    \t\tXWPFParagraph par = iterator.next();\n-    \t\tString parStyle = par.getStyle();\n-    \t\tif (parStyle != null && parStyle.substring(0, 7).equals(\"Heading\")) {\n-    \t\t\ttry {\n-    \t\t\t\tint level = new Integer(parStyle.substring(\"Heading\".length()));\n-        \t\t\ttoc.addRow(level, par.getText(), 1, \"112723803\");\n-    \t\t\t}\n-    \t\t\tcatch (NumberFormatException e) {\n-    \t\t\t\te.printStackTrace();\n-    \t\t\t}\n-    \t\t}\n-    \t}\n+        CTSdtBlock block = this.getDocument().getBody().addNewSdt();\n+        TOC toc = new TOC(block);\n+        int i = 1;\n+        for (Iterator<XWPFParagraph> iterator = getParagraphsIterator() ; iterator.hasNext() ; ) {\n+            XWPFParagraph par = iterator.next();\n+            String parStyle = par.getStyle();\n+            if (parStyle != null && parStyle.substring(0, 7).equals(\"Heading\")) {\n+                try {\n+                    int level = Integer.valueOf(parStyle.substring(\"Heading\".length()));\n+                    toc.addRow(level, par.getText(), 1, \"112723803\");\n+                }\n+                catch (NumberFormatException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n     }\n }\n-",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFDocument.java",
                "sha": "19faaf00856ed177ed79534dc686914e8c236f86",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/extractor/WordDocument.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdf/extractor/WordDocument.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hdf/extractor/WordDocument.java",
                "patch": "@@ -394,7 +394,7 @@ private void findFormatting(byte[] tableStream, int charOffset,\n \n               byte[] chpx = new byte[size];\n               System.arraycopy(fkp, ++chpxOffset, chpx, 0, size);\n-              //_papTable.put(new Integer(fcStart), papx);\n+              //_papTable.put(Integer.valueOf(fcStart), papx);\n               _characterTable.add(new ChpxNode(fcStart, fcEnd, chpx));\n           }\n \n@@ -734,12 +734,12 @@ private int calculateHeaderHeight(int start, int end, int pageWidth)\n         lineWidth += 10 * tempString.length();//metrics.stringWidth(tempString);\n         if(lineWidth > pageWidth)\n         {\n-          lineHeights.add(new Integer(maxHeight));\n+          lineHeights.add(Integer.valueOf(maxHeight));\n           maxHeight = 0;\n           lineWidth = 0;\n         }\n       }\n-      lineHeights.add(new Integer(maxHeight));\n+      lineHeights.add(Integer.valueOf(maxHeight));\n     }\n     int sum = 0;\n     size = lineHeights.size();",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/extractor/WordDocument.java",
                "sha": "3a4651d4f67cb475438d64b11dd6d321479ea38d",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/extractor/data/ListTables.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdf/extractor/data/ListTables.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/scratchpad/src/org/apache/poi/hdf/extractor/data/ListTables.java",
                "patch": "@@ -51,14 +51,14 @@ public LVL getLevel(int list, int level)\n         LFOLVL lfolvl = override._levels[x];\n         if(lfolvl._fFormatting)\n         {\n-          LST lst = (LST)_lists.get(new Integer(override._lsid));\n+          LST lst = (LST)_lists.get(Integer.valueOf(override._lsid));\n           LVL lvl = lfolvl._override;\n           lvl._istd = Utils.convertBytesToShort(lst._rgistd, level * 2);\n           return lvl;\n         }\n         else if(lfolvl._fStartAt)\n         {\n-          LST lst = (LST)_lists.get(new Integer(override._lsid));\n+          LST lst = (LST)_lists.get(Integer.valueOf(override._lsid));\n           LVL lvl = lst._levels[level];\n           LVL newLvl = (LVL)lvl.clone();\n           newLvl._istd = Utils.convertBytesToShort(lst._rgistd, level * 2);\n@@ -68,7 +68,7 @@ else if(lfolvl._fStartAt)\n       }\n     }\n \n-    LST lst = (LST)_lists.get(new Integer(override._lsid));\n+    LST lst = (LST)_lists.get(Integer.valueOf(override._lsid));\n     LVL lvl = lst._levels[level];\n     lvl._istd = Utils.convertBytesToShort(lst._rgistd, level * 2);\n     return lvl;\n@@ -89,7 +89,7 @@ private void initLST(byte[] plcflst)\n       byte code = plcflst[2 + 26 + (x * 28)];\n       lst._fSimpleList = StyleSheet.getFlag(code & 0x01);\n       //lstArray[x] = lst;\n-      _lists.put(new Integer(lst._lsid), lst);\n+      _lists.put(Integer.valueOf(lst._lsid), lst);\n \n       if(lst._fSimpleList)\n       {",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/extractor/data/ListTables.java",
                "sha": "d9a8d481b194386c4b2b30d24bdd62a7af4f7ce0",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/extractor/util/BTreeSet.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdf/extractor/util/BTreeSet.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hdf/extractor/util/BTreeSet.java",
                "patch": "@@ -161,7 +161,7 @@ private BTreeNode firstNode() {\n \n             while (temp._entries[0].child != null) {\n                 temp = temp._entries[0].child;\n-                parentIndex.push(new Integer(0));\n+                parentIndex.push(Integer.valueOf(0));\n             }\n \n             return temp;\n@@ -193,11 +193,11 @@ else if (!parentIndex.empty()) { //All elements have been returned, return succe\n \n             // else - You're not a leaf so simply find and return the successor of lastReturned\n             currentNode = currentNode._entries[index].child;\n-            parentIndex.push(new Integer(index));\n+            parentIndex.push(Integer.valueOf(index));\n \n             while (currentNode._entries[0].child != null) {\n                 currentNode = currentNode._entries[0].child;\n-                parentIndex.push(new Integer(0));\n+                parentIndex.push(Integer.valueOf(0));\n             }\n \n             index = 1;",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/extractor/util/BTreeSet.java",
                "sha": "39e8d1e8680314b00dd487722cd26dbb57112a6f",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/model/HDFObjectFactory.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdf/model/HDFObjectFactory.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hdf/model/HDFObjectFactory.java",
                "patch": "@@ -345,7 +345,7 @@ private void initParagraphProperties(int parOffset, PlexOfCps parPlcf, int charO\n \n                 byte[] chpx = new byte[size];\n                 System.arraycopy(fkp, ++chpxOffset, chpx, 0, size);\n-                //_papTable.put(new Integer(fcStart), papx);\n+                //_papTable.put(Integer.valueOf(fcStart), papx);\n                 _characterRuns.add(new ChpxNode(fcStart, fcEnd, chpx));\n             }\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/model/HDFObjectFactory.java",
                "sha": "f137944a66404fb58ad39144170a943cc5190f06",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/model/hdftypes/ListTables.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdf/model/hdftypes/ListTables.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/scratchpad/src/org/apache/poi/hdf/model/hdftypes/ListTables.java",
                "patch": "@@ -51,14 +51,14 @@ public LVL getLevel(int list, int level)\n         LFOLVL lfolvl = override._levels[x];\n         if(lfolvl._fFormatting)\n         {\n-          LST lst = (LST)_lists.get(new Integer(override._lsid));\n+          LST lst = (LST)_lists.get(Integer.valueOf(override._lsid));\n           LVL lvl = lfolvl._override;\n           lvl._istd = Utils.convertBytesToShort(lst._rgistd, level * 2);\n           return lvl;\n         }\n         else if(lfolvl._fStartAt)\n         {\n-          LST lst = (LST)_lists.get(new Integer(override._lsid));\n+          LST lst = (LST)_lists.get(Integer.valueOf(override._lsid));\n           LVL lvl = lst._levels[level];\n           LVL newLvl = (LVL)lvl.clone();\n           newLvl._istd = Utils.convertBytesToShort(lst._rgistd, level * 2);\n@@ -68,7 +68,7 @@ else if(lfolvl._fStartAt)\n       }\n     }\n \n-    LST lst = (LST)_lists.get(new Integer(override._lsid));\n+    LST lst = (LST)_lists.get(Integer.valueOf(override._lsid));\n     LVL lvl = lst._levels[level];\n     lvl._istd = Utils.convertBytesToShort(lst._rgistd, level * 2);\n     return lvl;\n@@ -89,7 +89,7 @@ private void initLST(byte[] plcflst)\n       byte code = plcflst[2 + 26 + (x * 28)];\n       lst._fSimpleList = StyleSheet.getFlag(code & 0x01);\n       //lstArray[x] = lst;\n-      _lists.put(new Integer(lst._lsid), lst);\n+      _lists.put(Integer.valueOf(lst._lsid), lst);\n \n       if(lst._fSimpleList)\n       {",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/model/hdftypes/ListTables.java",
                "sha": "8107210a6722e0cd2cd20008e340b6d87da41bb4",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/model/util/BTreeSet.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdf/model/util/BTreeSet.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hdf/model/util/BTreeSet.java",
                "patch": "@@ -235,7 +235,7 @@ private BTreeNode firstNode()\n             while (temp.entries[0].child != null)\n             {\n                 temp = temp.entries[0].child;\n-                parentIndex.push(new Integer(0));\n+                parentIndex.push(Integer.valueOf(0));\n             }\n \n             return temp;\n@@ -272,12 +272,12 @@ else if (!parentIndex.empty())\n \n             // else - You're not a leaf so simply find and return the successor of lastReturned\n             currentNode = currentNode.entries[index].child;\n-            parentIndex.push(new Integer(index));\n+            parentIndex.push(Integer.valueOf(index));\n \n             while (currentNode.entries[0].child != null)\n             {\n                 currentNode = currentNode.entries[0].child;\n-                parentIndex.push(new Integer(0));\n+                parentIndex.push(Integer.valueOf(0));\n             }\n \n             index = 1;",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdf/model/util/BTreeSet.java",
                "sha": "a9241f914e54c045db92302332296f5b7ca26733",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdgf/chunks/Chunk.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdgf/chunks/Chunk.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 5,
                "filename": "src/scratchpad/src/org/apache/poi/hdgf/chunks/Chunk.java",
                "patch": "@@ -166,10 +166,10 @@ protected void processCommands() {\n \t\t\t// Types 0->7 = a flat at bit 0->7\n \t\t\tcase 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n \t\t\t\tint val = contents[offset] & (1<<type);\n-\t\t\t\tcommand.value = new Boolean( (val > 0) );\n+\t\t\t\tcommand.value = Boolean.valueOf(val > 0);\n \t\t\t\tbreak;\n \t\t\tcase 8:\n-\t\t\t\tcommand.value = new Byte( contents[offset] );\n+\t\t\t\tcommand.value = Byte.valueOf(contents[offset]);\n \t\t\t\tbreak;\n \t\t\tcase 9:\n \t\t\t\tcommand.value = new Double(\n@@ -195,12 +195,12 @@ protected void processCommands() {\n \t\t\t\tcommand.value = StringUtil.getFromUnicodeLE(contents, startsAt, strLen);\n \t\t\t\tbreak;\n \t\t\tcase 25:\n-\t\t\t\tcommand.value = new Short(\n+\t\t\t\tcommand.value = Short.valueOf(\n \t\t\t\t\tLittleEndian.getShort(contents, offset)\n \t\t\t\t);\n \t\t\t\tbreak;\n \t\t\tcase 26:\n-\t\t\t\tcommand.value = new Integer(\n+\t\t\t\tcommand.value = Integer.valueOf(\n \t\t\t\t\t\tLittleEndian.getInt(contents, offset)\n \t\t\t\t);\n \t\t\t\tbreak;\n@@ -273,7 +273,7 @@ private BlockOffsetCommand(CommandDefinition definition) {\n \t\t}\n \t\tprivate void setOffset(int offset) {\n \t\t\tthis.offset = offset;\n-\t\t\tvalue = new Integer(offset);\n+\t\t\tvalue = Integer.valueOf(offset);\n \t\t}\n \t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdgf/chunks/Chunk.java",
                "sha": "64314ee5f0f16a523891d8611b467c82cb82b104",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdgf/chunks/ChunkFactory.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hdgf/chunks/ChunkFactory.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hdgf/chunks/ChunkFactory.java",
                "patch": "@@ -98,7 +98,7 @@ private void processChunkParseCommands() throws IOException {\n \t\t\t\tdefsL.toArray(new CommandDefinition[defsL.size()]);\n \n \t\t\t// Add to the hashtable\n-\t\t\tchunkCommandDefinitions.put(new Integer(chunkType), defs);\n+\t\t\tchunkCommandDefinitions.put(Integer.valueOf(chunkType), defs);\n \t\t}\n \t\tinp.close();\n \t\tcpd.close();\n@@ -171,7 +171,7 @@ public Chunk createChunk(byte[] data, int offset) {\n \n \t\t// Feed in the stuff from  chunks_parse_cmds.tbl\n \t\tCommandDefinition[] defs = (CommandDefinition[])\n-\t\t\tchunkCommandDefinitions.get(new Integer(header.getType()));\n+\t\t\tchunkCommandDefinitions.get(Integer.valueOf(header.getType()));\n \t\tif(defs == null) defs = new CommandDefinition[0];\n \t\tchunk.commandDefinitions = defs;\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hdgf/chunks/ChunkFactory.java",
                "sha": "3bc35883d68ca3ddf1efe4a967bab49f94bc9473",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/EncryptedSlideShow.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/EncryptedSlideShow.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/EncryptedSlideShow.java",
                "patch": "@@ -117,7 +117,7 @@ public static DocumentEncryptionAtom fetchDocumentEncryptionAtom(HSLFSlideShow h\n \n \t\t\tint offset = (\n \t\t\t\t\t(Integer)pph.getSlideLocationsLookup().get(\n-\t\t\t\t\t\t\tnew Integer(maxSlideId)\n+\t\t\t\t\t\t\tInteger.valueOf(maxSlideId)\n \t\t\t\t\t) ).intValue();\n \t\t\tRecord r3 = Record.buildRecordAtOffset(\n \t\t\t\t\thss.getUnderlyingBytes(),",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/EncryptedSlideShow.java",
                "sha": "00152134f693a0fb2a0587f0383902648b53d5bf",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java",
                "patch": "@@ -231,11 +231,11 @@ private void buildRecords()\n         HashMap offset2id = new HashMap();\n         while (usrOffset != 0){\n             UserEditAtom usr = (UserEditAtom) Record.buildRecordAtOffset(docstream, usrOffset);\n-            lst.add(new Integer(usrOffset));\n+            lst.add(Integer.valueOf(usrOffset));\n             int psrOffset = usr.getPersistPointersOffset();\n \n             PersistPtrHolder ptr = (PersistPtrHolder)Record.buildRecordAtOffset(docstream, psrOffset);\n-            lst.add(new Integer(psrOffset));\n+            lst.add(Integer.valueOf(psrOffset));\n             Hashtable entries = ptr.getSlideLocationsLookup();\n             for (Iterator it = entries.keySet().iterator(); it.hasNext(); ) {\n                 Integer id = (Integer)it.next();\n@@ -401,7 +401,7 @@ public void write(OutputStream out, boolean preserveNodes) throws IOException {\n                 int oldPos = pdr.getLastOnDiskOffset();\n                 int newPos = baos.size();\n                 pdr.setLastOnDiskOffset(newPos);\n-                oldToNewPositions.put(new Integer(oldPos),new Integer(newPos));\n+                oldToNewPositions.put(Integer.valueOf(oldPos),Integer.valueOf(newPos));\n                 //System.out.println(oldPos + \" -> \" + newPos);\n             }\n \n@@ -438,7 +438,7 @@ public void write(OutputStream out, boolean preserveNodes) throws IOException {\n \n         // Update and write out the Current User atom\n         int oldLastUserEditAtomPos = (int)currentUser.getCurrentEditOffset();\n-        Integer newLastUserEditAtomPos = (Integer)oldToNewPositions.get(new Integer(oldLastUserEditAtomPos));\n+        Integer newLastUserEditAtomPos = (Integer)oldToNewPositions.get(Integer.valueOf(oldLastUserEditAtomPos));\n         if(newLastUserEditAtomPos == null) {\n             throw new HSLFException(\"Couldn't find the new location of the UserEditAtom that used to be at \" + oldLastUserEditAtomPos);\n         }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java",
                "sha": "17d999991f626f1ef3b9567c4f2aaffc345a9ad7",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/dev/SlideIdListing.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/dev/SlideIdListing.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/dev/SlideIdListing.java",
                "patch": "@@ -124,7 +124,7 @@ public static void main(String[] args) throws Exception {\n \t\t\t\tint[] sheetIDs = pph.getKnownSlideIDs();\n \t\t\t\tHashtable sheetOffsets = pph.getSlideLocationsLookup();\n \t\t\t\tfor(int j=0; j<sheetIDs.length; j++) {\n-\t\t\t\t\tInteger id = new Integer(sheetIDs[j]);\n+\t\t\t\t\tInteger id = Integer.valueOf(sheetIDs[j]);\n \t\t\t\t\tInteger offset = (Integer)sheetOffsets.get(id);\n \n \t\t\t\t\tSystem.out.println(\"  Knows about sheet \" + id);",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/dev/SlideIdListing.java",
                "sha": "48d8352eaf19de25ecf6ad5fd8f0404579871d87",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/dev/UserEditAndPersistListing.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/dev/UserEditAndPersistListing.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/dev/UserEditAndPersistListing.java",
                "patch": "@@ -63,7 +63,7 @@ public static void main(String[] args) throws Exception {\n \t\t\t\tint[] sheetIDs = pph.getKnownSlideIDs();\n \t\t\t\tHashtable sheetOffsets = pph.getSlideLocationsLookup();\n \t\t\t\tfor(int j=0; j<sheetIDs.length; j++) {\n-\t\t\t\t\tInteger id = new Integer(sheetIDs[j]);\n+\t\t\t\t\tInteger id = Integer.valueOf(sheetIDs[j]);\n \t\t\t\t\tInteger offset = (Integer)sheetOffsets.get(id);\n \n \t\t\t\t\tSystem.out.println(\"  Knows about sheet \" + id);",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/dev/UserEditAndPersistListing.java",
                "sha": "300d315b7ffcf2a0cfed826bce27bf9b8e38eeac",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/extractor/PowerPointExtractor.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/extractor/PowerPointExtractor.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/extractor/PowerPointExtractor.java",
                "patch": "@@ -237,7 +237,7 @@ public String getText(boolean getSlideText, boolean getNoteText, boolean getComm\n \t\t\t\tif (notes == null) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tInteger id = new Integer(notes._getSheetNumber());\n+\t\t\t\tInteger id = Integer.valueOf(notes._getSheetNumber());\n \t\t\t\tif (seenNotes.contains(id)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/extractor/PowerPointExtractor.java",
                "sha": "97c7d71f6ade00d8fdacfb0d5f7d6a85d5af2dc2",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/model/ShapeTypes.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/ShapeTypes.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/ShapeTypes.java",
                "patch": "@@ -34,7 +34,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * @return  the name of the shape\n      */\n     public static String typeName(int type) {\n-        String name = (String)types.get(new Integer(type));\n+        String name = (String)types.get(Integer.valueOf(type));\n         return name;\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/model/ShapeTypes.java",
                "sha": "7b5a17deccc1aeb005c6390835be0ba52306ca2f",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/CString.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/CString.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/CString.java",
                "patch": "@@ -38,7 +38,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t/** The bytes that make up the text */\n \tprivate byte[] _text;\n \n-\t/** Grabs the text. */\n+\t/** Grabs the text. Never <code>null</code> */\n \tpublic String getText() {\n \t\treturn StringUtil.getFromUnicodeLE(_text);\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/CString.java",
                "sha": "0f088d3887b172e74131e21c39c0911ececbea98",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/PersistPtrHolder.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/PersistPtrHolder.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 6,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/PersistPtrHolder.java",
                "patch": "@@ -98,10 +98,10 @@ public void addSlideLookup(int slideID, int posOnDisk) {\n \t\tSystem.arraycopy(_ptrData,0,newPtrData,0,_ptrData.length);\n \n \t\t// Add to the slide location lookup hash\n-\t\t_slideLocations.put(new Integer(slideID), new Integer(posOnDisk));\n+\t\t_slideLocations.put(Integer.valueOf(slideID), Integer.valueOf(posOnDisk));\n \t\t// Add to the ptrData offset lookup hash\n-\t\t_slideOffsetDataLocation.put(new Integer(slideID),\n-\t\t\t\tnew Integer(_ptrData.length + 4));\n+\t\t_slideOffsetDataLocation.put(Integer.valueOf(slideID),\n+\t\t\t\tInteger.valueOf(_ptrData.length + 4));\n \n \t\t// Build the info block\n \t\t// First 20 bits = offset number = slide ID\n@@ -163,8 +163,8 @@ protected PersistPtrHolder(byte[] source, int start, int len) {\n \t\t\tfor(int i=0; i<offset_count; i++) {\n \t\t\t\tint sheet_no = offset_no + i;\n \t\t\t\tlong sheet_offset = LittleEndian.getUInt(_ptrData,pos);\n-\t\t\t\t_slideLocations.put(new Integer(sheet_no), new Integer((int)sheet_offset));\n-\t\t\t\t_slideOffsetDataLocation.put(new Integer(sheet_no), new Integer(pos));\n+\t\t\t\t_slideLocations.put(Integer.valueOf(sheet_no), Integer.valueOf((int)sheet_offset));\n+\t\t\t\t_slideOffsetDataLocation.put(Integer.valueOf(sheet_no), Integer.valueOf(pos));\n \n \t\t\t\t// Wind on by 4 bytes per sheet found\n \t\t\t\tpos += 4;\n@@ -188,7 +188,7 @@ public void updateOtherRecordReferences(Hashtable oldToNewReferencesLookup) {\n \t\t// Find where they used to live, and where they now live\n \t\t// Then, update the right bit of _ptrData with their new location\n \t\tfor(int i=0; i<slideIDs.length; i++) {\n-\t\t\tInteger id = new Integer(slideIDs[i]);\n+\t\t\tInteger id = Integer.valueOf(slideIDs[i]);\n \t\t\tInteger oldPos = (Integer)_slideLocations.get(id);\n \t\t\tInteger newPos = (Integer)oldToNewReferencesLookup.get(oldPos);\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/PersistPtrHolder.java",
                "sha": "cc514ed46d9154fe697463778b32a6f0831b9779",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/Record.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/Record.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/Record.java",
                "patch": "@@ -179,7 +179,7 @@ public static Record createRecordForType(long type, byte[] b, int start, int len\n \t\t\t// Grab the right constructor\n \t\t\tjava.lang.reflect.Constructor con = c.getDeclaredConstructor(new Class[] { byte[].class, Integer.TYPE, Integer.TYPE });\n \t\t\t// Instantiate\n-\t\t\ttoReturn = (Record)(con.newInstance(new Object[] { b, new Integer(start), new Integer(len) }));\n+\t\t\ttoReturn = (Record)(con.newInstance(new Object[] { b, Integer.valueOf(start), Integer.valueOf(len) }));\n \t\t} catch(InstantiationException ie) {\n \t\t\tthrow new RuntimeException(\"Couldn't instantiate the class for type with id \" + type + \" on class \" + c + \" : \" + ie, ie);\n \t\t} catch(java.lang.reflect.InvocationTargetException ite) {",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/Record.java",
                "sha": "d6280cb0f9d468007e080ce14e369ac9118e4dd7",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/RecordContainer.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/RecordContainer.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/RecordContainer.java",
                "patch": "@@ -36,7 +36,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n public abstract class RecordContainer extends Record\n {\n \tprotected Record[] _children;\n-\tprivate Boolean changingChildRecordsLock = new Boolean(true);\n+\tprivate Boolean changingChildRecordsLock = Boolean.TRUE;\n \n \t/**\n \t * Return any children",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/RecordContainer.java",
                "sha": "509c891ce7394fb715f1d8d965654a1a69ea1fcb",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java",
                "patch": "@@ -217,7 +217,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * @return name of the record\n      */\n     public static String recordName(int type) {\n-        String name = (String)typeToName.get(new Integer(type));\n+        String name = (String)typeToName.get(Integer.valueOf(type));\n         if (name == null) name = \"Unknown\" + type;\n         return name;\n     }\n@@ -232,7 +232,7 @@ public static String recordName(int type) {\n      * @return class to handle the record, or null if an unknown (eg Escher) record\n      */\n \tpublic static Class recordHandlingClass(int type) {\n-\t\tClass c = (Class)typeToClass.get(new Integer(type));\n+\t\tClass c = (Class)typeToClass.get(Integer.valueOf(type));\n \t\treturn c;\n \t}\n \n@@ -252,7 +252,7 @@ public static Class recordHandlingClass(int type) {\n \t\t\t\tif (val instanceof Type) {\n \t\t\t\t\tType t = (Type)val;\n \t\t\t\t\tClass c = t.handlingClass;\n-\t\t\t\t\tInteger id = new Integer(t.typeID);\n+\t\t\t\t\tInteger id = Integer.valueOf(t.typeID);\n \t\t\t\t\tif(c == null) { c = UnknownRecordPlaceholder.class; }\n \n                     typeToName.put(id, f[i].getName());",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java",
                "sha": "68ebf98a31b463ace8dc9bcd3b3683cc343aa4aa",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/UserEditAtom.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/UserEditAtom.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/UserEditAtom.java",
                "patch": "@@ -124,15 +124,15 @@ protected UserEditAtom(byte[] source, int start, int len) {\n \tpublic void updateOtherRecordReferences(Hashtable oldToNewReferencesLookup) {\n \t\t// Look up the new positions of our preceding UserEditAtomOffset\n \t\tif(lastUserEditAtomOffset != 0) {\n-\t\t\tInteger newLocation = (Integer)oldToNewReferencesLookup.get(new Integer(lastUserEditAtomOffset));\n+\t\t\tInteger newLocation = (Integer)oldToNewReferencesLookup.get(Integer.valueOf(lastUserEditAtomOffset));\n \t\t\tif(newLocation == null) {\n \t\t\t\tthrow new RuntimeException(\"Couldn't find the new location of the UserEditAtom that used to be at \" + lastUserEditAtomOffset);\n \t\t\t}\n \t\t\tlastUserEditAtomOffset = newLocation.intValue();\n \t\t}\n \n \t\t// Ditto for our PersistPtr\n-\t\tInteger newLocation = (Integer)oldToNewReferencesLookup.get(new Integer(persistPointersOffset));\n+\t\tInteger newLocation = (Integer)oldToNewReferencesLookup.get(Integer.valueOf(persistPointersOffset));\n \t\tif(newLocation == null) {\n \t\t\tthrow new RuntimeException(\"Couldn't find the new location of the PersistPtr that used to be at \" + persistPointersOffset);\n \t\t}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/record/UserEditAtom.java",
                "sha": "971fbf4c6a581c3d6b2c30f6c42a1e1e270a1b7d",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 9,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java",
                "patch": "@@ -162,7 +162,7 @@ private void findMostRecentCoreRecords() {\n \t\t\t\t// PersistPtr, remove their old positions\n \t\t\t\tint[] ids = pph.getKnownSlideIDs();\n \t\t\t\tfor (int j = 0; j < ids.length; j++) {\n-\t\t\t\t\tInteger id = new Integer(ids[j]);\n+\t\t\t\t\tInteger id = Integer.valueOf(ids[j]);\n \t\t\t\t\tif (mostRecentByBytes.containsKey(id)) {\n \t\t\t\t\t\tmostRecentByBytes.remove(id);\n \t\t\t\t\t}\n@@ -171,7 +171,7 @@ private void findMostRecentCoreRecords() {\n \t\t\t\t// Now, update the byte level locations with their latest values\n \t\t\t\tHashtable thisSetOfLocations = pph.getSlideLocationsLookup();\n \t\t\t\tfor (int j = 0; j < ids.length; j++) {\n-\t\t\t\t\tInteger id = new Integer(ids[j]);\n+\t\t\t\t\tInteger id = Integer.valueOf(ids[j]);\n \t\t\t\t\tmostRecentByBytes.put(id, thisSetOfLocations.get(id));\n \t\t\t\t}\n \t\t\t}\n@@ -192,18 +192,18 @@ private void findMostRecentCoreRecords() {\n \t\t}\n \t\tArrays.sort(allIDs);\n \t\tfor (int i = 0; i < allIDs.length; i++) {\n-\t\t\t_sheetIdToCoreRecordsLookup.put(new Integer(allIDs[i]), new Integer(i));\n+\t\t\t_sheetIdToCoreRecordsLookup.put(Integer.valueOf(allIDs[i]), Integer.valueOf(i));\n \t\t}\n \n \t\t// Now convert the byte offsets back into record offsets\n \t\tfor (int i = 0; i < _records.length; i++) {\n \t\t\tif (_records[i] instanceof PositionDependentRecord) {\n \t\t\t\tPositionDependentRecord pdr = (PositionDependentRecord) _records[i];\n-\t\t\t\tInteger recordAt = new Integer(pdr.getLastOnDiskOffset());\n+\t\t\t\tInteger recordAt = Integer.valueOf(pdr.getLastOnDiskOffset());\n \n \t\t\t\t// Is it one we care about?\n \t\t\t\tfor (int j = 0; j < allIDs.length; j++) {\n-\t\t\t\t\tInteger thisID = new Integer(allIDs[j]);\n+\t\t\t\t\tInteger thisID = Integer.valueOf(allIDs[j]);\n \t\t\t\t\tInteger thatRecordAt = (Integer) mostRecentByBytes.get(thisID);\n \n \t\t\t\t\tif (thatRecordAt.equals(recordAt)) {\n@@ -258,7 +258,7 @@ private Record getCoreRecordForSAS(SlideAtomsSet sas) {\n \t *            the refID\n \t */\n \tprivate Record getCoreRecordForRefID(int refID) {\n-\t\tInteger coreRecordId = (Integer) _sheetIdToCoreRecordsLookup.get(new Integer(refID));\n+\t\tInteger coreRecordId = (Integer) _sheetIdToCoreRecordsLookup.get(Integer.valueOf(refID));\n \t\tif (coreRecordId != null) {\n \t\t\tRecord r = _mostRecentCoreRecords[coreRecordId.intValue()];\n \t\t\treturn r;\n@@ -364,8 +364,8 @@ private void buildSlidesAndNotes() {\n \n \t\t\t\t\t// Record the match between slide id and these notes\n \t\t\t\t\tSlidePersistAtom spa = notesSets[i].getSlidePersistAtom();\n-\t\t\t\t\tInteger slideId = new Integer(spa.getSlideIdentifier());\n-\t\t\t\t\tslideIdToNotes.put(slideId, new Integer(i));\n+\t\t\t\t\tInteger slideId = Integer.valueOf(spa.getSlideIdentifier());\n+\t\t\t\t\tslideIdToNotes.put(slideId, Integer.valueOf(i));\n \t\t\t\t} else {\n \t\t\t\t\tlogger.log(POILogger.ERROR, \"A Notes SlideAtomSet at \" + i\n \t\t\t\t\t\t\t+ \" said its record was at refID \"\n@@ -422,7 +422,7 @@ private void buildSlidesAndNotes() {\n \t\t\t// 0 if slide has no notes.\n \t\t\tint noteId = slidesRecords[i].getSlideAtom().getNotesID();\n \t\t\tif (noteId != 0) {\n-\t\t\t\tInteger notesPos = (Integer) slideIdToNotes.get(new Integer(noteId));\n+\t\t\t\tInteger notesPos = (Integer) slideIdToNotes.get(Integer.valueOf(noteId));\n \t\t\t\tif (notesPos != null)\n \t\t\t\t\tnotes = _notes[notesPos.intValue()];\n \t\t\t\telse",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hslf/usermodel/SlideShow.java",
                "sha": "8214f0d36c52bc2613dfdb4b2d88d9273dc728a2",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/FIBFieldHandler.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/FIBFieldHandler.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/FIBFieldHandler.java",
                "patch": "@@ -146,7 +146,7 @@ public FIBFieldHandler(byte[] mainStream, int offset, byte[] tableStream,\n       fieldOffset += LittleEndian.INT_SIZE;\n       int dsSize = LittleEndian.getInt(mainStream, fieldOffset);\n \n-      if (offsetList.contains(new Integer(x)) ^ areKnown)\n+      if (offsetList.contains(Integer.valueOf(x)) ^ areKnown)\n       {\n         if (dsSize > 0)\n         {\n@@ -160,7 +160,7 @@ public FIBFieldHandler(byte[] mainStream, int offset, byte[] tableStream,\n           {\n             UnhandledDataStructure unhandled = new UnhandledDataStructure(\n               tableStream, dsOffset, dsSize);\n-            _unknownMap.put(new Integer(x), unhandled);\n+            _unknownMap.put(Integer.valueOf(x), unhandled);\n           }\n         }\n       }\n@@ -208,7 +208,7 @@ void writeTo(byte[] mainStream, int offset, HWPFOutputStream tableStream)\n \n     for (int x = 0; x < length; x++)\n     {\n-      UnhandledDataStructure ds = (UnhandledDataStructure)_unknownMap.get(new Integer(x));\n+      UnhandledDataStructure ds = (UnhandledDataStructure)_unknownMap.get(Integer.valueOf(x));\n       if (ds != null)\n       {\n         LittleEndian.putInt(mainStream, offset, tableStream.getOffset());",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/FIBFieldHandler.java",
                "sha": "52e9bbd51c16ff6fb17ef2346669f683b845ac7d",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/FSPATable.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/FSPATable.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/FSPATable.java",
                "patch": "@@ -48,13 +48,13 @@ public FSPATable(byte[] tableStream, int fcPlcspa, int lcbPlcspa, List tpt)\n             FSPA fspa = new FSPA(property.getBytes(), 0);\n \n             _shapes.add(fspa);\n-            _shapeIndexesByPropertyStart.put(new Integer(property.getStart()), new Integer(i));\n+            _shapeIndexesByPropertyStart.put(Integer.valueOf(property.getStart()), Integer.valueOf(i));\n         }\n     }\n \n     public FSPA getFspaFromCp(int cp)\n     {\n-        Integer idx = (Integer)_shapeIndexesByPropertyStart.get(new Integer(cp));\n+        Integer idx = (Integer)_shapeIndexesByPropertyStart.get(Integer.valueOf(cp));\n         if (idx == null) {\n             return null;\n         }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/FSPATable.java",
                "sha": "b1578e386976c4c671ec370dddadaffd2138f8f8",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/FileInformationBlock.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/FileInformationBlock.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 12,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/FileInformationBlock.java",
                "patch": "@@ -58,18 +58,18 @@ public FileInformationBlock(byte[] mainDocument)\n     public void fillVariableFields(byte[] mainDocument, byte[] tableStream)\n     {\n       HashSet fieldSet = new HashSet();\n-      fieldSet.add(new Integer(FIBFieldHandler.STSHF));\n-      fieldSet.add(new Integer(FIBFieldHandler.CLX));\n-      fieldSet.add(new Integer(FIBFieldHandler.DOP));\n-      fieldSet.add(new Integer(FIBFieldHandler.PLCFBTECHPX));\n-      fieldSet.add(new Integer(FIBFieldHandler.PLCFBTEPAPX));\n-      fieldSet.add(new Integer(FIBFieldHandler.PLCFSED));\n-      fieldSet.add(new Integer(FIBFieldHandler.PLCFLST));\n-      fieldSet.add(new Integer(FIBFieldHandler.PLFLFO));\n-      fieldSet.add(new Integer(FIBFieldHandler.PLCFFLDMOM));\n-      fieldSet.add(new Integer(FIBFieldHandler.STTBFFFN));\n-      fieldSet.add(new Integer(FIBFieldHandler.STTBSAVEDBY));\n-      fieldSet.add(new Integer(FIBFieldHandler.MODIFIED));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.STSHF));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.CLX));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.DOP));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.PLCFBTECHPX));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.PLCFBTEPAPX));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.PLCFSED));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.PLCFLST));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.PLFLFO));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.PLCFFLDMOM));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.STTBFFFN));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.STTBSAVEDBY));\n+      fieldSet.add(Integer.valueOf(FIBFieldHandler.MODIFIED));\n \n \n       _shortHandler = new FIBShortHandler(mainDocument);",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/FileInformationBlock.java",
                "sha": "6c09b49aca580109d29c0e340d78ec7273170178",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 5,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java",
                "patch": "@@ -58,7 +58,7 @@ public ListTables(byte[] tableStream, int lstOffset, int lfoOffset)\n     for (int x = 0; x < length; x++)\n     {\n       ListData lst = new ListData(tableStream, lstOffset);\n-      _listMap.put(new Integer(lst.getLsid()), lst);\n+      _listMap.put(Integer.valueOf(lst.getLsid()), lst);\n       lstOffset += LIST_DATA_SIZE;\n \n       int num = lst.numLevels();\n@@ -96,12 +96,12 @@ public ListTables(byte[] tableStream, int lstOffset, int lfoOffset)\n   public int addList(ListData lst, ListFormatOverride override)\n   {\n     int lsid = lst.getLsid();\n-    while (_listMap.get(new Integer(lsid)) != null)\n+    while (_listMap.get(Integer.valueOf(lsid)) != null)\n     {\n       lsid = lst.resetListID();\n       override.setLsid(lsid);\n     }\n-    _listMap.put(new Integer(lsid), lst);\n+    _listMap.put(Integer.valueOf(lsid), lst);\n     _overrideList.add(override);\n     return lsid;\n   }\n@@ -190,7 +190,7 @@ public int getOverrideIndexFromListID(int lstid)\n \n   public ListLevel getLevel(int listID, int level)\n   {\n-    ListData lst = (ListData)_listMap.get(new Integer(listID));\n+    ListData lst = (ListData)_listMap.get(Integer.valueOf(listID));\n     if(level < lst.numLevels()) {\n     \tListLevel lvl = lst.getLevels()[level];\n     \treturn lvl;\n@@ -201,7 +201,7 @@ public ListLevel getLevel(int listID, int level)\n \n   public ListData getListData(int listID)\n   {\n-    return (ListData) _listMap.get(new Integer(listID));\n+    return (ListData) _listMap.get(Integer.valueOf(listID));\n   }\n \n   public boolean equals(Object obj)",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java",
                "sha": "fd72d42270e39b71baa0700371ea2f6fef5972af",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/sprm/ParagraphSprmUncompressor.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/sprm/ParagraphSprmUncompressor.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 8,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/sprm/ParagraphSprmUncompressor.java",
                "patch": "@@ -400,21 +400,21 @@ private static void handleTabs(ParagraphProperties pap, SprmOperation sprm)\n     HashMap tabMap = new HashMap();\n     for (int x = 0; x < tabPositions.length; x++)\n     {\n-      tabMap.put(new Integer(tabPositions[x]), new Byte(tabDescriptors[x]));\n+      tabMap.put(Integer.valueOf(tabPositions[x]), Byte.valueOf(tabDescriptors[x]));\n     }\n \n     for (int x = 0; x < delSize; x++)\n     {\n-      tabMap.remove(new Integer(LittleEndian.getShort(grpprl, offset)));\n+      tabMap.remove(Integer.valueOf(LittleEndian.getShort(grpprl, offset)));\n       offset += LittleEndian.SHORT_SIZE;\n     }\n \n     int addSize = grpprl[offset++];\n     int start = offset;\n     for (int x = 0; x < addSize; x++)\n     {\n-      Integer key = new Integer(LittleEndian.getShort(grpprl, offset));\n-      Byte val = new Byte(grpprl[start + ((LittleEndian.SHORT_SIZE * addSize) + x)]);\n+      Integer key = Integer.valueOf(LittleEndian.getShort(grpprl, offset));\n+      Byte val = Byte.valueOf(grpprl[start + ((LittleEndian.SHORT_SIZE * addSize) + x)]);\n       tabMap.put(key, val);\n       offset += LittleEndian.SHORT_SIZE;\n     }\n@@ -452,20 +452,20 @@ private static void handleTabs(ParagraphProperties pap, SprmOperation sprm)\n //    HashMap tabMap = new HashMap();\n //    for (int x = 0; x < tabPositions.length; x++)\n //    {\n-//      tabMap.put(new Integer(tabPositions[x]), new Byte(tabDescriptors[x]));\n+//      tabMap.put(Integer.valueOf(tabPositions[x]), Byte.valueOf(tabDescriptors[x]));\n //    }\n //\n //    for (int x = 0; x < delSize; x++)\n //    {\n-//      tabMap.remove(new Integer(LittleEndian.getInt(grpprl, offset)));\n+//      tabMap.remove(Integer.valueOf(LittleEndian.getInt(grpprl, offset)));\n //      offset += LittleEndian.INT_SIZE;;\n //    }\n //\n //    int addSize = grpprl[offset++];\n //    for (int x = 0; x < addSize; x++)\n //    {\n-//      Integer key = new Integer(LittleEndian.getInt(grpprl, offset));\n-//      Byte val = new Byte(grpprl[(LittleEndian.INT_SIZE * (addSize - x)) + x]);\n+//      Integer key = Integer.valueOf(LittleEndian.getInt(grpprl, offset));\n+//      Byte val = Byte.valueOf(grpprl[(LittleEndian.INT_SIZE * (addSize - x)) + x]);\n //      tabMap.put(key, val);\n //      offset += LittleEndian.INT_SIZE;\n //    }",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/src/org/apache/poi/hwpf/sprm/ParagraphSprmUncompressor.java",
                "sha": "c53daff04fc69e86a19e2368d855f7d6edd49a9d",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/testcases/org/apache/poi/hslf/TestReWriteSanity.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/TestReWriteSanity.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 5,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/TestReWriteSanity.java",
                "patch": "@@ -59,16 +59,16 @@ public void testUserEditAtomsRight() throws Exception {\n \t\tRecord[] r = wss.getRecords();\n \t\tHashtable pp = new Hashtable();\n \t\tHashtable ue = new Hashtable();\n-\t\tue.put(new Integer(0),new Integer(0)); // Will show 0 if first\n+\t\tue.put(Integer.valueOf(0),Integer.valueOf(0)); // Will show 0 if first\n \t\tint pos = 0;\n \t\tint lastUEPos = -1;\n \n \t\tfor(int i=0; i<r.length; i++) {\n \t\t\tif(r[i] instanceof PersistPtrHolder) {\n-\t\t\t\tpp.put(new Integer(pos), r[i]);\n+\t\t\t\tpp.put(Integer.valueOf(pos), r[i]);\n \t\t\t}\n \t\t\tif(r[i] instanceof UserEditAtom) {\n-\t\t\t\tue.put(new Integer(pos), r[i]);\n+\t\t\t\tue.put(Integer.valueOf(pos), r[i]);\n \t\t\t\tlastUEPos = pos;\n \t\t\t}\n \n@@ -84,8 +84,8 @@ public void testUserEditAtomsRight() throws Exception {\n \t\t\t\tint luPos = uea.getLastUserEditAtomOffset();\n \t\t\t\tint ppPos = uea.getPersistPointersOffset();\n \n-\t\t\t\tassertTrue(pp.containsKey(new Integer(ppPos)));\n-\t\t\t\tassertTrue(ue.containsKey(new Integer(luPos)));\n+\t\t\t\tassertTrue(pp.containsKey(Integer.valueOf(ppPos)));\n+\t\t\t\tassertTrue(ue.containsKey(Integer.valueOf(luPos)));\n \t\t\t}\n \t\t}\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/testcases/org/apache/poi/hslf/TestReWriteSanity.java",
                "sha": "ae76116a413563c29f2d9ee7658dae94b6553277",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 6,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "patch": "@@ -109,15 +109,15 @@ public void test42474_2() throws Exception {\n \n         //map slide number and starting phrase of its notes\n         Map<Integer, String> notesMap = new HashMap<Integer, String>();\n-        notesMap.put(new Integer(4), \"For  decades before calculators\");\n-        notesMap.put(new Integer(5), \"Several commercial applications\");\n-        notesMap.put(new Integer(6), \"There are three variations of LNS that are discussed here\");\n-        notesMap.put(new Integer(7), \"Although multiply and square root are easier\");\n-        notesMap.put(new Integer(8), \"The bus Z is split into Z_H and Z_L\");\n+        notesMap.put(Integer.valueOf(4), \"For  decades before calculators\");\n+        notesMap.put(Integer.valueOf(5), \"Several commercial applications\");\n+        notesMap.put(Integer.valueOf(6), \"There are three variations of LNS that are discussed here\");\n+        notesMap.put(Integer.valueOf(7), \"Although multiply and square root are easier\");\n+        notesMap.put(Integer.valueOf(8), \"The bus Z is split into Z_H and Z_L\");\n \n         Slide[] slide = ppt.getSlides();\n         for (int i = 0; i < slide.length; i++) {\n-            Integer slideNumber = new Integer(slide[i].getSlideNumber());\n+            Integer slideNumber = Integer.valueOf(slide[i].getSlideNumber());\n             Notes notes = slide[i].getNotesSheet();\n             if (notesMap.containsKey(slideNumber)){\n                 assertNotNull(notes);",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "sha": "122c72c96010fa82abb1f5dafe3b44a643578b54",
                "status": "modified"
            },
            {
                "additions": 622,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestMetaDataIPI.java",
                "changes": 1348,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hpsf/basic/TestMetaDataIPI.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 726,
                "filename": "src/testcases/org/apache/poi/hpsf/basic/TestMetaDataIPI.java",
                "patch": "@@ -43,117 +43,80 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n /**\n  * Basing on: src/examples/src/org/apache/poi/hpsf/examples/ModifyDocumentSummaryInformation.java\n  * This class tests reading and writing of meta data. No actual document is created. All information\n- * is stored in a virtal document in a ByteArrayOutputStream\n+ * is stored in a virtual document in a ByteArrayOutputStream\n  * @author Matthias G\\u00fcnter\n  */\n-public class TestMetaDataIPI extends TestCase{\n-\n- private ByteArrayOutputStream bout= null; //our store\n- private POIFSFileSystem poifs=null;\n- DirectoryEntry dir = null;\n- DocumentSummaryInformation dsi=null;\n- SummaryInformation si=null;\n- \n-\n-\n- /**\n-  * Setup is used to get the document ready. Gets the DocumentSummaryInformation and the \n-  * SummaryInformation to reasonable values\n-  */\n- public void setUp(){\n-\t bout=new ByteArrayOutputStream();\n-\t poifs= new POIFSFileSystem();\n-     dir = poifs.getRoot();\n-     dsi=null;\n-     try\n-     {\n-         DocumentEntry dsiEntry = (DocumentEntry)\n-             dir.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n-         DocumentInputStream dis = new DocumentInputStream(dsiEntry);\n-         PropertySet ps = new PropertySet(dis);\n-         dis.close();\n-         dsi = new DocumentSummaryInformation(ps);\n-       \n-         \n-     }\n-     catch (FileNotFoundException ex)\n-     {\n-         /* There is no document summary information yet. We have to create a\n-          * new one. */\n-         dsi = PropertySetFactory.newDocumentSummaryInformation();\n-         assertNotNull(dsi);\n-     } catch (IOException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t} catch (NoPropertySetStreamException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t} catch (MarkUnsupportedException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t} catch (UnexpectedPropertySetTypeException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t}\n-    assertNotNull(dsi);\n-    try\n-    {\n-        DocumentEntry dsiEntry = (DocumentEntry)\n-            dir.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n-        DocumentInputStream dis = new DocumentInputStream(dsiEntry);\n-        PropertySet ps = new PropertySet(dis);\n-        dis.close();\n-        si = new SummaryInformation(ps);\n-      \n-        \n-    }\n-    catch (FileNotFoundException ex)\n-    {\n-        /* There is no document summary information yet. We have to create a\n-         * new one. */\n-        si = PropertySetFactory.newSummaryInformation();\n-        assertNotNull(si);\n-    } catch (IOException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t} catch (NoPropertySetStreamException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t} catch (MarkUnsupportedException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n-\t} catch (UnexpectedPropertySetTypeException e) {\n-\t\te.printStackTrace();\n-\t\tfail();\n+public final class TestMetaDataIPI extends TestCase{\n+\n+\tprivate ByteArrayOutputStream bout; //our store\n+\tprivate POIFSFileSystem poifs;\n+\tprivate DirectoryEntry dir;\n+\tprivate DocumentSummaryInformation dsi;\n+\tprivate SummaryInformation si;\n+\n+\n+\n+\t/**\n+\t * Setup is used to get the document ready. Gets the DocumentSummaryInformation and the\n+\t * SummaryInformation to reasonable values\n+\t */\n+\tpublic void setUp() {\n+\t\tbout = new ByteArrayOutputStream();\n+\t\tpoifs = new POIFSFileSystem();\n+\t\tdir = poifs.getRoot();\n+\t\tdsi = null;\n+\t\ttry {\n+\t\t\tDocumentEntry dsiEntry = (DocumentEntry) dir\n+\t\t\t\t\t.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n+\t\t\tDocumentInputStream dis = new DocumentInputStream(dsiEntry);\n+\t\t\tPropertySet ps = new PropertySet(dis);\n+\t\t\tdis.close();\n+\t\t\tdsi = new DocumentSummaryInformation(ps);\n+\n+\t\t} catch (FileNotFoundException ex) {\n+\t\t\t/*\n+\t\t\t * There is no document summary information yet. We have to create a\n+\t\t\t * new one.\n+\t\t\t */\n+\t\t\tdsi = PropertySetFactory.newDocumentSummaryInformation();\n+\t\t\tassertNotNull(dsi);\n+\t\t} catch (Exception e) {\n+\t\t\te.printStackTrace();\n+\t\t\tfail();\n+\t\t}\n+\t\tassertNotNull(dsi);\n+\t\ttry {\n+\t\t\tDocumentEntry dsiEntry = (DocumentEntry) dir\n+\t\t\t\t\t.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n+\t\t\tDocumentInputStream dis = new DocumentInputStream(dsiEntry);\n+\t\t\tPropertySet ps = new PropertySet(dis);\n+\t\t\tdis.close();\n+\t\t\tsi = new SummaryInformation(ps);\n+\n+\t\t} catch (FileNotFoundException ex) {\n+\t\t\t/*\n+\t\t\t * There is no document summary information yet. We have to create a\n+\t\t\t * new one.\n+\t\t\t */\n+\t\t\tsi = PropertySetFactory.newSummaryInformation();\n+\t\t\tassertNotNull(si);\n+\t\t} catch (Exception e) {\n+\t\t\te.printStackTrace();\n+\t\t\tfail();\n+\t\t}\n+\t\tassertNotNull(dsi);\n \t}\n-\tassertNotNull(dsi);\n-    \n-    \n- }\n- \n- /**\n-  * Setting a lot of things to null.\n-  */\n- public void tearDown(){\n-\tbout=null;\n-\tpoifs=null;\n-\tdir=null;\n-\tdsi=null;\n-\t \n- }\n- \n- \n- /**\n-  * Closes the ByteArrayOutputStream and reads it into a ByteArrayInputStream.\n-  * When finished writing information this method is used in the tests to\n-  * start reading from the created document and then the see if the results match.\n-  *\n-  */\n-  public void closeAndReOpen(){\n-\t     \n-\t     try {\n+\n+\t/**\n+\t * Closes the ByteArrayOutputStream and reads it into a ByteArrayInputStream.\n+\t * When finished writing information this method is used in the tests to\n+\t * start reading from the created document and then the see if the results match.\n+\t */\n+\tpublic void closeAndReOpen() {\n+\n+\t\ttry {\n \t\t\tdsi.write(dir, DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n-\t\t\tsi.write(dir,SummaryInformation.DEFAULT_STREAM_NAME);\n+\t\t\tsi.write(dir, SummaryInformation.DEFAULT_STREAM_NAME);\n \t\t} catch (WritingNotSupportedException e) {\n \t\t\te.printStackTrace();\n \t\t\tfail();\n@@ -162,659 +125,592 @@ public void closeAndReOpen(){\n \t\t\tfail();\n \t\t}\n \n-        si=null;\n-        dsi=null;\n+\t\tsi = null;\n+\t\tdsi = null;\n \t\ttry {\n-\t\t\t\n \t\t\tpoifs.writeFilesystem(bout);\n \t\t\tbout.flush();\n-\t\t\t\n \t\t} catch (IOException e) {\n-\n \t\t\te.printStackTrace();\n \t\t\tfail();\n \t\t}\n-\t     \n-\t     InputStream is=new ByteArrayInputStream(bout.toByteArray());\n-\t   assertNotNull(is);\n-\t   POIFSFileSystem poifs=null;\n+\n+\t\tInputStream is = new ByteArrayInputStream(bout.toByteArray());\n+\t\tassertNotNull(is);\n+\t\tPOIFSFileSystem poifs = null;\n \t\ttry {\n \t\t\tpoifs = new POIFSFileSystem(is);\n \t\t} catch (IOException e) {\n-\n \t\t\te.printStackTrace();\n \t\t\tfail();\n \t\t}\n-\t     try {\n+\t\ttry {\n \t\t\tis.close();\n \t\t} catch (IOException e) {\n \t\t\te.printStackTrace();\n \t\t\tfail();\n \t\t}\n-\t    assertNotNull(poifs);\n-\t     /* Read the document summary information. */\n-\t     DirectoryEntry dir = poifs.getRoot();\n-\t     \n-\t     try\n-\t     {\n-\t         DocumentEntry dsiEntry = (DocumentEntry)\n-\t             dir.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n-\t         DocumentInputStream dis = new DocumentInputStream(dsiEntry);\n-\t         PropertySet ps = new PropertySet(dis);\n-\t         dis.close();\n-\t         dsi = new DocumentSummaryInformation(ps);\n-\t     }\n-\t     catch (FileNotFoundException ex)\n-\t     {\n-\t         fail();\n-\t     } catch (IOException e) {\n-\t\t\te.printStackTrace();\n+\t\tassertNotNull(poifs);\n+\t\t/* Read the document summary information. */\n+\t\tDirectoryEntry dir = poifs.getRoot();\n+\n+\t\ttry {\n+\t\t\tDocumentEntry dsiEntry = (DocumentEntry) dir\n+\t\t\t\t\t.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n+\t\t\tDocumentInputStream dis = new DocumentInputStream(dsiEntry);\n+\t\t\tPropertySet ps = new PropertySet(dis);\n+\t\t\tdis.close();\n+\t\t\tdsi = new DocumentSummaryInformation(ps);\n+\t\t} catch (FileNotFoundException ex) {\n \t\t\tfail();\n-\t\t} catch (NoPropertySetStreamException e) {\n+\t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tfail();\n-\t\t} catch (MarkUnsupportedException e) {\n+\t\t}\n+\t\ttry {\n+\t\t\tDocumentEntry dsiEntry = (DocumentEntry) dir\n+\t\t\t\t\t.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n+\t\t\tDocumentInputStream dis = new DocumentInputStream(dsiEntry);\n+\t\t\tPropertySet ps = new PropertySet(dis);\n+\t\t\tdis.close();\n+\t\t\tsi = new SummaryInformation(ps);\n+\n+\t\t} catch (FileNotFoundException ex) {\n+\t\t\t/*\n+\t\t\t * There is no document summary information yet. We have to create a\n+\t\t\t * new one.\n+\t\t\t */\n+\t\t\tsi = PropertySetFactory.newSummaryInformation();\n+\t\t\tassertNotNull(si);\n+\t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tfail();\n-\t\t} catch (UnexpectedPropertySetTypeException e) {\n-\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the most important information in DocumentSummaryInformation and Summary Information and rereads it\n+\t */\n+\tpublic void testOne() {\n+\n+\t\t// DocumentSummaryInformation\n+\t\tdsi.setCompany(\"xxxCompanyxxx\");\n+\t\tdsi.setManager(\"xxxManagerxxx\");\n+\t\tdsi.setCategory(\"xxxCategoryxxx\");\n+\n+\t\t// SummaryInformation\n+\t\tsi.setTitle(\"xxxTitlexxx\");\n+\t\tsi.setAuthor(\"xxxAuthorxxx\");\n+\t\tsi.setComments(\"xxxCommentsxxx\");\n+\t\tsi.setKeywords(\"xxxKeyWordsxxx\");\n+\t\tsi.setSubject(\"xxxSubjectxxx\");\n+\n+\t\t// Custom Properties (in DocumentSummaryInformation\n+\t\tCustomProperties customProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tcustomProperties = new CustomProperties();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\t\tcustomProperties.put(\"Key1\", \"Value1\");\n+\t\tcustomProperties.put(\"Schl\\u00fcssel2\", \"Wert2\");\n+\t\tcustomProperties.put(\"Sample Integer\", new Integer(12345));\n+\t\tcustomProperties.put(\"Sample Boolean\", Boolean.TRUE);\n+\t\tDate date = new Date();\n+\t\tcustomProperties.put(\"Sample Date\", date);\n+\t\tcustomProperties.put(\"Sample Double\", new Double(-1.0001));\n+\t\tcustomProperties.put(\"Sample Negative Integer\", new Integer(-100000));\n+\n+\t\tdsi.setCustomProperties(customProperties);\n+\n+\t\t// start reading\n+\t\tcloseAndReOpen();\n+\n+\t\t// testing\n+\t\tassertNotNull(dsi);\n+\t\tassertNotNull(si);\n+\n+\t\tassertEquals(\"Category\", \"xxxCategoryxxx\", dsi.getCategory());\n+\t\tassertEquals(\"Company\", \"xxxCompanyxxx\", dsi.getCompany());\n+\t\tassertEquals(\"Manager\", \"xxxManagerxxx\", dsi.getManager());\n+\n+\t\tassertEquals(\"\", \"xxxAuthorxxx\", si.getAuthor());\n+\t\tassertEquals(\"\", \"xxxTitlexxx\", si.getTitle());\n+\t\tassertEquals(\"\", \"xxxCommentsxxx\", si.getComments());\n+\t\tassertEquals(\"\", \"xxxKeyWordsxxx\", si.getKeywords());\n+\t\tassertEquals(\"\", \"xxxSubjectxxx\", si.getSubject());\n+\n+\t\t/*\n+\t\t * Read the custom properties. If there are no custom properties yet,\n+\t\t * the application has to create a new CustomProperties object. It will\n+\t\t * serve as a container for custom properties.\n+\t\t */\n+\t\tcustomProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n \t\t\tfail();\n \t\t}\n-\t\t  try\n-\t\t    {\n-\t\t        DocumentEntry dsiEntry = (DocumentEntry)\n-\t\t            dir.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n-\t\t        DocumentInputStream dis = new DocumentInputStream(dsiEntry);\n-\t\t        PropertySet ps = new PropertySet(dis);\n-\t\t        dis.close();\n-\t\t        si = new SummaryInformation(ps);\n-\t\t      \n-\t\t        \n-\t\t    }\n-\t\t    catch (FileNotFoundException ex)\n-\t\t    {\n-\t\t        /* There is no document summary information yet. We have to create a\n-\t\t         * new one. */\n-\t\t        si = PropertySetFactory.newSummaryInformation();\n-\t\t        assertNotNull(si);\n-\t\t    } catch (IOException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t\tfail();\n-\t\t\t} catch (NoPropertySetStreamException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t\tfail();\n-\t\t\t} catch (MarkUnsupportedException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t\tfail();\n-\t\t\t} catch (UnexpectedPropertySetTypeException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t\tfail();\n-\t\t\t}\n-  }\n-  \n-  /**\n-   * Sets the most important information in DocumentSummaryInformation and Summary Information and rereads it\n-   *\n-   */\n- public void testOne(){\n-\t \n-\t //DocumentSummaryInformation\n-\t dsi.setCompany(\"xxxCompanyxxx\");\n-\t dsi.setManager(\"xxxManagerxxx\");\n-\t dsi.setCategory(\"xxxCategoryxxx\");\n-\t \n-\t //SummaryInformation\n-\t si.setTitle(\"xxxTitlexxx\");\n-\t si.setAuthor(\"xxxAuthorxxx\");\n-\t si.setComments(\"xxxCommentsxxx\");\n-\t si.setKeywords(\"xxxKeyWordsxxx\");\n-\t si.setSubject(\"xxxSubjectxxx\");\n-\t \n-\t //Custom Properties (in DocumentSummaryInformation\n-     CustomProperties customProperties = dsi.getCustomProperties();\n-     if (customProperties == null){\n-         customProperties = new CustomProperties();\n-     }\n-     \n-     /* Insert some custom properties into the container. */\n-     customProperties.put(\"Key1\", \"Value1\");\n-     customProperties.put(\"Schl\\u00fcssel2\", \"Wert2\");\n-     customProperties.put(\"Sample Integer\", new Integer(12345));\n-     customProperties.put(\"Sample Boolean\", new Boolean(true));\n-     Date date=new Date();\n-     customProperties.put(\"Sample Date\", date);\n-     customProperties.put(\"Sample Double\", new Double(-1.0001));\n-     customProperties.put(\"Sample Negative Integer\", new Integer(-100000));\n-\n-     dsi.setCustomProperties(customProperties);\n-\n-     //start reading\n-\t closeAndReOpen();\n-     \n-\t //testing\n-     assertNotNull(dsi);\n-     assertNotNull(si);\n-     \n-     assertEquals(\"Category\",\"xxxCategoryxxx\",dsi.getCategory());\n-     assertEquals(\"Company\",\"xxxCompanyxxx\",dsi.getCompany());\n-     assertEquals(\"Manager\",\"xxxManagerxxx\",dsi.getManager());\n-     \n-     assertEquals(\"\",\"xxxAuthorxxx\",si.getAuthor());\n-     assertEquals(\"\",\"xxxTitlexxx\",si.getTitle());\n-     assertEquals(\"\",\"xxxCommentsxxx\",si.getComments());\n-     assertEquals(\"\",\"xxxKeyWordsxxx\",si.getKeywords());\n-     assertEquals(\"\",\"xxxSubjectxxx\",si.getSubject());\n-     \n-\n-     /* Read the custom properties. If there are no custom properties yet,\n-      * the application has to create a new CustomProperties object. It will\n-      * serve as a container for custom properties. */\n-     customProperties = dsi.getCustomProperties();\n-     if (customProperties == null){\n-    \t fail();\n-         }\n-     \n-     /* Insert some custom properties into the container. */\n-     String a1=(String) customProperties.get(\"Key1\");\n-     assertEquals(\"Key1\",\"Value1\",a1);\n-     String a2=(String) customProperties.get(\"Schl\\u00fcssel2\");\n-     assertEquals(\"Schl\\u00fcssel2\",\"Wert2\",a2);\n-     Integer a3=(Integer) customProperties.get(\"Sample Integer\");\n-     assertEquals(\"Sample Number\",new Integer(12345),a3);\n-     Boolean a4=(Boolean) customProperties.get(\"Sample Boolean\");\n-     assertEquals(\"Sample Boolean\",new Boolean(true),a4);\n-     Date a5=(Date) customProperties.get(\"Sample Date\");\n-     assertEquals(\"Custom Date:\",date,a5);\n-     \n-     Double a6=(Double) customProperties.get(\"Sample Double\");\n-     assertEquals(\"Custom Float\",new Double(-1.0001),a6);\n-     \n-     Integer a7=(Integer) customProperties.get(\"Sample Negative Integer\");\n-     assertEquals(\"Neg\", new Integer(-100000),a7);\n- }\n-     \n-\n- /**\n-  * multiplies a string\n-  * @param s Input String\n-  * @return  the multiplied String\n-  */\n- public String elongate(String s){\n-\t StringBuffer sb=new StringBuffer();\n-\t for (int i=0;i<10000;i++){\n-\t\t sb.append(s);\n-\t\t sb.append(\" \");\n-\t }\n-\t return sb.toString();\n- }\n- \n- \n- \n- /**\n-  * Test very long input in each of the fields (approx 30-60KB each)\n-  *\n-  */\n-public void testTwo(){\n-\t \n-\tString company=elongate(\"company\");\n-\tString manager=elongate(\"manager\");\n-\tString category=elongate(\"category\");\n-\tString title=elongate(\"title\");\n-\tString author=elongate(\"author\");\n-\tString comments=elongate(\"comments\");\n-\tString keywords=elongate(\"keywords\");\n-\tString subject=elongate(\"subject\");\n-\tString p1=elongate(\"p1\");\n-\tString p2=elongate(\"p2\");\n-\tString k1=elongate(\"k1\");\n-\tString k2=elongate(\"k2\");\n-\t\n-\t dsi.setCompany(company);\n-\t dsi.setManager(manager);\n-\t dsi.setCategory(category);\n-\t \n-\t si.setTitle(title);\n-\t si.setAuthor(author);\n-\t si.setComments(comments);\n-\t si.setKeywords(keywords);\n-\t si.setSubject(subject);\n-    CustomProperties customProperties = dsi.getCustomProperties();\n-    if (customProperties == null){\n-        customProperties = new CustomProperties();\n-    }\n-    \n-    /* Insert some custom properties into the container. */\n-    customProperties.put(k1, p1);\n-    customProperties.put(k2, p2);\n-    customProperties.put(\"Sample Number\", new Integer(12345));\n-    customProperties.put(\"Sample Boolean\", new Boolean(true));\n-    Date date=new Date();\n-    customProperties.put(\"Sample Date\", date);\n-\n-    dsi.setCustomProperties(customProperties);\n-\n-\n-\t closeAndReOpen();\n-  \n-   assertNotNull(dsi);\n-   assertNotNull(si);\n-    /* Change the category to \"POI example\". Any former category value will\n-     * be lost. If there has been no category yet, it will be created. */\n-    assertEquals(\"Category\",category,dsi.getCategory());\n-    assertEquals(\"Company\",company,dsi.getCompany());\n-    assertEquals(\"Manager\",manager,dsi.getManager());\n-    \n-    assertEquals(\"\",author,si.getAuthor());\n-    assertEquals(\"\",title,si.getTitle());\n-    assertEquals(\"\",comments,si.getComments());\n-    assertEquals(\"\",keywords,si.getKeywords());\n-    assertEquals(\"\",subject,si.getSubject());\n-    \n-    \n-    /* Read the custom properties. If there are no custom properties\n-     * yet, the application has to create a new CustomProperties object.\n-     * It will serve as a container for custom properties. */\n-    customProperties = dsi.getCustomProperties();\n-    if (customProperties == null){\n-   \t fail();\n-        }\n-    \n-    /* Insert some custom properties into the container. */\n-    String a1=(String) customProperties.get(k1);\n-    assertEquals(\"Key1\",p1,a1);\n-    String a2=(String) customProperties.get(k2);\n-    assertEquals(\"Schl\\u00fcssel2\",p2,a2);\n-    Integer a3=(Integer) customProperties.get(\"Sample Number\");\n-    assertEquals(\"Sample Number\",new Integer(12345),a3);\n-    Boolean a4=(Boolean) customProperties.get(\"Sample Boolean\");\n-    assertEquals(\"Sample Boolean\",new Boolean(true),a4);\n-    Date a5=(Date) customProperties.get(\"Sample Date\");\n-    assertEquals(\"Custom Date:\",date,a5);\n \n+\t\t/* Insert some custom properties into the container. */\n+\t\tString a1 = (String) customProperties.get(\"Key1\");\n+\t\tassertEquals(\"Key1\", \"Value1\", a1);\n+\t\tString a2 = (String) customProperties.get(\"Schl\\u00fcssel2\");\n+\t\tassertEquals(\"Schl\\u00fcssel2\", \"Wert2\", a2);\n+\t\tInteger a3 = (Integer) customProperties.get(\"Sample Integer\");\n+\t\tassertEquals(\"Sample Number\", new Integer(12345), a3);\n+\t\tBoolean a4 = (Boolean) customProperties.get(\"Sample Boolean\");\n+\t\tassertEquals(\"Sample Boolean\", Boolean.TRUE, a4);\n+\t\tDate a5 = (Date) customProperties.get(\"Sample Date\");\n+\t\tassertEquals(\"Custom Date:\", date, a5);\n+\n+\t\tDouble a6 = (Double) customProperties.get(\"Sample Double\");\n+\t\tassertEquals(\"Custom Float\", new Double(-1.0001), a6);\n+\n+\t\tInteger a7 = (Integer) customProperties.get(\"Sample Negative Integer\");\n+\t\tassertEquals(\"Neg\", new Integer(-100000), a7);\n+\t}\n \n+\t/**\n+\t * multiplies a string\n+\t * @param s Input String\n+\t * @return the multiplied String\n+\t */\n+\tprivate static String elongate(String s) {\n+\t\tStringBuffer sb = new StringBuffer();\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tsb.append(s);\n+\t\t\tsb.append(\" \");\n+\t\t}\n+\t\treturn sb.toString();\n \t}\n-    \n \n-/**\n- * adds strange characters to the string\n- * @param s Input String\n- * @return  the multiplied String\n- */\n-public String strangize(String s){\n-\t StringBuffer sb=new StringBuffer();\n-\t String[] umlaute= {\"\\u00e4\",\"\\u00fc\",\"\\u00f6\",\"\\u00dc\",\"$\",\"\\u00d6\",\"\\u00dc\",\"\\u00c9\",\"\\u00d6\",\"@\",\"\\u00e7\",\"&\"};\n-\t char j=0;\n-\t Random rand=new Random();\n-\t for (int i=0;i<5;i++){\n-\t\t sb.append(s);\n-\t\t sb.append(\" \");\n-\t\t j=(char) rand.nextInt(220);\n-\t\t j+=33;\n-\t\t // System.out.println(j);\n-\t\t sb.append(\">\");\n-\t\t sb.append(new Character(j));\n-\t\t sb.append(\"=\");\n-\t\t sb.append(umlaute[rand.nextInt(umlaute.length)]);\n-\t\t sb.append(\"<\");\n-\t }\n-\t \n-\t return sb.toString();\n-}\n+\t/**\n+\t * Test very long input in each of the fields (approx 30-60KB each)\n+\t */\n+\tpublic void testTwo() {\n+\n+\t\tString company = elongate(\"company\");\n+\t\tString manager = elongate(\"manager\");\n+\t\tString category = elongate(\"category\");\n+\t\tString title = elongate(\"title\");\n+\t\tString author = elongate(\"author\");\n+\t\tString comments = elongate(\"comments\");\n+\t\tString keywords = elongate(\"keywords\");\n+\t\tString subject = elongate(\"subject\");\n+\t\tString p1 = elongate(\"p1\");\n+\t\tString p2 = elongate(\"p2\");\n+\t\tString k1 = elongate(\"k1\");\n+\t\tString k2 = elongate(\"k2\");\n+\n+\t\tdsi.setCompany(company);\n+\t\tdsi.setManager(manager);\n+\t\tdsi.setCategory(category);\n+\n+\t\tsi.setTitle(title);\n+\t\tsi.setAuthor(author);\n+\t\tsi.setComments(comments);\n+\t\tsi.setKeywords(keywords);\n+\t\tsi.setSubject(subject);\n+\t\tCustomProperties customProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tcustomProperties = new CustomProperties();\n+\t\t}\n \n+\t\t/* Insert some custom properties into the container. */\n+\t\tcustomProperties.put(k1, p1);\n+\t\tcustomProperties.put(k2, p2);\n+\t\tcustomProperties.put(\"Sample Number\", new Integer(12345));\n+\t\tcustomProperties.put(\"Sample Boolean\", Boolean.TRUE);\n+\t\tDate date = new Date();\n+\t\tcustomProperties.put(\"Sample Date\", date);\n+\n+\t\tdsi.setCustomProperties(customProperties);\n+\n+\t\tcloseAndReOpen();\n+\n+\t\tassertNotNull(dsi);\n+\t\tassertNotNull(si);\n+\t\t/*\n+\t\t * Change the category to \"POI example\". Any former category value will\n+\t\t * be lost. If there has been no category yet, it will be created.\n+\t\t */\n+\t\tassertEquals(\"Category\", category, dsi.getCategory());\n+\t\tassertEquals(\"Company\", company, dsi.getCompany());\n+\t\tassertEquals(\"Manager\", manager, dsi.getManager());\n+\n+\t\tassertEquals(\"\", author, si.getAuthor());\n+\t\tassertEquals(\"\", title, si.getTitle());\n+\t\tassertEquals(\"\", comments, si.getComments());\n+\t\tassertEquals(\"\", keywords, si.getKeywords());\n+\t\tassertEquals(\"\", subject, si.getSubject());\n+\n+\t\t/*\n+\t\t * Read the custom properties. If there are no custom properties yet,\n+\t\t * the application has to create a new CustomProperties object. It will\n+\t\t * serve as a container for custom properties.\n+\t\t */\n+\t\tcustomProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tfail();\n+\t\t}\n \n-/**\n- * Tests with strange characters in keys and data (Umlaute etc.)\n- *\n- */\n-public void testThree(){\n-\t \n-\tString company=strangize(\"company\");\n-\tString manager=strangize(\"manager\");\n-\tString category=strangize(\"category\");\n-\tString title=strangize(\"title\");\n-\tString author=strangize(\"author\");\n-\tString comments=strangize(\"comments\");\n-\tString keywords=strangize(\"keywords\");\n-\tString subject=strangize(\"subject\");\n-\tString p1=strangize(\"p1\");\n-\tString p2=strangize(\"p2\");\n-\tString k1=strangize(\"k1\");\n-\tString k2=strangize(\"k2\");\n-\t\n-\t dsi.setCompany(company);\n-\t dsi.setManager(manager);\n-\t dsi.setCategory(category);\n-\t \n-\t si.setTitle(title);\n-\t si.setAuthor(author);\n-\t si.setComments(comments);\n-\t si.setKeywords(keywords);\n-\t si.setSubject(subject);\n-   CustomProperties customProperties = dsi.getCustomProperties();\n-   if (customProperties == null){\n-       customProperties = new CustomProperties();\n-   }\n-   \n-   /* Insert some custom properties into the container. */\n-   customProperties.put(k1, p1);\n-   customProperties.put(k2, p2);\n-   customProperties.put(\"Sample Number\", new Integer(12345));\n-   customProperties.put(\"Sample Boolean\", new Boolean(false));\n-   Date date=new Date(0);\n-   customProperties.put(\"Sample Date\", date);\n-\n-   dsi.setCustomProperties(customProperties);\n-\n-\n-\t closeAndReOpen();\n- \n-  assertNotNull(dsi);\n-  assertNotNull(si);\n-   /* Change the category to \"POI example\". Any former category value will\n-    * be lost. If there has been no category yet, it will be created. */\n-   assertEquals(\"Category\",category,dsi.getCategory());\n-   assertEquals(\"Company\",company,dsi.getCompany());\n-   assertEquals(\"Manager\",manager,dsi.getManager());\n-   \n-   assertEquals(\"\",author,si.getAuthor());\n-   assertEquals(\"\",title,si.getTitle());\n-   assertEquals(\"\",comments,si.getComments());\n-   assertEquals(\"\",keywords,si.getKeywords());\n-   assertEquals(\"\",subject,si.getSubject());\n-   \n-   \n-   /* Read the custom properties. If there are no custom properties yet,\n-    * the application has to create a new CustomProperties object. It will\n-    * serve as a container for custom properties. */\n-   customProperties = dsi.getCustomProperties();\n-   if (customProperties == null){\n-  \t fail();\n-       }\n-   \n-   /* Insert some custom properties into the container. */\n-   // System.out.println(k1);\n-   String a1=(String) customProperties.get(k1);\n-   assertEquals(\"Key1\",p1,a1);\n-   String a2=(String) customProperties.get(k2);\n-   assertEquals(\"Schl\\u00fcssel2\",p2,a2);\n-   Integer a3=(Integer) customProperties.get(\"Sample Number\");\n-   assertEquals(\"Sample Number\",new Integer(12345),a3);\n-   Boolean a4=(Boolean) customProperties.get(\"Sample Boolean\");\n-   assertEquals(\"Sample Boolean\",new Boolean(false),a4);\n-   Date a5=(Date) customProperties.get(\"Sample Date\");\n-   assertEquals(\"Custom Date:\",date,a5);\n-  \n+\t\t/* Insert some custom properties into the container. */\n+\t\tString a1 = (String) customProperties.get(k1);\n+\t\tassertEquals(\"Key1\", p1, a1);\n+\t\tString a2 = (String) customProperties.get(k2);\n+\t\tassertEquals(\"Schl\\u00fcssel2\", p2, a2);\n+\t\tInteger a3 = (Integer) customProperties.get(\"Sample Number\");\n+\t\tassertEquals(\"Sample Number\", new Integer(12345), a3);\n+\t\tBoolean a4 = (Boolean) customProperties.get(\"Sample Boolean\");\n+\t\tassertEquals(\"Sample Boolean\", Boolean.TRUE, a4);\n+\t\tDate a5 = (Date) customProperties.get(\"Sample Date\");\n+\t\tassertEquals(\"Custom Date:\", date, a5);\n \n \t}\n-   \n-   /**\n-    * Iterative testing: writing, reading etc.\n-    *\n-    */\n-   public void testFour(){\n-\t   for (int i=1;i<100;i++){\n-\t\t   setUp();\n-\t\t   testThree();\n-\t\t   tearDown();\n-\t   }\n-   }\n-   \n-   \n \n-   /**\n-    * adds strange characters to the string with the adding of unicode characters\n-    * @param s Input String\n-    * @return  the multiplied String\n-    */\n-   public String strangizeU(String s){\n-\t  \n-   \t StringBuffer sb=new StringBuffer();\n-     String[] umlaute= {\"\\u00e4\",\"\\u00fc\",\"\\u00f6\",\"\\u00dc\",\"$\",\"\\u00d6\",\"\\u00dc\",\"\\u00c9\",\"\\u00d6\",\"@\",\"\\u00e7\",\"&\"};\n-   \t char j=0;\n-   \t Random rand=new Random();\n-   \t for (int i=0;i<5;i++){\n-   \t\t sb.append(s);\n-   \t\t sb.append(\" \");\n-   \t\t j=(char) rand.nextInt(220);\n-   \t\t j+=33;\n-   \t\t // System.out.println(j);\n-   \t\t sb.append(\">\");\n-   \t\t sb.append(new Character(j));\n-   \t\t sb.append(\"=\");\n-   \t\t sb.append(umlaute[rand.nextInt(umlaute.length)]);\n-   \t\t sb.append(\"<\");\n-   \t }\n-   \t sb.append(\"\\u00e4\\u00f6\\u00fc\\uD840\\uDC00\");\n-   \t return sb.toString();\n-   }\n-   /**\n-    * Unicode test\n-    *\n-    */\n-   public void testUnicode(){\n-\t   String company=strangizeU(\"company\");\n-\t\tString manager=strangizeU(\"manager\");\n-\t\tString category=strangizeU(\"category\");\n-\t\tString title=strangizeU(\"title\");\n-\t\tString author=strangizeU(\"author\");\n-\t\tString comments=strangizeU(\"comments\");\n-\t\tString keywords=strangizeU(\"keywords\");\n-\t\tString subject=strangizeU(\"subject\");\n-\t\tString p1=strangizeU(\"p1\");\n-\t\tString p2=strangizeU(\"p2\");\n-\t\tString k1=strangizeU(\"k1\");\n-\t\tString k2=strangizeU(\"k2\");\n-\t\t\n-\t\t dsi.setCompany(company);\n-\t\t dsi.setManager(manager);\n-\t\t dsi.setCategory(category);\n-\t\t \n-\t\t si.setTitle(title);\n-\t\t si.setAuthor(author);\n-\t\t si.setComments(comments);\n-\t\t si.setKeywords(keywords);\n-\t\t si.setSubject(subject);\n-\t   CustomProperties customProperties = dsi.getCustomProperties();\n-\t   if (customProperties == null){\n-\t       customProperties = new CustomProperties();\n-\t   }\n-\t   \n-\t   /* Insert some custom properties into the container. */\n-\t   customProperties.put(k1, p1);\n-\t   customProperties.put(k2, p2);\n-\t   customProperties.put(\"Sample Number\", new Integer(12345));\n-\t   customProperties.put(\"Sample Boolean\", new Boolean(true));\n-\t   Date date=new Date();\n-\t   customProperties.put(\"Sample Date\", date);\n-\n-\t   dsi.setCustomProperties(customProperties);\n-\n-\n-\t\t closeAndReOpen();\n-\t \n-\t  assertNotNull(dsi);\n-\t  assertNotNull(si);\n-\t   /* Change the category to \"POI example\". Any former category value will\n-\t    * be lost. If there has been no category yet, it will be created. */\n-\t   assertEquals(\"Category\",category,dsi.getCategory());\n-\t   assertEquals(\"Company\",company,dsi.getCompany());\n-\t   assertEquals(\"Manager\",manager,dsi.getManager());\n-\t   \n-\t   assertEquals(\"\",author,si.getAuthor());\n-\t   assertEquals(\"\",title,si.getTitle());\n-\t   assertEquals(\"\",comments,si.getComments());\n-\t   assertEquals(\"\",keywords,si.getKeywords());\n-\t   assertEquals(\"\",subject,si.getSubject());\n-\t   \n-\t   \n-       /* Read the custom properties. If there are no custom properties yet,\n-        * the application has to create a new CustomProperties object. It will\n-        * serve as a container for custom properties. */\n-\t   customProperties = dsi.getCustomProperties();\n-\t   if (customProperties == null){\n-\t  \t fail();\n-\t       }\n-\t   \n-\t   /* Insert some custom properties into the container. */\n-\t   // System.out.println(k1);\n-\t   String a1=(String) customProperties.get(k1);\n-\t   assertEquals(\"Key1\",p1,a1);\n-\t   String a2=(String) customProperties.get(k2);\n-\t   assertEquals(\"Schl\\u00fcssel2\",p2,a2);\n-       Integer a3=(Integer) customProperties.get(\"Sample Number\");\n-\t   assertEquals(\"Sample Number\",new Integer(12345),a3);\n-\t   Boolean a4=(Boolean) customProperties.get(\"Sample Boolean\");\n-\t   assertEquals(\"Sample Boolean\",new Boolean(true),a4);\n-\t   Date a5=(Date) customProperties.get(\"Sample Date\");\n-\t   assertEquals(\"Custom Date:\",date,a5);\n-\t  \n-\t\n-\n-   }\n-   \n-   \n-   /**\n-    * Iterative testing of the unicode test\n-    *\n+\n+\t/**\n+\t * adds strange characters to the string\n+\t * @param s Input String\n+\t * @return  the multiplied String\n+\t */\n+\tprivate static String strangize(String s) {\n+\t\tStringBuffer sb = new StringBuffer();\n+\t\tString[] umlaute = { \"\\u00e4\", \"\\u00fc\", \"\\u00f6\", \"\\u00dc\", \"$\", \"\\u00d6\", \"\\u00dc\",\n+\t\t\t\t\"\\u00c9\", \"\\u00d6\", \"@\", \"\\u00e7\", \"&\" };\n+\t\tchar j = 0;\n+\t\tRandom rand = new Random(0); // TODO - no Random - tests should be completely deterministic\n+\t\tfor (int i = 0; i < 5; i++) {\n+\t\t\tsb.append(s);\n+\t\t\tsb.append(\" \");\n+\t\t\tj = (char) rand.nextInt(220);\n+\t\t\tj += 33;\n+\t\t\t// System.out.println(j);\n+\t\t\tsb.append(\">\");\n+\t\t\tsb.append(new Character(j));\n+\t\t\tsb.append(\"=\");\n+\t\t\tsb.append(umlaute[rand.nextInt(umlaute.length)]);\n+\t\t\tsb.append(\"<\");\n+\t\t}\n+\n+\t\treturn sb.toString();\n+\t}\n+\n+\n+\t/**\n+\t * Tests with strange characters in keys and data (Umlaute etc.)\n+\t */\n+\tpublic void testThree() {\n+\n+\t\tString company = strangize(\"company\");\n+\t\tString manager = strangize(\"manager\");\n+\t\tString category = strangize(\"category\");\n+\t\tString title = strangize(\"title\");\n+\t\tString author = strangize(\"author\");\n+\t\tString comments = strangize(\"comments\");\n+\t\tString keywords = strangize(\"keywords\");\n+\t\tString subject = strangize(\"subject\");\n+\t\tString p1 = strangize(\"p1\");\n+\t\tString p2 = strangize(\"p2\");\n+\t\tString k1 = strangize(\"k1\");\n+\t\tString k2 = strangize(\"k2\");\n+\n+\t\tdsi.setCompany(company);\n+\t\tdsi.setManager(manager);\n+\t\tdsi.setCategory(category);\n+\n+\t\tsi.setTitle(title);\n+\t\tsi.setAuthor(author);\n+\t\tsi.setComments(comments);\n+\t\tsi.setKeywords(keywords);\n+\t\tsi.setSubject(subject);\n+\t\tCustomProperties customProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tcustomProperties = new CustomProperties();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\t\tcustomProperties.put(k1, p1);\n+\t\tcustomProperties.put(k2, p2);\n+\t\tcustomProperties.put(\"Sample Number\", new Integer(12345));\n+\t\tcustomProperties.put(\"Sample Boolean\", Boolean.FALSE);\n+\t\tDate date = new Date(0);\n+\t\tcustomProperties.put(\"Sample Date\", date);\n+\n+\t\tdsi.setCustomProperties(customProperties);\n+\n+\t\tcloseAndReOpen();\n+\n+\t\tassertNotNull(dsi);\n+\t\tassertNotNull(si);\n+\t\t/*\n+\t\t * Change the category to \"POI example\". Any former category value will\n+\t\t * be lost. If there has been no category yet, it will be created.\n+\t\t */\n+\t\tassertEquals(\"Category\", category, dsi.getCategory());\n+\t\tassertEquals(\"Company\", company, dsi.getCompany());\n+\t\tassertEquals(\"Manager\", manager, dsi.getManager());\n+\n+\t\tassertEquals(\"\", author, si.getAuthor());\n+\t\tassertEquals(\"\", title, si.getTitle());\n+\t\tassertEquals(\"\", comments, si.getComments());\n+\t\tassertEquals(\"\", keywords, si.getKeywords());\n+\t\tassertEquals(\"\", subject, si.getSubject());\n+\n+\t\t/*\n+\t\t * Read the custom properties. If there are no custom properties yet,\n+\t\t * the application has to create a new CustomProperties object. It will\n+\t\t * serve as a container for custom properties.\n+\t\t */\n+\t\tcustomProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tfail();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\t\t// System.out.println(k1);\n+\t\tString a1 = (String) customProperties.get(k1);\n+\t\tassertEquals(\"Key1\", p1, a1);\n+\t\tString a2 = (String) customProperties.get(k2);\n+\t\tassertEquals(\"Schl\\u00fcssel2\", p2, a2);\n+\t\tInteger a3 = (Integer) customProperties.get(\"Sample Number\");\n+\t\tassertEquals(\"Sample Number\", new Integer(12345), a3);\n+\t\tBoolean a4 = (Boolean) customProperties.get(\"Sample Boolean\");\n+\t\tassertEquals(\"Sample Boolean\", Boolean.FALSE, a4);\n+\t\tDate a5 = (Date) customProperties.get(\"Sample Date\");\n+\t\tassertEquals(\"Custom Date:\", date, a5);\n+\n+\t}\n+\n+\t/**\n+\t * Iterative testing: writing, reading etc.\n+\t */\n+\tpublic void testFour() {\n+\t\tfor (int i = 1; i < 100; i++) {\n+\t\t\tsetUp();\n+\t\t\ttestThree();\n+\t\t}\n+\t}\n+\n+\n+\n+\t/**\n+\t * adds strange characters to the string with the adding of unicode characters\n+\t * @param s Input String\n+\t * @return  the multiplied String\n     */\n-   public void testSix(){\n-\t   for (int i=1;i<100;i++){\n-\t\t   setUp();\n-\t\t   testUnicode();\n-\t\t   tearDown();\n-\t   }\n-   }\n-   \n+\tprivate static String strangizeU(String s) {\n+\n+\t\tStringBuffer sb = new StringBuffer();\n+\t\tString[] umlaute = { \"\\u00e4\", \"\\u00fc\", \"\\u00f6\", \"\\u00dc\", \"$\", \"\\u00d6\", \"\\u00dc\",\n+\t\t\t\t\"\\u00c9\", \"\\u00d6\", \"@\", \"\\u00e7\", \"&\" };\n+\t\tchar j = 0;\n+\t\tRandom rand = new Random(0); // TODO - no Random - tests should be completely deterministic\n+\t\tfor (int i = 0; i < 5; i++) {\n+\t\t\tsb.append(s);\n+\t\t\tsb.append(\" \");\n+\t\t\tj = (char) rand.nextInt(220);\n+\t\t\tj += 33;\n+\t\t\t// System.out.println(j);\n+\t\t\tsb.append(\">\");\n+\t\t\tsb.append(new Character(j));\n+\t\t\tsb.append(\"=\");\n+\t\t\tsb.append(umlaute[rand.nextInt(umlaute.length)]);\n+\t\t\tsb.append(\"<\");\n+\t\t}\n+\t\tsb.append(\"\\u00e4\\u00f6\\u00fc\\uD840\\uDC00\");\n+\t\treturn sb.toString();\n+\t}\n+\n+\t/**\n+\t * Unicode test\n+\t */\n+\tpublic void testUnicode() {\n+\t\tString company = strangizeU(\"company\");\n+\t\tString manager = strangizeU(\"manager\");\n+\t\tString category = strangizeU(\"category\");\n+\t\tString title = strangizeU(\"title\");\n+\t\tString author = strangizeU(\"author\");\n+\t\tString comments = strangizeU(\"comments\");\n+\t\tString keywords = strangizeU(\"keywords\");\n+\t\tString subject = strangizeU(\"subject\");\n+\t\tString p1 = strangizeU(\"p1\");\n+\t\tString p2 = strangizeU(\"p2\");\n+\t\tString k1 = strangizeU(\"k1\");\n+\t\tString k2 = strangizeU(\"k2\");\n+\n+\t\tdsi.setCompany(company);\n+\t\tdsi.setManager(manager);\n+\t\tdsi.setCategory(category);\n+\n+\t\tsi.setTitle(title);\n+\t\tsi.setAuthor(author);\n+\t\tsi.setComments(comments);\n+\t\tsi.setKeywords(keywords);\n+\t\tsi.setSubject(subject);\n+\t\tCustomProperties customProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tcustomProperties = new CustomProperties();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\t\tcustomProperties.put(k1, p1);\n+\t\tcustomProperties.put(k2, p2);\n+\t\tcustomProperties.put(\"Sample Number\", new Integer(12345));\n+\t\tcustomProperties.put(\"Sample Boolean\", Boolean.TRUE);\n+\t\tDate date = new Date();\n+\t\tcustomProperties.put(\"Sample Date\", date);\n+\n+\t\tdsi.setCustomProperties(customProperties);\n+\n+\t\tcloseAndReOpen();\n+\n+\t\tassertNotNull(dsi);\n+\t\tassertNotNull(si);\n+\t\t/*\n+\t\t * Change the category to \"POI example\". Any former category value will\n+\t\t * be lost. If there has been no category yet, it will be created.\n+\t\t */\n+\t\tassertEquals(\"Category\", category, dsi.getCategory());\n+\t\tassertEquals(\"Company\", company, dsi.getCompany());\n+\t\tassertEquals(\"Manager\", manager, dsi.getManager());\n+\n+\t\tassertEquals(\"\", author, si.getAuthor());\n+\t\tassertEquals(\"\", title, si.getTitle());\n+\t\tassertEquals(\"\", comments, si.getComments());\n+\t\tassertEquals(\"\", keywords, si.getKeywords());\n+\t\tassertEquals(\"\", subject, si.getSubject());\n+\n+\t\t/*\n+\t\t * Read the custom properties. If there are no custom properties yet,\n+\t\t * the application has to create a new CustomProperties object. It will\n+\t\t * serve as a container for custom properties.\n+\t\t */\n+\t\tcustomProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tfail();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\t\t// System.out.println(k1);\n+\t\tString a1 = (String) customProperties.get(k1);\n+\t\tassertEquals(\"Key1\", p1, a1);\n+\t\tString a2 = (String) customProperties.get(k2);\n+\t\tassertEquals(\"Schl\\u00fcssel2\", p2, a2);\n+\t\tInteger a3 = (Integer) customProperties.get(\"Sample Number\");\n+\t\tassertEquals(\"Sample Number\", new Integer(12345), a3);\n+\t\tBoolean a4 = (Boolean) customProperties.get(\"Sample Boolean\");\n+\t\tassertEquals(\"Sample Boolean\", Boolean.TRUE, a4);\n+\t\tDate a5 = (Date) customProperties.get(\"Sample Date\");\n+\t\tassertEquals(\"Custom Date:\", date, a5);\n+\t}\n+\n \n    /**\n-    * Tests conversion in custom fields and errors\n-    *\n-    */\n-  public void testConvAndExistance(){\n-  \t \n-  \t\n-      CustomProperties customProperties = dsi.getCustomProperties();\n-      if (customProperties == null){\n-          customProperties = new CustomProperties();\n-      }\n-      \n-      /* Insert some custom properties into the container. */\n-      customProperties.put(\"int\", new Integer(12345));\n-      customProperties.put(\"negint\", new Integer(-12345));\n-      customProperties.put(\"long\", new Long(12345));\n-      customProperties.put(\"neglong\", new Long(-12345));\n-      customProperties.put(\"boolean\", new Boolean(true));\n-      customProperties.put(\"string\", \"a String\");\n-      //customProperties.put(\"float\", new Float(12345.0));  is not valid\n-      //customProperties.put(\"negfloat\", new Float(-12345.1)); is not valid\n-      customProperties.put(\"double\", new Double(12345.2));\n-      customProperties.put(\"negdouble\", new Double(-12345.3));\n-      //customProperties.put(\"char\", new Character('a')); is not valid\n-      \n-      Date date=new Date();\n-      customProperties.put(\"date\", date);\n-\n-      dsi.setCustomProperties(customProperties);\n-\n-\n-  \t closeAndReOpen();\n-    \n-     assertNotNull(dsi);\n-     assertNotNull(si);\n-      /* Change the category to \"POI example\". Any former category value will\n-       * be lost. If there has been no category yet, it will be created. */\n-      assertNull(dsi.getCategory());\n-      assertNull(dsi.getCompany());\n-      assertNull(dsi.getManager());\n-      \n-      assertNull(si.getAuthor());\n-      assertNull(si.getTitle());\n-      assertNull(si.getComments());\n-      assertNull(si.getKeywords());\n-      assertNull(si.getSubject());\n-      \n-      \n-      /* Read the custom properties. If there are no custom properties\n-       * yet, the application has to create a new CustomProperties object.\n-       * It will serve as a container for custom properties. */\n-      customProperties = dsi.getCustomProperties();\n-      if (customProperties == null){\n-     \t fail();\n-          }\n-      \n-      /* Insert some custom properties into the container. */\n-\n-      Integer a3=(Integer) customProperties.get(\"int\");\n-      assertEquals(\"int\",new Integer(12345),a3);\n-      \n-      a3=(Integer) customProperties.get(\"negint\");\n-      assertEquals(\"negint\",new Integer(-12345),a3);\n-      \n-      Long al=(Long) customProperties.get(\"neglong\");\n-      assertEquals(\"neglong\",new Long(-12345),al);\n-      \n-      al=(Long) customProperties.get(\"long\");\n-      assertEquals(\"long\",new Long(12345),al);\n-      \n-      Boolean a4=(Boolean) customProperties.get(\"boolean\");\n-      assertEquals(\"boolean\",new Boolean(true),a4);\n-      \n-      Date a5=(Date) customProperties.get(\"date\");\n-      assertEquals(\"Custom Date:\",date,a5);\n-  \n-      Double d=(Double) customProperties.get(\"double\");\n-      assertEquals(\"int\",new Double(12345.2),d);\n-      \n-      d=(Double) customProperties.get(\"negdouble\");\n-      assertEquals(\"string\",new Double(-12345.3),d);\n-\n-      String s=(String) customProperties.get(\"string\");\n-      assertEquals(\"sring\",\"a String\",s);\n-      \n-      Object o=null;\n-      \n-      o=customProperties.get(\"string\");\n-      if (!(o instanceof String)){\n-    \t  fail();\n-      }\n-      o=customProperties.get(\"boolean\");\n-      if (!(o instanceof Boolean)){\n-    \t  fail();\n-      }\n-      \n-      o=customProperties.get(\"int\");\n-      if (!(o instanceof Integer)){\n-    \t  fail();\n-      }\n-      o=customProperties.get(\"negint\");\n-      if (!(o instanceof Integer)){\n-    \t  fail();\n-      }\n-      \n-      o=customProperties.get(\"long\");\n-      if (!(o instanceof Long)){\n-    \t  fail();\n-      }\n-      o=customProperties.get(\"neglong\");\n-      if (!(o instanceof Long)){\n-    \t  fail();\n-      }\n-      \n-      o=customProperties.get(\"double\");\n-      if (!(o instanceof Double)){\n-    \t  fail();\n-      }\n-      o=customProperties.get(\"negdouble\");\n-      if (!(o instanceof Double)){\n-    \t  fail();\n-      }\n-      \n-      o=customProperties.get(\"date\");\n-      if (!(o instanceof Date)){\n-    \t  fail();\n-      }\n-   \t}\n-      \n-\n-   \n-}\n\\ No newline at end of file\n+\t * Iterative testing of the unicode test\n+\t * \n+\t */\n+\tpublic void testSix() {\n+\t\tfor (int i = 1; i < 100; i++) {\n+\t\t\tsetUp();\n+\t\t\ttestUnicode();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Tests conversion in custom fields and errors\n+\t */\n+\tpublic void testConvAndExistence() {\n+\n+\t\tCustomProperties customProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tcustomProperties = new CustomProperties();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\t\tcustomProperties.put(\"int\", new Integer(12345));\n+\t\tcustomProperties.put(\"negint\", new Integer(-12345));\n+\t\tcustomProperties.put(\"long\", new Long(12345));\n+\t\tcustomProperties.put(\"neglong\", new Long(-12345));\n+\t\tcustomProperties.put(\"boolean\", Boolean.TRUE);\n+\t\tcustomProperties.put(\"string\", \"a String\");\n+\t\t// customProperties.put(\"float\", new Float(12345.0)); is not valid\n+\t\t// customProperties.put(\"negfloat\", new Float(-12345.1)); is not valid\n+\t\tcustomProperties.put(\"double\", new Double(12345.2));\n+\t\tcustomProperties.put(\"negdouble\", new Double(-12345.3));\n+\t\t// customProperties.put(\"char\", new Character('a')); is not valid\n+\n+\t\tDate date = new Date();\n+\t\tcustomProperties.put(\"date\", date);\n+\n+\t\tdsi.setCustomProperties(customProperties);\n+\n+\t\tcloseAndReOpen();\n+\n+\t\tassertNotNull(dsi);\n+\t\tassertNotNull(si);\n+\t\t/*\n+\t\t * Change the category to \"POI example\". Any former category value will\n+\t\t * be lost. If there has been no category yet, it will be created.\n+\t\t */\n+\t\tassertNull(dsi.getCategory());\n+\t\tassertNull(dsi.getCompany());\n+\t\tassertNull(dsi.getManager());\n+\n+\t\tassertNull(si.getAuthor());\n+\t\tassertNull(si.getTitle());\n+\t\tassertNull(si.getComments());\n+\t\tassertNull(si.getKeywords());\n+\t\tassertNull(si.getSubject());\n+\n+\t\t/*\n+\t\t * Read the custom properties. If there are no custom properties yet,\n+\t\t * the application has to create a new CustomProperties object. It will\n+\t\t * serve as a container for custom properties.\n+\t\t */\n+\t\tcustomProperties = dsi.getCustomProperties();\n+\t\tif (customProperties == null) {\n+\t\t\tfail();\n+\t\t}\n+\n+\t\t/* Insert some custom properties into the container. */\n+\n+\t\tInteger a3 = (Integer) customProperties.get(\"int\");\n+\t\tassertEquals(\"int\", new Integer(12345), a3);\n+\n+\t\ta3 = (Integer) customProperties.get(\"negint\");\n+\t\tassertEquals(\"negint\", new Integer(-12345), a3);\n+\n+\t\tLong al = (Long) customProperties.get(\"neglong\");\n+\t\tassertEquals(\"neglong\", new Long(-12345), al);\n+\n+\t\tal = (Long) customProperties.get(\"long\");\n+\t\tassertEquals(\"long\", new Long(12345), al);\n+\n+\t\tBoolean a4 = (Boolean) customProperties.get(\"boolean\");\n+\t\tassertEquals(\"boolean\", Boolean.TRUE, a4);\n+\n+\t\tDate a5 = (Date) customProperties.get(\"date\");\n+\t\tassertEquals(\"Custom Date:\", date, a5);\n+\n+\t\tDouble d = (Double) customProperties.get(\"double\");\n+\t\tassertEquals(\"int\", new Double(12345.2), d);\n+\n+\t\td = (Double) customProperties.get(\"negdouble\");\n+\t\tassertEquals(\"string\", new Double(-12345.3), d);\n+\n+\t\tString s = (String) customProperties.get(\"string\");\n+\t\tassertEquals(\"sring\", \"a String\", s);\n+\n+\n+\t\tassertTrue(customProperties.get(\"string\") instanceof String);\n+\t\tassertTrue(customProperties.get(\"boolean\") instanceof Boolean);\n+\t\tassertTrue(customProperties.get(\"int\") instanceof Integer);\n+\t\tassertTrue(customProperties.get(\"negint\") instanceof Integer);\n+\t\tassertTrue(customProperties.get(\"long\") instanceof Long);\n+\t\tassertTrue(customProperties.get(\"neglong\") instanceof Long);\n+\t\tassertTrue(customProperties.get(\"double\") instanceof Double);\n+\t\tassertTrue(customProperties.get(\"negdouble\") instanceof Double);\n+\t\tassertTrue(customProperties.get(\"date\") instanceof Date);\n+\t}\n+}",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestMetaDataIPI.java",
                "sha": "63bde0c2dea346588dc7ae892811447ac3c9558d",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestUnicode.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hpsf/basic/TestUnicode.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 4,
                "filename": "src/testcases/org/apache/poi/hpsf/basic/TestUnicode.java",
                "patch": "@@ -53,7 +53,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n     /**\n      * <p>Read a the test file from the \"data\" directory.</p>\n-     * \n+     *\n      * @exception FileNotFoundException if the file to be read does not exist.\n      * @exception IOException if any other I/O exception occurs\n      */\n@@ -68,7 +68,7 @@ protected void setUp() {\n      * <p>Tests the {@link PropertySet} methods. The test file has two\n      * property set: the first one is a {@link SummaryInformation},\n      * the second one is a {@link DocumentSummaryInformation}.</p>\n-     * \n+     *\n      * @exception IOException if an I/O exception occurs\n      * @exception HPSFException if an HPSF exception occurs\n      */\n@@ -82,9 +82,9 @@ public void testPropertySetMethods() throws IOException, HPSFException\n         Assert.assertEquals(ps.getSectionCount(), 2);\n         Section s = (Section) ps.getSections().get(1);\n         Assert.assertEquals(s.getProperty(1),\n-                            new Integer(Constants.CP_UTF16));\n+                            Integer.valueOf(Constants.CP_UTF16));\n         Assert.assertEquals(s.getProperty(2),\n-                            new Integer(-96070278));\n+                            Integer.valueOf(-96070278));\n         Assert.assertEquals(s.getProperty(3),\n                             \"MCon_Info zu Office bei Schreiner\");\n         Assert.assertEquals(s.getProperty(4),",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestUnicode.java",
                "sha": "cdd74f79fca8e311f7ed02bf4bd6f2bea4412d69",
                "status": "modified"
            },
            {
                "additions": 35,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestWrite.java",
                "changes": 70,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hpsf/basic/TestWrite.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 35,
                "filename": "src/testcases/org/apache/poi/hpsf/basic/TestWrite.java",
                "patch": "@@ -107,7 +107,7 @@ public void setUp()\n     /**\n      * <p>Writes an empty property set to a POIFS and reads it back\n      * in.</p>\n-     * \n+     *\n      * @exception IOException if an I/O exception occurs\n      */\n     public void testNoFormatID() throws IOException\n@@ -150,7 +150,7 @@ public void testNoFormatID() throws IOException\n     /**\n      * <p>Writes an empty property set to a POIFS and reads it back\n      * in.</p>\n-     * \n+     *\n      * @exception IOException if an I/O exception occurs\n      * @exception UnsupportedVariantTypeException if HPSF does not yet support\n      * a variant type to be written\n@@ -190,7 +190,7 @@ public void testWriteEmptyPropertySet()\n     /**\n      * <p>Writes a simple property set with a SummaryInformation section to a\n      * POIFS and reads it back in.</p>\n-     * \n+     *\n      * @exception IOException if an I/O exception occurs\n      * @exception UnsupportedVariantTypeException if HPSF does not yet support\n      * a variant type to be written\n@@ -199,30 +199,30 @@ public void testWriteSimplePropertySet()\n         throws IOException, UnsupportedVariantTypeException\n     {\n         final String AUTHOR = \"Rainer Klute\";\n-        final String TITLE = \"Test Document\"; \n+        final String TITLE = \"Test Document\";\n         final File dataDir = _samples.getFile(\"\");\n         final File filename = new File(dataDir, POI_FS);\n         filename.deleteOnExit();\n         final OutputStream out = new FileOutputStream(filename);\n         final POIFSFileSystem poiFs = new POIFSFileSystem();\n-    \n+\n         final MutablePropertySet ps = new MutablePropertySet();\n         final MutableSection si = new MutableSection();\n         si.setFormatID(SectionIDMap.SUMMARY_INFORMATION_ID);\n         ps.getSections().set(0, si);\n-    \n+\n         final MutableProperty p = new MutableProperty();\n         p.setID(PropertyIDMap.PID_AUTHOR);\n         p.setType(Variant.VT_LPWSTR);\n         p.setValue(AUTHOR);\n         si.setProperty(p);\n         si.setProperty(PropertyIDMap.PID_TITLE, Variant.VT_LPSTR, TITLE);\n-    \n+\n         poiFs.createDocument(ps.toInputStream(),\n                              SummaryInformation.DEFAULT_STREAM_NAME);\n         poiFs.writeFilesystem(out);\n         out.close();\n-    \n+\n         /* Read the POIFS: */\n         final PropertySet[] psa = new PropertySet[1];\n         final POIFSReader r = new POIFSReader();\n@@ -240,7 +240,7 @@ public void testWriteSimplePropertySet()\n                         fail(org.apache.poi.hpsf.Util.toString(ex));\n                     }\n                 }\n-    \n+\n             },\n             SummaryInformation.DEFAULT_STREAM_NAME);\n         r.read(new FileInputStream(filename));\n@@ -259,7 +259,7 @@ public void testWriteSimplePropertySet()\n     /**\n      * <p>Writes a simple property set with two sections to a POIFS and reads it\n      * back in.</p>\n-     * \n+     *\n      * @exception IOException if an I/O exception occurs\n      * @exception WritingNotSupportedException if HPSF does not yet support\n      * a variant type to be written\n@@ -365,7 +365,7 @@ public void testVariantTypes()\n     {\n         Throwable t = null;\n         final int codepage = CODEPAGE_DEFAULT;\n-        if (!hasProperDefaultCharset())            \n+        if (!hasProperDefaultCharset())\n         {\n             System.err.println(IMPROPER_DEFAULT_CHARSET_MESSAGE +\n                 \" This testcase is skipped.\");\n@@ -375,8 +375,8 @@ public void testVariantTypes()\n         try\n         {\n             check(Variant.VT_EMPTY, null, codepage);\n-            check(Variant.VT_BOOL, new Boolean(true), codepage);\n-            check(Variant.VT_BOOL, new Boolean(false), codepage);\n+            check(Variant.VT_BOOL, Boolean.TRUE, codepage);\n+            check(Variant.VT_BOOL, Boolean.FALSE, codepage);\n             check(Variant.VT_CF, new byte[]{0}, codepage);\n             check(Variant.VT_CF, new byte[]{0, 1}, codepage);\n             check(Variant.VT_CF, new byte[]{0, 1, 2}, codepage);\n@@ -385,11 +385,11 @@ public void testVariantTypes()\n             check(Variant.VT_CF, new byte[]{0, 1, 2, 3, 4, 5}, codepage);\n             check(Variant.VT_CF, new byte[]{0, 1, 2, 3, 4, 5, 6}, codepage);\n             check(Variant.VT_CF, new byte[]{0, 1, 2, 3, 4, 5, 6, 7}, codepage);\n-            check(Variant.VT_I4, new Integer(27), codepage);\n-            check(Variant.VT_I8, new Long(28), codepage);\n+            check(Variant.VT_I4, Integer.valueOf(27), codepage);\n+            check(Variant.VT_I8, Long.valueOf(28), codepage);\n             check(Variant.VT_R8, new Double(29.0), codepage);\n-            check(Variant.VT_I4, new Integer(-27), codepage);\n-            check(Variant.VT_I8, new Long(-28), codepage);\n+            check(Variant.VT_I4, Integer.valueOf(-27), codepage);\n+            check(Variant.VT_I8, Long.valueOf(-28), codepage);\n             check(Variant.VT_R8, new Double(-29.0), codepage);\n             check(Variant.VT_FILETIME, new Date(), codepage);\n             check(Variant.VT_I4, new Integer(Integer.MAX_VALUE), codepage);\n@@ -460,7 +460,7 @@ public void testCodepages()\n         for (int i = 0; i < validCodepages.length; i++)\n         {\n             final int cp = validCodepages[i];\n-            if (cp == -1 && !hasProperDefaultCharset())            \n+            if (cp == -1 && !hasProperDefaultCharset())\n             {\n                 System.err.println(IMPROPER_DEFAULT_CHARSET_MESSAGE +\n                      \" This testcase is skipped for the default codepage.\");\n@@ -590,10 +590,10 @@ public void testUnicodeWrite8Bit()\n      * @param codepage The codepage to use for writing and reading.\n      * @throws UnsupportedVariantTypeException if the variant is not supported.\n      * @throws IOException if an I/O exception occurs.\n-     * @throws ReadingNotSupportedException \n-     * @throws UnsupportedEncodingException \n+     * @throws ReadingNotSupportedException\n+     * @throws UnsupportedEncodingException\n      */\n-    private void check(final long variantType, final Object value, \n+    private void check(final long variantType, final Object value,\n                        final int codepage)\n         throws UnsupportedVariantTypeException, IOException,\n                ReadingNotSupportedException, UnsupportedEncodingException\n@@ -651,17 +651,17 @@ private int diff(final byte[] a, final byte[] b)\n      * <p>This test method does a write and read back test with all POI\n      * filesystems in the \"data\" directory by performing the following\n      * actions for each file:</p>\n-     * \n+     *\n      * <ul>\n-     * \n+     *\n      * <li><p>Read its property set streams.</p></li>\n-     * \n+     *\n      * <li><p>Create a new POI filesystem containing the origin file's\n      * property set streams.</p></li>\n-     * \n+     *\n      * <li><p>Read the property set streams from the POI filesystem just\n      * created.</p></li>\n-     * \n+     *\n      * <li><p>Compare each property set stream with the corresponding one from\n      * the origin file and check whether they are equal.</p></li>\n      *\n@@ -731,7 +731,7 @@ private void testRecreate(final File f)\n                 final InputStream in2 = new ByteArrayInputStream(bytes2);\n                 final PropertySet ps1 = PropertySetFactory.create(in1);\n                 final PropertySet ps2 = PropertySetFactory.create(in2);\n-            \n+\n                 /* Compare the property set stream with the corresponding one\n                  * from the origin file and check whether they are equal. */\n                 assertEquals(\"Equality for file \" + f.getName(), ps1, ps2);\n@@ -761,14 +761,14 @@ public void testDictionary()\n             final MutablePropertySet ps1 = new MutablePropertySet();\n             final MutableSection s = (MutableSection) ps1.getSections().get(0);\n             final Map m = new HashMap(3, 1.0f);\n-            m.put(new Long(1), \"String 1\");\n-            m.put(new Long(2), \"String 2\");\n-            m.put(new Long(3), \"String 3\");\n+            m.put(Long.valueOf(1), \"String 1\");\n+            m.put(Long.valueOf(2), \"String 2\");\n+            m.put(Long.valueOf(3), \"String 3\");\n             s.setDictionary(m);\n             s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);\n             int codepage = Constants.CP_UNICODE;\n             s.setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,\n-                          new Integer(codepage));\n+                          Integer.valueOf(codepage));\n             poiFs.createDocument(ps1.toInputStream(), \"Test\");\n             poiFs.writeFilesystem(out);\n             out.close();\n@@ -813,14 +813,14 @@ public void testDictionaryWithInvalidCodepage()\n             final MutablePropertySet ps1 = new MutablePropertySet();\n             final MutableSection s = (MutableSection) ps1.getSections().get(0);\n             final Map m = new HashMap(3, 1.0f);\n-            m.put(new Long(1), \"String 1\");\n-            m.put(new Long(2), \"String 2\");\n-            m.put(new Long(3), \"String 3\");\n+            m.put(Long.valueOf(1), \"String 1\");\n+            m.put(Long.valueOf(2), \"String 2\");\n+            m.put(Long.valueOf(3), \"String 3\");\n             s.setDictionary(m);\n             s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);\n             int codepage = 12345;\n             s.setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,\n-                          new Integer(codepage));\n+                          Integer.valueOf(codepage));\n             poiFs.createDocument(ps1.toInputStream(), \"Test\");\n             poiFs.writeFilesystem(out);\n             out.close();",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestWrite.java",
                "sha": "eabda72d5ba65b9b10e6fb75192ccf0d5cfb962e",
                "status": "modified"
            },
            {
                "additions": 42,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestWriteWellKnown.java",
                "changes": 89,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hpsf/basic/TestWriteWellKnown.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 47,
                "filename": "src/testcases/org/apache/poi/hpsf/basic/TestWriteWellKnown.java",
                "patch": "@@ -58,7 +58,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n /**\n  * <p>Tests HPSF's high-level writing functionality for the well-known property\n  * set \"SummaryInformation\" and \"DocumentSummaryInformation\".</p>\n- * \n+ *\n  * @author Rainer Klute\n  *     <a href=\"mailto:klute@rainer-klute.de\">klute@rainer-klute.de</a>\n  */\n@@ -83,11 +83,6 @@ public void setUp()\n      * pointed to by the \"POI.testdata.path\" system property, trying to extract\n      * the document summary information stream in the root directory and calling\n      * its get... methods.</p>\n-     * @throws IOException \n-     * @throws FileNotFoundException \n-     * @throws MarkUnsupportedException \n-     * @throws NoPropertySetStreamException \n-     * @throws UnexpectedPropertySetTypeException \n      */\n     public void testReadDocumentSummaryInformation()\n             throws FileNotFoundException, IOException,\n@@ -131,7 +126,7 @@ public boolean accept(final File file)\n                 final DocumentInputStream dis = new DocumentInputStream(dsiEntry);\n                 final PropertySet ps = new PropertySet(dis);\n                 final DocumentSummaryInformation dsi = new DocumentSummaryInformation(ps);\n-                \n+\n                 /* Execute the get... methods. */\n                 dsi.getByteCount();\n                 dsi.getByteOrder();\n@@ -159,43 +154,43 @@ public boolean accept(final File file)\n      * <p>This test method test the writing of properties in the well-known\n      * property set streams \"SummaryInformation\" and\n      * \"DocumentSummaryInformation\" by performing the following steps:</p>\n-     * \n+     *\n      * <ol>\n-     * \n+     *\n      * <li><p>Read a test document <em>doc1</em> into a POI filesystem.</p></li>\n-     * \n+     *\n      * <li><p>Read the summary information stream and the document summary\n      * information stream from the POI filesystem.</p></li>\n-     * \n+     *\n      * <li><p>Write all properties supported by HPSF to the summary\n      * information (e.g. author, edit date, application name) and to the\n      * document summary information (e.g. company, manager).</p></li>\n-     * \n+     *\n      * <li><p>Write the summary information stream and the document summary\n      * information stream to the POI filesystem.</p></li>\n-     * \n+     *\n      * <li><p>Write the POI filesystem to a (temporary) file <em>doc2</em>\n      * and close the latter.</p></li>\n-     * \n+     *\n      * <li><p>Open <em>doc2</em> for reading and check summary information\n      * and document summary information. All properties written before must be\n      * found in the property streams of <em>doc2</em> and have the correct\n      * values.</p></li>\n-     * \n+     *\n      * <li><p>Remove all properties supported by HPSF from the summary\n      * information (e.g. author, edit date, application name) and from the\n      * document summary information (e.g. company, manager).</p></li>\n-     * \n+     *\n      * <li><p>Write the summary information stream and the document summary\n      * information stream to the POI filesystem.</p></li>\n-     * \n+     *\n      * <li><p>Write the POI filesystem to a (temporary) file <em>doc3</em>\n      * and close the latter.</p></li>\n-     * \n+     *\n      * <li><p>Open <em>doc3</em> for reading and check summary information\n      * and document summary information. All properties removed before must not\n      * be found in the property streams of <em>doc3</em>.</p></li> </ol>\n-     * \n+     *\n      * @throws IOException if some I/O error occurred.\n      * @throws MarkUnsupportedException\n      * @throws NoPropertySetStreamException\n@@ -209,17 +204,17 @@ public void testWriteWellKnown() throws IOException,\n         POIDataSamples _samples = POIDataSamples.getHPSFInstance();\n         final File dataDir = _samples.getFile(\"\");\n         final File doc1 = new File(dataDir, POI_FS);\n-    \n+\n         /* Read a test document <em>doc1</em> into a POI filesystem. */\n         POIFSFileSystem poifs = new POIFSFileSystem(new FileInputStream(doc1));\n         DirectoryEntry dir = poifs.getRoot();\n         DocumentEntry siEntry = (DocumentEntry) dir.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n         DocumentEntry dsiEntry = (DocumentEntry) dir.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n-    \n+\n         /*\n          * Read the summary information stream and the document summary\n          * information stream from the POI filesystem.\n-         * \n+         *\n          * Please note that the result consists of SummaryInformation and\n          * DocumentSummaryInformation instances which are in memory only. To\n          * make them permanent they have to be written to a POI filesystem\n@@ -232,7 +227,7 @@ public void testWriteWellKnown() throws IOException,\n         dis = new DocumentInputStream(dsiEntry);\n         ps = new PropertySet(dis);\n         DocumentSummaryInformation dsi = new DocumentSummaryInformation(ps);\n-    \n+\n         /*\n          * Write all properties supported by HPSF to the summary information\n          * (e.g. author, edit date, application name) and to the document\n@@ -245,7 +240,7 @@ public void testWriteWellKnown() throws IOException,\n         final long time2 = cal.getTimeInMillis();\n         cal.set(2002, 8, 8, 8, 8, 8);\n         final long time3 = cal.getTimeInMillis();\n-    \n+\n         int nr = 4711;\n         final String P_APPLICATION_NAME = \"ApplicationName\";\n         final String P_AUTHOR = \"Author\";\n@@ -265,7 +260,7 @@ public void testWriteWellKnown() throws IOException,\n         // FIXME (byte array properties not yet implemented): final byte[] P_THUMBNAIL = new byte[123];\n         final String P_TITLE = \"Title\";\n         final int    P_WORD_COUNT = ++nr;\n-    \n+\n         final int     P_BYTE_COUNT = ++nr;\n         final String  P_CATEGORY = \"Category\";\n         final String  P_COMPANY = \"Company\";\n@@ -296,7 +291,7 @@ public void testWriteWellKnown() throws IOException,\n         final Long MIN_LONG = new Long(Long.MIN_VALUE);\n         final Double MAX_DOUBLE = new Double(Double.MAX_VALUE);\n         final Double MIN_DOUBLE = new Double(Double.MIN_VALUE);\n-        \n+\n         si.setApplicationName(P_APPLICATION_NAME);\n         si.setAuthor(P_AUTHOR);\n         si.setCharCount(P_CHAR_COUNT);\n@@ -315,7 +310,7 @@ public void testWriteWellKnown() throws IOException,\n         // FIXME (byte array properties not yet implemented): si.setThumbnail(P_THUMBNAIL);\n         si.setTitle(P_TITLE);\n         si.setWordCount(P_WORD_COUNT);\n-    \n+\n         dsi.setByteCount(P_BYTE_COUNT);\n         dsi.setCategory(P_CATEGORY);\n         dsi.setCompany(P_COMPANY);\n@@ -345,7 +340,7 @@ public void testWriteWellKnown() throws IOException,\n         customProperties.put(\"negative_Integer\", NEGATIVE_INTEGER);\n         customProperties.put(\"negative_Long\", NEGATIVE_LONG);\n         customProperties.put(\"negative_Double\", NEGATIVE_DOUBLE);\n-        customProperties.put(\"Boolean\", new Boolean(true));\n+        customProperties.put(\"Boolean\", Boolean.TRUE);\n         customProperties.put(\"Date\", now);\n         customProperties.put(\"max_Integer\", MAX_INTEGER);\n         customProperties.put(\"min_Integer\", MIN_INTEGER);\n@@ -378,14 +373,14 @@ public void testWriteWellKnown() throws IOException,\n         dir = poifs.getRoot();\n         siEntry = (DocumentEntry) dir.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n         dsiEntry = (DocumentEntry) dir.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n-    \n+\n         dis = new DocumentInputStream(siEntry);\n         ps = new PropertySet(dis);\n         si = new SummaryInformation(ps);\n         dis = new DocumentInputStream(dsiEntry);\n         ps = new PropertySet(dis);\n         dsi = new DocumentSummaryInformation(ps);\n-    \n+\n         assertEquals(P_APPLICATION_NAME, si.getApplicationName());\n         assertEquals(P_AUTHOR, si.getAuthor());\n         assertEquals(P_CHAR_COUNT, si.getCharCount());\n@@ -404,7 +399,7 @@ public void testWriteWellKnown() throws IOException,\n         // FIXME (byte array properties not yet implemented): assertEquals(P_THUMBNAIL, si.getThumbnail());\n         assertEquals(P_TITLE, si.getTitle());\n         assertEquals(P_WORD_COUNT, si.getWordCount());\n-    \n+\n         assertEquals(P_BYTE_COUNT, dsi.getByteCount());\n         assertEquals(P_CATEGORY, dsi.getCategory());\n         assertEquals(P_COMPANY, dsi.getCompany());\n@@ -434,7 +429,7 @@ public void testWriteWellKnown() throws IOException,\n         assertEquals(NEGATIVE_INTEGER, cps.get(\"negative_Integer\"));\n         assertEquals(NEGATIVE_LONG, cps.get(\"negative_Long\"));\n         assertEquals(NEGATIVE_DOUBLE, cps.get(\"negative_Double\"));\n-        assertEquals(new Boolean(true), cps.get(\"Boolean\"));\n+        assertEquals(Boolean.TRUE, cps.get(\"Boolean\"));\n         assertEquals(now, cps.get(\"Date\"));\n         assertEquals(MAX_INTEGER, cps.get(\"max_Integer\"));\n         assertEquals(MIN_INTEGER, cps.get(\"min_Integer\"));\n@@ -464,7 +459,7 @@ public void testWriteWellKnown() throws IOException,\n         si.removeThumbnail();\n         si.removeTitle();\n         si.removeWordCount();\n-    \n+\n         dsi.removeByteCount();\n         dsi.removeCategory();\n         dsi.removeCompany();\n@@ -481,23 +476,23 @@ public void testWriteWellKnown() throws IOException,\n         dsi.removePresentationFormat();\n         dsi.removeScale();\n         dsi.removeSlideCount();\n-    \n-        /* \n+\n+        /*\n          * <li><p>Write the summary information stream and the document summary\n          * information stream to the POI filesystem. */\n         si.write(dir, siEntry.getName());\n         dsi.write(dir, dsiEntry.getName());\n-    \n-        /* \n+\n+        /*\n          * <li><p>Write the POI filesystem to a (temporary) file <em>doc3</em>\n          * and close the latter. */\n         final File doc3 = File.createTempFile(\"POI_HPSF_Test.\", \".tmp\");\n         doc3.deleteOnExit();\n         out = new FileOutputStream(doc3);\n         poifs.writeFilesystem(out);\n         out.close();\n-    \n-        /* \n+\n+        /*\n          * Open <em>doc3</em> for reading and check summary information\n          * and document summary information. All properties removed before must not\n          * be found in the property streams of <em>doc3</em>.\n@@ -506,14 +501,14 @@ public void testWriteWellKnown() throws IOException,\n         dir = poifs.getRoot();\n         siEntry = (DocumentEntry) dir.getEntry(SummaryInformation.DEFAULT_STREAM_NAME);\n         dsiEntry = (DocumentEntry) dir.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);\n-    \n+\n         dis = new DocumentInputStream(siEntry);\n         ps = new PropertySet(dis);\n         si = new SummaryInformation(ps);\n         dis = new DocumentInputStream(dsiEntry);\n         ps = new PropertySet(dis);\n         dsi = new DocumentSummaryInformation(ps);\n-    \n+\n         assertEquals(null, si.getApplicationName());\n         assertEquals(null, si.getAuthor());\n         assertEquals(0, si.getCharCount());\n@@ -537,7 +532,7 @@ public void testWriteWellKnown() throws IOException,\n         assertEquals(null, si.getTitle());\n         assertEquals(0, si.getWordCount());\n         assertTrue(si.wasNull());\n-    \n+\n         assertEquals(0, dsi.getByteCount());\n         assertTrue(dsi.wasNull());\n         assertEquals(null, dsi.getCategory());\n@@ -611,7 +606,7 @@ public void runTest(final File file) throws FileNotFoundException,\n                 else\n                     dsi = PropertySetFactory.newDocumentSummaryInformation();\n                 final CustomProperties cps = dsi.getCustomProperties();\n-                \n+\n                 if (cps == null)\n                     /* The document does not have custom properties. */\n                     return;\n@@ -663,14 +658,14 @@ public void testCustomerProperties()\n         assertEquals(1, cps.size());\n         Object v1 = cps.get(KEY);\n         assertEquals(VALUE_1, v1);\n-        \n+\n         /* After adding a custom property with the same name the size must still\n          * be one. */\n         cps.put(KEY, VALUE_2);\n         assertEquals(1, cps.size());\n         Object v2 = cps.get(KEY);\n         assertEquals(VALUE_2, v2);\n-        \n+\n         /* Removing the custom property must return the remove property and\n          * reduce the size to 0. */\n         cp = (CustomProperty) cps.remove(KEY);\n@@ -715,15 +710,15 @@ public void testGetCustomerProperties()\n         p.setType(Variant.VT_LPWSTR);\n         p.setValue(VALUE_1);\n         s.setProperty(p);\n-        dictionary.put(new Long(ID_1), NAME_1);\n+        dictionary.put(Long.valueOf(ID_1), NAME_1);\n         s.setDictionary(dictionary);\n         cps = dsi.getCustomProperties();\n         assertEquals(1, cps.size());\n         assertTrue(cps.isPure());\n \n         /* Add another custom property. */\n         s.setProperty(ID_2, Variant.VT_LPWSTR, VALUE_1);\n-        dictionary.put(new Long(ID_2), NAME_1);\n+        dictionary.put(Long.valueOf(ID_2), NAME_1);\n         s.setDictionary(dictionary);\n         cps = dsi.getCustomProperties();\n         assertEquals(1, cps.size());",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hpsf/basic/TestWriteWellKnown.java",
                "sha": "ad6e1237cf4e8edeb062d806b40218641204fea3",
                "status": "modified"
            },
            {
                "additions": 34,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 34,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java",
                "patch": "@@ -56,7 +56,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * the file 'functionMetadata.txt'.   There are more than 300 built-in functions in Excel and the\n  * intention of this class is to make it easier to maintain the metadata, by extracting it from\n  * a reliable source.\n- * \n+ *\n  * @author Josh Micich\n  */\n public final class ExcelFileFormatDocFunctionExtractor {\n@@ -65,10 +65,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n \t/**\n \t * For simplicity, the output file is strictly simple ASCII.\n-\t * This method detects any unexpected characters. \n+\t * This method detects any unexpected characters.\n \t */\n \t/* package */ static boolean isSimpleAscii(char c) {\n-\t\t\n+\n \t\tif (c>=0x21 && c<=0x7E) {\n \t\t\t// everything from '!' to '~' (includes letters, digits, punctuation\n \t\t\treturn true;\n@@ -83,8 +83,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t\t}\n \t\treturn false;\n \t}\n-\t\n-\t\n+\n+\n \tprivate static final class FunctionData {\n \t\t// special characters from the ooo document\n \t\tprivate static final int CHAR_ELLIPSIS_8230 = 8230;\n@@ -148,15 +148,15 @@ private static String checkMark(boolean b) {\n \t\t\treturn b ? \"x\" : \"\";\n \t\t}\n \t}\n-\t\n+\n \tprivate static final class FunctionDataCollector {\n \n \t\tprivate final Map _allFunctionsByIndex;\n \t\tprivate final Map _allFunctionsByName;\n \t\tprivate final Set _groupFunctionIndexes;\n \t\tprivate final Set _groupFunctionNames;\n \t\tprivate final PrintStream _ps;\n-\t\t\n+\n \t\tpublic FunctionDataCollector(PrintStream ps) {\n \t\t\t_ps = ps;\n \t\t\t_allFunctionsByIndex = new HashMap();\n@@ -168,19 +168,19 @@ public FunctionDataCollector(PrintStream ps) {\n \t\tpublic void addFuntion(int funcIx, boolean hasFootnote, String funcName, int minParams, int maxParams,\n \t\t\t\tString returnClass, String paramClasses, String volatileFlagStr) {\n \t\t\tboolean isVolatile = volatileFlagStr.length() > 0;\n-\t\t\t\n-\t\t\tInteger funcIxKey = new Integer(funcIx);\n+\n+\t\t\tInteger funcIxKey = Integer.valueOf(funcIx);\n \t\t\tif(!_groupFunctionIndexes.add(funcIxKey)) {\n \t\t\t\tthrow new RuntimeException(\"Duplicate function index (\" + funcIx + \")\");\n \t\t\t}\n \t\t\tif(!_groupFunctionNames.add(funcName)) {\n \t\t\t\tthrow new RuntimeException(\"Duplicate function name '\" + funcName + \"'\");\n \t\t\t}\n-\t\t\t\n+\n \t\t\tcheckRedefinedFunction(hasFootnote, funcName, funcIxKey);\n-\t\t\tFunctionData fd = new FunctionData(funcIx, hasFootnote, funcName, \n+\t\t\tFunctionData fd = new FunctionData(funcIx, hasFootnote, funcName,\n \t\t\t\t\tminParams, maxParams, returnClass, paramClasses, isVolatile);\n-\t\t\t\n+\n \t\t\t_allFunctionsByIndex.put(funcIxKey, fd);\n \t\t\t_allFunctionsByName.put(funcName, fd);\n \t\t}\n@@ -195,7 +195,7 @@ private void checkRedefinedFunction(boolean hasNote, String funcName, Integer fu\n \t\t\tfdPrev = (FunctionData) _allFunctionsByIndex.get(funcIxKey);\n \t\t\tif(fdPrev != null) {\n \t\t\t\tif(!fdPrev.hasFootnote() || !hasNote) {\n-\t\t\t\t\tthrow new RuntimeException(\"changing function [\" \n+\t\t\t\t\tthrow new RuntimeException(\"changing function [\"\n \t\t\t\t\t\t\t+ funcIxKey + \"] definition without foot-note\");\n \t\t\t\t}\n \t\t\t\t_allFunctionsByName.remove(fdPrev.getName());\n@@ -204,10 +204,10 @@ private void checkRedefinedFunction(boolean hasNote, String funcName, Integer fu\n \t\t\tfdPrev = (FunctionData) _allFunctionsByName.get(funcName);\n \t\t\tif(fdPrev != null) {\n \t\t\t\tif(!fdPrev.hasFootnote() || !hasNote) {\n-\t\t\t\t\tthrow new RuntimeException(\"changing function '\" \n+\t\t\t\t\tthrow new RuntimeException(\"changing function '\"\n \t\t\t\t\t\t\t+ funcName + \"' definition without foot-note\");\n \t\t\t\t}\n-\t\t\t\t_allFunctionsByIndex.remove(new Integer(fdPrev.getIndex()));\n+\t\t\t\t_allFunctionsByIndex.remove(Integer.valueOf(fdPrev.getIndex()));\n \t\t\t}\n \t\t}\n \n@@ -217,33 +217,33 @@ public void endTableGroup(String headingText) {\n \t\t\t_groupFunctionIndexes.clear();\n \t\t\t_groupFunctionNames.clear();\n \t\t\tArrays.sort(keys);\n-\t\t\t\n+\n \t\t\t_ps.println(\"# \" + headingText);\n \t\t\tfor (int i = 0; i < keys.length; i++) {\n \t\t\t\tFunctionData fd = (FunctionData) _allFunctionsByIndex.get(keys[i]);\n \t\t\t\t_ps.println(fd.formatAsDataLine());\n \t\t\t}\n \t\t}\n \t}\n-\t\n+\n \t/**\n-\t * To avoid drag-in - parse XML using only JDK. \n+\t * To avoid drag-in - parse XML using only JDK.\n \t */\n \tprivate static class EFFDocHandler implements ContentHandler {\n \t\tprivate static final String[] HEADING_PATH_NAMES = {\n-\t\t\t\"office:document-content\", \"office:body\", \"office:text\", \"text:h\",\t\n+\t\t\t\"office:document-content\", \"office:body\", \"office:text\", \"text:h\",\n \t\t};\n \t\tprivate static final String[] TABLE_BASE_PATH_NAMES = {\n-\t\t\t\"office:document-content\", \"office:body\", \"office:text\", \"table:table\",\t\n+\t\t\t\"office:document-content\", \"office:body\", \"office:text\", \"table:table\",\n \t\t};\n \t\tprivate static final String[] TABLE_ROW_RELPATH_NAMES = {\n-\t\t\t\"table:table-row\",\t\n+\t\t\t\"table:table-row\",\n \t\t};\n \t\tprivate static final String[] TABLE_CELL_RELPATH_NAMES = {\n-\t\t\t\"table:table-row\", \"table:table-cell\", \"text:p\",\t\n+\t\t\t\"table:table-row\", \"table:table-cell\", \"text:p\",\n \t\t};\n \t\t// after May 2008 there was one more style applied to the footnotes\n-\t\tprivate static final String[] NOTE_REF_RELPATH_NAMES_OLD = { \n+\t\tprivate static final String[] NOTE_REF_RELPATH_NAMES_OLD = {\n \t\t\t\"table:table-row\", \"table:table-cell\", \"text:p\", \"text:span\", \"text:note-ref\",\n \t\t};\n \t\tprivate static final String[] NOTE_REF_RELPATH_NAMES = {\n@@ -255,7 +255,7 @@ public void endTableGroup(String headingText) {\n \t\t/** <code>true</code> only when parsing the target tables */\n \t\tprivate boolean _isInsideTable;\n \n-\t\tprivate final List _rowData; \n+\t\tprivate final List _rowData;\n \t\tprivate final StringBuffer _textNodeBuffer;\n \t\tprivate final List _rowNoteFlags;\n \t\tprivate boolean _cellHasNote;\n@@ -304,7 +304,7 @@ public void endElement(String namespaceURI, String localName, String name) {\n \t\t\tif(matchesPath(0, HEADING_PATH_NAMES)) {\n \t\t\t\t_lastHeadingText = _textNodeBuffer.toString().trim();\n \t\t\t\t_textNodeBuffer.setLength(0);\n-\t\t\t}\t\t\t\n+\t\t\t}\n \t\t\tif(_isInsideTable) {\n \t\t\t\tif(matchesTargetPath()) {\n \t\t\t\t\t_fdc.endTableGroup(_lastHeadingText);\n@@ -350,7 +350,7 @@ public void processFunction(String[] cellData, Boolean[] noteFlags, int i) {\n \t\t\tString returnClass = cellData[i + 4];\n \t\t\tString paramClasses = cellData[i + 5];\n \t\t\tString volatileFlagStr = cellData[i + 6];\n-\t\t\t\n+\n \t\t\t_fdc.addFuntion(funcIx, hasFootnote, funcName, minParams, maxParams, returnClass, paramClasses, volatileFlagStr);\n \t\t}\n \t\tprivate static int parseInt(String valStr) {\n@@ -412,7 +412,7 @@ public void startPrefixMapping(String prefix, String uri) {\n \n \tprivate static void extractFunctionData(FunctionDataCollector fdc, InputStream is) {\n \t\tXMLReader xr;\n-\t\t\n+\n \t\ttry {\n \t\t\t// First up, try the default one\n \t\t\txr = XMLReaderFactory.createXMLReader();\n@@ -460,7 +460,7 @@ private static void checkByte(int b) {\n \t\tpublic void write(byte[] b, int off, int len) throws IOException {\n \t\t\tfor (int i = 0; i < len; i++) {\n \t\t\t\tcheckByte(b[i + off]);\n-\t\t\t\t\n+\n \t\t\t}\n \t\t\t_os.write(b, off, len);\n \t\t}\n@@ -483,7 +483,7 @@ private static void processFile(File effDocFile, File outFile) {\n \t\t} catch(UnsupportedEncodingException e) {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n-\t\t\n+\n \t\toutputLicenseHeader(ps);\n \t\tClass genClass = ExcelFileFormatDocFunctionExtractor.class;\n \t\tps.println(\"# Created by (\" + genClass.getName() + \")\");\n@@ -504,7 +504,7 @@ private static void processFile(File effDocFile, File outFile) {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n \t\tps.close();\n-\t\t\n+\n \t\tString canonicalOutputFileName;\n \t\ttry {\n \t\t\tcanonicalOutputFileName = outFile.getCanonicalPath();\n@@ -554,7 +554,7 @@ private static String getFileMD5(File f) {\n \t\t\tInputStream is = new FileInputStream(f);\n \t\t\twhile(true) {\n \t\t\t\tint bytesRead = is.read(buf);\n-\t\t\t\tif(bytesRead<1) { \n+\t\t\t\tif(bytesRead<1) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tm.update(buf, 0, bytesRead);\n@@ -563,7 +563,7 @@ private static String getFileMD5(File f) {\n \t\t} catch (IOException e) {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n-\t\t\n+\n \t\treturn \"0x\" + new BigInteger(1, m.digest()).toString(16);\n \t}\n \n@@ -585,7 +585,7 @@ private static File downloadSourceFile() {\n \t\t\tOutputStream os = new FileOutputStream(result);\n \t\t\twhile(true) {\n \t\t\t\tint bytesRead = is.read(buf);\n-\t\t\t\tif(bytesRead<1) { \n+\t\t\t\tif(bytesRead<1) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tos.write(buf, 0, bytesRead);\n@@ -609,7 +609,7 @@ public static void main(String[] args) {\n \t\t\tprocessFile(effDocFile, outFile);\n \t\t\treturn;\n \t\t}\n-\t\t\n+\n \t\tFile tempEFFDocFile = downloadSourceFile();\n \t\tprocessFile(tempEFFDocFile, outFile);\n \t\ttempEFFDocFile.delete();",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java",
                "sha": "c3a026c211d6963c20f46bddf184f63798757666",
                "status": "modified"
            },
            {
                "additions": 37,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hssf/usermodel/StreamUtility.java",
                "changes": 74,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/StreamUtility.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 37,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/StreamUtility.java",
                "patch": "@@ -6,7 +6,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    (the \"License\"); you may not use this file except in compliance with\n    the License.  You may obtain a copy of the License at\n \n-       http://www.apache.org/licenses/LICENSE-2.0\n+\t   http://www.apache.org/licenses/LICENSE-2.0\n \n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -23,24 +23,24 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.List;\n \n /**\n- * Utility class to help test code verify that generated files do not differ from proof copies in \n+ * Utility class to help test code verify that generated files do not differ from proof copies in\n  * any significant detail.  Normally this task would be simple except for the presence of artifacts\n- * in the file that change every time it is generated.  Usually these volatile artifacts are  \n+ * in the file that change every time it is generated.  Usually these volatile artifacts are\n  * time-stamps, user names, or other machine dependent parameters.\n- *  \n+ *\n  * @author Josh Micich\n  */\n public final class StreamUtility {\n \n \t/**\n \t * Compares two streams with expected differences in specified regions.  The streams are\n-     * expected to be of equal length and comparison is always byte for byte.  That is -\n-     * differences can only involve exchanging each individual byte for another single byte.<br>\n-     * Both input streams are closed.\n-     *  \n-\t * @param allowableDifferenceRegions array of integer pairs: (offset, length). \n+\t * expected to be of equal length and comparison is always byte for byte.  That is -\n+\t * differences can only involve exchanging each individual byte for another single byte.<br>\n+\t * Both input streams are closed.\n+\t *\n+\t * @param allowableDifferenceRegions array of integer pairs: (offset, length).\n \t * Any differences encountered in these regions of the streams will be ignored\n-\t * @return <code>null</code> if streams are identical, else the \n+\t * @return <code>null</code> if streams are identical, else the\n \t * byte indexes of differing data.  If streams were different lengths,\n \t * the returned indexes will be -1 and the length of the shorter stream\n \t */\n@@ -51,36 +51,36 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \t\t}\n \t\tboolean success = false;\n \t\tint[] result;\n-        try {\n-            result = diffInternal(isA, isB, allowableDifferenceRegions);\n-            success = true;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            close(isA, success);\n-            close(isB, success);\n-        }\n-        return result;\n+\t\ttry {\n+\t\t\tresult = diffInternal(isA, isB, allowableDifferenceRegions);\n+\t\t\tsuccess = true;\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t} finally {\n+\t\t\tclose(isA, success);\n+\t\t\tclose(isB, success);\n+\t\t}\n+\t\treturn result;\n \t}\n \n \t/**\n \t * @param success <code>false</code> if the outer method is throwing an exception.\n \t */\n-    private static void close(InputStream is, boolean success) {\n-        try {\n-            is.close();\n-        } catch (IOException e) {\n-            if(success) {\n-                // this is a new error. ok to throw\n-                throw new RuntimeException(e);\n-            }\n-            // else don't subvert original exception. just print stack trace for this one\n-            e.printStackTrace();\n-        }\n-    }\n+\tprivate static void close(InputStream is, boolean success) {\n+\t\ttry {\n+\t\t\tis.close();\n+\t\t} catch (IOException e) {\n+\t\t\tif(success) {\n+\t\t\t\t// this is a new error. ok to throw\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t\t// else don't subvert original exception. just print stack trace for this one\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n \n-    private static int[] diffInternal(InputStream isA, InputStream isB, int[] allowableDifferenceRegions)\n-            throws IOException {\n+\tprivate static int[] diffInternal(InputStream isA, InputStream isB, int[] allowableDifferenceRegions)\n+\t\t\tthrows IOException {\n \t\tint offset = 0;\n \t\tList temp = new ArrayList();\n \t\twhile (true) {\n@@ -97,11 +97,11 @@ private static void close(InputStream is, boolean success) {\n \t\t\t\treturn new int[] { -1, offset, };\n \t\t\t}\n \t\t\tif (b != b2 && !isIgnoredRegion(allowableDifferenceRegions, offset)) {\n-\t\t\t\ttemp.add(new Integer(offset));\n+\t\t\t\ttemp.add(Integer.valueOf(offset));\n \t\t\t}\n \t\t\toffset++;\n \t\t}\n-    }\n+\t}\n \n \tprivate static boolean isIgnoredRegion(int[] allowableDifferenceRegions, int offset) {\n \t\tfor (int i = 0; i < allowableDifferenceRegions.length; i+=2) {\n@@ -121,7 +121,7 @@ private static boolean isIgnoredRegion(int[] allowableDifferenceRegions, int off\n \t\t}\n \t\tInteger[] boxInts = new Integer[nItems];\n \t\ttemp.toArray(boxInts);\n-\t\t\n+\n \t\tint[] result = new int[nItems];\n \t\tfor (int i = 0; i < result.length; i++) {\n \t\t\tresult[i] = boxInts[i].intValue();",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/hssf/usermodel/StreamUtility.java",
                "sha": "b9f39a03c6878cc426f8ec0f10200dd8b54b6601",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/ss/usermodel/BaseTestDataFormat.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/usermodel/BaseTestDataFormat.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/ss/usermodel/BaseTestDataFormat.java",
                "patch": "@@ -40,7 +40,7 @@ public void baseBuiltinFormats() {\n \n         Map<Integer, String> formats = BuiltinFormats.getBuiltinFormats();\n         for (int idx : formats.keySet()) {\n-            String fmt = formats.get(new Integer(idx));\n+            String fmt = formats.get(Integer.valueOf(idx));\n             assertEquals(idx, df.getFormat(fmt));\n         }\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/ss/usermodel/BaseTestDataFormat.java",
                "sha": "b1c21dd373aba552b1288e3dabf49fae0920bc4d",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/LocalTestNode.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/util/LocalTestNode.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 3,
                "filename": "src/testcases/org/apache/poi/util/LocalTestNode.java",
                "patch": "@@ -15,7 +15,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.util;\n \n@@ -33,7 +32,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n     LocalTestNode(final int key)\n     {\n-        _key   = new Integer(key);\n+        _key   = Integer.valueOf(key);\n         _value = String.valueOf(key);\n     }\n \n@@ -118,7 +117,6 @@ public boolean equals(Object o)\n     /**\n      * @return hash code\n      */\n-\n     public int hashCode()\n     {\n         return getKey().hashCode() ^ getValue().hashCode();",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/LocalTestNode.java",
                "sha": "6eaaed59015f51f6f191cb0225ec8b499bf7d90e",
                "status": "modified"
            },
            {
                "additions": 178,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestArrayUtil.java",
                "changes": 354,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/util/TestArrayUtil.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 176,
                "filename": "src/testcases/org/apache/poi/util/TestArrayUtil.java",
                "patch": "@@ -15,261 +15,264 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n+\n package org.apache.poi.util;\n \n-import junit.framework.*;\n+import junit.framework.TestCase;\n \n /**\n  * Unit test for ArrayUtil\n  *\n  * @author Nick Burch\n  */\n-public class TestArrayUtil extends TestCase\n-{\n+public class TestArrayUtil extends TestCase {\n \t/**\n \t * Test to ensure that our own arraycopy behaves as it should do\n \t */\n \tpublic void testarraycopy() {\n \t\tbyte[] bytes = new byte[] { 0x01, 0x02, 0x03, 0x04 };\n-\t\t\n+\n \t\t// Test copy whole thing\n \t\tbyte[] dest = new byte[4];\n \t\tArrayUtil.arraycopy(bytes, 0, dest, 0, 4);\n-\t\t\n+\n \t\tassertEquals(dest.length, bytes.length);\n \t\tfor(int i=0; i<dest.length; i++) {\n \t\t\tassertEquals(bytes[i], dest[i]);\n \t\t}\n-\t\t\n+\n \t\t// ToDo - test exceptions are as expected\n \t}\n-\t\n-\t\n+\n+\n \t/**\n-\t * Helper for testArrayMoveWithin \n+\t * Helper for testArrayMoveWithin\n \t */\n-\tprivate Integer[] getIntsList() { \n+\tprivate Integer[] getIntsList() {\n \t\treturn new Integer[] {\n-\t\t\t\tnew Integer(0),\n-\t\t\t\tnew Integer(1),\n-\t\t\t\tnew Integer(2),\n-\t\t\t\tnew Integer(3),\n-\t\t\t\tnew Integer(4),\n-\t\t\t\tnew Integer(5),\n-\t\t\t\tnew Integer(6),\n-\t\t\t\tnew Integer(7),\n-\t\t\t\tnew Integer(8),\n-\t\t\t\tnew Integer(9)\n+\t\t\t\tInteger.valueOf(0),\n+\t\t\t\tInteger.valueOf(1),\n+\t\t\t\tInteger.valueOf(2),\n+\t\t\t\tInteger.valueOf(3),\n+\t\t\t\tInteger.valueOf(4),\n+\t\t\t\tInteger.valueOf(5),\n+\t\t\t\tInteger.valueOf(6),\n+\t\t\t\tInteger.valueOf(7),\n+\t\t\t\tInteger.valueOf(8),\n+\t\t\t\tInteger.valueOf(9)\n \t\t};\n \t}\n+\n+\tprivate static void assertEquals(int exp, Integer act) {\n+\t\tassertEquals(exp, act.intValue());\n+\t}\n \t\n \t/**\n \t * Test to ensure that arrayMoveWithin works as expected\n \t */\n \tpublic void testArrayMoveWithin() {\n \t\tInteger[] ints = getIntsList();\n-\t\t\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(2), ints[2]);\n-\t\tassertEquals(new Integer(3), ints[3]);\n-\t\tassertEquals(new Integer(4), ints[4]);\n-\t\tassertEquals(new Integer(5), ints[5]);\n-\t\tassertEquals(new Integer(6), ints[6]);\n-\t\tassertEquals(new Integer(7), ints[7]);\n-\t\tassertEquals(new Integer(8), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n-\t\t\n+\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(2, ints[2]);\n+\t\tassertEquals(3, ints[3]);\n+\t\tassertEquals(4, ints[4]);\n+\t\tassertEquals(5, ints[5]);\n+\t\tassertEquals(6, ints[6]);\n+\t\tassertEquals(7, ints[7]);\n+\t\tassertEquals(8, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n+\n \t\t//\n \t\t// Moving to a later point in the array\n \t\t//\n-\t\t\n+\n \t\t// Shift 1 back\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 4, 8, 1);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(2), ints[2]);\n-\t\tassertEquals(new Integer(3), ints[3]);\n-\t\tassertEquals(new Integer(5), ints[4]);\n-\t\tassertEquals(new Integer(6), ints[5]);\n-\t\tassertEquals(new Integer(7), ints[6]);\n-\t\tassertEquals(new Integer(8), ints[7]);\n-\t\tassertEquals(new Integer(4), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(2, ints[2]);\n+\t\tassertEquals(3, ints[3]);\n+\t\tassertEquals(5, ints[4]);\n+\t\tassertEquals(6, ints[5]);\n+\t\tassertEquals(7, ints[6]);\n+\t\tassertEquals(8, ints[7]);\n+\t\tassertEquals(4, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n \t\t// Shift front 1 back\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 0, 7, 1);\n-\t\tassertEquals(new Integer(1), ints[0]);\n-\t\tassertEquals(new Integer(2), ints[1]);\n-\t\tassertEquals(new Integer(3), ints[2]);\n-\t\tassertEquals(new Integer(4), ints[3]);\n-\t\tassertEquals(new Integer(5), ints[4]);\n-\t\tassertEquals(new Integer(6), ints[5]);\n-\t\tassertEquals(new Integer(7), ints[6]);\n-\t\tassertEquals(new Integer(0), ints[7]);\n-\t\tassertEquals(new Integer(8), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n+\t\tassertEquals(1, ints[0]);\n+\t\tassertEquals(2, ints[1]);\n+\t\tassertEquals(3, ints[2]);\n+\t\tassertEquals(4, ints[3]);\n+\t\tassertEquals(5, ints[4]);\n+\t\tassertEquals(6, ints[5]);\n+\t\tassertEquals(7, ints[6]);\n+\t\tassertEquals(0, ints[7]);\n+\t\tassertEquals(8, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n \t\t// Shift 1 to end\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 4, 9, 1);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(2), ints[2]);\n-\t\tassertEquals(new Integer(3), ints[3]);\n-\t\tassertEquals(new Integer(5), ints[4]);\n-\t\tassertEquals(new Integer(6), ints[5]);\n-\t\tassertEquals(new Integer(7), ints[6]);\n-\t\tassertEquals(new Integer(8), ints[7]);\n-\t\tassertEquals(new Integer(9), ints[8]);\n-\t\tassertEquals(new Integer(4), ints[9]);\n-\n-\t\t\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(2, ints[2]);\n+\t\tassertEquals(3, ints[3]);\n+\t\tassertEquals(5, ints[4]);\n+\t\tassertEquals(6, ints[5]);\n+\t\tassertEquals(7, ints[6]);\n+\t\tassertEquals(8, ints[7]);\n+\t\tassertEquals(9, ints[8]);\n+\t\tassertEquals(4, ints[9]);\n+\n+\n \t\t//\n \t\t// Moving to an earlier point in the array\n \t\t//\n-\t\t\n+\n \t\t// Shift 1 forward\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 8, 3, 1);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(2), ints[2]);\n-\t\tassertEquals(new Integer(8), ints[3]);\n-\t\tassertEquals(new Integer(3), ints[4]);\n-\t\tassertEquals(new Integer(4), ints[5]);\n-\t\tassertEquals(new Integer(5), ints[6]);\n-\t\tassertEquals(new Integer(6), ints[7]);\n-\t\tassertEquals(new Integer(7), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(2, ints[2]);\n+\t\tassertEquals(8, ints[3]);\n+\t\tassertEquals(3, ints[4]);\n+\t\tassertEquals(4, ints[5]);\n+\t\tassertEquals(5, ints[6]);\n+\t\tassertEquals(6, ints[7]);\n+\t\tassertEquals(7, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n \t\t// Shift end 1 forward\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 9, 2, 1);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(9), ints[2]);\n-\t\tassertEquals(new Integer(2), ints[3]);\n-\t\tassertEquals(new Integer(3), ints[4]);\n-\t\tassertEquals(new Integer(4), ints[5]);\n-\t\tassertEquals(new Integer(5), ints[6]);\n-\t\tassertEquals(new Integer(6), ints[7]);\n-\t\tassertEquals(new Integer(7), ints[8]);\n-\t\tassertEquals(new Integer(8), ints[9]);\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(9, ints[2]);\n+\t\tassertEquals(2, ints[3]);\n+\t\tassertEquals(3, ints[4]);\n+\t\tassertEquals(4, ints[5]);\n+\t\tassertEquals(5, ints[6]);\n+\t\tassertEquals(6, ints[7]);\n+\t\tassertEquals(7, ints[8]);\n+\t\tassertEquals(8, ints[9]);\n+\n \t\t// Shift 1 to front\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 5, 0, 1);\n-\t\tassertEquals(new Integer(5), ints[0]);\n-\t\tassertEquals(new Integer(0), ints[1]);\n-\t\tassertEquals(new Integer(1), ints[2]);\n-\t\tassertEquals(new Integer(2), ints[3]);\n-\t\tassertEquals(new Integer(3), ints[4]);\n-\t\tassertEquals(new Integer(4), ints[5]);\n-\t\tassertEquals(new Integer(6), ints[6]);\n-\t\tassertEquals(new Integer(7), ints[7]);\n-\t\tassertEquals(new Integer(8), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\n-\t\t\n+\t\tassertEquals(5, ints[0]);\n+\t\tassertEquals(0, ints[1]);\n+\t\tassertEquals(1, ints[2]);\n+\t\tassertEquals(2, ints[3]);\n+\t\tassertEquals(3, ints[4]);\n+\t\tassertEquals(4, ints[5]);\n+\t\tassertEquals(6, ints[6]);\n+\t\tassertEquals(7, ints[7]);\n+\t\tassertEquals(8, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n+\n \t\t//\n \t\t// Moving many to a later point in the array\n \t\t//\n-\t\t\n+\n \t\t// Shift 3 back\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 2, 6, 3);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(5), ints[2]);\n-\t\tassertEquals(new Integer(6), ints[3]);\n-\t\tassertEquals(new Integer(7), ints[4]);\n-\t\tassertEquals(new Integer(8), ints[5]);\n-\t\tassertEquals(new Integer(2), ints[6]);\n-\t\tassertEquals(new Integer(3), ints[7]);\n-\t\tassertEquals(new Integer(4), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(5, ints[2]);\n+\t\tassertEquals(6, ints[3]);\n+\t\tassertEquals(7, ints[4]);\n+\t\tassertEquals(8, ints[5]);\n+\t\tassertEquals(2, ints[6]);\n+\t\tassertEquals(3, ints[7]);\n+\t\tassertEquals(4, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n \t\t// Shift 3 to back\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 2, 7, 3);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(5), ints[2]);\n-\t\tassertEquals(new Integer(6), ints[3]);\n-\t\tassertEquals(new Integer(7), ints[4]);\n-\t\tassertEquals(new Integer(8), ints[5]);\n-\t\tassertEquals(new Integer(9), ints[6]);\n-\t\tassertEquals(new Integer(2), ints[7]);\n-\t\tassertEquals(new Integer(3), ints[8]);\n-\t\tassertEquals(new Integer(4), ints[9]);\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(5, ints[2]);\n+\t\tassertEquals(6, ints[3]);\n+\t\tassertEquals(7, ints[4]);\n+\t\tassertEquals(8, ints[5]);\n+\t\tassertEquals(9, ints[6]);\n+\t\tassertEquals(2, ints[7]);\n+\t\tassertEquals(3, ints[8]);\n+\t\tassertEquals(4, ints[9]);\n+\n \t\t// Shift from 3 front\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 0, 5, 3);\n-\t\tassertEquals(new Integer(3), ints[0]);\n-\t\tassertEquals(new Integer(4), ints[1]);\n-\t\tassertEquals(new Integer(5), ints[2]);\n-\t\tassertEquals(new Integer(6), ints[3]);\n-\t\tassertEquals(new Integer(7), ints[4]);\n-\t\tassertEquals(new Integer(0), ints[5]);\n-\t\tassertEquals(new Integer(1), ints[6]);\n-\t\tassertEquals(new Integer(2), ints[7]);\n-\t\tassertEquals(new Integer(8), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n-\t\t\n+\t\tassertEquals(3, ints[0]);\n+\t\tassertEquals(4, ints[1]);\n+\t\tassertEquals(5, ints[2]);\n+\t\tassertEquals(6, ints[3]);\n+\t\tassertEquals(7, ints[4]);\n+\t\tassertEquals(0, ints[5]);\n+\t\tassertEquals(1, ints[6]);\n+\t\tassertEquals(2, ints[7]);\n+\t\tassertEquals(8, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n+\n \t\t//\n \t\t// Moving many to an earlier point in the array\n \t\t//\n-\t\t\n+\n \t\t// Shift 3 forward\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 6, 2, 3);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(6), ints[2]);\n-\t\tassertEquals(new Integer(7), ints[3]);\n-\t\tassertEquals(new Integer(8), ints[4]);\n-\t\tassertEquals(new Integer(2), ints[5]);\n-\t\tassertEquals(new Integer(3), ints[6]);\n-\t\tassertEquals(new Integer(4), ints[7]);\n-\t\tassertEquals(new Integer(5), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(6, ints[2]);\n+\t\tassertEquals(7, ints[3]);\n+\t\tassertEquals(8, ints[4]);\n+\t\tassertEquals(2, ints[5]);\n+\t\tassertEquals(3, ints[6]);\n+\t\tassertEquals(4, ints[7]);\n+\t\tassertEquals(5, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n \t\t// Shift 3 to front\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 6, 0, 3);\n-\t\tassertEquals(new Integer(6), ints[0]);\n-\t\tassertEquals(new Integer(7), ints[1]);\n-\t\tassertEquals(new Integer(8), ints[2]);\n-\t\tassertEquals(new Integer(0), ints[3]);\n-\t\tassertEquals(new Integer(1), ints[4]);\n-\t\tassertEquals(new Integer(2), ints[5]);\n-\t\tassertEquals(new Integer(3), ints[6]);\n-\t\tassertEquals(new Integer(4), ints[7]);\n-\t\tassertEquals(new Integer(5), ints[8]);\n-\t\tassertEquals(new Integer(9), ints[9]);\n-\t\t\n+\t\tassertEquals(6, ints[0]);\n+\t\tassertEquals(7, ints[1]);\n+\t\tassertEquals(8, ints[2]);\n+\t\tassertEquals(0, ints[3]);\n+\t\tassertEquals(1, ints[4]);\n+\t\tassertEquals(2, ints[5]);\n+\t\tassertEquals(3, ints[6]);\n+\t\tassertEquals(4, ints[7]);\n+\t\tassertEquals(5, ints[8]);\n+\t\tassertEquals(9, ints[9]);\n+\n \t\t// Shift from 3 back\n \t\tints = getIntsList();\n \t\tArrayUtil.arrayMoveWithin(ints, 7, 3, 3);\n-\t\tassertEquals(new Integer(0), ints[0]);\n-\t\tassertEquals(new Integer(1), ints[1]);\n-\t\tassertEquals(new Integer(2), ints[2]);\n-\t\tassertEquals(new Integer(7), ints[3]);\n-\t\tassertEquals(new Integer(8), ints[4]);\n-\t\tassertEquals(new Integer(9), ints[5]);\n-\t\tassertEquals(new Integer(3), ints[6]);\n-\t\tassertEquals(new Integer(4), ints[7]);\n-\t\tassertEquals(new Integer(5), ints[8]);\n-\t\tassertEquals(new Integer(6), ints[9]);\n-\t\t\n-\t\t\n+\t\tassertEquals(0, ints[0]);\n+\t\tassertEquals(1, ints[1]);\n+\t\tassertEquals(2, ints[2]);\n+\t\tassertEquals(7, ints[3]);\n+\t\tassertEquals(8, ints[4]);\n+\t\tassertEquals(9, ints[5]);\n+\t\tassertEquals(3, ints[6]);\n+\t\tassertEquals(4, ints[7]);\n+\t\tassertEquals(5, ints[8]);\n+\t\tassertEquals(6, ints[9]);\n+\n+\n \t\t// Check can't shift more than we have\n \t\ttry {\n \t\t\tints = getIntsList();\n@@ -278,7 +281,7 @@ public void testArrayMoveWithin() {\n \t\t} catch(IllegalArgumentException e) {\n \t\t\t// Good, we don't have 5 from 7 onwards\n \t\t}\n-\t\t\n+\n \t\t// Check can't shift where would overshoot\n \t\ttry {\n \t\t\tints = getIntsList();\n@@ -289,4 +292,3 @@ public void testArrayMoveWithin() {\n \t\t}\n \t}\n }\n-",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestArrayUtil.java",
                "sha": "2af0481513f86a99ba7642b69d34b1e3d1763ad8",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestBinaryTree.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/util/TestBinaryTree.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 12,
                "filename": "src/testcases/org/apache/poi/util/TestBinaryTree.java",
                "patch": "@@ -120,7 +120,7 @@ public void testContainsKey() {\n             m.put(nodes[ k ].getKey(), nodes[ k ]);\n             assertTrue(m.containsKey(nodes[ k ].getKey()));\n         }\n-        assertTrue(!m.containsKey(new Integer(-1)));\n+        assertTrue(!m.containsKey(Integer.valueOf(-1)));\n         try\n         {\n             m.containsKey(\"foo\");\n@@ -179,7 +179,7 @@ public void testGet() {\n             m.put(nodes[ k ].getKey(), nodes[ k ]);\n             assertSame(m.get(nodes[ k ].getKey()), nodes[ k ]);\n         }\n-        assertNull(m.get(new Integer(-1)));\n+        assertNull(m.get(Integer.valueOf(-1)));\n         try\n         {\n             m.get(\"foo\");\n@@ -270,7 +270,7 @@ public void testRemove() {\n         catch (ClassCastException ignored)\n         {\n         }\n-        assertNull(m.remove(new Integer(-1)));\n+        assertNull(m.remove(Integer.valueOf(-1)));\n         try\n         {\n             m.remove(\"foo\");\n@@ -450,7 +450,7 @@ public void testKeySet() {\n         Collection c1 = new LinkedList();\n         Collection c2 = new LinkedList();\n \n-        c2.add(new Integer(-99));\n+        c2.add(Integer.valueOf(-99));\n         for (int k = 0; k < nodes.length; k++)\n         {\n             m.put(nodes[ k ].getKey(), nodes[ k ]);\n@@ -461,7 +461,7 @@ public void testKeySet() {\n         assertTrue(!m.keySet().containsAll(c2));\n         m  = new BinaryTree();\n         c1 = new LinkedList();\n-        c1.add(new Integer(-55));\n+        c1.add(Integer.valueOf(-55));\n         try\n         {\n             m.keySet().addAll(c1);\n@@ -869,7 +869,7 @@ public void testConstructors() {\n         }\n \n         // reject incompatible values\n-        m2.put(\"2\", new Integer(2));\n+        m2.put(\"2\", Integer.valueOf(2));\n         try\n         {\n             m = new BinaryTree(m2);\n@@ -881,7 +881,7 @@ public void testConstructors() {\n \n         // reject incompatible keys\n         m2.remove(\"2\");\n-        m2.put(new Integer(2), \"bad key\");\n+        m2.put(Integer.valueOf(2), \"bad key\");\n         try\n         {\n             m = new BinaryTree(m2);\n@@ -973,7 +973,7 @@ public void testRemoveValue() {\n         catch (ClassCastException ignored)\n         {\n         }\n-        assertNull(m.remove(new Integer(-1)));\n+        assertNull(m.remove(Integer.valueOf(-1)));\n         try\n         {\n             m.removeValue(\"foo\");\n@@ -1135,7 +1135,7 @@ public void testKeySetByValue() {\n         Collection c1 = new LinkedList();\n         Collection c2 = new LinkedList();\n \n-        c2.add(new Integer(-99));\n+        c2.add(Integer.valueOf(-99));\n         for (int k = 0; k < nodes.length; k++)\n         {\n             m.put(nodes[ k ].getKey(), nodes[ k ]);\n@@ -1146,7 +1146,7 @@ public void testKeySetByValue() {\n         assertTrue(!m.keySetByValue().containsAll(c2));\n         m  = new BinaryTree();\n         c1 = new LinkedList();\n-        c1.add(new Integer(-55));\n+        c1.add(Integer.valueOf(-55));\n         try\n         {\n             m.keySetByValue().addAll(c1);\n@@ -1390,7 +1390,7 @@ private static void testKeySet(final Map m) {\n         }\n         for (int k = 0; k < m.size(); k++)\n         {\n-            assertTrue(s.contains(new Integer(k)));\n+            assertTrue(s.contains(Integer.valueOf(k)));\n         }\n         int count = 0;\n \n@@ -1616,7 +1616,7 @@ private static void testKeySetByValue(final BinaryTree m) {\n         }\n         for (int k = 0; k < m.size(); k++)\n         {\n-            assertTrue(s.contains(new Integer(k)));\n+            assertTrue(s.contains(Integer.valueOf(k)));\n         }\n         int count = 0;\n ",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestBinaryTree.java",
                "sha": "542635980fa4f6d54ad79d869f820196028a0c93",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestPOILogger.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/util/TestPOILogger.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 2,
                "filename": "src/testcases/org/apache/poi/util/TestPOILogger.java",
                "patch": "@@ -39,8 +39,8 @@ public void testVariousLogTypes() {\n \n         POILogger log = POILogFactory.getLogger( \"foo\" );\n \n-        log.log( POILogger.WARN, \"Test = \", new Integer( 1 ) );\n-        log.logFormatted( POILogger.ERROR, \"Test param 1 = %, param 2 = %\", \"2\", new Integer( 3 ) );\n+        log.log( POILogger.WARN, \"Test = \", Integer.valueOf( 1 ) );\n+        log.logFormatted( POILogger.ERROR, \"Test param 1 = %, param 2 = %\", \"2\", Integer.valueOf( 3 ) );\n         log.logFormatted( POILogger.ERROR, \"Test param 1 = %, param 2 = %\", new int[]{4, 5} );\n         log.logFormatted( POILogger.ERROR,\n                 \"Test param 1 = %1.1, param 2 = %0.1\", new double[]{4, 5.23} );",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestPOILogger.java",
                "sha": "a3d34fac17a76949fdacce6fbf132d1803c87496",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestStringUtil.java",
                "changes": 72,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/util/TestStringUtil.java?ref=78e643fe2184d931b08120ee5f29e2b2e9daf3c1",
                "deletions": 49,
                "filename": "src/testcases/org/apache/poi/util/TestStringUtil.java",
                "patch": "@@ -60,11 +60,11 @@ public void testPutCompressedUnicode() {\n                     (byte) 'r', (byte) 'l', (byte) 'd', (byte) 0xAE\n                 };\n         String input;\n-\t\ttry {\n-\t\t\tinput = new String( expected_output, StringUtil.getPreferredEncoding() );\n-\t\t} catch (UnsupportedEncodingException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n+        try {\n+            input = new String( expected_output, StringUtil.getPreferredEncoding() );\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n \n         StringUtil.putCompressedUnicode( input, output, 0 );\n         for ( int j = 0; j < expected_output.length; j++ )\n@@ -129,57 +129,31 @@ public void testPutUncompressedUnicode() {\n     }\n \n     public void testFormat() {\n-        assertEquals( \"This is a test \" + fmt( 1.2345, 2, 2 ),\n-                StringUtil.format( \"This is a test %2.2\", new Object[]\n-                {\n-                    new Double( 1.2345 )\n-                } ) );\n-        assertEquals( \"This is a test \" + fmt( 1.2345, -1, 3 ),\n-                StringUtil.format( \"This is a test %.3\", new Object[]\n-                {\n-                    new Double( 1.2345 )\n-                } ) );\n-        assertEquals( \"This is a great test \" + fmt( 1.2345, -1, 3 ),\n-                StringUtil.format( \"This is a % test %.3\", new Object[]\n-                {\n-                    \"great\", new Double( 1.2345 )\n-                } ) );\n-        assertEquals( \"This is a test 1\",\n-                StringUtil.format( \"This is a test %\", new Object[]\n-                {\n-                    new Integer( 1 )\n-                } ) );\n-        assertEquals( \"This is a test 1\",\n-                StringUtil.format( \"This is a test %\", new Object[]\n-                {\n-                    new Integer( 1 ), new Integer( 1 )\n-                } ) );\n-        assertEquals( \"This is a test 1.x\",\n-                StringUtil.format( \"This is a test %1.x\", new Object[]\n-                {\n-                    new Integer( 1 )\n-                } ) );\n-        assertEquals( \"This is a test ?missing data?1.x\",\n-                StringUtil.format( \"This is a test %1.x\", new Object[]\n-                {\n-                } ) );\n-        assertEquals( \"This is a test %1.x\",\n-                StringUtil.format( \"This is a test \\\\%1.x\", new Object[]\n-                {\n-                } ) );\n+\n+        confirm(\"This is a test \" + fmt(1.2345, 2, 2), \"This is a test %2.2\", new Double(1.2345));\n+        confirm(\"This is a test \" + fmt(1.2345, -1, 3), \"This is a test %.3\", new Double(1.2345));\n+        confirm(\"This is a great test \" + fmt(1.2345, -1, 3),\n+                \"This is a % test %.3\", \"great\", new Double(1.2345));\n+        confirm(\"This is a test 1\", \"This is a test %\", Integer.valueOf(1));\n+        confirm(\"This is a test 1\", \"This is a test %\", Integer.valueOf(1), Integer.valueOf(1));\n+        confirm(\"This is a test 1.x\", \"This is a test %1.x\", Integer.valueOf(1));\n+        confirm(\"This is a test ?missing data?1.x\", \"This is a test %1.x\");\n+        confirm(\"This is a test %1.x\", \"This is a test \\\\%1.x\");\n     }\n \n+    private static void confirm(String expectedResult, String fmtString, Object ... params) {\n+        String actualResult = StringUtil.format(fmtString, params);\n+        assertEquals(expectedResult, actualResult);\n+    }\n \n     private static String fmt(double num, int minIntDigits, int maxFracDigitis) {\n         NumberFormat nf = NumberFormat.getInstance();\n \n-        if ( minIntDigits != -1 )\n-        {\n-            nf.setMinimumIntegerDigits( minIntDigits );\n+        if (minIntDigits != -1) {\n+            nf.setMinimumIntegerDigits(minIntDigits);\n         }\n-        if ( maxFracDigitis != -1 )\n-        {\n-            nf.setMaximumFractionDigits( maxFracDigitis );\n+        if (maxFracDigitis != -1) {\n+            nf.setMaximumFractionDigits(maxFracDigitis);\n         }\n \n         return nf.format( num );",
                "raw_url": "https://github.com/apache/poi/raw/78e643fe2184d931b08120ee5f29e2b2e9daf3c1/src/testcases/org/apache/poi/util/TestStringUtil.java",
                "sha": "e05fe0611ac7069d7e0ec79a16cc9bfd39d6fd4c",
                "status": "modified"
            }
        ],
        "message": "Bugzilla 47962 - Fixed some potential NPEs. Avoided unnecessary creation of box instances.  Applied patch with mods\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@823348 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/8f4139a9a6041ec05a30223f84f39e0939bc863b",
        "patched_files": [
            "ShapeTypes.java",
            "VariantSupport.java",
            "RegionUtil.java",
            "PersistPtrHolder.java",
            "EscherAggregate.java",
            "Sheet.java",
            "HSSFRequest.java",
            "IntMapper.java",
            "Chunk.java",
            "WordDocument.java",
            "FileInformationBlock.java",
            "FIBFieldHandler.java",
            "HSSFPictureData.java",
            "StreamUtility.java",
            "RowRecordsAggregate.java",
            "TextObjectRecord.java",
            "POILogger.java",
            "Borders.java",
            "MutableSection.java",
            "RecordContainer.java",
            "CustomProperties.java",
            "TOC.java",
            "Variant.java",
            "ArrayUtil.java",
            "Record.java",
            "Section.java",
            "ListTables.java",
            "DrawingManager.java",
            "SubRecord.java",
            "BTreeSet.java",
            "HSLFSlideShow.java",
            "RecordTypes.java",
            "CString.java",
            "FontDetails.java",
            "UserEditAndPersistListing.java",
            "WorkbookEvaluator.java",
            "DocumentSummaryInformation.java",
            "UserEditAtom.java",
            "Workbook.java",
            "HSSFWorkbook.java",
            "POIXMLProperties.java",
            "SheetReferences.java",
            "NoteRecord.java",
            "StringUtil.java",
            "PowerPointExtractor.java",
            "FSPATable.java",
            "DataFormatter.java",
            "EscherOptRecord.java",
            "PageBreakRecord.java",
            "ChunkFactory.java",
            "ModifyDocumentSummaryInformation.java",
            "EscherProperties.java",
            "XWPFDocument.java",
            "SVTableCellEditor.java",
            "EncryptedSlideShow.java",
            "HexRead.java",
            "BaseTestDataFormat.java",
            "ColumnInfoRecordsAggregate.java",
            "Property.java",
            "PropertyIDMap.java",
            "BuiltinFormats.java",
            "FormatTrackingHSSFListener.java",
            "DefaultEscherRecordFactory.java",
            "SlideIdListing.java",
            "HDFObjectFactory.java",
            "ParagraphSprmUncompressor.java",
            "EmbeddedObjectRefSubRecord.java",
            "CellUtil.java",
            "SlideShow.java",
            "ExcelFileFormatDocFunctionExtractor.java",
            "XSSFExportToXml.java",
            "HSSFColor.java",
            "FunctionDataBuilder.java",
            "SVTableUtils.java",
            "HSSFSheet.java",
            "RecordFactory.java",
            "LocalTestNode.java",
            "BitFieldFactory.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestUnicode.java",
            "TestUserEditAtom.java",
            "TestBugs.java",
            "TestEscherAggregate.java",
            "TestWrite.java",
            "TestFormatTrackingHSSFListener.java",
            "TestEmbeddedObjectRefSubRecord.java",
            "TestWriteWellKnown.java",
            "TestHSSFPictureData.java",
            "TestFontDetails.java",
            "TestBinaryTree.java",
            "TestArrayUtil.java",
            "TestVariantSupport.java",
            "TestUserEditAndPersistListing.java",
            "TestCString.java",
            "TestMetaDataIPI.java",
            "TestColumnInfoRecordsAggregate.java",
            "TestWorkbook.java",
            "TestFileInformationBlock.java",
            "TestRecordFactory.java",
            "TestEscherOptRecord.java",
            "TestRecordContainer.java",
            "TestPOIXMLProperties.java",
            "TestStringUtil.java",
            "TestSheet.java",
            "TestReWriteSanity.java",
            "TestWorkbookEvaluator.java",
            "TestSubRecord.java",
            "TestHSLFSlideShow.java",
            "TestPOILogger.java",
            "TestRowRecordsAggregate.java",
            "TestNoteRecord.java",
            "TestSlideIdListing.java",
            "TestRecordTypes.java",
            "TestRegionUtil.java",
            "TestHSSFSheet.java",
            "TestHSSFWorkbook.java",
            "TestHSSFColor.java",
            "TestListTables.java",
            "TestTextObjectRecord.java",
            "TestDataFormatter.java",
            "TestXWPFDocument.java"
        ]
    },
    "poi_7b15cc3": {
        "bug_id": "poi_7b15cc3",
        "commit": "https://github.com/apache/poi/commit/7b15cc372e8f5564bb6e781f6a62fa2f0dae1a93",
        "file": [
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/7b15cc372e8f5564bb6e781f6a62fa2f0dae1a93/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "changes": 30,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java?ref=7b15cc372e8f5564bb6e781f6a62fa2f0dae1a93",
                "deletions": 7,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "patch": "@@ -817,14 +817,30 @@ public void setBorderBetween(Borders border) {\n      * @return boolean - if page break is set\n      */\n     public boolean isPageBreak() {\n-        CTPPr ppr = getCTPPr();\n-        CTOnOff ctPageBreak = ppr.isSetPageBreakBefore() ? ppr\n-                .getPageBreakBefore() : null;\n-        if (ctPageBreak != null\n-                && ctPageBreak.getVal().intValue() == STOnOff.INT_TRUE) {\n-            return true;\n+        final CTPPr ppr = getCTPPr();\n+        final CTOnOff ctPageBreak = ppr.isSetPageBreakBefore() ? ppr.getPageBreakBefore() : null;\n+        if (ctPageBreak == null) {\n+            return false;\n+        }\n+        return isTruelike(ctPageBreak.getVal(), false);\n+    }\n+\n+    private static boolean isTruelike(final STOnOff.Enum value, boolean defaultValue) {\n+        if (value == null) {\n+            return defaultValue;\n+        }\n+        switch (value.intValue()) {\n+            case STOnOff.INT_TRUE:\n+            case STOnOff.INT_X_1:\n+            case STOnOff.INT_ON:\n+                return true;\n+            case STOnOff.INT_FALSE:\n+            case STOnOff.INT_X_0:\n+            case STOnOff.INT_OFF:\n+                return false;\n+            default:\n+                return defaultValue;\n         }\n-        return false;\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/7b15cc372e8f5564bb6e781f6a62fa2f0dae1a93/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "sha": "64af4f4a6e2190cdbadb1088dffacf87fd1488e2",
                "status": "modified"
            }
        ],
        "message": "github-53: fix NPE when iterating over paragraphs in certain *.docx files. Thanks to Praful Kumar Vaishnav! This closes #53.\nhttps://github.com/apache/poi/pull/53\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1795254 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/980f319270f3eff03d1db16584a335a21dae8eaf",
        "patched_files": [
            "XWPFParagraph.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFParagraph.java"
        ]
    },
    "poi_7e432a3": {
        "bug_id": "poi_7e432a3",
        "commit": "https://github.com/apache/poi/commit/7e432a3211a3fd259897224849489690fd767f0e",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/7e432a3211a3fd259897224849489690fd767f0e/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java?ref=7e432a3211a3fd259897224849489690fd767f0e",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "patch": "@@ -151,7 +151,7 @@ public boolean fetch(XSLFShape shape) {\n     public Rectangle2D getAnchor() {\n \n         CTTransform2D xfrm = getXfrm(false);\n-        if (xfrm == null) {\n+        if (xfrm == null || !xfrm.isSetOff()) {\n             return null;\n         }\n ",
                "raw_url": "https://github.com/apache/poi/raw/7e432a3211a3fd259897224849489690fd767f0e/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "sha": "64ff9a97668eb880a20c10c36793139c481391e5",
                "status": "modified"
            }
        ],
        "message": "#63541 - NullPointerException from XSLFSimpleShape.getAnchor for empty xfrm tags\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1866810 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/8f051a0b88b51ac4df4a1133b3dbf42bf3ba1e17",
        "patched_files": [
            "XSLFSimpleShape.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSLFSimpleShape.java"
        ]
    },
    "poi_7e74976": {
        "bug_id": "poi_7e74976",
        "commit": "https://github.com/apache/poi/commit/7e74976c04fb51724dff868585cecd63b3e9338b",
        "file": [
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/poi/blob/7e74976c04fb51724dff868585cecd63b3e9338b/src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java?ref=7e74976c04fb51724dff868585cecd63b3e9338b",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java",
                "patch": "@@ -135,9 +135,22 @@ public int getOverrideIndexFromListID( int lsid )\n         return _plfLfo.getIlfoByLsid( lsid );\n     }\n \n+    /**\n+     * Get the ListLevel for a given lsid and level\n+     * @param lsid\n+     * @param level\n+     * @return ListLevel if found, or <code>null</code> if ListData can't be found or if level is > that available\n+     */\n   public ListLevel getLevel(int lsid, int level)\n   {\n     ListData lst = _listMap.get(Integer.valueOf(lsid));\n+    if (lst == null) {\n+        if (log.check(POILogger.WARN)) {\n+            log.log(POILogger.WARN, \"ListData for \" +\n+                    lsid + \" was null.\");\n+        }\n+        return null;\n+    }\n     if(level < lst.numLevels()) {\n     \tListLevel lvl = lst.getLevels()[level];\n     \treturn lvl;",
                "raw_url": "https://github.com/apache/poi/raw/7e74976c04fb51724dff868585cecd63b3e9338b/src/scratchpad/src/org/apache/poi/hwpf/model/ListTables.java",
                "sha": "d3865d25ce234ed42b0357a7341b39bd7d64422b",
                "status": "modified"
            }
        ],
        "message": "Bug 60574 prevent rare NPE in ListTables\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1778320 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/cf37b13c3ab1277fdaa722d3f0abc5fe8b7ebe3c",
        "patched_files": [
            "ListTables.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestListTables.java"
        ]
    },
    "poi_7ef203f": {
        "bug_id": "poi_7ef203f",
        "commit": "https://github.com/apache/poi/commit/7ef203f71c1c5a12448d222e8e37d8ec724a5e43",
        "file": [
            {
                "additions": 37,
                "blob_url": "https://github.com/apache/poi/blob/7ef203f71c1c5a12448d222e8e37d8ec724a5e43/src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java?ref=7ef203f71c1c5a12448d222e8e37d8ec724a5e43",
                "deletions": 8,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java",
                "patch": "@@ -84,6 +84,12 @@\n      * TextHeaderAtom, TextBytesAtom ot TextCharsAtom, StyleTextPropAtom etc.\r\n      */\r\n     protected EscherTextboxWrapper _txtbox;\r\n+    \r\n+    /**\r\n+     * Is the TextBox missing the text records which actually\r\n+     *  store the text?\r\n+     */\r\n+    private boolean _missingTextRecords = false;\r\n \r\n     /**\r\n      * Create a TextBox object and initialize it from the supplied Record container.\r\n@@ -544,23 +550,34 @@ public void setTextType(int type){\n     public void setSheet(Sheet sheet){\r\n         _sheet = sheet;\r\n \r\n-        //initialize _txtrun object.\r\n-        //we can't do it in the constructor because the sheet is not assigned yet\r\n+        // Initialize _txtrun object.\r\n+        // (We can't do it in the constructor because the sheet\r\n+        //  is not assigned then, it's only built once we have\r\n+        //  all the records)\r\n         if(_txtrun == null) initTextRun();\r\n-\r\n+        if(_txtrun == null) {\r\n+        \t// No text records found, skip\r\n+        \t_missingTextRecords = true;\r\n+        \treturn;\r\n+        } else {\r\n+        \t_missingTextRecords = false;\r\n+        }\r\n+        \r\n+        // Supply the sheet to our child RichTextRuns\r\n         RichTextRun[] rt = _txtrun.getRichTextRuns();\r\n         for (int i = 0; i < rt.length; i++) {\r\n             rt[i].supplySlideShow(_sheet.getSlideShow());\r\n         }\r\n     }\r\n \r\n     private void initTextRun(){\r\n-\r\n         TextHeaderAtom tha = null;\r\n         TextCharsAtom tca = null;\r\n         TextBytesAtom tba = null;\r\n         StyleTextPropAtom sta = null;\r\n         OutlineTextRefAtom ota = null;\r\n+        \r\n+        // Find the interesting child records \r\n         Record[] child = _txtbox.getChildRecords();\r\n         for (int i = 0; i < child.length; i++) {\r\n             if (child[i] instanceof TextHeaderAtom) tha = (TextHeaderAtom)child[i];\r\n@@ -570,8 +587,10 @@ private void initTextRun(){\n             else if (child[i] instanceof TextCharsAtom) tca = (TextCharsAtom)child[i];\r\n         }\r\n \r\n-        if (ota != null){\r\n-            //TextHeaderAtom, TextBytesAtom and  StyleTextPropAtom are stored outside of  EscherContainerRecord\r\n+        // Special handling for cases where there's an OutlineTextRefAtom\r\n+        if (ota != null) {\r\n+            // TextHeaderAtom, TextBytesAtom and StyleTextPropAtom are\r\n+        \t//  stored outside of  EscherContainerRecord\r\n             int idx = ota.getTextIndex();\r\n             Slide sl = (Slide)getSheet();\r\n             Record[] rec = sl.getSlideAtomsSet().getSlideRecords();\r\n@@ -591,7 +610,17 @@ private void initTextRun(){\n                 }\r\n             }\r\n         }\r\n-        if(tba != null) _txtrun = new TextRun(tha,tba,sta);\r\n-        else if (tca != null) _txtrun = new TextRun(tha,tca,sta);\r\n+        \r\n+        // If we found the records we needed, create a TextRun\r\n+        if(tba != null) {\r\n+        \t// Bytes based Text Run\r\n+        \t_txtrun = new TextRun(tha,tba,sta);\r\n+        } else if (tca != null) {\r\n+        \t// Characters (unicode) based Text Run\r\n+        \t_txtrun = new TextRun(tha,tca,sta);\r\n+        } else {\r\n+        \t// Empty text box\r\n+        \tSystem.err.println(\"Warning - no text records found for TextBox\");\r\n+        }\r\n     }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/7ef203f71c1c5a12448d222e8e37d8ec724a5e43/src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java",
                "sha": "44cee7c0ef289adc6eefe92a75f1690a1cacf5b8",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/7ef203f71c1c5a12448d222e8e37d8ec724a5e43/src/scratchpad/testcases/org/apache/poi/hslf/data/empty_textbox.ppt",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/data/empty_textbox.ppt?ref=7ef203f71c1c5a12448d222e8e37d8ec724a5e43",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/data/empty_textbox.ppt",
                "raw_url": "https://github.com/apache/poi/raw/7ef203f71c1c5a12448d222e8e37d8ec724a5e43/src/scratchpad/testcases/org/apache/poi/hslf/data/empty_textbox.ppt",
                "sha": "403b2861e28b0402924b5b17d9a046ce1411a037",
                "status": "added"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/7ef203f71c1c5a12448d222e8e37d8ec724a5e43/src/scratchpad/testcases/org/apache/poi/hslf/model/TestShapes.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestShapes.java?ref=7ef203f71c1c5a12448d222e8e37d8ec724a5e43",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestShapes.java",
                "patch": "@@ -33,11 +33,15 @@\n  */\r\n public class TestShapes extends TestCase {\r\n     private SlideShow ppt;\r\n+    private SlideShow pptB;\r\n \r\n     protected void setUp() throws Exception {\r\n \t\tString dirname = System.getProperty(\"HSLF.testdata.path\");\r\n \t\tString filename = dirname + \"/empty.ppt\";\r\n \t\tppt = new SlideShow(new HSLFSlideShow(filename));\r\n+\t\t\r\n+\t\tString filenameB = dirname + \"/empty_textbox.ppt\";\r\n+\t\tpptB = new SlideShow(new HSLFSlideShow(filenameB));\r\n     }\r\n \r\n     public void testGraphics() throws Exception {\r\n@@ -169,6 +173,19 @@ public void testTextBoxWriteBytes() throws Exception {\n         assertEquals(\"Arial\", rt.getFontName());\r\n         assertEquals(Color.red, txtbox.getFontColor());\r\n     }\r\n+    \r\n+    /**\r\n+     * Test with an empty text box\r\n+     */\r\n+    public void testEmptyTextBox() throws Exception {\r\n+    \tassertEquals(2, pptB.getSlides().length);\r\n+    \tSlide s1 = pptB.getSlides()[0];\r\n+    \tSlide s2 = pptB.getSlides()[1];\r\n+    \t\r\n+    \t// Check we can get the shapes count\r\n+    \tassertEquals(2, s1.getShapes().length);\r\n+    \tassertEquals(2, s2.getShapes().length);\r\n+    }\r\n \r\n     /**\r\n      * If you iterate over text shapes in a slide and collect them in a set\r",
                "raw_url": "https://github.com/apache/poi/raw/7ef203f71c1c5a12448d222e8e37d8ec724a5e43/src/scratchpad/testcases/org/apache/poi/hslf/model/TestShapes.java",
                "sha": "6d2f1fcc3561e4d28b087739d25dcc7d02025799",
                "status": "modified"
            }
        ],
        "message": "Fix for NPE in bug #40036. The TextBox will still be fairly useless though\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@450097 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/a2d54c0fe2f4b491b49325c57189659e16cac4cc",
        "patched_files": [
            "TextBox.java",
            "empty_textbox.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestShapes.java"
        ]
    },
    "poi_827d628": {
        "bug_id": "poi_827d628",
        "commit": "https://github.com/apache/poi/commit/827d6284097ee2950c0301f642e713615570eb7b",
        "file": [
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/poi/blob/827d6284097ee2950c0301f642e713615570eb7b/src/ooxml/java/org/apache/poi/ooxml/POIXMLProperties.java",
                "changes": 50,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/ooxml/POIXMLProperties.java?ref=827d6284097ee2950c0301f642e713615570eb7b",
                "deletions": 22,
                "filename": "src/ooxml/java/org/apache/poi/ooxml/POIXMLProperties.java",
                "patch": "@@ -68,17 +68,20 @@ public POIXMLProperties(OPCPackage docPackage) throws IOException, OpenXML4JExce\n         this.pkg = docPackage;\n \n         // Core properties\n-        core = new CoreProperties((PackagePropertiesPart)pkg.getPackageProperties() );\n+        core = new CoreProperties((PackagePropertiesPart)pkg.getPackageProperties());\n \n         // Extended properties\n         PackageRelationshipCollection extRel =\n                 pkg.getRelationshipsByType(PackageRelationshipTypes.EXTENDED_PROPERTIES);\n         if(extRel.size() == 1) {\n-            extPart = pkg.getPart( extRel.getRelationship(0));\n-            org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument.Factory.parse(\n-                    extPart.getInputStream(), DEFAULT_XML_OPTIONS\n-            );\n-            ext = new ExtendedProperties(props);\n+            extPart = pkg.getPart(extRel.getRelationship(0));\n+            if (extPart == null) {\n+                ext = new ExtendedProperties((org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument)NEW_EXT_INSTANCE.copy());\n+            } else {\n+                org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument.Factory.parse(\n+                        extPart.getInputStream(), DEFAULT_XML_OPTIONS);\n+                ext = new ExtendedProperties(props);\n+            }\n         } else {\n             extPart = null;\n             ext = new ExtendedProperties((org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument)NEW_EXT_INSTANCE.copy());\n@@ -88,11 +91,14 @@ public POIXMLProperties(OPCPackage docPackage) throws IOException, OpenXML4JExce\n         PackageRelationshipCollection custRel =\n                 pkg.getRelationshipsByType(PackageRelationshipTypes.CUSTOM_PROPERTIES);\n         if(custRel.size() == 1) {\n-            custPart = pkg.getPart( custRel.getRelationship(0));\n-            org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument.Factory.parse(\n-                    custPart.getInputStream(), DEFAULT_XML_OPTIONS\n-            );\n-            cust = new CustomProperties(props);\n+            custPart = pkg.getPart(custRel.getRelationship(0));\n+            if (custPart == null) {\n+                cust = new CustomProperties((org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument)NEW_CUST_INSTANCE.copy());\n+            } else {\n+                org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props = org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument.Factory.parse(\n+                        custPart.getInputStream(), DEFAULT_XML_OPTIONS);\n+                cust = new CustomProperties(props);\n+            }\n         } else {\n             custPart = null;\n             cust = new CustomProperties((org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument)NEW_CUST_INSTANCE.copy());\n@@ -197,9 +203,9 @@ public void setThumbnail(String filename, InputStream imageData) throws IOExcept\n      * @throws IOException if the properties can't be saved\n      * @throws POIXMLException if the properties are erroneous\n      */\n-    public void commit() throws IOException{\n+    public void commit() throws IOException {\n \n-        if(extPart == null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n+        if(extPart == null && ext != null && ext.props != null && !NEW_EXT_INSTANCE.toString().equals(ext.props.toString())){\n             try {\n                 PackagePartName prtname = PackagingURIHelper.createPartName(\"/docProps/app.xml\");\n                 pkg.addRelationship(prtname, TargetMode.INTERNAL, \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\");\n@@ -208,7 +214,7 @@ public void commit() throws IOException{\n                 throw new POIXMLException(e);\n             }\n         }\n-        if(custPart == null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n+        if(custPart == null && cust != null && cust.props != null && !NEW_CUST_INSTANCE.toString().equals(cust.props.toString())){\n             try {\n                 PackagePartName prtname = PackagingURIHelper.createPartName(\"/docProps/custom.xml\");\n                 pkg.addRelationship(prtname, TargetMode.INTERNAL, \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties\");\n@@ -218,17 +224,17 @@ public void commit() throws IOException{\n             }\n         }\n         if(extPart != null){\n-            OutputStream out = extPart.getOutputStream();\n-            if (extPart.getSize() > 0) {\n-                extPart.clear();\n+            try (OutputStream out = extPart.getOutputStream()) {\n+                if (extPart.getSize() > 0) {\n+                    extPart.clear();\n+                }\n+                ext.props.save(out, DEFAULT_XML_OPTIONS);\n             }\n-            ext.props.save(out, DEFAULT_XML_OPTIONS);\n-            out.close();\n         }\n         if(custPart != null){\n-            OutputStream out = custPart.getOutputStream();\n-            cust.props.save(out, DEFAULT_XML_OPTIONS);\n-            out.close();\n+            try (OutputStream out = custPart.getOutputStream()) {\n+                cust.props.save(out, DEFAULT_XML_OPTIONS);\n+            }\n         }\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/827d6284097ee2950c0301f642e713615570eb7b/src/ooxml/java/org/apache/poi/ooxml/POIXMLProperties.java",
                "sha": "31dac6a468bd13bc22fb54726074e5008cc252ff",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/827d6284097ee2950c0301f642e713615570eb7b/src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java?ref=827d6284097ee2950c0301f642e713615570eb7b",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java",
                "patch": "@@ -724,6 +724,18 @@ public void test61515() throws IOException {\n         ppt.close();\n     }\n \n+    @Ignore\n+    @Test\n+    public void testDivinoRevelado() throws IOException {\n+        XMLSlideShow ppt = XSLFTestDataSamples.openSampleDocument(\"Divino_Revelado.pptx\");\n+        try {\n+            XMLSlideShow saved = XSLFTestDataSamples.writeOutAndReadBack(ppt);\n+        } catch (IOException e) {\n+            fail(\"Could not read back saved presentation.\");\n+        }\n+        ppt.close();\n+    }\n+\n     @Test\n     public void bug62051() throws IOException {\n         final Function<List<XSLFShape>, int[]> ids = (shapes) ->",
                "raw_url": "https://github.com/apache/poi/raw/827d6284097ee2950c0301f642e713615570eb7b/src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java",
                "sha": "a57b3025d421a117d9f5f0922291e6390f96772f",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/827d6284097ee2950c0301f642e713615570eb7b/test-data/slideshow/Divino_Revelado.pptx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/slideshow/Divino_Revelado.pptx?ref=827d6284097ee2950c0301f642e713615570eb7b",
                "deletions": 0,
                "filename": "test-data/slideshow/Divino_Revelado.pptx",
                "raw_url": "https://github.com/apache/poi/raw/827d6284097ee2950c0301f642e713615570eb7b/test-data/slideshow/Divino_Revelado.pptx",
                "sha": "fa22e69c8a5551ae98fea37b151d3866b41ee015",
                "status": "added"
            }
        ],
        "message": "Handle NPE issues in POIXMLProperties\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1837007 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/02f7b450d4ed94e011caddda6b15fae71d5e08c6",
        "patched_files": [
            "Divino_Revelado.java",
            "POIXMLProperties.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestPOIXMLProperties.java",
            "TestXSLFBugs.java"
        ]
    },
    "poi_85d6f81": {
        "bug_id": "poi_85d6f81",
        "commit": "https://github.com/apache/poi/commit/85d6f81076332ddfd73e124644ceec110d855d53",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 1,
                "filename": "src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java",
                "patch": "@@ -22,10 +22,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n \n-import org.apache.poi.openxml4j.exceptions.InvalidFormatException;\n import org.apache.poi.ss.extractor.EmbeddedData;\n import org.apache.poi.ss.extractor.EmbeddedExtractor;\n import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.Name;\n import org.apache.poi.ss.usermodel.Row;\n import org.apache.poi.ss.usermodel.Sheet;\n import org.apache.poi.ss.usermodel.Workbook;\n@@ -91,6 +91,13 @@ private void readContent(Workbook wb) {\n \t\t\t    }\n \t\t\t}\n \t\t}\n+\n+\t\tfor (Name name : wb.getAllNames()) {\n+\t\t\t// this sometimes caused exceptions\n+            if(!name.isFunctionName()) {\n+                name.getRefersToFormula();\n+            }\n+\t\t}\n \t}\n \n \tprivate void extractEmbedded(Workbook wb) throws IOException {",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/src/integrationtest/org/apache/poi/stress/SpreadsheetHandler.java",
                "sha": "38f633b4cd78d7813a178399faf357cde9cea56e",
                "status": "modified"
            },
            {
                "additions": 104,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/src/java/org/apache/poi/ss/formula/SheetNameFormatter.java",
                "changes": 177,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/SheetNameFormatter.java?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 73,
                "filename": "src/java/org/apache/poi/ss/formula/SheetNameFormatter.java",
                "patch": "@@ -17,11 +17,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.ss.formula;\n \n+import java.io.IOException;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.apache.poi.ss.util.CellReference;\n import org.apache.poi.ss.SpreadsheetVersion;\n+import org.apache.poi.util.Removal;\n \n /**\n  * Formats sheet names for use in formula expressions.\n@@ -47,106 +49,134 @@ private SheetNameFormatter() {\n \t * sheet name will be converted to double single quotes ('').  \n \t */\n \tpublic static String format(String rawSheetName) {\n-        StringBuilder sb = new StringBuilder(rawSheetName.length() + 2);\n+        StringBuilder sb = new StringBuilder((rawSheetName == null ? 0 : rawSheetName.length()) + 2);\n \t\tappendFormat(sb, rawSheetName);\n \t\treturn sb.toString();\n \t}\n-\t\n-\t/**\n-\t * Convenience method for ({@link #format(String)}) when a StringBuffer is already available.\n-\t *\n-     * @param out - sheet name will be appended here possibly with delimiting quotes\n-     * @param rawSheetName - sheet name\n-     * @deprecated use <code>appendFormat(StringBuilder out, String rawSheetName)</code> instead\n-\t */\n-\t@Deprecated\n-\tpublic static void appendFormat(StringBuffer out, String rawSheetName) {\n-\t\tboolean needsQuotes = needsDelimiting(rawSheetName);\n-\t\tif(needsQuotes) {\n-\t\t\tout.append(DELIMITER);\n-\t\t\tappendAndEscape(out, rawSheetName);\n-\t\t\tout.append(DELIMITER);\n-\t\t} else {\n-\t\t\tout.append(rawSheetName);\n-\t\t}\n-\t}\n \n     /**\n-     * @deprecated use <code>appendFormat(StringBuilder out, String workbookName, String rawSheetName)</code> instead\n+     * @deprecated Only kept for binary compatibility, will be replaced by the version with Appendable as parameter\n      */\n     @Deprecated\n-\tpublic static void appendFormat(StringBuffer out, String workbookName, String rawSheetName) {\n-\t\tboolean needsQuotes = needsDelimiting(workbookName) || needsDelimiting(rawSheetName);\n-\t\tif(needsQuotes) {\n-\t\t\tout.append(DELIMITER);\n-\t\t\tout.append('[');\n-\t\t\tappendAndEscape(out, workbookName.replace('[', '(').replace(']', ')'));\n-\t\t\tout.append(']');\n-\t\t\tappendAndEscape(out, rawSheetName);\n-\t\t\tout.append(DELIMITER);\n-\t\t} else {\n-\t\t\tout.append('[');\n-\t\t\tout.append(workbookName);\n-\t\t\tout.append(']');\n-\t\t\tout.append(rawSheetName);\n+    @Removal(version=\"5.0.0\")\n+    public static void appendFormat(StringBuffer out, String rawSheetName) {\n+        appendFormat((Appendable)out, rawSheetName);\n+    }\n+\n+    /**\n+     * @deprecated Only kept for binary compatibility, will be replaced by the version with Appendable as parameter\n+     */\n+    @Deprecated\n+    @Removal(version=\"5.0.0\")\n+    public static void appendFormat(StringBuffer out, String workbookName, String rawSheetName) {\n+        appendFormat((Appendable)out, workbookName, rawSheetName);\n+    }\n+\n+    /**\n+     * Only kept for binary compatibility, will be replaced by the version with Appendable as parameter\n+     */\n+    @Removal(version=\"5.0.0\")\n+    public static void appendFormat(StringBuilder out, String rawSheetName) {\n+        appendFormat((Appendable)out, rawSheetName);\n+    }\n+\n+    /**\n+     * Only kept for binary compatibility, will be replaced by the version with Appendable as parameter\n+     */\n+    @Removal(version=\"5.0.0\")\n+    public static void appendFormat(StringBuilder out, String workbookName, String rawSheetName) {\n+        appendFormat((Appendable)out, workbookName, rawSheetName);\n+    }\n+\n+    /**\n+     * Convenience method for ({@link #format(String)}) when a StringBuffer is already available.\n+     *\n+     * @param out - sheet name will be appended here possibly with delimiting quotes\n+     * @param rawSheetName - sheet name\n+     */\n+\tpublic static void appendFormat(Appendable out, String rawSheetName) {\n+\t\ttry {\n+\t\t\tboolean needsQuotes = needsDelimiting(rawSheetName);\n+\t\t\tif(needsQuotes) {\n+\t\t\t\tout.append(DELIMITER);\n+\t\t\t\tappendAndEscape(out, rawSheetName);\n+\t\t\t\tout.append(DELIMITER);\n+\t\t\t} else {\n+\t\t\t\tappendAndEscape(out, rawSheetName);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n \t\t}\n \t}\n \n \t/**\n-\t * Convenience method for ({@link #format(String)}) when a StringBuilder is already available.\n+\t * Convenience method for ({@link #format(String)}) when a StringBuffer is already available.\n \t *\n \t * @param out - sheet name will be appended here possibly with delimiting quotes\n-     * @param rawSheetName - sheet name\n+\t * @param workbookName - workbook name\n+\t * @param rawSheetName - sheet name\n \t */\n-\tpublic static void appendFormat(StringBuilder out, String rawSheetName) {\n-\t\tboolean needsQuotes = needsDelimiting(rawSheetName);\n-\t\tif(needsQuotes) {\n-\t\t\tout.append(DELIMITER);\n-\t\t\tappendAndEscape(out, rawSheetName);\n-\t\t\tout.append(DELIMITER);\n-\t\t} else {\n-\t\t\tout.append(rawSheetName);\n+\tpublic static void appendFormat(Appendable out, String workbookName, String rawSheetName) {\n+\t\ttry {\n+\t\t\tboolean needsQuotes = needsDelimiting(workbookName) || needsDelimiting(rawSheetName);\n+\t\t\tif(needsQuotes) {\n+\t\t\t\tout.append(DELIMITER);\n+\t\t\t\tout.append('[');\n+\t\t\t\tappendAndEscape(out, workbookName.replace('[', '(').replace(']', ')'));\n+\t\t\t\tout.append(']');\n+\t\t\t\tappendAndEscape(out, rawSheetName);\n+\t\t\t\tout.append(DELIMITER);\n+\t\t\t} else {\n+\t\t\t\tout.append('[');\n+\t\t\t\tappendOrREF(out, workbookName);\n+\t\t\t\tout.append(']');\n+\t\t\t\tappendOrREF(out, rawSheetName);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n \t\t}\n \t}\n-\tpublic static void appendFormat(StringBuilder out, String workbookName, String rawSheetName) {\n-\t\tboolean needsQuotes = needsDelimiting(workbookName) || needsDelimiting(rawSheetName);\n-\t\tif(needsQuotes) {\n-\t\t\tout.append(DELIMITER);\n-\t\t\tout.append('[');\n-\t\t\tappendAndEscape(out, workbookName.replace('[', '(').replace(']', ')'));\n-\t\t\tout.append(']');\n-\t\t\tappendAndEscape(out, rawSheetName);\n-\t\t\tout.append(DELIMITER);\n+\n+\tprivate static void appendOrREF(Appendable out, String name) throws IOException {\n+\t\tif(name == null) {\n+\t\t\tout.append(\"#REF\");\n \t\t} else {\n-\t\t\tout.append('[');\n-\t\t\tout.append(workbookName);\n-\t\t\tout.append(']');\n-\t\t\tout.append(rawSheetName);\n+\t\t\tout.append(name);\n \t\t}\n \t}\n \n-    static void appendAndEscape(Appendable sb, String rawSheetName) {\n-        int len = rawSheetName.length();\n-        for(int i=0; i<len; i++) {\n-            char ch = rawSheetName.charAt(i);\n-            try {\n-                if(ch == DELIMITER) {\n-                    // single quotes (') are encoded as ('')\n-                    sb.append(DELIMITER);\n-                }\n-                sb.append(ch);\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n+\tstatic void appendAndEscape(Appendable sb, String rawSheetName) {\n+\t\ttry {\n+\t\t\tif (rawSheetName == null) {\n+\t\t\t\tsb.append(\"#REF\");\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tint len = rawSheetName.length();\n+\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\tchar ch = rawSheetName.charAt(i);\n+\t\t\t\tif (ch == DELIMITER) {\n+\t\t\t\t\t// single quotes (') are encoded as ('')\n+\t\t\t\t\tsb.append(DELIMITER);\n+\t\t\t\t}\n+\t\t\t\tsb.append(ch);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n     }\n \n \t/**\n \t * Tell if the given raw sheet name needs screening/delimiting.\n \t * @param rawSheetName the sheet name.\n-\t * @return true if the given raw sheet name needs screening/delimiting, false otherwise.\n+\t * @return true if the given raw sheet name needs screening/delimiting, false otherwise or\n+\t * \t\t\tif the sheet name is null.\n \t */\n \tstatic boolean needsDelimiting(String rawSheetName) {\n+\t\tif(rawSheetName == null) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tint len = rawSheetName.length();\n \t\tif(len < 1) {\n \t\t\tthrow new RuntimeException(\"Zero length string is an invalid sheet name\");\n@@ -185,6 +215,7 @@ private static boolean nameLooksLikeBooleanLiteral(String rawSheetName) {\n \t\t}\n \t\treturn false;\n \t}\n+\n \t/**\n \t * @return <code>true</code> if the presence of the specified character in a sheet name would \n \t * require the sheet name to be delimited in formulas.  This includes every non-alphanumeric ",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/src/java/org/apache/poi/ss/formula/SheetNameFormatter.java",
                "sha": "37daee5165fea3a1e4500e265ac5ebb1c405a307",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/src/java/org/apache/poi/ss/formula/SheetRangeAndWorkbookIndexFormatter.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/SheetRangeAndWorkbookIndexFormatter.java?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/ss/formula/SheetRangeAndWorkbookIndexFormatter.java",
                "patch": "@@ -66,8 +66,8 @@ private static String formatWithoutDelimiting(StringBuilder sb, int workbookInde\n     }\n \n     private static boolean anySheetNameNeedsEscaping(String firstSheetName, String lastSheetName) {\n-        boolean anySheetNameNeedsDelimiting = firstSheetName != null && SheetNameFormatter.needsDelimiting(firstSheetName);\n-        anySheetNameNeedsDelimiting |= lastSheetName != null && SheetNameFormatter.needsDelimiting(lastSheetName);\n+        boolean anySheetNameNeedsDelimiting = SheetNameFormatter.needsDelimiting(firstSheetName);\n+        anySheetNameNeedsDelimiting |= SheetNameFormatter.needsDelimiting(lastSheetName);\n         return anySheetNameNeedsDelimiting;\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/src/java/org/apache/poi/ss/formula/SheetRangeAndWorkbookIndexFormatter.java",
                "sha": "3ee1d77df5ab3c77c1ec86fad64c6eeb594891c7",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/src/java/org/apache/poi/ss/formula/ptg/ExternSheetNameResolver.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/ptg/ExternSheetNameResolver.java?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/ss/formula/ptg/ExternSheetNameResolver.java",
                "patch": "@@ -37,7 +37,7 @@ public static String prependSheetName(FormulaRenderingWorkbook book, int field_1\n             String wbName = externalSheet.getWorkbookName();\n             String sheetName = externalSheet.getSheetName();\n             if (wbName != null) {\n-                sb = new StringBuilder(wbName.length() + sheetName.length() + cellRefText.length() + 4);\n+                sb = new StringBuilder(wbName.length() + (sheetName == null ? 0 : sheetName.length()) + cellRefText.length() + 4);\n                 SheetNameFormatter.appendFormat(sb, wbName, sheetName);\n             } else {\n                 sb = new StringBuilder(sheetName.length() + cellRefText.length() + 4);",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/src/java/org/apache/poi/ss/formula/ptg/ExternSheetNameResolver.java",
                "sha": "2717662d2b4530ab1a76c605e38f3b3238d15740",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -3135,4 +3135,21 @@ public void test51262() throws IOException {\n             assertEquals(\"\\uFF2D\\uFF33 \\uFF30\\u30B4\\u30B7\\u30C3\\u30AF\", font.getFontName());\n         }\n     }\n+\n+    @Test\n+    public void test60460() throws IOException {\n+        final Workbook wb = HSSFTestDataSamples.openSampleWorkbook(\"60460.xls\");\n+\n+        assertEquals(2, wb.getAllNames().size());\n+\n+        Name rangedName = wb.getAllNames().get(0);\n+        assertFalse(rangedName.isFunctionName());\n+        assertEquals(\"'[\\\\\\\\HEPPC3/gt$/Teaching/Syn/physyn.xls]#REF'!$AK$70:$AL$70\", rangedName.getRefersToFormula());\n+\n+        rangedName = wb.getAllNames().get(1);\n+        assertFalse(rangedName.isFunctionName());\n+        assertEquals(\"Questionnaire!$A$1:$L$65\", rangedName.getRefersToFormula());\n+\n+        wb.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "333704fd826496ff3f340f735e18226e911af220",
                "status": "modified"
            },
            {
                "additions": 107,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/src/testcases/org/apache/poi/ss/formula/TestSheetNameFormatter.java",
                "changes": 117,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/formula/TestSheetNameFormatter.java?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 10,
                "filename": "src/testcases/org/apache/poi/ss/formula/TestSheetNameFormatter.java",
                "patch": "@@ -17,22 +17,23 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.ss.formula;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n /**\n  * Tests for {@link SheetNameFormatter}\n  * \n  * @author Josh Micich\n  */\n-public final class TestSheetNameFormatter extends TestCase {\n-\n-\tprivate static void confirmFormat(String rawSheetName, String expectedSheetNameEncoding) {\n-\t\tassertEquals(expectedSheetNameEncoding, SheetNameFormatter.format(rawSheetName));\n-\t}\n-\n+public final class TestSheetNameFormatter {\n \t/**\n \t * Tests main public method 'format' \n \t */\n+\t@Test\n \tpublic void testFormat() {\n \t\t\n \t\tconfirmFormat(\"abc\", \"abc\");\n@@ -43,14 +44,108 @@ public void testFormat() {\n \n \t\tconfirmFormat(\"O'Brian\", \"'O''Brian'\"); // single quote gets doubled\n \t\t\n-\t\t\n \t\tconfirmFormat(\"3rdTimeLucky\", \"'3rdTimeLucky'\"); // digit in first pos\n \t\tconfirmFormat(\"_\", \"_\"); // plain underscore OK\n \t\tconfirmFormat(\"my_3rd_sheet\", \"my_3rd_sheet\"); // underscores and digits OK\n \t\tconfirmFormat(\"A12220\", \"'A12220'\"); \n-\t\tconfirmFormat(\"TAXRETURN19980415\", \"TAXRETURN19980415\"); \n+\t\tconfirmFormat(\"TAXRETURN19980415\", \"TAXRETURN19980415\");\n+\n+\t\tconfirmFormat(null, \"#REF\");\n \t}\n-\t\n+\n+\tprivate static void confirmFormat(String rawSheetName, String expectedSheetNameEncoding) {\n+\t\t// test all variants\n+\n+\t\tassertEquals(expectedSheetNameEncoding, SheetNameFormatter.format(rawSheetName));\n+\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tSheetNameFormatter.appendFormat(sb, rawSheetName);\n+\t\tassertEquals(expectedSheetNameEncoding, sb.toString());\n+\n+\t\tsb = new StringBuilder();\n+\t\tSheetNameFormatter.appendFormat((Appendable)sb, rawSheetName);\n+\t\tassertEquals(expectedSheetNameEncoding, sb.toString());\n+\n+\t\tStringBuffer sbf = new StringBuffer();\n+\t\t//noinspection deprecation\n+\t\tSheetNameFormatter.appendFormat(sbf, rawSheetName);\n+\t\tassertEquals(expectedSheetNameEncoding, sbf.toString());\n+\t}\n+\n+\t@Test\n+\tpublic void testFormatWithWorkbookName() {\n+\n+\t\tconfirmFormat(\"abc\", \"abc\", \"[abc]abc\");\n+\t\tconfirmFormat(\"abc\", \"123\", \"'[abc]123'\");\n+\n+\t\tconfirmFormat(\"abc\", \"my sheet\", \"'[abc]my sheet'\"); // space\n+\t\tconfirmFormat(\"abc\", \"A:MEM\", \"'[abc]A:MEM'\"); // colon\n+\n+\t\tconfirmFormat(\"abc\", \"O'Brian\", \"'[abc]O''Brian'\"); // single quote gets doubled\n+\n+\t\tconfirmFormat(\"abc\", \"3rdTimeLucky\", \"'[abc]3rdTimeLucky'\"); // digit in first pos\n+\t\tconfirmFormat(\"abc\", \"_\", \"[abc]_\"); // plain underscore OK\n+\t\tconfirmFormat(\"abc\", \"my_3rd_sheet\", \"[abc]my_3rd_sheet\"); // underscores and digits OK\n+\t\tconfirmFormat(\"abc\", \"A12220\", \"'[abc]A12220'\");\n+\t\tconfirmFormat(\"abc\", \"TAXRETURN19980415\", \"[abc]TAXRETURN19980415\");\n+\n+\t\tconfirmFormat(\"abc\", null, \"[abc]#REF\");\n+\t\tconfirmFormat(null, \"abc\", \"[#REF]abc\");\n+\t\tconfirmFormat(null, null, \"[#REF]#REF\");\n+\t}\n+\n+\tprivate static void confirmFormat(String workbookName, String rawSheetName, String expectedSheetNameEncoding) {\n+\t\t// test all variants\n+\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tSheetNameFormatter.appendFormat(sb, workbookName, rawSheetName);\n+\t\tassertEquals(expectedSheetNameEncoding, sb.toString());\n+\n+\t\tsb = new StringBuilder();\n+\t\tSheetNameFormatter.appendFormat((Appendable)sb, workbookName, rawSheetName);\n+\t\tassertEquals(expectedSheetNameEncoding, sb.toString());\n+\n+\t\tStringBuffer sbf = new StringBuffer();\n+\t\t//noinspection deprecation\n+\t\tSheetNameFormatter.appendFormat(sbf, workbookName, rawSheetName);\n+\t\tassertEquals(expectedSheetNameEncoding, sbf.toString());\n+\t}\n+\n+\t@Test\n+\tpublic void testFormatException() {\n+\t\tAppendable mock = new Appendable() {\n+\t\t\t@Override\n+\t\t\tpublic Appendable append(CharSequence csq) throws IOException {\n+\t\t\t\tthrow new IOException(\"Test exception\");\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Appendable append(CharSequence csq, int start, int end) throws IOException {\n+\t\t\t\tthrow new IOException(\"Test exception\");\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Appendable append(char c) throws IOException {\n+\t\t\t\tthrow new IOException(\"Test exception\");\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\tSheetNameFormatter.appendFormat(mock, null, null);\n+\t\t\tfail(\"Should catch exception here\");\n+\t\t} catch (RuntimeException e) {\n+\t\t\t// expected here\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tSheetNameFormatter.appendFormat(mock, null);\n+\t\t\tfail(\"Should catch exception here\");\n+\t\t} catch (RuntimeException e) {\n+\t\t\t// expected here\n+\t\t}\n+\t}\n+\n+\t@Test\n \tpublic void testBooleanLiterals() {\n \t\tconfirmFormat(\"TRUE\", \"'TRUE'\");\n \t\tconfirmFormat(\"FALSE\", \"'FALSE'\");\n@@ -69,6 +164,7 @@ private static void confirmCellNameMatch(String rawSheetName, boolean expected)\n \t * Tests functionality to determine whether a sheet name containing only letters and digits\n \t * would look (to Excel) like a cell name.\n \t */\n+\t@Test\n \tpublic void testLooksLikePlainCellReference() {\n \t\t\n \t\tconfirmCellNameMatch(\"A1\", true);\n@@ -91,6 +187,7 @@ private static void confirmCellRange(String text, int numberOfPrefixLetters, boo\n \t * Tests exact boundaries for names that look very close to cell names (i.e. contain 1 or more\n \t * letters followed by one or more digits).\n \t */\n+\t@Test\n \tpublic void testCellRange() {\n \t\tconfirmCellRange(\"A1\", 1, true);\n \t\tconfirmCellRange(\"a111\", 1, true);",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/src/testcases/org/apache/poi/ss/formula/TestSheetNameFormatter.java",
                "sha": "76a4fc7ac2cb1ea7af1603aa05cd6176fb49ab08",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/85d6f81076332ddfd73e124644ceec110d855d53/test-data/spreadsheet/60460.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/60460.xls?ref=85d6f81076332ddfd73e124644ceec110d855d53",
                "deletions": 0,
                "filename": "test-data/spreadsheet/60460.xls",
                "raw_url": "https://github.com/apache/poi/raw/85d6f81076332ddfd73e124644ceec110d855d53/test-data/spreadsheet/60460.xls",
                "sha": "73fad8aa84838b3d915fbba0311191fb0e0e485e",
                "status": "added"
            }
        ],
        "message": "Bug 60460: Handle null workbook or sheet names and emit #REF as Excel does\ninstead of throwing NullPointerException\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1850008 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/faf53dcdb4e64b9b59e51eef5f399eb4ed3c8dd9",
        "patched_files": [
            "SheetRangeAndWorkbookIndexFormatter.java",
            "SpreadsheetHandler.java",
            "SheetNameFormatter.java",
            "ExternSheetNameResolver.java",
            "60460.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java",
            "TestSheetNameFormatter.java",
            "SheetRangeAndWorkbookIndexFormatterTest.java"
        ]
    },
    "poi_877982e": {
        "bug_id": "poi_877982e",
        "commit": "https://github.com/apache/poi/commit/877982ea92d741dbc37992b5a5cc80c5c8380796",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/877982ea92d741dbc37992b5a5cc80c5c8380796/src/documentation/content/xdocs/status.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=877982ea92d741dbc37992b5a5cc80c5c8380796",
                "deletions": 1,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,7 +34,7 @@\n \n     <changes>\n         <release version=\"3.8-beta1\" date=\"2010-??-??\">\n-          \n+           <action dev=\"poi-developers\" type=\"fix\">50119 - avoid NPE when XSSFReader comes across chart sheets</action>\n         </release>\n         <release version=\"3.7\" date=\"2010-10-25\">\n            <action dev=\"poi-developers\" type=\"fix\">50075 - avoid NPE in ListLevel.getNumberText() when numberText is null </action>",
                "raw_url": "https://github.com/apache/poi/raw/877982ea92d741dbc37992b5a5cc80c5c8380796/src/documentation/content/xdocs/status.xml",
                "sha": "c27545d3cfea6a8b5af5783c7f0c2d7035eb7cc0",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/877982ea92d741dbc37992b5a5cc80c5c8380796/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java?ref=877982ea92d741dbc37992b5a5cc80c5c8380796",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "patch": "@@ -177,7 +177,8 @@ private SheetIterator(PackagePart wb) throws IOException {\n                 //step 1. Map sheet's relationship Id and the corresponding PackagePart\n                 sheetMap = new HashMap<String, PackagePart>();\n                 for(PackageRelationship rel : wb.getRelationships()){\n-                    if(rel.getRelationshipType().equals(XSSFRelation.WORKSHEET.getRelation())){\n+                    if(rel.getRelationshipType().equals(XSSFRelation.WORKSHEET.getRelation()) ||\n+                       rel.getRelationshipType().equals(XSSFRelation.CHARTSHEET.getRelation())){\n                         PackagePartName relName = PackagingURIHelper.createPartName(rel.getTargetURI());\n                         sheetMap.put(rel.getId(), wb.getPackage().getPart(relName));\n                     }",
                "raw_url": "https://github.com/apache/poi/raw/877982ea92d741dbc37992b5a5cc80c5c8380796/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFReader.java",
                "sha": "0994ad8500c2e82636a36b63727c25cfa51c231a",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/poi/blob/877982ea92d741dbc37992b5a5cc80c5c8380796/src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java?ref=877982ea92d741dbc37992b5a5cc80c5c8380796",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java",
                "patch": "@@ -116,4 +116,22 @@ public void testOrderOfSheets() throws Exception {\n \t\t}\n \t\tassertEquals(4, count);\n \t}\n+\t\n+   \n+   /**\n+    * Iterating over a workbook with chart sheets in it, using the\n+    *  XSSFReader method\n+    * @throws Exception\n+    */\n+   public void test50119() throws Exception {\n+      OPCPackage pkg =  XSSFTestDataSamples.openSamplePackage(\"WithChartSheet.xlsx\");\n+      XSSFReader r = new XSSFReader(pkg);\n+      XSSFReader.SheetIterator it = (XSSFReader.SheetIterator)r.getSheetsData();\n+      \n+      while(it.hasNext())\n+      {\n+          InputStream stream = it.next();\n+          stream.close();\n+      }\n+   }\n }",
                "raw_url": "https://github.com/apache/poi/raw/877982ea92d741dbc37992b5a5cc80c5c8380796/src/ooxml/testcases/org/apache/poi/xssf/eventusermodel/TestXSSFReader.java",
                "sha": "11f03dd62d8b6aa5c92f851802f82109a78de966",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/877982ea92d741dbc37992b5a5cc80c5c8380796/test-data/spreadsheet/WithChartSheet.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/WithChartSheet.xlsx?ref=877982ea92d741dbc37992b5a5cc80c5c8380796",
                "deletions": 0,
                "filename": "test-data/spreadsheet/WithChartSheet.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/877982ea92d741dbc37992b5a5cc80c5c8380796/test-data/spreadsheet/WithChartSheet.xlsx",
                "sha": "8defbd6cc4b80d9c5ff3807cf47c061bb54b9362",
                "status": "added"
            }
        ],
        "message": "Fix bug #50119 - avoid NPE when XSSFReader comes across chart sheets\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1025630 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1a9cfa44d4cec78fd59f4803461ddd55c2eec694",
        "patched_files": [
            "status.java",
            "WithChartSheet.java",
            "XSSFReader.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFReader.java"
        ]
    },
    "poi_8811c99": {
        "bug_id": "poi_8811c99",
        "commit": "https://github.com/apache/poi/commit/8811c99ac3a9d6b843c99fc6cee00533067f1402",
        "file": [
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/8811c99ac3a9d6b843c99fc6cee00533067f1402/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java?ref=8811c99ac3a9d6b843c99fc6cee00533067f1402",
                "deletions": 9,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "patch": "@@ -163,7 +163,7 @@ public void addParagraph(XWPFParagraph p) {\n     /**\r\n      * removes a paragraph of this tablecell\r\n      *\r\n-     * @param pos\r\n+     * @param pos The position in the list of paragraphs, 0-based\r\n      */\r\n     public void removeParagraph(int pos) {\r\n         paragraphs.remove(pos);\r\n@@ -234,6 +234,11 @@ public XWPFVertAlign getVerticalAlignment() {\n         CTTcPr tcpr = ctTc.getTcPr();\r\n         if (tcpr != null) {\r\n             CTVerticalJc va = tcpr.getVAlign();\r\n+            if(va != null) {\r\n+                vAlign = stVertAlignTypeMap.get(va.getVal().intValue());\r\n+            } else {\r\n+                vAlign = XWPFVertAlign.TOP;\r\n+            }\r\n             if (va != null && va.getVal() != null) {\r\n                 vAlign = stVertAlignTypeMap.get(va.getVal().intValue());\r\n             }\r\n@@ -255,7 +260,7 @@ public void setVerticalAlignment(XWPFVertAlign vAlign) {\n     /**\r\n      * add a new paragraph at position of the cursor\r\n      *\r\n-     * @param cursor\r\n+     * @param cursor The XmlCursor structure created with XmlBeans\r\n      * @return the inserted paragraph\r\n      */\r\n     public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\r\n@@ -417,7 +422,7 @@ public void insertTable(int pos, XWPFTable table) {\n     }\r\n \r\n     public String getText() {\r\n-        StringBuffer text = new StringBuffer();\r\n+        StringBuilder text = new StringBuilder();\r\n         for (XWPFParagraph p : paragraphs) {\r\n             text.append(p.getText());\r\n         }\r\n@@ -437,7 +442,7 @@ public String getTextRecursively() {\n \r\n         StringBuffer text = new StringBuffer();\r\n         for (int i = 0; i < bodyElements.size(); i++) {\r\n-            boolean isLast = (i == bodyElements.size() - 1) ? true : false;\r\n+            boolean isLast = (i == bodyElements.size() - 1);\r\n             appendBodyElementText(text, bodyElements.get(i), isLast);\r\n         }\r\n \r\n@@ -447,7 +452,7 @@ public String getTextRecursively() {\n     private void appendBodyElementText(StringBuffer text, IBodyElement e, boolean isLast) {\r\n         if (e instanceof XWPFParagraph) {\r\n             text.append(((XWPFParagraph) e).getText());\r\n-            if (isLast == false) {\r\n+            if (!isLast) {\r\n                 text.append('\\t');\r\n             }\r\n         } else if (e instanceof XWPFTable) {\r\n@@ -456,18 +461,18 @@ private void appendBodyElementText(StringBuffer text, IBodyElement e, boolean is\n                 for (XWPFTableCell cell : row.getTableCells()) {\r\n                     List<IBodyElement> localBodyElements = cell.getBodyElements();\r\n                     for (int i = 0; i < localBodyElements.size(); i++) {\r\n-                        boolean localIsLast = (i == localBodyElements.size() - 1) ? true : false;\r\n+                        boolean localIsLast = (i == localBodyElements.size() - 1);\r\n                         appendBodyElementText(text, localBodyElements.get(i), localIsLast);\r\n                     }\r\n                 }\r\n             }\r\n \r\n-            if (isLast == false) {\r\n+            if (!isLast) {\r\n                 text.append('\\n');\r\n             }\r\n         } else if (e instanceof XWPFSDT) {\r\n             text.append(((XWPFSDT) e).getContent().getText());\r\n-            if (isLast == false) {\r\n+            if (!isLast) {\r\n                 text.append('\\t');\r\n             }\r\n         }\r\n@@ -507,7 +512,7 @@ public XWPFDocument getXWPFDocument() {\n     }\r\n \r\n     // Create a map from this XWPF-level enum to the STVerticalJc.Enum values\r\n-    public static enum XWPFVertAlign {\r\n+    public enum XWPFVertAlign {\r\n         TOP, CENTER, BOTH, BOTTOM\r\n     }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/8811c99ac3a9d6b843c99fc6cee00533067f1402/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFTableCell.java",
                "sha": "f070b095e7e3ea93867febc6482a48675d93385d",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/8811c99ac3a9d6b843c99fc6cee00533067f1402/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java",
                "changes": 35,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java?ref=8811c99ac3a9d6b843c99fc6cee00533067f1402",
                "deletions": 16,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java",
                "patch": "@@ -19,23 +19,12 @@\n \n package org.apache.poi.xwpf.usermodel;\n \n-import java.util.List;\n-\n import junit.framework.TestCase;\n-\n import org.apache.poi.xwpf.XWPFTestDataSamples;\n import org.apache.poi.xwpf.usermodel.XWPFTableCell.XWPFVertAlign;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHMerge;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTShd;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcBorders;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcPr;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTVMerge;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTVerticalJc;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.STMerge;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.STShd;\n-import org.openxmlformats.schemas.wordprocessingml.x2006.main.STVerticalJc;\n+import org.openxmlformats.schemas.wordprocessingml.x2006.main.*;\n+\n+import java.util.List;\n \n public class TestXWPFTableCell extends TestCase {\n     @Override\n@@ -117,9 +106,23 @@ public void testCellVerticalAlign() throws Exception{\n         List<XWPFTableRow> tableRows = table.getRows();\n         assertEquals(2, tableRows.size());\n \n-        assertNull(tableRows.get(0).getCell(0).getVerticalAlignment());\n+        assertEquals(XWPFVertAlign.TOP, tableRows.get(0).getCell(0).getVerticalAlignment());\n         assertEquals(XWPFVertAlign.BOTTOM, tableRows.get(0).getCell(1).getVerticalAlignment());\n         assertEquals(XWPFVertAlign.CENTER, tableRows.get(1).getCell(0).getVerticalAlignment());\n-        assertNull(tableRows.get(1).getCell(1).getVerticalAlignment());\n+        assertEquals(XWPFVertAlign.TOP, tableRows.get(1).getCell(1).getVerticalAlignment());\n     }\n+\t\n+\tpublic void testCellVerticalAlign2() throws Exception{\n+\t\tXWPFDocument docx = XWPFTestDataSamples.openSampleDocument(\"TestTableCellAlign.docx\");\n+\t\tList<XWPFTable> tables = docx.getTables();\n+        for (XWPFTable table : tables) {\n+            List<XWPFTableRow> tableRows = table.getRows();\n+            for (XWPFTableRow tableRow : tableRows) {\n+                List<XWPFTableCell> tableCells = tableRow.getTableCells();\n+                for (XWPFTableCell tableCell : tableCells) {\n+\t\t\t\t\tassertNotNull(tableCell.getVerticalAlignment());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\t\t\t\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/8811c99ac3a9d6b843c99fc6cee00533067f1402/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFTableCell.java",
                "sha": "00e34e241e03ff7fbcc7db51c4d8f526c86984d5",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/8811c99ac3a9d6b843c99fc6cee00533067f1402/test-data/document/TestTableCellAlign.docx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/TestTableCellAlign.docx?ref=8811c99ac3a9d6b843c99fc6cee00533067f1402",
                "deletions": 0,
                "filename": "test-data/document/TestTableCellAlign.docx",
                "raw_url": "https://github.com/apache/poi/raw/8811c99ac3a9d6b843c99fc6cee00533067f1402/test-data/document/TestTableCellAlign.docx",
                "sha": "cf40dd2213a44972cce7f1bccdfd6f9db8933386",
                "status": "added"
            }
        ],
        "message": "Avoid NPE in XWPFTableCell, taken from https://github.com/prasad-babu/poi/tree/WORKING_BRANCH\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1746625 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/bde09054f029fbd8e9206a4b6d83d659e0aebb9c",
        "patched_files": [
            "XWPFTableCell.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFTableCell.java",
            "TestTableCellAlign.java"
        ]
    },
    "poi_88c6860": {
        "bug_id": "poi_88c6860",
        "commit": "https://github.com/apache/poi/commit/88c68602c426e5667671424a902118485585dec5",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/88c68602c426e5667671424a902118485585dec5/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=88c68602c426e5667671424a902118485585dec5",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.8-beta4\" date=\"2011-??-??\">\n+           <action dev=\"poi-developers\" type=\"fix\">51671 - HWPFDocument.write based on NPOIFSFileSystem throws a NullPointerException</action>\n            <action dev=\"poi-developers\" type=\"add\">support for tables and hyperlinks in XSLF</action>\n            <action dev=\"poi-developers\" type=\"fix\">51535 - correct signed vs unsigned short reading in NDocumentInputStream</action>\n            <action dev=\"poi-developers\" type=\"add\">51634 - support SXSSF streaming from templates</action>",
                "raw_url": "https://github.com/apache/poi/raw/88c68602c426e5667671424a902118485585dec5/src/documentation/content/xdocs/status.xml",
                "sha": "99ab3a10e55109d6572fa79b451189daebd50241",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/88c68602c426e5667671424a902118485585dec5/src/java/org/apache/poi/POIDocument.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/POIDocument.java?ref=88c68602c426e5667671424a902118485585dec5",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/POIDocument.java",
                "patch": "@@ -36,6 +36,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.poifs.filesystem.Entry;\n import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n+import org.apache.poi.util.Internal;\n import org.apache.poi.util.POILogFactory;\n import org.apache.poi.util.POILogger;\n \n@@ -262,7 +263,8 @@ protected void copyNodes(DirectoryNode sourceRoot, DirectoryNode targetRoot,\n \t/**\n \t * Copies an Entry into a target POIFS directory, recursively\n \t */\n-\tprivate void copyNodeRecursively(Entry entry, DirectoryEntry target)\n+    @Internal\n+\tprotected void copyNodeRecursively(Entry entry, DirectoryEntry target)\n \tthrows IOException {\n \t\t//System.err.println(\"copyNodeRecursively called with \"+entry.getName()+\n \t\t//                   \",\"+target.getName());",
                "raw_url": "https://github.com/apache/poi/raw/88c68602c426e5667671424a902118485585dec5/src/java/org/apache/poi/POIDocument.java",
                "sha": "fad5b47bc0453260f2f3f070d03f5d16c8faaea0",
                "status": "modified"
            },
            {
                "additions": 95,
                "blob_url": "https://github.com/apache/poi/blob/88c68602c426e5667671424a902118485585dec5/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java",
                "changes": 149,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java?ref=88c68602c426e5667671424a902118485585dec5",
                "deletions": 54,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java",
                "patch": "@@ -22,6 +22,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.util.Iterator;\n \n import org.apache.poi.hpsf.DocumentSummaryInformation;\n import org.apache.poi.hpsf.SummaryInformation;\n@@ -65,6 +66,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.poifs.common.POIFSConstants;\n import org.apache.poi.poifs.filesystem.DirectoryNode;\n import org.apache.poi.poifs.filesystem.DocumentEntry;\n+import org.apache.poi.poifs.filesystem.Entry;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n import org.apache.poi.util.Internal;\n \n@@ -81,6 +83,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private static final String PROPERTY_PRESERVE_BIN_TABLES = \"org.apache.poi.hwpf.preserveBinTables\";\n     private static final String PROPERTY_PRESERVE_TEXT_TABLE = \"org.apache.poi.hwpf.preserveTextTable\";\n \n+    private static final String STREAM_DATA = \"Data\";\n+    private static final String STREAM_TABLE_0 = \"0Table\";\n+    private static final String STREAM_TABLE_1 = \"1Table\";\n+\n   /** And for making sense of CP lengths in the FIB */\n   @Deprecated\n   protected CPSplitCalculator _cpSplit;\n@@ -181,7 +187,7 @@ public HWPFDocument(InputStream istream) throws IOException\n    */\n   public HWPFDocument(POIFSFileSystem pfilesystem) throws IOException\n   {\n-\tthis(pfilesystem.getRoot());\n+    this(pfilesystem.getRoot());\n   }\n \n   /**\n@@ -213,7 +219,7 @@ public HWPFDocument(DirectoryNode directory) throws IOException\n   {\n     // Load the main stream and FIB\n     // Also handles HPSF bits\n-\tsuper(directory);\n+    super(directory);\n \n     // Do the CP Split\n     _cpSplit = new CPSplitCalculator(_fib);\n@@ -224,20 +230,20 @@ public HWPFDocument(DirectoryNode directory) throws IOException\n     }\n \n     // use the fib to determine the name of the table stream.\n-    String name = \"0Table\";\n+    String name = STREAM_TABLE_0;\n     if (_fib.isFWhichTblStm())\n     {\n-      name = \"1Table\";\n+      name = STREAM_TABLE_1;\n     }\n \n     // Grab the table stream.\n     DocumentEntry tableProps;\n-\ttry {\n-\t\ttableProps =\n-\t\t\t(DocumentEntry)directory.getEntry(name);\n-\t} catch(FileNotFoundException fnfe) {\n-\t\tthrow new IllegalStateException(\"Table Stream '\" + name + \"' wasn't found - Either the document is corrupt, or is Word95 (or earlier)\");\n-\t}\n+    try {\n+        tableProps =\n+            (DocumentEntry)directory.getEntry(name);\n+    } catch(FileNotFoundException fnfe) {\n+        throw new IllegalStateException(\"Table Stream '\" + name + \"' wasn't found - Either the document is corrupt, or is Word95 (or earlier)\");\n+    }\n \n     // read in the table stream.\n     _tableStream = new byte[tableProps.getSize()];\n@@ -249,9 +255,9 @@ public HWPFDocument(DirectoryNode directory) throws IOException\n     try\n     {\n       DocumentEntry dataProps =\n-          (DocumentEntry)directory.getEntry(\"Data\");\n+          (DocumentEntry)directory.getEntry(STREAM_DATA);\n       _dataStream = new byte[dataProps.getSize()];\n-      directory.createDocumentInputStream(\"Data\").read(_dataStream);\n+      directory.createDocumentInputStream(STREAM_DATA).read(_dataStream);\n     }\n     catch(java.io.FileNotFoundException e)\n     {\n@@ -396,7 +402,7 @@ public StringBuilder getText()\n   @Deprecated\n   public CPSplitCalculator getCPSplitCalculator()\n   {\n-\treturn _cpSplit;\n+    return _cpSplit;\n   }\n \n   public DocumentProperties getDocProperties()\n@@ -512,7 +518,7 @@ public Range getMainTextboxRange()\n    *  separators and footnote separators.\n    */\n   public Range getHeaderStoryRange() {\n-\t  return getRange( SubdocumentType.HEADER );\n+      return getRange( SubdocumentType.HEADER );\n   }\n \n   /**\n@@ -550,7 +556,7 @@ public RevisionMarkAuthorTable getRevisionMarkAuthorTable()\n    * @return PicturesTable object, that is able to extract images from this document\n    */\n   public PicturesTable getPicturesTable() {\n-\t  return _pictures;\n+      return _pictures;\n   }\n \n   @Internal\n@@ -636,8 +642,8 @@ public void write(OutputStream out)\n   {\n     // initialize our streams for writing.\n     HWPFFileSystem docSys = new HWPFFileSystem();\n-    HWPFOutputStream wordDocumentStream = docSys.getStream(\"WordDocument\");\n-    HWPFOutputStream tableStream = docSys.getStream(\"1Table\");\n+    HWPFOutputStream wordDocumentStream = docSys.getStream(STREAM_WORD_DOCUMENT);\n+    HWPFOutputStream tableStream = docSys.getStream(STREAM_TABLE_1);\n     //HWPFOutputStream dataStream = docSys.getStream(\"Data\");\n     int tableOffset = 0;\n \n@@ -910,6 +916,9 @@ public void write(OutputStream out)\n       mainBuf = tempBuf;\n     }\n \n+        // Table1 stream will be used\n+        _fib.setFWhichTblStm( true );\n+\n     // write out the FileInformationBlock.\n     //_fib.serialize(mainBuf, 0);\n     _fib.writeTo(mainBuf, tableStream);\n@@ -934,52 +943,84 @@ public void write(OutputStream out)\n       dataBuf = tempBuf;\n     }\n \n-//    // spit out the Word document.\n-//    POIFSFileSystem pfs = new POIFSFileSystem();\n-//    \n-//    pfs.createDocument(new ByteArrayInputStream(mainBuf), \"WordDocument\");\n-//    pfs.createDocument(new ByteArrayInputStream(tableBuf), \"1Table\");\n-//    pfs.createDocument(new ByteArrayInputStream(dataBuf), \"Data\");\n-//    writeProperties(pfs);\n-\n-        POIFSFileSystem pfs = directory.getFileSystem();\n-        deleteEntrySafe( pfs, \"WordDocument\" );\n-        deleteEntrySafe( pfs, \"0Table\" );\n-        deleteEntrySafe( pfs, \"1Table\" );\n-        deleteEntrySafe( pfs, \"Data\" );\n-\n-        // read properties only if they were not read\n-        getSummaryInformation();\n-        // update properties in case user changed them\n-        deleteEntrySafe( pfs, SummaryInformation.DEFAULT_STREAM_NAME );\n-        deleteEntrySafe( pfs, DocumentSummaryInformation.DEFAULT_STREAM_NAME );\n-        writeProperties( pfs );\n-\n-        pfs.createDocument( new ByteArrayInputStream( mainBuf ), \"WordDocument\" );\n-        pfs.createDocument( new ByteArrayInputStream( tableBuf ), \"1Table\" );\n-        pfs.createDocument( new ByteArrayInputStream( dataBuf ), \"Data\" );\n+        // create new document preserving order of entries\n+        POIFSFileSystem pfs = new POIFSFileSystem();\n+        boolean docWritten = false;\n+        boolean dataWritten = false;\n+        boolean tableWritten = false;\n+        boolean propertiesWritten = false;\n+        for ( Iterator<Entry> iter = directory.getEntries(); iter.hasNext(); )\n+        {\n+            Entry entry = iter.next();\n+            if ( entry.getName().equals( STREAM_WORD_DOCUMENT ) )\n+            {\n+                if ( !docWritten )\n+                {\n+                    pfs.createDocument( new ByteArrayInputStream( mainBuf ),\n+                            STREAM_WORD_DOCUMENT );\n+                    docWritten = true;\n+                }\n+            }\n+            else if ( entry.getName().equals( STREAM_TABLE_0 )\n+                    || entry.getName().equals( STREAM_TABLE_1 ) )\n+            {\n+                if ( !tableWritten )\n+                {\n+                    pfs.createDocument( new ByteArrayInputStream( tableBuf ),\n+                            STREAM_TABLE_1 );\n+                    tableWritten = true;\n+                }\n+            }\n+            else if ( entry.getName().equals(\n+                    SummaryInformation.DEFAULT_STREAM_NAME )\n+                    || entry.getName().equals(\n+                            DocumentSummaryInformation.DEFAULT_STREAM_NAME ) )\n+            {\n+                if ( !propertiesWritten )\n+                {\n+                    writeProperties( pfs );\n+                    propertiesWritten = true;\n+                }\n+            }\n+            else if ( entry.getName().equals( STREAM_DATA ) )\n+            {\n+                if ( !dataWritten )\n+                {\n+                    pfs.createDocument( new ByteArrayInputStream( dataBuf ),\n+                            STREAM_DATA );\n+                    dataWritten = true;\n+                }\n+            }\n+            else\n+            {\n+                copyNodeRecursively( entry, pfs.getRoot() );\n+            }\n+        }\n+\n+        if ( !docWritten )\n+            pfs.createDocument( new ByteArrayInputStream( mainBuf ),\n+                    STREAM_WORD_DOCUMENT );\n+        if ( !tableWritten )\n+            pfs.createDocument( new ByteArrayInputStream( tableBuf ),\n+                    STREAM_TABLE_1 );\n+        if ( !propertiesWritten )\n+            writeProperties( pfs );\n+        if ( !dataWritten )\n+            pfs.createDocument( new ByteArrayInputStream( dataBuf ),\n+                    STREAM_DATA );\n+\n         pfs.writeFilesystem( out );\n+        this.directory = pfs.getRoot();\n \n         /*\n          * since we updated all references in FIB and etc, using new arrays to\n          * access data\n          */\n+        this.directory = pfs.getRoot();\n         this._tableStream = tableStream.toByteArray();\n         this._dataStream = dataBuf;\n     }\n \n-    private static void deleteEntrySafe( POIFSFileSystem pfs, final String name )\n-    {\n-        try\n-        {\n-            pfs.getRoot().getEntry( name ).delete();\n-        }\n-        catch ( FileNotFoundException exc )\n-        {\n-            // ok\n-        }\n-    }\n-\n   @Internal\n   public byte[] getDataStream()\n   {\n@@ -988,7 +1029,7 @@ private static void deleteEntrySafe( POIFSFileSystem pfs, final String name )\n   @Internal\n   public byte[] getTableStream()\n   {\n-\treturn _tableStream;\n+    return _tableStream;\n   }\n \n   public int registerList(HWPFList list)",
                "raw_url": "https://github.com/apache/poi/raw/88c68602c426e5667671424a902118485585dec5/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java",
                "sha": "fc979f46d9a39e455fcd4898704fd4171c033909",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/88c68602c426e5667671424a902118485585dec5/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java?ref=88c68602c426e5667671424a902118485585dec5",
                "deletions": 9,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java",
                "patch": "@@ -22,12 +22,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.io.InputStream;\n import java.io.PushbackInputStream;\n \n-import org.apache.poi.hwpf.usermodel.ObjectsPool;\n-\n-import org.apache.poi.poifs.filesystem.DirectoryEntry;\n-\n-import org.apache.poi.hwpf.usermodel.ObjectPoolImpl;\n-\n import org.apache.poi.EncryptedDocumentException;\n import org.apache.poi.POIDocument;\n import org.apache.poi.hwpf.model.CHPBinTable;\n@@ -38,7 +32,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hwpf.model.SectionTable;\n import org.apache.poi.hwpf.model.StyleSheet;\n import org.apache.poi.hwpf.model.TextPieceTable;\n+import org.apache.poi.hwpf.usermodel.ObjectPoolImpl;\n+import org.apache.poi.hwpf.usermodel.ObjectsPool;\n import org.apache.poi.hwpf.usermodel.Range;\n+import org.apache.poi.poifs.filesystem.DirectoryEntry;\n import org.apache.poi.poifs.filesystem.DirectoryNode;\n import org.apache.poi.poifs.filesystem.DocumentEntry;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n@@ -53,6 +50,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public abstract class HWPFDocumentCore extends POIDocument\n {\n+    protected static final String STREAM_OBJECT_POOL = \"ObjectPool\";\n+    protected static final String STREAM_WORD_DOCUMENT = \"WordDocument\";\n+\n   /** Holds OLE2 objects */\n   protected ObjectPoolImpl _objectPool;\n \n@@ -151,7 +151,7 @@ public HWPFDocumentCore(DirectoryNode directory) throws IOException\n        directory.getEntry(\"WordDocument\");\n     _mainStream = new byte[documentProps.getSize()];\n \n-    directory.createDocumentInputStream(\"WordDocument\").read(_mainStream);\n+    directory.createDocumentInputStream(STREAM_WORD_DOCUMENT).read(_mainStream);\n \n     // Create our FIB, and check for the doc being encrypted\n     _fib = new FileInformationBlock(_mainStream);\n@@ -164,11 +164,12 @@ public HWPFDocumentCore(DirectoryNode directory) throws IOException\n             try\n             {\n                 objectPoolEntry = (DirectoryEntry) directory\n-                        .getEntry( \"ObjectPool\" );\n+                        .getEntry( STREAM_OBJECT_POOL );\n             }\n             catch ( FileNotFoundException exc )\n             {\n-                objectPoolEntry = directory.createDirectory( \"ObjectPool\" );\n+                objectPoolEntry = directory\n+                        .createDirectory( STREAM_OBJECT_POOL );\n             }\n             _objectPool = new ObjectPoolImpl( objectPoolEntry );\n         }",
                "raw_url": "https://github.com/apache/poi/raw/88c68602c426e5667671424a902118485585dec5/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocumentCore.java",
                "sha": "5301084a8ea42d028b666c80b5112d087adb0c9d",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/88c68602c426e5667671424a902118485585dec5/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java?ref=88c68602c426e5667671424a902118485585dec5",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java",
                "patch": "@@ -16,6 +16,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.hwpf.usermodel;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n@@ -24,6 +25,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.Collection;\n import java.util.List;\n \n+import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;\n+\n import junit.framework.TestCase;\n \n import org.apache.commons.codec.digest.DigestUtils;\n@@ -630,4 +633,18 @@ public void test51604p3() throws Exception\n \n         assertEquals( Arrays.toString( oldData ), Arrays.toString( newData ) );\n     }\n+\n+    /**\n+     * [RESOLVED FIXED] Bug 51671 - HWPFDocument.write based on NPOIFSFileSystem\n+     * throws a NullPointerException\n+     */\n+    public void test51671() throws Exception\n+    {\n+        InputStream is = POIDataSamples.getDocumentInstance()\n+                .openResourceAsStream( \"empty.doc\" );\n+        NPOIFSFileSystem npoifsFileSystem = new NPOIFSFileSystem( is );\n+        HWPFDocument hwpfDocument = new HWPFDocument(\n+                npoifsFileSystem.getRoot() );\n+        hwpfDocument.write( new ByteArrayOutputStream() );\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/88c68602c426e5667671424a902118485585dec5/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBugs.java",
                "sha": "85d49387f1d8a3261500c3b21d46a4efc58a9c1a",
                "status": "modified"
            }
        ],
        "message": "fix 51671 - HWPFDocument.write based on NPOIFSFileSystem throws a NullPointerException\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1158754 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/4013bcd57caddb4bedcfcea1b3faedead5b6363f",
        "patched_files": [
            "HWPFDocument.java",
            "status.java",
            "POIDocument.java",
            "HWPFDocumentCore.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBugs.java"
        ]
    },
    "poi_89d734d": {
        "bug_id": "poi_89d734d",
        "commit": "https://github.com/apache/poi/commit/89d734dcb3f9d204c75e3a88fb1013a3f9293307",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/89d734dcb3f9d204c75e3a88fb1013a3f9293307/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java?ref=89d734dcb3f9d204c75e3a88fb1013a3f9293307",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java",
                "patch": "@@ -359,9 +359,9 @@ private String convertSharedFormula(int idx){\n      */\n     public void setCellFormula(String formula) {\n         XSSFWorkbook wb = row.getSheet().getWorkbook();\n-        if (formula == null && cell.isSetF()) {\n+        if (formula == null) {\n             wb.onDeleteFormula(this);\n-            cell.unsetF();\n+            if(cell.isSetF()) cell.unsetF();\n             return;\n         }\n ",
                "raw_url": "https://github.com/apache/poi/raw/89d734dcb3f9d204c75e3a88fb1013a3f9293307/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java",
                "sha": "3143037430a79f74312a2e9d03c66e16cf4d6335",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/89d734dcb3f9d204c75e3a88fb1013a3f9293307/src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java?ref=89d734dcb3f9d204c75e3a88fb1013a3f9293307",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java",
                "patch": "@@ -265,7 +265,13 @@ public final void testSetFormulaValue() {\n \t\tassertEquals(\"I changed!\", c2.getStringCellValue());\n \t\tassertEquals(Cell.CELL_TYPE_FORMULA, c2.getCellType());\n \t\tassertEquals(Cell.CELL_TYPE_STRING, c2.getCachedFormulaResultType());\n-\t}\n+\n+        //calglin Cell.setCellFormula(null) for a non-formula cell\n+        Cell c3 = r.createCell(2);\n+        c3.setCellFormula(null);\n+        assertEquals(Cell.CELL_TYPE_BLANK, c3.getCellType());\n+\n+    }\n \tprivate Cell createACell() {\n \t\treturn _testDataProvider.createWorkbook().createSheet(\"Sheet1\").createRow(0).createCell(0);\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/89d734dcb3f9d204c75e3a88fb1013a3f9293307/src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java",
                "sha": "4e747b289890d19ae735a97c7f837c2c84f3c84e",
                "status": "modified"
            }
        ],
        "message": "avoid NPE when calling XSSF.setCellFormula(null) for a non-formula cell\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@766750 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/df946963b6595b38c40671b22a97f37f9acfce5e",
        "patched_files": [
            "XSSFCell.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFCell.java"
        ]
    },
    "poi_8c6e95f": {
        "bug_id": "poi_8c6e95f",
        "commit": "https://github.com/apache/poi/commit/8c6e95f597620e5c117fa39cbd564d98f28a382d",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/8c6e95f597620e5c117fa39cbd564d98f28a382d/src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java?ref=8c6e95f597620e5c117fa39cbd564d98f28a382d",
                "deletions": 2,
                "filename": "src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java",
                "patch": "@@ -64,6 +64,8 @@ public void handleFile(InputStream stream, String path) throws Exception {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n+\t\tHSSFOptimiser.optimiseFonts(wb);\n \t}\n \n \tprivate static final Set<String> EXPECTED_ADDITIONAL_FAILURES = new HashSet<>();\n@@ -85,6 +87,7 @@ public void handleFile(InputStream stream, String path) throws Exception {\n \tpublic void handleAdditional(File file) throws Exception {\n \t\t// redirect stdout as the examples often write lots of text\n \t\tPrintStream oldOut = System.out;\n+\t\tString fileWithParent = file.getParentFile().getName() + \"/\" + file.getName();\n \t\ttry {\n \t\t\tSystem.setOut(new PrintStream(new OutputStream() {\n \t\t\t\t@Override\n@@ -95,11 +98,11 @@ public void write(int b) {\n \t\t\tBiffViewer.main(new String[]{file.getAbsolutePath()});\n \n \t\t\tassertFalse(\"Expected Extraction to fail for file \" + file + \" and handler \" + this + \", but did not fail!\",\n-\t\t\t\t\tEXPECTED_ADDITIONAL_FAILURES.contains(file.getParentFile().getName() + \"/\" + file.getName()));\n+\t\t\t\t\tEXPECTED_ADDITIONAL_FAILURES.contains(fileWithParent));\n \t\t} catch (OldExcelFormatException e) {\n \t\t\t// old excel formats are not supported here\n \t\t} catch (RuntimeException e) {\n-\t\t\tif(!EXPECTED_ADDITIONAL_FAILURES.contains(file.getParentFile().getName() + \"/\" + file.getName())) {\n+\t\t\tif(!EXPECTED_ADDITIONAL_FAILURES.contains(fileWithParent)) {\n \t\t\t\tthrow e;\n \t\t\t}\n \t\t} finally {",
                "raw_url": "https://github.com/apache/poi/raw/8c6e95f597620e5c117fa39cbd564d98f28a382d/src/integrationtest/org/apache/poi/stress/HSSFFileHandler.java",
                "sha": "603231022e74dc97edb556f5f6fc4b216af7bbe9",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8c6e95f597620e5c117fa39cbd564d98f28a382d/src/java/org/apache/poi/hssf/record/common/UnicodeString.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/common/UnicodeString.java?ref=8c6e95f597620e5c117fa39cbd564d98f28a382d",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/common/UnicodeString.java",
                "patch": "@@ -712,7 +712,7 @@ public String getDebugInfo()\n         if (field_4_format_runs != null) {\n           for (int i = 0; i < field_4_format_runs.size();i++) {\n             FormatRun r = field_4_format_runs.get(i);\n-            buffer.append(\"      .format_run\"+i+\"          = \").append(r).append(\"\\n\");\n+            buffer.append(\"      .format_run\").append(i).append(\"          = \").append(r).append(\"\\n\");\n           }\n         }\n         if (field_5_ext_rst != null) {",
                "raw_url": "https://github.com/apache/poi/raw/8c6e95f597620e5c117fa39cbd564d98f28a382d/src/java/org/apache/poi/hssf/record/common/UnicodeString.java",
                "sha": "80689564b96d0d824a96c941570ea9d71237aa15",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/8c6e95f597620e5c117fa39cbd564d98f28a382d/src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java",
                "changes": 27,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java?ref=8c6e95f597620e5c117fa39cbd564d98f28a382d",
                "deletions": 13,
                "filename": "src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java",
                "patch": "@@ -59,9 +59,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private static void confirmSize(int expectedSize, UnicodeString s) {\n         confirmSize(expectedSize, s, 0);\n     }\n+\n     /**\n      * Note - a value of zero for <tt>amountUsedInCurrentRecord</tt> would only ever occur just\n-     * after a {@link ContinueRecord} had been started.  In the initial {@link SSTRecord} this \n+     * after a {@link ContinueRecord} had been started.  In the initial {@link SSTRecord} this\n      * value starts at 8 (for the first {@link UnicodeString} written).  In general, it can be\n      * any value between 0 and {@link #MAX_DATA_SIZE}\n      */\n@@ -181,7 +182,7 @@ public void perfectContinuedStringSize() {\n     }\n     \n     @Test\n-    public void formatRun() throws Exception {\n+    public void formatRun() {\n        FormatRun fr = new FormatRun((short)4, (short)0x15c);\n        assertEquals(4, fr.getCharacterPos());\n        assertEquals(0x15c, fr.getFontIndex());\n@@ -207,7 +208,7 @@ public void formatRun() throws Exception {\n     }\n     \n     @Test\n-    public void extRstFromEmpty() throws Exception {\n+    public void extRstFromEmpty() {\n        ExtRst ext = new ExtRst();\n        \n        assertEquals(0, ext.getNumberOfRuns());\n@@ -231,14 +232,14 @@ public void extRstFromEmpty() throws Exception {\n        assertEquals(-1, b[0]);\n        assertEquals(-1, b[1]);\n        assertEquals(14, b[2]);\n-       assertEquals(00, b[3]);\n+       assertEquals(0, b[3]);\n        \n        // Reserved\n        assertEquals(1, b[4]);\n        assertEquals(0, b[5]);\n        // Data size\n        assertEquals(10, b[6]);\n-       assertEquals(00, b[7]);\n+       assertEquals(0, b[7]);\n        // Font*2\n        assertEquals(0, b[8]);\n        assertEquals(0, b[9]);\n@@ -274,13 +275,13 @@ public void extRstFromEmpty() throws Exception {\n     }\n     \n     @Test\n-    public void extRstFromData() throws Exception {\n+    public void extRstFromData() {\n        byte[] data = new byte[] {\n-             01, 00, 0x0C, 00, \n-             00, 00, 0x37, 00, \n-             00, 00, \n-             00, 00, 00, 00, \n-             00, 00 // Cruft at the end, as found from real files\n+               1, 0, 0x0C, 0,\n+               0, 0, 0x37, 0,\n+               0, 0,\n+               0, 0, 0, 0,\n+               0, 0 // Cruft at the end, as found from real files\n        };\n        assertEquals(16, data.length);\n        \n@@ -298,7 +299,7 @@ public void extRstFromData() throws Exception {\n     }\n     \n     @Test\n-    public void corruptExtRstDetection() throws Exception {\n+    public void corruptExtRstDetection() {\n        byte[] data = new byte[] {\n              0x79, 0x79, 0x11, 0x11, \n              0x22, 0x22, 0x33, 0x33, \n@@ -385,7 +386,7 @@ private static UnicodeString makeUnicodeString(int numChars) {\n      * @return a string of the specified number of characters\n      */\n     private static UnicodeString makeUnicodeString(int numChars, boolean is16Bit) {\n-        StringBuilder b = new StringBuilder(numChars);\n+      StringBuilder b = new StringBuilder(numChars);\n         int charBase = is16Bit ? 0x8A00 : 'A';\n         for (int i = 0; i < numChars; i++) {\n             char ch = (char) ((i % 16) + charBase);",
                "raw_url": "https://github.com/apache/poi/raw/8c6e95f597620e5c117fa39cbd564d98f28a382d/src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java",
                "sha": "1a823e3aaaa2602a030cb9289cc1489716744433",
                "status": "modified"
            }
        ],
        "message": "Add some more testing for bug 63151: NullPointerException in HSSFOptimiser.optimiseFonts(), also execute it as part of large regression tests in the future\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1854190 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/34d6410bc1e3e2d51256de23e434ce2f8c507e18",
        "patched_files": [
            "UnicodeString.java",
            "HSSFFileHandler.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestUnicodeString.java"
        ]
    },
    "poi_8f9f5b0": {
        "bug_id": "poi_8f9f5b0",
        "commit": "https://github.com/apache/poi/commit/8f9f5b0065db47207d4541091bd197ec96f49890",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/documentation/content/xdocs/changes.xml",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -44,6 +44,11 @@\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Created a common interface for handling Excel files, irrespective of if they are .xls or .xlsx</action>\n         </release>\n         <release version=\"3.1-beta2\" date=\"2008-05-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">44523 - fixed workbook sheet selection and focus</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">45000 - Fixed NPE in ListLevel when numberText is null</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">44985 - Properly update TextSpecInfoAtom when the parent text is changed</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">41187 - fixed HSSFSheet to properly read xls files without ROW records</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">44950 - fixed HSSFFormulaEvaluator.evaluateInCell() and Area3DEval.getValue() also added validation for number of elements in AreaEvals</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">42570 - fixed LabelRecord to use empty string instead of null when the length is zero.</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">42564 - fixed ArrayPtg to use ConstantValueParser.  Fixed a few other ArrayPtg encoding issues.</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">Follow-on from 28754 - StringPtg.toFormulaString() should escape double quotes</action>",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/documentation/content/xdocs/changes.xml",
                "sha": "b2dea5c407bf9e26a7c4ce9e0d7bed085e657b66",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/documentation/content/xdocs/status.xml",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -41,6 +41,11 @@\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Created a common interface for handling Excel files, irrespective of if they are .xls or .xlsx</action>\n         </release>\n         <release version=\"3.1-beta2\" date=\"2008-05-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">44523 - fixed workbook sheet selection and focus</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">45000 - Fixed NPE in ListLevel when numberText is null</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">44985 - Properly update TextSpecInfoAtom when the parent text is changed</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">41187 - fixed HSSFSheet to properly read xls files without ROW records</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">44950 - fixed HSSFFormulaEvaluator.evaluateInCell() and Area3DEval.getValue() also added validation for number of elements in AreaEvals</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">42570 - fixed LabelRecord to use empty string instead of null when the length is zero.</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">42564 - fixed ArrayPtg to use ConstantValueParser.  Fixed a few other ArrayPtg encoding issues.</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">Follow-on from 28754 - StringPtg.toFormulaString() should escape double quotes</action>",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/documentation/content/xdocs/status.xml",
                "sha": "75117754bdafc4b0c3fffbcab205bd211933c9ec",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/documentation/release-guide.txt",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/release-guide.txt?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 2,
                "filename": "src/documentation/release-guide.txt",
                "patch": "@@ -37,14 +37,14 @@ where $TAG is the release tag, for example, REL_3_1_BETA1\n   3. Checkout the tagged version\r\n {code}\r\n cd tags\r\n-svn checkout https://svn.apache.org/repos/asf/poi/tags/TAG\r\n+svn checkout https://svn.apache.org/repos/asf/poi/tags/$TAG\r\n {code}\r\n \r\n   4. Merge (if required)\r\n \r\n {code}\r\n cd $TAG\r\n-$ svn merge https://svn.apache.org/repos/asf/poi/tags/TAG \\\r\n+$ svn merge https://svn.apache.org/repos/asf/poi/tags/$TAG \\\r\n https://svn.apache.org/repos/asf/poi/trunk\r\n {code}\r\n \r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/documentation/release-guide.txt",
                "sha": "e1fbc94e6f655843b2b828ecb5496fe1df4b0915",
                "status": "modified"
            },
            {
                "additions": 318,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/model/Sheet.java",
                "changes": 1167,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/Sheet.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 849,
                "filename": "src/java/org/apache/poi/hssf/model/Sheet.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -16,7 +15,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    limitations under the License.\n ==================================================================== */\n \n-\n package org.apache.poi.hssf.model;\n \n import org.apache.poi.hssf.record.*;\n@@ -57,9 +55,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @see org.apache.poi.hssf.usermodel.HSSFSheet\n  * @version 1.0-pre\n  */\n-\n-public class Sheet implements Model\n-{\n+public final class Sheet implements Model {\n     public static final short   LeftMargin = 0;\n     public static final short   RightMargin = 1;\n     public static final short   TopMargin = 2;\n@@ -97,9 +93,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     protected ObjectProtectRecord        objprotect        =     null;\n     protected ScenarioProtectRecord      scenprotect       =     null;\n     protected PasswordRecord             password          =     null;\n-    protected List                       condFormatting    =     new ArrayList();;\n+    protected List                       condFormatting    =     new ArrayList();\n \n-    /** Add an UncalcedRecord if not true indicating formulas have not been calculated */ \n+    /** Add an UncalcedRecord if not true indicating formulas have not been calculated */\n     protected boolean uncalced = false;\n \t\n     public static final byte PANE_LOWER_RIGHT = (byte)0;\n@@ -108,7 +104,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     public static final byte PANE_UPPER_LEFT = (byte)3;\n \n     /**\n-     * Creates new Sheet with no intialization --useless at this point\n+     * Creates new Sheet with no initialization --useless at this point\n      * @see #createSheet(List,int,int)\n      */\n     public Sheet()\n@@ -166,7 +162,7 @@ else if (rec.getSid() == EOFRecord.sid)\n                 }\n             }\n             else if (rec.getSid() == UncalcedRecord.sid) {\n-            \tretval.uncalced = true; \n+                retval.uncalced = true;\n             }\n             else if (rec.getSid() == DimensionsRecord.sid)\n             {\n@@ -188,14 +184,14 @@ else if (rec.getSid() == MergeCellsRecord.sid)\n             }\n             else if ( rec.getSid() == CFHeaderRecord.sid )\n             {\n-            \tCFRecordsAggregate cfAgg = CFRecordsAggregate.createCFAggregate(recs, k);\n-            \tretval.condFormatting.add(cfAgg);\n-            \trec = cfAgg;\n+                CFRecordsAggregate cfAgg = CFRecordsAggregate.createCFAggregate(recs, k);\n+                retval.condFormatting.add(cfAgg);\n+                rec = cfAgg;\n             }\n             else if ( rec.getSid() == CFRuleRecord.sid )\n             {\n-            \t// Skip it since it is processed by CFRecordsAggregate\n-            \trec = null;\n+                // Skip it since it is processed by CFRecordsAggregate\n+                rec = null;\n             }\n             else if (rec.getSid() == ColumnInfoRecord.sid)\n             {\n@@ -244,7 +240,7 @@ else if ( rec.getSid() == RowRecord.sid )\n                 if ( isfirstrow )\n                 {\n                     retval.rows = new RowRecordsAggregate();\n-                    rec = retval.rows;                    \n+                    rec = retval.rows;\n                     isfirstrow = false;\n                 }\n                 retval.rows.insertRow(row);\n@@ -256,7 +252,7 @@ else if ( rec.getSid() == PrintGridlinesRecord.sid )\n             else if ( rec.getSid() == GridsetRecord.sid )\n             {\n                 retval.gridset = (GridsetRecord) rec;\n-            }            \n+            }\n             else if ( rec.getSid() == HeaderRecord.sid && bofEofNestingLevel == 1)\n             {\n                 retval.header = (HeaderRecord) rec;\n@@ -301,32 +297,32 @@ else if ( rec.getSid() == IndexRecord.sid )\n             {\n                 rec = null;\n             }\n-            \n-\t\t\telse if ( rec.getSid() == ProtectRecord.sid )\n-\t\t\t{\n-\t\t\t\tretval.protect = (ProtectRecord) rec;\n-\t\t\t} \n-\t\t\telse if ( rec.getSid() == ObjectProtectRecord.sid )\n-\t\t\t{\n-\t\t\t\tretval.objprotect = (ObjectProtectRecord) rec;\n-\t\t\t} \n-\t\t\telse if ( rec.getSid() == ScenarioProtectRecord.sid )\n-\t\t\t{\n-\t\t\t\tretval.scenprotect = (ScenarioProtectRecord) rec;\n-\t\t\t} \n-\t\t\telse if ( rec.getSid() == PasswordRecord.sid )\n-\t\t\t{\n-\t\t\t\tretval.password = (PasswordRecord) rec;\n-\t\t\t} \n-\t\t\telse if (rec.getSid() == PageBreakRecord.HORIZONTAL_SID) \n-\t\t\t{\t\n-\t\t\t\tretval.rowBreaks = (PageBreakRecord)rec;\t\t\t\t\n-\t\t\t}\n-\t\t\telse if (rec.getSid() == PageBreakRecord.VERTICAL_SID) \n-\t\t\t{\t\n-\t\t\t\tretval.colBreaks = (PageBreakRecord)rec;\t\t\t\t\n-\t\t\t}\n-            \n+\n+            else if ( rec.getSid() == ProtectRecord.sid )\n+            {\n+                retval.protect = (ProtectRecord) rec;\n+            }\n+            else if ( rec.getSid() == ObjectProtectRecord.sid )\n+            {\n+                retval.objprotect = (ObjectProtectRecord) rec;\n+            }\n+            else if ( rec.getSid() == ScenarioProtectRecord.sid )\n+            {\n+                retval.scenprotect = (ScenarioProtectRecord) rec;\n+            }\n+            else if ( rec.getSid() == PasswordRecord.sid )\n+            {\n+                retval.password = (PasswordRecord) rec;\n+            }\n+            else if (rec.getSid() == PageBreakRecord.HORIZONTAL_SID)\n+            {\n+                retval.rowBreaks = (PageBreakRecord)rec;\n+            }\n+            else if (rec.getSid() == PageBreakRecord.VERTICAL_SID)\n+            {\n+                retval.colBreaks = (PageBreakRecord)rec;\n+            }\n+\n             if (rec != null)\n             {\n                 records.add(rec);\n@@ -351,9 +347,9 @@ else if (rec.getSid() == PageBreakRecord.VERTICAL_SID)\n     /**\n      * Clones the low level records of this sheet and returns the new sheet instance.\n      * This method is implemented by adding methods for deep cloning to all records that\n-     * can be added to a sheet. The <b>Record</b> object does not implement cloneable. \n+     * can be added to a sheet. The <b>Record</b> object does not implement cloneable.\n      * When adding a new record, implement a public clone method if and only if the record\n-     * belongs to a sheet. \n+     * belongs to a sheet.\n      */\n     public Sheet cloneSheet()\n     {\n@@ -374,7 +370,7 @@ public Sheet cloneSheet()\n           ValueRecordsAggregate vrAgg = (ValueRecordsAggregate)rec;\n           for (Iterator cellIter = vrAgg.getIterator();cellIter.hasNext();) {\n             Record valRec = (Record)cellIter.next();\n-            \n+\n             if (valRec instanceof FormulaRecordAggregate) {\n                 FormulaRecordAggregate fmAgg = (FormulaRecordAggregate)valRec;\n                 Record fmAggRec = fmAgg.getFormulaRecord();\n@@ -459,9 +455,9 @@ public static Sheet createSheet()\n         records.add(retval.rowBreaks);\n         retval.colBreaks = new PageBreakRecord(PageBreakRecord.VERTICAL_SID);\n         records.add(retval.colBreaks);\n-        \n+\n         retval.header = (HeaderRecord) retval.createHeader();\n-        records.add( retval.header );        \n+        records.add( retval.header );\n         retval.footer = (FooterRecord) retval.createFooter();\n         records.add( retval.footer );\n         records.add( retval.createHCenter() );\n@@ -479,11 +475,11 @@ public static Sheet createSheet()\n         retval.dimsloc = records.size()-1;\n         records.add(retval.windowTwo = retval.createWindowTwo());\n         retval.setLoc(records.size() - 1);\n-        retval.selection = \n+        retval.selection =\n                 (SelectionRecord) retval.createSelection();\n         records.add(retval.selection);\n-\t\tretval.protect = (ProtectRecord) retval.createProtect();\n-\t\trecords.add(retval.protect);\n+        retval.protect = (ProtectRecord) retval.createProtect();\n+        records.add(retval.protect);\n         records.add(retval.createEOF());\n \n \n@@ -511,42 +507,41 @@ private void checkRows()\n         }\n     }\n \n-    //public int addMergedRegion(short rowFrom, short colFrom, short rowTo,\n-    public int addMergedRegion(int rowFrom, short colFrom, int rowTo,\n-                               short colTo)\n-    {\n-    \t// Validate input\n-    \tif(rowTo < rowFrom) {\n-    \t\tthrow new IllegalArgumentException(\"The row to (\"+rowTo+\") must be >= the row from (\"+rowFrom+\")\");\n-    \t}\n-    \tif(colTo < colFrom) {\n-    \t\tthrow new IllegalArgumentException(\"The col to (\"+colTo+\") must be >= the col from (\"+colFrom+\")\");\n-    \t}\n-    \t\n+    public int addMergedRegion(int rowFrom, short colFrom, int rowTo, short colTo) {\n+        // Validate input\n+        if (rowTo < rowFrom) {\n+            throw new IllegalArgumentException(\"The 'to' row (\" + rowTo\n+                    + \") must not be less than the 'from' row (\" + rowFrom + \")\");\n+        }\n+        if (colTo < colFrom) {\n+            throw new IllegalArgumentException(\"The 'to' col (\" + colTo\n+                    + \") must not be less than the 'from' col (\" + colFrom + \")\");\n+        }\n+\n         if (merged == null || merged.getNumAreas() == 1027)\n         {\n             merged = ( MergeCellsRecord ) createMergedCells();\n-            mergedRecords.add(merged);            \n+            mergedRecords.add(merged);\n             records.add(records.size() - 1, merged);\n         }\n         merged.addArea(rowFrom, colFrom, rowTo, colTo);\n-        return numMergedRegions++; \n+        return numMergedRegions++;\n     }\n \n     public void removeMergedRegion(int index)\n     {\n         //safety checks\n         if (index >= numMergedRegions || mergedRecords.size() == 0)\n            return;\n-            \n+\n         int pos = 0;\n         int startNumRegions = 0;\n-        \n+\n         //optimisation for current record\n         if (numMergedRegions - index < merged.getNumAreas())\n         {\n             pos = mergedRecords.size() - 1;\n-            startNumRegions = numMergedRegions - merged.getNumAreas(); \n+            startNumRegions = numMergedRegions - merged.getNumAreas();\n         }\n         else\n         {\n@@ -558,7 +553,7 @@ public void removeMergedRegion(int index)\n                     pos = n;\n                     break;\n                 }\n-                startNumRegions += record.getNumAreas(); \n+                startNumRegions += record.getNumAreas();\n             }\n         }\n \n@@ -567,17 +562,17 @@ public void removeMergedRegion(int index)\n         numMergedRegions--;\n         if (rec.getNumAreas() == 0)\n         {\n-\t\t\tmergedRecords.remove(pos);\n-\t\t\t//get rid of the record from the sheet\n-\t\t\trecords.remove(merged);            \n+            mergedRecords.remove(pos);\n+            //get rid of the record from the sheet\n+            records.remove(merged);\n             if (merged == rec) {\n-            \t//pull up the LAST record for operations when we finally\n-            \t//support continue records for mergedRegions\n-            \tif (mergedRecords.size() > 0) {\n-            \t\tmerged = (MergeCellsRecord) mergedRecords.get(mergedRecords.size() - 1);\n-            \t} else {\n-            \t\tmerged = null;\n-            \t}\n+                //pull up the LAST record for operations when we finally\n+                //support continue records for mergedRegions\n+                if (mergedRecords.size() > 0) {\n+                    merged = (MergeCellsRecord) mergedRecords.get(mergedRecords.size() - 1);\n+                } else {\n+                    merged = null;\n+                }\n             }\n         }\n     }\n@@ -587,10 +582,10 @@ public void removeMergedRegion(int index)\n         //safety checks\n         if (index >= numMergedRegions || mergedRecords.size() == 0)\n             return null;\n-            \n+\n         int pos = 0;\n         int startNumRegions = 0;\n-        \n+\n         //optimisation for current record\n         if (numMergedRegions - index < merged.getNumAreas())\n         {\n@@ -607,7 +602,7 @@ public void removeMergedRegion(int index)\n                     pos = n;\n                     break;\n                 }\n-                startNumRegions += record.getNumAreas(); \n+                startNumRegions += record.getNumAreas();\n             }\n         }\n         return ((MergeCellsRecord) mergedRecords.get(pos)).getAreaAt(index - startNumRegions);\n@@ -620,62 +615,62 @@ public int getNumMergedRegions()\n     // Find correct position to add new CF record\n     private int findConditionalFormattingPosition()\n     {\n-    \t// This is default. \n-    \t// If the algorithm does not find the right position,\n-    \t// this one will be used (this is a position before EOF record)\n-    \tint index = records.size()-2;\n-    \t\n-    \tfor( int i=index; i>=0; i-- )\n-    \t{\n-    \t\tRecord rec = (Record)records.get(i);\n-    \t\tshort sid = rec.getSid();\n-    \t\t\n-    \t\t// CFRecordsAggregate records already exist, just add to the end\n-    \t\tif (rec instanceof CFRecordsAggregate)\t{ return i+1; }\n-    \t\t\n-    \t\tif( sid == (short)0x00ef )\t\t\t\t{ return i+1; }// PHONETICPR\n-    \t\tif( sid == (short)0x015f )\t\t\t\t{ return i+1; }// LABELRANGES\n-    \t\tif( sid == MergeCellsRecord.sid )\t\t{ return i+1; }\n-    \t\tif( sid == (short)0x0099 )\t\t\t\t{ return i+1; }// STANDARDWIDTH\n-    \t\tif( sid == SelectionRecord.sid )\t\t{ return i+1; }\n-    \t\tif( sid == PaneRecord.sid )\t\t\t\t{ return i+1; }\n-    \t\tif( sid == SCLRecord.sid ) \t\t\t\t{ return i+1; }\n-    \t\tif( sid == WindowTwoRecord.sid )\t\t{ return i+1; }\n-    \t}\n-    \t\n-    \treturn index;\n+        // This is default.\n+        // If the algorithm does not find the right position,\n+        // this one will be used (this is a position before EOF record)\n+        int index = records.size()-2;\n+\n+        for( int i=index; i>=0; i-- )\n+        {\n+            Record rec = (Record)records.get(i);\n+            short sid = rec.getSid();\n+\n+            // CFRecordsAggregate records already exist, just add to the end\n+            if (rec instanceof CFRecordsAggregate)    { return i+1; }\n+\n+            if( sid == (short)0x00ef )                { return i+1; }// PHONETICPR\n+            if( sid == (short)0x015f )                { return i+1; }// LABELRANGES\n+            if( sid == MergeCellsRecord.sid )        { return i+1; }\n+            if( sid == (short)0x0099 )                { return i+1; }// STANDARDWIDTH\n+            if( sid == SelectionRecord.sid )        { return i+1; }\n+            if( sid == PaneRecord.sid )                { return i+1; }\n+            if( sid == SCLRecord.sid )                 { return i+1; }\n+            if( sid == WindowTwoRecord.sid )        { return i+1; }\n+        }\n+\n+        return index;\n     }\n \n     public int addConditionalFormatting(CFRecordsAggregate cfAggregate)\n     {\n-    \tint index = findConditionalFormattingPosition();\n-    \trecords.add(index, cfAggregate);\n-    \tcondFormatting.add(cfAggregate);\n-    \treturn condFormatting.size()-1;\n+        int index = findConditionalFormattingPosition();\n+        records.add(index, cfAggregate);\n+        condFormatting.add(cfAggregate);\n+        return condFormatting.size()-1;\n     }\n \n     public void removeConditionalFormatting(int index)\n     {\n         if (index >= 0 && index <= condFormatting.size()-1 )\n         {\n-        \tCFRecordsAggregate cfAggregate = getCFRecordsAggregateAt(index);\n-        \trecords.remove(cfAggregate);\n-        \tcondFormatting.remove(index);\n+            CFRecordsAggregate cfAggregate = getCFRecordsAggregateAt(index);\n+            records.remove(cfAggregate);\n+            condFormatting.remove(index);\n         }\n     }\n-    \n+\n     public CFRecordsAggregate getCFRecordsAggregateAt(int index)\n     {\n         if (index >= 0 && index <= condFormatting.size()-1 )\n         {\n-        \treturn (CFRecordsAggregate) condFormatting.get(index);\n+            return (CFRecordsAggregate) condFormatting.get(index);\n         }\n         return null;\n     }\n-    \n+\n     public int getNumConditionalFormattings()\n     {\n-    \treturn condFormatting.size();\n+        return condFormatting.size();\n     }\n \n     /**\n@@ -711,8 +706,6 @@ public int getNumRecords()\n      *\n      * @see org.apache.poi.hssf.record.DimensionsRecord\n      */\n-\n-    //public void setDimensions(short firstrow, short firstcol, short lastrow,\n     public void setDimensions(int firstrow, short firstcol, int lastrow,\n                               short lastcol)\n     {\n@@ -735,7 +728,7 @@ public void setDimensions(int firstrow, short firstcol, int lastrow,\n \n     /**\n      * set the locator for where we should look for the next value record.  The\n-     * algorythm will actually start here and find the correct location so you\n+     * algorithm will actually start here and find the correct location so you\n      * can set this to 0 and watch performance go down the tubes but it will work.\n      * After a value is set this is automatically advanced.  Its also set by the\n      * create method.  So you probably shouldn't mess with this unless you have\n@@ -813,13 +806,13 @@ public int serialize(int offset, byte [] data)\n         for (int k = 0; k < records.size(); k++)\n         {\n             Record record = (( Record ) records.get(k));\n-            \n+\n             // Don't write out UncalcedRecord entries, as\n             //  we handle those specially just below\n             if (record instanceof UncalcedRecord) {\n-            \tcontinue;\n+                continue;\n             }\n-            \n+\n             // Once the rows have been found in the list of records, start\n             //  writing out the blocked row information. This includes the DBCell references\n             if (record instanceof RowRecordsAggregate) {\n@@ -829,13 +822,13 @@ public int serialize(int offset, byte [] data)\n             } else {\n               pos += record.serialize(pos, data );   // rec.length;\n             }\n-            \n+\n             // If the BOF record was just serialized then add the IndexRecord\n             if (record.getSid() == BOFRecord.sid) {\n               // Add an optional UncalcedRecord\n               if (uncalced) {\n-            \t  UncalcedRecord rec = new UncalcedRecord();\n-            \t  pos += rec.serialize(pos, data);\n+                  UncalcedRecord rec = new UncalcedRecord();\n+                  pos += rec.serialize(pos, data);\n               }\n               //Can there be more than one BOF for a sheet? If not then we can\n               //remove this guard. So be safe it is left here.\n@@ -871,7 +864,7 @@ public int serialize(int offset, byte [] data)\n             log.log(POILogger.DEBUG, \"Sheet.serialize returning \");\n         return pos-offset;\n     }\n-    \n+\n     private int serializeIndexRecord(final int BOFRecordIndex, final int offset, byte[] data) {\n       IndexRecord index = new IndexRecord();\n       index.setFirstRow(rows.getFirstRowNum());\n@@ -906,7 +899,7 @@ private int serializeIndexRecord(final int BOFRecordIndex, final int offset, byt\n       }\n       return index.serialize(offset, data);\n     }\n-    \n+\n \n     /**\n      * Create a row record.  (does not add it to the records contained in this sheet)\n@@ -930,8 +923,6 @@ public RowRecord createRow(int row)\n      * @return LabelSSTRecord newly created containing your SST Index, row,col.\n      * @see org.apache.poi.hssf.record.SSTRecord\n      */\n-\n-    //public LabelSSTRecord createLabelSST(short row, short col, int index)\n     public LabelSSTRecord createLabelSST(int row, short col, int index)\n     {\n         log.logFormatted(POILogger.DEBUG, \"create labelsst row,col,index %,%,%\",\n@@ -957,8 +948,6 @@ public LabelSSTRecord createLabelSST(int row, short col, int index)\n      *\n      * @return NumberRecord for that row, col containing that value as added to the sheet\n      */\n-\n-    //public NumberRecord createNumber(short row, short col, double value)\n     public NumberRecord createNumber(int row, short col, double value)\n     {\n         log.logFormatted(POILogger.DEBUG, \"create number row,col,value %,%,%\",\n@@ -968,7 +957,6 @@ public NumberRecord createNumber(int row, short col, double value)\n         });\n         NumberRecord rec = new NumberRecord();\n \n-        //rec.setRow(( short ) row);\n         rec.setRow(row);\n         rec.setColumn(col);\n         rec.setValue(value);\n@@ -982,18 +970,14 @@ public NumberRecord createNumber(int row, short col, double value)\n      * @param row - the row the BlankRecord is a member of\n      * @param col - the column the BlankRecord is a member of\n      */\n-\n-    //public BlankRecord createBlank(short row, short col)\n     public BlankRecord createBlank(int row, short col)\n     {\n-        //log.logFormatted(POILogger.DEBUG, \"create blank row,col %,%\", new short[]\n         log.logFormatted(POILogger.DEBUG, \"create blank row,col %,%\", new int[]\n         {\n             row, col\n         });\n         BlankRecord rec = new BlankRecord();\n \n-        //rec.setRow(( short ) row);\n         rec.setRow(row);\n         rec.setColumn(col);\n         rec.setXFIndex(( short ) 0x0f);\n@@ -1009,12 +993,9 @@ public BlankRecord createBlank(int row, short col)\n      * @param formula - a String representing the formula.  To be parsed to PTGs\n      * @return bogus/useless formula record\n      */\n-\n-    //public FormulaRecord createFormula(short row, short col, String formula)\n     public FormulaRecord createFormula(int row, short col, String formula)\n     {\n         log.logFormatted(POILogger.DEBUG, \"create formula row,col,formula %,%,%\",\n-                         //new short[]\n                          new int[]\n         {\n             row, col\n@@ -1052,8 +1033,6 @@ public FormulaRecord createFormula(int row, short col, String formula)\n      * @param row the row to add the cell value to\n      * @param col the cell value record itself.\n      */\n-\n-    //public void addValueRecord(short row, CellValueRecordInterface col)\n     public void addValueRecord(int row, CellValueRecordInterface col)\n     {\n         checkCells();\n@@ -1075,29 +1054,6 @@ public void addValueRecord(int row, CellValueRecordInterface col)\n             d.setFirstCol(col.getColumn());\n         }\n         cells.insertCell(col);\n-\n-        /*\n-         * for (int k = loc; k < records.size(); k++)\n-         * {\n-         *   Record rec = ( Record ) records.get(k);\n-         *\n-         *   if (rec.getSid() == RowRecord.sid)\n-         *   {\n-         *       RowRecord rowrec = ( RowRecord ) rec;\n-         *\n-         *       if (rowrec.getRowNumber() == col.getRow())\n-         *       {\n-         *           records.add(k + 1, col);\n-         *           loc = k;\n-         *           if (rowrec.getLastCol() <= col.getColumn())\n-         *           {\n-         *               rowrec.setLastCol((( short ) (col.getColumn() + 1)));\n-         *           }\n-         *           break;\n-         *       }\n-         *   }\n-         * }\n-         */\n     }\n \n     /**\n@@ -1109,36 +1065,13 @@ public void addValueRecord(int row, CellValueRecordInterface col)\n      * @param col - a record supporting the CellValueRecordInterface.\n      * @see org.apache.poi.hssf.record.CellValueRecordInterface\n      */\n-\n-    //public void removeValueRecord(short row, CellValueRecordInterface col)\n     public void removeValueRecord(int row, CellValueRecordInterface col)\n     {\n         checkCells();\n         log.logFormatted(POILogger.DEBUG, \"remove value record row,dimsloc %,%\",\n                          new int[]{row, dimsloc} );\n         loc = dimsloc;\n         cells.removeCell(col);\n-\n-        /*\n-         * for (int k = loc; k < records.size(); k++)\n-         * {\n-         *   Record rec = ( Record ) records.get(k);\n-         *\n-         *   // checkDimsLoc(rec,k);\n-         *   if (rec.isValue())\n-         *   {\n-         *       CellValueRecordInterface cell =\n-         *           ( CellValueRecordInterface ) rec;\n-         *\n-         *       if ((cell.getRow() == col.getRow())\n-         *               && (cell.getColumn() == col.getColumn()))\n-         *       {\n-         *           records.remove(k);\n-         *           break;\n-         *       }\n-         *   }\n-         * }\n-         */\n     }\n \n     /**\n@@ -1160,26 +1093,10 @@ public void replaceValueRecord(CellValueRecordInterface newval)\n         //The ValueRecordsAggregate use a tree map underneath.\n         //The tree Map uses the CellValueRecordInterface as both the\n         //key and the value, if we dont do a remove, then\n-        //the previous instance of the key is retained, effectively using \n+        //the previous instance of the key is retained, effectively using\n         //double the memory\n         cells.removeCell(newval);\n         cells.insertCell(newval);\n-\n-        /*\n-         * CellValueRecordInterface oldval = getNextValueRecord();\n-         *\n-         * while (oldval != null)\n-         * {\n-         *   if (oldval.isEqual(newval))\n-         *   {\n-         *       records.set(( short ) (getLoc() - 1), newval);\n-         *       return;\n-         *   }\n-         *   oldval = getNextValueRecord();\n-         * }\n-         * addValueRecord(newval.getRow(), newval);\n-         * setLoc(dimsloc);\n-         */\n     }\n \n     /**\n@@ -1218,41 +1135,6 @@ public void addRow(RowRecord row)\n \n         rows.insertRow(row);\n \n-        /*\n-         * for (int k = loc; k < records.size(); k++)\n-         * {\n-         *   Record rec = ( Record ) records.get(k);\n-         *\n-         *   if (rec.getSid() == IndexRecord.sid)\n-         *   {\n-         *       index = ( IndexRecord ) rec;\n-         *   }\n-         *   if (rec.getSid() == RowRecord.sid)\n-         *   {\n-         *       RowRecord rowrec = ( RowRecord ) rec;\n-         *\n-         *       if (rowrec.getRowNumber() > row.getRowNumber())\n-         *       {\n-         *           records.add(k, row);\n-         *           loc = k;\n-         *           break;\n-         *       }\n-         *   }\n-         *   if (rec.getSid() == WindowTwoRecord.sid)\n-         *   {\n-         *       records.add(k, row);\n-         *       loc = k;\n-         *       break;\n-         *   }\n-         * }\n-         * if (index != null)\n-         * {\n-         *   if (index.getLastRowAdd1() <= row.getRowNumber())\n-         *   {\n-         *       index.setLastRowAdd1(row.getRowNumber() + 1);\n-         *   }\n-         * }\n-         */\n         if (log.check( POILogger.DEBUG ))\n             log.log(POILogger.DEBUG, \"exit addRow\");\n     }\n@@ -1268,33 +1150,9 @@ public void addRow(RowRecord row)\n     public void removeRow(RowRecord row)\n     {\n         checkRows();\n-        // IndexRecord index = null;\n \n         setLoc(getDimsLoc());\n         rows.removeRow(row);\n-\n-        /*\n-         * for (int k = loc; k < records.size(); k++)\n-         * {\n-         *   Record rec = ( Record ) records.get(k);\n-         *\n-         *   // checkDimsLoc(rec,k);\n-         *   if (rec.getSid() == RowRecord.sid)\n-         *   {\n-         *       RowRecord rowrec = ( RowRecord ) rec;\n-         *\n-         *       if (rowrec.getRowNumber() == row.getRowNumber())\n-         *       {\n-         *           records.remove(k);\n-         *           break;\n-         *       }\n-         *   }\n-         *   if (rec.getSid() == WindowTwoRecord.sid)\n-         *   {\n-         *       break;\n-         *   }\n-         * }\n-         */\n     }\n \n     /**\n@@ -1325,65 +1183,7 @@ public CellValueRecordInterface getNextValueRecord()\n             return null;\n         }\n         return ( CellValueRecordInterface ) valueRecIterator.next();\n-\n-        /*\n-         *      if (this.getLoc() < records.size())\n-         *     {\n-         *         for (int k = getLoc(); k < records.size(); k++)\n-         *         {\n-         *             Record rec = ( Record ) records.get(k);\n-         *\n-         *             this.setLoc(k + 1);\n-         *             if (rec instanceof CellValueRecordInterface)\n-         *             {\n-         *                 return ( CellValueRecordInterface ) rec;\n-         *             }\n-         *         }\n-         *     }\n-         *     return null;\n-         */\n-    }\n-\n-    /**\n-     * get the NEXT RowRecord or CellValueRecord(from LOC).  The first record that\n-     * is a Row record or CellValueRecord(starting at LOC) will be returned.\n-     * <P>\n-     * This method is \"loc\" sensitive.  Meaning you need to set LOC to where you\n-     * want it to start searching.  If you don't know do this: setLoc(getDimsLoc).\n-     * When adding several rows you can just start at the last one by leaving loc\n-     * at what this sets it to.  For this method, set loc to dimsloc to start with.\n-     * subsequent calls will return rows in (physical) sequence or NULL when you get to the end.\n-     *\n-     * @return RowRecord representing the next row record or CellValueRecordInterface\n-     *  representing the next cellvalue or NULL if there are no more\n-     * @see #setLoc(int)\n-     *\n-     */\n-\n-/*    public Record getNextRowOrValue()\n-    {\n-        POILogger.DEBUG((new StringBuffer(\"getNextRow loc= \")).append(loc)\n-            .toString());\n-        if (this.getLoc() < records.size())\n-        {\n-            for (int k = this.getLoc(); k < records.size(); k++)\n-            {\n-                Record rec = ( Record ) records.get(k);\n-\n-                this.setLoc(k + 1);\n-                if (rec.getSid() == RowRecord.sid)\n-                {\n-                    return rec;\n-                }\n-                else if (rec.isValue())\n-                {\n-                    return rec;\n-                }\n-            }\n-        }\n-        return null;\n     }\n- */\n \n     /**\n      * get the NEXT RowRecord (from LOC).  The first record that is a Row record\n@@ -1413,20 +1213,6 @@ public RowRecord getNextRow()\n             return null;\n         }\n         return ( RowRecord ) rowRecIterator.next();\n-\n-/*        if (this.getLoc() < records.size())\n-        {\n-            for (int k = this.getLoc(); k < records.size(); k++)\n-            {\n-                Record rec = ( Record ) records.get(k);\n-\n-                this.setLoc(k + 1);\n-                if (rec.getSid() == RowRecord.sid)\n-                {\n-                    return ( RowRecord ) rec;\n-                }\n-            }\n-        }*/\n     }\n \n     /**\n@@ -1445,34 +1231,10 @@ public RowRecord getNextRow()\n      * @see #setLoc(int)\n      *\n      */\n-\n-    //public RowRecord getRow(short rownum)\n-    public RowRecord getRow(int rownum)\n-    {\n+    public RowRecord getRow(int rownum) {\n         if (log.check( POILogger.DEBUG ))\n             log.log(POILogger.DEBUG, \"getNextRow loc= \" + loc);\n         return rows.getRow(rownum);\n-\n-        /*\n-         * if (this.getLoc() < records.size())\n-         * {\n-         *   for (int k = this.getLoc(); k < records.size(); k++)\n-         *   {\n-         *       Record rec = ( Record ) records.get(k);\n-         *\n-         *       this.setLoc(k + 1);\n-         *       if (rec.getSid() == RowRecord.sid)\n-         *       {\n-         *           if ((( RowRecord ) rec).getRowNumber() == rownum)\n-         *           {\n-         *               return ( RowRecord ) rec;\n-         *           }\n-         *       }\n-         *   }\n-         * }\n-         */\n-\n-        // return null;\n     }\n \n     /**\n@@ -1489,7 +1251,6 @@ protected Record createBOF()\n         retval.setVersion(( short ) 0x600);\n         retval.setType(( short ) 0x010);\n \n-        // retval.setBuild((short)0x10d3);\n         retval.setBuild(( short ) 0x0dbb);\n         retval.setBuildYear(( short ) 1996);\n         retval.setHistoryBitMask(0xc1);\n@@ -1807,7 +1568,7 @@ protected Record createDefaultColWidth()\n      * @see org.apache.poi.hssf.record.ColumnInfoRecord\n      * @return record containing a ColumnInfoRecord\n      */\n-\n+    // TODO change return type to ColumnInfoRecord \n     protected Record createColInfo()\n     {\n         return ColumnInfoRecordsAggregate.createColInfo();\n@@ -1830,12 +1591,12 @@ public short getDefaultColumnWidth()\n \n     public boolean isGridsPrinted()\n     {\n-    \tif (gridset == null) {\n-    \t\tgridset = (GridsetRecord)createGridset();\n-    \t\t//Insert the newlycreated Gridset record at the end of the record (just before the EOF)\n-    \t\tint loc = findFirstRecordLocBySid(EOFRecord.sid);\n-    \t\trecords.add(loc, gridset);     \t\t\n-    \t}\n+        if (gridset == null) {\n+            gridset = (GridsetRecord)createGridset();\n+            //Insert the newlycreated Gridset record at the end of the record (just before the EOF)\n+            int loc = findFirstRecordLocBySid(EOFRecord.sid);\n+            records.add(loc, gridset);\n+        }\n         return !gridset.getGridset();\n     }\n \n@@ -1918,16 +1679,16 @@ public short getColumnWidth(short column)\n         }\n         return retval;\n     }\n-    \n+\n     /**\n-     * get the index to the ExtendedFormatRecord \"associated\" with \n-     * the column at specified 0-based index. (In this case, an \n-     * ExtendedFormatRecord index is actually associated with a \n+     * get the index to the ExtendedFormatRecord \"associated\" with\n+     * the column at specified 0-based index. (In this case, an\n+     * ExtendedFormatRecord index is actually associated with a\n      * ColumnInfoRecord which spans 1 or more columns)\n      * <br/>\n      * Returns the index to the default ExtendedFormatRecord (0xF)\n      * if no ColumnInfoRecord exists that includes the column\n-     * index specified. \n+     * index specified.\n      * @param column\n      * @return index of ExtendedFormatRecord associated with\n      * ColumnInfoRecord that includes the column index or the\n@@ -2116,38 +1877,38 @@ protected Record createSelection()\n         retval.setNumRefs(( short ) 0x0);\n         return retval;\n     }\n-    \n-    public short getTopRow() \n+\n+    public short getTopRow()\n     {\n-    \treturn (windowTwo==null) ? (short) 0 : windowTwo.getTopRow();\n+        return (windowTwo==null) ? (short) 0 : windowTwo.getTopRow();\n     }\n-    \n-    public void setTopRow(short topRow) \n+\n+    public void setTopRow(short topRow)\n     {\n-    \tif (windowTwo!=null) \n-    \t{\n-    \t\twindowTwo.setTopRow(topRow);\n-    \t}\n+        if (windowTwo!=null)\n+        {\n+            windowTwo.setTopRow(topRow);\n+        }\n     }\n-   \n+\n     /**\n      * Sets the left column to show in desktop window pane.\n      * @param leftCol the left column to show in desktop window pane\n      */\n         public void setLeftCol(short leftCol){\n-        \tif (windowTwo!=null) \n-        \t{   \n-        \twindowTwo.setLeftCol(leftCol);\n-        \t}\n+            if (windowTwo!=null)\n+            {\n+            windowTwo.setLeftCol(leftCol);\n+            }\n         }\n-        \n-        public short getLeftCol() \n+\n+        public short getLeftCol()\n         {\n-        \treturn (windowTwo==null) ? (short) 0 : windowTwo.getLeftCol();\n+            return (windowTwo==null) ? (short) 0 : windowTwo.getLeftCol();\n         }\n-        \n-        \n-    \n+\n+\n+\n     /**\n      * Returns the active row\n      *\n@@ -2162,7 +1923,7 @@ public int getActiveCellRow()\n         }\n         return selection.getActiveCellRow();\n     }\n-    \n+\n     /**\n      * Sets the active row\n      *\n@@ -2177,7 +1938,7 @@ public void setActiveCellRow(int row)\n             selection.setActiveCellRow(row);\n         }\n     }\n-    \n+\n     /**\n      * Returns the active column\n      *\n@@ -2192,7 +1953,7 @@ public short getActiveCellCol()\n         }\n         return selection.getActiveCellCol();\n     }\n-    \n+\n     /**\n      * Sets the active column\n      *\n@@ -2278,9 +2039,9 @@ public int getSize()\n         }\n         // Add space for UncalcedRecord\n         if (uncalced) {\n-        \tretval += UncalcedRecord.getStaticRecordSize();\n+            retval += UncalcedRecord.getStaticRecordSize();\n         }\n-        \n+\n         return retval;\n     }\n \n@@ -2367,16 +2128,19 @@ public int findFirstRecordLocBySid( short sid )\n      */\n     public HeaderRecord getHeader ()\n     {\n-\treturn header;\n+    return header;\n     }\n \n+    public WindowTwoRecord getWindowTwo() {\n+        return windowTwo;\n+    }\n     /**\n      * Sets the HeaderRecord.\n      * @param newHeader The new HeaderRecord for the sheet.\n      */\n     public void setHeader (HeaderRecord newHeader)\n     {\n-    \theader = newHeader;\n+        header = newHeader;\n     }\n \n     /**\n@@ -2385,7 +2149,7 @@ public void setHeader (HeaderRecord newHeader)\n      */\n     public FooterRecord getFooter ()\n     {\n-\t    return footer;\n+        return footer;\n     }\n \n     /**\n@@ -2394,7 +2158,7 @@ public FooterRecord getFooter ()\n      */\n     public void setFooter (FooterRecord newFooter)\n     {\n-\t    footer = newFooter;\n+        footer = newFooter;\n     }\n \n     /**\n@@ -2403,7 +2167,7 @@ public void setFooter (FooterRecord newFooter)\n      */\n     public PrintSetupRecord getPrintSetup ()\n     {\n-\t    return printSetup;\n+        return printSetup;\n     }\n \n     /**\n@@ -2412,7 +2176,7 @@ public PrintSetupRecord getPrintSetup ()\n      */\n     public void setPrintSetup (PrintSetupRecord newPrintSetup)\n     {\n-\t    printSetup = newPrintSetup;\n+        printSetup = newPrintSetup;\n     }\n \n     /**\n@@ -2421,7 +2185,7 @@ public void setPrintSetup (PrintSetupRecord newPrintSetup)\n      */\n     public PrintGridlinesRecord getPrintGridlines ()\n     {\n-\t    return printGridlines;\n+        return printGridlines;\n     }\n \n     /**\n@@ -2430,7 +2194,7 @@ public PrintGridlinesRecord getPrintGridlines ()\n      */\n     public void setPrintGridlines (PrintGridlinesRecord newPrintGridlines)\n     {\n-\t    printGridlines = newPrintGridlines;\n+        printGridlines = newPrintGridlines;\n     }\n \n     /**\n@@ -2447,23 +2211,23 @@ public void setSelected(boolean sel) {\n       * @return the size of the margin\n       */\n     public double getMargin(short margin) {\n-\tif (getMargins()[margin] != null)\n-\t    return margins[margin].getMargin();\n-\telse {\n-\t    switch ( margin )\n-\t\t{\n-\t\tcase LeftMargin:\n-\t\t    return .75;\n-\t\tcase RightMargin:\n-\t\t    return .75;\n-\t\tcase TopMargin:\n-\t\t    return 1.0;\n-\t\tcase BottomMargin:\n-\t\t    return 1.0;\n-\t\tdefault :\n-\t\t    throw new RuntimeException( \"Unknown margin constant:  \" + margin );\n-\t\t}\n-\t}\n+    if (getMargins()[margin] != null)\n+        return margins[margin].getMargin();\n+    else {\n+        switch ( margin )\n+        {\n+        case LeftMargin:\n+            return .75;\n+        case RightMargin:\n+            return .75;\n+        case TopMargin:\n+            return 1.0;\n+        case BottomMargin:\n+            return 1.0;\n+        default :\n+            throw new RuntimeException( \"Unknown margin constant:  \" + margin );\n+        }\n+    }\n     }\n \n      /**\n@@ -2472,32 +2236,32 @@ public double getMargin(short margin) {\n       * @param size the size of the margin\n       */\n     public void setMargin(short margin, double size) {\n-\tMargin m = getMargins()[margin];\n-\tif (m  == null) {\n-\t    switch ( margin )\n-\t\t{\n-\t\tcase LeftMargin:\n-\t\t    m = new LeftMarginRecord();\n-\t\t    records.add( getDimsLoc() + 1, m );\n-\t\t    break;\n-\t\tcase RightMargin:\n-\t\t    m = new RightMarginRecord();\n-\t\t    records.add( getDimsLoc() + 1, m );\n-\t\t    break;\n-\t\tcase TopMargin:\n-\t\t    m = new TopMarginRecord();\n-\t\t    records.add( getDimsLoc() + 1, m );\n-\t\t    break;\n-\t\tcase BottomMargin:\n-\t\t    m = new BottomMarginRecord();\n-\t\t    records.add( getDimsLoc() + 1, m );\n-\t\t    break;\n-\t\tdefault :\n-\t\t    throw new RuntimeException( \"Unknown margin constant:  \" + margin );\n-\t\t}\n-\t    margins[margin] = m;\n-\t}\n-\tm.setMargin( size );\n+    Margin m = getMargins()[margin];\n+    if (m  == null) {\n+        switch ( margin )\n+        {\n+        case LeftMargin:\n+            m = new LeftMarginRecord();\n+            records.add( getDimsLoc() + 1, m );\n+            break;\n+        case RightMargin:\n+            m = new RightMarginRecord();\n+            records.add( getDimsLoc() + 1, m );\n+            break;\n+        case TopMargin:\n+            m = new TopMarginRecord();\n+            records.add( getDimsLoc() + 1, m );\n+            break;\n+        case BottomMargin:\n+            m = new BottomMarginRecord();\n+            records.add( getDimsLoc() + 1, m );\n+            break;\n+        default :\n+            throw new RuntimeException( \"Unknown margin constant:  \" + margin );\n+        }\n+        margins[margin] = m;\n+    }\n+    m.setMargin( size );\n     }\n \n     public int getEofLoc()\n@@ -2514,10 +2278,10 @@ public int getEofLoc()\n      */\n     public void createFreezePane(int colSplit, int rowSplit, int topRow, int leftmostColumn )\n     {\n-    \tint paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n-    \tif (paneLoc != -1)\n-    \t\trecords.remove(paneLoc);\n-    \t\n+        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n+        if (paneLoc != -1)\n+            records.remove(paneLoc);\n+\n         int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n         PaneRecord pane = new PaneRecord();\n         pane.setX((short)colSplit);\n@@ -2563,10 +2327,10 @@ else if (colSplit == 0)\n      */\n     public void createSplitPane(int xSplitPos, int ySplitPos, int topRow, int leftmostColumn, int activePane )\n     {\n-    \tint paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n-    \tif (paneLoc != -1)\n-    \t\trecords.remove(paneLoc);\n-    \t\n+        int paneLoc = findFirstRecordLocBySid(PaneRecord.sid);\n+        if (paneLoc != -1)\n+            records.remove(paneLoc);\n+\n         int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n         PaneRecord r = new PaneRecord();\n         r.setX((short)xSplitPos);\n@@ -2583,7 +2347,7 @@ public void createSplitPane(int xSplitPos, int ySplitPos, int topRow, int leftmo\n         sel.setPane(PANE_LOWER_RIGHT);\n \n     }\n-    \n+\n     /**\n      * Returns the information regarding the currently configured pane (split or freeze).\n      * @return null if no pane configured, or the pane information.\n@@ -2592,9 +2356,9 @@ public PaneInformation getPaneInformation() {\n       PaneRecord rec = (PaneRecord)findFirstRecordBySid(PaneRecord.sid);\n       if (rec == null)\n         return null;\n-        \n+\n       return new PaneInformation(rec.getX(), rec.getY(), rec.getTopRow(),\n-    \t\t                     rec.getLeftColumn(), (byte)rec.getActivePane(), windowTwo.getFreezePanes());      \n+                                 rec.getLeftColumn(), (byte)rec.getActivePane(), windowTwo.getFreezePanes());\n     }\n \n     public SelectionRecord getSelection()\n@@ -2660,12 +2424,12 @@ protected ScenarioProtectRecord createScenarioProtect()\n      */\n     public ProtectRecord getProtect()\n     {\n-    \tif (protect == null) {\n-    \t\tprotect = (ProtectRecord)createProtect();\n-    \t\t//Insert the newlycreated protect record at the end of the record (just before the EOF)\n-    \t\tint loc = findFirstRecordLocBySid(EOFRecord.sid);\n-    \t\trecords.add(loc, protect);    \t\t\n-    \t}\n+        if (protect == null) {\n+            protect = (ProtectRecord)createProtect();\n+            //Insert the newlycreated protect record at the end of the record (just before the EOF)\n+            int loc = findFirstRecordLocBySid(EOFRecord.sid);\n+            records.add(loc, protect);\n+        }\n         return protect;\n     }\n \n@@ -2674,12 +2438,12 @@ public ProtectRecord getProtect()\n      */\n     public PasswordRecord getPassword()\n     {\n-    \tif (password == null) {\n-    \t\tpassword = createPassword();\n-    \t\t//Insert the newly created password record at the end of the record (just before the EOF)\n-    \t\tint loc = findFirstRecordLocBySid(EOFRecord.sid);\n-    \t\trecords.add(loc, password);    \t\t\n-    \t}\n+        if (password == null) {\n+            password = createPassword();\n+            //Insert the newly created password record at the end of the record (just before the EOF)\n+            int loc = findFirstRecordLocBySid(EOFRecord.sid);\n+            records.add(loc, password);\n+        }\n         return password;\n     }\n \n@@ -2714,7 +2478,7 @@ public void setDisplayGridlines(boolean show) {\n      * @return whether gridlines are displayed\n      */\n     public boolean isDisplayGridlines() {\n-\treturn windowTwo.getDisplayGridlines();\n+    return windowTwo.getDisplayGridlines();\n     }\n \n     /**\n@@ -2730,7 +2494,7 @@ public void setDisplayFormulas(boolean show) {\n      * @return whether formulas are displayed\n      */\n     public boolean isDisplayFormulas() {\n-\treturn windowTwo.getDisplayFormulas();\n+    return windowTwo.getDisplayFormulas();\n     }\n \n     /**\n@@ -2746,32 +2510,32 @@ public void setDisplayRowColHeadings(boolean show) {\n      * @return whether RowColHeadings are displayed\n      */\n     public boolean isDisplayRowColHeadings() {\n-\t    return windowTwo.getDisplayRowColHeadings();\n+        return windowTwo.getDisplayRowColHeadings();\n     }\n-    \n+\n \n     /**\n-\t * @return whether an uncalced record must be inserted or not at generation\n-\t */\n-\tpublic boolean getUncalced() {\n-\t\treturn uncalced;\n-\t}\n-\t/**\n-\t * @param uncalced whether an uncalced record must be inserted or not at generation\n-\t */\n-\tpublic void setUncalced(boolean uncalced) {\n-\t\tthis.uncalced = uncalced;\n-\t}\n+     * @return whether an uncalced record must be inserted or not at generation\n+     */\n+    public boolean getUncalced() {\n+        return uncalced;\n+    }\n+    /**\n+     * @param uncalced whether an uncalced record must be inserted or not at generation\n+     */\n+    public void setUncalced(boolean uncalced) {\n+        this.uncalced = uncalced;\n+    }\n \n-\t/**\n+    /**\n      * Returns the array of margins.  If not created, will create.\n      *\n      * @return the array of marings.\n      */\n     protected Margin[] getMargins() {\n         if (margins == null)\n             margins = new Margin[4];\n-    \treturn margins;\n+        return margins;\n     }\n \n     /**\n@@ -2789,11 +2553,11 @@ public int aggregateDrawingRecords(DrawingManager2 drawingManager, boolean creat\n         boolean noDrawingRecordsFound = (loc == -1);\n         if (noDrawingRecordsFound)\n         {\n-        \tif(!createIfMissing) {\n-        \t\t// None found, and not allowed to add in\n-        \t\treturn -1;\n-        \t}\n-        \t\n+            if(!createIfMissing) {\n+                // None found, and not allowed to add in\n+                return -1;\n+            }\n+\n             EscherAggregate aggregate = new EscherAggregate( drawingManager );\n             loc = findFirstRecordLocBySid(EscherAggregate.sid);\n             if (loc == -1)\n@@ -2847,53 +2611,53 @@ public void preSerialize()\n      * @param breaks The page record to be shifted\n      * @param start Starting \"main\" value to shift breaks\n      * @param stop Ending \"main\" value to shift breaks\n-     * @param count number of units (rows/columns) to shift by \n+     * @param count number of units (rows/columns) to shift by\n      */\n     public void shiftBreaks(PageBreakRecord breaks, short start, short stop, int count) {\n-   \t\n-    \tif(rowBreaks == null)\n-    \t\treturn;\n-    \tIterator iterator = breaks.getBreaksIterator();\n-    \tList shiftedBreak = new ArrayList();\n-    \twhile(iterator.hasNext()) \n-    \t{\n-    \t\tPageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n-    \t\tshort breakLocation = breakItem.main;\n-    \t\tboolean inStart = (breakLocation >= start);\n-    \t\tboolean inEnd = (breakLocation <= stop);\n-    \t\tif(inStart && inEnd)\n-    \t\t\tshiftedBreak.add(breakItem);\n-    \t}\n-    \t\n-    \titerator = shiftedBreak.iterator();\n-    \twhile (iterator.hasNext()) {    \t\t\n-\t\t\tPageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n-    \t\tbreaks.removeBreak(breakItem.main);\n-    \t\tbreaks.addBreak((short)(breakItem.main+count), breakItem.subFrom, breakItem.subTo);\n-    \t}\n-    }\n-    \n+\n+        if(rowBreaks == null)\n+            return;\n+        Iterator iterator = breaks.getBreaksIterator();\n+        List shiftedBreak = new ArrayList();\n+        while(iterator.hasNext())\n+        {\n+            PageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n+            short breakLocation = breakItem.main;\n+            boolean inStart = (breakLocation >= start);\n+            boolean inEnd = (breakLocation <= stop);\n+            if(inStart && inEnd)\n+                shiftedBreak.add(breakItem);\n+        }\n+\n+        iterator = shiftedBreak.iterator();\n+        while (iterator.hasNext()) {\n+            PageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n+            breaks.removeBreak(breakItem.main);\n+            breaks.addBreak((short)(breakItem.main+count), breakItem.subFrom, breakItem.subTo);\n+        }\n+    }\n+\n     /**\n      * Sets a page break at the indicated row\n      * @param row\n      */\n-    public void setRowBreak(int row, short fromCol, short toCol) { \n-    \tif (rowBreaks == null) {\n+    public void setRowBreak(int row, short fromCol, short toCol) {\n+        if (rowBreaks == null) {\n             int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n             rowBreaks = new PageBreakRecord(PageBreakRecord.HORIZONTAL_SID);\n             records.add(loc, rowBreaks);\n-    \t}\n-    \trowBreaks.addBreak((short)row, fromCol, toCol);\n+        }\n+        rowBreaks.addBreak((short)row, fromCol, toCol);\n     }\n \n     /**\n      * Removes a page break at the indicated row\n      * @param row\n      */\n     public void removeRowBreak(int row) {\n-    \tif (rowBreaks == null)\n-    \t\tthrow new IllegalArgumentException(\"Sheet does not define any row breaks\");\n-    \trowBreaks.removeBreak((short)row);\n+        if (rowBreaks == null)\n+            throw new IllegalArgumentException(\"Sheet does not define any row breaks\");\n+        rowBreaks.removeBreak((short)row);\n     }\n \n     /**\n@@ -2902,31 +2666,31 @@ public void removeRowBreak(int row) {\n      * @return true if the specified row has a page break\n      */\n     public boolean isRowBroken(int row) {\n-    \treturn (rowBreaks == null) ? false : rowBreaks.getBreak((short)row) != null;\n+        return (rowBreaks == null) ? false : rowBreaks.getBreak((short)row) != null;\n     }\n \n     /**\n      * Sets a page break at the indicated column\n      *\n      */\n     public void setColumnBreak(short column, short fromRow, short toRow) {\n-    \tif (colBreaks == null) {\n+        if (colBreaks == null) {\n             int loc = findFirstRecordLocBySid(WindowTwoRecord.sid);\n             colBreaks = new PageBreakRecord(PageBreakRecord.VERTICAL_SID);\n             records.add(loc, colBreaks);\n-    \t}    \t\n-    \tcolBreaks.addBreak(column, fromRow, toRow);\n+        }\n+        colBreaks.addBreak(column, fromRow, toRow);\n     }\n \n     /**\n      * Removes a page break at the indicated column\n      *\n      */\n     public void removeColumnBreak(short column) {\n-    \tif (colBreaks == null)\n-    \t\tthrow new IllegalArgumentException(\"Sheet does not define any column breaks\");\n-    \t\n-    \tcolBreaks.removeBreak(column);\n+        if (colBreaks == null)\n+            throw new IllegalArgumentException(\"Sheet does not define any column breaks\");\n+\n+        colBreaks.removeBreak(column);\n     }\n \n     /**\n@@ -2935,17 +2699,17 @@ public void removeColumnBreak(short column) {\n      * @return true if the specified column has a page break\n      */\n     public boolean isColumnBroken(short column) {\n-    \treturn (colBreaks == null) ? false : colBreaks.getBreak(column) != null;\n+        return (colBreaks == null) ? false : colBreaks.getBreak(column) != null;\n     }\n-    \n+\n     /**\n      * Shifts the horizontal page breaks for the indicated count\n      * @param startingRow\n      * @param endingRow\n      * @param count\n      */\n     public void shiftRowBreaks(int startingRow, int endingRow, int count) {\n-    \tshiftBreaks(rowBreaks, (short)startingRow, (short)endingRow, (short)count);\n+        shiftBreaks(rowBreaks, (short)startingRow, (short)endingRow, (short)count);\n     }\n \n     /**\n@@ -2955,39 +2719,39 @@ public void shiftRowBreaks(int startingRow, int endingRow, int count) {\n      * @param count\n      */\n     public void shiftColumnBreaks(short startingCol, short endingCol, short count) {\n-    \tshiftBreaks(colBreaks, startingCol, endingCol, count);\n+        shiftBreaks(colBreaks, startingCol, endingCol, count);\n     }\n-    \n+\n     /**\n      * Returns all the row page breaks\n      * @return all the row page breaks\n      */\n     public Iterator getRowBreaks() {\n-    \treturn rowBreaks.getBreaksIterator();\n+        return rowBreaks.getBreaksIterator();\n     }\n-    \n+\n     /**\n      * Returns the number of row page breaks\n      * @return the number of row page breaks\n      */\n     public int getNumRowBreaks(){\n-    \treturn (rowBreaks == null) ? 0 : (int)rowBreaks.getNumBreaks();\n+        return (rowBreaks == null) ? 0 : (int)rowBreaks.getNumBreaks();\n     }\n-    \n+\n     /**\n      * Returns all the column page breaks\n      * @return all the column page breaks\n      */\n     public Iterator getColumnBreaks(){\n-    \treturn colBreaks.getBreaksIterator();\n+        return colBreaks.getBreaksIterator();\n     }\n-    \n+\n     /**\n      * Returns the number of column page breaks\n      * @return the number of column page breaks\n      */\n     public int getNumColumnBreaks(){\n-    \treturn (colBreaks == null) ? 0 : (int)colBreaks.getNumBreaks();\n+        return (colBreaks == null) ? 0 : (int)colBreaks.getNumBreaks();\n     }\n \n     public void setColumnGroupCollapsed( short columnNumber, boolean collapsed )\n@@ -3030,213 +2794,40 @@ public void protectSheet( String password, boolean objects, boolean scenarios )\n             records.add(protIdx+2,srec);\n             scenprotect = srec;\n         }\n-    }    \n+    }\n \n     /**\n-     * unprotect objects in the sheet (will not protect them, but any set to false are \n+     * unprotect objects in the sheet (will not protect them, but any set to false are\n      * unprotected.\n      * @param sheet is unprotected (false = unprotect)\n      * @param objects are unprotected (false = unprotect)\n      * @param scenarios are unprotected (false = unprotect)\n      */\n     public void unprotectSheet( boolean sheet, boolean objects, boolean scenarios ) {\n-        int protIdx = -1;\n+\n         if (!sheet) {\n            ProtectRecord prec = getProtect();\n            prec.setProtect(sheet);\n            PasswordRecord pass = getPassword();\n            pass.setPassword((short)00);\n-        } \n+        }\n         if(objprotect != null && !objects) {\n             objprotect.setProtect(false);\n         }\n         if(scenprotect != null && !scenarios) {\n             scenprotect.setProtect(false);\n         }\n-    }    \n+    }\n \n     /**\n      * @return {sheet is protected, objects are proteced, scenarios are protected}\n      */\n     public boolean[] isProtected() {\n-        return new boolean[] { (protect != null && protect.getProtect()), \n+        return new boolean[] { (protect != null && protect.getProtect()),\n                              (objprotect != null && objprotect.getProtect()),\n                              (scenprotect != null && scenprotect.getProtect())};\n     }\n- \n-//    private void collapseColumn( short columnNumber )\n-//    {\n-//        int idx = findColumnIdx( columnNumber, 0 );\n-//        if (idx == -1)\n-//            return;\n-//\n-//        // Find the start of the group.\n-//        ColumnInfoRecord columnInfo = (ColumnInfoRecord) columnSizes.get( findStartOfColumnOutlineGroup( idx ) );\n-//\n-//        // Hide all the columns until the end of the group\n-//        columnInfo = writeHidden( columnInfo, idx, true );\n-//\n-//        // Write collapse field\n-//        setColumn( (short) ( columnInfo.getLastColumn() + 1 ), null, null, null, Boolean.TRUE);\n-//    }\n-\n-//    private void expandColumn( short columnNumber )\n-//    {\n-//        int idx = findColumnIdx( columnNumber, 0 );\n-//        if (idx == -1)\n-//            return;\n-//\n-//        // If it is already exapanded do nothing.\n-//        if (!isColumnGroupCollapsed(idx))\n-//            return;\n-//\n-//        // Find the start of the group.\n-//        int startIdx = findStartOfColumnOutlineGroup( idx );\n-//        ColumnInfoRecord columnInfo = getColInfo( startIdx );\n-//\n-//        // Find the end of the group.\n-//        int endIdx = findEndOfColumnOutlineGroup( idx );\n-//        ColumnInfoRecord endColumnInfo = getColInfo( endIdx );\n-//\n-//        // expand:\n-//        // colapsed bit must be unset\n-//        // hidden bit gets unset _if_ surrounding groups are expanded you can determine\n-//        //   this by looking at the hidden bit of the enclosing group.  You will have\n-//        //   to look at the start and the end of the current group to determine which\n-//        //   is the enclosing group\n-//        // hidden bit only is altered for this outline level.  ie.  don't uncollapse contained groups\n-//        if (!isColumnGroupHiddenByParent( idx ))\n-//        {\n-//            for (int i = startIdx; i <= endIdx; i++)\n-//            {\n-//                if (columnInfo.getOutlineLevel() == getColInfo(i).getOutlineLevel())\n-//                    getColInfo(i).setHidden( false );\n-//            }\n-//        }\n-//\n-//        // Write collapse field\n-//        setColumn( (short) ( columnInfo.getLastColumn() + 1 ), null, null, null, Boolean.FALSE);\n-//    }\n-\n-//    private boolean isColumnGroupCollapsed( int idx )\n-//    {\n-//        int endOfOutlineGroupIdx = findEndOfColumnOutlineGroup( idx );\n-//        if (endOfOutlineGroupIdx >= columnSizes.size())\n-//            return false;\n-//        if (getColInfo(endOfOutlineGroupIdx).getLastColumn() + 1 != getColInfo(endOfOutlineGroupIdx + 1).getFirstColumn())\n-//            return false;\n-//        else\n-//            return getColInfo(endOfOutlineGroupIdx+1).getCollapsed();\n-//    }\n-\n-//    private boolean isColumnGroupHiddenByParent( int idx )\n-//    {\n-//        // Look out outline details of end\n-//        int endLevel;\n-//        boolean endHidden;\n-//        int endOfOutlineGroupIdx = findEndOfColumnOutlineGroup( idx );\n-//        if (endOfOutlineGroupIdx >= columnSizes.size())\n-//        {\n-//            endLevel = 0;\n-//            endHidden = false;\n-//        }\n-//        else if (getColInfo(endOfOutlineGroupIdx).getLastColumn() + 1 != getColInfo(endOfOutlineGroupIdx + 1).getFirstColumn())\n-//        {\n-//            endLevel = 0;\n-//            endHidden = false;\n-//        }\n-//        else\n-//        {\n-//            endLevel = getColInfo( endOfOutlineGroupIdx + 1).getOutlineLevel();\n-//            endHidden = getColInfo( endOfOutlineGroupIdx + 1).getHidden();\n-//        }\n-//\n-//        // Look out outline details of start\n-//        int startLevel;\n-//        boolean startHidden;\n-//        int startOfOutlineGroupIdx = findStartOfColumnOutlineGroup( idx );\n-//        if (startOfOutlineGroupIdx <= 0)\n-//        {\n-//            startLevel = 0;\n-//            startHidden = false;\n-//        }\n-//        else if (getColInfo(startOfOutlineGroupIdx).getFirstColumn() - 1 != getColInfo(startOfOutlineGroupIdx - 1).getLastColumn())\n-//        {\n-//            startLevel = 0;\n-//            startHidden = false;\n-//        }\n-//        else\n-//        {\n-//            startLevel = getColInfo( startOfOutlineGroupIdx - 1).getOutlineLevel();\n-//            startHidden = getColInfo( startOfOutlineGroupIdx - 1 ).getHidden();\n-//        }\n-//\n-//        if (endLevel > startLevel)\n-//        {\n-//            return endHidden;\n-//        }\n-//        else\n-//        {\n-//            return startHidden;\n-//        }\n-//    }\n-\n-//    private ColumnInfoRecord getColInfo(int idx)\n-//    {\n-//        return columns.getColInfo( idx );\n-//    }\n-\n-//    private int findStartOfColumnOutlineGroup(int idx)\n-//    {\n-//        // Find the start of the group.\n-//        ColumnInfoRecord columnInfo = (ColumnInfoRecord) columnSizes.get( idx );\n-//        int level = columnInfo.getOutlineLevel();\n-//        while (idx != 0)\n-//        {\n-//            ColumnInfoRecord prevColumnInfo = (ColumnInfoRecord) columnSizes.get( idx - 1 );\n-//            if (columnInfo.getFirstColumn() - 1 == prevColumnInfo.getLastColumn())\n-//            {\n-//                if (prevColumnInfo.getOutlineLevel() < level)\n-//                {\n-//                    break;\n-//                }\n-//                idx--;\n-//                columnInfo = prevColumnInfo;\n-//            }\n-//            else\n-//            {\n-//                break;\n-//            }\n-//        }\n-//\n-//        return idx;\n-//    }\n-\n-//    private int findEndOfColumnOutlineGroup(int idx)\n-//    {\n-//        // Find the end of the group.\n-//        ColumnInfoRecord columnInfo = (ColumnInfoRecord) columnSizes.get( idx );\n-//        int level = columnInfo.getOutlineLevel();\n-//        while (idx < columnSizes.size() - 1)\n-//        {\n-//            ColumnInfoRecord nextColumnInfo = (ColumnInfoRecord) columnSizes.get( idx + 1 );\n-//            if (columnInfo.getLastColumn() + 1 == nextColumnInfo.getFirstColumn())\n-//            {\n-//                if (nextColumnInfo.getOutlineLevel() < level)\n-//                {\n-//                    break;\n-//                }\n-//                idx++;\n-//                columnInfo = nextColumnInfo;\n-//            }\n-//            else\n-//            {\n-//                break;\n-//            }\n-//        }\n-//\n-//        return idx;\n-//    }\n+\n \n     public void groupRowRange(int fromRow, int toRow, boolean indent)\n     {\n@@ -3272,8 +2863,8 @@ private void recalcRowGutter()\n         // Grab the guts record, adding if needed\n         GutsRecord guts = (GutsRecord) findFirstRecordBySid( GutsRecord.sid );\n         if(guts == null) {\n-        \tguts = new GutsRecord();\n-        \trecords.add(guts);\n+            guts = new GutsRecord();\n+            records.add(guts);\n         }\n         // Set the levels onto it\n         guts.setRowLevelMax( (short) ( maxLevel + 1 ) );\n@@ -3291,126 +2882,4 @@ public void setRowGroupCollapsed( int row, boolean collapse )\n             rows.expandRow( row );\n         }\n     }\n-\n-\n-//    private void collapseRow( int rowNumber )\n-//    {\n-//\n-//        // Find the start of the group.\n-//        int startRow = rows.findStartOfRowOutlineGroup( rowNumber );\n-//        RowRecord rowRecord = (RowRecord) rows.getRow( startRow );\n-//\n-//        // Hide all the columns until the end of the group\n-//        int lastRow = rows.writeHidden( rowRecord, startRow, true );\n-//\n-//        // Write collapse field\n-//        if (getRow(lastRow + 1) != null)\n-//        {\n-//            getRow(lastRow + 1).setColapsed( true );\n-//        }\n-//        else\n-//        {\n-//            RowRecord row = createRow( lastRow + 1);\n-//            row.setColapsed( true );\n-//            rows.insertRow( row );\n-//        }\n-//    }\n-\n-//    private int findStartOfRowOutlineGroup(int row)\n-//    {\n-//        // Find the start of the group.\n-//        RowRecord rowRecord = rows.getRow( row );\n-//        int level = rowRecord.getOutlineLevel();\n-//        int currentRow = row;\n-//        while (rows.getRow( currentRow ) != null)\n-//        {\n-//            rowRecord = rows.getRow( currentRow );\n-//            if (rowRecord.getOutlineLevel() < level)\n-//                return currentRow + 1;\n-//            currentRow--;\n-//        }\n-//\n-//        return currentRow + 1;\n-//    }\n-\n-//    private int writeHidden( RowRecord rowRecord, int row, boolean hidden )\n-//    {\n-//        int level = rowRecord.getOutlineLevel();\n-//        while (rowRecord != null && rows.getRow(row).getOutlineLevel() >= level)\n-//        {\n-//            rowRecord.setZeroHeight( hidden );\n-//            row++;\n-//            rowRecord = rows.getRow( row );\n-//        }\n-//        return row - 1;\n-//    }\n-\n-//    private int findEndOfRowOutlineGroup( int row )\n-//    {\n-//        int level = getRow( row ).getOutlineLevel();\n-//        int currentRow;\n-//        for (currentRow = row; currentRow < rows.getLastRowNum(); currentRow++)\n-//        {\n-//            if (getRow(currentRow) == null || getRow(currentRow).getOutlineLevel() < level)\n-//            {\n-//                break;\n-//            }\n-//        }\n-//\n-//        return currentRow-1;\n-//    }\n-\n-//    private boolean isRowGroupCollapsed( int row )\n-//    {\n-//        int collapseRow = rows.findEndOfRowOutlineGroup( row ) + 1;\n-//\n-//        if (getRow(collapseRow) == null)\n-//            return false;\n-//        else\n-//            return getRow( collapseRow ).getColapsed();\n-//    }\n-\n-\n-//    private boolean isRowGroupHiddenByParent( int row )\n-//    {\n-//        // Look out outline details of end\n-//        int endLevel;\n-//        boolean endHidden;\n-//        int endOfOutlineGroupIdx = rows.findEndOfRowOutlineGroup( row );\n-//        if (getRow( endOfOutlineGroupIdx + 1 ) == null)\n-//        {\n-//            endLevel = 0;\n-//            endHidden = false;\n-//        }\n-//        else\n-//        {\n-//            endLevel = getRow( endOfOutlineGroupIdx + 1).getOutlineLevel();\n-//            endHidden = getRow( endOfOutlineGroupIdx + 1).getZeroHeight();\n-//        }\n-//\n-//        // Look out outline details of start\n-//        int startLevel;\n-//        boolean startHidden;\n-//        int startOfOutlineGroupIdx = rows.findStartOfRowOutlineGroup( row );\n-//        if (startOfOutlineGroupIdx - 1 < 0 || getRow(startOfOutlineGroupIdx - 1) == null)\n-//        {\n-//            startLevel = 0;\n-//            startHidden = false;\n-//        }\n-//        else\n-//        {\n-//            startLevel = getRow( startOfOutlineGroupIdx - 1).getOutlineLevel();\n-//            startHidden = getRow( startOfOutlineGroupIdx - 1 ).getZeroHeight();\n-//        }\n-//\n-//        if (endLevel > startLevel)\n-//        {\n-//            return endHidden;\n-//        }\n-//        else\n-//        {\n-//            return startHidden;\n-//        }\n-//    }\n-\n }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/model/Sheet.java",
                "sha": "45090e85cf161bcd22ed837434e0a7a74b1710e4",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/PaneRecord.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/PaneRecord.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 17,
                "filename": "src/java/org/apache/poi/hssf/record/PaneRecord.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -15,13 +14,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.hssf.record;\n \n \n-\n-import org.apache.poi.util.*;\n+import org.apache.poi.util.HexDump;\n+import org.apache.poi.util.LittleEndian;\n \n /**\n  * Describes the frozen and unfozen panes.\n@@ -30,9 +28,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n-public class PaneRecord\n-    extends Record\n-{\n+public final class PaneRecord extends Record {\n     public final static short      sid                             = 0x41;\n     private  short      field_1_x;\n     private  short      field_2_y;\n@@ -42,7 +38,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     public final static short       ACTIVE_PANE_LOWER_RIGHT        = 0;\n     public final static short       ACTIVE_PANE_UPPER_RIGHT        = 1;\n     public final static short       ACTIVE_PANE_LOWER_LEFT         = 2;\n+    // TODO - remove obsolete field (it was deprecated May-2008 v3.1)\n+    /** @deprecated use ACTIVE_PANE_UPPER_LEFT */\n     public final static short       ACTIVE_PANE_UPER_LEFT          = 3;\n+    public final static short       ACTIVE_PANE_UPPER_LEFT         = 3;\n \n \n     public PaneRecord()\n@@ -82,7 +81,6 @@ protected void fillFields(RecordInputStream in)\n         field_3_topRow                 = in.readShort();\n         field_4_leftColumn             = in.readShort();\n         field_5_activePane             = in.readShort();\n-\n     }\n \n     public String toString()\n@@ -229,7 +227,7 @@ public void setLeftColumn(short field_4_leftColumn)\n      *        ACTIVE_PANE_LOWER_RIGHT\n      *        ACTIVE_PANE_UPPER_RIGHT\n      *        ACTIVE_PANE_LOWER_LEFT\n-     *        ACTIVE_PANE_UPER_LEFT\n+     *        ACTIVE_PANE_UPPER_LEFT\n      */\n     public short getActivePane()\n     {\n@@ -244,16 +242,10 @@ public short getActivePane()\n      *        ACTIVE_PANE_LOWER_RIGHT\n      *        ACTIVE_PANE_UPPER_RIGHT\n      *        ACTIVE_PANE_LOWER_LEFT\n-     *        ACTIVE_PANE_UPER_LEFT\n+     *        ACTIVE_PANE_UPPER_LEFT\n      */\n     public void setActivePane(short field_5_activePane)\n     {\n         this.field_5_activePane = field_5_activePane;\n     }\n-\n-\n-}  // END OF CLASS\n-\n-\n-\n-\n+}",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/PaneRecord.java",
                "sha": "f02e4116555bf9253c9e769f47b51d2c09e1da05",
                "status": "modified"
            },
            {
                "additions": 31,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/RowRecord.java",
                "changes": 65,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/RowRecord.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 34,
                "filename": "src/java/org/apache/poi/hssf/record/RowRecord.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -15,7 +14,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.hssf.record;\n \n@@ -31,28 +29,27 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author Jason Height (jheight at chariot dot net dot au)\n  * @version 2.0-pre\n  */\n-\n-public class RowRecord\n-    extends Record\n-    implements Comparable\n-{\n-    public final static short sid = 0x208;\n+public final class RowRecord extends Record implements Comparable {\n+\tpublic final static short sid = 0x208;\n     \n-    /** The maximum row number that excel can handle (zero bazed) ie 65536 rows is\n+    private static final int OPTION_BITS_ALWAYS_SET = 0x0100;\n+    private static final int DEFAULT_HEIGHT_BIT = 0x8000;\n+\n+    /** The maximum row number that excel can handle (zero based) ie 65536 rows is\n      *  max number of rows.\n      */\n     public final static int MAX_ROW_NUMBER = 65535;\n     \n-    //private short             field_1_row_number;\n-    private int             field_1_row_number;\n+    private int               field_1_row_number;\n     private short             field_2_first_col;\n     private short             field_3_last_col;   // plus 1\n     private short             field_4_height;\n     private short             field_5_optimize;   // hint field for gui, can/should be set to zero\n \n     // for generated sheets.\n     private short             field_6_reserved;\n-    private short             field_7_option_flags;\n+    /** 16 bit options flags */\n+    private int             field_7_option_flags;\n     private static final BitField          outlineLevel  = BitFieldFactory.getInstance(0x07);\n \n     // bit 3 reserved\n@@ -62,8 +59,17 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private static final BitField          formatted     = BitFieldFactory.getInstance(0x80);\n     private short             field_8_xf_index;   // only if isFormatted\n \n-    public RowRecord()\n-    {\n+    public RowRecord(int rowNumber) {\n+        field_1_row_number = rowNumber;\n+        field_2_first_col = -1;\n+        field_3_last_col = -1;\n+        field_4_height = (short)DEFAULT_HEIGHT_BIT;\n+        field_4_height = (short)DEFAULT_HEIGHT_BIT;\n+        field_5_optimize = ( short ) 0;\n+        field_6_reserved = ( short ) 0;\n+        field_7_option_flags = OPTION_BITS_ALWAYS_SET; // seems necessary for outlining\n+\n+        field_8_xf_index = ( short ) 0xf;\n     }\n \n     /**\n@@ -86,7 +92,6 @@ protected void validateSid(short id)\n \n     protected void fillFields(RecordInputStream in)\n     {\n-        //field_1_row_number   = LittleEndian.getShort(data, 0 + offset);\n         field_1_row_number   = in.readUShort();\n         field_2_first_col    = in.readShort();\n         field_3_last_col     = in.readShort();\n@@ -156,7 +161,7 @@ public void setOptimize(short optimize)\n \n     public void setOptionFlags(short options)\n     {\n-        field_7_option_flags = options;\n+        field_7_option_flags = options | OPTION_BITS_ALWAYS_SET;\n     }\n \n     // option bitfields\n@@ -169,20 +174,18 @@ public void setOptionFlags(short options)\n \n     public void setOutlineLevel(short ol)\n     {\n-        field_7_option_flags =\n-            outlineLevel.setShortValue(field_7_option_flags, ol);\n+        field_7_option_flags = outlineLevel.setValue(field_7_option_flags, ol);\n     }\n \n     /**\n-     * set whether or not to colapse this row\n-     * @param c - colapse or not\n+     * set whether or not to collapse this row\n+     * @param c - collapse or not\n      * @see #setOptionFlags(short)\n      */\n \n     public void setColapsed(boolean c)\n     {\n-        field_7_option_flags = colapsed.setShortBoolean(field_7_option_flags,\n-                c);\n+        field_7_option_flags = colapsed.setBoolean(field_7_option_flags, c);\n     }\n \n     /**\n@@ -193,8 +196,7 @@ public void setColapsed(boolean c)\n \n     public void setZeroHeight(boolean z)\n     {\n-        field_7_option_flags =\n-            zeroHeight.setShortBoolean(field_7_option_flags, z);\n+        field_7_option_flags = zeroHeight.setBoolean(field_7_option_flags, z);\n     }\n \n     /**\n@@ -205,8 +207,7 @@ public void setZeroHeight(boolean z)\n \n     public void setBadFontHeight(boolean f)\n     {\n-        field_7_option_flags =\n-            badFontHeight.setShortBoolean(field_7_option_flags, f);\n+        field_7_option_flags = badFontHeight.setBoolean(field_7_option_flags, f);\n     }\n \n     /**\n@@ -217,8 +218,7 @@ public void setBadFontHeight(boolean f)\n \n     public void setFormatted(boolean f)\n     {\n-        field_7_option_flags = formatted.setShortBoolean(field_7_option_flags,\n-                f);\n+        field_7_option_flags = formatted.setBoolean(field_7_option_flags, f);\n     }\n \n     // end bitfields\n@@ -293,7 +293,7 @@ public short getOptimize()\n \n     public short getOptionFlags()\n     {\n-        return field_7_option_flags;\n+        return (short)field_7_option_flags;\n     }\n \n     // option bitfields\n@@ -306,7 +306,7 @@ public short getOptionFlags()\n \n     public short getOutlineLevel()\n     {\n-        return outlineLevel.getShortValue(field_7_option_flags);\n+        return (short)outlineLevel.getValue(field_7_option_flags);\n     }\n \n     /**\n@@ -410,7 +410,6 @@ public int serialize(int offset, byte [] data)\n     {\n         LittleEndian.putShort(data, 0 + offset, sid);\n         LittleEndian.putShort(data, 2 + offset, ( short ) 16);\n-        //LittleEndian.putShort(data, 4 + offset, getRowNumber());\n         LittleEndian.putShort(data, 4 + offset, ( short ) getRowNumber());\n         LittleEndian.putShort(data, 6 + offset, getFirstCol() == -1 ? (short)0 : getFirstCol());\n         LittleEndian.putShort(data, 8 + offset, getLastCol() == -1 ? (short)0 : getLastCol());\n@@ -419,7 +418,6 @@ public int serialize(int offset, byte [] data)\n         LittleEndian.putShort(data, 14 + offset, field_6_reserved);\n         LittleEndian.putShort(data, 16 + offset, getOptionFlags());\n \n-//    LittleEndian.putShort(data,18,getOutlineLevel());\n         LittleEndian.putShort(data, 18 + offset, getXFIndex());\n         return getRecordSize();\n     }\n@@ -469,8 +467,7 @@ public boolean equals(Object obj)\n     }\n \n     public Object clone() {\n-      RowRecord rec = new RowRecord();\n-      rec.field_1_row_number = field_1_row_number;\n+      RowRecord rec = new RowRecord(field_1_row_number);\n       rec.field_2_first_col = field_2_first_col;\n       rec.field_3_last_col = field_3_last_col;\n       rec.field_4_height = field_4_height;",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/RowRecord.java",
                "sha": "cbfc0ec59423d716caf30574781efc40d7656a21",
                "status": "modified"
            },
            {
                "additions": 48,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/WindowOneRecord.java",
                "changes": 75,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/WindowOneRecord.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 27,
                "filename": "src/java/org/apache/poi/hssf/record/WindowOneRecord.java",
                "patch": "@@ -57,8 +57,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n         BitFieldFactory.getInstance(0x20);                                        // display tabs at the bottom\n \n     // all the rest are \"reserved\"\n-    private short                 field_6_selected_tab;\n-    private short                 field_7_displayed_tab;\n+    private int                   field_6_active_sheet;\n+    private int                   field_7_first_visible_tab;\n     private short                 field_8_num_selected_tabs;\n     private short                 field_9_tab_width_ratio;\n \n@@ -91,8 +91,8 @@ protected void fillFields(RecordInputStream in)\n         field_3_width             = in.readShort();\n         field_4_height            = in.readShort();\n         field_5_options           = in.readShort();\n-        field_6_selected_tab      = in.readShort();\n-        field_7_displayed_tab     = in.readShort();\n+        field_6_active_sheet      = in.readShort();\n+        field_7_first_visible_tab     = in.readShort();\n         field_8_num_selected_tabs = in.readShort();\n         field_9_tab_width_ratio   = in.readShort();\n     }\n@@ -202,24 +202,33 @@ public void setDisplayTabs(boolean disptabs)\n \n     // end bitfields\n \n+    public void setActiveSheetIndex(int index) {\n+    \tfield_6_active_sheet = index;\n+\t}\n     /**\n-     * set the selected tab number\n-     * @param s  tab number\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use setActiveSheetIndex() \n      */\n-\n     public void setSelectedTab(short s)\n     {\n-        field_6_selected_tab = s;\n+        setActiveSheetIndex(s);\n     }\n \n     /**\n-     * set the displayed tab number\n-     * @param t  tab number\n+     * Sets the first visible sheet in the worksheet tab-bar.  This method does <b>not</b>\n+     *  hide, select or focus sheets.  It just sets the scroll position in the tab-bar.\n+     * @param t the sheet index of the tab that will become the first in the tab-bar\n      */\n+    public void setFirstVisibleTab(int t) {\n+        field_7_first_visible_tab = t;\n+    }\n \n-    public void setDisplayedTab(short t)\n-    {\n-        field_7_displayed_tab = t;\n+    /**\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use setFirstVisibleTab() \n+     */\n+    public void setDisplayedTab(short t) {\n+        setFirstVisibleTab(t);\n     }\n \n     /**\n@@ -347,24 +356,36 @@ public boolean getDisplayTabs()\n \n     // end options bitfields\n \n+    \n     /**\n-     * get the selected tab number\n-     * @return Tab number\n+     * @return the index of the currently displayed sheet \n+     */\n+    public int getActiveSheetIndex() {\n+    \treturn field_6_active_sheet;\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use getActiveSheetIndex() \n      */\n-\n     public short getSelectedTab()\n     {\n-        return field_6_selected_tab;\n+        return (short) getActiveSheetIndex();\n     }\n \n     /**\n-     * get the displayed tab number\n-     * @return Tab number\n+     * @return the first visible sheet in the worksheet tab-bar. \n+     * I.E. the scroll position of the tab-bar.\n+     */\n+    public int getFirstVisibleTab() {\n+        return field_7_first_visible_tab;\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use getFirstVisibleTab() \n      */\n-\n     public short getDisplayedTab()\n     {\n-        return field_7_displayed_tab;\n+        return (short) getFirstVisibleTab();\n     }\n \n     /**\n@@ -412,10 +433,10 @@ public String toString()\n             .append(getDisplayVerticalScrollbar()).append(\"\\n\");\n         buffer.append(\"        .tabs        = \").append(getDisplayTabs())\n             .append(\"\\n\");\n-        buffer.append(\"    .selectedtab     = \")\n-            .append(Integer.toHexString(getSelectedTab())).append(\"\\n\");\n-        buffer.append(\"    .displayedtab    = \")\n-            .append(Integer.toHexString(getDisplayedTab())).append(\"\\n\");\n+        buffer.append(\"    .activeSheet     = \")\n+            .append(Integer.toHexString(getActiveSheetIndex())).append(\"\\n\");\n+        buffer.append(\"    .firstVisibleTab    = \")\n+            .append(Integer.toHexString(getFirstVisibleTab())).append(\"\\n\");\n         buffer.append(\"    .numselectedtabs = \")\n             .append(Integer.toHexString(getNumSelectedTabs())).append(\"\\n\");\n         buffer.append(\"    .tabwidthratio   = \")\n@@ -434,8 +455,8 @@ public int serialize(int offset, byte [] data)\n         LittleEndian.putShort(data, 8 + offset, getWidth());\n         LittleEndian.putShort(data, 10 + offset, getHeight());\n         LittleEndian.putShort(data, 12 + offset, getOptions());\n-        LittleEndian.putShort(data, 14 + offset, getSelectedTab());\n-        LittleEndian.putShort(data, 16 + offset, getDisplayedTab());\n+        LittleEndian.putUShort(data, 14 + offset, getActiveSheetIndex());\n+        LittleEndian.putUShort(data, 16 + offset, getFirstVisibleTab());\n         LittleEndian.putShort(data, 18 + offset, getNumSelectedTabs());\n         LittleEndian.putShort(data, 20 + offset, getTabWidthRatio());\n         return getRecordSize();",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/WindowOneRecord.java",
                "sha": "4c836f2ee83e731d15ba44c6b2d1780cc3826fbb",
                "status": "modified"
            },
            {
                "additions": 20,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/WindowTwoRecord.java",
                "changes": 30,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/WindowTwoRecord.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 10,
                "filename": "src/java/org/apache/poi/hssf/record/WindowTwoRecord.java",
                "patch": "@@ -54,7 +54,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private BitField          displayGuts             = BitFieldFactory.getInstance(0x80);\n     private BitField          freezePanesNoSplit      = BitFieldFactory.getInstance(0x100);\n     private BitField          selected                = BitFieldFactory.getInstance(0x200);\n-    private BitField          paged                   = BitFieldFactory.getInstance(0x400);\n+    private BitField          active                  = BitFieldFactory.getInstance(0x400);\n     private BitField          savedInPageBreakPreview = BitFieldFactory.getInstance(0x800);\n \n     // 4-7 reserved\n@@ -222,12 +222,16 @@ public void setSelected(boolean sel)\n      * is the sheet currently displayed in the window\n      * @param p  displayed or not\n      */\n-\n-    public void setPaged(boolean p)\n-    {\n-        field_1_options = paged.setShortBoolean(field_1_options, p);\n+    public void setActive(boolean p) {\n+        field_1_options = active.setShortBoolean(field_1_options, p);\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated use setActive()\n+     */\n+    public void setPaged(boolean p) {\n+    \tsetActive(p);\n     }\n-\n     /**\n      * was the sheet saved in page break view\n      * @param p  pagebreaksaved or not\n@@ -416,9 +420,15 @@ public boolean getSelected()\n      * @return displayed or not\n      */\n \n-    public boolean getPaged()\n-    {\n-        return paged.isSet(field_1_options);\n+    public boolean isActive() {\n+        return active.isSet(field_1_options);\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated use isActive()\n+     */\n+    public boolean getPaged() {\n+        return isActive();\n     }\n \n     /**\n@@ -520,7 +530,7 @@ public String toString()\n             .append(getFreezePanesNoSplit()).append(\"\\n\");\n         buffer.append(\"       .selected    = \").append(getSelected())\n             .append(\"\\n\");\n-        buffer.append(\"       .paged       = \").append(getPaged())\n+        buffer.append(\"       .active       = \").append(isActive())\n             .append(\"\\n\");\n         buffer.append(\"       .svdinpgbrkpv= \")\n             .append(getSavedInPageBreakPreview()).append(\"\\n\");",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/WindowTwoRecord.java",
                "sha": "e2bb6d5609d618f20911e576333dc251faa9bc0c",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "changes": 47,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 30,
                "filename": "src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "patch": "@@ -35,19 +35,17 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @author Jason Height (jheight at chariot dot net dot au)\n  */\n \n-public class RowRecordsAggregate\n-    extends Record\n-{\n-    int     firstrow = -1;\n-    int     lastrow  = -1;\n-    Map records  = null;\n-    int     size     = 0;\n+public final class RowRecordsAggregate extends Record {\n+    private int     firstrow = -1;\n+    private int     lastrow  = -1;\n+    private Map records  = null; // TODO - use a proper key in this map\n+    private int     size     = 0;\n \n     /** Creates a new instance of ValueRecordsAggregate */\n \n     public RowRecordsAggregate()\n     {\n-        records = new TreeMap();\n+        records = new TreeMap();  \n     }\n \n     public void insertRow(RowRecord row)\n@@ -74,15 +72,13 @@ public void removeRow(RowRecord row)\n         records.remove(row);\n     }\n \n-    public RowRecord getRow(int rownum)\n-    {\n-\t\t// Row must be between 0 and 65535\n-\t\tif(rownum < 0 || rownum > 65535) {\n-\t\t\tthrow new IllegalArgumentException(\"The row number must be between 0 and 65535\");\n-\t\t}\n+    public RowRecord getRow(int rownum) {\n+        // Row must be between 0 and 65535\n+        if(rownum < 0 || rownum > 65535) {\n+            throw new IllegalArgumentException(\"The row number must be between 0 and 65535\");\n+        }\n \n-        RowRecord row = new RowRecord();\n-        row.setRowNumber(rownum);\n+        RowRecord row = new RowRecord(rownum);\n         return ( RowRecord ) records.get(row);\n     }\n \n@@ -333,7 +329,7 @@ public void collapseRow( int rowNumber )\n \n         // Find the start of the group.\n         int startRow = findStartOfRowOutlineGroup( rowNumber );\n-        RowRecord rowRecord = (RowRecord) getRow( startRow );\n+        RowRecord rowRecord = getRow( startRow );\n \n         // Hide all the columns until the end of the group\n         int lastRow = writeHidden( rowRecord, startRow, true );\n@@ -358,17 +354,8 @@ public void collapseRow( int rowNumber )\n      * @return RowRecord created for the passed in row number\n      * @see org.apache.poi.hssf.record.RowRecord\n      */\n-    public static RowRecord createRow(int row)\n-    {\n-        RowRecord rowrec = new RowRecord();\n-\n-        //rowrec.setRowNumber(( short ) row);\n-        rowrec.setRowNumber(row);\n-        rowrec.setHeight(( short ) 0xff);\n-        rowrec.setOptimize(( short ) 0x0);\n-        rowrec.setOptionFlags(( short ) 0x100);  // seems necessary for outlining\n-        rowrec.setXFIndex(( short ) 0xf);\n-        return rowrec;\n+    public static RowRecord createRow(int rowNumber) {\n+        return new RowRecord(rowNumber);\n     }\n \n     public boolean isRowGroupCollapsed( int row )\n@@ -399,12 +386,12 @@ public void expandRow( int rowNumber )\n         int endIdx = findEndOfRowOutlineGroup( idx );\n \n         // expand:\n-        // colapsed bit must be unset\n+        // collapsed bit must be unset\n         // hidden bit gets unset _if_ surrounding groups are expanded you can determine\n         //   this by looking at the hidden bit of the enclosing group.  You will have\n         //   to look at the start and the end of the current group to determine which\n         //   is the enclosing group\n-        // hidden bit only is altered for this outline level.  ie.  don't uncollapse contained groups\n+        // hidden bit only is altered for this outline level.  ie.  don't un-collapse contained groups\n         if ( !isRowGroupHiddenByParent( idx ) )\n         {\n             for ( int i = startIdx; i <= endIdx; i++ )",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java",
                "sha": "65af632d3fbea30a8e1df7f96fa87e54662d214a",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/FuncPtg.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/FuncPtg.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 17,
                "filename": "src/java/org/apache/poi/hssf/record/formula/FuncPtg.java",
                "patch": "@@ -32,18 +32,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     public final static int  SIZE = 3;\n     private int numParams=0;\n \n-    /**\n-     * FuncPtgs are defined to be 4 bytes but the actual FuncPtg uses only 2 bytes.\n-     * If we have leftOvers that are read from the file we should serialize them back out.\n-     * <p>\n-     * If the leftovers are removed, a prompt \"Warning: Data may have been lost occurs in Excel\"\n-     */\n-\t//protected byte[] leftOvers = null;\n-\n-    private FuncPtg() {\n-      //Required for clone methods\n-    }\n-\n     /**Creates new function pointer from a byte array\n      * usually called while reading an excel file.\n      */\n@@ -75,11 +63,9 @@ public int getNumberOfOperands() {\n     }\n \n     public Object clone() {\n-      FuncPtg ptg = new FuncPtg();\n-      //ptg.field_1_num_args = field_1_num_args;\n-      ptg.field_2_fnc_index = field_2_fnc_index;\n-      ptg.setClass(ptgClass);\n-     return ptg;\n+        FuncPtg ptg = new FuncPtg(field_2_fnc_index);\n+        ptg.setClass(ptgClass);\n+        return ptg;\n     }\n \n     public int getSize() {",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/FuncPtg.java",
                "sha": "364ddf5a02bb46abb9030559394ccba816e2e47e",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/eval/Area2DEval.java",
                "changes": 80,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/eval/Area2DEval.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 74,
                "filename": "src/java/org/apache/poi/hssf/record/formula/eval/Area2DEval.java",
                "patch": "@@ -22,79 +22,11 @@\n \n /**\n  * @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;\n- *   \n+ * \n  */\n-public final class Area2DEval implements AreaEval {\n-// TODO -refactor with Area3DEval\n-    private final AreaPtg _delegate;\n+public final class Area2DEval extends AreaEvalBase {\n \n-    private final ValueEval[] _values;\n-\n-    public Area2DEval(Ptg ptg, ValueEval[] values) {\n-        if(ptg == null) {\n-            throw new IllegalArgumentException(\"ptg must not be null\");\n-        }\n-        if(values == null) {\n-            throw new IllegalArgumentException(\"values must not be null\");\n-        }\n-        for(int i=values.length-1; i>=0; i--) {\n-            if(values[i] == null) {\n-                throw new IllegalArgumentException(\"value array elements must not be null\");\n-            }\n-        }\n-        // TODO - check size of array vs size of AreaPtg\n-        _delegate = (AreaPtg) ptg;\n-        _values = values;\n-    }\n-\n-    public int getFirstColumn() {\n-        return _delegate.getFirstColumn();\n-    }\n-\n-    public int getFirstRow() {\n-        return _delegate.getFirstRow();\n-    }\n-\n-    public int getLastColumn() {\n-        return _delegate.getLastColumn();\n-    }\n-\n-    public int getLastRow() {\n-        return _delegate.getLastRow();\n-    }\n-\n-    public ValueEval[] getValues() {\n-        return _values;\n-    }\n-    \n-    public ValueEval getValueAt(int row, int col) {\n-        ValueEval retval;\n-        int index = ((row-getFirstRow())*(getLastColumn()-getFirstColumn()+1))+(col-getFirstColumn());\n-        if (index <0 || index >= _values.length)\n-            retval = ErrorEval.VALUE_INVALID;\n-        else \n-            retval = _values[index];\n-        return retval;\n-    }\n-    \n-    public boolean contains(int row, int col) {\n-        return (getFirstRow() <= row) && (getLastRow() >= row) \n-            && (getFirstColumn() <= col) && (getLastColumn() >= col);\n-    }\n-    \n-    public boolean containsRow(int row) {\n-        return (getFirstRow() <= row) && (getLastRow() >= row);\n-    }\n-    \n-    public boolean containsColumn(short col) {\n-        return (getFirstColumn() <= col) && (getLastColumn() >= col);\n-    }\n-    \n-    public boolean isColumn() {\n-        return _delegate.getFirstColumn() == _delegate.getLastColumn();\n-    }\n-\n-    public boolean isRow() {\n-        return _delegate.getFirstRow() == _delegate.getLastRow();\n-    }\n-}\n+\tpublic Area2DEval(Ptg ptg, ValueEval[] values) {\n+\t\tsuper((AreaPtg) ptg, values);\n+\t}\n+}\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/eval/Area2DEval.java",
                "sha": "5ae98b39fed8df1e73173d73bc2c2ae18bb71a29",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/eval/Area3DEval.java",
                "changes": 86,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/eval/Area3DEval.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 76,
                "filename": "src/java/org/apache/poi/hssf/record/formula/eval/Area3DEval.java",
                "patch": "@@ -22,84 +22,18 @@\n \n /**\n  * @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;\n- *  \n+ * \n  */\n-public final class Area3DEval implements AreaEval {\n-\t// TODO -refactor with Area3DEval\n-    private final Area3DPtg _delegate;\n+public final class Area3DEval extends AreaEvalBase {\n \n-    private final ValueEval[] _values;\n+\tprivate final int _externSheetIndex;\n \n-    public Area3DEval(Ptg ptg, ValueEval[] values) {\n-        if(ptg == null) {\n-            throw new IllegalArgumentException(\"ptg must not be null\");\n-        }\n-        if(values == null) {\n-            throw new IllegalArgumentException(\"values must not be null\");\n-        }\n-        for(int i=values.length-1; i>=0; i--) {\n-            if(values[i] == null) {\n-                throw new IllegalArgumentException(\"value array elements must not be null\");\n-            }\n-        }\n-        // TODO - check size of array vs size of AreaPtg\n-        _values = values;\n-        _delegate = (Area3DPtg) ptg;\n-    }\n+\tpublic Area3DEval(Ptg ptg, ValueEval[] values) {\n+\t\tsuper((Area3DPtg) ptg, values);\n+\t\t_externSheetIndex = ((Area3DPtg) ptg).getExternSheetIndex();\n+\t}\n \n-    public int getFirstColumn() {\n-        return _delegate.getFirstColumn();\n-    }\n-\n-    public int getFirstRow() {\n-        return _delegate.getFirstRow();\n-    }\n-\n-    public int getLastColumn() {\n-        return (short) _delegate.getLastColumn();\n-    }\n-\n-    public int getLastRow() {\n-        return _delegate.getLastRow();\n-    }\n-\n-    public ValueEval[] getValues() {\n-        return _values;\n-    }\n-    \n-    public ValueEval getValueAt(int row, int col) {\n-        ValueEval retval;\n-        int index = (row-getFirstRow())*(col-getFirstColumn());\n-        if (index <0 || index >= _values.length)\n-            retval = ErrorEval.VALUE_INVALID;\n-        else \n-            retval = _values[index];\n-        return retval;\n-    }\n-    \n-    public boolean contains(int row, int col) {\n-        return (getFirstRow() <= row) && (getLastRow() >= row) \n-            && (getFirstColumn() <= col) && (getLastColumn() >= col);\n-    }\n-    \n-    public boolean containsRow(int row) {\n-        return (getFirstRow() <= row) && (getLastRow() >= row);\n-    }\n-    \n-    public boolean containsColumn(short col) {\n-        return (getFirstColumn() <= col) && (getLastColumn() >= col);\n-    }\n-    \n-    \n-    public boolean isColumn() {\n-        return _delegate.getFirstColumn() == _delegate.getLastColumn();\n-    }\n-\n-    public boolean isRow() {\n-        return _delegate.getFirstRow() == _delegate.getLastRow();\n-    }\n-\n-    public int getExternSheetIndex() {\n-        return _delegate.getExternSheetIndex();\n-    }\n+\tpublic int getExternSheetIndex() {\n+\t\treturn _externSheetIndex;\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/eval/Area3DEval.java",
                "sha": "89209e21b6ba604cf83d0c613304004544e09fef",
                "status": "modified"
            },
            {
                "additions": 122,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/eval/AreaEvalBase.java",
                "changes": 122,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/eval/AreaEvalBase.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/record/formula/eval/AreaEvalBase.java",
                "patch": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.poi.hssf.record.formula.eval;\n+\n+import org.apache.poi.hssf.record.formula.AreaI;\n+\n+/**\n+ * @author Josh Micich\n+ */\n+abstract class AreaEvalBase implements AreaEval {\n+\n+\tprivate final int _firstColumn;\n+\tprivate final int _firstRow;\n+\tprivate final int _lastColumn;\n+\tprivate final int _lastRow;\n+\tprivate final ValueEval[] _values;\n+\tprivate final int _nColumns;\n+\tprivate final int _nRows;\n+\n+\tprotected AreaEvalBase(AreaI ptg, ValueEval[] values) {\n+\t\tif (values == null) {\n+\t\t\tthrow new IllegalArgumentException(\"values must not be null\");\n+\t\t}\n+\t\t_firstRow = ptg.getFirstRow();\n+\t\t_firstColumn = ptg.getFirstColumn();\n+\t\t_lastRow = ptg.getLastRow();\n+\t\t_lastColumn = ptg.getLastColumn();\n+\t\t\n+\t\t_nColumns = _lastColumn - _firstColumn + 1;\n+\t\t_nRows = _lastRow - _firstRow + 1;\n+\t\t\n+\t\tint expectedItemCount = _nRows * _nColumns;\n+\t\tif ((values.length != expectedItemCount)) {\n+\t\t\t// Note - this math may need alteration when POI starts to support full column or full row refs\n+\t\t\tthrow new IllegalArgumentException(\"Array size should be (\" + expectedItemCount\n+\t\t\t\t\t+ \") but was (\" + values.length + \")\");\n+\t\t}\n+\t\t\n+\n+\n+\t\tfor (int i = values.length - 1; i >= 0; i--) {\n+\t\t\tif (values[i] == null) {\n+\t\t\t\tthrow new IllegalArgumentException(\"value array elements must not be null\");\n+\t\t\t}\n+\t\t}\n+\t\t_values = values;\n+\t}\n+\n+\tpublic final int getFirstColumn() {\n+\t\treturn _firstColumn;\n+\t}\n+\n+\tpublic final int getFirstRow() {\n+\t\treturn _firstRow;\n+\t}\n+\n+\tpublic final int getLastColumn() {\n+\t\treturn _lastColumn;\n+\t}\n+\n+\tpublic final int getLastRow() {\n+\t\treturn _lastRow;\n+\t}\n+\n+\tpublic final ValueEval[] getValues() {\n+\t\t// TODO - clone() - but some junits rely on not cloning at the moment\n+\t\treturn _values;\n+\t}\n+\n+\tpublic final ValueEval getValueAt(int row, int col) {\n+\t\tint rowOffsetIx = row - _firstRow;\n+\t\tint colOffsetIx = col - _firstColumn;\n+\t\t\n+\t\tif(rowOffsetIx < 0 || rowOffsetIx >= _nRows) {\n+\t\t\tthrow new IllegalArgumentException(\"Specified row index (\" + row \n+\t\t\t\t\t+ \") is outside the allowed range (\" + _firstRow + \"..\" + _lastRow + \")\");\n+\t\t}\n+\t\tif(colOffsetIx < 0 || colOffsetIx >= _nColumns) {\n+\t\t\tthrow new IllegalArgumentException(\"Specified column index (\" + col \n+\t\t\t\t\t+ \") is outside the allowed range (\" + _firstColumn + \"..\" + col + \")\");\n+\t\t}\n+\n+\t\tint index = rowOffsetIx * _nColumns + colOffsetIx;\n+\t\treturn _values[index];\n+\t}\n+\n+\tpublic final boolean contains(int row, int col) {\n+\t\treturn _firstRow <= row && _lastRow >= row \n+\t\t\t&& _firstColumn <= col && _lastColumn >= col;\n+\t}\n+\n+\tpublic final boolean containsRow(int row) {\n+\t\treturn (_firstRow <= row) && (_lastRow >= row);\n+\t}\n+\n+\tpublic final boolean containsColumn(short col) {\n+\t\treturn (_firstColumn <= col) && (_lastColumn >= col);\n+\t}\n+\n+\tpublic final boolean isColumn() {\n+\t\treturn _firstColumn == _lastColumn;\n+\t}\n+\n+\tpublic final boolean isRow() {\n+\t\treturn _firstRow == _lastRow;\n+\t}\n+}",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/eval/AreaEvalBase.java",
                "sha": "9436ae0aa9d5e447384da90e7206367bcd9de208",
                "status": "added"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/function/FunctionMetadataReader.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/formula/function/FunctionMetadataReader.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 8,
                "filename": "src/java/org/apache/poi/hssf/record/formula/function/FunctionMetadataReader.java",
                "patch": "@@ -37,15 +37,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n final class FunctionMetadataReader {\n \n \tprivate static final String METADATA_FILE_NAME = \"functionMetadata.txt\";\n+\t\n+\t/** plain ASCII text metadata file uses three dots for ellipsis */\n+\tprivate static final String ELLIPSIS = \"...\";\n \n \tprivate static final Pattern TAB_DELIM_PATTERN = Pattern.compile(\"\\t\");\n \tprivate static final Pattern SPACE_DELIM_PATTERN = Pattern.compile(\" \");\n \tprivate static final byte[] EMPTY_BYTE_ARRAY = { };\n \n-\t// special characters from the ooo document\n-\tprivate static final int CHAR_ELLIPSIS_8230 = 8230;\n-\tprivate static final int CHAR_NDASH_8211 = 8211;\n-\t\n \tprivate static final String[] DIGIT_ENDING_FUNCTION_NAMES = {\n \t\t// Digits at the end of a function might be due to a left-over footnote marker.\n \t\t// except in these cases\n@@ -59,10 +58,12 @@ public static FunctionMetadataRegistry createRegistry() {\n \t\t\tthrow new RuntimeException(\"resource '\" + METADATA_FILE_NAME + \"' not found\");\n \t\t}\n \n-\t\tBufferedReader br = null;\n+\t\tBufferedReader br;\n \t\ttry {\n \t\t\tbr = new BufferedReader(new InputStreamReader(is,\"UTF-8\"));\n-\t\t} catch(UnsupportedEncodingException e) { /* never happens */ }\n+\t\t} catch(UnsupportedEncodingException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t\tFunctionDataBuilder fdb = new FunctionDataBuilder(400);\n \n \t\ttry {\n@@ -127,7 +128,9 @@ private static byte parseReturnTypeCode(String code) {\n \t\t}\n \t\tString[] array = SPACE_DELIM_PATTERN.split(codes);\n \t\tint nItems = array.length;\n-\t\tif(array[nItems-1].charAt(0) == CHAR_ELLIPSIS_8230) {\n+\t\tif(ELLIPSIS.equals(array[nItems-1])) {\n+\t\t\t// final ellipsis is optional, and ignored\n+\t\t\t// (all unspecified params are assumed to be the same as the last)\n \t\t\tnItems --;\n \t\t}\n \t\tbyte[] result = new byte[nItems];\n@@ -141,7 +144,6 @@ private static boolean isDash(String codes) {\n \t\tif(codes.length() == 1) {\n \t\t\tswitch (codes.charAt(0)) {\n \t\t\t\tcase '-':\n-\t\t\t\tcase CHAR_NDASH_8211: // this is what the ooo doc has\n \t\t\t\t\treturn true;\n \t\t\t}\n \t\t}",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/record/formula/function/FunctionMetadataReader.java",
                "sha": "5ce732719935650a352ad39025bf0622e73dc1f8",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "patch": "@@ -826,8 +826,7 @@ public void setCellErrorValue(byte value)\n         int row=record.getRow();\n         short col=record.getColumn();\n         short styleIndex=record.getXFIndex();\n-        if ((cellType != CELL_TYPE_ERROR) && (cellType != CELL_TYPE_FORMULA))\n-        {\n+        if (cellType != CELL_TYPE_ERROR) {\n             setCellType(CELL_TYPE_ERROR, false, row, col, styleIndex);\n         }\n         (( BoolErrRecord ) record).setValue(value);",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "sha": "2c823489492035dc2d57e75cf84cc88353894330",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFRow.java",
                "changes": 34,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFRow.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 23,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFRow.java",
                "patch": "@@ -21,7 +21,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.NoSuchElementException;\n \n import org.apache.poi.hssf.model.Sheet;\n-import org.apache.poi.hssf.model.Workbook;\n import org.apache.poi.hssf.record.CellValueRecordInterface;\n import org.apache.poi.hssf.record.RowRecord;\n import org.apache.poi.ss.usermodel.Cell;\n@@ -39,11 +38,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n     // used for collections\n     public final static int INITIAL_CAPACITY = 5;\n-    //private short rowNum;\n+\n     private int rowNum;\n     private HSSFCell[] cells=new HSSFCell[INITIAL_CAPACITY];\n-//    private short firstcell = -1;\n-//    private short lastcell = -1;\n \n     /**\n      * reference to low level representation\n@@ -63,7 +60,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n     private Sheet sheet;\n \n-    protected HSSFRow()\n+    // TODO - ditch this constructor\n+    HSSFRow()\n     {\n     }\n \n@@ -75,18 +73,12 @@ protected HSSFRow()\n      * @param rowNum the row number of this row (0 based)\n      * @see org.apache.poi.hssf.usermodel.HSSFSheet#createRow(int)\n      */\n-\n-    //protected HSSFRow(Workbook book, Sheet sheet, short rowNum)\n-    protected HSSFRow(HSSFWorkbook book, Sheet sheet, int rowNum)\n+    HSSFRow(HSSFWorkbook book, Sheet sheet, int rowNum)\n     {\n         this.rowNum = rowNum;\n         this.book = book;\n         this.sheet = sheet;\n-        row = new RowRecord();\n-        row.setOptionFlags( (short)0x100 );   // seems necessary for outlining to work.  \n-        row.setHeight((short) 0xff);\n-        row.setLastCol((short) -1);\n-        row.setFirstCol((short) -1);\n+        row = new RowRecord(rowNum);\n \n         setRowNum(rowNum);\n     }\n@@ -100,8 +92,7 @@ protected HSSFRow(HSSFWorkbook book, Sheet sheet, int rowNum)\n      * @param record the low level api object this row should represent\n      * @see org.apache.poi.hssf.usermodel.HSSFSheet#createRow(int)\n      */\n-\n-    protected HSSFRow(HSSFWorkbook book, Sheet sheet, RowRecord record)\n+    HSSFRow(HSSFWorkbook book, Sheet sheet, RowRecord record)\n     {\n         this.book = book;\n         this.sheet = sheet;\n@@ -219,12 +210,11 @@ protected HSSFCell createCellFromRecord(CellValueRecordInterface cell)\n      * @param rowNum  the row number (0-based)\n      * @throws IndexOutOfBoundsException if the row number is not within the range 0-65535.\n      */\n-\n-    //public void setRowNum(short rowNum)\n-    public void setRowNum(int rowNum)\n-    {\n-        if ((rowNum < 0) || (rowNum > RowRecord.MAX_ROW_NUMBER))\n-          throw new IndexOutOfBoundsException(\"Row number must be between 0 and \"+RowRecord.MAX_ROW_NUMBER+\", was <\"+rowNum+\">\");\n+    public void setRowNum(int rowNum) {\n+        if ((rowNum < 0) || (rowNum > RowRecord.MAX_ROW_NUMBER)) {\n+          throw new IllegalArgumentException(\"Invalid row number (\" + rowNum \n+                  + \") outside allowable range (0..\" + RowRecord.MAX_ROW_NUMBER + \")\");\n+        }\n         this.rowNum = rowNum;\n         if (row != null)\n         {\n@@ -236,8 +226,6 @@ public void setRowNum(int rowNum)\n      * get row number this row represents\n      * @return the row number (0 based)\n      */\n-\n-    //public short getRowNum()\n     public int getRowNum()\n     {\n         return rowNum;",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFRow.java",
                "sha": "d62a7c23a046fe67d943334be6fce6fb3a7544a2",
                "status": "modified"
            },
            {
                "additions": 76,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 95,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 19,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -153,6 +153,7 @@ private void setPropertiesFromSheet(Sheet sheet)\n     {\n         int sloc = sheet.getLoc();\n         RowRecord row = sheet.getNextRow();\n+        boolean rowRecordsAlreadyPresent = row!=null;\n \n         while (row != null)\n         {\n@@ -177,6 +178,18 @@ private void setPropertiesFromSheet(Sheet sheet)\n             if ( ( lastrow == null ) || ( lastrow.getRowNum() != cval.getRow() ) )\n             {\n                 hrow = getRow( cval.getRow() );\n+                if (hrow == null) {\n+                    // Some tools (like Perl module Spreadsheet::WriteExcel - bug 41187) skip the RowRecords \n+                    // Excel, OpenOffice.org and GoogleDocs are all OK with this, so POI should be too.\n+                    if (rowRecordsAlreadyPresent) {\n+                        // if at least one row record is present, all should be present.\n+                        throw new RuntimeException(\"Unexpected missing row when some rows already present\");\n+                    }\n+                    // create the row record on the fly now.\n+                    RowRecord rowRec = new RowRecord(cval.getRow());\n+                    sheet.addRow(rowRec);\n+                    hrow = createRowFromRecord(rowRec);\n+                }\n             }\n             if ( hrow != null )\n             {\n@@ -982,13 +995,34 @@ public HSSFFooter getFooter()\n         return new HSSFFooter( getSheet().getFooter() );\n     }\n \n+    /**\n+     * Note - this is not the same as whether the sheet is focused (isActive)\n+     * @return <code>true</code> if this sheet is currently selected\n+     */\n+    public boolean isSelected() {\n+        return getSheet().getWindowTwo().getSelected();\n+    }\n     /**\n      * Sets whether sheet is selected.\n      * @param sel Whether to select the sheet or deselect the sheet.\n      */\n     public void setSelected( boolean sel )\n     {\n-        getSheet().setSelected( sel );\n+        getSheet().getWindowTwo().setSelected(sel);\n+    }\n+    /**\n+     * @return <code>true</code> if this sheet is currently focused\n+     */\n+    public boolean isActive() {\n+        return getSheet().getWindowTwo().isActive();\n+    }\n+    /**\n+     * Sets whether sheet is selected.\n+     * @param sel Whether to select the sheet or deselect the sheet.\n+     */\n+    public void setActive(boolean sel )\n+    {\n+        getSheet().getWindowTwo().setActive(sel);\n     }\n \n     /**\n@@ -1690,6 +1724,23 @@ public void setDefaultColumnStyle(short column, CellStyle style) {\n      * @param column the column index\n      */\n     public void autoSizeColumn(short column) {\n+    \tautoSizeColumn(column, false);\n+    }\n+    \n+    /**\n+     * Adjusts the column width to fit the contents.\n+     *\n+     * This process can be relatively slow on large sheets, so this should\n+     *  normally only be called once per column, at the end of your\n+     *  processing.\n+     *\n+     * You can specify whether the content of merged cells should be considered or ignored.  \n+     *  Default is to ignore merged cells.\n+     *   \n+     * @param column the column index\n+     * @param useMergedCells whether to use the contents of merged cells when calculating the width of the column\n+     */\n+    public void autoSizeColumn(short column, boolean useMergedCells) {\n         AttributedString str;\n         TextLayout layout;\n         /**\n@@ -1698,13 +1749,13 @@ public void autoSizeColumn(short column) {\n          * '0' looks to be a good choice.\n          */\n         char defaultChar = '0';\n-\n+       \n         /**\n          * This is the multiple that the font height is scaled by when determining the\n          * boundary of rotated text.\n          */\n         double fontHeightMultiple = 2.0;\n-\n+       \n         FontRenderContext frc = new FontRenderContext(null, true, true);\n \n         HSSFWorkbook wb = new HSSFWorkbook(book);\n@@ -1716,21 +1767,27 @@ public void autoSizeColumn(short column) {\n         int defaultCharWidth = (int)layout.getAdvance();\n \n         double width = -1;\n+        rows:\n         for (Iterator it = rowIterator(); it.hasNext();) {\n             HSSFRow row = (HSSFRow) it.next();\n             HSSFCell cell = row.getCell(column);\n \n-            boolean isCellInMergedRegion = false;\n-            for (int i = 0 ; i < getNumMergedRegions() && ! isCellInMergedRegion; i++) {\n-                isCellInMergedRegion = getMergedRegionAt(i).contains(row.getRowNum(), column);\n+            if (cell == null) continue;\n+\n+            int colspan = 1;\n+            for (int i = 0 ; i < getNumMergedRegions(); i++) {\n+                if (getMergedRegionAt(i).contains(row.getRowNum(), column)) {\n+                \tif (!useMergedCells) {\n+                    \t// If we're not using merged cells, skip this one and move on to the next. \n+                \t\tcontinue rows;\n+                \t}\n+                \tcell = row.getCell(getMergedRegionAt(i).getColumnFrom());\n+                \tcolspan = 1+ getMergedRegionAt(i).getColumnTo() - getMergedRegionAt(i).getColumnFrom();\n+                }\n             }\n \n-            if (cell == null | isCellInMergedRegion) continue;\n-\n             HSSFCellStyle style = cell.getCellStyle();\n             HSSFFont font = wb.getFontAt(style.getFontIndex());\n-            //the number of spaces to indent the text in the cell\n-            int indention = style.getIndention();\n \n             if (cell.getCellType() == HSSFCell.CELL_TYPE_STRING) {\n                 HSSFRichTextString rt = cell.getRichStringCellValue();\n@@ -1763,9 +1820,9 @@ public void autoSizeColumn(short column) {\n                         trans.concatenate(\n                         AffineTransform.getScaleInstance(1, fontHeightMultiple)\n                         );\n-                        width = Math.max(width, layout.getOutline(trans).getBounds().getWidth() / defaultCharWidth + indention);\n+                        width = Math.max(width, ((layout.getOutline(trans).getBounds().getWidth() / colspan) / defaultCharWidth) + cell.getCellStyle().getIndention());\n                     } else {\n-                        width = Math.max(width, layout.getBounds().getWidth() / defaultCharWidth + indention);\n+                        width = Math.max(width, ((layout.getBounds().getWidth() / colspan) / defaultCharWidth) + cell.getCellStyle().getIndention());\n                     }\n                 }\n             } else {\n@@ -1808,19 +1865,19 @@ public void autoSizeColumn(short column) {\n                         trans.concatenate(\n                         AffineTransform.getScaleInstance(1, fontHeightMultiple)\n                         );\n-                        width = Math.max(width, layout.getOutline(trans).getBounds().getWidth() / defaultCharWidth + indention);\n+                        width = Math.max(width, ((layout.getOutline(trans).getBounds().getWidth() / colspan) / defaultCharWidth) + cell.getCellStyle().getIndention());\n                     } else {\n-                        width = Math.max(width, layout.getBounds().getWidth() / defaultCharWidth + indention);\n+                        width = Math.max(width, ((layout.getBounds().getWidth() / colspan) / defaultCharWidth) + cell.getCellStyle().getIndention());\n                     }\n                 }\n             }\n \n-            if (width != -1) {\n-                if (width > Short.MAX_VALUE) { //calculated width can be greater that Short.MAX_VALUE!\n-                     width = Short.MAX_VALUE;\n-                }\n-                sheet.setColumnWidth(column, (short) (width * 256));\n+        }\n+        if (width != -1) {\n+            if (width > Short.MAX_VALUE) { //width can be bigger that Short.MAX_VALUE!\n+            \twidth = Short.MAX_VALUE;\n             }\n+            sheet.setColumnWidth(column, (short) (width * 256));\n         }\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "f33570c10cb57dfb7111b2fa7df681bf178cc867",
                "status": "modified"
            },
            {
                "additions": 111,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java",
                "changes": 155,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 44,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java",
                "patch": "@@ -382,16 +382,66 @@ public void setSheetOrder(String sheetname, int pos ) {\n         workbook.setSheetOrder(sheetname, pos);\n     }\n \n+    private void validateSheetIndex(int index) {\n+        int lastSheetIx = sheets.size() - 1;\n+        if (index < 0 || index > lastSheetIx) {\n+            throw new IllegalArgumentException(\"Sheet index (\" \n+                    + index +\") is out of range (0..\" +    lastSheetIx + \")\");\n+        }\n+    }\n+    \n     /**\n-     * sets the tab whose data is actually seen when the sheet is opened.\n-     * This may be different from the \"selected sheet\" since excel seems to\n-     * allow you to show the data of one sheet when another is seen \"selected\"\n-     * in the tabs (at the bottom).\n-     * @see org.apache.poi.hssf.usermodel.HSSFSheet#setSelected(boolean)\n-     * @param index\n+     * Selects a single sheet. This may be different to\n+     * the 'active' sheet (which is the sheet with focus).  \n+     */\n+    public void setSelectedTab(int index) {\n+        \n+        validateSheetIndex(index);\n+        int nSheets = sheets.size();\n+        for (int i=0; i<nSheets; i++) {\n+               getSheetAt(i).setSelected(i == index);\n+        }\n+        workbook.getWindowOne().setNumSelectedTabs((short)1);\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated use setSelectedTab(int)\n      */\n     public void setSelectedTab(short index) {\n-        workbook.getWindowOne().setSelectedTab(index);\n+        setSelectedTab((int)index);\n+    }\n+    public void setSelectedTabs(int[] indexes) {\n+        \n+        for (int i = 0; i < indexes.length; i++) {\n+            validateSheetIndex(indexes[i]);\n+        }\n+        int nSheets = sheets.size();\n+        for (int i=0; i<nSheets; i++) {\n+            boolean bSelect = false;\n+            for (int j = 0; j < indexes.length; j++) {\n+                if (indexes[j] == i) {\n+                    bSelect = true;\n+                    break;\n+                }\n+                \n+            }\n+               getSheetAt(i).setSelected(bSelect);\n+        }\n+        workbook.getWindowOne().setNumSelectedTabs((short)indexes.length);\n+    }\n+    /**\n+     * Convenience method to set the active sheet.  The active sheet is is the sheet\n+     * which is currently displayed when the workbook is viewed in Excel.\n+     * 'Selected' sheet(s) is a distinct concept.\n+     */\n+    public void setActiveSheet(int index) {\n+        \n+        validateSheetIndex(index);\n+        int nSheets = sheets.size();\n+        for (int i=0; i<nSheets; i++) {\n+             getSheetAt(i).setActive(i == index);\n+        }\n+        workbook.getWindowOne().setActiveSheetIndex(index);\n     }\n \n     /**\n@@ -401,25 +451,46 @@ public void setSelectedTab(short index) {\n      * in the tabs (at the bottom).\n      * @see org.apache.poi.hssf.usermodel.HSSFSheet#setSelected(boolean)\n      */\n+    public int getActiveSheetIndex() {\n+        return workbook.getWindowOne().getActiveSheetIndex();\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use getActiveSheetIndex() \n+     */\n     public short getSelectedTab() {\n-        return workbook.getWindowOne().getSelectedTab();\n+        return (short) getActiveSheetIndex();\n     }\n \n+    \n     /**\n      * sets the first tab that is displayed in the list of tabs\n      * in excel.\n      * @param index\n      */\n+    public void setFirstVisibleTab(int index) {\n+        workbook.getWindowOne().setFirstVisibleTab(index);\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use setFirstVisibleTab() \n+     */\n     public void setDisplayedTab(short index) {\n-        workbook.getWindowOne().setDisplayedTab(index);\n+       setFirstVisibleTab(index);\n     }\n \n     /**\n-     * sets the first tab that is displayed in the list of tabs\n-     * in excel.\n+     * sets the first tab that is displayed in the list of tabs in excel.\n+     */\n+    public int getFirstVisibleTab() {\n+        return workbook.getWindowOne().getFirstVisibleTab();\n+    }\n+    /**\n+     * deprecated May 2008\n+     * @deprecated - Misleading name - use getFirstVisibleTab() \n      */\n     public short getDisplayedTab() {\n-        return workbook.getWindowOne().getDisplayedTab();\n+        return (short) getFirstVisibleTab();\n     }\n \n     /**\n@@ -580,17 +651,13 @@ public int getExternalSheetIndex(int internalSheetIndex) {\n \n     public HSSFSheet createSheet()\n     {\n-\n-//        if (getNumberOfSheets() == 3)\n-//            throw new RuntimeException(\"You cannot have more than three sheets in HSSF 1.0\");\n         HSSFSheet sheet = new HSSFSheet(this);\n \n         sheets.add(sheet);\n-        workbook.setSheetName(sheets.size() - 1,\n-                \"Sheet\" + (sheets.size() - 1));\n-        WindowTwoRecord windowTwo = (WindowTwoRecord) sheet.getSheet().findFirstRecordBySid(WindowTwoRecord.sid);\n-        windowTwo.setSelected(sheets.size() == 1);\n-        windowTwo.setPaged(sheets.size() == 1);\n+        workbook.setSheetName(sheets.size() - 1, \"Sheet\" + (sheets.size() - 1));\n+        boolean isOnlySheet = sheets.size() == 1;\n+        sheet.setSelected(isOnlySheet);\n+        sheet.setActive(isOnlySheet);\n         return sheet;\n     }\n \n@@ -601,23 +668,24 @@ public HSSFSheet createSheet()\n      */\n \n     public HSSFSheet cloneSheet(int sheetNum) {\n-      HSSFSheet srcSheet = (HSSFSheet)sheets.get(sheetNum);\n-      String srcName = workbook.getSheetName(sheetNum);\n-      if (srcSheet != null) {\n+        validateSheetIndex(sheetNum);\n+        HSSFSheet srcSheet = (HSSFSheet) sheets.get(sheetNum);\n+        String srcName = workbook.getSheetName(sheetNum);\n         HSSFSheet clonedSheet = srcSheet.cloneSheet(this);\n-        WindowTwoRecord windowTwo = (WindowTwoRecord) clonedSheet.getSheet().findFirstRecordBySid(WindowTwoRecord.sid);\n-        windowTwo.setSelected(sheets.size() == 1);\n-        windowTwo.setPaged(sheets.size() == 1);\n+        clonedSheet.setSelected(false);\n+        clonedSheet.setActive(false);\n \n         sheets.add(clonedSheet);\n-        int i=1;\n+        int i = 1;\n         while (true) {\n-            //Try and find the next sheet name that is unique\n+            // Try and find the next sheet name that is unique\n             String name = srcName;\n             String index = Integer.toString(i++);\n-            if (name.length()+index.length()+2<31)\n-              name = name + \"(\"+index+\")\";\n-            else name = name.substring(0, 31-index.length()-2)+\"(\"+index+\")\";\n+            if (name.length() + index.length() + 2 < 31) {\n+                name = name + \"(\" + index + \")\";\n+            } else {\n+                name = name.substring(0, 31 - index.length() - 2) + \"(\" + index + \")\";\n+            }\n \n             //If the sheet name is unique, then set it otherwise move on to the next number.\n             if (workbook.getSheetIndex(name) == -1) {\n@@ -626,18 +694,18 @@ public HSSFSheet cloneSheet(int sheetNum) {\n             }\n         }\n         return clonedSheet;\n-      }\n-      return null;\n     }\n \n     /**\n-     * create an HSSFSheet for this HSSFWorkbook, adds it to the sheets and returns\n-     * the high level representation.  Use this to create new sheets.\n-     *\n-     * @param sheetname     sheetname to set for the sheet.\n+     * create an HSSFSheet for this HSSFWorkbook, adds it to the sheets and\n+     * returns the high level representation. Use this to create new sheets.\n+     * \n+     * @param sheetname\n+     *            sheetname to set for the sheet.\n      * @return HSSFSheet representing the new sheet.\n-     * @throws IllegalArgumentException if there is already a sheet present with a case-insensitive\n-     *  match for the specified name.\n+     * @throws IllegalArgumentException\n+     *             if there is already a sheet present with a case-insensitive\n+     *             match for the specified name.\n      */\n \n     public HSSFSheet createSheet(String sheetname)\n@@ -649,9 +717,9 @@ public HSSFSheet createSheet(String sheetname)\n \n         sheets.add(sheet);\n         workbook.setSheetName(sheets.size() - 1, sheetname);\n-        WindowTwoRecord windowTwo = (WindowTwoRecord) sheet.getSheet().findFirstRecordBySid(WindowTwoRecord.sid);\n-        windowTwo.setSelected(sheets.size() == 1);\n-        windowTwo.setPaged(sheets.size() == 1);\n+        boolean isOnlySheet = sheets.size() == 1;\n+        sheet.setSelected(isOnlySheet);\n+        sheet.setActive(isOnlySheet);\n         return sheet;\n     }\n \n@@ -855,8 +923,7 @@ public void setRepeatingRowsAndColumns(int sheetIndex,\n         HSSFPrintSetup printSetup = sheet.getPrintSetup();\n         printSetup.setValidSettings(false);\n \n-        WindowTwoRecord w2 = (WindowTwoRecord) sheet.getSheet().findFirstRecordBySid(WindowTwoRecord.sid);\n-        w2.setPaged(true);\n+        sheet.setActive(true);\n     }\n \n     private NameRecord findExistingRowColHeaderNameRecord( int sheetIndex )",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/hssf/usermodel/HSSFWorkbook.java",
                "sha": "b4c3cf3c7d17848f0e63454cf0cc6d3f55c70776",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/poifs/storage/BlockListImpl.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
                "patch": "@@ -102,7 +102,8 @@ public ListManagedBlock remove(final int index)\n         catch (ArrayIndexOutOfBoundsException ignored)\n         {\n             throw new IOException(\"Cannot remove block[ \" + index\n-                                  + \" ]; out of range\");\n+                                  + \" ]; out of range[ 0 - \" + \n+                                  (_blocks.length-1) + \" ]\");\n         }\n         return result;\n     }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
                "sha": "7e44fda3f35b31978c07fae340256f7d130ec872",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/poifs/storage/RawDataBlock.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/poifs/storage/RawDataBlock.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/poifs/storage/RawDataBlock.java",
                "patch": "@@ -81,8 +81,9 @@ else if (count != blockSize) {\n             log.log(POILogger.ERROR,\n             \t\t\"Unable to read entire block; \" + count\n                      + type + \" read before EOF; expected \"\n-                     + blockSize + \" bytes. Your document\"\n-                     + \" has probably been truncated!\"\n+                     + blockSize + \" bytes. Your document \"\n+                     + \"was either written by software that \"\n+                     + \"ignores the spec, or has been truncated!\"\n             );\n         }\n         else {",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/poifs/storage/RawDataBlock.java",
                "sha": "b4630a78b400ef9e46f5a57533102c1713cd0468",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/ss/usermodel/FormulaEvaluator.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/usermodel/FormulaEvaluator.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/ss/usermodel/FormulaEvaluator.java",
                "patch": "@@ -220,8 +220,7 @@ public Cell evaluateInCell(Cell cell) {\n                     cell.setCellValue(cv.getBooleanValue());\n                     break;\n                 case Cell.CELL_TYPE_ERROR:\n-                    cell.setCellType(Cell.CELL_TYPE_ERROR);\n-                    cell.setCellValue(cv.getErrorValue());\n+                    cell.setCellErrorValue(cv.getErrorValue());\n                     break;\n                 case Cell.CELL_TYPE_NUMERIC:\n                     cell.setCellType(Cell.CELL_TYPE_NUMERIC);",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/java/org/apache/poi/ss/usermodel/FormulaEvaluator.java",
                "sha": "36916e9c814c9ec600058e39569d2eddfeca936c",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/ooxml/interfaces-jdk14/org/apache/poi/ss/usermodel/Cell.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/interfaces-jdk14/org/apache/poi/ss/usermodel/Cell.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 1,
                "filename": "src/ooxml/interfaces-jdk14/org/apache/poi/ss/usermodel/Cell.java",
                "patch": "@@ -78,9 +78,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     int getCellType();\n     short getCellNum();\n \n-    byte getErrorCellValue();\n     String getCellFormula();\n \n+    byte getErrorCellValue();\n+    void setCellErrorValue(byte value);\n+\n     HSSFCellStyle getCellStyle();\n \n     boolean getBooleanCellValue();",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/ooxml/interfaces-jdk14/org/apache/poi/ss/usermodel/Cell.java",
                "sha": "471dca5b40c748279cdaecd10e2ec2c3da168a93",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/records/definitions/pane_record.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/records/definitions/pane_record.xml?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 1,
                "filename": "src/records/definitions/pane_record.xml",
                "patch": "@@ -31,7 +31,7 @@\n             <const name=\"lower right\" value=\"0\"/>\n             <const name=\"upper right\" value=\"1\"/>\n             <const name=\"lower left\" value=\"2\"/>\n-            <const name=\"uper left\" value=\"3\"/>\n+            <const name=\"upper left\" value=\"3\"/>\n         </field>\n     </fields>\n </record>",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/records/definitions/pane_record.xml",
                "sha": "436443113abda3fef51edc2a09a88bd754c5144f",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata-asGenerated.txt",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata-asGenerated.txt?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 23,
                "filename": "src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata-asGenerated.txt",
                "patch": "@@ -29,7 +29,7 @@\n 7\tMAX\t1\t30\tV\tR\t\t\r\n 8\tROW\t0\t1\tV\tR\t\t\r\n 9\tCOLUMN\t0\t1\tV\tR\t\t\r\n-10\tNA\t0\t0\tV\t\u2013\t\t\r\n+10\tNA\t0\t0\tV\t-\t\t\r\n 11\tNPV\t2\t30\tV\tV R\t\t\r\n 12\tSTDEV\t1\t30\tV\tR\t\t\r\n 13\tDOLLAR\t1\t2\tV\tV V\t\t\r\n@@ -38,7 +38,7 @@\n 16\tCOS\t1\t1\tV\tV\t\t\r\n 17\tTAN\t1\t1\tV\tV\t\t\r\n 18\tARCTAN\t1\t1\tV\tV\t\t\r\n-19\tPI\t0\t0\tV\t\u2013\t\t\r\n+19\tPI\t0\t0\tV\t-\t\t\r\n 20\tSQRT\t1\t1\tV\tV\t\t\r\n 21\tEXP\t1\t1\tV\tV\t\t\r\n 22\tLN\t1\t1\tV\tV\t\t\r\n@@ -53,8 +53,8 @@\n 31\tMID\t3\t3\tV\tV V V\t\t\r\n 32\tLEN\t1\t1\tV\tV\t\t\r\n 33\tVALUE\t1\t1\tV\tV\t\t\r\n-34\tTRUE\t0\t0\tV\t\u2013\t\t\r\n-35\tFALSE\t0\t0\tV\t\u2013\t\t\r\n+34\tTRUE\t0\t0\tV\t-\t\t\r\n+35\tFALSE\t0\t0\tV\t-\t\t\r\n 36\tAND\t1\t30\tV\tR\t\t\r\n 37\tOR\t1\t30\tV\tR\t\t\r\n 38\tNOT\t1\t1\tV\tV\t\t\r\n@@ -80,7 +80,7 @@\n 60\tRATE\t3\t6\tV\tV V V V V V\t\t\r\n 61\tMIRR\t3\t3\tV\tR V V\t\t\r\n 62\tIRR\t1\t2\tV\tR V\t\t\r\n-63\tRAND\t0\t0\tV\t\u2013\tx\t\r\n+63\tRAND\t0\t0\tV\t-\tx\t\r\n 64\tMATCH\t2\t3\tV\tV R R\t\t\r\n 65\tDATE\t3\t3\tV\tV V V\t\t\r\n 66\tTIME\t3\t3\tV\tV V V\t\t\r\n@@ -91,7 +91,7 @@\n 71\tHOUR\t1\t1\tV\tV\t\t\r\n 72\tMINUTE\t1\t1\tV\tV\t\t\r\n 73\tSECOND\t1\t1\tV\tV\t\t\r\n-74\tNOW\t0\t0\tV\t\u2013\tx\t\r\n+74\tNOW\t0\t0\tV\t-\tx\t\r\n 75\tAREAS\t1\t1\tV\tR\t\t\r\n 76\tROWS\t1\t1\tV\tR\t\t\r\n 77\tCOLUMNS\t1\t1\tV\tR\t\t\r\n@@ -170,10 +170,10 @@\n 215\tJIS\t1\t1\tV\tV\t\tx\r\n 219\tADDRESS\t2\t5\tV\tV V V V V\t\t\r\n 220\tDAYS360\t2\t2\tV\tV V\t\tx\r\n-221\tTODAY\t0\t0\tV\t\u2013\tx\t\r\n+221\tTODAY\t0\t0\tV\t-\tx\t\r\n 222\tVDB\t5\t7\tV\tV V V V V V V\t\t\r\n-227\tMEDIAN\t1\t30\tV\tR \u2026\t\t\r\n-228\tSUMPRODUCT\t1\t30\tV\tA \u2026\t\t\r\n+227\tMEDIAN\t1\t30\tV\tR ...\t\t\r\n+228\tSUMPRODUCT\t1\t30\tV\tA ...\t\t\r\n 229\tSINH\t1\t1\tV\tV\t\t\r\n 230\tCOSH\t1\t1\tV\tV\t\t\r\n 231\tTANH\t1\t1\tV\tV\t\t\r\n@@ -188,7 +188,7 @@\n 247\tDB\t4\t5\tV\tV V V V V\t\t\r\n 252\tFREQUENCY\t2\t2\tA\tR R\t\t\r\n 261\tERROR.TYPE\t1\t1\tV\tV\t\t\r\n-269\tAVEDEV\t1\t30\tV\tR \u2026\t\t\r\n+269\tAVEDEV\t1\t30\tV\tR ...\t\t\r\n 270\tBETADIST\t3\t5\tV\tV V V V V\t\t\r\n 271\tGAMMALN\t1\t1\tV\tV\t\t\r\n 272\tBETAINV\t3\t5\tV\tV V V V V\t\t\r\n@@ -237,12 +237,12 @@\n 315\tSLOPE\t2\t2\tV\tA A\t\t\r\n 316\tTTEST\t4\t4\tV\tA A V V\t\t\r\n 317\tPROB\t3\t4\tV\tA A V V\t\t\r\n-318\tDEVSQ\t1\t30\tV\tR \u2026\t\t\r\n-319\tGEOMEAN\t1\t30\tV\tR \u2026\t\t\r\n-320\tHARMEAN\t1\t30\tV\tR \u2026\t\t\r\n-321\tSUMSQ\t0\t30\tV\tR \u2026\t\t\r\n-322\tKURT\t1\t30\tV\tR \u2026\t\t\r\n-323\tSKEW\t1\t30\tV\tR \u2026\t\t\r\n+318\tDEVSQ\t1\t30\tV\tR ...\t\t\r\n+319\tGEOMEAN\t1\t30\tV\tR ...\t\t\r\n+320\tHARMEAN\t1\t30\tV\tR ...\t\t\r\n+321\tSUMSQ\t0\t30\tV\tR ...\t\t\r\n+322\tKURT\t1\t30\tV\tR ...\t\t\r\n+323\tSKEW\t1\t30\tV\tR ...\t\t\r\n 324\tZTEST\t2\t3\tV\tR V V\t\t\r\n 325\tLARGE\t2\t2\tV\tR V\t\t\r\n 326\tSMALL\t2\t2\tV\tR V\t\t\r\n@@ -274,10 +274,10 @@\n 358\tGETPIVOTDATA\t2\t30\t\t\t\t\r\n 359\tHYPERLINK\t1\t2\tV\tV V\t\t\r\n 360\tPHONETIC\t1\t1\tV\tR\t\t\r\n-361\tAVERAGEA\t1\t30\tV\tR \u2026\t\t\r\n-362\tMAXA\t1\t30\tV\tR \u2026\t\t\r\n-363\tMINA\t1\t30\tV\tR \u2026\t\t\r\n-364\tSTDEVPA\t1\t30\tV\tR \u2026\t\t\r\n-365\tVARPA\t1\t30\tV\tR \u2026\t\t\r\n-366\tSTDEVA\t1\t30\tV\tR \u2026\t\t\r\n-367\tVARA\t1\t30\tV\tR \u2026\t\t\r\n+361\tAVERAGEA\t1\t30\tV\tR ...\t\t\r\n+362\tMAXA\t1\t30\tV\tR ...\t\t\r\n+363\tMINA\t1\t30\tV\tR ...\t\t\r\n+364\tSTDEVPA\t1\t30\tV\tR ...\t\t\r\n+365\tVARPA\t1\t30\tV\tR ...\t\t\r\n+366\tSTDEVA\t1\t30\tV\tR ...\t\t\r\n+367\tVARA\t1\t30\tV\tR ...\t\t\r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata-asGenerated.txt",
                "sha": "475131e1c0e4d347cd092cfde7691414384848b1",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata.txt",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata.txt?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 23,
                "filename": "src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata.txt",
                "patch": "@@ -31,7 +31,7 @@\n 7\tMAX\t1\t30\tV\tR\t\t\r\n 8\tROW\t0\t1\tV\tR\t\t\r\n 9\tCOLUMN\t0\t1\tV\tR\t\t\r\n-10\tNA\t0\t0\tV\t\u2013\t\t\r\n+10\tNA\t0\t0\tV\t-\t\t\r\n 11\tNPV\t2\t30\tV\tV R\t\t\r\n 12\tSTDEV\t1\t30\tV\tR\t\t\r\n 13\tDOLLAR\t1\t2\tV\tV V\t\t\r\n@@ -40,7 +40,7 @@\n 16\tCOS\t1\t1\tV\tV\t\t\r\n 17\tTAN\t1\t1\tV\tV\t\t\r\n 18\tATAN\t1\t1\tV\tV\t\t\r\n-19\tPI\t0\t0\tV\t\u2013\t\t\r\n+19\tPI\t0\t0\tV\t-\t\t\r\n 20\tSQRT\t1\t1\tV\tV\t\t\r\n 21\tEXP\t1\t1\tV\tV\t\t\r\n 22\tLN\t1\t1\tV\tV\t\t\r\n@@ -55,8 +55,8 @@\n 31\tMID\t3\t3\tV\tV V V\t\t\r\n 32\tLEN\t1\t1\tV\tV\t\t\r\n 33\tVALUE\t1\t1\tV\tV\t\t\r\n-34\tTRUE\t0\t0\tV\t\u2013\t\t\r\n-35\tFALSE\t0\t0\tV\t\u2013\t\t\r\n+34\tTRUE\t0\t0\tV\t-\t\t\r\n+35\tFALSE\t0\t0\tV\t-\t\t\r\n 36\tAND\t1\t30\tV\tR\t\t\r\n 37\tOR\t1\t30\tV\tR\t\t\r\n 38\tNOT\t1\t1\tV\tV\t\t\r\n@@ -82,7 +82,7 @@\n 60\tRATE\t3\t6\tV\tV V V V V V\t\t\r\n 61\tMIRR\t3\t3\tV\tR V V\t\t\r\n 62\tIRR\t1\t2\tV\tR V\t\t\r\n-63\tRAND\t0\t0\tV\t\u2013\tx\t\r\n+63\tRAND\t0\t0\tV\t-\tx\t\r\n 64\tMATCH\t2\t3\tV\tV R R\t\t\r\n 65\tDATE\t3\t3\tV\tV V V\t\t\r\n 66\tTIME\t3\t3\tV\tV V V\t\t\r\n@@ -93,7 +93,7 @@\n 71\tHOUR\t1\t1\tV\tV\t\t\r\n 72\tMINUTE\t1\t1\tV\tV\t\t\r\n 73\tSECOND\t1\t1\tV\tV\t\t\r\n-74\tNOW\t0\t0\tV\t\u2013\tx\t\r\n+74\tNOW\t0\t0\tV\t-\tx\t\r\n 75\tAREAS\t1\t1\tV\tR\t\t\r\n 76\tROWS\t1\t1\tV\tR\t\t\r\n 77\tCOLUMNS\t1\t1\tV\tR\t\t\r\n@@ -172,10 +172,10 @@\n 215\tJIS\t1\t1\tV\tV\t\tx\r\n 219\tADDRESS\t2\t5\tV\tV V V V V\t\t\r\n 220\tDAYS360\t2\t2\tV\tV V\t\tx\r\n-221\tTODAY\t0\t0\tV\t\u2013\tx\t\r\n+221\tTODAY\t0\t0\tV\t-\tx\t\r\n 222\tVDB\t5\t7\tV\tV V V V V V V\t\t\r\n-227\tMEDIAN\t1\t30\tV\tR \u2026\t\t\r\n-228\tSUMPRODUCT\t1\t30\tV\tA \u2026\t\t\r\n+227\tMEDIAN\t1\t30\tV\tR ...\t\t\r\n+228\tSUMPRODUCT\t1\t30\tV\tA ...\t\t\r\n 229\tSINH\t1\t1\tV\tV\t\t\r\n 230\tCOSH\t1\t1\tV\tV\t\t\r\n 231\tTANH\t1\t1\tV\tV\t\t\r\n@@ -192,7 +192,7 @@\n 247\tDB\t4\t5\tV\tV V V V V\t\t\r\n 252\tFREQUENCY\t2\t2\tA\tR R\t\t\r\n 261\tERROR.TYPE\t1\t1\tV\tV\t\t\r\n-269\tAVEDEV\t1\t30\tV\tR \u2026\t\t\r\n+269\tAVEDEV\t1\t30\tV\tR ...\t\t\r\n 270\tBETADIST\t3\t5\tV\tV V V V V\t\t\r\n 271\tGAMMALN\t1\t1\tV\tV\t\t\r\n 272\tBETAINV\t3\t5\tV\tV V V V V\t\t\r\n@@ -241,12 +241,12 @@\n 315\tSLOPE\t2\t2\tV\tA A\t\t\r\n 316\tTTEST\t4\t4\tV\tA A V V\t\t\r\n 317\tPROB\t3\t4\tV\tA A V V\t\t\r\n-318\tDEVSQ\t1\t30\tV\tR \u2026\t\t\r\n-319\tGEOMEAN\t1\t30\tV\tR \u2026\t\t\r\n-320\tHARMEAN\t1\t30\tV\tR \u2026\t\t\r\n-321\tSUMSQ\t0\t30\tV\tR \u2026\t\t\r\n-322\tKURT\t1\t30\tV\tR \u2026\t\t\r\n-323\tSKEW\t1\t30\tV\tR \u2026\t\t\r\n+318\tDEVSQ\t1\t30\tV\tR ...\t\t\r\n+319\tGEOMEAN\t1\t30\tV\tR ...\t\t\r\n+320\tHARMEAN\t1\t30\tV\tR ...\t\t\r\n+321\tSUMSQ\t0\t30\tV\tR ...\t\t\r\n+322\tKURT\t1\t30\tV\tR ...\t\t\r\n+323\tSKEW\t1\t30\tV\tR ...\t\t\r\n 324\tZTEST\t2\t3\tV\tR V V\t\t\r\n 325\tLARGE\t2\t2\tV\tR V\t\t\r\n 326\tSMALL\t2\t2\tV\tR V\t\t\r\n@@ -278,10 +278,10 @@\n 358\tGETPIVOTDATA\t2\t30\t\t\t\t\r\n 359\tHYPERLINK\t1\t2\tV\tV V\t\t\r\n 360\tPHONETIC\t1\t1\tV\tR\t\t\r\n-361\tAVERAGEA\t1\t30\tV\tR \u2026\t\t\r\n-362\tMAXA\t1\t30\tV\tR \u2026\t\t\r\n-363\tMINA\t1\t30\tV\tR \u2026\t\t\r\n-364\tSTDEVPA\t1\t30\tV\tR \u2026\t\t\r\n-365\tVARPA\t1\t30\tV\tR \u2026\t\t\r\n-366\tSTDEVA\t1\t30\tV\tR \u2026\t\t\r\n-367\tVARA\t1\t30\tV\tR \u2026\t\t\r\n+361\tAVERAGEA\t1\t30\tV\tR ...\t\t\r\n+362\tMAXA\t1\t30\tV\tR ...\t\t\r\n+363\tMINA\t1\t30\tV\tR ...\t\t\r\n+364\tSTDEVPA\t1\t30\tV\tR ...\t\t\r\n+365\tVARPA\t1\t30\tV\tR ...\t\t\r\n+366\tSTDEVA\t1\t30\tV\tR ...\t\t\r\n+367\tVARA\t1\t30\tV\tR ...\t\t\r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/resources/main/org/apache/poi/hssf/record/formula/function/functionMetadata.txt",
                "sha": "6902027de974b8925260c978be952f9cc2a79cce",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/examples/src/org/apache/poi/hslf/examples/DataExtraction.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/examples/src/org/apache/poi/hslf/examples/DataExtraction.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 11,
                "filename": "src/scratchpad/examples/src/org/apache/poi/hslf/examples/DataExtraction.java",
                "patch": "@@ -69,16 +69,9 @@ public static void main(String args[]) throws Exception {\n                     String name = ole.getInstanceName();\r\n                     if (\"Worksheet\".equals(name)) {\r\n \r\n-                        //save xls on disk\r\n-                        FileOutputStream out = new FileOutputStream(name + \"-(\"+(j)+\").xls\");\r\n-                        InputStream dis = data.getData();\r\n-                        byte[] chunk = new byte[2048];\r\n-                        int count;\r\n-                        while ((count = dis.read(chunk)) >= 0) {\r\n-                          out.write(chunk,0,count);\r\n-                        }\r\n-                        is.close();\r\n-                        out.close();\r\n+                        //read xls\r\n+                        HSSFWorkbook wb = new HSSFWorkbook(data.getData());\r\n+\r\n                     } else if (\"Document\".equals(name)) {\r\n                         HWPFDocument doc = new HWPFDocument(data.getData());\r\n                         //read the word document\r\n@@ -93,7 +86,15 @@ public static void main(String args[]) throws Exception {\n                         doc.write(out);\r\n                         out.close();\r\n                      }  else {\r\n-                        System.err.println(\"Processing \" + name);\r\n+                        FileOutputStream out = new FileOutputStream(ole.getProgID() + \"-\"+(j+1)+\".dat\");\r\n+                        InputStream dis = data.getData();\r\n+                        byte[] chunk = new byte[2048];\r\n+                        int count;\r\n+                        while ((count = dis.read(chunk)) >= 0) {\r\n+                          out.write(chunk,0,count);\r\n+                        }\r\n+                        is.close();\r\n+                        out.close();\r\n                     }\r\n                 }\r\n \r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/examples/src/org/apache/poi/hslf/examples/DataExtraction.java",
                "sha": "611466c9247acce111daf4a687e8034c33dd6312",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/model/ShapeFactory.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/ShapeFactory.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/ShapeFactory.java",
                "patch": "@@ -76,6 +76,7 @@ public static Shape createSimpeShape(EscherContainerRecord spContainer, Shape pa\n             case ShapeTypes.TextBox:\n                 shape = new TextBox(spContainer, parent);\n                 break;\n+            case ShapeTypes.HostControl: \n             case ShapeTypes.PictureFrame: {\n                 EscherOptRecord opt = (EscherOptRecord)Shape.getEscherChild(spContainer, EscherOptRecord.RECORD_ID);\n                 EscherProperty prop = Shape.getEscherProperty(opt, EscherProperties.BLIP__PICTUREID);",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/model/ShapeFactory.java",
                "sha": "4bef9033dbe2f255a47360e7643d08385954d61e",
                "status": "modified"
            },
            {
                "additions": 33,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/model/TextRun.java",
                "changes": 49,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/TextRun.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 16,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/TextRun.java",
                "patch": "@@ -45,7 +45,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tprotected TextBytesAtom  _byteAtom;\n \tprotected TextCharsAtom  _charAtom;\n \tprotected StyleTextPropAtom _styleAtom;\n-    protected TextSpecInfoAtom  _specAtom;\n \tprotected boolean _isUnicode;\n \tprotected RichTextRun[] _rtRuns;\n \tprivate SlideShow slideShow;\n@@ -319,9 +318,9 @@ public RichTextRun appendText(String s) {\n \t *  touch the stylings. \n \t */\n \tprivate void storeText(String s) {\n-\t\t// Remove a single trailing \\n, as there is an implicit one at the\n+\t\t// Remove a single trailing \\r, as there is an implicit one at the\n \t\t//  end of every record\n-\t\tif(s.endsWith(\"\\n\")) {\n+\t\tif(s.endsWith(\"\\r\")) {\n \t\t\ts = s.substring(0, s.length()-1);\n \t\t}\n \t\t\n@@ -361,6 +360,18 @@ private void storeText(String s) {\n \t\t\t\t_isUnicode = true;\n \t\t\t}\n \t\t}\n+        /**\n+         * If TextSpecInfoAtom is present, we must update the text size in it,\n+         * otherwise the ppt will be corrupted\n+         */\n+        if(_records != null) for (int i = 0; i < _records.length; i++) {\n+            if(_records[i] instanceof TextSpecInfoAtom){\n+                TextSpecInfoAtom specAtom = (TextSpecInfoAtom)_records[i];\n+                if((s.length() + 1) != specAtom.getCharactersCovered()){\n+                    specAtom.reset(s.length() + 1);\n+                }\n+            }\n+        }\n \t}\n \t\n \t/**\n@@ -446,7 +457,7 @@ public synchronized void changeTextInRichTextRun(RichTextRun run, String s) {\n \t *  as the the first character has. \n \t * If you care about styling, do setText on a RichTextRun instead \n \t */\n-\tpublic synchronized void setText(String s) {\n+\tpublic synchronized void setRawText(String s) {\n \t\t// Save the new text to the atoms\n \t\tstoreText(s);\n \t\tRichTextRun fst = _rtRuns[0];\n@@ -474,20 +485,18 @@ public synchronized void setText(String s) {\n \t\t\t_rtRuns[0] = new RichTextRun(this,0,s.length());\n \t\t}\n \n-        /**\n-         * If TextSpecInfoAtom is present, we must update the text size,\n-         * otherwise the ppt will be corrupted\n-         */\n-        if(_records != null) for (int i = 0; i < _records.length; i++) {\n-            if(_records[i] instanceof TextSpecInfoAtom){\n-                TextSpecInfoAtom specAtom = (TextSpecInfoAtom)_records[i];\n-                specAtom.setTextSize(s.length());\n-            }\n-\n-        }\n \t}\n \n-\t/**\n+    /**\n+     * Changes the text.\n+     * Converts '\\r' into '\\n'\n+     */\n+    public synchronized void setText(String s) {\n+        String text = normalize(s);\n+        setRawText(text);\n+    }\n+\n+    /**\n \t * Ensure a StyleTextPropAtom is present for this run, \n \t *  by adding if required. Normally for internal TextRun use.\n \t */\n@@ -666,4 +675,12 @@ public TextRulerAtom getTextRuler(){\n         return null;\n \n     }\n+\n+    /**\n+     * Returns a new string with line breaks converted into internal ppt representation\n+     */\n+    public String normalize(String s){\n+        String ns = s.replaceAll(\"\\\\r?\\\\n\", \"\\r\");\n+        return ns;\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/model/TextRun.java",
                "sha": "4030ddc0c281a571bd3f54c5c379e970fde10166",
                "status": "modified"
            },
            {
                "additions": 95,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExControl.java",
                "changes": 95,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/ExControl.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/ExControl.java",
                "patch": "@@ -0,0 +1,95 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.hslf.record;\r\n+\r\n+import java.io.OutputStream;\r\n+import java.io.IOException;\r\n+\r\n+import org.apache.poi.util.LittleEndian;\r\n+import org.apache.poi.util.POILogger;\r\n+\r\n+/**\r\n+ * Container for OLE Control object. It contains:\r\n+ * <p>\r\n+ * 1. ExControlAtom (4091)\r\n+ * 2. ExOleObjAtom (4035)\r\n+ * 3. CString (4026), Instance MenuName (1) used for menus and the Links dialog box.\r\n+ * 4. CString (4026), Instance ProgID (2) that stores the OLE Programmatic Identifier.\r\n+ *  A ProgID is a string that uniquely identifies a given object.\r\n+ * 5. CString (4026), Instance ClipboardName (3) that appears in the paste special dialog.\r\n+ * 6. MetaFile( 4033), optional\r\n+ * </p>\r\n+ *\r\n+ *\r\n+ * @author Yegor kozlov\r\n+ */\r\n+public class ExControl extends ExEmbed {\r\n+\r\n+    // Links to our more interesting children\r\n+    private ExControlAtom ctrlAtom;\r\n+\r\n+    /**\r\n+     * Set things up, and find our more interesting children\r\n+     *\r\n+     * @param source the source data as a byte array.\r\n+     * @param start the start offset into the byte array.\r\n+     * @param len the length of the slice in the byte array.\r\n+     */\r\n+    protected ExControl(byte[] source, int start, int len) {\r\n+        super(source, start, len);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new ExEmbed, with blank fields\r\n+     */\r\n+    public ExControl() {\r\n+        super();\r\n+\r\n+        _children[0] = ctrlAtom = new ExControlAtom();\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the {@link ExControlAtom}.\r\n+     *\r\n+     * @return the {@link ExControlAtom}.\r\n+     */\r\n+    public ExControlAtom getExControlAtom()\r\n+    {\r\n+        return ctrlAtom;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the type (held as a little endian in bytes 3 and 4)\r\n+     * that this class handles.\r\n+     *\r\n+     * @return the record type.\r\n+     */\r\n+    public long getRecordType() {\r\n+        return RecordTypes.ExControl.typeID;\r\n+    }\r\n+\r\n+    protected RecordAtom getEmbedAtom(Record[] children){\r\n+        RecordAtom atom = null;\r\n+        if(_children[0] instanceof ExControlAtom) {\r\n+            atom = (ExControlAtom)_children[0];\r\n+        } else {\r\n+            logger.log(POILogger.ERROR, \"First child record wasn't a ExControlAtom, was of type \" + _children[0].getRecordType());\r\n+        }\r\n+        return atom;\r\n+    }\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExControl.java",
                "sha": "e6e7da893c71ed0591578ae52918bca70f0741da",
                "status": "added"
            },
            {
                "additions": 96,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExControlAtom.java",
                "changes": 96,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/ExControlAtom.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/ExControlAtom.java",
                "patch": "@@ -0,0 +1,96 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+\r\n+package org.apache.poi.hslf.record;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.OutputStream;\r\n+\r\n+import org.apache.poi.util.LittleEndian;\r\n+\r\n+/**\r\n+ * Contains a long integer, slideID, which stores the unique slide identifier of the slide\r\n+ * where this control resides.\r\n+ *\r\n+ * @author Yegor Kozlov\r\n+ */\r\n+public class ExControlAtom extends RecordAtom {\r\n+\r\n+\r\n+    /**\r\n+     * Record header.\r\n+     */\r\n+    private byte[] _header;\r\n+\r\n+    /**\r\n+     * slideId.\r\n+     */\r\n+    private int _id;\r\n+\r\n+    /**\r\n+     * Constructs a brand new embedded object atom record.\r\n+     */\r\n+    protected ExControlAtom() {\r\n+        _header = new byte[8];\r\n+\r\n+        LittleEndian.putShort(_header, 2, (short) getRecordType());\r\n+        LittleEndian.putInt(_header, 4, 4);\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructs the ExControlAtom record from its source data.\r\n+     *\r\n+     * @param source the source data as a byte array.\r\n+     * @param start  the start offset into the byte array.\r\n+     * @param len    the length of the slice in the byte array.\r\n+     */\r\n+    protected ExControlAtom(byte[] source, int start, int len) {\r\n+        // Get the header.\r\n+        _header = new byte[8];\r\n+        System.arraycopy(source, start, _header, 0, 8);\r\n+\r\n+        _id = LittleEndian.getInt(source, start + 8);\r\n+    }\r\n+\r\n+    public int getSlideId() {\r\n+        return _id;\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the record type.\r\n+     * @return the record type.\r\n+     */\r\n+    public long getRecordType() {\r\n+        return RecordTypes.ExControlAtom.typeID;\r\n+    }\r\n+\r\n+    /**\r\n+     * Write the contents of the record back, so it can be written\r\n+     * to disk\r\n+     *\r\n+     * @param out the output stream to write to.\r\n+     * @throws java.io.IOException if an error occurs.\r\n+     */\r\n+    public void writeOut(OutputStream out) throws IOException {\r\n+        out.write(_header);\r\n+        byte[] data = new byte[4];\r\n+        LittleEndian.putInt(data, _id);\r\n+        out.write(data);\r\n+    }\r\n+\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExControlAtom.java",
                "sha": "ae99d0a235e7b32aa426106a305fa318694d5e4c",
                "status": "added"
            },
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExEmbed.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/ExEmbed.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 7,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/ExEmbed.java",
                "patch": "@@ -36,7 +36,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private byte[] _header;\n \n     // Links to our more interesting children\n-    private ExEmbedAtom embedAtom;\n+    private RecordAtom embedAtom;\n     private ExOleObjAtom oleObjAtom;\n     private CString menuName;\n     private CString progId;\n@@ -91,11 +91,7 @@ public ExEmbed() {\n     private void findInterestingChildren() {\n \n         // First child should be the ExHyperlinkAtom\n-        if(_children[0] instanceof ExEmbedAtom) {\n-            embedAtom = (ExEmbedAtom)_children[0];\n-        } else {\n-            logger.log(POILogger.ERROR, \"First child record wasn't a ExEmbedAtom, was of type \" + _children[0].getRecordType());\n-        }\n+        embedAtom = getEmbedAtom(_children);\n \n         // Second child should be the ExOleObjAtom\n         if (_children[1] instanceof ExOleObjAtom) {\n@@ -115,14 +111,24 @@ private void findInterestingChildren() {\n         }\n     }\n \n+    protected RecordAtom getEmbedAtom(Record[] children){\n+        RecordAtom atom = null;\n+        if(_children[0] instanceof ExEmbedAtom) {\n+            atom = (ExEmbedAtom)_children[0];\n+        } else {\n+            logger.log(POILogger.ERROR, \"First child record wasn't a ExEmbedAtom, was of type \" + _children[0].getRecordType());\n+        }\n+        return atom;\n+    }\n+\n     /**\n      * Gets the {@link ExEmbedAtom}.\n      *\n      * @return the {@link ExEmbedAtom}.\n      */\n     public ExEmbedAtom getExEmbedAtom()\n     {\n-        return embedAtom;\n+        return (ExEmbedAtom)embedAtom;\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExEmbed.java",
                "sha": "501712e9d5f410f7a81e7c5d880fe5ccb60a0bea",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExOleObjStg.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/ExOleObjStg.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 4,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/ExOleObjStg.java",
                "patch": "@@ -17,11 +17,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hslf.record;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.io.*;\n import java.util.zip.InflaterInputStream;\n+import java.util.zip.DeflaterOutputStream;\n \n import org.apache.poi.util.LittleEndian;\n \n@@ -92,6 +90,25 @@ public InputStream getData() {\n         return new InflaterInputStream(compressedStream);\n     }\n \n+    /**\n+     * Sets the embedded data.\n+     *\n+     * @param data the embedded data.\n+     */\n+     public void setData(byte[] data) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        //first four bytes is the length of the raw data\n+        byte[] b = new byte[4];\n+        LittleEndian.putInt(b, data.length);\n+        out.write(b);\n+\n+        DeflaterOutputStream def = new DeflaterOutputStream(out);\n+        def.write(data, 0, data.length);\n+        def.finish();\n+        _data = out.toByteArray();\n+        LittleEndian.putInt(_header, 4, _data.length);\n+    }\n+\n     /**\n      * Gets the record type.\n      *",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/ExOleObjStg.java",
                "sha": "c7408b0fe4e5ffbe903c27659d9abedd37341c7d",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java",
                "patch": "@@ -119,7 +119,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     public static final Type RecolorInfoAtom = new Type(4071,null);\n     public static final Type ExQuickTimeMovie = new Type(4074,null);\n     public static final Type ExQuickTimeMovieData = new Type(4075,null);\n-    public static final Type ExControl = new Type(4078,null);\n+    public static final Type ExControl = new Type(4078,ExControl.class);\n     public static final Type SlideListWithText = new Type(4080,SlideListWithText.class);\n     public static final Type InteractiveInfo = new Type(4082,InteractiveInfo.class);\n     public static final Type InteractiveInfoAtom = new Type(4083,InteractiveInfoAtom.class);",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/RecordTypes.java",
                "sha": "a6f00da124da26cb05072dce6a74d2d9cb89642b",
                "status": "modified"
            },
            {
                "additions": 115,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/TextSpecInfoAtom.java",
                "changes": 115,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/record/TextSpecInfoAtom.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/record/TextSpecInfoAtom.java",
                "patch": "@@ -20,6 +20,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \r\n import java.io.OutputStream;\r\n import java.io.IOException;\r\n+import java.util.ArrayList;\r\n \r\n /**\r\n  * The special info runs contained in this text.\r\n@@ -82,4 +83,118 @@ public void writeOut(OutputStream out) throws IOException {\n     public void setTextSize(int size){\r\n         LittleEndian.putInt(_data, 0, size);\r\n     }\r\n+\r\n+    /**\r\n+     * Reset the content to one info run with the default values\r\n+     * @param size  the site of parent text\r\n+     */\r\n+    public void reset(int size){\r\n+        _data = new byte[10];\r\n+        // 01 00 00 00\r\n+        LittleEndian.putInt(_data, 0, size);\r\n+        // 01 00 00 00\r\n+        LittleEndian.putInt(_data, 4, 1); //mask\r\n+        // 00 00\r\n+        LittleEndian.putShort(_data, 8, (short)0); //langId\r\n+\r\n+        // Update the size (header bytes 5-8)\r\n+        LittleEndian.putInt(_header, 4, _data.length);\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the number of characters covered by this records\r\n+     *\r\n+     * @return the number of characters covered by this records\r\n+     */\r\n+    public int getCharactersCovered(){\r\n+        int covered = 0;\r\n+        TextSpecInfoRun[] runs = getTextSpecInfoRuns();\r\n+        for (int i = 0; i < runs.length; i++) covered += runs[i].len;\r\n+        return covered;\r\n+    }\r\n+\r\n+    public TextSpecInfoRun[] getTextSpecInfoRuns(){\r\n+        ArrayList lst = new ArrayList();\r\n+        int pos = 0;\r\n+        int[] bits = {1, 0, 2};\r\n+        while(pos < _data.length) {\r\n+            TextSpecInfoRun run = new TextSpecInfoRun();\r\n+            run.len = LittleEndian.getInt(_data, pos); pos += 4;\r\n+            run.mask = LittleEndian.getInt(_data, pos); pos += 4;\r\n+            for (int i = 0; i < bits.length; i++) {\r\n+                if((run.mask & 1 << bits[i]) != 0){\r\n+                    switch (bits[i]){\r\n+                        case 0:\r\n+                            run.spellInfo = LittleEndian.getShort(_data, pos); pos += 2;\r\n+                            break;\r\n+                        case 1:\r\n+                            run.langId = LittleEndian.getShort(_data, pos); pos += 2;\r\n+                            break;\r\n+                        case 2:\r\n+                            run.altLangId = LittleEndian.getShort(_data, pos); pos += 2;\r\n+                            break;\r\n+                    }\r\n+                }\r\n+            }\r\n+            lst.add(run);\r\n+        }\r\n+        return (TextSpecInfoRun[])lst.toArray(new TextSpecInfoRun[lst.size()]);\r\n+\r\n+    }\r\n+\r\n+    public static class TextSpecInfoRun {\r\n+        //Length of special info run.\r\n+        protected int len;\r\n+\r\n+        //Special info mask of this run;\r\n+        protected int mask;\r\n+\r\n+        // info fields as indicated by the mask.\r\n+        // -1 means the bit is not set\r\n+        protected short spellInfo = -1;\r\n+        protected short langId = -1;\r\n+        protected short altLangId = -1;\r\n+\r\n+        /**\r\n+         * Spelling status of this text. See Spell Info table below.\r\n+         *\r\n+         * <p>Spell Info Types:</p>\r\n+         * <li>0    Unchecked\r\n+         * <li>1    Previously incorrect, needs rechecking\r\n+         * <li>2    Correct\r\n+         * <li>3    Incorrect\r\n+         *\r\n+         * @return Spelling status of this text\r\n+         */\r\n+        public short getSpellInfo(){\r\n+            return spellInfo;\r\n+        }\r\n+\r\n+        /**\r\n+         * Windows LANGID for this text.\r\n+         *\r\n+         * @return Windows LANGID for this text.\r\n+         */\r\n+        public short getLangId(){\r\n+            return spellInfo;\r\n+        }\r\n+\r\n+        /**\r\n+         * Alternate Windows LANGID of this text;\r\n+         * must be a valid non-East Asian LANGID if the text has an East Asian language,\r\n+         * otherwise may be an East Asian LANGID or language neutral (zero).\r\n+         *\r\n+         * @return  Alternate Windows LANGID of this text\r\n+         */\r\n+        public short getAltLangId(){\r\n+            return altLangId;\r\n+        }\r\n+\r\n+        /**\r\n+         * @return Length of special info run.\r\n+         */\r\n+        public int length(){\r\n+            return len;\r\n+        }\r\n+    }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/record/TextSpecInfoAtom.java",
                "sha": "85cdd1e156ae7ad8e1cfc4fc704d0c93f41e014e",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/usermodel/ObjectData.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/usermodel/ObjectData.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/usermodel/ObjectData.java",
                "patch": "@@ -17,6 +17,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n package org.apache.poi.hslf.usermodel;\n \n import java.io.InputStream;\n+import java.io.IOException;\n \n import org.apache.poi.hslf.record.ExOleObjStg;\n \n@@ -49,6 +50,15 @@ public InputStream getData() {\n         return storage.getData();\n     }\n \n+    /**\n+     * Sets the embedded data.\n+     *\n+     * @param data the embedded data.\n+     */\n+     public void setData(byte[] data) throws IOException {\n+        storage.setData(data);    \n+    }\n+\n     /**\n      * Return the record that contains the object data.\n      *",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/usermodel/ObjectData.java",
                "sha": "bbef87a96cf2b34536af5cff307baa8b5d453e01",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java",
                "patch": "@@ -162,10 +162,18 @@ public String getRawText() {\n \t * Change the text\n \t */\n \tpublic void setText(String text) {\n-\t\tlength = text.length();\n-\t\tparentRun.changeTextInRichTextRun(this,text);\n+        String s = parentRun.normalize(text);\n+        setRawText(s);\n \t}\n \t\n+    /**\n+     * Change the text\n+     */\n+    public void setRawText(String text) {\n+        length = text.length();\n+        parentRun.changeTextInRichTextRun(this,text);\n+    }\n+\n \t/**\n \t * Tells the RichTextRun its new position in the parent TextRun\n \t * @param startAt",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hslf/usermodel/RichTextRun.java",
                "sha": "6bc203b658f97a512c9726554544320386cef698",
                "status": "modified"
            },
            {
                "additions": 37,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 31,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -16,22 +15,20 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    limitations under the License.\n ==================================================================== */\n \n-\n package org.apache.poi.hwpf.model;\n \n+import java.util.Arrays;\n+\n import org.apache.poi.util.BitField;\n import org.apache.poi.util.LittleEndian;\n \n-import org.apache.poi.hwpf.usermodel.CharacterProperties;\n-import org.apache.poi.hwpf.usermodel.ParagraphProperties;\n-\n-import org.apache.poi.hwpf.sprm.ParagraphSprmCompressor;\n-import org.apache.poi.hwpf.sprm.CharacterSprmCompressor;\n-\n-import java.util.Arrays;\n-\n-public class ListLevel\n+/**\n+ * \n+ */\n+public final class ListLevel\n {\n+  private static final int RGBXCH_NUMS_SIZE = 9;\n+\n   private int _iStartAt;\n   private byte _nfc;\n   private byte _info;\n@@ -70,7 +67,7 @@ public ListLevel(int level, boolean numbered)\n     _grpprlPapx = new byte[0];\n     _grpprlChpx = new byte[0];\n     _numberText = new char[0];\n-    _rgbxchNums = new byte[9];\n+    _rgbxchNums = new byte[RGBXCH_NUMS_SIZE];\n \n     if (numbered)\n     {\n@@ -90,12 +87,11 @@ public ListLevel(byte[] buf, int offset)\n     _nfc = buf[offset++];\n     _info = buf[offset++];\n \n-    _rgbxchNums = new byte[9];\n-    for (int x = 0; x < 9; x++)\n-    {\n-      _rgbxchNums[x] = buf[offset++];\n-    }\n-    _ixchFollow = buf[offset++];\n+    _rgbxchNums = new byte[RGBXCH_NUMS_SIZE];\n+    System.arraycopy(buf, offset, _rgbxchNums, 0, RGBXCH_NUMS_SIZE);\n+    offset += RGBXCH_NUMS_SIZE;\n+  \n+   _ixchFollow = buf[offset++];\n     _dxaSpace = LittleEndian.getInt(buf, offset);\n     offset += LittleEndian.INT_SIZE;\n     _dxaIndent = LittleEndian.getInt(buf, offset);\n@@ -207,8 +203,8 @@ public boolean equals(Object obj)\n     offset += LittleEndian.INT_SIZE;\n     buf[offset++] = _nfc;\n     buf[offset++] = _info;\n-    System.arraycopy(_rgbxchNums, 0, buf, offset, _rgbxchNums.length);\n-    offset += _rgbxchNums.length;\n+    System.arraycopy(_rgbxchNums, 0, buf, offset, RGBXCH_NUMS_SIZE);\n+    offset += RGBXCH_NUMS_SIZE;\n     buf[offset++] = _ixchFollow;\n     LittleEndian.putInt(buf, offset, _dxaSpace);\n     offset += LittleEndian.INT_SIZE;\n@@ -225,23 +221,33 @@ public boolean equals(Object obj)\n     System.arraycopy(_grpprlPapx, 0, buf, offset, _cbGrpprlPapx);\n     offset += _cbGrpprlPapx;\n \n-    LittleEndian.putShort(buf, offset, (short)_numberText.length);\n-    offset += LittleEndian.SHORT_SIZE;\n-    for (int x = 0; x < _numberText.length; x++)\n-    {\n-      LittleEndian.putShort(buf, offset, (short)_numberText[x]);\n+    if (_numberText == null) {\n+      // TODO - write junit to test this flow\n+      LittleEndian.putUShort(buf, offset, 0);\n+    } else {\n+      LittleEndian.putUShort(buf, offset, _numberText.length);\n       offset += LittleEndian.SHORT_SIZE;\n+      for (int x = 0; x < _numberText.length; x++)\n+      {\n+        LittleEndian.putUShort(buf, offset, _numberText[x]);\n+        offset += LittleEndian.SHORT_SIZE;\n+      }\n     }\n     return buf;\n   }\n   public int getSizeInBytes()\n   {\n-      if (_numberText!=null)\n-      {\n-            return 28 + _cbGrpprlChpx + _cbGrpprlPapx + (_numberText.length * LittleEndian.SHORT_SIZE) + 2;\n-      } else {\n-          return 28 + _cbGrpprlChpx + _cbGrpprlPapx  + 2;\n-      }\n+    int result =\n+        6 // int byte byte\n+        + RGBXCH_NUMS_SIZE\n+        + 13 // byte int int byte byte short\n+        + _cbGrpprlChpx \n+        + _cbGrpprlPapx\n+        + 2; // numberText length\n+    if (_numberText != null) {\n+      result += _numberText.length * LittleEndian.SHORT_SIZE;\n+    }\n+    return result;\n   }\n \n }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java",
                "sha": "f6b4d8594fea8ec64c70b18d20331ea18dc920cb",
                "status": "modified"
            },
            {
                "additions": 95,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/testcases/org/apache/poi/hslf/record/TestTextSpecInfoAtom.java",
                "changes": 95,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/record/TestTextSpecInfoAtom.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/record/TestTextSpecInfoAtom.java",
                "patch": "@@ -0,0 +1,95 @@\n+\r\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+        \r\n+\r\n+\r\n+package org.apache.poi.hslf.record;\r\n+\r\n+import org.apache.poi.hslf.HSLFSlideShow;\r\n+import org.apache.poi.hslf.model.textproperties.CharFlagsTextProp;\r\n+import org.apache.poi.hslf.model.textproperties.TextProp;\r\n+import org.apache.poi.hslf.model.textproperties.TextPropCollection;\r\n+import org.apache.poi.hslf.record.StyleTextPropAtom.*;\r\n+import org.apache.poi.hslf.usermodel.SlideShow;\r\n+import org.apache.poi.util.HexDump;\r\n+\r\n+import junit.framework.TestCase;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.util.LinkedList;\r\n+import java.util.Arrays;\r\n+\r\n+/**\r\n+ * Tests TextSpecInfoAtom\r\n+ *\r\n+ * @author Yegor Kozlov\r\n+ */\r\n+public class TestTextSpecInfoAtom extends TestCase {\r\n+\r\n+    //from a real file\r\n+\tprivate byte[] data_1 = new byte[] {\r\n+        0x00, 0x00, (byte)0xAA, 0x0F, 0x2C, 0x00, 0x00, 0x00,\r\n+        0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\r\n+        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x00,\r\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01,\r\n+        0x00, 0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n+\t};\r\n+\r\n+\r\n+    public void testRead() throws Exception {\r\n+\t\tTextSpecInfoAtom spec = new TextSpecInfoAtom(data_1, 0, data_1.length);\r\n+        TextSpecInfoAtom.TextSpecInfoRun[] run = spec.getTextSpecInfoRuns();\r\n+        assertEquals(5, run.length);\r\n+\r\n+        assertEquals(10, run[0].length());\r\n+        assertEquals(1, run[1].length());\r\n+        assertEquals(70, run[2].length());\r\n+        assertEquals(9, run[3].length());\r\n+        assertEquals(32, run[4].length());\r\n+\r\n+    }\r\n+\r\n+    public void testWrite() throws Exception {\r\n+        TextSpecInfoAtom spec = new TextSpecInfoAtom(data_1, 0, data_1.length);\r\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n+        spec.writeOut(out);\r\n+\r\n+        byte[] result = out.toByteArray();\r\n+        assertTrue(Arrays.equals(result, data_1));\r\n+\t}\r\n+\r\n+    public void testReset() throws Exception {\r\n+        TextSpecInfoAtom spec = new TextSpecInfoAtom(data_1, 0, data_1.length);\r\n+        spec.reset(32);  //length of the parent text\r\n+\r\n+        TextSpecInfoAtom.TextSpecInfoRun[] run = spec.getTextSpecInfoRuns();\r\n+        assertEquals(1, run.length);\r\n+\r\n+        assertEquals(32, run[0].length());\r\n+\r\n+        //serialize and read again\r\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n+        spec.writeOut(out);\r\n+\r\n+        byte[] result = out.toByteArray();\r\n+        TextSpecInfoAtom spec2 = new TextSpecInfoAtom(result, 0, result.length);\r\n+        TextSpecInfoAtom.TextSpecInfoRun[] run2 = spec2.getTextSpecInfoRuns();\r\n+        assertEquals(1, run2.length);\r\n+\r\n+        assertEquals(32, run2[0].length());\r\n+    }\r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/scratchpad/testcases/org/apache/poi/hslf/record/TestTextSpecInfoAtom.java",
                "sha": "5079628aec6afab3d420ce39da188dc7c3ecc91e",
                "status": "added"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/HSSFTests.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/HSSFTests.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 6,
                "filename": "src/testcases/org/apache/poi/hssf/HSSFTests.java",
                "patch": "@@ -22,9 +22,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import org.apache.poi.hssf.eventmodel.TestEventRecordFactory;\n import org.apache.poi.hssf.eventmodel.TestModelFactory;\n-import org.apache.poi.hssf.model.TestDrawingManager;\n-import org.apache.poi.hssf.model.TestFormulaParser;\n-import org.apache.poi.hssf.model.TestSheet;\n+import org.apache.poi.hssf.model.AllModelTests;\n import org.apache.poi.hssf.record.AllRecordTests;\n import org.apache.poi.hssf.usermodel.AllUserModelTests;\n import org.apache.poi.hssf.util.TestAreaReference;\n@@ -50,19 +48,17 @@ public static Test suite() {\n         TestSuite suite = new TestSuite(\"Tests for org.apache.poi.hssf\");\n         // $JUnit-BEGIN$\n \n+        suite.addTest(AllModelTests.suite());\n         suite.addTest(AllUserModelTests.suite());\n         suite.addTest(AllRecordTests.suite());\n \n-        suite.addTest(new TestSuite(TestFormulaParser.class));\n         suite.addTest(new TestSuite(TestAreaReference.class));\n         suite.addTest(new TestSuite(TestCellReference.class));\n         suite.addTest(new TestSuite(TestRangeAddress.class));\n         suite.addTest(new TestSuite(TestRKUtil.class));\n         suite.addTest(new TestSuite(TestSheetReferences.class));\n         suite.addTest(new TestSuite(TestEventRecordFactory.class));\n         suite.addTest(new TestSuite(TestModelFactory.class));\n-        suite.addTest(new TestSuite(TestDrawingManager.class));\n-        suite.addTest(new TestSuite(TestSheet.class));\n         // $JUnit-END$\n         return suite;\n     }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/HSSFTests.java",
                "sha": "0a4fa66af7d58ce8922988cd5e7aa40556a32c95",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/data/ex41187-19267.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/ex41187-19267.xls?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/ex41187-19267.xls",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/data/ex41187-19267.xls",
                "sha": "c07bfca59447a830438dbf4bc50bfa2ba318e358",
                "status": "added"
            },
            {
                "additions": 40,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/model/AllModelTests.java",
                "changes": 40,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/model/AllModelTests.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/model/AllModelTests.java",
                "patch": "@@ -0,0 +1,40 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.hssf.model;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Collects all tests for <tt>org.apache.poi.hssf.model</tt>.\n+ * \n+ * @author Josh Micich\n+ */\n+public final class AllModelTests {\n+\t\n+\tpublic static Test suite() {\n+\t\tTestSuite result = new TestSuite(AllModelTests.class.getName());\n+\t\tresult.addTestSuite(TestDrawingManager.class);\n+\t\tresult.addTestSuite(TestDrawingManager2.class);\n+\t\tresult.addTestSuite(TestFormulaParser.class);\n+\t\tresult.addTestSuite(TestFormulaParserEval.class);\n+\t\tresult.addTestSuite(TestSheet.class);\n+\t\tresult.addTestSuite(TestSheetAdditional.class);\n+\t\treturn result;\n+\t}\n+}",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/model/AllModelTests.java",
                "sha": "19ef437063be75446f9a993d215f04faf20d0c1b",
                "status": "added"
            },
            {
                "additions": 91,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/model/TestSheet.java",
                "changes": 184,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/model/TestSheet.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 93,
                "filename": "src/testcases/org/apache/poi/hssf/model/TestSheet.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -15,7 +14,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.hssf.model;\n \n@@ -34,8 +32,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  *\n  * @author Glen Stampoultzis (glens at apache.org)\n  */\n-public class TestSheet extends TestCase\n-{\n+public final class TestSheet extends TestCase {\n     public void testCreateSheet() throws Exception\n     {\n         // Check we're adding row and cell aggregates\n@@ -76,6 +73,21 @@ public void testAddMergedRegion()\n         if ((regionsToAdd % 1027) != 0)\n             recordsExpected++;\n         assertTrue(\"The \" + regionsToAdd + \" merged regions should have been spread out over \" + recordsExpected + \" records, not \" + recordsAdded, recordsAdded == recordsExpected);\n+        // Check we can't add one with invalid date\n+        try {\n+            sheet.addMergedRegion(10, (short)10, 9, (short)12);\n+            fail(\"Expected an exception to occur\");\n+        } catch(IllegalArgumentException e) {\n+            // occurs during successful test\n+            assertEquals(\"The 'to' row (9) must not be less than the 'from' row (10)\", e.getMessage());\n+        }\n+        try {\n+            sheet.addMergedRegion(10, (short)10, 12, (short)9);\n+            fail(\"Expected an exception to occur\");\n+        } catch(IllegalArgumentException e) {\n+            // occurs during successful test\n+            assertEquals(\"The 'to' col (9) must not be less than the 'from' col (10)\", e.getMessage());\n+        }\n     }\n \n     public void testRemoveMergedRegion()\n@@ -113,9 +125,9 @@ public void testMovingMergedRegion() {\n \n         MergeCellsRecord merged = new MergeCellsRecord();\n         merged.addArea(0, (short)0, 1, (short)2);\n-        records.add(new RowRecord());\n-        records.add(new RowRecord());\n-        records.add(new RowRecord());\n+        records.add(new RowRecord(0));\n+        records.add(new RowRecord(1));\n+        records.add(new RowRecord(2));\n         records.add(merged);\n \n         Sheet sheet = Sheet.createSheet(records, 0);\n@@ -142,20 +154,11 @@ public void testGetNumMergedRegions()\n      */\n     public void testRowAggregation() {\n         List records = new ArrayList();\n-        RowRecord row = new RowRecord();\n-        row.setRowNumber(0);\n-        records.add(row);\n-\n-        row = new RowRecord();\n-        row.setRowNumber(1);\n-        records.add(row);\n \n+        records.add(new RowRecord(0));\n+        records.add(new RowRecord(1));\n         records.add(new StringRecord());\n-\n-        row = new RowRecord();\n-        row.setRowNumber(2);\n-        records.add(row);\n-\n+        records.add(new RowRecord(2));\n \n         Sheet sheet = Sheet.createSheet(records, 0);\n         assertNotNull(\"Row [2] was skipped\", sheet.getRow(2));\n@@ -197,9 +200,9 @@ public void testRowPageBreaks(){\n         Iterator iterator = sheet.getRowBreaks();\n         while (iterator.hasNext()) {\n             PageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n-            int main = (int)breakItem.main;\n+            int main = breakItem.main;\n             if (main != 0 && main != 10 && main != 11) fail(\"Invalid page break\");\n-            if (main == 0) \tis0 = true;\n+            if (main == 0)     is0 = true;\n             if (main == 10) is10= true;\n             if (main == 11) is11 = true;\n         }\n@@ -216,8 +219,6 @@ public void testRowPageBreaks(){\n         assertFalse(\"row should be removed\", sheet.isRowBroken(10));\n \n         assertEquals(\"no more breaks\", 0, sheet.getNumRowBreaks());\n-\n-\n     }\n \n     /**\n@@ -256,10 +257,10 @@ public void testColPageBreaks(){\n         Iterator iterator = sheet.getColumnBreaks();\n         while (iterator.hasNext()) {\n             PageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n-            int main = (int)breakItem.main;\n+            int main = breakItem.main;\n             if (main != 0 && main != 1 && main != 10 && main != 15) fail(\"Invalid page break\");\n-            if (main == 0) \tis0 = true;\n-            if (main == 1) \tis1 = true;\n+            if (main == 0)  is0 = true;\n+            if (main == 1)  is1 = true;\n             if (main == 10) is10= true;\n             if (main == 15) is15 = true;\n         }\n@@ -286,72 +287,69 @@ public void testColPageBreaks(){\n      * works as designed.\n      */\n     public void testXFIndexForColumn() {\n-        try{\n-            final short TEST_IDX = 10;\n-            final short DEFAULT_IDX = 0xF; // 15\n-            short xfindex = Short.MIN_VALUE;\n-            Sheet sheet = Sheet.createSheet();\n-            \n-            // without ColumnInfoRecord\n-            xfindex = sheet.getXFIndexForColAt((short) 0);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 1);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-            \n-            ColumnInfoRecord nci = ( ColumnInfoRecord ) sheet.createColInfo();\n-            sheet.columns.insertColumn(nci);\n-            \n-            // single column ColumnInfoRecord\n-            nci.setFirstColumn((short) 2);\n-            nci.setLastColumn((short) 2);\n-            nci.setXFIndex(TEST_IDX);            \n-            xfindex = sheet.getXFIndexForColAt((short) 0);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 1);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 2);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 3);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-\n-            // ten column ColumnInfoRecord\n-            nci.setFirstColumn((short) 2);\n-            nci.setLastColumn((short) 11);\n-            nci.setXFIndex(TEST_IDX);            \n-            xfindex = sheet.getXFIndexForColAt((short) 1);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 2);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 6);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 11);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 12);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-\n-            // single column ColumnInfoRecord starting at index 0\n-            nci.setFirstColumn((short) 0);\n-            nci.setLastColumn((short) 0);\n-            nci.setXFIndex(TEST_IDX);            \n-            xfindex = sheet.getXFIndexForColAt((short) 0);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 1);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-\n-            // ten column ColumnInfoRecord starting at index 0\n-            nci.setFirstColumn((short) 0);\n-            nci.setLastColumn((short) 9);\n-            nci.setXFIndex(TEST_IDX);            \n-            xfindex = sheet.getXFIndexForColAt((short) 0);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 7);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 9);\n-            assertEquals(TEST_IDX, xfindex);\n-            xfindex = sheet.getXFIndexForColAt((short) 10);\n-            assertEquals(DEFAULT_IDX, xfindex);\n-        }\n-        catch(Exception e){e.printStackTrace();fail(e.getMessage());}\n+        final short TEST_IDX = 10;\n+        final short DEFAULT_IDX = 0xF; // 15\n+        short xfindex = Short.MIN_VALUE;\n+        Sheet sheet = Sheet.createSheet();\n+        \n+        // without ColumnInfoRecord\n+        xfindex = sheet.getXFIndexForColAt((short) 0);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 1);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+        \n+        ColumnInfoRecord nci = ( ColumnInfoRecord ) sheet.createColInfo();\n+        sheet.columns.insertColumn(nci);\n+        \n+        // single column ColumnInfoRecord\n+        nci.setFirstColumn((short) 2);\n+        nci.setLastColumn((short) 2);\n+        nci.setXFIndex(TEST_IDX);            \n+        xfindex = sheet.getXFIndexForColAt((short) 0);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 1);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 2);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 3);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+\n+        // ten column ColumnInfoRecord\n+        nci.setFirstColumn((short) 2);\n+        nci.setLastColumn((short) 11);\n+        nci.setXFIndex(TEST_IDX);            \n+        xfindex = sheet.getXFIndexForColAt((short) 1);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 2);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 6);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 11);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 12);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+\n+        // single column ColumnInfoRecord starting at index 0\n+        nci.setFirstColumn((short) 0);\n+        nci.setLastColumn((short) 0);\n+        nci.setXFIndex(TEST_IDX);            \n+        xfindex = sheet.getXFIndexForColAt((short) 0);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 1);\n+        assertEquals(DEFAULT_IDX, xfindex);\n+\n+        // ten column ColumnInfoRecord starting at index 0\n+        nci.setFirstColumn((short) 0);\n+        nci.setLastColumn((short) 9);\n+        nci.setXFIndex(TEST_IDX);            \n+        xfindex = sheet.getXFIndexForColAt((short) 0);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 7);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 9);\n+        assertEquals(TEST_IDX, xfindex);\n+        xfindex = sheet.getXFIndexForColAt((short) 10);\n+        assertEquals(DEFAULT_IDX, xfindex);\n     }\n-\n }\n+",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/model/TestSheet.java",
                "sha": "9281eb80d7c0a8767f2d7c32b23ce57187ea1fbb",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/model/TestSheetAdditional.java",
                "changes": 266,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/model/TestSheetAdditional.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 262,
                "filename": "src/testcases/org/apache/poi/hssf/model/TestSheetAdditional.java",
                "patch": "@@ -19,125 +19,18 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import java.lang.reflect.Field;\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n \n import junit.framework.TestCase;\n \n import org.apache.poi.hssf.record.ColumnInfoRecord;\n-import org.apache.poi.hssf.record.MergeCellsRecord;\n-import org.apache.poi.hssf.record.PageBreakRecord;\n-import org.apache.poi.hssf.record.RowRecord;\n-import org.apache.poi.hssf.record.StringRecord;\n \n /**\n  * @author Tony Poppleton\n  */\n-public class TestSheetAdditional extends TestCase\n-{\n-\t/**\n-\t * Constructor for SheetTest.\n-\t * @param arg0\n-\t */\n-\tpublic TestSheetAdditional(String arg0)\n-\t{\n-\t\tsuper(arg0);\n-\t}\n+public final class TestSheetAdditional extends TestCase {\n \t\n-\tpublic void testAddMergedRegion()\n-\t{\n-\t\tSheet sheet = Sheet.createSheet();\n-\t\tint regionsToAdd = 4096;\n-\t\tint startRecords = sheet.getRecords().size();\n-\t\t\n-\t\t//simple test that adds a load of regions\n-\t\tfor (int n = 0; n < regionsToAdd; n++)\n-\t\t{\n-\t\t\tint index = sheet.addMergedRegion(0, (short) 0, 1, (short) 1);\n-\t\t\tassertTrue(\"Merged region index expected to be \" + n + \" got \" + index, index == n);\n-\t\t}\n-\t\t\n-\t\t//test all the regions were indeed added \n-\t\tassertTrue(sheet.getNumMergedRegions() == regionsToAdd);\n-\t\t\n-\t\t//test that the regions were spread out over the appropriate number of records\n-\t\tint recordsAdded    = sheet.getRecords().size() - startRecords;\n-\t\tint recordsExpected = regionsToAdd/1027;\n-\t\tif ((regionsToAdd % 1027) != 0)\n-\t\t\trecordsExpected++;\n-\t\tassertTrue(\"The \" + regionsToAdd + \" merged regions should have been spread out over \" + recordsExpected + \" records, not \" + recordsAdded, recordsAdded == recordsExpected);\n-\t\t\n-\t\t// Check we can't add one with invalud date\n-\t\ttry {\n-\t\t\tsheet.addMergedRegion(10, (short)10, 9, (short)12);\n-\t\t\tfail();\n-\t\t} catch(IllegalArgumentException e) {}\n-\t\ttry {\n-\t\t\tsheet.addMergedRegion(10, (short)10, 12, (short)9);\n-\t\t\tfail();\n-\t\t} catch(IllegalArgumentException e) {}\n-\t}\n-\n-\tpublic void testRemoveMergedRegion()\n-\t{\n-\t\tSheet sheet = Sheet.createSheet();\n-\t\tint regionsToAdd = 4096;\n-\t\t\n-\t\tfor (int n = 0; n < regionsToAdd; n++)\n-\t\t\tsheet.addMergedRegion(0, (short) 0, 1, (short) 1);\n-\t\t\t\n-\t\tint records = sheet.getRecords().size();\n-\t\t\n-\t\t//remove a third from the beginning\n-\t\tfor (int n = 0; n < regionsToAdd/3; n++)\n-\t\t{\n-\t\t\tsheet.removeMergedRegion(0); \n-\t\t\t//assert they have been deleted\n-\t\t\tassertTrue(\"Num of regions should be \" + (regionsToAdd - n - 1) + \" not \" + sheet.getNumMergedRegions(), sheet.getNumMergedRegions() == regionsToAdd - n - 1);\n-\t\t}\n-\t\t\n-\t\t//assert any record removing was done\n-\t\tint recordsRemoved = (regionsToAdd/3)/1027; //doesn't work for particular values of regionsToAdd\n-\t\tassertTrue(\"Expected \" + recordsRemoved + \" record to be removed from the starting \" + records + \".  Currently there are \" + sheet.getRecords().size() + \" records\", records - sheet.getRecords().size() == recordsRemoved);\n-\t}\n-\n-\t/**\n-\t * Bug: 22922 (Reported by Xuemin Guan)\n-\t * <p>\n-\t * Remove mergedregion fails when a sheet loses records after an initial CreateSheet\n-\t * fills up the records.\n-\t *\n-\t */\n-\tpublic void testMovingMergedRegion() {\n-\t\tList records = new ArrayList();\n-\t\t\n-\t\tMergeCellsRecord merged = new MergeCellsRecord();\n-\t\tmerged.addArea(0, (short)0, 1, (short)2);\n-\t\trecords.add(new RowRecord());\n-\t\trecords.add(new RowRecord());\n-\t\trecords.add(new RowRecord());\n-\t\trecords.add(merged);\n-\t\t\n-\t\tSheet sheet = Sheet.createSheet(records, 0);\n-\t\tsheet.records.remove(0);\n-\t\t\n-\t\t//stub object to throw off list INDEX operations\n-\t\tsheet.removeMergedRegion(0);\n-\t\tassertEquals(\"Should be no more merged regions\", 0, sheet.getNumMergedRegions());\n-\t}\n-\n-\tpublic void testGetMergedRegionAt()\n-\t{\n-\t\t//TODO\n-\t}\n-\n-\tpublic void testGetNumMergedRegions()\n-\t{\n-\t\t//TODO\n-\t}\n-\n-\tpublic void DISBALEDtestGetCellWidth() throws Exception\n-\t{\n+\tpublic void testGetCellWidth() {\n \t\tSheet sheet = Sheet.createSheet();\n \t\tColumnInfoRecord nci = ( ColumnInfoRecord ) sheet.createColInfo();\n \n@@ -146,14 +39,8 @@ public void DISBALEDtestGetCellWidth() throws Exception\n \t\tnci.setLastColumn((short)10);\n \t\tnci.setColumnWidth((short)100);\n \t\t\n-\t\tField f = null;\n-\t\tf = Sheet.class.getDeclaredField(\"columnSizes\");\n-\t\tf.setAccessible(true);\n-\t\tList columnSizes = new ArrayList();\n-\t\tf.set(sheet,columnSizes);\n-\t\tcolumnSizes.add(nci);\n-\t\tsheet.records.add(1 + sheet.dimsloc, nci);\n-\t\tsheet.dimsloc++;\n+\t\t\n+\t\tsheet.columns.insertColumn(nci);\n \n \t\tassertEquals((short)100,sheet.getColumnWidth((short)5));\n \t\tassertEquals((short)100,sheet.getColumnWidth((short)6));\n@@ -172,151 +59,6 @@ public void DISBALEDtestGetCellWidth() throws Exception\n \t\tassertEquals((short)100,sheet.getColumnWidth((short)10));\n \t}\n \n-\t/**\n-\t * Makes sure all rows registered for this sheet are aggregated, they were being skipped\n-\t *\n-\t */\n-\tpublic void testRowAggregation() {\n-\t\tList records = new ArrayList();\n-\t\tRowRecord row = new RowRecord();\n-\t\trow.setRowNumber(0);\t\t\n-\t\trecords.add(row);\n-\t\t\n-\t\trow = new RowRecord();\n-\t\trow.setRowNumber(1);\n-\t\trecords.add(row);\n-\n-\t\trecords.add(new StringRecord());\n-\t\t\n-\t\trow = new RowRecord();\n-\t\trow.setRowNumber(2);\n-\t\trecords.add(row);\n-\t\t\n-\t\t\n-\t\tSheet sheet = Sheet.createSheet(records, 0);\n-\t\tassertNotNull(\"Row [2] was skipped\", sheet.getRow(2));\n-\t\t\n-\t}\n-\t\n-\t/**\n-\t * Make sure page break functionality works (in memory)\n-\t *\n-\t */\n-\tpublic void testRowPageBreaks(){\n-\t\tshort colFrom = 0;\n-\t\tshort colTo = 255;\n-\t\t\n-\t\tSheet sheet = Sheet.createSheet();\n-\t\tsheet.setRowBreak(0, colFrom, colTo);\n-\t\t\n-\t\tassertTrue(\"no row break at 0\", sheet.isRowBroken(0));\n-\t\tassertEquals(\"1 row break available\", 1, sheet.getNumRowBreaks());\n-\t\t\n-\t\tsheet.setRowBreak(0, colFrom, colTo);\t\t\n-\t\tsheet.setRowBreak(0, colFrom, colTo);\t\t\n-\n-\t\tassertTrue(\"no row break at 0\", sheet.isRowBroken(0));\n-\t\tassertEquals(\"1 row break available\", 1, sheet.getNumRowBreaks());\n-\t\t\n-\t\tsheet.setRowBreak(10, colFrom, colTo);\n-\t\tsheet.setRowBreak(11, colFrom, colTo);\n-\n-\t\tassertTrue(\"no row break at 10\", sheet.isRowBroken(10));\n-\t\tassertTrue(\"no row break at 11\", sheet.isRowBroken(11));\n-\t\tassertEquals(\"3 row break available\", 3, sheet.getNumRowBreaks());\n-\t\t\n-\t\t\n-\t\tboolean is10 = false;\n-\t\tboolean is0 = false;\n-\t\tboolean is11 = false;\n-\t\t\n-\t\tIterator iterator = sheet.getRowBreaks();\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tPageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n-\t\t\tint main = (int)breakItem.main;\n-\t\t\tif (main != 0 && main != 10 && main != 11) fail(\"Invalid page break\");\n-\t\t\tif (main == 0) \tis0 = true;\n-\t\t\tif (main == 10) is10= true;\n-\t\t\tif (main == 11) is11 = true;\n-\t\t}\n-\t\t\n-\t\tassertTrue(\"one of the breaks didnt make it\", is0 && is10 && is11); \n-\t\t\n-\t\tsheet.removeRowBreak(11);\n-\t\tassertFalse(\"row should be removed\", sheet.isRowBroken(11));\n-\t\t\n-\t\tsheet.removeRowBreak(0);\n-\t\tassertFalse(\"row should be removed\", sheet.isRowBroken(0));\n-\t\t\n-\t\tsheet.removeRowBreak(10);\n-\t\tassertFalse(\"row should be removed\", sheet.isRowBroken(10));\n-\t\t\n-\t\tassertEquals(\"no more breaks\", 0, sheet.getNumRowBreaks());\n-\t\t\n-\t\t\n-\t}\n-\t\n-\t/**\n-\t * Make sure column pag breaks works properly (in-memory)\n-\t *\n-\t */\n-\tpublic void testColPageBreaks(){\n-\t\tshort rowFrom = 0;\n-\t\tshort rowTo = (short)65535;\n-\t\t\n-\t\tSheet sheet = Sheet.createSheet();\n-\t\tsheet.setColumnBreak((short)0, rowFrom, rowTo); \n-\t\t\n-\t\tassertTrue(\"no col break at 0\", sheet.isColumnBroken((short)0));\n-\t\tassertEquals(\"1 col break available\", 1, sheet.getNumColumnBreaks());\t\t\n-\t\t\n-\t\tsheet.setColumnBreak((short)0, rowFrom, rowTo);\n-\t\t\n-\t\tassertTrue(\"no col break at 0\", sheet.isColumnBroken((short)0));\n-\t\tassertEquals(\"1 col break available\", 1, sheet.getNumColumnBreaks());\t\t\n-\t\t\n-\t\tsheet.setColumnBreak((short)1, rowFrom, rowTo);\n-\t\tsheet.setColumnBreak((short)10, rowFrom, rowTo);\n-\t\tsheet.setColumnBreak((short)15, rowFrom, rowTo);\n-\t\t\n-\t\tassertTrue(\"no col break at 1\", sheet.isColumnBroken((short)1));\n-\t\tassertTrue(\"no col break at 10\", sheet.isColumnBroken((short)10));\n-\t\tassertTrue(\"no col break at 15\", sheet.isColumnBroken((short)15));\n-\t\tassertEquals(\"4 col break available\", 4, sheet.getNumColumnBreaks());\t\t\n-\n-\t\tboolean is10 = false;\n-\t\tboolean is0 = false;\n-\t\tboolean is1 = false;\n-\t\tboolean is15 = false;\n-\t\t\n-\t\tIterator iterator = sheet.getColumnBreaks();\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tPageBreakRecord.Break breakItem = (PageBreakRecord.Break)iterator.next();\n-\t\t\tint main = (int)breakItem.main;\n-\t\t\tif (main != 0 && main != 1 && main != 10 && main != 15) fail(\"Invalid page break\");\n-\t\t\tif (main == 0) \tis0 = true;\n-\t\t\tif (main == 1) \tis1 = true;\n-\t\t\tif (main == 10) is10= true;\n-\t\t\tif (main == 15) is15 = true;\n-\t\t}\n-\t\t\n-\t\tassertTrue(\"one of the breaks didnt make it\", is0 && is1 && is10 && is15); \n-\t\t\n-\t\tsheet.removeColumnBreak((short)15);\n-\t\tassertFalse(\"column break should not be there\", sheet.isColumnBroken((short)15));\n-\n-\t\tsheet.removeColumnBreak((short)0);\n-\t\tassertFalse(\"column break should not be there\", sheet.isColumnBroken((short)0));\n-\t\t\n-\t\tsheet.removeColumnBreak((short)1);\n-\t\tassertFalse(\"column break should not be there\", sheet.isColumnBroken((short)1));\n-\t\t\n-\t\tsheet.removeColumnBreak((short)10);\n-\t\tassertFalse(\"column break should not be there\", sheet.isColumnBroken((short)10));\n-\t\t\n-\t\tassertEquals(\"no more breaks\", 0, sheet.getNumColumnBreaks());\n-\t}\n-\n }\n \n ",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/model/TestSheetAdditional.java",
                "sha": "f1c3b7c9cace67319cc2214d56c8f920a44d8906",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/aggregates/TestRowRecordsAggregate.java",
                "changes": 31,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/aggregates/TestRowRecordsAggregate.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 19,
                "filename": "src/testcases/org/apache/poi/hssf/record/aggregates/TestRowRecordsAggregate.java",
                "patch": "@@ -1,4 +1,3 @@\n-\n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -15,34 +14,28 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n+\n package org.apache.poi.hssf.record.aggregates;\n \n-import org.apache.poi.hssf.record.*;\n+import junit.framework.TestCase;\n \n-public class TestRowRecordsAggregate extends junit.framework.TestCase {\n-    public TestRowRecordsAggregate(String name) {\n-        super (name);\n-    }\n+import org.apache.poi.hssf.record.RowRecord;\n+\n+/**\n+ * \n+ */\n+public final class TestRowRecordsAggregate extends TestCase {\n     \n     public void testRowGet() {\n         RowRecordsAggregate rra = new RowRecordsAggregate();\n-        RowRecord rr = new RowRecord();\n-        rr.setRowNumber(( short ) 4);\n+        RowRecord rr = new RowRecord(4);\n         rra.insertRow(rr);\n-        RowRecord rr2 = new RowRecord(); rr2.setRowNumber((short) 1);\n-        rra.insertRow(rr2);\n+        rra.insertRow(new RowRecord(1));\n         \n         RowRecord rr1 = rra.getRow(4);\n         \n-        assertTrue(\"Row Record should not be null\", rr1!=null);\n-        assertTrue(\"Row number is 1\",rr1.getRowNumber() == 4);\n+        assertNotNull(rr1);\n+        assertEquals(\"Row number is 1\", 4, rr1.getRowNumber());\n         assertTrue(\"Row record retrieved is identical \", rr1 == rr);\n     }\n-    \n-     public static void main(String [] args) {\n-        System.out\n-        .println(\"Testing org.apache.poi.hssf.record.aggregates.RowRecordAggregate\");\n-        junit.textui.TestRunner.run(TestRowRecordsAggregate.class);\n-    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/aggregates/TestRowRecordsAggregate.java",
                "sha": "239fc2b8870515ca14f2bec9116ca21a03cb18f9",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/TestFuncPtg.java",
                "changes": 53,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/TestFuncPtg.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 34,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/TestFuncPtg.java",
                "patch": "@@ -1,4 +1,3 @@\n-        \n /* ====================================================================\n    Licensed to the Apache Software Foundation (ASF) under one or more\n    contributor license agreements.  See the NOTICE file distributed with\n@@ -26,45 +25,31 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  *\n  * @author Danny Mui (dmui at apache dot org)\n  */\n+public final class TestFuncPtg extends TestCase {\n \n-public class TestFuncPtg extends TestCase\n-{\n-\n-    public TestFuncPtg( String name )\n-    {\n-        super( name );\n-    }\n-\n-\n-    public static void main( java.lang.String[] args )\n-    {\n-        junit.textui.TestRunner.run( TestFuncPtg.class );\n-    }\n-\n-    /**\n-     * Make sure the left overs are re-serialized on excel file reads to avoid\n-     * the \"Warning: Data may have been lost\" prompt in excel.\n-     * <p/>\n-     * This ptg represents a LEN function extracted from excel\n-     */\n-\n-    public void testLeftOvers()\n-    {\n-        byte[] fakeData = new byte[4];\n-\n-        //fakeData[0] = (byte) 0x41;\n-        fakeData[0] = (byte) 0x20;  //function index\n-        fakeData[1] = (byte) 0;\n-        fakeData[2] = (byte) 8;\n+    public void testRead() {\n+    \t// This ptg represents a LEN function extracted from excel\n+        byte[] fakeData = {\n+            0x20,  //function index\n+            0,\n+        };\n \n         FuncPtg ptg = new FuncPtg( new TestcaseRecordInputStream((short)0, (short)fakeData.length, fakeData) );\n-        assertEquals( \"Len formula index is not 32(20H)\", (int) 0x20, ptg.getFunctionIndex() );\n+        assertEquals( \"Len formula index is not 32(20H)\", 0x20, ptg.getFunctionIndex() );\n         assertEquals( \"Number of operands in the len formula\", 1, ptg.getNumberOfOperands() );\n         assertEquals( \"Function Name\", \"LEN\", ptg.getName() );\n         assertEquals( \"Ptg Size\", 3, ptg.getSize() );\n-        //assertEquals(\"first leftover byte is not 0\", (byte)0, ptg.leftOvers[0]);\n-        //assertEquals(\"second leftover byte is not 8\", (byte)8, ptg.leftOvers[1]);\n-\n+    }\n+    \n+    public void testClone() {\n+        FuncPtg funcPtg = new FuncPtg(27); // ROUND() - takes 2 args\n+\n+        FuncPtg clone = (FuncPtg) funcPtg.clone();\n+        if (clone.getNumberOfOperands() == 0) {\n+            fail(\"clone() did copy field numberOfOperands\");\n+        }\n+        assertEquals(2, clone.getNumberOfOperands());\n+        assertEquals(\"ROUND\", clone.getName());\n     }\n }\n ",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/TestFuncPtg.java",
                "sha": "89997b59d1a98af2ab2ef6d089c014a55894675d",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/eval/AllFormulaEvalTests.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/eval/AllFormulaEvalTests.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/eval/AllFormulaEvalTests.java",
                "patch": "@@ -28,7 +28,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n public class AllFormulaEvalTests {\n \t\n \tpublic static Test suite() {\n-\t\tTestSuite result = new TestSuite(\"Tests for org.apache.poi.hssf.record.formula.eval\");\n+\t\tTestSuite result = new TestSuite(AllFormulaEvalTests.class.getName());\n+\t\tresult.addTestSuite(TestAreaEval.class);\n \t\tresult.addTestSuite(TestCircularReferences.class);\n \t\tresult.addTestSuite(TestExternalFunction.class);\n \t\tresult.addTestSuite(TestFormulaBugs.class);",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/eval/AllFormulaEvalTests.java",
                "sha": "8887445ad3826928e432802eca1639ac32a2e6fb",
                "status": "modified"
            },
            {
                "additions": 62,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/eval/TestAreaEval.java",
                "changes": 62,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/eval/TestAreaEval.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/eval/TestAreaEval.java",
                "patch": "@@ -0,0 +1,62 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.hssf.record.formula.eval;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.TestCase;\n+\n+import org.apache.poi.hssf.record.formula.Area3DPtg;\n+\n+/**\n+ * Tests for <tt>AreaEval</tt>\n+ *  \n+ * @author Josh Micich\n+ */\n+public final class TestAreaEval extends TestCase {\n+\n+\tpublic void testGetValue_bug44950() {\n+\t\t\n+\t\tArea3DPtg ptg = new Area3DPtg(\"B2:D3\", (short)0);\n+\t\tNumberEval one = new NumberEval(1);\n+\t\tValueEval[] values = {\n+\t\t\t\tone,\t\n+\t\t\t\tnew NumberEval(2),\t\n+\t\t\t\tnew NumberEval(3),\t\n+\t\t\t\tnew NumberEval(4),\t\n+\t\t\t\tnew NumberEval(5),\t\n+\t\t\t\tnew NumberEval(6),\t\n+\t\t};\n+\t\tAreaEval ae = new Area3DEval(ptg, values);\n+\t\tif (one == ae.getValueAt(1, 2)) {\n+\t\t\tthrow new AssertionFailedError(\"Identified bug 44950 a\");\n+\t\t}\n+\t\tconfirm(1, ae, 1, 1);\n+\t\tconfirm(2, ae, 1, 2);\n+\t\tconfirm(3, ae, 1, 3);\n+\t\tconfirm(4, ae, 2, 1);\n+\t\tconfirm(5, ae, 2, 2);\n+\t\tconfirm(6, ae, 2, 3);\n+\t\t\n+\t}\n+\n+\tprivate static void confirm(int expectedValue, AreaEval ae, int row, int col) {\n+\t\tNumberEval v = (NumberEval) ae.getValueAt(row, col);\n+\t\tassertEquals(expectedValue, v.getNumberValue(), 0.0);\n+\t}\n+\n+}",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/eval/TestAreaEval.java",
                "sha": "6c855707ba44f7391f5834bb2683b431d5512392",
                "status": "added"
            },
            {
                "additions": 80,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java",
                "changes": 85,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 5,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java",
                "patch": "@@ -61,7 +61,32 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n \tprivate static final String SOURCE_DOC_FILE_NAME = \"excelfileformat.odt\";\n \n+\t/**\n+\t * For simplicity, the output file is strictly simple ASCII.\n+\t * This method detects any unexpected characters. \n+\t */\n+\t/* package */ static boolean isSimpleAscii(char c) {\n+\t\t\n+\t\tif (c>=0x21 && c<=0x7E) {\n+\t\t\t// everything from '!' to '~' (includes letters, digits, punctuation\n+\t\t\treturn true;\n+\t\t}\n+\t\t// some specific whitespace chars below 0x21:\n+\t\tswitch(c) {\n+\t\t\tcase ' ':\n+\t\t\tcase '\\t':\n+\t\t\tcase '\\r':\n+\t\t\tcase '\\n':\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\t\n \tprivate static final class FunctionData {\n+\t\t// special characters from the ooo document\n+\t\tprivate static final int CHAR_ELLIPSIS_8230 = 8230;\n+\t\tprivate static final int CHAR_NDASH_8211 = 8211;\n \n \t\tprivate final int _index;\n \t\tprivate final boolean _hasFootnote;\n@@ -79,10 +104,30 @@ public FunctionData(int funcIx, boolean hasFootnote, String funcName, int minPar\n \t\t\t_name = funcName;\n \t\t\t_minParams = minParams;\n \t\t\t_maxParams = maxParams;\n-\t\t\t_returnClass = returnClass;\n-\t\t\t_paramClasses = paramClasses;\n+\t\t\t_returnClass = convertSpecialChars(returnClass);\n+\t\t\t_paramClasses = convertSpecialChars(paramClasses);\n \t\t\t_isVolatile = isVolatile;\n \t\t}\n+\t\tprivate static String convertSpecialChars(String ss) {\n+\t\t\tStringBuffer sb = new StringBuffer(ss.length() + 4);\n+\t\t\tfor(int i=0; i<ss.length(); i++) {\n+\t\t\t\tchar c = ss.charAt(i);\n+\t\t\t\tif (isSimpleAscii(c)) {\n+\t\t\t\t\tsb.append(c);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tswitch (c) {\n+\t\t\t\t\tcase CHAR_NDASH_8211:\n+\t\t\t\t\t\tsb.append('-');\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tcase CHAR_ELLIPSIS_8230:\n+\t\t\t\t\t\tsb.append(\"...\");\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tthrow new RuntimeException(\"bad char (\" + ((int)c) + \") in string '\" + ss + \"'\");\n+\t\t\t}\n+\t\t\treturn sb.toString();\n+\t\t}\n \t\tpublic int getIndex() {\n \t\t\treturn _index;\n \t\t}\n@@ -382,6 +427,33 @@ private static void extractFunctionData(FunctionDataCollector fdc, InputStream i\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n \t}\n+\t/**\n+\t * To be sure that no tricky unicode chars make it through to the output file.\n+\t */\n+\tprivate static final class SimpleAsciiOutputStream extends OutputStream {\n+\n+\t\tprivate final OutputStream _os;\n+\n+\t\tpublic SimpleAsciiOutputStream(OutputStream os) {\n+\t\t\t_os = os;\n+\t\t}\n+\t\tpublic void write(int b) throws IOException {\n+\t\t\tcheckByte(b);\n+\t\t\t_os.write(b);\n+\t\t}\n+\t\tprivate static void checkByte(int b) {\n+\t\t\tif (!isSimpleAscii((char)b)) {\n+\t\t\t\tthrow new RuntimeException(\"Encountered char (\" + b + \") which was not simple ascii as expected\");\n+\t\t\t}\n+\t\t}\n+\t\tpublic void write(byte[] b, int off, int len) throws IOException {\n+\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\tcheckByte(b[i + off]);\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t_os.write(b, off, len);\n+\t\t}\n+\t}\n \n \tprivate static void processFile(File effDocFile, File outFile) {\n \t\tOutputStream os;\n@@ -390,10 +462,13 @@ private static void processFile(File effDocFile, File outFile) {\n \t\t} catch (FileNotFoundException e) {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n-\t\tPrintStream ps = null;\n+\t\tos = new SimpleAsciiOutputStream(os);\n+\t\tPrintStream ps;\n \t\ttry {\n-\t\t\tps = new PrintStream(os,true, \"UTF-8\");\n-\t\t} catch(UnsupportedEncodingException e) {}\n+\t\t\tps = new PrintStream(os, true, \"UTF-8\");\n+\t\t} catch(UnsupportedEncodingException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t\t\n \t\toutputLicenseHeader(ps);\n \t\tClass genClass = ExcelFileFormatDocFunctionExtractor.class;",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/function/ExcelFileFormatDocFunctionExtractor.java",
                "sha": "47137df4f6440d3f6299e7639e3920fa28d76161",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/functions/TestCountFuncs.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/functions/TestCountFuncs.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 4,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/functions/TestCountFuncs.java",
                "patch": "@@ -67,7 +67,7 @@ public void testCountA() {\n \t\targs = new Eval[] {\n \t\t\tEvalFactory.createAreaEval(\"D1:F5\", 3, 5),\t// 15\n \t\t\tEvalFactory.createRefEval(\"A1\"),\t\n-\t\t\tEvalFactory.createAreaEval(\"A1:F6\", 7, 6),\t// 42\n+\t\t\tEvalFactory.createAreaEval(\"A1:G6\", 7, 6),\t// 42\n \t\t\tnew NumberEval(0),\n \t\t};\n \t\tconfirmCountA(59, args);\n@@ -87,7 +87,7 @@ public void testCountIf() {\n \t\t\t\tBoolEval.TRUE,\n \t\t\t\tBlankEval.INSTANCE,\n \t\t};\n-\t\trange = createAreaEval(\"A1:B2\", values);\n+\t\trange = createAreaEval(\"A1:B3\", values);\n \t\tconfirmCountIf(2, range, BoolEval.TRUE);\n \t\t\n \t\t// when criteria is numeric\n@@ -98,9 +98,8 @@ public void testCountIf() {\n \t\t\t\tnew NumberEval(2),\t\n \t\t\t\tnew NumberEval(2),\t\n \t\t\t\tBoolEval.TRUE,\n-\t\t\t\tBlankEval.INSTANCE,\n \t\t};\n-\t\trange = createAreaEval(\"A1:B2\", values);\n+\t\trange = createAreaEval(\"A1:B3\", values);\n \t\tconfirmCountIf(3, range, new NumberEval(2));\n \t\t// note - same results when criteria is a string that parses as the number with the same value\n \t\tconfirmCountIf(3, range, new StringEval(\"2.00\"));",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/functions/TestCountFuncs.java",
                "sha": "6d11e5a53a9ce2c23d7839510add3dac5d06aa4b",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/functions/TestIndex.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/formula/functions/TestIndex.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 6,
                "filename": "src/testcases/org/apache/poi/hssf/record/formula/functions/TestIndex.java",
                "patch": "@@ -14,7 +14,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n \n package org.apache.poi.hssf.record.formula.functions;\n \n@@ -33,18 +32,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public final class TestIndex extends TestCase {\n \n-\tpublic TestIndex(String testName) {\n-\t\tsuper(testName);\n-\t}\n-\t\n \tprivate static final double[] TEST_VALUES0 = {\n \t\t\t1, 2,\n \t\t\t3, 4,\n \t\t\t5, 6,\n \t\t\t7, 8,\n \t\t\t9, 10,\n \t\t\t11, 12,\n-\t\t\t13, // excess array element. TODO - Area2DEval currently has no validation to ensure correct size of values array\n \t};\n \t\n \t/**",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/record/formula/functions/TestIndex.java",
                "sha": "492d68e983b511c6aac5ba5d45cfb9296d565653",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/AllUserModelTests.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/AllUserModelTests.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 4,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/AllUserModelTests.java",
                "patch": "@@ -38,10 +38,12 @@ public static Test suite() {\n \t\tresult.addTestSuite(TestEscherGraphics2d.class);\n \t\tresult.addTestSuite(TestFontDetails.class);\n \t\tresult.addTestSuite(TestFormulas.class);\n+\t\tresult.addTestSuite(TestFormulaEvaluatorBugs.class);\n+\t\tresult.addTestSuite(TestFormulaEvaluatorDocs.class);\n \t\tresult.addTestSuite(TestHSSFCell.class);\n \t\tresult.addTestSuite(TestHSSFClientAnchor.class);\n-\t\tresult.addTestSuite(TestHSSFConditionalFormatting.class);\n \t\tresult.addTestSuite(TestHSSFComment.class);\n+\t\tresult.addTestSuite(TestHSSFConditionalFormatting.class);\n \t\tresult.addTestSuite(TestHSSFDateUtil.class);\n \t\tresult.addTestSuite(TestHSSFHeaderFooter.class);\n \t\tresult.addTestSuite(TestHSSFHyperlink.class);\n@@ -54,17 +56,19 @@ public static Test suite() {\n \t\tresult.addTestSuite(TestHSSFSheet.class);\n \t\tresult.addTestSuite(TestHSSFSheetOrder.class);\n \t\tresult.addTestSuite(TestHSSFSheetSetOrder.class);\n+\t\tresult.addTestSuite(TestHSSFTextbox.class);\n \t\tresult.addTestSuite(TestHSSFWorkbook.class);\n \t\tresult.addTestSuite(TestNamedRange.class);\n \t\tresult.addTestSuite(TestOLE2Embeding.class);\n+\t\tresult.addTestSuite(TestPOIFSProperties.class);\n \t\tresult.addTestSuite(TestReadWriteChart.class);\n \t\tresult.addTestSuite(TestSanityChecker.class);\n \t\tresult.addTestSuite(TestSheetHiding.class);\n \t\tresult.addTestSuite(TestSheetShiftRows.class);\n \t\tif (false) { // deliberately avoiding this one\n-            result.addTestSuite(TestUnfixedBugs.class);\n-        }\n-        result.addTestSuite(TestUnicodeWorkbook.class);\n+\t\t\tresult.addTestSuite(TestUnfixedBugs.class);\n+\t\t}\n+\t\tresult.addTestSuite(TestUnicodeWorkbook.class);\n \t\tresult.addTestSuite(TestUppercaseWorkbook.class);\n \t\tresult.addTestSuite(TestWorkbook.class);\t\t\n \t\t",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/AllUserModelTests.java",
                "sha": "0e18e21e52c93cf4be21916a9058f7fc101c5c3a",
                "status": "modified"
            },
            {
                "additions": 74,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestFormulaEvaluatorBugs.java",
                "changes": 132,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestFormulaEvaluatorBugs.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 58,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestFormulaEvaluatorBugs.java",
                "patch": "@@ -22,12 +22,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.Iterator;\n import java.util.List;\n \n+import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n \n import org.apache.poi.hssf.HSSFTestDataSamples;\n import org.apache.poi.hssf.record.aggregates.FormulaRecordAggregate;\n import org.apache.poi.hssf.record.formula.AreaPtg;\n import org.apache.poi.hssf.record.formula.FuncVarPtg;\n+\n /**\n  * \n  */\n@@ -51,42 +53,41 @@ protected void setUp() {\n \t */\n \tpublic void test44636() throws Exception {\n \t\t// Open the existing file, tweak one value and\n-\t\t//  re-calculate\n+\t\t// re-calculate\n \n \t\tHSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(\"44636.xls\");\n-\t\tHSSFSheet sheet = wb.getSheetAt (0);\n-\t\tHSSFRow row = sheet.getRow (0);\n+\t\tHSSFSheet sheet = wb.getSheetAt(0);\n+\t\tHSSFRow row = sheet.getRow(0);\n \n-\t\trow.getCell((short)0).setCellValue(4.2);\n-\t\trow.getCell((short)2).setCellValue(25);\n+\t\trow.getCell((short) 0).setCellValue(4.2);\n+\t\trow.getCell((short) 2).setCellValue(25);\n \n \t\tHSSFFormulaEvaluator.evaluateAllFormulaCells(wb);\n-\t\tassertEquals(4.2*25, row.getCell((short)3).getNumericCellValue(), 0.0001);\n+\t\tassertEquals(4.2 * 25, row.getCell((short) 3).getNumericCellValue(), 0.0001);\n \n \t\t// Save\n-\t\tFile existing = new File(tmpDirName,\"44636-existing.xls\");\n+\t\tFile existing = new File(tmpDirName, \"44636-existing.xls\");\n \t\tFileOutputStream out = new FileOutputStream(existing);\n \t\twb.write(out);\n \t\tout.close();\n \t\tSystem.err.println(\"Existing file for bug #44636 written to \" + existing.toString());\n \n-\n \t\t// Now, do a new file from scratch\n \t\twb = new HSSFWorkbook();\n \t\tsheet = wb.createSheet();\n \n \t\trow = sheet.createRow(0);\n-\t\trow.createCell((short)0).setCellValue(1.2);\n-\t\trow.createCell((short)1).setCellValue(4.2);\n+\t\trow.createCell((short) 0).setCellValue(1.2);\n+\t\trow.createCell((short) 1).setCellValue(4.2);\n \n \t\trow = sheet.createRow(1);\n-\t\trow.createCell((short)0).setCellFormula(\"SUM(A1:B1)\");\n+\t\trow.createCell((short) 0).setCellFormula(\"SUM(A1:B1)\");\n \n \t\tHSSFFormulaEvaluator.evaluateAllFormulaCells(wb);\n-\t\tassertEquals(5.4, row.getCell((short)0).getNumericCellValue(), 0.0001);\n+\t\tassertEquals(5.4, row.getCell((short) 0).getNumericCellValue(), 0.0001);\n \n \t\t// Save\n-\t\tFile scratch = new File(tmpDirName,\"44636-scratch.xls\");\n+\t\tFile scratch = new File(tmpDirName, \"44636-scratch.xls\");\n \t\tout = new FileOutputStream(scratch);\n \t\twb.write(out);\n \t\tout.close();\n@@ -105,62 +106,62 @@ public void test44297() {\n \t\tHSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(\"44297.xls\");\n \n \t\tHSSFRow row;\n-\t\tHSSFCell  cell;\n+\t\tHSSFCell cell;\n \n-\t\tHSSFSheet sheet   = wb.getSheetAt(0);\n+\t\tHSSFSheet sheet = wb.getSheetAt(0);\n \n \t\tHSSFFormulaEvaluator eva = new HSSFFormulaEvaluator(sheet, wb);\n \n \t\trow = sheet.getRow(0);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"31+46\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(77, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(1);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"30+53\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(83, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(2);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"SUM(A1:A2)\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(160, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(4);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"32767+32768\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(65535, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(7);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"32744+42333\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(75077, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(8);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"327680.0/32768\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(10, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(9);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"32767+32769\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(65536, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(10);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"35000+36000\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(71000, eva.evaluate(cell).getNumberValue(), 0);\n \n \t\trow = sheet.getRow(11);\n-\t\tcell = row.getCell((short)0);\n+\t\tcell = row.getCell((short) 0);\n \t\tassertEquals(\"-1000000.0-3000000.0\", cell.getCellFormula());\n \t\teva.setCurrentRow(row);\n \t\tassertEquals(-4000000, eva.evaluate(cell).getNumberValue(), 0);\n@@ -176,57 +177,55 @@ public void test44410() {\n \n \t\tHSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(\"SingleLetterRanges.xls\");\n \n-\t\tHSSFSheet sheet   = wb.getSheetAt(0);\n+\t\tHSSFSheet sheet = wb.getSheetAt(0);\n \n \t\tHSSFFormulaEvaluator eva = new HSSFFormulaEvaluator(sheet, wb);\n \n-\t\t// =index(C:C,2,1)   -> 2\n+\t\t// =index(C:C,2,1) -> 2\n \t\tHSSFRow rowIDX = sheet.getRow(3);\n-\t\t// =sum(C:C)\t\t -> 6\n+\t\t// =sum(C:C) -> 6\n \t\tHSSFRow rowSUM = sheet.getRow(4);\n-\t\t// =sum(C:D)\t\t -> 66\n+\t\t// =sum(C:D) -> 66\n \t\tHSSFRow rowSUM2D = sheet.getRow(5);\n \n \t\t// Test the sum\n-\t\tHSSFCell cellSUM = rowSUM.getCell((short)0);\n+\t\tHSSFCell cellSUM = rowSUM.getCell((short) 0);\n \n-\t\tFormulaRecordAggregate frec = \n-\t\t\t(FormulaRecordAggregate)cellSUM.getCellValueRecord();\n+\t\tFormulaRecordAggregate frec = (FormulaRecordAggregate) cellSUM.getCellValueRecord();\n \t\tList ops = frec.getFormulaRecord().getParsedExpression();\n \t\tassertEquals(2, ops.size());\n \t\tassertEquals(AreaPtg.class, ops.get(0).getClass());\n \t\tassertEquals(FuncVarPtg.class, ops.get(1).getClass());\n \n-\t\t// Actually stored as C1 to C65536 \n-\t\t//  (last row is -1 === 65535)\n-\t\tAreaPtg ptg = (AreaPtg)ops.get(0);\n+\t\t// Actually stored as C1 to C65536\n+\t\t// (last row is -1 === 65535)\n+\t\tAreaPtg ptg = (AreaPtg) ops.get(0);\n \t\tassertEquals(2, ptg.getFirstColumn());\n \t\tassertEquals(2, ptg.getLastColumn());\n \t\tassertEquals(0, ptg.getFirstRow());\n \t\tassertEquals(65535, ptg.getLastRow());\n \t\tassertEquals(\"C:C\", ptg.toFormulaString(wb));\n \n \t\t// Will show as C:C, but won't know how many\n-\t\t//  rows it covers as we don't have the sheet\n-\t\t//  to hand when turning the Ptgs into a string\n+\t\t// rows it covers as we don't have the sheet\n+\t\t// to hand when turning the Ptgs into a string\n \t\tassertEquals(\"SUM(C:C)\", cellSUM.getCellFormula());\n \t\teva.setCurrentRow(rowSUM);\n \n \t\t// But the evaluator knows the sheet, so it\n-\t\t//  can do it properly\n+\t\t// can do it properly\n \t\tassertEquals(6, eva.evaluate(cellSUM).getNumberValue(), 0);\n \n-\n \t\t// Test the index\n \t\t// Again, the formula string will be right but\n-\t\t//  lacking row count, evaluated will be right\n-\t\tHSSFCell cellIDX = rowIDX.getCell((short)0);\n+\t\t// lacking row count, evaluated will be right\n+\t\tHSSFCell cellIDX = rowIDX.getCell((short) 0);\n \t\tassertEquals(\"INDEX(C:C,2,1)\", cellIDX.getCellFormula());\n \t\teva.setCurrentRow(rowIDX);\n \t\tassertEquals(2, eva.evaluate(cellIDX).getNumberValue(), 0);\n \n \t\t// Across two colums\n-\t\tHSSFCell cellSUM2D = rowSUM2D.getCell((short)0);\n+\t\tHSSFCell cellSUM2D = rowSUM2D.getCell((short) 0);\n \t\tassertEquals(\"SUM(C:D)\", cellSUM2D.getCellFormula());\n \t\teva.setCurrentRow(rowSUM2D);\n \t\tassertEquals(66, eva.evaluate(cellSUM2D).getNumberValue(), 0);\n@@ -240,7 +239,7 @@ public void testEvaluateBooleanInCell_bug44508() {\n \t\tHSSFSheet sheet = wb.createSheet();\n \t\twb.setSheetName(0, \"Sheet1\");\n \t\tHSSFRow row = sheet.createRow(0);\n-\t\tHSSFCell cell = row.createCell((short)0);\n+\t\tHSSFCell cell = row.createCell((short) 0);\n \n \t\tcell.setCellFormula(\"1=1\");\n \n@@ -253,29 +252,46 @@ public void testEvaluateBooleanInCell_bug44508() {\n \t\t}\n \t\tassertEquals(true, cell.getBooleanCellValue());\n \t}\n-\t\n+\n \tpublic void testClassCast_bug44861() throws Exception {\n-\t\tHSSFWorkbook wb = HSSFTestDataSamples.\n-\t\t\topenSampleWorkbook(\"44861.xls\");\n-\t\t\n+\t\tHSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(\"44861.xls\");\n+\n \t\t// Check direct\n \t\tHSSFFormulaEvaluator.evaluateAllFormulaCells(wb);\n-\t\t\n+\n \t\t// And via calls\n \t\tint numSheets = wb.getNumberOfSheets();\n-\t\tfor(int i=0; i<numSheets; i++) {\n+\t\tfor (int i = 0; i < numSheets; i++) {\n \t\t\tHSSFSheet s = wb.getSheetAt(i);\n-\t\t\tHSSFFormulaEvaluator eval = new HSSFFormulaEvaluator(s,wb);\n-\t\t\t\n-\t\t\tfor(Iterator rows = s.rowIterator(); rows.hasNext();) {\n-\t\t        HSSFRow r = (HSSFRow)rows.next();\n-\t\t        eval.setCurrentRow(r);\n-\t\t        \n-\t\t        for(Iterator cells = r.cellIterator(); cells.hasNext();) {\n-\t\t        \tHSSFCell c = (HSSFCell)cells.next();\n-\t\t        \teval.evaluateFormulaCell(c);\n-\t\t        }\n+\t\t\tHSSFFormulaEvaluator eval = new HSSFFormulaEvaluator(s, wb);\n+\n+\t\t\tfor (Iterator rows = s.rowIterator(); rows.hasNext();) {\n+\t\t\t\tHSSFRow r = (HSSFRow) rows.next();\n+\t\t\t\teval.setCurrentRow(r);\n+\n+\t\t\t\tfor (Iterator cells = r.cellIterator(); cells.hasNext();) {\n+\t\t\t\t\tHSSFCell c = (HSSFCell) cells.next();\n+\t\t\t\t\teval.evaluateFormulaCell(c);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void testEvaluateInCellWithErrorCode_bug44950() {\n+\t\tHSSFWorkbook wb = new HSSFWorkbook();\n+\t\tHSSFSheet sheet = wb.createSheet(\"Sheet1\");\n+\t\tHSSFRow row = sheet.createRow(1);\n+\t\tHSSFCell cell = row.createCell((short) 0);\n+\t\tcell.setCellFormula(\"na()\"); // this formula evaluates to an Excel error code '#N/A'\n+\t\tHSSFFormulaEvaluator fe = new HSSFFormulaEvaluator(sheet, wb);\n+\t\tfe.setCurrentRow(row);\n+\t\ttry {\n+\t\t\tfe.evaluateInCell(cell);\n+\t\t} catch (NumberFormatException e) {\n+\t\t\tif (e.getMessage().equals(\"You cannot get an error value from a non-error cell\")) {\n+\t\t\t\tthrow new AssertionFailedError(\"Identified bug 44950 b\");\n \t\t\t}\n+\t\t\tthrow e;\n \t\t}\n \t}\n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestFormulaEvaluatorBugs.java",
                "sha": "349cfa8a8504b4d4cb7910eae054b3a6dc11f2f1",
                "status": "modified"
            },
            {
                "additions": 39,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFRow.java",
                "changes": 54,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFRow.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 15,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFRow.java",
                "patch": "@@ -17,11 +17,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.usermodel;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-\n import junit.framework.TestCase;\n \n+import org.apache.poi.hssf.HSSFTestDataSamples;\n+\n /**\n  * Test HSSFRow is okay.\n  *\n@@ -32,7 +31,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     public void testLastAndFirstColumns() {\n         HSSFWorkbook workbook = new HSSFWorkbook();\n         HSSFSheet sheet = workbook.createSheet();\n-        HSSFRow row = sheet.createRow((short) 0);\n+        HSSFRow row = sheet.createRow(0);\n         assertEquals(-1, row.getFirstCellNum());\n         assertEquals(-1, row.getLastCellNum());\n \n@@ -50,7 +49,35 @@ public void testLastAndFirstColumns() {\n         assertEquals(4, row.getLastCellNum());\n     }\n \n-    public void testRemoveCell() throws Exception {\n+    /**\n+     * Make sure that there is no cross-talk between rows especially with getFirstCellNum and getLastCellNum\n+     * This test was added in response to bug report 44987.\n+     */\n+    public void testBoundsInMultipleRows() {\n+        HSSFWorkbook workbook = new HSSFWorkbook();\n+        HSSFSheet sheet = workbook.createSheet();\n+        HSSFRow rowA = sheet.createRow(0);\n+\n+        rowA.createCell((short) 10);\n+        rowA.createCell((short) 5);\n+        assertEquals(5, rowA.getFirstCellNum());\n+        assertEquals(11, rowA.getLastCellNum());\n+\n+        HSSFRow rowB = sheet.createRow(1);\n+        rowB.createCell((short) 15);\n+        rowB.createCell((short) 30);\n+        assertEquals(15, rowB.getFirstCellNum());\n+        assertEquals(31, rowB.getLastCellNum());\n+\n+        assertEquals(5, rowA.getFirstCellNum());\n+        assertEquals(11, rowA.getLastCellNum());\n+        rowA.createCell((short) 50);\n+        assertEquals(51, rowA.getLastCellNum());\n+\n+        assertEquals(31, rowB.getLastCellNum());\n+    }\n+\n+    public void testRemoveCell() {\n         HSSFWorkbook workbook = new HSSFWorkbook();\n         HSSFSheet sheet = workbook.createSheet();\n         HSSFRow row = sheet.createRow((short) 0);\n@@ -76,16 +103,11 @@ public void testRemoveCell() throws Exception {\n         assertEquals(0, data[6]);\n         assertEquals(0, data[8]);\n \n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        workbook.write(baos);\n-        baos.close();\n-        ByteArrayInputStream inputStream = new ByteArrayInputStream(baos.toByteArray());\n-        workbook = new HSSFWorkbook(inputStream);\n+        workbook = HSSFTestDataSamples.writeOutAndReadBack(workbook);\n         sheet = workbook.getSheetAt(0);\n-        inputStream.close();\n \n-        assertEquals(-1, sheet.getRow((short) 0).getLastCellNum());\n-        assertEquals(-1, sheet.getRow((short) 0).getFirstCellNum());\n+        assertEquals(-1, sheet.getRow(0).getLastCellNum());\n+        assertEquals(-1, sheet.getRow(0).getFirstCellNum());\n     }\n \n     public void testMoveCell() {\n@@ -143,8 +165,9 @@ public void testRowBounds() {\n       try {\n         sheet.createRow(-1);\n         fail(\"IndexOutOfBoundsException should have been thrown\");\n-      } catch (IndexOutOfBoundsException ex) {\n+      } catch (IllegalArgumentException e) {\n         // expected during successful test\n+        assertEquals(\"Invalid row number (-1) outside allowable range (0..65535)\", e.getMessage());\n       }\n \n       //Test high row bound\n@@ -153,8 +176,9 @@ public void testRowBounds() {\n       try {\n         sheet.createRow(65536);\n         fail(\"IndexOutOfBoundsException should have been thrown\");\n-      } catch (IndexOutOfBoundsException ex) {\n+      } catch (IllegalArgumentException e) {\n         // expected during successful test\n+        assertEquals(\"Invalid row number (65536) outside allowable range (0..65535)\", e.getMessage());\n       }\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFRow.java",
                "sha": "7611abb51ce8bc3e8ec0f93449af87e0fb715a17",
                "status": "modified"
            },
            {
                "additions": 65,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "changes": 100,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 35,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "patch": "@@ -23,6 +23,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n \n+import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n \n import org.apache.poi.hssf.HSSFTestDataSamples;\n@@ -193,17 +194,29 @@ public void testRemoveRow()\n \tpublic void testCloneSheet() {\n \t\tHSSFWorkbook workbook = new HSSFWorkbook();\n \t\tHSSFSheet sheet = workbook.createSheet(\"Test Clone\");\n-\t\tHSSFRow row = sheet.createRow((short) 0);\n+\t\tHSSFRow row = sheet.createRow(0);\n \t\tHSSFCell cell = row.createCell((short) 0);\n-\t\tcell.setCellValue(\"clone_test\"); \n-\t\tHSSFSheet cloned = workbook.cloneSheet(0);\n-  \n+\t\tHSSFCell cell2 = row.createCell((short) 1);\n+\t\tcell.setCellValue(new HSSFRichTextString(\"clone_test\")); \n+\t\tcell2.setCellFormula(\"sin(1)\"); \n+\n+\t\tHSSFSheet clonedSheet = workbook.cloneSheet(0);\n+\t\tHSSFRow clonedRow = clonedSheet.getRow(0);\n+\n \t\t//Check for a good clone\n-\t\tassertEquals(cloned.getRow((short)0).getCell((short)0).getStringCellValue(), \"clone_test\");\n+\t\tassertEquals(clonedRow.getCell(0).getRichStringCellValue().getString(), \"clone_test\");\n \n \t\t//Check that the cells are not somehow linked\n-\t\tcell.setCellValue(\"Difference Check\");\n-\t\tassertEquals(cloned.getRow((short)0).getCell((short)0).getStringCellValue(), \"clone_test\");\n+\t\tcell.setCellValue(new HSSFRichTextString(\"Difference Check\"));\n+\t\tcell2.setCellFormula(\"cos(2)\");\n+\t\tif (\"Difference Check\".equals(clonedRow.getCell(0).getRichStringCellValue().getString())) {\n+\t\t\tfail(\"string cell not properly cloned\");\n+\t\t}\n+\t\tif (\"COS(2)\".equals(clonedRow.getCell(1).getCellFormula())) {\n+\t\t\tfail(\"formula cell not properly cloned\");\n+\t\t}\n+\t\tassertEquals(clonedRow.getCell(0).getRichStringCellValue().getString(), \"clone_test\");\n+\t\tassertEquals(clonedRow.getCell(1).getCellFormula(), \"SIN(1)\");\n \t}\n \n \t/** tests that the sheet name for multiple clones of the same sheet is unique\n@@ -214,7 +227,7 @@ public void testCloneSheetMultipleTimes() {\n \t\tHSSFSheet sheet = workbook.createSheet(\"Test Clone\");\n \t\tHSSFRow row = sheet.createRow((short) 0);\n \t\tHSSFCell cell = row.createCell((short) 0);\n-\t\tcell.setCellValue(\"clone_test\");\n+\t\tcell.setCellValue(new HSSFRichTextString(\"clone_test\"));\n \t\t//Clone the sheet multiple times\n \t\tworkbook.cloneSheet(0);\n \t\tworkbook.cloneSheet(0);\n@@ -517,11 +530,11 @@ public void testShiftMerged() {\n \t\tHSSFSheet sheet = wb.createSheet();\n \t\tHSSFRow row = sheet.createRow(0);\n \t\tHSSFCell cell = row.createCell((short)0);\n-\t\tcell.setCellValue(\"first row, first cell\");\n+\t\tcell.setCellValue(new HSSFRichTextString(\"first row, first cell\"));\n \n \t\trow = sheet.createRow(1);\n \t\tcell = row.createCell((short)1);\n-\t\tcell.setCellValue(\"second row, second cell\");\n+\t\tcell.setCellValue(new HSSFRichTextString(\"second row, second cell\"));\n \n \t\tRegion region = new Region(1, (short)0, 1, (short)1);   \n \t\tsheet.addMergedRegion(region);\n@@ -643,28 +656,28 @@ public void testTopRow() {\n \n \t/** cell with formula becomes null on cloning a sheet*/\n \t public void test35084() {\n-   \n-   \tHSSFWorkbook wb = new HSSFWorkbook();\n-   \tHSSFSheet s =wb.createSheet(\"Sheet1\");\n-   \tHSSFRow r = s.createRow(0);\n-   \tr.createCell((short)0).setCellValue(1);\n-   \tr.createCell((short)1).setCellFormula(\"A1*2\");\n-   \tHSSFSheet s1 = wb.cloneSheet(0);\n-   \tr=s1.getRow(0);\n-   \tassertEquals(\"double\" ,r.getCell((short)0).getNumericCellValue(),(double)1,0); //sanity check\n-   \tassertNotNull(r.getCell((short)1)); \n-   \tassertEquals(\"formula\", r.getCell((short)1).getCellFormula(), \"A1*2\");\n-   }\n+\n+\t\tHSSFWorkbook wb = new HSSFWorkbook();\n+\t\tHSSFSheet s = wb.createSheet(\"Sheet1\");\n+\t\tHSSFRow r = s.createRow(0);\n+\t\tr.createCell((short) 0).setCellValue(1);\n+\t\tr.createCell((short) 1).setCellFormula(\"A1*2\");\n+\t\tHSSFSheet s1 = wb.cloneSheet(0);\n+\t\tr = s1.getRow(0);\n+\t\tassertEquals(\"double\", r.getCell((short) 0).getNumericCellValue(), 1, 0); // sanity check\n+\t\tassertNotNull(r.getCell((short) 1));\n+\t\tassertEquals(\"formula\", r.getCell((short) 1).getCellFormula(), \"A1*2\");\n+\t}\n \n \t/** test that new default column styles get applied */\n \tpublic void testDefaultColumnStyle() {\n-\tHSSFWorkbook wb = new HSSFWorkbook();\n-\tHSSFCellStyle style = wb.createCellStyle();\n-\tHSSFSheet s = wb.createSheet();\n-\ts.setDefaultColumnStyle((short)0, style);\n-\tHSSFRow r = s.createRow(0);\n-\tHSSFCell c = r.createCell((short)0);\n-\tassertEquals(\"style should match\", style.getIndex(), c.getCellStyle().getIndex());\n+\t\tHSSFWorkbook wb = new HSSFWorkbook();\n+\t\tHSSFCellStyle style = wb.createCellStyle();\n+\t\tHSSFSheet s = wb.createSheet();\n+\t\ts.setDefaultColumnStyle((short) 0, style);\n+\t\tHSSFRow r = s.createRow(0);\n+\t\tHSSFCell c = r.createCell((short) 0);\n+\t\tassertEquals(\"style should match\", style.getIndex(), c.getCellStyle().getIndex());\n \t}\n \n \n@@ -814,11 +827,6 @@ public void testForceRecalculation() throws Exception {\n \t\tassertTrue(wb3.getSheetAt(3).getForceFormulaRecalculation());\n \t}\n \n-\n-\tpublic static void main(java.lang.String[] args) {\n-\t\t junit.textui.TestRunner.run(TestHSSFSheet.class);\n-\t}\n-\n \tpublic void testColumnWidth() throws Exception {\n \t\t//check we can correctly read column widths from a reference workbook\n \t\tHSSFWorkbook wb = openSample(\"colwidth.xls\");\n@@ -870,11 +878,33 @@ public void testColumnWidth() throws Exception {\n \t\tassertEquals(256*10, sh.getColumnWidth((short)0));\n \t\tassertEquals(256*10, sh.getColumnWidth((short)1));\n \t\tassertEquals(256*10, sh.getColumnWidth((short)2));\n-\t\t//columns D-F have custom wodth\n+\t\t//columns D-F have custom width\n \t\tfor (char i = 'D'; i <= 'F'; i++) {\n \t\t\tshort w = (short)(256*12);\n \t\t\tassertEquals(w, sh.getColumnWidth((short)i));\n \t\t}\n+\t}\n+\t\n+\t/**\n+\t * Some utilities write Excel files without the ROW records.\n+\t * Excel, ooo, and google docs are OK with this.\n+\t * Now POI is too.\n+\t */\n+\tpublic void testMissingRowRecords_bug41187() {\n+\t\tHSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(\"ex41187-19267.xls\");\n \n+\t\tHSSFSheet sheet = wb.getSheetAt(0);\n+\t\tHSSFRow row = sheet.getRow(0);\n+\t\tif(row == null) {\n+\t\t\tthrow new AssertionFailedError(\"Identified bug 41187 a\");\n+\t\t}\n+\t\tif (row.getHeight() == 0) {\n+\t\t\tthrow new AssertionFailedError(\"Identified bug 41187 b\");\n+\t\t}\n+\t\tassertEquals(\"Hi Excel!\", row.getCell(0).getRichStringCellValue().getString());\n+\t\t// check row height for 'default' flag\n+\t\tassertEquals((short)0x8000, row.getHeight());\n+\t\t\n+\t\tHSSFTestDataSamples.writeOutAndReadBack(wb);\n \t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "sha": "7599f2a16621d7be45d2ed17f64618319b9cd60f",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFWorkbook.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFWorkbook.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 7,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFWorkbook.java",
                "patch": "@@ -147,9 +147,10 @@ public void testReadWriteWithCharts() {\n         // Single chart, two sheets\n         b = openSample(\"44010-SingleChart.xls\");\n         assertEquals(2, b.getNumberOfSheets());\n+        assertEquals(\"Graph2\", b.getSheetName(1));\n         s = b.getSheetAt(1);\n         assertEquals(0, s.getFirstRowNum());\n-        assertEquals(0, s.getLastRowNum());\n+        assertEquals(8, s.getLastRowNum());\n         \n         // Has chart on 1st sheet??\n         // FIXME\n@@ -166,7 +167,7 @@ public void testReadWriteWithCharts() {\n         assertEquals(2, b.getNumberOfSheets());\n         s = b.getSheetAt(1);\n         assertEquals(0, s.getFirstRowNum());\n-        assertEquals(0, s.getLastRowNum());\n+        assertEquals(8, s.getLastRowNum());\n \n         \n         // Two charts, three sheets\n@@ -175,10 +176,10 @@ public void testReadWriteWithCharts() {\n         \n         s = b.getSheetAt(1);\n         assertEquals(0, s.getFirstRowNum());\n-        assertEquals(0, s.getLastRowNum());\n+        assertEquals(8, s.getLastRowNum());\n         s = b.getSheetAt(2);\n         assertEquals(0, s.getFirstRowNum());\n-        assertEquals(0, s.getLastRowNum());\n+        assertEquals(8, s.getLastRowNum());\n         \n         // Has chart on 1st sheet??\n         // FIXME\n@@ -197,13 +198,13 @@ public void testReadWriteWithCharts() {\n         \n         s = b.getSheetAt(1);\n         assertEquals(0, s.getFirstRowNum());\n-        assertEquals(0, s.getLastRowNum());\n+        assertEquals(8, s.getLastRowNum());\n         s = b.getSheetAt(2);\n         assertEquals(0, s.getFirstRowNum());\n-        assertEquals(0, s.getLastRowNum());\n+        assertEquals(8, s.getLastRowNum());\n     }\n     \n     private static HSSFWorkbook writeRead(HSSFWorkbook b) {\n-    \treturn HSSFTestDataSamples.writeOutAndReadBack(b);\n+        return HSSFTestDataSamples.writeOutAndReadBack(b);\n     }\n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFWorkbook.java",
                "sha": "75ac6923a9a22a516a0af7a685c32e20a14a04ed",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/data/ShortLastBlock.qwp",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/data/ShortLastBlock.qwp?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/poifs/data/ShortLastBlock.qwp",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/data/ShortLastBlock.qwp",
                "sha": "b278d06c205904f3ce982f49693badf9a29696f1",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/data/ShortLastBlock.wps",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/data/ShortLastBlock.wps?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/poifs/data/ShortLastBlock.wps",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/data/ShortLastBlock.wps",
                "sha": "1b1a627a998094870e92231ca6b0bf94f56e2a65",
                "status": "added"
            },
            {
                "additions": 37,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/filesystem/TestPOIFSFileSystem.java",
                "changes": 37,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/filesystem/TestPOIFSFileSystem.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/poifs/filesystem/TestPOIFSFileSystem.java",
                "patch": "@@ -17,6 +17,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.poifs.filesystem;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n \n@@ -115,6 +118,40 @@ public void testAlwaysClose() {\n \t\tassertTrue(\"input stream was not closed\", testIS.isClosed()); // but still should close\n \t\t\n \t}\n+\t\n+\t/**\n+\t * Test for bug # 48898 - problem opening an OLE2\n+\t *  file where the last block is short (i.e. not a full\n+\t *  multiple of 512 bytes)\n+\t *  \n+\t * As yet, this problem remains. One school of thought is\n+\t *  not not issue an EOF when we discover the last block\n+\t *  is short, but this seems a bit wrong.\n+\t * The other is to fix the handling of the last block in\n+\t *  POIFS, since it seems to be slight wrong\n+\t */\n+\tpublic void DISABLEDtestShortLastBlock() throws Exception {\n+\t\tString[] files = new String[] {\n+\t\t\t\"ShortLastBlock.qwp\", \"ShortLastBlock.wps\"\t\n+\t\t};\n+\t\tString pdirname = System.getProperty(\"POIFS.testdata.path\");\n+\n+\t\tfor(int i=0; i<files.length; i++) {\n+\t\t\tFile f = new File(pdirname, files[i]);\n+\t\t\tassertTrue(f.exists());\n+\t\t\t\n+\t\t\t// Open the file up\n+\t\t\tPOIFSFileSystem fs = new POIFSFileSystem(\n+\t\t\t\t\tnew FileInputStream(f)\n+\t\t\t);\n+\t\t\t\n+\t\t\t// Write it into a temp output array\n+\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\t\tfs.writeFilesystem(baos);\n+\t\t\t\n+\t\t\t// Check sizes\n+\t\t}\n+\t}\n \n \tprivate static InputStream openSampleStream(String sampleFileName) {\n \t\treturn HSSFTestDataSamples.openSampleFileStream(sampleFileName);",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/filesystem/TestPOIFSFileSystem.java",
                "sha": "1cde86918b9623a6105ff51ff1f187d69b96bc6a",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/storage/TestRawDataBlock.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/storage/TestRawDataBlock.java?ref=8f9f5b0065db47207d4541091bd197ec96f49890",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/poifs/storage/TestRawDataBlock.java",
                "patch": "@@ -152,7 +152,7 @@ public void testShortConstructor() throws Exception\n \t            }\n \t            \n \t            assertEquals(\n-\t            \t\t\"7 - Unable to read entire block; \"+bts+\" read before EOF; expected 512 bytes. Your document has probably been truncated!\", \n+\t            \t\t\"7 - Unable to read entire block; \"+bts+\" read before EOF; expected 512 bytes. Your document was either written by software that ignores the spec, or has been truncated!\", \n \t            \t\t(String)(logger.logged.get(0))\n \t            );\n             } else {",
                "raw_url": "https://github.com/apache/poi/raw/8f9f5b0065db47207d4541091bd197ec96f49890/src/testcases/org/apache/poi/poifs/storage/TestRawDataBlock.java",
                "sha": "a4cdb734a602f71bd309bbf4bbdec7ba9067a2d1",
                "status": "modified"
            }
        ],
        "message": "Merged revisions 638786-638802,638805-638811,638813-638814,638816-639230,639233-639241,639243-639253,639255-639486,639488-639601,639603-639835,639837-639917,639919-640056,640058-640710,640712-641156,641158-641184,641186-641795,641797-641798,641800-641933,641935-641963,641965-641966,641968-641995,641997-642230,642232-642562,642564-642565,642568-642570,642572-642573,642576-642736,642739-642877,642879,642881-642890,642892-642903,642905-642945,642947-643624,643626-643653,643655-643669,643671,643673-643830,643832-643833,643835-644342,644344-644472,644474-644508,644510-645347,645349-645351,645353-645559,645561-645565,645568-645951,645953-646193,646195-646311,646313-646404,646406-646665,646667-646853,646855-646869,646871-647151,647153-647185,647187-647277,647279-647566,647568-647573,647575,647578-647711,647714-647737,647739-647823,647825-648155,648157-648202,648204-648273,648275,648277-648302,648304-648333,648335-648588,648590-648622,648625-648673,648675-649141,649144,649146-649556,649558-649795,649799,649801-649910,649912-649913,649915-650128,650131-650132,650134-650137,650140-650914,650916-651991,651993-652284,652286-652287,652289,652291,652293-652297,652299-652328,652330-652425,652427-652445,652447-652560,652562-652933,652935,652937-652993,652995-653116,653118-653124,653126-653483,653487-653519,653522-653550,653552-653607,653609-653667,653669-653674,653676-653814,653817-653830,653832-657131 via svnmerge from \nhttps://svn.apache.org:443/repos/asf/poi/trunk\n\n........\n  r653892 | josh | 2008-05-06 20:48:55 +0100 (Tue, 06 May 2008) | 1 line\n  \n  Another attempt to fix unicode problems in functionMetadata.txt.  Made that file pure ascii.\n........\n  r653945 | nick | 2008-05-06 23:51:28 +0100 (Tue, 06 May 2008) | 1 line\n  \n  Add disabled test for bug #44898, and slightly improve a few poifs related error messages\n........\n  r654056 | nick | 2008-05-07 10:41:03 +0100 (Wed, 07 May 2008) | 1 line\n  \n  Update a test to match the new warning on short files\n........\n  r654356 | josh | 2008-05-08 01:52:05 +0100 (Thu, 08 May 2008) | 1 line\n  \n  44950 - fixed HSSFFormulaEvaluator.evaluateInCell() and Area3DEval.getValue() also added validation for number of elements in AreaEvals\n........\n  r654366 | josh | 2008-05-08 02:06:56 +0100 (Thu, 08 May 2008) | 1 line\n  \n  tiny clean-up after r654356 (bug 44950)\n........\n  r654649 | josh | 2008-05-09 00:02:43 +0100 (Fri, 09 May 2008) | 1 line\n  \n  fixed mistake in FuncPtg.clone(), added test case, cleaned up outdated (since bug 13292) test method.\n........\n  r654650 | josh | 2008-05-09 00:06:30 +0100 (Fri, 09 May 2008) | 1 line\n  \n  removed unused constructor and old comment after r654649\n........\n  r655216 | josh | 2008-05-11 02:30:56 +0100 (Sun, 11 May 2008) | 1 line\n  \n  bug 23630 - fixed spelling mistake in constant name \n........\n  r655278 | josh | 2008-05-11 09:15:39 +0100 (Sun, 11 May 2008) | 1 line\n  \n  41187 - fixed HSSFSheet to properly read xls files without ROW records\n........\n  r655282 | yegor | 2008-05-11 10:03:24 +0100 (Sun, 11 May 2008) | 1 line\n  \n   Added boolean flag to turn on use of merged columns in autosize\n........\n  r655912 | josh | 2008-05-13 16:25:51 +0100 (Tue, 13 May 2008) | 1 line\n  \n  added test case for reported bug 44987\n........\n  r656213 | yegor | 2008-05-14 11:15:00 +0100 (Wed, 14 May 2008) | 1 line\n  \n  properly update TextSpecInfoAtom when parent text is changed\n........\n  r656215 | yegor | 2008-05-14 11:18:00 +0100 (Wed, 14 May 2008) | 1 line\n  \n  Support for embedded ActiveX objects: PowerPoint references them similar to embedded documents but in a different container: ExControl instead of ExEmbed\n........\n  r656252 | yegor | 2008-05-14 13:42:30 +0100 (Wed, 14 May 2008) | 1 line\n  \n  convert line breaks into internal ppt represenatation when changing text\n........\n  r656699 | yegor | 2008-05-15 16:23:38 +0100 (Thu, 15 May 2008) | 1 line\n  \n  added a set accessor for embedded ole data\n........\n  r656757 | josh | 2008-05-15 18:49:23 +0100 (Thu, 15 May 2008) | 1 line\n  \n  bug 45000 - Fixed NPE in ListLevel when numberText is null\n........\n  r656893 | josh | 2008-05-16 00:30:08 +0100 (Fri, 16 May 2008) | 1 line\n  \n  44523 - fixed workbook sheet selection and focus\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/ooxml@657135 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/fa33841f96bb4073eb4f784ebed66ef4f7568ad4",
        "patched_files": [
            "AllFormulaEvalTests.java",
            "RawDataBlock.java",
            "Cell.java",
            "BlockListImpl.java",
            "ExEmbed.java",
            "Sheet.java",
            "WindowOneRecord.java",
            "ExControl.java",
            "HSSFRow.java",
            "release-guide.java",
            "FuncPtg.java",
            "ex41187-19267.java",
            "TextSpecInfoAtom.java",
            "FunctionMetadataReader.java",
            "status.java",
            "HSSFWorkbook.java",
            "TextRun.java",
            "functionMetadata-asGenerated.java",
            "HSSFCell.java",
            "RowRecordsAggregate.java",
            "AreaEvalBase.java",
            "changes.java",
            "ShapeFactory.java",
            "PaneRecord.java",
            "AreaEval.java",
            "Area2DEval.java",
            "DataExtraction.java",
            "functionMetadata.java",
            "AllModelTests.java",
            "AllUserModelTests.java",
            "FormulaEvaluator.java",
            "ListLevel.java",
            "ExControlAtom.java",
            "RichTextRun.java",
            "WindowTwoRecord.java",
            "ExOleObjStg.java",
            "ObjectData.java",
            "Index.java",
            "pane_record.java",
            "Area3DEval.java",
            "HSSFSheet.java",
            "POIFSFileSystem.java",
            "HSSFTests.java",
            "ExcelFileFormatDocFunctionExtractor.java",
            "ShortLastBlock.java",
            "RowRecord.java",
            "RecordTypes.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestRecordTypes.java",
            "TestTextSpecInfoAtom.java",
            "TestPOIFSFileSystem.java",
            "TestTextRun.java",
            "TestRichTextRun.java",
            "TestHSSFSheet.java",
            "TestHSSFWorkbook.java",
            "TestAreaEval.java",
            "TestFormulaEvaluatorBugs.java",
            "TestExOleObjStg.java",
            "TestRawDataBlock.java",
            "TestFuncPtg.java",
            "TestHSSFRow.java",
            "TestSheet.java",
            "TestExControl.java",
            "TestCountFuncs.java",
            "TestHSSFCell.java",
            "TestSheetAdditional.java",
            "TestIndex.java",
            "TestRowRecordsAggregate.java",
            "TestPaneRecord.java"
        ]
    },
    "poi_920c7d5": {
        "bug_id": "poi_920c7d5",
        "commit": "https://github.com/apache/poi/commit/920c7d59888a19ebe689c4ed7e960b4289c1ff8c",
        "file": [
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/920c7d59888a19ebe689c4ed7e960b4289c1ff8c/src/testcases/org/apache/poi/hssf/record/TestExternalNameRecord.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/TestExternalNameRecord.java?ref=920c7d59888a19ebe689c4ed7e960b4289c1ff8c",
                "deletions": 3,
                "filename": "src/testcases/org/apache/poi/hssf/record/TestExternalNameRecord.java",
                "patch": "@@ -17,11 +17,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.hssf.record;\n \n-import org.apache.poi.util.HexRead;\n-import org.apache.poi.util.HexDump;\n-\n import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n+\n+import org.apache.poi.util.HexDump;\n+import org.apache.poi.util.HexRead;\n /**\n  *\n  * @author Josh Micich\n@@ -68,6 +68,8 @@ public void testBasicSize() {\n \t\t\tthrow new AssertionFailedError(\"Identified bug 44695\");\n \t\t}\n \t\tassertEquals(17, enr.getRecordSize());\n+\t\t\n+\t\tassertNotNull(enr.serialize());\t\t\n \t}\n \n \tpublic void testAutoStdDocName() {\n@@ -172,4 +174,18 @@ public void test48339() {\n         byte[] ser = enr.serialize();\n         assertEquals(HexDump.toHex(data), HexDump.toHex(ser));\n     }\n+    \n+    public void testNPEWithFileFrom49219() {\n+        // the file at test-data/spreadsheet/49219.xls has ExternalNameRecords without actual data, \n+    \t// we did handle this during reading, but failed during serializing this out, ensure it works now\n+        byte[] data = new byte[] {\n+        \t\t2, 127, 0, 0, 0, 0, \n+        \t\t9, 0, 82, 97, 116, 101, 95, 68, 97, 116, 101};\n+\n+\t\tExternalNameRecord enr = createSimpleENR(data);\n+\n+        byte[] ser = enr.serialize();\n+        assertEquals(\"[23, 00, 11, 00, 02, 7F, 00, 00, 00, 00, 09, 00, 52, 61, 74, 65, 5F, 44, 61, 74, 65]\", \n+        \t\tHexDump.toHex(ser));\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/920c7d59888a19ebe689c4ed7e960b4289c1ff8c/src/testcases/org/apache/poi/hssf/record/TestExternalNameRecord.java",
                "sha": "54042ba00611e6ed1d72818442654253f4650275",
                "status": "modified"
            }
        ],
        "message": "Add a test for spreadsheet/49219.xls which previously failed with NullPointerException because we did not handle serializing ExternalNameRecords without actual data\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1647212 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e67b008ce8da523864eb52aa50e44e4be5240552",
        "patched_files": [
            "ExternalNameRecord.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestExternalNameRecord.java"
        ]
    },
    "poi_93e1ccd": {
        "bug_id": "poi_93e1ccd",
        "commit": "https://github.com/apache/poi/commit/93e1ccd36b21d32234bc04198a2592cb48187919",
        "file": [
            {
                "additions": 313,
                "blob_url": "https://github.com/apache/poi/blob/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/java/org/apache/poi/xssf/model/StylesTable.java",
                "changes": 637,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/model/StylesTable.java?ref=93e1ccd36b21d32234bc04198a2592cb48187919",
                "deletions": 324,
                "filename": "src/ooxml/java/org/apache/poi/xssf/model/StylesTable.java",
                "patch": "@@ -24,6 +24,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.Enumeration;\n import java.util.Hashtable;\n import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map.Entry;\n \n import org.apache.poi.ss.usermodel.CellStyle;\n@@ -54,149 +55,148 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.STPatternType;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.StyleSheetDocument;\n \n-\n /**\n  * Table of styles shared across all sheets in a workbook.\n  *\n- * @version $Id: SharedStringsTable.java 612495 2008-01-16 16:08:22Z ugo $\n+ * @author ugo\n  */\n public class StylesTable implements StylesSource, XSSFModel {\n-    private final Hashtable<Long,String> numberFormats = new Hashtable<Long,String>();\n-    private final ArrayList<CTFont> fonts = new ArrayList<CTFont>();\n-    private final LinkedList<CTFill> fills = new LinkedList<CTFill>();\n-    private final LinkedList<CTBorder> borders = new LinkedList<CTBorder>();\n-    private final LinkedList<CTXf> styleXfs = new LinkedList<CTXf>();\n-    private final LinkedList<CTXf> xfs = new LinkedList<CTXf>();\n-\n-    private final LinkedList<CTDxf> dxfs = new LinkedList<CTDxf>();\n-\n-    /**\n-     * The first style id available for use as a custom style\n-     */\n-    public static final long FIRST_CUSTOM_STYLE_ID = 165;\n-\n-    private StyleSheetDocument doc;\n-\n-    /**\n-     * Create a new StylesTable, by reading it from\n-     *  the InputStream of a a PackagePart.\n-     *\n-     * @param is The input stream containing the XML document.\n-     * @throws IOException if an error occurs while reading.\n-     */\n-    public StylesTable(InputStream is) throws IOException {\n-        readFrom(is);\n-    }\n-    /**\n-     * Create a new, empty StylesTable\n-     */\n-    public StylesTable() {\n-    \tdoc = StyleSheetDocument.Factory.newInstance();\n-    \tdoc.addNewStyleSheet();\n-    \t// Initialization required in order to make the document readable by MSExcel\n-    \tinitialize();\n-    }\n-\n-    /**\n-     * Read this shared styles table from an XML file.\n-     *\n-     * @param is The input stream containing the XML document.\n-     * @throws IOException if an error occurs while reading.\n-     */\n-    public void readFrom(InputStream is) throws IOException {\n-        try {\n-            doc = StyleSheetDocument.Factory.parse(is);\n-            // Grab all the different bits we care about\n-            if(doc.getStyleSheet().getNumFmts() != null)\n-        \tfor (CTNumFmt nfmt : doc.getStyleSheet().getNumFmts().getNumFmtArray()) {\n-        \t    numberFormats.put(nfmt.getNumFmtId(), nfmt.getFormatCode());\n-        \t}\n-            if(doc.getStyleSheet().getFonts() != null)\n-        \tfor (CTFont font : doc.getStyleSheet().getFonts().getFontArray()) {\n-        \t    fonts.add(font);\n-        \t}\n-            if(doc.getStyleSheet().getFills() != null)\n-        \tfor (CTFill fill : doc.getStyleSheet().getFills().getFillArray()) {\n-        \t    fills.add(fill);\n-        \t}\n-            if(doc.getStyleSheet().getBorders() != null)\n-        \tfor (CTBorder border : doc.getStyleSheet().getBorders().getBorderArray()) {\n-        \t    borders.add(border);\n-        \t}\n-            if(doc.getStyleSheet().getCellXfs() != null)\n-        \tfor (CTXf xf : doc.getStyleSheet().getCellXfs().getXfArray()) {\n-        \t    xfs.add(xf);\n-        \t}\n-            if(doc.getStyleSheet().getCellStyleXfs() != null)\n-        \tfor (CTXf xf : doc.getStyleSheet().getCellStyleXfs().getXfArray()) {\n-        \t    styleXfs.add(xf);\n-        \t}\n-            // dxf\n-            if(doc.getStyleSheet().getDxfs() != null)\n-        \tfor (CTDxf dxf : doc.getStyleSheet().getDxfs().getDxfArray()) {\n-        \t    dxfs.add(dxf);\n-        \t}\n-\n-        } catch (XmlException e) {\n-            throw new IOException(e.getLocalizedMessage());\n-        }\n-    }\n-\n-    // ===========================================================\n-    //  Start of style related getters and setters\n-    // ===========================================================\n-\n-    public String getNumberFormatAt(long idx) {\n-        return numberFormats.get(idx);\n-    }\n-    public synchronized long putNumberFormat(String fmt) {\n-        if (numberFormats.containsValue(fmt)) {\n-        \t// Find the key, and return that\n-        \tfor(Enumeration<Long> keys = numberFormats.keys(); keys.hasMoreElements();) {\n-        \t\tLong key = keys.nextElement();\n-        \t\tif(numberFormats.get(key).equals(fmt)) {\n-        \t\t\treturn key;\n-        \t\t}\n-        \t}\n-        \tthrow new IllegalStateException(\"Found the format, but couldn't figure out where - should never happen!\");\n-        }\n-\n-        // Find a spare key, and add that\n-        long newKey = FIRST_CUSTOM_STYLE_ID;\n-        while(numberFormats.containsKey(newKey)) {\n-        \tnewKey++;\n-        }\n-        numberFormats.put(newKey, fmt);\n-        return newKey;\n-    }\n-\n-    public Font getFontAt(long idx) {\n-    \treturn new XSSFFont(fonts.get((int) idx));\n-    }\n-\n-    public synchronized long putFont(Font font) {\n-    \treturn putFont((XSSFFont)font, fonts);\n-    }\n+\tprivate final Hashtable<Long,String> numberFormats = new Hashtable<Long,String>();\n+\tprivate final List<CTFont> fonts = new ArrayList<CTFont>();\n+\tprivate final List<CTFill> fills = new LinkedList<CTFill>();\n+\tprivate final List<CTBorder> borders = new LinkedList<CTBorder>();\n+\tprivate final List<CTXf> styleXfs = new LinkedList<CTXf>();\n+\tprivate final List<CTXf> xfs = new LinkedList<CTXf>();\n+\n+\tprivate final List<CTDxf> dxfs = new LinkedList<CTDxf>();\n+\n+\t/**\n+\t * The first style id available for use as a custom style\n+\t */\n+\tpublic static final long FIRST_CUSTOM_STYLE_ID = 165;\n+\n+\tprivate StyleSheetDocument doc;\n+\n+\t/**\n+\t * Create a new StylesTable, by reading it from\n+\t *  the InputStream of a a PackagePart.\n+\t *\n+\t * @param is The input stream containing the XML document.\n+\t * @throws IOException if an error occurs while reading.\n+\t */\n+\tpublic StylesTable(InputStream is) throws IOException {\n+\t\treadFrom(is);\n+\t}\n+\t/**\n+\t * Create a new, empty StylesTable\n+\t */\n+\tpublic StylesTable() {\n+\t\tdoc = StyleSheetDocument.Factory.newInstance();\n+\t\tdoc.addNewStyleSheet();\n+\t\t// Initialization required in order to make the document readable by MSExcel\n+\t\tinitialize();\n+\t}\n+\n+\t/**\n+\t * Read this shared styles table from an XML file.\n+\t *\n+\t * @param is The input stream containing the XML document.\n+\t * @throws IOException if an error occurs while reading.\n+\t */\n+\tpublic void readFrom(InputStream is) throws IOException {\n+\t\ttry {\n+\t\t\tdoc = StyleSheetDocument.Factory.parse(is);\n+\t\t\t// Grab all the different bits we care about\n+\t\t\tif(doc.getStyleSheet().getNumFmts() != null)\n+\t\t\tfor (CTNumFmt nfmt : doc.getStyleSheet().getNumFmts().getNumFmtArray()) {\n+\t\t\t\tnumberFormats.put(nfmt.getNumFmtId(), nfmt.getFormatCode());\n+\t\t\t}\n+\t\t\tif(doc.getStyleSheet().getFonts() != null)\n+\t\t\tfor (CTFont font : doc.getStyleSheet().getFonts().getFontArray()) {\n+\t\t\t\tfonts.add(font);\n+\t\t\t}\n+\t\t\tif(doc.getStyleSheet().getFills() != null)\n+\t\t\tfor (CTFill fill : doc.getStyleSheet().getFills().getFillArray()) {\n+\t\t\t\tfills.add(fill);\n+\t\t\t}\n+\t\t\tif(doc.getStyleSheet().getBorders() != null)\n+\t\t\tfor (CTBorder border : doc.getStyleSheet().getBorders().getBorderArray()) {\n+\t\t\t\tborders.add(border);\n+\t\t\t}\n+\t\t\tif(doc.getStyleSheet().getCellXfs() != null)\n+\t\t\tfor (CTXf xf : doc.getStyleSheet().getCellXfs().getXfArray()) {\n+\t\t\t\txfs.add(xf);\n+\t\t\t}\n+\t\t\tif(doc.getStyleSheet().getCellStyleXfs() != null)\n+\t\t\tfor (CTXf xf : doc.getStyleSheet().getCellStyleXfs().getXfArray()) {\n+\t\t\t\tstyleXfs.add(xf);\n+\t\t\t}\n+\t\t\t// dxf\n+\t\t\tif(doc.getStyleSheet().getDxfs() != null)\n+\t\t\tfor (CTDxf dxf : doc.getStyleSheet().getDxfs().getDxfArray()) {\n+\t\t\t\tdxfs.add(dxf);\n+\t\t\t}\n+\n+\t\t} catch (XmlException e) {\n+\t\t\tthrow new IOException(e.getLocalizedMessage());\n+\t\t}\n+\t}\n+\n+\t// ===========================================================\n+\t//  Start of style related getters and setters\n+\t// ===========================================================\n+\n+\tpublic String getNumberFormatAt(long idx) {\n+\t\treturn numberFormats.get(idx);\n+\t}\n+\tpublic synchronized long putNumberFormat(String fmt) {\n+\t\tif (numberFormats.containsValue(fmt)) {\n+\t\t\t// Find the key, and return that\n+\t\t\tfor(Enumeration<Long> keys = numberFormats.keys(); keys.hasMoreElements();) {\n+\t\t\t\tLong key = keys.nextElement();\n+\t\t\t\tif(numberFormats.get(key).equals(fmt)) {\n+\t\t\t\t\treturn key;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthrow new IllegalStateException(\"Found the format, but couldn't figure out where - should never happen!\");\n+\t\t}\n+\n+\t\t// Find a spare key, and add that\n+\t\tlong newKey = FIRST_CUSTOM_STYLE_ID;\n+\t\twhile(numberFormats.containsKey(newKey)) {\n+\t\t\tnewKey++;\n+\t\t}\n+\t\tnumberFormats.put(newKey, fmt);\n+\t\treturn newKey;\n+\t}\n+\n+\tpublic Font getFontAt(long idx) {\n+\t\treturn new XSSFFont(fonts.get((int) idx));\n+\t}\n+\n+\tpublic synchronized long putFont(Font font) {\n+\t\treturn putFont((XSSFFont)font, fonts);\n+\t}\n \n \tpublic XSSFCellStyle getStyleAt(long idx) {\n-    \tint styleXfId = 0;\n+\t\tint styleXfId = 0;\n \n-    \t// 0 is the empty default\n-    \tif(xfs.get((int) idx).getXfId() > 0) {\n-    \t\tstyleXfId = (int) xfs.get((int) idx).getXfId();\n-    \t}\n+\t\t// 0 is the empty default\n+\t\tif(xfs.get((int) idx).getXfId() > 0) {\n+\t\t\tstyleXfId = (int) xfs.get((int) idx).getXfId();\n+\t\t}\n \n \t\treturn new XSSFCellStyle((int) idx, styleXfId, this);\n \t}\n-    public synchronized long putStyle(CellStyle style) {\n-    \tXSSFCellStyle xStyle = (XSSFCellStyle)style;\n-    \tCTXf mainXF = xStyle.getCoreXf();\n+\tpublic synchronized long putStyle(CellStyle style) {\n+\t\tXSSFCellStyle xStyle = (XSSFCellStyle)style;\n+\t\tCTXf mainXF = xStyle.getCoreXf();\n \n-    \tif(! xfs.contains(mainXF)) {\n-    \t\txfs.add(mainXF);\n-    \t}\n+\t\tif(! xfs.contains(mainXF)) {\n+\t\t\txfs.add(mainXF);\n+\t\t}\n \t\treturn xfs.indexOf(mainXF);\n-    }\n+\t}\n \n \tpublic XSSFCellBorder getBorderAt(long idx) {\n \t\treturn new XSSFCellBorder(borders.get((int)idx));\n@@ -209,7 +209,7 @@ public XSSFCellFill getFillAt(long idx) {\n \t\treturn new XSSFCellFill(fills.get((int) idx));\n \t}\n \tpublic long putFill(XSSFCellFill fill) {\n-\t\treturn putFill(fill, fills);\n+\t\treturn fill.putFill(fills);\n \t}\n \n \tpublic CTXf getCellXfAt(long idx) {\n@@ -227,228 +227,217 @@ public long putCellStyleXf(CTXf cellStyleXf) {\n \t\tstyleXfs.add(cellStyleXf);\n \t\treturn styleXfs.size();\n \t}\n-    /**\n-     * get the size of cell styles\n-     */\n-    public int getNumCellStyles(){\n-        return styleXfs.size();\n-    }\n-    /**\n-     * get the size of fonts\n-     */\n-    public int getNumberOfFonts(){\n-        return this.fonts.size();\n-    }\n-    /**\n-     * For unit testing only\n-     */\n-    public int _getNumberFormatSize() {\n-    \treturn numberFormats.size();\n-    }\n-    /**\n-     * For unit testing only\n-     */\n-    public int _getFontsSize() {\n-    \treturn fonts.size();\n-    }\n-    /**\n-     * For unit testing only\n-     */\n-    public int _getFillsSize() {\n-    \treturn fills.size();\n-    }\n-    /**\n-     * For unit testing only\n-     */\n-    public int _getBordersSize() {\n-    \treturn borders.size();\n-    }\n-    /**\n-     * For unit testing only\n-     */\n-    public int _getXfsSize() {\n-    \treturn xfs.size();\n-    }\n-    /**\n-     * For unit testing only\n-     */\n-    public int _getStyleXfsSize() {\n-    \treturn styleXfs.size();\n-    }\n-    /**\n-     * For unit testing only!\n-     */\n-    public CTStylesheet _getRawStylesheet() {\n-    \treturn doc.getStyleSheet();\n-    }\n-\n-\n-    /**\n-     * Write this table out as XML.\n-     *\n-     * @param out The stream to write to.\n-     * @throws IOException if an error occurs while writing.\n-     */\n-    public void writeTo(OutputStream out) throws IOException {\n-        XmlOptions options = new XmlOptions();\n-        options.setSaveOuter();\n-        options.setUseDefaultNamespace();\n-\n-        // Requests use of whitespace for easier reading\n-        options.setSavePrettyPrint();\n-\n-\n-        // Work on the current one\n-        // Need to do this, as we don't handle\n-        //  all the possible entries yet\n-\n-    \t// Formats\n-    \tCTNumFmts formats = CTNumFmts.Factory.newInstance();\n-    \tformats.setCount(numberFormats.size());\n-    \tfor (Entry<Long, String> fmt : numberFormats.entrySet()) {\n-    \t\tCTNumFmt ctFmt = formats.addNewNumFmt();\n-    \t\tctFmt.setNumFmtId(fmt.getKey());\n-    \t\tctFmt.setFormatCode(fmt.getValue());\n-    \t}\n-    \tdoc.getStyleSheet().setNumFmts(formats);\n-\n-    \t// Fonts\n-    \tCTFonts ctFonts = CTFonts.Factory.newInstance();\n-    \tctFonts.setCount(fonts.size());\n-    \tctFonts.setFontArray(\n-    \t\t\tfonts.toArray(new CTFont[fonts.size()])\n-    \t);\n-    \tdoc.getStyleSheet().setFonts(ctFonts);\n-\n-    \t// Fills\n-    \tCTFills ctFills = CTFills.Factory.newInstance();\n-    \tctFills.setCount(fills.size());\n-    \tctFills.setFillArray(fills.toArray(new CTFill[fills.size()]));\n-    \tdoc.getStyleSheet().setFills(ctFills);\n-\n-    \t// Borders\n-    \tCTBorders ctBorders = CTBorders.Factory.newInstance();\n-    \tctBorders.setCount(borders.size());\n-    \tctBorders.setBorderArray(borders.toArray(new CTBorder[borders.size()]));\n-    \tdoc.getStyleSheet().setBorders(ctBorders);\n-\n-    \t// Xfs\n-    \tif(xfs.size() > 0) {\n-\t    \tCTCellXfs ctXfs = CTCellXfs.Factory.newInstance();\n-\t    \tctXfs.setCount(xfs.size());\n-\t    \tctXfs.setXfArray(\n-\t    \t\t\txfs.toArray(new CTXf[xfs.size()])\n-\t    \t);\n-\t    \tdoc.getStyleSheet().setCellXfs(ctXfs);\n-    \t}\n-\n-    \t// Style xfs\n-    \tif(styleXfs.size() > 0) {\n-        \tCTCellStyleXfs ctSXfs = CTCellStyleXfs.Factory.newInstance();\n-        \tctSXfs.setCount(styleXfs.size());\n-        \tctSXfs.setXfArray(\n-        \t\t\tstyleXfs.toArray(new CTXf[styleXfs.size()])\n-        \t);\n-        \tdoc.getStyleSheet().setCellStyleXfs(ctSXfs);\n-    \t}\n-\n-    \t// Style dxfs\n-    \tif(dxfs.size() > 0) {\n-        \tCTDxfs ctDxfs = CTDxfs.Factory.newInstance();\n-        \tctDxfs.setCount(dxfs.size());\n-        \tctDxfs.setDxfArray(dxfs.toArray(new CTDxf[dxfs.size()])\n-        \t);\n-        \tdoc.getStyleSheet().setDxfs(ctDxfs);\n-    \t}\n-\n-        // Save\n-        doc.save(out, options);\n-    }\n-\n-\tprivate long putBorder(XSSFCellBorder border, LinkedList<CTBorder> borders) {\n-\t\treturn border.putBorder(borders);\n-\t}\n-\n-\tprivate long putFill(XSSFCellFill fill, LinkedList<CTFill> fills) {\n-\t\treturn fill.putFill(fills);\n+\t/**\n+\t * get the size of cell styles\n+\t */\n+\tpublic int getNumCellStyles(){\n+\t\treturn styleXfs.size();\n+\t}\n+\t/**\n+\t * get the size of fonts\n+\t */\n+\tpublic int getNumberOfFonts(){\n+\t\treturn this.fonts.size();\n+\t}\n+\t/**\n+\t * For unit testing only\n+\t */\n+\tpublic int _getNumberFormatSize() {\n+\t\treturn numberFormats.size();\n+\t}\n+\t/**\n+\t * For unit testing only\n+\t */\n+\tpublic int _getFontsSize() {\n+\t\treturn fonts.size();\n+\t}\n+\t/**\n+\t * For unit testing only\n+\t */\n+\tpublic int _getFillsSize() {\n+\t\treturn fills.size();\n+\t}\n+\t/**\n+\t * For unit testing only\n+\t */\n+\tpublic int _getBordersSize() {\n+\t\treturn borders.size();\n+\t}\n+\t/**\n+\t * For unit testing only\n+\t */\n+\tpublic int _getXfsSize() {\n+\t\treturn xfs.size();\n+\t}\n+\t/**\n+\t * For unit testing only\n+\t */\n+\tpublic int _getStyleXfsSize() {\n+\t\treturn styleXfs.size();\n+\t}\n+\t/**\n+\t * For unit testing only!\n+\t */\n+\tpublic CTStylesheet _getRawStylesheet() {\n+\t\treturn doc.getStyleSheet();\n \t}\n \n-\tprivate long putFont(XSSFFont font, ArrayList<CTFont> fonts) {\n-\t    return font.putFont(fonts);\n-    }\n \n+\t/**\n+\t * Write this table out as XML.\n+\t *\n+\t * @param out The stream to write to.\n+\t * @throws IOException if an error occurs while writing.\n+\t */\n+\tpublic void writeTo(OutputStream out) throws IOException {\n+\t\tXmlOptions options = new XmlOptions();\n+\t\toptions.setSaveOuter();\n+\t\toptions.setUseDefaultNamespace();\n+\n+\t\t// Requests use of whitespace for easier reading\n+\t\toptions.setSavePrettyPrint();\n+\n+\n+\t\t// Work on the current one\n+\t\t// Need to do this, as we don't handle\n+\t\t//  all the possible entries yet\n+\n+\t\t// Formats\n+\t\tCTNumFmts formats = CTNumFmts.Factory.newInstance();\n+\t\tformats.setCount(numberFormats.size());\n+\t\tfor (Entry<Long, String> fmt : numberFormats.entrySet()) {\n+\t\t\tCTNumFmt ctFmt = formats.addNewNumFmt();\n+\t\t\tctFmt.setNumFmtId(fmt.getKey());\n+\t\t\tctFmt.setFormatCode(fmt.getValue());\n+\t\t}\n+\t\tdoc.getStyleSheet().setNumFmts(formats);\n+\n+\t\t// Fonts\n+\t\tCTFonts ctFonts = CTFonts.Factory.newInstance();\n+\t\tctFonts.setCount(fonts.size());\n+\t\tctFonts.setFontArray(\n+\t\t\t\tfonts.toArray(new CTFont[fonts.size()])\n+\t\t);\n+\t\tdoc.getStyleSheet().setFonts(ctFonts);\n+\n+\t\t// Fills\n+\t\tCTFills ctFills = CTFills.Factory.newInstance();\n+\t\tctFills.setCount(fills.size());\n+\t\tctFills.setFillArray(fills.toArray(new CTFill[fills.size()]));\n+\t\tdoc.getStyleSheet().setFills(ctFills);\n+\n+\t\t// Borders\n+\t\tCTBorders ctBorders = CTBorders.Factory.newInstance();\n+\t\tctBorders.setCount(borders.size());\n+\t\tctBorders.setBorderArray(borders.toArray(new CTBorder[borders.size()]));\n+\t\tdoc.getStyleSheet().setBorders(ctBorders);\n+\n+\t\t// Xfs\n+\t\tif(xfs.size() > 0) {\n+\t\t\tCTCellXfs ctXfs = CTCellXfs.Factory.newInstance();\n+\t\t\tctXfs.setCount(xfs.size());\n+\t\t\tctXfs.setXfArray(\n+\t\t\t\t\txfs.toArray(new CTXf[xfs.size()])\n+\t\t\t);\n+\t\t\tdoc.getStyleSheet().setCellXfs(ctXfs);\n+\t\t}\n+\n+\t\t// Style xfs\n+\t\tif(styleXfs.size() > 0) {\n+\t\t\tCTCellStyleXfs ctSXfs = CTCellStyleXfs.Factory.newInstance();\n+\t\t\tctSXfs.setCount(styleXfs.size());\n+\t\t\tctSXfs.setXfArray(\n+\t\t\t\t\tstyleXfs.toArray(new CTXf[styleXfs.size()])\n+\t\t\t);\n+\t\t\tdoc.getStyleSheet().setCellStyleXfs(ctSXfs);\n+\t\t}\n+\n+\t\t// Style dxfs\n+\t\tif(dxfs.size() > 0) {\n+\t\t\tCTDxfs ctDxfs = CTDxfs.Factory.newInstance();\n+\t\t\tctDxfs.setCount(dxfs.size());\n+\t\t\tctDxfs.setDxfArray(dxfs.toArray(new CTDxf[dxfs.size()])\n+\t\t\t);\n+\t\t\tdoc.getStyleSheet().setDxfs(ctDxfs);\n+\t\t}\n+\n+\t\t// Save\n+\t\tdoc.save(out, options);\n+\t}\n+\n+\tprivate long putBorder(XSSFCellBorder border, List<CTBorder> borders) {\n+\t\treturn border.putBorder((LinkedList<CTBorder>) borders); // TODO - use List instead of LinkedList\n+\t}\n \n+\tprivate long putFont(XSSFFont font, List<CTFont> fonts) {\n+\t\treturn font.putFont((ArrayList<CTFont>) fonts); // TODO - use List instead of ArrayList\n+\t}\n \n \tprivate void initialize() {\n \t\t//CTFont ctFont = createDefaultFont();\n-\t    XSSFFont xssfFont = createDefaultFont();\n-\t    fonts.add(xssfFont.getCTFont());\n+\t\tXSSFFont xssfFont = createDefaultFont();\n+\t\tfonts.add(xssfFont.getCTFont());\n \n-\t    CTFill[] ctFill = createDefaultFills();\n-\t    fills.add(ctFill[0]);\n-\t    fills.add(ctFill[1]);\n+\t\tCTFill[] ctFill = createDefaultFills();\n+\t\tfills.add(ctFill[0]);\n+\t\tfills.add(ctFill[1]);\n \n-\t    CTBorder ctBorder = createDefaultBorder();\n-\t    borders.add(ctBorder);\n+\t\tCTBorder ctBorder = createDefaultBorder();\n+\t\tborders.add(ctBorder);\n \n-\t    CTXf styleXf = createDefaultXf();\n-\t    styleXfs.add(styleXf);\n-\t    CTXf xf = createDefaultXf();\n-\t    xf.setXfId(0);\n-\t    xfs.add(xf);\n+\t\tCTXf styleXf = createDefaultXf();\n+\t\tstyleXfs.add(styleXf);\n+\t\tCTXf xf = createDefaultXf();\n+\t\txf.setXfId(0);\n+\t\txfs.add(xf);\n \t}\n \n \tprivate CTXf createDefaultXf() {\n-\t    CTXf ctXf = CTXf.Factory.newInstance();\n-\t    ctXf.setNumFmtId(0);\n-\t    ctXf.setFontId(0);\n-\t    ctXf.setFillId(0);\n-\t    ctXf.setBorderId(0);\n-\t    return ctXf;\n+\t\tCTXf ctXf = CTXf.Factory.newInstance();\n+\t\tctXf.setNumFmtId(0);\n+\t\tctXf.setFontId(0);\n+\t\tctXf.setFillId(0);\n+\t\tctXf.setBorderId(0);\n+\t\treturn ctXf;\n \t}\n \tprivate CTBorder createDefaultBorder() {\n-\t    CTBorder ctBorder = CTBorder.Factory.newInstance();\n-\t    ctBorder.addNewBottom();\n-\t    ctBorder.addNewTop();\n-\t    ctBorder.addNewLeft();\n-\t    ctBorder.addNewRight();\n-\t    ctBorder.addNewDiagonal();\n-\t    return ctBorder;\n+\t\tCTBorder ctBorder = CTBorder.Factory.newInstance();\n+\t\tctBorder.addNewBottom();\n+\t\tctBorder.addNewTop();\n+\t\tctBorder.addNewLeft();\n+\t\tctBorder.addNewRight();\n+\t\tctBorder.addNewDiagonal();\n+\t\treturn ctBorder;\n \t}\n \n \n \tprivate CTFill[] createDefaultFills() {\n-\t    CTFill[] ctFill = new CTFill[]{CTFill.Factory.newInstance(),CTFill.Factory.newInstance()};\n-\t    ctFill[0].addNewPatternFill().setPatternType(STPatternType.NONE);\n-\t    ctFill[1].addNewPatternFill().setPatternType(STPatternType.DARK_GRAY);\n-\t    return ctFill;\n+\t\tCTFill[] ctFill = new CTFill[]{CTFill.Factory.newInstance(),CTFill.Factory.newInstance()};\n+\t\tctFill[0].addNewPatternFill().setPatternType(STPatternType.NONE);\n+\t\tctFill[1].addNewPatternFill().setPatternType(STPatternType.DARK_GRAY);\n+\t\treturn ctFill;\n \t}\n \n \tprivate XSSFFont createDefaultFont() {\n-\t    CTFont ctFont = CTFont.Factory.newInstance();\n-\t    XSSFFont xssfFont=new XSSFFont(ctFont);\n-\t    xssfFont.setFontHeightInPoints(XSSFFont.DEFAULT_FONT_SIZE);\n-\t    xssfFont.setColor(XSSFFont.DEFAULT_FONT_COLOR);//setTheme\n-\t    xssfFont.setFontName(XSSFFont.DEFAULT_FONT_NAME);\n-\t    xssfFont.setFamily(FontFamily.SWISS);\n-\t    xssfFont.setScheme(FontScheme.MINOR);\n-\t    return xssfFont;\n+\t\tCTFont ctFont = CTFont.Factory.newInstance();\n+\t\tXSSFFont xssfFont=new XSSFFont(ctFont);\n+\t\txssfFont.setFontHeightInPoints(XSSFFont.DEFAULT_FONT_SIZE);\n+\t\txssfFont.setColor(XSSFFont.DEFAULT_FONT_COLOR);//setTheme\n+\t\txssfFont.setFontName(XSSFFont.DEFAULT_FONT_NAME);\n+\t\txssfFont.setFamily(FontFamily.SWISS);\n+\t\txssfFont.setScheme(FontScheme.MINOR);\n+\t\treturn xssfFont;\n \t}\n \n-\n \tpublic CTDxf getDxf(long idx) {\n-\t    if(dxfs.size()==0)\n+\t\tif(dxfs.size()==0)\n \t\treturn CTDxf.Factory.newInstance();\n-\t    else\n+\t\telse\n \t\treturn dxfs.get((int) idx);\n \t}\n \n-\n \tpublic long putDxf(CTDxf dxf) {\n-\t    this.dxfs.add(dxf);\n-\t    return this.dxfs.size();\n+\t\tthis.dxfs.add(dxf);\n+\t\treturn this.dxfs.size();\n \t}\n-\t\n-\t\n-\t\n }",
                "raw_url": "https://github.com/apache/poi/raw/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/java/org/apache/poi/xssf/model/StylesTable.java",
                "sha": "79d28bf115e50a4fe59cb80dc2311ce64dafa18a",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/java/org/apache/poi/xssf/usermodel/IndexedColors.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/IndexedColors.java?ref=93e1ccd36b21d32234bc04198a2592cb48187919",
                "deletions": 4,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/IndexedColors.java",
                "patch": "@@ -77,12 +77,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     BROWN(60),\n     PLUM(61),\n     INDIGO(62),\n-    GREY_80_PERCENT(63);\n+    GREY_80_PERCENT(63),\n+    AUTOMATIC(64),\n+    ;\n \n-    private short index;\n+    private int index;\n \n     IndexedColors(int idx){\n-        index = (short)idx;\n+        index = idx;\n     }\n \n     /**\n@@ -91,6 +93,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n      * @return index of this color\n      */\n     public short getIndex(){\n-        return index;\n+        return (short)index;\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/java/org/apache/poi/xssf/usermodel/IndexedColors.java",
                "sha": "b61e62d5d9615e3968adcb52ea1777bf53c6f0e3",
                "status": "modified"
            },
            {
                "additions": 40,
                "blob_url": "https://github.com/apache/poi/blob/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/java/org/apache/poi/xssf/usermodel/extensions/XSSFCellFill.java",
                "changes": 66,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/extensions/XSSFCellFill.java?ref=93e1ccd36b21d32234bc04198a2592cb48187919",
                "deletions": 26,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/extensions/XSSFCellFill.java",
                "patch": "@@ -16,80 +16,94 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.xssf.usermodel.extensions;\n \n-import java.util.LinkedList;\n+import java.util.List;\n \n+import org.apache.poi.xssf.usermodel.IndexedColors;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTColor;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTFill;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTPatternFill;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.STPatternType.Enum;\n \n-public class XSSFCellFill {\n+public final class XSSFCellFill {\n \t\n-\tprivate CTFill fill;\n+\tprivate CTFill _fill;\n \t\n \tpublic XSSFCellFill(CTFill fill) {\n-\t\tthis.fill = fill;\n+\t\t_fill = fill;\n \t}\n \t\n \tpublic XSSFCellFill() {\n-\t\tthis.fill = CTFill.Factory.newInstance();\n+\t\t_fill = CTFill.Factory.newInstance();\n \t}\n \t\n \tpublic XSSFColor getFillBackgroundColor() {\n-\t\treturn new XSSFColor(getPatternFill().getBgColor());\n+\t\tCTColor ctColor = getPatternFill().getBgColor();\n+\t\tif (ctColor == null) {\n+\t\t\tXSSFColor result = new XSSFColor();\n+\t\t\tresult.setIndexed(IndexedColors.AUTOMATIC.getIndex());\n+\t\t\treturn result;\n+\t\t}\n+\t\treturn new XSSFColor(ctColor);\n \t}\n \n \tpublic XSSFColor getFillForegroundColor() {\n-\t\treturn new XSSFColor(getPatternFill().getFgColor());\n+\t\tCTColor ctColor = getPatternFill().getFgColor();\n+\t\tif (ctColor == null) {\n+\t\t\tXSSFColor result = new XSSFColor();\n+\t\t\tresult.setIndexed(IndexedColors.AUTOMATIC.getIndex());\n+\t\t\treturn result;\n+\t\t}\n+\t\treturn new XSSFColor(ctColor);\n \t}\n \n \tpublic Enum getPatternType() {\n \t\treturn getPatternFill().getPatternType();\n \t}\n \t\n-\tpublic long putFill(LinkedList<CTFill> fills) {\n-\t\tif (fills.contains(fill)) {\n-\t\t\treturn fills.indexOf(fill);\n+\t/**\n+\t * @return the index of the just added fill\n+\t */\n+\tpublic int putFill(List<CTFill> fills) {\n+\t\tif (fills.contains(_fill)) {\n+\t\t\treturn fills.indexOf(_fill);\n \t\t}\n-\t\tfills.add(fill);\n+\t\tfills.add(_fill);\n \t\treturn fills.size() - 1;\n \t}\n \n \tprivate CTPatternFill getPatternFill() {\n-\t\tCTPatternFill patternFill = fill.getPatternFill();\n+\t\tCTPatternFill patternFill = _fill.getPatternFill();\n \t\tif (patternFill == null) {\n-\t\t\tpatternFill = fill.addNewPatternFill();\n+\t\t\tpatternFill = _fill.addNewPatternFill();\n \t\t}\n \t\treturn patternFill;\n \t}\n \n \tpublic CTFill getCTFill() {\n-\t\treturn this.fill;\n+\t\treturn _fill;\n \t}\n \t\n-        public void setFillBackgroundColor(long index) {\n-                CTColor ctColor=getPatternFill().addNewBgColor();\n-                ctColor.setIndexed(index);\n-                fill.getPatternFill().setBgColor(ctColor);\n-        }\n+\tpublic void setFillBackgroundColor(long index) {\n+\t\tCTColor ctColor=getPatternFill().addNewBgColor();\n+\t\tctColor.setIndexed(index);\n+\t\t_fill.getPatternFill().setBgColor(ctColor);\n+\t}\n \n \tpublic void setFillForegroundColor(long index) {\n \t\tCTColor ctColor=getPatternFill().addNewFgColor();\n \t\tctColor.setIndexed(index);\n-\t\tfill.getPatternFill().setFgColor(ctColor);\n+\t\t_fill.getPatternFill().setFgColor(ctColor);\n \t}\n \t\n-\t public void setFillBackgroundRgbColor(XSSFColor color) {\n-             fill.getPatternFill().setBgColor(color.getCTColor());\n-\t }\n+\tpublic void setFillBackgroundRgbColor(XSSFColor color) {\n+\t\t_fill.getPatternFill().setBgColor(color.getCTColor());\n+\t}\n \n \tpublic void setFillForegroundRgbColor(XSSFColor color) {\n-\t\tfill.getPatternFill().setFgColor(color.getCTColor());\n+\t\t_fill.getPatternFill().setFgColor(color.getCTColor());\n \t}\n \t\n \tpublic void setPatternType(Enum patternType) {\n \t\tgetPatternFill().setPatternType(patternType);\n \t}\n-\n-    \n }",
                "raw_url": "https://github.com/apache/poi/raw/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/java/org/apache/poi/xssf/usermodel/extensions/XSSFCellFill.java",
                "sha": "53bb41f0f63de8c7f3433b6702858ebc693c98de",
                "status": "modified"
            },
            {
                "additions": 358,
                "blob_url": "https://github.com/apache/poi/blob/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCellStyle.java",
                "changes": 681,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCellStyle.java?ref=93e1ccd36b21d32234bc04198a2592cb48187919",
                "deletions": 323,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCellStyle.java",
                "patch": "@@ -17,6 +17,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xssf.usermodel;\n \n+import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n \n import org.apache.poi.ss.usermodel.CellStyle;\n@@ -30,328 +31,362 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n public class TestXSSFCellStyle extends TestCase {\n \n-    private StylesTable stylesTable;\n-    private CTBorder ctBorderA;\n-    private CTFill ctFill;\n-    private CTFont ctFont;\n-    private CTXf cellStyleXf;\n-    private CTXf cellXf;\n-    private CTCellXfs cellXfs;\n-    private XSSFCellStyle cellStyle;\n-    private CTStylesheet ctStylesheet;\n-\n-    public void setUp() {\n-        stylesTable = new StylesTable();\n-        \n-        ctStylesheet = stylesTable._getRawStylesheet();\n-        \n-        // Until we do XSSFBorder properly, cheat\n-        ctBorderA = CTBorder.Factory.newInstance();\n-        XSSFCellBorder borderA = new XSSFCellBorder(ctBorderA);\n-        long borderId = stylesTable.putBorder(borderA);\n-        assertEquals(1, borderId);\n-\n-        XSSFCellBorder borderB = new XSSFCellBorder();\n-        assertEquals(2, stylesTable.putBorder(borderB));\n-\n-        ctFill = CTFill.Factory.newInstance();\n-        XSSFCellFill fill = new XSSFCellFill(ctFill);\n-        long fillId = stylesTable.putFill(fill);\n-        assertEquals(2, fillId);\n-\n-        ctFont = CTFont.Factory.newInstance();\n-        XSSFFont font = new XSSFFont(ctFont);\n-        long fontId = stylesTable.putFont(font);\n-        assertEquals(1, fontId);\n-\n-        cellStyleXf = ctStylesheet.addNewCellStyleXfs().addNewXf();\n-        cellStyleXf.setBorderId(1);\n-        cellStyleXf.setFillId(1);\n-        cellStyleXf.setFontId(1);\n-        \n-        cellXfs = ctStylesheet.addNewCellXfs();\n-        cellXf = cellXfs.addNewXf();\n-        cellXf.setXfId(1);\n-        cellXf.setBorderId(1);\n-        cellXf.setFillId(1);\n-        cellXf.setFontId(1);\n-        stylesTable.putCellStyleXf(cellStyleXf);\n-        long id=stylesTable.putCellXf(cellXf);\n-        cellStyle = new XSSFCellStyle(1, 1, stylesTable);\n-    }\n-\n-    public void testGetSetBorderBottom() {\n-        ctBorderA.addNewBottom().setStyle(STBorderStyle.THIN);\n-        assertEquals((short)1, cellStyle.getBorderBottom());\n-        cellStyle.setBorderBottom((short) 2);\n-        assertEquals(STBorderStyle.THIN, ctBorderA.getBottom().getStyle());\n-        cellStyle.setBorderBottomEnum(STBorderStyle.THICK);\n-        assertEquals(6, ctBorderA.getBottom().getStyle().intValue());\n-    }\n-\n-    public void testGetBorderBottomAsString() {\n-        ctBorderA.addNewBottom().setStyle(STBorderStyle.THIN);\n-        assertEquals(\"thin\", cellStyle.getBorderBottomAsString());\n-    }\n-\n-    public void testGetSetBorderRight() {\n-        ctBorderA.addNewRight().setStyle(STBorderStyle.MEDIUM);\n-        assertEquals((short)2, cellStyle.getBorderRight());\n-        cellStyle.setBorderRight((short) 2);\n-        assertEquals(STBorderStyle.THIN, ctBorderA.getRight().getStyle());\n-        cellStyle.setBorderRightEnum(STBorderStyle.THICK);\n-        assertEquals(6, ctBorderA.getRight().getStyle().intValue());\n-    }\n-\n-    public void testGetBorderRightAsString() {\n-        ctBorderA.addNewRight().setStyle(STBorderStyle.MEDIUM);\n-        assertEquals(\"medium\", cellStyle.getBorderRightAsString());\n-    }\n-\n-    public void testGetSetBorderLeft() {\n-        ctBorderA.addNewLeft().setStyle(STBorderStyle.DASHED);\n-        assertEquals((short)3, cellStyle.getBorderLeft());\n-        cellStyle.setBorderLeft((short) 2);\n-        assertEquals(STBorderStyle.THIN, ctBorderA.getLeft().getStyle());\n-        cellStyle.setBorderLeftEnum(STBorderStyle.THICK);\n-        assertEquals(6, ctBorderA.getLeft().getStyle().intValue());\n-    }\n-\n-    public void testGetBorderLeftAsString() {\n-        ctBorderA.addNewLeft().setStyle(STBorderStyle.DASHED);\n-        assertEquals(\"dashed\", cellStyle.getBorderLeftAsString());\n-    }\n-\n-    public void testGetSetBorderTop() {\n-        ctBorderA.addNewTop().setStyle(STBorderStyle.HAIR);\n-        assertEquals((short)7, cellStyle.getBorderTop());\n-        cellStyle.setBorderTop((short) 2);\n-        assertEquals(STBorderStyle.THIN, ctBorderA.getTop().getStyle());\n-        cellStyle.setBorderTopEnum(STBorderStyle.THICK);\n-        assertEquals(6, ctBorderA.getTop().getStyle().intValue());\n-    }\n-\n-    public void testGetBorderTopAsString() {\n-        ctBorderA.addNewTop().setStyle(STBorderStyle.HAIR);\n-        assertEquals(\"hair\", cellStyle.getBorderTopAsString());\n-    }\n-\n-    public void testGetSetBottomBorderColor() {\n-        CTColor ctColor = ctBorderA.addNewBottom().addNewColor();\n-        ctColor.setIndexed(2);\n-        XSSFColor color = new XSSFColor(ctColor);\n-        assertEquals((short)2, cellStyle.getBottomBorderColor());\n-        CTColor anotherCtColor = CTColor.Factory.newInstance();\n-        anotherCtColor.setIndexed(4);\n-        anotherCtColor.setTheme(3);\n-        anotherCtColor.setRgb(\"1234\".getBytes());\n-        XSSFColor anotherColor = new XSSFColor(anotherCtColor);\n-        cellStyle.setBorderColor(BorderSide.BOTTOM, anotherColor);\n-        assertEquals((short)4, cellStyle.getBottomBorderColor());\n-        assertEquals(new String(\"1234\".getBytes()), new String(cellStyle.getBorderColor(BorderSide.BOTTOM).getRgb()));\n-    }\n-\n-    public void testGetSetTopBorderColor() {\n-        CTColor ctColor = ctBorderA.addNewTop().addNewColor();\n-        ctColor.setIndexed(5);\n-        XSSFColor color = new XSSFColor(ctColor);\n-        assertEquals((short)5, cellStyle.getTopBorderColor());\n-        CTColor anotherCtColor = CTColor.Factory.newInstance();\n-        anotherCtColor.setIndexed(7);\n-        anotherCtColor.setTheme(3);\n-        anotherCtColor.setRgb(\"abcd\".getBytes());\n-        XSSFColor anotherColor = new XSSFColor(anotherCtColor);\n-        cellStyle.setBorderColor(BorderSide.TOP, anotherColor);\n-        assertEquals((short)7, cellStyle.getTopBorderColor());\n-        assertEquals(new String(\"abcd\".getBytes()), new String(cellStyle.getBorderColor(BorderSide.TOP).getRgb()));\n-    }\n-\n-    public void testGetSetLeftBorderColor() {\n-        CTColor ctColor = ctBorderA.addNewLeft().addNewColor();\n-        ctColor.setIndexed(2);\n-        XSSFColor color = new XSSFColor(ctColor);\n-        assertEquals((short)2, cellStyle.getLeftBorderColor());\n-        CTColor anotherCtColor = CTColor.Factory.newInstance();\n-        anotherCtColor.setIndexed(4);\n-        anotherCtColor.setTheme(3);\n-        anotherCtColor.setRgb(\"1234\".getBytes());\n-        XSSFColor anotherColor = new XSSFColor(anotherCtColor);\n-        cellStyle.setBorderColor(BorderSide.LEFT, anotherColor);\n-        assertEquals((short)4, cellStyle.getLeftBorderColor());\n-        assertEquals(new String(\"1234\".getBytes()), new String(cellStyle.getBorderColor(BorderSide.LEFT).getRgb()));\n-    }\n-\n-    public void testGetSetRightBorderColor() {\n-        CTColor ctColor = ctBorderA.addNewRight().addNewColor();\n-        ctColor.setIndexed(8);\n-        XSSFColor color = new XSSFColor(ctColor);\n-        assertEquals((short)8, cellStyle.getRightBorderColor());\n-        CTColor anotherCtColor = CTColor.Factory.newInstance();\n-        anotherCtColor.setIndexed(14);\n-        anotherCtColor.setTheme(3);\n-        anotherCtColor.setRgb(\"af67\".getBytes());\n-        XSSFColor anotherColor = new XSSFColor(anotherCtColor);\n-        cellStyle.setBorderColor(BorderSide.RIGHT, anotherColor);\n-        assertEquals((short)14, cellStyle.getRightBorderColor());\n-        assertEquals(new String(\"af67\".getBytes()), new String(cellStyle.getBorderColor(BorderSide.RIGHT).getRgb()));\n-    }\n-\n-    public void testGetFillBackgroundColor() {\n-\tsetUp();\n-\tCTPatternFill ctPatternFill = ctFill.addNewPatternFill();\n-        CTColor ctBgColor = ctPatternFill.addNewBgColor();\n-        ctBgColor.setIndexed(IndexedColors.BRIGHT_GREEN.getIndex());\n-        ctPatternFill.setBgColor(ctBgColor);\n-\n-        XSSFCellFill cellFill=new XSSFCellFill(ctFill);\n-        long index=stylesTable.putFill(cellFill);\n-        ((XSSFCellStyle)cellStyle).getCoreXf().setFillId(index);\n-\n-        assertEquals(2,cellStyle.getCoreXf().getFillId());\n-        assertEquals(IndexedColors.BRIGHT_GREEN.getIndex(), cellStyle.getFillBackgroundColor());\n-        \n-        cellStyle.setFillBackgroundColor(IndexedColors.BLUE.getIndex());\n-        assertEquals(IndexedColors.BLUE.getIndex(), ctFill.getPatternFill().getBgColor().getIndexed());\n-        \n-        //test rgb color - XSSFColor\n-        CTColor ctColor=CTColor.Factory.newInstance();\n-        ctColor.setRgb(\"FFFFFF\".getBytes());\n-        ctPatternFill.setBgColor(ctColor);\n-        assertEquals(ctColor.toString(), cellStyle.getFillBackgroundRgbColor().getCTColor().toString());\n-        \n-        cellStyle.setFillBackgroundRgbColor(new XSSFColor(ctColor));\n-        assertEquals(ctColor.getRgb()[0], ctPatternFill.getBgColor().getRgb()[0]);\n-        assertEquals(ctColor.getRgb()[1], ctPatternFill.getBgColor().getRgb()[1]);\n-        assertEquals(ctColor.getRgb()[2], ctPatternFill.getBgColor().getRgb()[2]);\n-        assertEquals(ctColor.getRgb()[3], ctPatternFill.getBgColor().getRgb()[3]);\n-    }\n-\n-    public void testGetFillForegroundColor() {\n-\tsetUp();\n-\tCTPatternFill ctPatternFill = ctFill.addNewPatternFill();\n-        CTColor ctFgColor = ctPatternFill.addNewFgColor();\n-        ctFgColor.setIndexed(IndexedColors.BRIGHT_GREEN.getIndex());\n-        ctPatternFill.setFgColor(ctFgColor);\n-\n-        XSSFCellFill cellFill=new XSSFCellFill(ctFill);\n-        long index=stylesTable.putFill(cellFill);\n-        ((XSSFCellStyle)cellStyle).getCoreXf().setFillId(index);\n-\n-        assertEquals(2,cellStyle.getCoreXf().getFillId());\n-        assertEquals(IndexedColors.BRIGHT_GREEN.getIndex(), cellStyle.getFillForegroundColor());\n-        \n-        cellStyle.setFillForegroundColor(IndexedColors.BLUE.getIndex());\n-        assertEquals(IndexedColors.BLUE.getIndex(), ctFill.getPatternFill().getFgColor().getIndexed());\n-        \n-        //test rgb color - XSSFColor\n-        CTColor ctColor=CTColor.Factory.newInstance();\n-        ctColor.setRgb(\"FFFFFF\".getBytes());\n-        ctPatternFill.setFgColor(ctColor);\n-        assertEquals(ctColor.toString(), cellStyle.getFillForegroundRgbColor().getCTColor().toString());\n-        \n-        cellStyle.setFillForegroundRgbColor(new XSSFColor(ctColor));\n-        assertEquals(ctColor.getRgb()[0], ctPatternFill.getFgColor().getRgb()[0]);\n-        assertEquals(ctColor.getRgb()[1], ctPatternFill.getFgColor().getRgb()[1]);\n-        assertEquals(ctColor.getRgb()[2], ctPatternFill.getFgColor().getRgb()[2]);\n-        assertEquals(ctColor.getRgb()[3], ctPatternFill.getFgColor().getRgb()[3]);\n-    }\n-\n-    public void testGetFillPattern() {\n-\tsetUp();\n-        CTPatternFill ctPatternFill = ctFill.addNewPatternFill();\n-        ctPatternFill.setPatternType(STPatternType.DARK_DOWN);\n-        XSSFCellFill cellFill=new XSSFCellFill(ctFill);\n-        long index=stylesTable.putFill(cellFill);\n-        ((XSSFCellStyle)cellStyle).getCoreXf().setFillId(index);\n+\tprivate static final int AUTO_COLOR_INDEX = 64;\n+\tprivate StylesTable stylesTable;\n+\tprivate CTBorder ctBorderA;\n+\tprivate CTFill ctFill;\n+\tprivate CTFont ctFont;\n+\tprivate CTXf cellStyleXf;\n+\tprivate CTXf cellXf;\n+\tprivate CTCellXfs cellXfs;\n+\tprivate XSSFCellStyle cellStyle;\n+\tprivate CTStylesheet ctStylesheet;\n+\n+\t@Override\n+\tprotected void setUp() {\n+\t\tstylesTable = new StylesTable();\n+\t\t\n+\t\tctStylesheet = stylesTable._getRawStylesheet();\n+\t\t\n+\t\t// Until we do XSSFBorder properly, cheat\n+\t\tctBorderA = CTBorder.Factory.newInstance();\n+\t\tXSSFCellBorder borderA = new XSSFCellBorder(ctBorderA);\n+\t\tlong borderId = stylesTable.putBorder(borderA);\n+\t\tassertEquals(1, borderId);\n+\n+\t\tXSSFCellBorder borderB = new XSSFCellBorder();\n+\t\tassertEquals(2, stylesTable.putBorder(borderB));\n+\n+\t\tctFill = CTFill.Factory.newInstance();\n+\t\tXSSFCellFill fill = new XSSFCellFill(ctFill);\n+\t\tlong fillId = stylesTable.putFill(fill);\n+\t\tassertEquals(2, fillId);\n+\n+\t\tctFont = CTFont.Factory.newInstance();\n+\t\tXSSFFont font = new XSSFFont(ctFont);\n+\t\tlong fontId = stylesTable.putFont(font);\n+\t\tassertEquals(1, fontId);\n+\n+\t\tcellStyleXf = ctStylesheet.addNewCellStyleXfs().addNewXf();\n+\t\tcellStyleXf.setBorderId(1);\n+\t\tcellStyleXf.setFillId(1);\n+\t\tcellStyleXf.setFontId(1);\n+\t\t\n+\t\tcellXfs = ctStylesheet.addNewCellXfs();\n+\t\tcellXf = cellXfs.addNewXf();\n+\t\tcellXf.setXfId(1);\n+\t\tcellXf.setBorderId(1);\n+\t\tcellXf.setFillId(1);\n+\t\tcellXf.setFontId(1);\n+\t\tstylesTable.putCellStyleXf(cellStyleXf);\n+\t\tstylesTable.putCellXf(cellXf);\n+\t\tcellStyle = new XSSFCellStyle(1, 1, stylesTable);\n+\t}\n+\n+\tpublic void testGetSetBorderBottom() {\n+\t\tctBorderA.addNewBottom().setStyle(STBorderStyle.THIN);\n+\t\tassertEquals((short)1, cellStyle.getBorderBottom());\n+\t\tcellStyle.setBorderBottom((short) 2);\n+\t\tassertEquals(STBorderStyle.THIN, ctBorderA.getBottom().getStyle());\n+\t\tcellStyle.setBorderBottomEnum(STBorderStyle.THICK);\n+\t\tassertEquals(6, ctBorderA.getBottom().getStyle().intValue());\n+\t}\n+\n+\tpublic void testGetBorderBottomAsString() {\n+\t\tctBorderA.addNewBottom().setStyle(STBorderStyle.THIN);\n+\t\tassertEquals(\"thin\", cellStyle.getBorderBottomAsString());\n+\t}\n+\n+\tpublic void testGetSetBorderRight() {\n+\t\tctBorderA.addNewRight().setStyle(STBorderStyle.MEDIUM);\n+\t\tassertEquals((short)2, cellStyle.getBorderRight());\n+\t\tcellStyle.setBorderRight((short) 2);\n+\t\tassertEquals(STBorderStyle.THIN, ctBorderA.getRight().getStyle());\n+\t\tcellStyle.setBorderRightEnum(STBorderStyle.THICK);\n+\t\tassertEquals(6, ctBorderA.getRight().getStyle().intValue());\n+\t}\n+\n+\tpublic void testGetBorderRightAsString() {\n+\t\tctBorderA.addNewRight().setStyle(STBorderStyle.MEDIUM);\n+\t\tassertEquals(\"medium\", cellStyle.getBorderRightAsString());\n+\t}\n+\n+\tpublic void testGetSetBorderLeft() {\n+\t\tctBorderA.addNewLeft().setStyle(STBorderStyle.DASHED);\n+\t\tassertEquals((short)3, cellStyle.getBorderLeft());\n+\t\tcellStyle.setBorderLeft((short) 2);\n+\t\tassertEquals(STBorderStyle.THIN, ctBorderA.getLeft().getStyle());\n+\t\tcellStyle.setBorderLeftEnum(STBorderStyle.THICK);\n+\t\tassertEquals(6, ctBorderA.getLeft().getStyle().intValue());\n+\t}\n+\n+\tpublic void testGetBorderLeftAsString() {\n+\t\tctBorderA.addNewLeft().setStyle(STBorderStyle.DASHED);\n+\t\tassertEquals(\"dashed\", cellStyle.getBorderLeftAsString());\n+\t}\n+\n+\tpublic void testGetSetBorderTop() {\n+\t\tctBorderA.addNewTop().setStyle(STBorderStyle.HAIR);\n+\t\tassertEquals((short)7, cellStyle.getBorderTop());\n+\t\tcellStyle.setBorderTop((short) 2);\n+\t\tassertEquals(STBorderStyle.THIN, ctBorderA.getTop().getStyle());\n+\t\tcellStyle.setBorderTopEnum(STBorderStyle.THICK);\n+\t\tassertEquals(6, ctBorderA.getTop().getStyle().intValue());\n+\t}\n+\n+\tpublic void testGetBorderTopAsString() {\n+\t\tctBorderA.addNewTop().setStyle(STBorderStyle.HAIR);\n+\t\tassertEquals(\"hair\", cellStyle.getBorderTopAsString());\n+\t}\n+\n+\tpublic void testGetSetBottomBorderColor() {\n+\t\tCTColor ctColor = ctBorderA.addNewBottom().addNewColor();\n+\t\tctColor.setIndexed(2);\n+\t\tassertEquals((short)2, cellStyle.getBottomBorderColor());\n+\t\tCTColor anotherCtColor = CTColor.Factory.newInstance();\n+\t\tanotherCtColor.setIndexed(4);\n+\t\tanotherCtColor.setTheme(3);\n+\t\tanotherCtColor.setRgb(\"1234\".getBytes());\n+\t\tXSSFColor anotherColor = new XSSFColor(anotherCtColor);\n+\t\tcellStyle.setBorderColor(BorderSide.BOTTOM, anotherColor);\n+\t\tassertEquals((short)4, cellStyle.getBottomBorderColor());\n+\t\tassertEquals(\"1234\", new String(cellStyle.getBorderColor(BorderSide.BOTTOM).getRgb()));\n+\t}\n+\n+\tpublic void testGetSetTopBorderColor() {\n+\t\tCTColor ctColor = ctBorderA.addNewTop().addNewColor();\n+\t\tctColor.setIndexed(5);\n+\t\tassertEquals((short)5, cellStyle.getTopBorderColor());\n+\t\tCTColor anotherCtColor = CTColor.Factory.newInstance();\n+\t\tanotherCtColor.setIndexed(7);\n+\t\tanotherCtColor.setTheme(3);\n+\t\tanotherCtColor.setRgb(\"abcd\".getBytes());\n+\t\tXSSFColor anotherColor = new XSSFColor(anotherCtColor);\n+\t\tcellStyle.setBorderColor(BorderSide.TOP, anotherColor);\n+\t\tassertEquals((short)7, cellStyle.getTopBorderColor());\n+\t\tassertEquals(\"abcd\", new String(cellStyle.getBorderColor(BorderSide.TOP).getRgb()));\n+\t}\n+\n+\tpublic void testGetSetLeftBorderColor() {\n+\t\tCTColor ctColor = ctBorderA.addNewLeft().addNewColor();\n+\t\tctColor.setIndexed(2);\n+\t\tassertEquals((short)2, cellStyle.getLeftBorderColor());\n+\t\tCTColor anotherCtColor = CTColor.Factory.newInstance();\n+\t\tanotherCtColor.setIndexed(4);\n+\t\tanotherCtColor.setTheme(3);\n+\t\tanotherCtColor.setRgb(\"1234\".getBytes());\n+\t\tXSSFColor anotherColor = new XSSFColor(anotherCtColor);\n+\t\tcellStyle.setBorderColor(BorderSide.LEFT, anotherColor);\n+\t\tassertEquals((short)4, cellStyle.getLeftBorderColor());\n+\t\tassertEquals(\"1234\", new String(cellStyle.getBorderColor(BorderSide.LEFT).getRgb()));\n+\t}\n+\n+\tpublic void testGetSetRightBorderColor() {\n+\t\tCTColor ctColor = ctBorderA.addNewRight().addNewColor();\n+\t\tctColor.setIndexed(8);\n+\t\tassertEquals((short)8, cellStyle.getRightBorderColor());\n+\t\tCTColor anotherCtColor = CTColor.Factory.newInstance();\n+\t\tanotherCtColor.setIndexed(14);\n+\t\tanotherCtColor.setTheme(3);\n+\t\tanotherCtColor.setRgb(\"af67\".getBytes());\n+\t\tXSSFColor anotherColor = new XSSFColor(anotherCtColor);\n+\t\tcellStyle.setBorderColor(BorderSide.RIGHT, anotherColor);\n+\t\tassertEquals((short)14, cellStyle.getRightBorderColor());\n+\t\tassertEquals(\"af67\", new String(cellStyle.getBorderColor(BorderSide.RIGHT).getRgb()));\n+\t}\n+\n+\tpublic void testGetFillBackgroundColor() {\n+\n+\t\tCTPatternFill ctPatternFill = ctFill.addNewPatternFill();\n+\t\tCTColor ctBgColor = ctPatternFill.addNewBgColor();\n+\t\tctBgColor.setIndexed(IndexedColors.BRIGHT_GREEN.getIndex());\n+\t\tctPatternFill.setBgColor(ctBgColor);\n+\n+\t\tXSSFCellFill cellFill=new XSSFCellFill(ctFill);\n+\t\tlong index=stylesTable.putFill(cellFill);\n+\t\tcellStyle.getCoreXf().setFillId(index);\n+\n+\t\tassertEquals(2,cellStyle.getCoreXf().getFillId());\n+\t\tassertEquals(IndexedColors.BRIGHT_GREEN.getIndex(), cellStyle.getFillBackgroundColor());\n+\t\t\n+\t\tcellStyle.setFillBackgroundColor(IndexedColors.BLUE.getIndex());\n+\t\tassertEquals(IndexedColors.BLUE.getIndex(), ctFill.getPatternFill().getBgColor().getIndexed());\n+\t\t\n+\t\t//test rgb color - XSSFColor\n+\t\tCTColor ctColor=CTColor.Factory.newInstance();\n+\t\tctColor.setRgb(\"FFFFFF\".getBytes());\n+\t\tctPatternFill.setBgColor(ctColor);\n+\t\tassertEquals(ctColor.toString(), cellStyle.getFillBackgroundRgbColor().getCTColor().toString());\n+\t\t\n+\t\tcellStyle.setFillBackgroundRgbColor(new XSSFColor(ctColor));\n+\t\tassertEquals(ctColor.getRgb()[0], ctPatternFill.getBgColor().getRgb()[0]);\n+\t\tassertEquals(ctColor.getRgb()[1], ctPatternFill.getBgColor().getRgb()[1]);\n+\t\tassertEquals(ctColor.getRgb()[2], ctPatternFill.getBgColor().getRgb()[2]);\n+\t\tassertEquals(ctColor.getRgb()[3], ctPatternFill.getBgColor().getRgb()[3]);\n+\t}\n \t\n-        assertEquals(CellStyle.THICK_FORWARD_DIAG, cellStyle.getFillPattern());\n-        \n-        cellStyle.setFillPattern(CellStyle.BRICKS);\n-        assertEquals(STPatternType.INT_DARK_TRELLIS,ctPatternFill.getPatternType().intValue());\n-    }\n-\n-    public void testGetFont() {\n-        assertNotNull(cellStyle.getFont());\n-    }\n-\n-    public void testGetSetHidden() {\n-        assertFalse(cellStyle.getHidden());\n-        cellXf.getProtection().setHidden(true);\n-        assertTrue(cellStyle.getHidden());\n-        cellStyle.setHidden(false);\n-        assertFalse(cellStyle.getHidden());\n-    }\n-\n-    public void testGetSetLocked() {\n-        assertFalse(cellStyle.getLocked());\n-        cellXf.getProtection().setLocked(true);\n-        assertTrue(cellStyle.getLocked());\n-        cellStyle.setLocked(false);\n-        assertFalse(cellStyle.getLocked());\n-    }\n-\n-    public void testGetSetIndent() {\n-        assertEquals((short)0, cellStyle.getIndention());\n-        cellXf.getAlignment().setIndent(3);\n-        assertEquals((short)3, cellStyle.getIndention());\n-        cellStyle.setIndention((short) 13);\n-        assertEquals((short)13, cellXf.getAlignment().getIndent());\n-    }\n-\n-    public void testGetSetAlignement() {\n-        assertNull(cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n-        assertEquals(HorizontalAlignment.GENERAL, cellStyle.getAlignmentEnum());\n-\n-        cellStyle.setAlignment(XSSFCellStyle.ALIGN_LEFT);\n-        assertEquals(XSSFCellStyle.ALIGN_LEFT, cellStyle.getAlignment());\n-        assertEquals(HorizontalAlignment.LEFT, cellStyle.getAlignmentEnum());\n-        assertEquals(STHorizontalAlignment.LEFT, cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n-\n-        cellStyle.setAlignment(HorizontalAlignment.JUSTIFY);\n-        assertEquals(XSSFCellStyle.ALIGN_JUSTIFY, cellStyle.getAlignment());\n-        assertEquals(HorizontalAlignment.JUSTIFY, cellStyle.getAlignmentEnum());\n-        assertEquals(STHorizontalAlignment.JUSTIFY, cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n-\n-        cellStyle.setAlignment(HorizontalAlignment.CENTER);\n-        assertEquals(XSSFCellStyle.ALIGN_CENTER, cellStyle.getAlignment());\n-        assertEquals(HorizontalAlignment.CENTER, cellStyle.getAlignmentEnum());\n-        assertEquals(STHorizontalAlignment.CENTER, cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n-    }\n-\n-    public void testGetSetVerticalAlignment() {\n-        assertEquals(VerticalAlignment.BOTTOM, cellStyle.getVerticalAlignmentEnum());\n-        assertEquals(XSSFCellStyle.VERTICAL_BOTTOM, cellStyle.getVerticalAlignment());\n-        assertNull(cellStyle.getCellAlignment().getCTCellAlignment().getVertical());\n-\n-        cellStyle.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);\n-        assertEquals(XSSFCellStyle.VERTICAL_CENTER, cellStyle.getVerticalAlignment());\n-        assertEquals(VerticalAlignment.CENTER, cellStyle.getVerticalAlignmentEnum());\n-        assertEquals(STVerticalAlignment.CENTER, cellStyle.getCellAlignment().getCTCellAlignment().getVertical());\n-\n-        cellStyle.setVerticalAlignment(XSSFCellStyle.VERTICAL_JUSTIFY);\n-        assertEquals(XSSFCellStyle.VERTICAL_JUSTIFY, cellStyle.getVerticalAlignment());\n-        assertEquals(VerticalAlignment.JUSTIFY, cellStyle.getVerticalAlignmentEnum());\n-        assertEquals(STVerticalAlignment.JUSTIFY, cellStyle.getCellAlignment().getCTCellAlignment().getVertical());\n-    }\n-\n-    public void testGetSetWrapText() {\n-        assertFalse(cellStyle.getWrapText());\n-        cellXf.getAlignment().setWrapText(true);\n-        assertTrue(cellStyle.getWrapText());\n-        cellStyle.setWrapText(false);\n-        assertFalse(cellXf.getAlignment().getWrapText());\n-    }\n-\n-    /**\n-     * Cloning one XSSFCellStyle onto Another, same XSSFWorkbook\n-     */\n-    public void testCloneStyleSameWB() throws Exception {\n-        // TODO\n-    }\n-    /**\n-     * Cloning one XSSFCellStyle onto Another, different XSSFWorkbooks\n-     */\n-    public void testCloneStyleDiffWB() throws Exception {\n-        // TODO\n-    }\n+\tpublic void testGetFillBackgroundColor_default() {\n+\n+\t\tXSSFWorkbook wb = new XSSFWorkbook();\n+\n+\t\tXSSFCellStyle style = wb.createCellStyle();\n+\n+\t\tshort color;\n+\t\ttry {\n+\t\t\tcolor = style.getFillBackgroundColor();\n+\t\t} catch (NullPointerException e) {\n+\t\t\tthrow new AssertionFailedError(\"Identified bug 45898\");\n+\t\t}\n+\t\tassertEquals(AUTO_COLOR_INDEX, color);\n+\t\tXSSFColor xcolor=style.getFillBackgroundRgbColor();\n+\t\tassertEquals(xcolor.getIndexed(), AUTO_COLOR_INDEX);\n+\t}\n+\t\n+\n+\tpublic void testGetFillForegroundColor() {\n+\n+\t\tCTPatternFill ctPatternFill = ctFill.addNewPatternFill();\n+\t\tCTColor ctFgColor = ctPatternFill.addNewFgColor();\n+\t\tctFgColor.setIndexed(IndexedColors.BRIGHT_GREEN.getIndex());\n+\t\tctPatternFill.setFgColor(ctFgColor);\n+\n+\t\tXSSFCellFill cellFill=new XSSFCellFill(ctFill);\n+\t\tlong index=stylesTable.putFill(cellFill);\n+\t\tcellStyle.getCoreXf().setFillId(index);\n+\n+\t\tassertEquals(2,cellStyle.getCoreXf().getFillId());\n+\t\tassertEquals(IndexedColors.BRIGHT_GREEN.getIndex(), cellStyle.getFillForegroundColor());\n+\t\t\n+\t\tcellStyle.setFillForegroundColor(IndexedColors.BLUE.getIndex());\n+\t\tassertEquals(IndexedColors.BLUE.getIndex(), ctFill.getPatternFill().getFgColor().getIndexed());\n+\t\t\n+\t\t//test rgb color - XSSFColor\n+\t\tCTColor ctColor=CTColor.Factory.newInstance();\n+\t\tctColor.setRgb(\"FFFFFF\".getBytes());\n+\t\tctPatternFill.setFgColor(ctColor);\n+\t\tassertEquals(ctColor.toString(), cellStyle.getFillForegroundRgbColor().getCTColor().toString());\n+\t\t\n+\t\tcellStyle.setFillForegroundRgbColor(new XSSFColor(ctColor));\n+\t\tassertEquals(ctColor.getRgb()[0], ctPatternFill.getFgColor().getRgb()[0]);\n+\t\tassertEquals(ctColor.getRgb()[1], ctPatternFill.getFgColor().getRgb()[1]);\n+\t\tassertEquals(ctColor.getRgb()[2], ctPatternFill.getFgColor().getRgb()[2]);\n+\t\tassertEquals(ctColor.getRgb()[3], ctPatternFill.getFgColor().getRgb()[3]);\n+\t}\n+\t\n+\tpublic void testGetFillForegroundColor_default() {\n+\n+\t\tXSSFWorkbook wb = new XSSFWorkbook();\n+\n+\t\tXSSFCellStyle style = wb.createCellStyle();\n+\n+\t\tshort color;\n+\t\ttry {\n+\t\t\tcolor = style.getFillForegroundColor();\n+\t\t} catch (NullPointerException e) {\n+\t\t\tthrow new AssertionFailedError(\"Identified bug 45898\");\n+\t\t}\n+\t\tassertEquals(AUTO_COLOR_INDEX, color);\n+\t\tXSSFColor xcolor=style.getFillForegroundRgbColor();\n+\t\tassertEquals(xcolor.getIndexed(), AUTO_COLOR_INDEX);\n+\t}\n+\t\n+\n+\tpublic void testGetFillPattern() {\n+\n+\t\tCTPatternFill ctPatternFill = ctFill.addNewPatternFill();\n+\t\tctPatternFill.setPatternType(STPatternType.DARK_DOWN);\n+\t\tXSSFCellFill cellFill=new XSSFCellFill(ctFill);\n+\t\tlong index=stylesTable.putFill(cellFill);\n+\t\tcellStyle.getCoreXf().setFillId(index);\n+\t\n+\t\tassertEquals(CellStyle.THICK_FORWARD_DIAG, cellStyle.getFillPattern());\n+\t\t\n+\t\tcellStyle.setFillPattern(CellStyle.BRICKS);\n+\t\tassertEquals(STPatternType.INT_DARK_TRELLIS,ctPatternFill.getPatternType().intValue());\n+\t}\n+\n+\tpublic void testGetFont() {\n+\t\tassertNotNull(cellStyle.getFont());\n+\t}\n+\n+\tpublic void testGetSetHidden() {\n+\t\tassertFalse(cellStyle.getHidden());\n+\t\tcellXf.getProtection().setHidden(true);\n+\t\tassertTrue(cellStyle.getHidden());\n+\t\tcellStyle.setHidden(false);\n+\t\tassertFalse(cellStyle.getHidden());\n+\t}\n+\n+\tpublic void testGetSetLocked() {\n+\t\tassertFalse(cellStyle.getLocked());\n+\t\tcellXf.getProtection().setLocked(true);\n+\t\tassertTrue(cellStyle.getLocked());\n+\t\tcellStyle.setLocked(false);\n+\t\tassertFalse(cellStyle.getLocked());\n+\t}\n+\n+\tpublic void testGetSetIndent() {\n+\t\tassertEquals((short)0, cellStyle.getIndention());\n+\t\tcellXf.getAlignment().setIndent(3);\n+\t\tassertEquals((short)3, cellStyle.getIndention());\n+\t\tcellStyle.setIndention((short) 13);\n+\t\tassertEquals((short)13, cellXf.getAlignment().getIndent());\n+\t}\n+\n+\tpublic void testGetSetAlignement() {\n+\t\tassertNull(cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n+\t\tassertEquals(HorizontalAlignment.GENERAL, cellStyle.getAlignmentEnum());\n+\n+\t\tcellStyle.setAlignment(XSSFCellStyle.ALIGN_LEFT);\n+\t\tassertEquals(XSSFCellStyle.ALIGN_LEFT, cellStyle.getAlignment());\n+\t\tassertEquals(HorizontalAlignment.LEFT, cellStyle.getAlignmentEnum());\n+\t\tassertEquals(STHorizontalAlignment.LEFT, cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n+\n+\t\tcellStyle.setAlignment(HorizontalAlignment.JUSTIFY);\n+\t\tassertEquals(XSSFCellStyle.ALIGN_JUSTIFY, cellStyle.getAlignment());\n+\t\tassertEquals(HorizontalAlignment.JUSTIFY, cellStyle.getAlignmentEnum());\n+\t\tassertEquals(STHorizontalAlignment.JUSTIFY, cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n+\n+\t\tcellStyle.setAlignment(HorizontalAlignment.CENTER);\n+\t\tassertEquals(XSSFCellStyle.ALIGN_CENTER, cellStyle.getAlignment());\n+\t\tassertEquals(HorizontalAlignment.CENTER, cellStyle.getAlignmentEnum());\n+\t\tassertEquals(STHorizontalAlignment.CENTER, cellStyle.getCellAlignment().getCTCellAlignment().getHorizontal());\n+\t}\n+\n+\tpublic void testGetSetVerticalAlignment() {\n+\t\tassertEquals(VerticalAlignment.BOTTOM, cellStyle.getVerticalAlignmentEnum());\n+\t\tassertEquals(XSSFCellStyle.VERTICAL_BOTTOM, cellStyle.getVerticalAlignment());\n+\t\tassertNull(cellStyle.getCellAlignment().getCTCellAlignment().getVertical());\n+\n+\t\tcellStyle.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);\n+\t\tassertEquals(XSSFCellStyle.VERTICAL_CENTER, cellStyle.getVerticalAlignment());\n+\t\tassertEquals(VerticalAlignment.CENTER, cellStyle.getVerticalAlignmentEnum());\n+\t\tassertEquals(STVerticalAlignment.CENTER, cellStyle.getCellAlignment().getCTCellAlignment().getVertical());\n+\n+\t\tcellStyle.setVerticalAlignment(XSSFCellStyle.VERTICAL_JUSTIFY);\n+\t\tassertEquals(XSSFCellStyle.VERTICAL_JUSTIFY, cellStyle.getVerticalAlignment());\n+\t\tassertEquals(VerticalAlignment.JUSTIFY, cellStyle.getVerticalAlignmentEnum());\n+\t\tassertEquals(STVerticalAlignment.JUSTIFY, cellStyle.getCellAlignment().getCTCellAlignment().getVertical());\n+\t}\n+\n+\tpublic void testGetSetWrapText() {\n+\t\tassertFalse(cellStyle.getWrapText());\n+\t\tcellXf.getAlignment().setWrapText(true);\n+\t\tassertTrue(cellStyle.getWrapText());\n+\t\tcellStyle.setWrapText(false);\n+\t\tassertFalse(cellXf.getAlignment().getWrapText());\n+\t}\n+\n+\t/**\n+\t * Cloning one XSSFCellStyle onto Another, same XSSFWorkbook\n+\t */\n+\tpublic void testCloneStyleSameWB() throws Exception {\n+\t\t// TODO\n+\t}\n+\t/**\n+\t * Cloning one XSSFCellStyle onto Another, different XSSFWorkbooks\n+\t */\n+\tpublic void testCloneStyleDiffWB() throws Exception {\n+\t\t// TODO\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCellStyle.java",
                "sha": "e1207d681d37ad28b53e829131354f1c62c414ad",
                "status": "modified"
            },
            {
                "additions": 383,
                "blob_url": "https://github.com/apache/poi/blob/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "changes": 767,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java?ref=93e1ccd36b21d32234bc04198a2592cb48187919",
                "deletions": 384,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "patch": "@@ -17,20 +17,21 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xssf.usermodel;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n+import java.io.IOException;\n import java.io.OutputStream;\n \n import junit.framework.TestCase;\n \n+import org.apache.poi.hssf.HSSFTestDataSamples;\n import org.apache.poi.ss.usermodel.CellStyle;\n import org.apache.poi.ss.usermodel.Font;\n import org.apache.poi.ss.usermodel.Name;\n import org.apache.poi.ss.usermodel.RichTextString;\n import org.apache.poi.ss.usermodel.Sheet;\n import org.apache.poi.ss.usermodel.StylesSource;\n+import org.apache.poi.xssf.XSSFTestDataSamples;\n import org.apache.poi.xssf.model.StylesTable;\n import org.openxml4j.opc.ContentTypes;\n import org.openxml4j.opc.Package;\n@@ -39,323 +40,309 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTSheet;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorkbook;\n \n-public class TestXSSFWorkbook extends TestCase {\n-    public TestXSSFWorkbook(String name) {\n-\t\tsuper(name);\n-\t\t\n+public final class TestXSSFWorkbook extends TestCase {\n+\n+\t@Override\n+\tprotected void setUp() throws Exception {\n \t\t// Use system out logger\n-\t    System.setProperty(\n-\t            \"org.apache.poi.util.POILogger\",\n-\t            \"org.apache.poi.util.SystemOutLogger\"\n-\t    );\n+\t\tSystem.setProperty(\n+\t\t\t\t\"org.apache.poi.util.POILogger\",\n+\t\t\t\t\"org.apache.poi.util.SystemOutLogger\"\n+\t\t);\n \t}\n \n \tpublic void testGetSheetIndex() {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        assertEquals(0, workbook.getSheetIndex(sheet1));\n-        assertEquals(0, workbook.getSheetIndex(\"sheet1\"));\n-        assertEquals(1, workbook.getSheetIndex(sheet2));\n-        assertEquals(1, workbook.getSheetIndex(\"sheet2\"));\n-        assertEquals(-1, workbook.getSheetIndex(\"noSheet\"));\n-    }\n-    \n-    public void testSetSheetOrder() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        assertSame(sheet1, workbook.getSheetAt(0));\n-        assertSame(sheet2, workbook.getSheetAt(1));\n-        workbook.setSheetOrder(\"sheet2\", 0);\n-        assertSame(sheet2, workbook.getSheetAt(0));\n-        assertSame(sheet1, workbook.getSheetAt(1));\n-        // Test reordering of CTSheets\n-        CTWorkbook ctwb = workbook.getWorkbook();\n-        CTSheet[] ctsheets = ctwb.getSheets().getSheetArray();\n-        assertEquals(\"sheet2\", ctsheets[0].getName());\n-        assertEquals(\"sheet1\", ctsheets[1].getName());\n-        \n-        // Borderline case: only one sheet\n-        workbook = new XSSFWorkbook();\n-        sheet1 = workbook.createSheet(\"sheet1\");\n-        assertSame(sheet1, workbook.getSheetAt(0));\n-        workbook.setSheetOrder(\"sheet1\", 0);\n-        assertSame(sheet1, workbook.getSheetAt(0));\n-    }\n-    \n-    public void testSetSelectedTab() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        assertEquals(0, workbook.getSelectedTab());\n-        workbook.setSelectedTab((short) 0);\n-        assertEquals(0, workbook.getSelectedTab());\n-        workbook.setSelectedTab((short) 1);\n-        assertEquals(1, workbook.getSelectedTab());\n-    }\n-    \n-    public void testSetSheetName() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        assertEquals(\"sheet1\", workbook.getSheetName(0));\n-        workbook.setSheetName(0, \"sheet2\");\n-        assertEquals(\"sheet2\", workbook.getSheetName(0));\n-    }\n-    \n-    public void testCloneSheet() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet\");\n-        Sheet sheet2 = workbook.cloneSheet(0);\n-        assertEquals(2, workbook.getNumberOfSheets());\n-        assertEquals(\"sheet(1)\", workbook.getSheetName(1));\n-        workbook.setSheetName(1, \"clonedsheet\");\n-        Sheet sheet3 = workbook.cloneSheet(1);\n-        assertEquals(3, workbook.getNumberOfSheets());\n-        assertEquals(\"clonedsheet(1)\", workbook.getSheetName(2));\n-    }\n-    \n-    public void testGetSheetByName() {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        assertSame(sheet1, workbook.getSheet(\"sheet1\"));\n-        assertSame(sheet2, workbook.getSheet(\"sheet2\"));\n-        assertNull(workbook.getSheet(\"nosheet\"));\n-    }\n-    \n-    public void testRemoveSheetAt() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        Sheet sheet3 = workbook.createSheet(\"sheet3\");\n-        workbook.removeSheetAt(1);\n-        assertEquals(2, workbook.getNumberOfSheets());\n-        assertEquals(\"sheet3\", workbook.getSheetName(1));\n-        workbook.removeSheetAt(0);\n-        assertEquals(1, workbook.getNumberOfSheets());\n-        assertEquals(\"sheet3\", workbook.getSheetName(0));\n-        workbook.removeSheetAt(0);\n-        assertEquals(0, workbook.getNumberOfSheets());\n-    }\n-    \n-    /**\n-     * Tests that we can save a new document\n-     */\n-    public void testSaveNew() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        Sheet sheet3 = workbook.createSheet(\"sheet3\");\n-        File file = File.createTempFile(\"poi-\", \".xlsx\");\n-        System.out.println(\"Saving newly created file to \" + file.getAbsolutePath());\n-        OutputStream out = new FileOutputStream(file);\n-        workbook.write(out);\n-        out.close();\n-    }\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tSheet sheet1 = workbook.createSheet(\"sheet1\");\n+\t\tSheet sheet2 = workbook.createSheet(\"sheet2\");\n+\t\tassertEquals(0, workbook.getSheetIndex(sheet1));\n+\t\tassertEquals(0, workbook.getSheetIndex(\"sheet1\"));\n+\t\tassertEquals(1, workbook.getSheetIndex(sheet2));\n+\t\tassertEquals(1, workbook.getSheetIndex(\"sheet2\"));\n+\t\tassertEquals(-1, workbook.getSheetIndex(\"noSheet\"));\n+\t}\n+\t\n+\tpublic void testSetSheetOrder() {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tSheet sheet1 = workbook.createSheet(\"sheet1\");\n+\t\tSheet sheet2 = workbook.createSheet(\"sheet2\");\n+\t\tassertSame(sheet1, workbook.getSheetAt(0));\n+\t\tassertSame(sheet2, workbook.getSheetAt(1));\n+\t\tworkbook.setSheetOrder(\"sheet2\", 0);\n+\t\tassertSame(sheet2, workbook.getSheetAt(0));\n+\t\tassertSame(sheet1, workbook.getSheetAt(1));\n+\t\t// Test reordering of CTSheets\n+\t\tCTWorkbook ctwb = workbook.getWorkbook();\n+\t\tCTSheet[] ctsheets = ctwb.getSheets().getSheetArray();\n+\t\tassertEquals(\"sheet2\", ctsheets[0].getName());\n+\t\tassertEquals(\"sheet1\", ctsheets[1].getName());\n+\t\t\n+\t\t// Borderline case: only one sheet\n+\t\tworkbook = new XSSFWorkbook();\n+\t\tsheet1 = workbook.createSheet(\"sheet1\");\n+\t\tassertSame(sheet1, workbook.getSheetAt(0));\n+\t\tworkbook.setSheetOrder(\"sheet1\", 0);\n+\t\tassertSame(sheet1, workbook.getSheetAt(0));\n+\t}\n+\t\n+\tpublic void testSetSelectedTab() {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tworkbook.createSheet(\"sheet1\");\n+\t\tworkbook.createSheet(\"sheet2\");\n+\t\tassertEquals(0, workbook.getSelectedTab());\n+\t\tworkbook.setSelectedTab((short) 0);\n+\t\tassertEquals(0, workbook.getSelectedTab());\n+\t\tworkbook.setSelectedTab((short) 1);\n+\t\tassertEquals(1, workbook.getSelectedTab());\n+\t}\n+\t\n+\tpublic void testSetSheetName() {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tworkbook.createSheet(\"sheet1\");\n+\t\tassertEquals(\"sheet1\", workbook.getSheetName(0));\n+\t\tworkbook.setSheetName(0, \"sheet2\");\n+\t\tassertEquals(\"sheet2\", workbook.getSheetName(0));\n+\t}\n+\t\n+\tpublic void testCloneSheet() {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tworkbook.createSheet(\"sheet\");\n+\t\tworkbook.cloneSheet(0);\n+\t\tassertEquals(2, workbook.getNumberOfSheets());\n+\t\tassertEquals(\"sheet(1)\", workbook.getSheetName(1));\n+\t\tworkbook.setSheetName(1, \"clonedsheet\");\n+\t\tworkbook.cloneSheet(1);\n+\t\tassertEquals(3, workbook.getNumberOfSheets());\n+\t\tassertEquals(\"clonedsheet(1)\", workbook.getSheetName(2));\n+\t}\n+\t\n+\tpublic void testGetSheetByName() {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tSheet sheet1 = workbook.createSheet(\"sheet1\");\n+\t\tSheet sheet2 = workbook.createSheet(\"sheet2\");\n+\t\tassertSame(sheet1, workbook.getSheet(\"sheet1\"));\n+\t\tassertSame(sheet2, workbook.getSheet(\"sheet2\"));\n+\t\tassertNull(workbook.getSheet(\"nosheet\"));\n+\t}\n+\t\n+\tpublic void testRemoveSheetAt() {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tworkbook.createSheet(\"sheet1\");\n+\t\tworkbook.createSheet(\"sheet2\");\n+\t\tworkbook.createSheet(\"sheet3\");\n+\t\tworkbook.removeSheetAt(1);\n+\t\tassertEquals(2, workbook.getNumberOfSheets());\n+\t\tassertEquals(\"sheet3\", workbook.getSheetName(1));\n+\t\tworkbook.removeSheetAt(0);\n+\t\tassertEquals(1, workbook.getNumberOfSheets());\n+\t\tassertEquals(\"sheet3\", workbook.getSheetName(0));\n+\t\tworkbook.removeSheetAt(0);\n+\t\tassertEquals(0, workbook.getNumberOfSheets());\n+\t}\n+\t\n+\t/**\n+\t * Tests that we can save a new document\n+\t */\n+\tpublic void testSaveNew() throws IOException {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tworkbook.createSheet(\"sheet1\");\n+\t\tworkbook.createSheet(\"sheet2\");\n+\t\tworkbook.createSheet(\"sheet3\");\n+\t\tFile file = File.createTempFile(\"poi-\", \".xlsx\");\n+\t\tSystem.out.println(\"Saving newly created file to \" + file.getAbsolutePath());\n+\t\tOutputStream out = new FileOutputStream(file);\n+\t\tworkbook.write(out);\n+\t\tout.close();\n+\t}\n \n-    /**\n-     * Tests that we can save, and then re-load a new document\n-     */\n-    public void testSaveLoadNew() throws Exception {\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        Sheet sheet1 = workbook.createSheet(\"sheet1\");\n-        Sheet sheet2 = workbook.createSheet(\"sheet2\");\n-        Sheet sheet3 = workbook.createSheet(\"sheet3\");\n-        \n-        RichTextString rts = workbook.getCreationHelper().createRichTextString(\"hello world\");\n-        \n-        sheet1.createRow(0).createCell((short)0).setCellValue(1.2);\n-        sheet1.createRow(1).createCell((short)0).setCellValue(rts);\n-        sheet2.createRow(0);\n-        \n-        assertEquals(0, workbook.getSheetAt(0).getFirstRowNum());\n-        assertEquals(1, workbook.getSheetAt(0).getLastRowNum());\n-        assertEquals(0, workbook.getSheetAt(1).getFirstRowNum());\n-        assertEquals(0, workbook.getSheetAt(1).getLastRowNum());\n-        assertEquals(-1, workbook.getSheetAt(2).getFirstRowNum());\n-        assertEquals(-1, workbook.getSheetAt(2).getLastRowNum());\n-        \n-        File file = File.createTempFile(\"poi-\", \".xlsx\");\n-        OutputStream out = new FileOutputStream(file);\n-        workbook.write(out);\n-        out.close();\n-        \n-        // Check the package contains what we'd expect it to\n-        Package pkg = Package.open(file.toString());\n-        PackagePart wbRelPart = \n-        \tpkg.getPart(PackagingURIHelper.createPartName(\"/xl/_rels/workbook.xml.rels\"));\n-        assertNotNull(wbRelPart);\n-        assertTrue(wbRelPart.isRelationshipPart());\n-        assertEquals(ContentTypes.RELATIONSHIPS_PART, wbRelPart.getContentType());\n-        \n-        PackagePart wbPart = \n-        \tpkg.getPart(PackagingURIHelper.createPartName(\"/xl/workbook.xml\"));\n-        // Links to the three sheets, shared strings and styles\n-        assertTrue(wbPart.hasRelationships());\n-        assertEquals(5, wbPart.getRelationships().size());\n-        \n-        // Load back the XSSFWorkbook\n-        workbook = new XSSFWorkbook(pkg);\n-        assertEquals(3, workbook.getNumberOfSheets());\n-        assertNotNull(workbook.getSheetAt(0));\n-        assertNotNull(workbook.getSheetAt(1));\n-        assertNotNull(workbook.getSheetAt(2));\n-        \n-        assertNotNull(workbook.getSharedStringSource());\n-        assertNotNull(workbook.getStylesSource());\n-        \n-        assertEquals(0, workbook.getSheetAt(0).getFirstRowNum());\n-        assertEquals(1, workbook.getSheetAt(0).getLastRowNum());\n-        assertEquals(0, workbook.getSheetAt(1).getFirstRowNum());\n-        assertEquals(0, workbook.getSheetAt(1).getLastRowNum());\n-        assertEquals(-1, workbook.getSheetAt(2).getFirstRowNum());\n-        assertEquals(-1, workbook.getSheetAt(2).getLastRowNum());\n-        \n-        sheet1 = workbook.getSheetAt(0);\n-        assertEquals(1.2, sheet1.getRow(0).getCell(0).getNumericCellValue(), 0.0001);\n-        assertEquals(\"hello world\", sheet1.getRow(1).getCell(0).getRichStringCellValue().getString());\n-    }\n-    \n-    public void testExisting() throws Exception {\n-\t\tFile xml = new File(\n-\t\t\t\tSystem.getProperty(\"HSSF.testdata.path\") +\n-\t\t\t\tFile.separator + \"Formatting.xlsx\"\n-\t\t);\n-\t\tassertTrue(xml.exists());\n-    \t\n-\t\tXSSFWorkbook workbook = new XSSFWorkbook(xml.toString());\n+\t/**\n+\t * Tests that we can save, and then re-load a new document\n+\t */\n+\tpublic void testSaveLoadNew() throws Exception {\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tSheet sheet1 = workbook.createSheet(\"sheet1\");\n+\t\tSheet sheet2 = workbook.createSheet(\"sheet2\");\n+\t\tworkbook.createSheet(\"sheet3\");\n+\t\t\n+\t\tRichTextString rts = workbook.getCreationHelper().createRichTextString(\"hello world\");\n+\t\t\n+\t\tsheet1.createRow(0).createCell((short)0).setCellValue(1.2);\n+\t\tsheet1.createRow(1).createCell((short)0).setCellValue(rts);\n+\t\tsheet2.createRow(0);\n+\t\t\n+\t\tassertEquals(0, workbook.getSheetAt(0).getFirstRowNum());\n+\t\tassertEquals(1, workbook.getSheetAt(0).getLastRowNum());\n+\t\tassertEquals(0, workbook.getSheetAt(1).getFirstRowNum());\n+\t\tassertEquals(0, workbook.getSheetAt(1).getLastRowNum());\n+\t\tassertEquals(-1, workbook.getSheetAt(2).getFirstRowNum());\n+\t\tassertEquals(-1, workbook.getSheetAt(2).getLastRowNum());\n+\t\t\n+\t\tFile file = File.createTempFile(\"poi-\", \".xlsx\");\n+\t\tOutputStream out = new FileOutputStream(file);\n+\t\tworkbook.write(out);\n+\t\tout.close();\n+\t\t\n+\t\t// Check the package contains what we'd expect it to\n+\t\tPackage pkg = Package.open(file.toString());\n+\t\tPackagePart wbRelPart = \n+\t\t\tpkg.getPart(PackagingURIHelper.createPartName(\"/xl/_rels/workbook.xml.rels\"));\n+\t\tassertNotNull(wbRelPart);\n+\t\tassertTrue(wbRelPart.isRelationshipPart());\n+\t\tassertEquals(ContentTypes.RELATIONSHIPS_PART, wbRelPart.getContentType());\n+\t\t\n+\t\tPackagePart wbPart = \n+\t\t\tpkg.getPart(PackagingURIHelper.createPartName(\"/xl/workbook.xml\"));\n+\t\t// Links to the three sheets, shared strings and styles\n+\t\tassertTrue(wbPart.hasRelationships());\n+\t\tassertEquals(5, wbPart.getRelationships().size());\n+\t\t\n+\t\t// Load back the XSSFWorkbook\n+\t\tworkbook = new XSSFWorkbook(pkg);\n+\t\tassertEquals(3, workbook.getNumberOfSheets());\n+\t\tassertNotNull(workbook.getSheetAt(0));\n+\t\tassertNotNull(workbook.getSheetAt(1));\n+\t\tassertNotNull(workbook.getSheetAt(2));\n+\t\t\n+\t\tassertNotNull(workbook.getSharedStringSource());\n+\t\tassertNotNull(workbook.getStylesSource());\n+\t\t\n+\t\tassertEquals(0, workbook.getSheetAt(0).getFirstRowNum());\n+\t\tassertEquals(1, workbook.getSheetAt(0).getLastRowNum());\n+\t\tassertEquals(0, workbook.getSheetAt(1).getFirstRowNum());\n+\t\tassertEquals(0, workbook.getSheetAt(1).getLastRowNum());\n+\t\tassertEquals(-1, workbook.getSheetAt(2).getFirstRowNum());\n+\t\tassertEquals(-1, workbook.getSheetAt(2).getLastRowNum());\n+\t\t\n+\t\tsheet1 = workbook.getSheetAt(0);\n+\t\tassertEquals(1.2, sheet1.getRow(0).getCell(0).getNumericCellValue(), 0.0001);\n+\t\tassertEquals(\"hello world\", sheet1.getRow(1).getCell(0).getRichStringCellValue().getString());\n+\t}\n+\t\n+\tpublic void testExisting() throws Exception {\n+\t\t\n+\t\tXSSFWorkbook workbook = XSSFTestDataSamples.openSampleWorkbook(\"Formatting.xlsx\");\n \t\tassertNotNull(workbook.getSharedStringSource());\n \t\tassertNotNull(workbook.getStylesSource());\n \t\t\n \t\t// And check a few low level bits too\n-\t\tPackage pkg = Package.open(xml.toString());\n-        PackagePart wbPart = \n-        \tpkg.getPart(PackagingURIHelper.createPartName(\"/xl/workbook.xml\"));\n-        \n-        // Links to the three sheets, shared, styles and themes\n-        assertTrue(wbPart.hasRelationships());\n-        assertEquals(6, wbPart.getRelationships().size());\n+\t\tPackage pkg = Package.open(HSSFTestDataSamples.openSampleFileStream(\"Formatting.xlsx\"));\n+\t\tPackagePart wbPart = \n+\t\t\tpkg.getPart(PackagingURIHelper.createPartName(\"/xl/workbook.xml\"));\n+\t\t\n+\t\t// Links to the three sheets, shared, styles and themes\n+\t\tassertTrue(wbPart.hasRelationships());\n+\t\tassertEquals(6, wbPart.getRelationships().size());\n \n-    }\n-    \n-    public void testFindFont(){\n-        //get default font and check against default value\n-    \tXSSFWorkbook workbook = new XSSFWorkbook();\n-    \tFont fontFind=workbook.findFont(Font.BOLDWEIGHT_NORMAL, IndexedColors.BLACK.getIndex(), (short)11, \"Calibri\", false, false, Font.SS_NONE, Font.U_NONE);\n-    \tassertNotNull(fontFind);\n-    \t\n-    \t//get default font, then change 2 values and check against different values (height changes)\n-    \tFont font=workbook.createFont();\n-    \t((XSSFFont)font).setBold(true);\n-    \tfont.setUnderline(Font.U_DOUBLE);\n-    \tStylesSource styleSource=new StylesTable();\n-    \tlong index=styleSource.putFont(font);\n-    \tSystem.out.println(\"index=\"+index);\n-    \tworkbook.setStylesSource(styleSource);\n-    \tfontFind=workbook.findFont(Font.BOLDWEIGHT_BOLD, IndexedColors.BLACK.getIndex(), (short)15, \"Calibri\", false, false, Font.SS_NONE, Font.U_DOUBLE);\n-        assertNull(fontFind);\n-    }\n+\t}\n+\t\n+\tpublic void testFindFont(){\n+\t\t//get default font and check against default value\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tFont fontFind=workbook.findFont(Font.BOLDWEIGHT_NORMAL, IndexedColors.BLACK.getIndex(), (short)11, \"Calibri\", false, false, Font.SS_NONE, Font.U_NONE);\n+\t\tassertNotNull(fontFind);\n+\t\t\n+\t\t//get default font, then change 2 values and check against different values (height changes)\n+\t\tFont font=workbook.createFont();\n+\t\t((XSSFFont)font).setBold(true);\n+\t\tfont.setUnderline(Font.U_DOUBLE);\n+\t\tStylesSource styleSource=new StylesTable();\n+\t\tlong index=styleSource.putFont(font);\n+\t\tSystem.out.println(\"index=\"+index);\n+\t\tworkbook.setStylesSource(styleSource);\n+\t\tfontFind=workbook.findFont(Font.BOLDWEIGHT_BOLD, IndexedColors.BLACK.getIndex(), (short)15, \"Calibri\", false, false, Font.SS_NONE, Font.U_DOUBLE);\n+\t\tassertNull(fontFind);\n+\t}\n \n-    public void testGetCellStyleAt(){\n-     \tXSSFWorkbook workbook = new XSSFWorkbook();\n-        short i = 0;\n-        //get default style\n-        CellStyle cellStyleAt = workbook.getCellStyleAt(i);\n-        assertNotNull(cellStyleAt);\n-        \n-        //get custom style\n-        StylesSource styleSource = workbook.getStylesSource();\n-        CellStyle customStyle = new XSSFCellStyle(styleSource);\n-        Font font = new XSSFFont();\n-        font.setFontName(\"Verdana\");\n-        customStyle.setFont(font);\n-        Long x = styleSource.putStyle(customStyle);\n-        cellStyleAt = workbook.getCellStyleAt(x.shortValue());\n-        assertNotNull(cellStyleAt);        \n-    }\n-    \n-    public void testGetFontAt(){\n-     \tXSSFWorkbook workbook = new XSSFWorkbook();\n-        StylesSource styleSource = workbook.getStylesSource();\n-        short i = 0;\n-        //get default font\n-        Font fontAt = workbook.getFontAt(i);\n-        assertNotNull(fontAt);\n-        \n-        //get customized font\n-        Font customFont = new XSSFFont();\n-        customFont.setItalic(true);\n-        Long x = styleSource.putFont(customFont);\n-        fontAt = workbook.getFontAt(x.shortValue());\n-        assertNotNull(fontAt);\n-    }\n-    \n-    public void testGetNumberOfFonts(){\n-     \tXSSFWorkbook wb = new XSSFWorkbook();\n+\tpublic void testGetCellStyleAt(){\n+\t \tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tshort i = 0;\n+\t\t//get default style\n+\t\tCellStyle cellStyleAt = workbook.getCellStyleAt(i);\n+\t\tassertNotNull(cellStyleAt);\n+\t\t\n+\t\t//get custom style\n+\t\tStylesSource styleSource = workbook.getStylesSource();\n+\t\tCellStyle customStyle = new XSSFCellStyle(styleSource);\n+\t\tFont font = new XSSFFont();\n+\t\tfont.setFontName(\"Verdana\");\n+\t\tcustomStyle.setFont(font);\n+\t\tLong x = styleSource.putStyle(customStyle);\n+\t\tcellStyleAt = workbook.getCellStyleAt(x.shortValue());\n+\t\tassertNotNull(cellStyleAt);\t\t\n+\t}\n+\t\n+\tpublic void testGetFontAt(){\n+\t \tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tStylesSource styleSource = workbook.getStylesSource();\n+\t\tshort i = 0;\n+\t\t//get default font\n+\t\tFont fontAt = workbook.getFontAt(i);\n+\t\tassertNotNull(fontAt);\n+\t\t\n+\t\t//get customized font\n+\t\tFont customFont = new XSSFFont();\n+\t\tcustomFont.setItalic(true);\n+\t\tLong x = styleSource.putFont(customFont);\n+\t\tfontAt = workbook.getFontAt(x.shortValue());\n+\t\tassertNotNull(fontAt);\n+\t}\n+\t\n+\tpublic void testGetNumberOfFonts(){\n+\t \tXSSFWorkbook wb = new XSSFWorkbook();\n \n-        XSSFFont f1=wb.createFont();\n-     \tf1.setBold(true);\n-     \twb.createCellStyle().setFont(f1);\n+\t\tXSSFFont f1=wb.createFont();\n+\t \tf1.setBold(true);\n+\t \twb.createCellStyle().setFont(f1);\n \n-        XSSFFont f2=wb.createFont();\n-     \tf2.setUnderline(Font.U_DOUBLE);\n-        wb.createCellStyle().setFont(f2);\n+\t\tXSSFFont f2=wb.createFont();\n+\t \tf2.setUnderline(Font.U_DOUBLE);\n+\t\twb.createCellStyle().setFont(f2);\n \n-        XSSFFont f3=wb.createFont();\n-     \tf3.setFontHeightInPoints((short)23);\n-        wb.createCellStyle().setFont(f3);\n+\t\tXSSFFont f3=wb.createFont();\n+\t \tf3.setFontHeightInPoints((short)23);\n+\t\twb.createCellStyle().setFont(f3);\n \n-        assertEquals(4,wb.getNumberOfFonts());\n-     \tassertEquals(Font.U_DOUBLE,wb.getFontAt((short)2).getUnderline());\n-    }\n-    \n-    public void testGetNumCellStyles(){\n-     \tXSSFWorkbook workbook = new XSSFWorkbook();\n-        short i = workbook.getNumCellStyles();\n-        //get default cellStyles\n-        assertEquals(1, i);\n-        //get wrong value\n-        assertNotSame(2, i);        \n-    }\n-    \n-    public void testGetDisplayedTab(){\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        short i = (short) workbook.getFirstVisibleTab();\n-        //get default diplayedTab\n-        assertEquals(0, i);        \n-    }\n-    \n-    public void testSetDisplayedTab(){\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        workbook.setFirstVisibleTab(new Integer(1).shortValue());\n-        short i = (short) workbook.getFirstVisibleTab();\n-        //0 (defualt value) is not longer set\n-        assertNotSame(0, i);\n-        //1 is the default tab\n-        assertEquals(1, i);\n-    }\n-    \n-    \n-    public void testLoadSave() throws Exception {\n-\t\tFile xml = new File(\n-\t\t\t\tSystem.getProperty(\"HSSF.testdata.path\") +\n-\t\t\t\tFile.separator + \"Formatting.xlsx\"\n-\t\t);\n-\t\tassertTrue(xml.exists());\n-    \t\n-\t\tXSSFWorkbook workbook = new XSSFWorkbook(xml.toString());\n+\t\tassertEquals(4,wb.getNumberOfFonts());\n+\t \tassertEquals(Font.U_DOUBLE,wb.getFontAt((short)2).getUnderline());\n+\t}\n+\t\n+\tpublic void testGetNumCellStyles(){\n+\t \tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tshort i = workbook.getNumCellStyles();\n+\t\t//get default cellStyles\n+\t\tassertEquals(1, i);\n+\t\t//get wrong value\n+\t\tassertNotSame(2, i);\t\t\n+\t}\n+\t\n+\tpublic void testGetDisplayedTab(){\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tshort i = (short) workbook.getFirstVisibleTab();\n+\t\t//get default diplayedTab\n+\t\tassertEquals(0, i);\t\t\n+\t}\n+\t\n+\tpublic void testSetDisplayedTab(){\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tworkbook.setFirstVisibleTab(new Integer(1).shortValue());\n+\t\tshort i = (short) workbook.getFirstVisibleTab();\n+\t\t//0 (defualt value) is not longer set\n+\t\tassertNotSame(0, i);\n+\t\t//1 is the default tab\n+\t\tassertEquals(1, i);\n+\t}\n+\t\n+\t\n+\tpublic void testLoadSave() {\n+\t\tXSSFWorkbook workbook = XSSFTestDataSamples.openSampleWorkbook(\"Formatting.xlsx\");\n \t\tassertEquals(3, workbook.getNumberOfSheets());\n \t\tassertEquals(\"dd/mm/yyyy\", workbook.getSheetAt(0).getRow(1).getCell(0).getRichStringCellValue().getString());\n \t\tassertNotNull(workbook.getSharedStringSource());\n \t\tassertNotNull(workbook.getStylesSource());\n \t\t\n \t\t// Write out, and check\n-\t\tFile tmpFile = File.createTempFile(\"poi-tmp\", \".xlsx\");\n-\t\tworkbook.write(new FileOutputStream(tmpFile));\n-\t\t\n \t\t// Load up again, check all still there\n-\t\tXSSFWorkbook wb2 = new XSSFWorkbook(tmpFile.toString());\n+\t\tXSSFWorkbook wb2 = XSSFTestDataSamples.writeOutAndReadBack(workbook);\n \t\tassertEquals(3, wb2.getNumberOfSheets());\n \t\tassertNotNull(wb2.getSheetAt(0));\n \t\tassertNotNull(wb2.getSheetAt(1));\n@@ -367,16 +354,10 @@ public void testLoadSave() throws Exception {\n \t\tassertEquals(\"yy/mm/dd\", wb2.getSheetAt(0).getRow(4).getCell(0).getRichStringCellValue().getString());\n \t\tassertNotNull(wb2.getSharedStringSource());\n \t\tassertNotNull(wb2.getStylesSource());\n-    }\n-    \n-    public void testStyles() throws Exception {\n-\t\tFile xml = new File(\n-\t\t\t\tSystem.getProperty(\"HSSF.testdata.path\") +\n-\t\t\t\tFile.separator + \"Formatting.xlsx\"\n-\t\t);\n-\t\tassertTrue(xml.exists());\n-    \t\n-\t\tXSSFWorkbook workbook = new XSSFWorkbook(xml.toString());\n+\t}\n+\t\n+\tpublic void testStyles() {\n+\t\tXSSFWorkbook workbook = XSSFTestDataSamples.openSampleWorkbook(\"Formatting.xlsx\");\n \t\t\n \t\tStylesSource ss = workbook.getStylesSource();\n \t\tassertNotNull(ss);\n@@ -403,12 +384,9 @@ public void testStyles() throws Exception {\n \t\t\n \t\t\n \t\t// Save, load back in again, and check\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        workbook.write(baos);\n-        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n-        workbook = new XSSFWorkbook(Package.open(bais));\n-        \n-        ss = workbook.getStylesSource();\n+\t\tworkbook = XSSFTestDataSamples.writeOutAndReadBack(workbook);\n+\t\t\n+\t\tss = workbook.getStylesSource();\n \t\tassertNotNull(ss);\n \t\tassertTrue(ss instanceof StylesTable);\n \t\tst = (StylesTable)ss;\n@@ -417,75 +395,96 @@ public void testStyles() throws Exception {\n \t\tassertEquals(2, st._getFontsSize());\n \t\tassertEquals(2, st._getFillsSize());\n \t\tassertEquals(1, st._getBordersSize());\n-    }\n-    \n-    public void testNamedRanges() throws Exception {\n-    \t// First up, a new file\n-        XSSFWorkbook workbook = new XSSFWorkbook();\n-        assertEquals(0, workbook.getNumberOfNames());\n-        \n-        Name nameA = workbook.createName();\n-        nameA.setReference(\"A2\");\n-        nameA.setNameName(\"ForA2\");\n-        \n-        XSSFName nameB = workbook.createName();\n-        nameB.setReference(\"B3\");\n-        nameB.setNameName(\"ForB3\");\n-        nameB.setComment(\"B3 Comment\");\n-        \n-        // Save and re-load\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        workbook.write(baos);\n-        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n-        workbook = new XSSFWorkbook(Package.open(bais));\n-        \n-        assertEquals(2, workbook.getNumberOfNames());\n-        assertEquals(\"A2\", workbook.getNameAt(0).getReference());\n-        assertEquals(\"ForA2\", workbook.getNameAt(0).getNameName());\n-        assertNull(workbook.getNameAt(0).getComment());\n-        \n-        assertEquals(\"B3\", workbook.getNameAt(1).getReference());\n-        assertEquals(\"ForB3\", workbook.getNameAt(1).getNameName());\n-        assertEquals(\"B3 Comment\", workbook.getNameAt(1).getComment());\n-        \n-        assertEquals(\"ForA2\", workbook.getNameName(0));\n-        assertEquals(1, workbook.getNameIndex(\"ForB3\"));\n-        assertEquals(-1, workbook.getNameIndex(\"ForB3!!\"));\n-    \t\n-        \n-        // Now, an existing file with named ranges\n-\t\tFile xml = new File(\n-\t\t\t\tSystem.getProperty(\"HSSF.testdata.path\") +\n-\t\t\t\tFile.separator + \"WithVariousData.xlsx\"\n-\t\t);\n-\t\tassertTrue(xml.exists());\n-    \t\n-\t\tworkbook = new XSSFWorkbook(xml.toString());\n-\t\t\n-        assertEquals(2, workbook.getNumberOfNames());\n-        assertEquals(\"Sheet1!$A$2:$A$7\", workbook.getNameAt(0).getReference());\n-        assertEquals(\"AllANumbers\", workbook.getNameAt(0).getNameName());\n-        assertEquals(\"All the numbers in A\", workbook.getNameAt(0).getComment());\n-        \n-        assertEquals(\"Sheet1!$B$2:$B$7\", workbook.getNameAt(1).getReference());\n-        assertEquals(\"AllBStrings\", workbook.getNameAt(1).getNameName());\n-        assertEquals(\"All the strings in B\", workbook.getNameAt(1).getComment());\n-        \n-        // Tweak, save, and re-check\n-        workbook.getNameAt(1).setNameName(\"BStringsFun\");\n-        \n-        baos = new ByteArrayOutputStream();\n-        workbook.write(baos);\n-        bais = new ByteArrayInputStream(baos.toByteArray());\n-        workbook = new XSSFWorkbook(Package.open(bais));\n-\t\t\n-        assertEquals(2, workbook.getNumberOfNames());\n-        assertEquals(\"Sheet1!$A$2:$A$7\", workbook.getNameAt(0).getReference());\n-        assertEquals(\"AllANumbers\", workbook.getNameAt(0).getNameName());\n-        assertEquals(\"All the numbers in A\", workbook.getNameAt(0).getComment());\n-        \n-        assertEquals(\"Sheet1!$B$2:$B$7\", workbook.getNameAt(1).getReference());\n-        assertEquals(\"BStringsFun\", workbook.getNameAt(1).getNameName());\n-        assertEquals(\"All the strings in B\", workbook.getNameAt(1).getComment());\n-    }\n+\t}\n+\t\n+\tpublic void testNamedRanges() {\n+\t\t// First up, a new file\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\tassertEquals(0, workbook.getNumberOfNames());\n+\t\t\n+\t\tName nameA = workbook.createName();\n+\t\tnameA.setReference(\"A2\");\n+\t\tnameA.setNameName(\"ForA2\");\n+\t\t\n+\t\tXSSFName nameB = workbook.createName();\n+\t\tnameB.setReference(\"B3\");\n+\t\tnameB.setNameName(\"ForB3\");\n+\t\tnameB.setComment(\"B3 Comment\");\n+\t\t\n+\t\t// Save and re-load\n+\t\tworkbook = XSSFTestDataSamples.writeOutAndReadBack(workbook);\n+\t\t\n+\t\tassertEquals(2, workbook.getNumberOfNames());\n+\t\tassertEquals(\"A2\", workbook.getNameAt(0).getReference());\n+\t\tassertEquals(\"ForA2\", workbook.getNameAt(0).getNameName());\n+\t\tassertNull(workbook.getNameAt(0).getComment());\n+\t\t\n+\t\tassertEquals(\"B3\", workbook.getNameAt(1).getReference());\n+\t\tassertEquals(\"ForB3\", workbook.getNameAt(1).getNameName());\n+\t\tassertEquals(\"B3 Comment\", workbook.getNameAt(1).getComment());\n+\t\t\n+\t\tassertEquals(\"ForA2\", workbook.getNameName(0));\n+\t\tassertEquals(1, workbook.getNameIndex(\"ForB3\"));\n+\t\tassertEquals(-1, workbook.getNameIndex(\"ForB3!!\"));\n+\t\t\n+\t\t\n+\t\t// Now, an existing file with named ranges\n+\t\tworkbook = XSSFTestDataSamples.openSampleWorkbook(\"WithVariousData.xlsx\");\n+\t\t\n+\t\tassertEquals(2, workbook.getNumberOfNames());\n+\t\tassertEquals(\"Sheet1!$A$2:$A$7\", workbook.getNameAt(0).getReference());\n+\t\tassertEquals(\"AllANumbers\", workbook.getNameAt(0).getNameName());\n+\t\tassertEquals(\"All the numbers in A\", workbook.getNameAt(0).getComment());\n+\t\t\n+\t\tassertEquals(\"Sheet1!$B$2:$B$7\", workbook.getNameAt(1).getReference());\n+\t\tassertEquals(\"AllBStrings\", workbook.getNameAt(1).getNameName());\n+\t\tassertEquals(\"All the strings in B\", workbook.getNameAt(1).getComment());\n+\t\t\n+\t\t// Tweak, save, and re-check\n+\t\tworkbook.getNameAt(1).setNameName(\"BStringsFun\");\n+\t\t\n+\t\tworkbook = XSSFTestDataSamples.writeOutAndReadBack(workbook);\n+\t\t\n+\t\tassertEquals(2, workbook.getNumberOfNames());\n+\t\tassertEquals(\"Sheet1!$A$2:$A$7\", workbook.getNameAt(0).getReference());\n+\t\tassertEquals(\"AllANumbers\", workbook.getNameAt(0).getNameName());\n+\t\tassertEquals(\"All the numbers in A\", workbook.getNameAt(0).getComment());\n+\t\t\n+\t\tassertEquals(\"Sheet1!$B$2:$B$7\", workbook.getNameAt(1).getReference());\n+\t\tassertEquals(\"BStringsFun\", workbook.getNameAt(1).getNameName());\n+\t\tassertEquals(\"All the strings in B\", workbook.getNameAt(1).getComment());\n+\t}\n+\t\n+\tpublic void testDuplicateNames() {\n+\n+\t\tXSSFWorkbook wb = new XSSFWorkbook();\n+\t\twb.createSheet(\"Sheet1\");\n+\t\twb.createSheet();\n+\t\twb.createSheet(\"name1\");\n+\t\ttry {\n+\t\twb.createSheet(\"name1\");\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tassertEquals(\"The workbook already contains a sheet of this name\", e.getMessage());\n+\t\t}\n+\n+\t\twb.createSheet();\n+\n+\t\ttry {\n+\t\t\twb.setSheetName(3, \"name1\");\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tassertEquals(\"The workbook already contains a sheet of this name\", e.getMessage());\n+\t\t}\n+\n+\t\ttry {\n+\t\t\twb.setSheetName(3, \"Sheet1\");\n+\t\t\tfail();\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tassertEquals(\"The workbook already contains a sheet of this name\", e.getMessage());\n+\t\t}\n+\n+\t\twb.setSheetName(3, \"name2\");\n+\t\twb.setSheetName(3, \"Sheet3\");\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/93e1ccd36b21d32234bc04198a2592cb48187919/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "sha": "38769743c1dccab25554f1f545ba3572b23aaf0e",
                "status": "modified"
            }
        ],
        "message": "Applied patch 45898 - fixed XSSFCellFill getFillBackgroundColor  and getFillForegroundColor to not throw NPE if fill has not been set.  Some other code clean up.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/ooxml@699984 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/0bb6110bd1ba80610457794657da37b36dfcdcc1",
        "patched_files": [
            "IndexedColors.java",
            "XSSFWorkbook.java",
            "XSSFCellFill.java",
            "XSSFCellStyle.java",
            "StylesTable.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestStylesTable.java",
            "TestXSSFCellFill.java",
            "TestIndexedColors.java",
            "TestXSSFWorkbook.java",
            "TestXSSFCellStyle.java"
        ]
    },
    "poi_9484ef6": {
        "bug_id": "poi_9484ef6",
        "commit": "https://github.com/apache/poi/commit/9484ef6f17137eca19415628e4151718f88a84c2",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/9484ef6f17137eca19415628e4151718f88a84c2/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java?ref=9484ef6f17137eca19415628e4151718f88a84c2",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "patch": "@@ -41,11 +41,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import javax.xml.validation.Validator;\n \n import org.apache.poi.openxml4j.exceptions.InvalidFormatException;\n-import org.apache.poi.xssf.usermodel.XSSFTable;\n import org.apache.poi.xssf.usermodel.XSSFCell;\n import org.apache.poi.xssf.usermodel.XSSFMap;\n import org.apache.poi.xssf.usermodel.XSSFRow;\n import org.apache.poi.xssf.usermodel.XSSFSheet;\n+import org.apache.poi.xssf.usermodel.XSSFTable;\n import org.apache.poi.xssf.usermodel.helpers.XSSFSingleXmlCell;\n import org.apache.poi.xssf.usermodel.helpers.XSSFXmlColumnPr;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.STXmlDataType;\n@@ -476,7 +476,7 @@ private Node getComplexTypeForElement(String elementName,Node xmlSchema,Node loc\n         if (!\"\".equals(complexTypeName)) {\n             NodeList  complexTypeList  = xmlSchema.getChildNodes();\n             for(int i=0; i< complexTypeList.getLength();i++) {\n-                Node node = list.item(i);\n+                Node node = complexTypeList.item(i);\n                 if ( node instanceof Element) {\n                     if (node.getLocalName().equals(\"complexType\")) {\n                         Node nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n@@ -504,4 +504,4 @@ private Node getComplexTypeForElement(String elementName,Node xmlSchema,Node loc\n         }\n         return complexTypeNode;\n     }\n-}\n+}\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/9484ef6f17137eca19415628e4151718f88a84c2/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "sha": "a6e1a2785acdacdd8457be91dabb1d58fc6b5826",
                "status": "modified"
            },
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/poi/blob/9484ef6f17137eca19415628e4151718f88a84c2/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java",
                "changes": 38,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java?ref=9484ef6f17137eca19415628e4151718f88a84c2",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java",
                "patch": "@@ -176,4 +176,42 @@ public void testMultiTable() throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+    public void test55850ComplexXmlExport() throws Exception {\n+\n+        XSSFWorkbook wb = XSSFTestDataSamples\n+                .openSampleWorkbook(\"55850.xlsx\");\n+\n+        for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+            if (!(p instanceof MapInfo)) {\n+                continue;\n+            }\n+            MapInfo mapInfo = (MapInfo) p;\n+\n+            XSSFMap map = mapInfo.getXSSFMapById(2);\n+\n+            assertNotNull(\"XSSFMap is null\", map);\n+\n+            XSSFExportToXml exporter = new XSSFExportToXml(map);\n+            ByteArrayOutputStream os = new ByteArrayOutputStream();\n+            exporter.exportToXML(os, true);\n+            String xmlData = os.toString(\"UTF-8\");\n+\n+            assertNotNull(xmlData);\n+            assertTrue(!xmlData.equals(\"\"));\n+\n+            String a = xmlData.split(\"<A>\")[1].split(\"</A>\")[0].trim();\n+            String b = a.split(\"<B>\")[1].split(\"</B>\")[0].trim();\n+            String c = b.split(\"<C>\")[1].split(\"</C>\")[0].trim();\n+            String d = c.split(\"<D>\")[1].split(\"</Dd>\")[0].trim();\n+            String e = d.split(\"<E>\")[1].split(\"</EA>\")[0].trim();\n+\n+            String euro = e.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+            String chf = e.split(\"<CHF>\")[1].split(\"</CHF>\")[0].trim();\n+\n+            assertEquals(\"15\", euro);\n+            assertEquals(\"19\", chf);\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/9484ef6f17137eca19415628e4151718f88a84c2/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java",
                "sha": "cb70b358f8e8e0478bffe1ee9b11112f57c4c4f0",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/9484ef6f17137eca19415628e4151718f88a84c2/test-data/spreadsheet/55850.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/55850.xlsx?ref=9484ef6f17137eca19415628e4151718f88a84c2",
                "deletions": 0,
                "filename": "test-data/spreadsheet/55850.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/9484ef6f17137eca19415628e4151718f88a84c2/test-data/spreadsheet/55850.xlsx",
                "sha": "ea8dc0e39996dbcfad6f50e3368cf2adb3a35871",
                "status": "added"
            }
        ],
        "message": "Bug 55850: fix NullPointerException during extraction from XSSF\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1549007 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/8e89928c883077b5720f83e937e53bb2f9af0c52",
        "patched_files": [
            "55850.java",
            "XSSFExportToXml.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFExportToXML.java"
        ]
    },
    "poi_9eff4e1": {
        "bug_id": "poi_9eff4e1",
        "commit": "https://github.com/apache/poi/commit/9eff4e10b36d171ed5a33771066b779604897aff",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/documentation/content/xdocs/changes.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -37,6 +37,8 @@\n \n \t\t<!-- Don't forget to update status.xml too! -->\n         <release version=\"3.5-beta6\" date=\"2009-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">47028 - Fixed XSSFCell to preserve cell style when cell value is set to blank</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">47026 - Avoid NPE in XSSFCell.setCellType() when workbook does not have SST</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">46987 - Allow RecordFactory to handle non-zero padding at the end of the workbook stream</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47034 - Fix reading the name of a NameRecord when the name is very long</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47001 - Fixed WriteAccessRecord and LinkTable to handle unusual format written by Google Docs</action>",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/documentation/content/xdocs/changes.xml",
                "sha": "f58747e7edd00256ccc44b27aa499d600352d5c8",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/documentation/content/xdocs/status.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,8 @@\n \t<!-- Don't forget to update changes.xml too! -->\n     <changes>\n         <release version=\"3.5-beta6\" date=\"2009-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">47028 - Fixed XSSFCell to preserve cell style when cell value is set to blank</action>\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">47026 - Avoid NPE in XSSFCell.setCellType() when workbook does not have SST</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">46987 - Allow RecordFactory to handle non-zero padding at the end of the workbook stream</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47034 - Fix reading the name of a NameRecord when the name is very long</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">47001 - Fixed WriteAccessRecord and LinkTable to handle unusual format written by Google Docs</action>",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/documentation/content/xdocs/status.xml",
                "sha": "4ef245ad87680cfb218d3b88c5a8c4a15bbd74f5",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java",
                "patch": "@@ -627,6 +627,7 @@ public void setAsActiveCell() {\n     private void setBlank(){\n         CTCell blank = CTCell.Factory.newInstance();\n         blank.setR(cell.getR());\n+        blank.setS(cell.getS());\n         cell.set(blank);\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFCell.java",
                "sha": "2a0e1ff4b27a25d562a2da47ed3046bc313c4066",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 5,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java",
                "patch": "@@ -179,6 +179,11 @@ else if (p instanceof XSSFSheet) {\n                 }\n             }\n \n+            if(sharedStringSource == null) {\n+                //Create SST if it is missing\n+                sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, XSSFFactory.getInstance());\n+            }\n+\n             // Load individual sheets. The order of sheets is defined by the order of CTSheet elements in the workbook\n             sheets = new ArrayList<XSSFSheet>(shIdMap.size());\n             for (CTSheet ctSheet : this.workbook.getSheets().getSheetArray()) {\n@@ -192,11 +197,6 @@ else if (p instanceof XSSFSheet) {\n                 sheets.add(sh);\n             }\n \n-            if(sharedStringSource == null) {\n-                //Create SST if it is missing\n-                sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, XSSFFactory.getInstance());\n-            }\n-\n             // Process the named ranges\n             namedRanges = new ArrayList<XSSFName>();\n             if(workbook.isSetDefinedNames()) {",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java",
                "sha": "1648ac86f35e79c69e0d25c187753bc578c7efea",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCell.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCell.java?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 1,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCell.java",
                "patch": "@@ -17,7 +17,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xssf.usermodel;\n \n-import org.apache.poi.ss.usermodel.BaseTestCell;\n+import org.apache.poi.ss.usermodel.*;\n import org.apache.poi.xssf.XSSFITestDataProvider;\n \n /**\n@@ -28,4 +28,26 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tpublic TestXSSFCell() {\n \t\tsuper(XSSFITestDataProvider.getInstance());\n \t}\n+\n+    /**\n+     * Bug 47026: trouble changing cell type when workbook doesn't contain\n+     * Shared String Table\n+     */\n+    public void test47026_1() throws Exception {\n+        Workbook source = _testDataProvider.openSampleWorkbook(\"47026.xlsm\");\n+        Sheet sheet = source.getSheetAt(0);\n+        Row row = sheet.getRow(0);\n+        Cell cell = row.getCell(0);\n+        cell.setCellType(Cell.CELL_TYPE_STRING);\n+        cell.setCellValue(\"456\");\n+    }\n+\n+    public void test47026_2() throws Exception {\n+        Workbook source = _testDataProvider.openSampleWorkbook(\"47026.xlsm\");\n+        Sheet sheet = source.getSheetAt(0);\n+        Row row = sheet.getRow(0);\n+        Cell cell = row.getCell(0);\n+        cell.setCellFormula(null);\n+        cell.setCellValue(\"456\");\n+    }\n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFCell.java",
                "sha": "f97a6d1b8155f46b7905f105faacce051334048b",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/testcases/org/apache/poi/hssf/data/47026.xlsm",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/47026.xlsm?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/47026.xlsm",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/testcases/org/apache/poi/hssf/data/47026.xlsm",
                "sha": "77e4eb97f31cb0fb89fff05029eeeab14aacf0f2",
                "status": "added"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/poi/blob/9eff4e10b36d171ed5a33771066b779604897aff/src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java?ref=9eff4e10b36d171ed5a33771066b779604897aff",
                "deletions": 3,
                "filename": "src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java",
                "patch": "@@ -22,7 +22,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n \n-import org.apache.poi.hssf.usermodel.HSSFRichTextString;\n import org.apache.poi.ss.ITestDataProvider;\n \n /**\n@@ -31,7 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public abstract class BaseTestCell extends TestCase {\n \n-\tprivate final ITestDataProvider _testDataProvider;\n+\tprotected final ITestDataProvider _testDataProvider;\n \n \t/**\n \t * @param testDataProvider an object that provides test data in HSSF / XSSF specific way\n@@ -401,9 +400,23 @@ public final void testSetStringInFormulaCell_bug44606() {\n \t\tCell cell = wb.createSheet(\"Sheet1\").createRow(0).createCell(0);\n \t\tcell.setCellFormula(\"B1&C1\");\n \t\ttry {\n-\t\t\tcell.setCellValue(new HSSFRichTextString(\"hello\"));\n+\t\t\tcell.setCellValue(wb.getCreationHelper().createRichTextString(\"hello\"));\n \t\t} catch (ClassCastException e) {\n \t\t\tthrow new AssertionFailedError(\"Identified bug 44606\");\n \t\t}\n \t}\n+\n+    /**\n+     *  Make sure that cell.setCellType(Cell.CELL_TYPE_BLANK) preserves the cell style\n+     */\n+    public void testSetBlank_bug47028() {\n+        Workbook wb = _testDataProvider.createWorkbook();\n+        CellStyle style = wb.createCellStyle();\n+        Cell cell = wb.createSheet(\"Sheet1\").createRow(0).createCell(0);\n+        cell.setCellStyle(style);\n+        int i1 = cell.getCellStyle().getIndex();\n+        cell.setCellType(Cell.CELL_TYPE_BLANK);\n+        int i2 = cell.getCellStyle().getIndex();\n+        assertEquals(i1, i2);\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/9eff4e10b36d171ed5a33771066b779604897aff/src/testcases/org/apache/poi/ss/usermodel/BaseTestCell.java",
                "sha": "1a987c1ac81004b57106d911eaadd50de4b4f7a3",
                "status": "modified"
            }
        ],
        "message": "Fixed XSSFCell to preserve cell style when cell value is set to blank, also avoid NPE in XSSFCell.setCellType() when workbook does not have SST, see bugs 47026 and 47028\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@766103 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/2ab0a58566226570ecbf55b7700cfb31d1e60a74",
        "patched_files": [
            "47026.java",
            "status.java",
            "BaseTestCell.java",
            "changes.java",
            "XSSFWorkbook.java",
            "XSSFCell.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFWorkbook.java",
            "TestXSSFCell.java"
        ]
    },
    "poi_a1b9cb2": {
        "bug_id": "poi_a1b9cb2",
        "commit": "https://github.com/apache/poi/commit/a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java?ref=a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java",
                "patch": "@@ -778,6 +778,9 @@ public XSSFComment getCellComment(CellAddress address) {\n      */\n     @Override\n     public Map<CellAddress, XSSFComment> getCellComments() {\n+        if (sheetComments == null) {\n+            return Collections.emptyMap();\n+        }\n         return sheetComments.getCellComments();\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java",
                "sha": "f0103719c1ca05f308708d3d313866540a7aec77",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3/src/testcases/org/apache/poi/ss/usermodel/BaseTestSheet.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/usermodel/BaseTestSheet.java?ref=a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/ss/usermodel/BaseTestSheet.java",
                "patch": "@@ -27,6 +27,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import static org.junit.Assume.assumeTrue;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Map.Entry;\n@@ -1119,6 +1120,10 @@ public void getCellComment() throws IOException {\n     public void getCellComments() throws IOException {\n         Workbook workbook = _testDataProvider.createWorkbook();\n         Sheet sheet = workbook.createSheet(\"TEST\");\n+\n+        // a sheet with no cell comments should return an empty map (not null or raise NPE).\n+        assertEquals(Collections.emptyMap(), sheet.getCellComments());\n+\n         Drawing dg = sheet.createDrawingPatriarch();\n         ClientAnchor anchor = workbook.getCreationHelper().createClientAnchor();\n         ",
                "raw_url": "https://github.com/apache/poi/raw/a1b9cb221e08dfc5b47cf5f4a105dea409e2e1b3/src/testcases/org/apache/poi/ss/usermodel/BaseTestSheet.java",
                "sha": "830298181c8fb821d66611b4515742b2ea78fc31",
                "status": "modified"
            }
        ],
        "message": "bug 59222: fix NPE thrown by (S)XSSFSheet.getCellComments(). Reported by Vasily Kopytov.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1736347 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/0d543621eaecf9fc8a0fd004e1f3af41ec045867",
        "patched_files": [
            "XSSFSheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFSheet.java"
        ]
    },
    "poi_a3e0872": {
        "bug_id": "poi_a3e0872",
        "commit": "https://github.com/apache/poi/commit/a3e087268a6ff9d5b90d3d334593d56693e400b8",
        "file": [
            {
                "additions": 47,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java",
                "changes": 47,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 0,
                "filename": "src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java",
                "patch": "@@ -16,15 +16,23 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\r\n package org.apache.poi.stress;\r\n \r\n+import static org.junit.Assert.assertEquals;\r\n import static org.junit.Assert.assertFalse;\r\n import static org.junit.Assert.assertNotNull;\r\n \r\n import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n import java.util.HashSet;\r\n import java.util.Set;\r\n \r\n import org.apache.poi.POITextExtractor;\r\n import org.apache.poi.extractor.ExtractorFactory;\r\n+import org.apache.poi.openxml4j.exceptions.InvalidFormatException;\r\n+import org.apache.poi.openxml4j.exceptions.OpenXML4JException;\r\n+import org.apache.xmlbeans.XmlException;\r\n \r\n public abstract class AbstractFileHandler implements FileHandler {\r\n     public static final Set<String> EXPECTED_EXTRACTOR_FAILURES = new HashSet<String>();\r\n@@ -48,6 +56,22 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     }\r\n \r\n     public void handleExtracting(File file) throws Exception {\r\n+        boolean before = ExtractorFactory.getThreadPrefersEventExtractors();\r\n+        try {\r\n+            ExtractorFactory.setThreadPrefersEventExtractors(true);\r\n+            handleExtractingInternal(file);\r\n+\r\n+            ExtractorFactory.setThreadPrefersEventExtractors(false);\r\n+            handleExtractingInternal(file);\r\n+        } finally {\r\n+            ExtractorFactory.setThreadPrefersEventExtractors(before);\r\n+        }\r\n+    }\r\n+\r\n+    private void handleExtractingInternal(File file) throws Exception {\r\n+        long length = file.length();\r\n+        long modified = file.lastModified();\r\n+        \r\n         POITextExtractor extractor = ExtractorFactory.createExtractor(file);\r\n         try  {\r\n             assertNotNull(extractor);\r\n@@ -60,6 +84,11 @@ public void handleExtracting(File file) throws Exception {\n \r\n             assertFalse(\"Expected Extraction to fail for file \" + file + \" and handler \" + this + \", but did not fail!\", \r\n                     EXPECTED_EXTRACTOR_FAILURES.contains(file));\r\n+            \r\n+            assertEquals(\"File should not be modified by extractor\", length, file.length());\r\n+            assertEquals(\"File should not be modified by extractor\", modified, file.lastModified());\r\n+            \r\n+            handleExtractingAsStream(file);\r\n         } catch (IllegalArgumentException e) {\r\n             if(!EXPECTED_EXTRACTOR_FAILURES.contains(file)) {\r\n                 throw new Exception(\"While handling \" + file, e);\r\n@@ -68,4 +97,22 @@ public void handleExtracting(File file) throws Exception {\n             extractor.close();\r\n         }\r\n     }\r\n+\r\n+    private void handleExtractingAsStream(File file) throws FileNotFoundException,\r\n+            IOException, InvalidFormatException, OpenXML4JException,\r\n+            XmlException {\r\n+        InputStream stream = new FileInputStream(file);\r\n+        try {\r\n+            POITextExtractor streamExtractor = ExtractorFactory.createExtractor(stream);\r\n+            try {\r\n+                assertNotNull(streamExtractor);\r\n+   \r\n+                assertNotNull(streamExtractor.getText());\r\n+            } finally {\r\n+                streamExtractor.close();\r\n+            }\r\n+        } finally {\r\n+            stream.close();\r\n+        }\r\n+    }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/integrationtest/org/apache/poi/stress/AbstractFileHandler.java",
                "sha": "8a27e6d0e9c2c39da95b992d0c51f4620eb790e8",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 0,
                "filename": "src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java",
                "patch": "@@ -18,6 +18,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import static org.junit.Assert.assertNotNull;\n \n+import java.io.File;\n import java.io.FileInputStream;\n import java.io.InputStream;\n \n@@ -43,4 +44,10 @@ public void test() throws Exception {\n \t\t\tstream.close();\n \t\t}\n \t}\n+\n+    // a test-case to test this locally without executing the full TestAllFiles\n+    @Test\n+    public void testExtractor() throws Exception {\n+        handleExtracting(new File(\"test-data/hpsf/TestBug44375.xls\"));\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/integrationtest/org/apache/poi/stress/HPSFFileHandler.java",
                "sha": "6a53b2e00995fea2a9493820e08bbdeeb8be6bf7",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/integrationtest/org/apache/poi/stress/XSSFFileHandler.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/XSSFFileHandler.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 0,
                "filename": "src/integrationtest/org/apache/poi/stress/XSSFFileHandler.java",
                "patch": "@@ -17,6 +17,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n package org.apache.poi.stress;\n \n import java.io.ByteArrayOutputStream;\n+import java.io.File;\n import java.io.FileInputStream;\n import java.io.InputStream;\n \n@@ -71,4 +72,10 @@ public void test() throws Exception {\n \t\t\tstream.close();\n \t\t}\n \t}\n+\n+    // a test-case to test this locally without executing the full TestAllFiles\n+    @Test\n+    public void testExtractor() throws Exception {\n+        handleExtracting(new File(\"test-data/spreadsheet/56278.xlsx\"));\n+    }\n }\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/integrationtest/org/apache/poi/stress/XSSFFileHandler.java",
                "sha": "a268ed46582b2e35e79fa78bb5adb5ebb70e2eee",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java",
                "patch": "@@ -57,6 +57,10 @@ public HPSFPropertiesExtractor(NPOIFSFileSystem fs) {\n     }\n \n     public String getDocumentSummaryInformationText() {\n+        if(document == null) {  // event based extractor does not have a document\n+            return \"\";\n+        }\n+\n         DocumentSummaryInformation dsi = document.getDocumentSummaryInformation();\n         StringBuffer text = new StringBuffer();\n \n@@ -78,6 +82,10 @@ public String getDocumentSummaryInformationText() {\n         return text.toString();\n     }\n     public String getSummaryInformationText() {\n+        if(document == null) {  // event based extractor does not have a document\n+            return \"\";\n+        }\n+\n         SummaryInformation si = document.getSummaryInformation();\n \n         // Just normal properties",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java",
                "sha": "1a0db038972d9bb280dbcef7558f6c43b62fb9f2",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/java/org/apache/poi/hssf/eventusermodel/HSSFEventFactory.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/eventusermodel/HSSFEventFactory.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 5,
                "filename": "src/java/org/apache/poi/hssf/eventusermodel/HSSFEventFactory.java",
                "patch": "@@ -19,6 +19,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import java.io.InputStream;\n import java.io.IOException;\n+import java.util.Set;\n \n import org.apache.poi.hssf.eventusermodel.HSSFUserException;\n import org.apache.poi.hssf.record.*;\n@@ -56,11 +57,24 @@ public void processWorkbookEvents(HSSFRequest req, POIFSFileSystem fs) throws IO\n     * @param req an Instance of HSSFRequest which has your registered listeners\n     * @param dir  a DirectoryNode containing your workbook\n     */\n-   public void processWorkbookEvents(HSSFRequest req, DirectoryNode dir) throws IOException {\n-      InputStream in = dir.createDocumentInputStream(\"Workbook\");\n-\n-      processEvents(req, in);\n-   }\n+    public void processWorkbookEvents(HSSFRequest req, DirectoryNode dir) throws IOException {\n+        // some old documents have \"WORKBOOK\" or \"BOOK\"\n+        final String name;\n+        Set<String> entryNames = dir.getEntryNames();\n+        if (entryNames.contains(\"Workbook\")) {\n+            name = \"Workbook\";\n+        } else if (entryNames.contains(\"WORKBOOK\")) {\n+            name = \"WORKBOOK\";\n+        } else if (entryNames.contains(\"BOOK\")) {\n+            name = \"BOOK\";\n+        } else {\n+            name = \"Workbook\";\n+        }\n+\n+        InputStream in = dir.createDocumentInputStream(name);\n+\n+        processEvents(req, in);\n+    }\n \n    /**\n     * Processes a file into essentially record events.",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/java/org/apache/poi/hssf/eventusermodel/HSSFEventFactory.java",
                "sha": "4d0b894e01577e42c43002001b0a3ce33216cefa",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 4,
                "filename": "src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java",
                "patch": "@@ -67,9 +67,14 @@ private void appendIfPresent(StringBuffer text, String thing, String value) {\n \t * Returns the core document properties, eg author\n \t */\n \tpublic String getCorePropertiesText() {\n+\t    POIXMLDocument document = getDocument();\n+        if(document == null) {  // event based extractor does not have a document\n+            return \"\";\n+        }\n+\n \t\tStringBuffer text = new StringBuffer();\n-\t\tPackagePropertiesPart props =\n-\t\t\tgetDocument().getProperties().getCoreProperties().getUnderlyingProperties();\n+        PackagePropertiesPart props =\n+\t\t\tdocument.getProperties().getCoreProperties().getUnderlyingProperties();\n \n \t\tappendIfPresent(text, \"Category\", props.getCategoryProperty().getValue());\n \t\tappendIfPresent(text, \"Category\", props.getCategoryProperty().getValue());\n@@ -99,9 +104,14 @@ public String getCorePropertiesText() {\n \t *  application\n \t */\n \tpublic String getExtendedPropertiesText() {\n+        POIXMLDocument document = getDocument();\n+        if(document == null) {  // event based extractor does not have a document\n+            return \"\";\n+        }\n+\n \t\tStringBuffer text = new StringBuffer();\n \t\torg.openxmlformats.schemas.officeDocument.x2006.extendedProperties.CTProperties\n-\t\t\tprops = getDocument().getProperties().getExtendedProperties().getUnderlyingProperties();\n+\t\t\tprops = document.getProperties().getExtendedProperties().getUnderlyingProperties();\n \n \t\tappendIfPresent(text, \"Application\", props.getApplication());\n \t\tappendIfPresent(text, \"AppVersion\", props.getAppVersion());\n@@ -127,9 +137,14 @@ public String getExtendedPropertiesText() {\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getCustomPropertiesText() {\n+       POIXMLDocument document = getDocument();\n+       if(document == null) {  // event based extractor does not have a document\n+           return \"\";\n+       }\n+\n       StringBuilder text = new StringBuilder();\n       org.openxmlformats.schemas.officeDocument.x2006.customProperties.CTProperties\n-      props = getDocument().getProperties().getCustomProperties().getUnderlyingProperties();\n+      props = document.getProperties().getCustomProperties().getUnderlyingProperties();\n \n        for(CTProperty property : props.getPropertyArray()) {\n          String val = \"(not implemented!)\";",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java",
                "sha": "8a35a34e4c2cc5ec909313ee614db4b2bcd2c396",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java",
                "patch": "@@ -265,10 +265,10 @@ public static POITextExtractor createExtractor(DirectoryNode poifsDir) throws IO\n \n \t/**\n \t * Returns an array of text extractors, one for each of\n-\t *  the embeded documents in the file (if there are any).\n-\t * If there are no embeded documents, you'll get back an\n+\t *  the embedded documents in the file (if there are any).\n+\t * If there are no embedded documents, you'll get back an\n \t *  empty array. Otherwise, you'll get one open\n-\t *  {@link POITextExtractor} for each embeded file.\n+\t *  {@link POITextExtractor} for each embedded file.\n \t */\n \tpublic static POITextExtractor[] getEmbededDocsTextExtractors(POIOLE2TextExtractor ext) throws IOException, InvalidFormatException, OpenXML4JException, XmlException {\n \t   // All the embded directories we spotted",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/java/org/apache/poi/extractor/ExtractorFactory.java",
                "sha": "60a0f518109a7e52a8410f1d026e7e8d963287d4",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFSheetXMLHandler.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFSheetXMLHandler.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFSheetXMLHandler.java",
                "patch": "@@ -96,6 +96,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    private String formatString;\n    private final DataFormatter formatter;\n    private int rowNum;\n+   private int nextRowNum;      // some sheets do not have rowNums, Excel can read them so we should try to handle them correctly as well\n    private String cellRef;\n    private boolean formulasNotResults;\n \n@@ -240,7 +241,12 @@ else if(\"oddHeader\".equals(name) || \"evenHeader\".equals(name) ||\n           headerFooter.setLength(0);\n        }\n        else if(\"row\".equals(name)) {\n-           rowNum = Integer.parseInt(attributes.getValue(\"r\")) - 1;\n+           String rowNumStr = attributes.getValue(\"r\");\n+           if(rowNumStr != null) {\n+               rowNum = Integer.parseInt(rowNumStr) - 1;\n+           } else {\n+               rowNum = nextRowNum;\n+           }\n            output.startRow(rowNum);\n        }\n        // c => cell\n@@ -343,7 +349,7 @@ public void endElement(String uri, String localName, String name)\n \n                case NUMBER:\n                    String n = value.toString();\n-                   if (this.formatString != null)\n+                   if (this.formatString != null && n.length() > 0)\n                        thisStr = formatter.formatRawCellContents(Double.parseDouble(n), this.formatIndex, this.formatString);\n                    else\n                        thisStr = n;\n@@ -370,6 +376,9 @@ public void endElement(String uri, String localName, String name)\n           \n           // Finish up the row\n           output.endRow(rowNum);\n+          \n+          // some sheets do not have rowNum set in the XML, Excel can read them so we should try to read them as well\n+          nextRowNum = rowNum + 1;\n        } else if (\"sheetData\".equals(name)) {\n            // Handle any \"missing\" cells which had comments attached\n            checkForEmptyCellComments(EmptyCellCommentsCheckType.END_OF_SHEET_DATA);",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/java/org/apache/poi/xssf/eventusermodel/XSSFSheetXMLHandler.java",
                "sha": "227441859eb577762e3c5b4c4bc97566d34d12f6",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFEventBasedExcelExtractor.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFEventBasedExcelExtractor.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 1,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFEventBasedExcelExtractor.java",
                "patch": "@@ -23,6 +23,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.TestCase;\n \n import org.apache.poi.POITextExtractor;\n+import org.apache.poi.POIXMLTextExtractor;\n import org.apache.poi.hssf.HSSFTestDataSamples;\n import org.apache.poi.hssf.extractor.ExcelExtractor;\n import org.apache.poi.xssf.XSSFTestDataSamples;\n@@ -155,7 +156,6 @@ public void testComparedToOLE2() throws Exception {\n \t\tPOITextExtractor[] extractors =\n \t\t\tnew POITextExtractor[] { ooxmlExtractor, ole2Extractor };\n \t\tfor (int i = 0; i < extractors.length; i++) {\n-\t\t\t@SuppressWarnings(\"resource\")\n             POITextExtractor extractor = extractors[i];\n \t\t\t\n \t\t\tString text = extractor.getText().replaceAll(\"[\\r\\t]\", \"\");\n@@ -316,4 +316,25 @@ public void testCommentsComparedToNonEventBasedExtractor()\n             fixture.close();\n         }\n     }\n+    \n+    public void testFile56278_normal() throws Exception {\n+        // first with normal Text Extractor\n+        POIXMLTextExtractor extractor = new XSSFExcelExtractor(\n+                XSSFTestDataSamples.openSampleWorkbook(\"56278.xlsx\"));\n+        try {\n+            assertNotNull(extractor.getText());\n+        } finally {\n+            extractor.close();\n+        }\n+    }\n+    \n+    public void testFile56278_event() throws Exception {\n+        // then with event based one\n+        POIXMLTextExtractor extractor = getExtractor(\"56278.xlsx\");        \n+        try {\n+            assertNotNull(extractor.getText());\n+        } finally {\n+            extractor.close();\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFEventBasedExcelExtractor.java",
                "sha": "b56b3791f010a0d3d49d4e82b3ed41459ff2c4d2",
                "status": "modified"
            },
            {
                "additions": 111,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/testcases/org/apache/poi/hpsf/extractor/TestHPSFPropertiesExtractor.java",
                "changes": 165,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hpsf/extractor/TestHPSFPropertiesExtractor.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 54,
                "filename": "src/testcases/org/apache/poi/hpsf/extractor/TestHPSFPropertiesExtractor.java",
                "patch": "@@ -22,10 +22,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.TestCase;\n \n import org.apache.poi.POIDataSamples;\n+import org.apache.poi.POITextExtractor;\n import org.apache.poi.hpsf.Thumbnail;\n import org.apache.poi.hssf.HSSFTestDataSamples;\n import org.apache.poi.hssf.extractor.ExcelExtractor;\n import org.apache.poi.hssf.usermodel.HSSFWorkbook;\n+import org.apache.poi.hwpf.extractor.Word6Extractor;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n \n public final class TestHPSFPropertiesExtractor extends TestCase {\n@@ -34,64 +36,75 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \tpublic void testNormalProperties() throws Exception {\n \t\tPOIFSFileSystem fs = new POIFSFileSystem(_samples.openResourceAsStream(\"TestMickey.doc\"));\n \t\tHPSFPropertiesExtractor ext = new HPSFPropertiesExtractor(fs);\n-\t\text.getText();\n-\n-\t\t// Check each bit in turn\n-\t\tString sinfText = ext.getSummaryInformationText();\n-\t\tString dinfText = ext.getDocumentSummaryInformationText();\n-\n-\t\tassertTrue(sinfText.indexOf(\"TEMPLATE = Normal\") > -1);\n-\t\tassertTrue(sinfText.indexOf(\"SUBJECT = sample subject\") > -1);\n-\t\tassertTrue(dinfText.indexOf(\"MANAGER = sample manager\") > -1);\n-\t\tassertTrue(dinfText.indexOf(\"COMPANY = sample company\") > -1);\n-\n-\t\t// Now overall\n-\t\tString text = ext.getText();\n-\t\tassertTrue(text.indexOf(\"TEMPLATE = Normal\") > -1);\n-\t\tassertTrue(text.indexOf(\"SUBJECT = sample subject\") > -1);\n-\t\tassertTrue(text.indexOf(\"MANAGER = sample manager\") > -1);\n-\t\tassertTrue(text.indexOf(\"COMPANY = sample company\") > -1);\n+\t\ttry {\n+    \t\text.getText();\n+    \n+    \t\t// Check each bit in turn\n+    \t\tString sinfText = ext.getSummaryInformationText();\n+    \t\tString dinfText = ext.getDocumentSummaryInformationText();\n+    \n+    \t\tassertTrue(sinfText.indexOf(\"TEMPLATE = Normal\") > -1);\n+    \t\tassertTrue(sinfText.indexOf(\"SUBJECT = sample subject\") > -1);\n+    \t\tassertTrue(dinfText.indexOf(\"MANAGER = sample manager\") > -1);\n+    \t\tassertTrue(dinfText.indexOf(\"COMPANY = sample company\") > -1);\n+    \n+    \t\t// Now overall\n+    \t\tString text = ext.getText();\n+    \t\tassertTrue(text.indexOf(\"TEMPLATE = Normal\") > -1);\n+    \t\tassertTrue(text.indexOf(\"SUBJECT = sample subject\") > -1);\n+    \t\tassertTrue(text.indexOf(\"MANAGER = sample manager\") > -1);\n+    \t\tassertTrue(text.indexOf(\"COMPANY = sample company\") > -1);\n+\t\t} finally {\n+\t\t    ext.close();\n+\t\t}\n \t}\n \n \tpublic void testNormalUnicodeProperties() throws Exception {\n \t\tPOIFSFileSystem fs = new POIFSFileSystem(_samples.openResourceAsStream(\"TestUnicode.xls\"));\n \t\tHPSFPropertiesExtractor ext = new HPSFPropertiesExtractor(fs);\n-\t\text.getText();\n-\n-\t\t// Check each bit in turn\n-\t\tString sinfText = ext.getSummaryInformationText();\n-\t\tString dinfText = ext.getDocumentSummaryInformationText();\n-\n-\t\tassertTrue(sinfText.indexOf(\"AUTHOR = marshall\") > -1);\n-\t\tassertTrue(sinfText.indexOf(\"TITLE = Titel: \\u00c4h\") > -1);\n-\t\tassertTrue(dinfText.indexOf(\"COMPANY = Schreiner\") > -1);\n-\t\tassertTrue(dinfText.indexOf(\"SCALE = false\") > -1);\n-\n-\t\t// Now overall\n-\t\tString text = ext.getText();\n-\t\tassertTrue(text.indexOf(\"AUTHOR = marshall\") > -1);\n-\t\tassertTrue(text.indexOf(\"TITLE = Titel: \\u00c4h\") > -1);\n-\t\tassertTrue(text.indexOf(\"COMPANY = Schreiner\") > -1);\n-\t\tassertTrue(text.indexOf(\"SCALE = false\") > -1);\n+\t\ttry {\n+    \t\text.getText();\n+    \n+    \t\t// Check each bit in turn\n+    \t\tString sinfText = ext.getSummaryInformationText();\n+    \t\tString dinfText = ext.getDocumentSummaryInformationText();\n+    \n+    \t\tassertTrue(sinfText.indexOf(\"AUTHOR = marshall\") > -1);\n+    \t\tassertTrue(sinfText.indexOf(\"TITLE = Titel: \\u00c4h\") > -1);\n+    \t\tassertTrue(dinfText.indexOf(\"COMPANY = Schreiner\") > -1);\n+    \t\tassertTrue(dinfText.indexOf(\"SCALE = false\") > -1);\n+    \n+    \t\t// Now overall\n+    \t\tString text = ext.getText();\n+    \t\tassertTrue(text.indexOf(\"AUTHOR = marshall\") > -1);\n+    \t\tassertTrue(text.indexOf(\"TITLE = Titel: \\u00c4h\") > -1);\n+    \t\tassertTrue(text.indexOf(\"COMPANY = Schreiner\") > -1);\n+    \t\tassertTrue(text.indexOf(\"SCALE = false\") > -1);\n+\t\t} finally {\n+\t\t    ext.close();\n+\t\t}\n \t}\n \n \tpublic void testCustomProperties() throws Exception {\n \t\tPOIFSFileSystem fs = new POIFSFileSystem(\n \t\t\t\t_samples.openResourceAsStream(\"TestMickey.doc\")\n \t\t);\n \t\tHPSFPropertiesExtractor ext = new HPSFPropertiesExtractor(fs);\n-\n-\t\t// Custom properties are part of the document info stream\n-\t\tString dinfText = ext.getDocumentSummaryInformationText();\n-\t\tassertTrue(dinfText.indexOf(\"Client = sample client\") > -1);\n-\t\tassertTrue(dinfText.indexOf(\"Division = sample division\") > -1);\n-\n-\t\tString text = ext.getText();\n-\t\tassertTrue(text.indexOf(\"Client = sample client\") > -1);\n-\t\tassertTrue(text.indexOf(\"Division = sample division\") > -1);\n+\t\ttry {\n+    \t\t// Custom properties are part of the document info stream\n+    \t\tString dinfText = ext.getDocumentSummaryInformationText();\n+    \t\tassertTrue(dinfText.indexOf(\"Client = sample client\") > -1);\n+    \t\tassertTrue(dinfText.indexOf(\"Division = sample division\") > -1);\n+    \n+    \t\tString text = ext.getText();\n+    \t\tassertTrue(text.indexOf(\"Client = sample client\") > -1);\n+    \t\tassertTrue(text.indexOf(\"Division = sample division\") > -1);\n+        } finally {\n+            ext.close();\n+        }\n \t}\n \n-\tpublic void testConstructors() {\n+\tpublic void testConstructors() throws IOException {\n \t\tPOIFSFileSystem fs;\n \t\tHSSFWorkbook wb;\n \t\ttry {\n@@ -102,9 +115,29 @@ public void testConstructors() {\n \t\t}\n \t\tExcelExtractor excelExt = new ExcelExtractor(wb);\n \n-\t\tString fsText = (new HPSFPropertiesExtractor(fs)).getText();\n-\t\tString hwText = (new HPSFPropertiesExtractor(wb)).getText();\n-\t\tString eeText = (new HPSFPropertiesExtractor(excelExt)).getText();\n+\t\tfinal String fsText;\n+\t\tHPSFPropertiesExtractor fsExt = new HPSFPropertiesExtractor(fs);\n+\t\ttry {\n+\t\t    fsText = fsExt.getText();\n+\t\t} finally {\n+\t\t    fsExt.close();\n+\t\t}\n+        \n+        final String hwText; \n+\t\tHPSFPropertiesExtractor hwExt = new HPSFPropertiesExtractor(wb);\n+\t\ttry {\n+\t\t    hwText = hwExt.getText();\n+\t\t} finally {\n+\t\t    hwExt.close();\n+\t\t}\n+\t\t\n+        final String eeText;\n+        HPSFPropertiesExtractor eeExt = new HPSFPropertiesExtractor(excelExt);\n+        try {\n+            eeText = eeExt.getText();\n+        } finally {\n+            eeExt.close();\n+        }\n \n \t\tassertEquals(fsText, hwText);\n \t\tassertEquals(fsText, eeText);\n@@ -113,13 +146,17 @@ public void testConstructors() {\n \t\tassertTrue(fsText.indexOf(\"TITLE = Titel: \\u00c4h\") > -1);\n \t}\n \n-\tpublic void test42726() {\n-\t\tHPSFPropertiesExtractor ex = new HPSFPropertiesExtractor(HSSFTestDataSamples.openSampleWorkbook(\"42726.xls\"));\n-\t\tString txt = ex.getText();\n-\t\tassertTrue(txt.indexOf(\"PID_AUTHOR\") != -1);\n-\t\tassertTrue(txt.indexOf(\"PID_EDITTIME\") != -1);\n-\t\tassertTrue(txt.indexOf(\"PID_REVNUMBER\") != -1);\n-\t\tassertTrue(txt.indexOf(\"PID_THUMBNAIL\") != -1);\n+\tpublic void test42726() throws IOException {\n+\t\tHPSFPropertiesExtractor ext = new HPSFPropertiesExtractor(HSSFTestDataSamples.openSampleWorkbook(\"42726.xls\"));\n+\t\ttry {\n+    \t\tString txt = ext.getText();\n+    \t\tassertTrue(txt.indexOf(\"PID_AUTHOR\") != -1);\n+    \t\tassertTrue(txt.indexOf(\"PID_EDITTIME\") != -1);\n+    \t\tassertTrue(txt.indexOf(\"PID_REVNUMBER\") != -1);\n+    \t\tassertTrue(txt.indexOf(\"PID_THUMBNAIL\") != -1);\n+        } finally {\n+            ext.close();\n+        }\n \t}\n \t\n     public void testThumbnail() throws Exception {\n@@ -131,4 +168,24 @@ public void testThumbnail() throws Exception {\n         assertNotNull(thumbnail.getThumbnailAsWMF());\n         wb.close();\n     }\n+\n+    public void testExtractorFromWord6Extractor() throws Exception {\n+        POIFSFileSystem fs = new POIFSFileSystem(_samples.openResourceAsStream(\"TestMickey.doc\"));\n+        Word6Extractor wExt = new Word6Extractor(fs);\n+        try {\n+            POITextExtractor ext = wExt.getMetadataTextExtractor();\n+            try {\n+                // Now overall\n+                String text = ext.getText();\n+                assertTrue(text.indexOf(\"TEMPLATE = Normal\") > -1);\n+                assertTrue(text.indexOf(\"SUBJECT = sample subject\") > -1);\n+                assertTrue(text.indexOf(\"MANAGER = sample manager\") > -1);\n+                assertTrue(text.indexOf(\"COMPANY = sample company\") > -1);\n+            } finally {\n+                ext.close();\n+            }\n+        } finally {\n+            wExt.close();\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/testcases/org/apache/poi/hpsf/extractor/TestHPSFPropertiesExtractor.java",
                "sha": "c6ad03db2d9daa0800d39f6ee8b4738183e582c4",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/testcases/org/apache/poi/hssf/eventusermodel/TestHSSFEventFactory.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/eventusermodel/TestHSSFEventFactory.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 2,
                "filename": "src/testcases/org/apache/poi/hssf/eventusermodel/TestHSSFEventFactory.java",
                "patch": "@@ -107,8 +107,6 @@ public void testUnknownContinueRecords() throws Exception {\n \t\tPOIFSFileSystem fs = new POIFSFileSystem(openSample(\"42844.xls\"));\n \t\tHSSFEventFactory factory = new HSSFEventFactory();\n \t\tfactory.processWorkbookEvents(req, fs);\n-\n-\t\tassertTrue(\"no errors while processing the file\", true);\n \t}\n \n \tprivate static class MockHSSFListener implements HSSFListener {\n@@ -125,4 +123,18 @@ public void processRecord(Record record) {\n \t\t\trecords.add(record);\n \t\t}\n \t}\n+\n+\tpublic void testWithDifferentWorkbookName() throws Exception {\n+        HSSFRequest req = new HSSFRequest();\n+        MockHSSFListener mockListen = new MockHSSFListener();\n+        req.addListenerForAllRecords(mockListen);\n+\n+        POIFSFileSystem fs = new POIFSFileSystem(openSample(\"BOOK_in_capitals.xls\"));\n+        HSSFEventFactory factory = new HSSFEventFactory();\n+        factory.processWorkbookEvents(req, fs);\n+\n+        fs = new POIFSFileSystem(openSample(\"WORKBOOK_in_capitals.xls\"));\n+        factory = new HSSFEventFactory();\n+        factory.processWorkbookEvents(req, fs);\n+\t}\n }\t",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/testcases/org/apache/poi/hssf/eventusermodel/TestHSSFEventFactory.java",
                "sha": "ff76cfa19cb3c083564c8b317e4c03f560d7d359",
                "status": "modified"
            },
            {
                "additions": 87,
                "blob_url": "https://github.com/apache/poi/blob/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java",
                "changes": 151,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java?ref=a3e087268a6ff9d5b90d3d334593d56693e400b8",
                "deletions": 64,
                "filename": "src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java",
                "patch": "@@ -46,15 +46,18 @@ private static ExcelExtractor createExtractor(String sampleFileName) {\n \t}\n \n \n-\tpublic void testSimple() {\n-\n+\tpublic void testSimple() throws IOException {\n \t\tExcelExtractor extractor = createExtractor(\"Simple.xls\");\n \n-\t\tassertEquals(\"Sheet1\\nreplaceMe\\nSheet2\\nSheet3\\n\", extractor.getText());\n-\n-\t\t// Now turn off sheet names\n-\t\textractor.setIncludeSheetNames(false);\n-\t\tassertEquals(\"replaceMe\\n\", extractor.getText());\n+\t\ttry {\n+    \t\tassertEquals(\"Sheet1\\nreplaceMe\\nSheet2\\nSheet3\\n\", extractor.getText());\n+    \n+    \t\t// Now turn off sheet names\n+    \t\textractor.setIncludeSheetNames(false);\n+    \t\tassertEquals(\"replaceMe\\n\", extractor.getText());\n+\t\t} finally {\n+\t\t    extractor.close();\n+\t\t}\n \t}\n \n \tpublic void testNumericFormula() {\n@@ -126,45 +129,47 @@ public void testStringFormula() {\n \n \n \tpublic void testEventExtractor() throws Exception {\n-\t\tEventBasedExcelExtractor extractor;\n-\n \t\t// First up, a simple file with string\n \t\t//  based formulas in it\n-\t\textractor = new EventBasedExcelExtractor(\n+\t\tEventBasedExcelExtractor extractor = new EventBasedExcelExtractor(\n \t\t\t\tnew POIFSFileSystem(\n \t\t\t\t\t\tHSSFTestDataSamples.openSampleFileStream(\"SimpleWithFormula.xls\")\n \t\t\t\t)\n \t\t);\n-\t\textractor.setIncludeSheetNames(true);\n-\n-\t\tString text = extractor.getText();\n-\t\tassertEquals(\"Sheet1\\nreplaceme\\nreplaceme\\nreplacemereplaceme\\nSheet2\\nSheet3\\n\", text);\n-\n-\t\textractor.setIncludeSheetNames(false);\n-\t\textractor.setFormulasNotResults(true);\n-\n-\t\ttext = extractor.getText();\n-\t\tassertEquals(\"replaceme\\nreplaceme\\nCONCATENATE(A1,A2)\\n\", text);\n-\n-\n-\t\t// Now, a slightly longer file with numeric formulas\n-\t\textractor = new EventBasedExcelExtractor(\n-\t\t\t\tnew POIFSFileSystem(\n-\t\t\t\t\t\tHSSFTestDataSamples.openSampleFileStream(\"sumifformula.xls\")\n-\t\t\t\t)\n-\t\t);\n-\t\textractor.setIncludeSheetNames(false);\n-\t\textractor.setFormulasNotResults(true);\n-\n-\t\ttext = extractor.getText();\n-\t\tassertEquals(\n-\t\t\t\t\"1000\\t1\\tSUMIF(A1:A5,\\\">4000\\\",B1:B5)\\n\" +\n-\t\t\t\t\"2000\\t2\\n\" +\n-\t\t\t\t\"3000\\t3\\n\" +\n-\t\t\t\t\"4000\\t4\\n\" +\n-\t\t\t\t\"5000\\t5\\n\",\n-\t\t\t\ttext\n-\t\t);\n+\t\ttry {\n+    \t\textractor.setIncludeSheetNames(true);\n+    \n+    \t\tString text = extractor.getText();\n+    \t\tassertEquals(\"Sheet1\\nreplaceme\\nreplaceme\\nreplacemereplaceme\\nSheet2\\nSheet3\\n\", text);\n+    \n+    \t\textractor.setIncludeSheetNames(false);\n+    \t\textractor.setFormulasNotResults(true);\n+    \n+    \t\ttext = extractor.getText();\n+    \t\tassertEquals(\"replaceme\\nreplaceme\\nCONCATENATE(A1,A2)\\n\", text);\n+    \n+    \n+    \t\t// Now, a slightly longer file with numeric formulas\n+    \t\textractor = new EventBasedExcelExtractor(\n+    \t\t\t\tnew POIFSFileSystem(\n+    \t\t\t\t\t\tHSSFTestDataSamples.openSampleFileStream(\"sumifformula.xls\")\n+    \t\t\t\t)\n+    \t\t);\n+    \t\textractor.setIncludeSheetNames(false);\n+    \t\textractor.setFormulasNotResults(true);\n+    \n+    \t\ttext = extractor.getText();\n+    \t\tassertEquals(\n+    \t\t\t\t\"1000\\t1\\tSUMIF(A1:A5,\\\">4000\\\",B1:B5)\\n\" +\n+    \t\t\t\t\"2000\\t2\\n\" +\n+    \t\t\t\t\"3000\\t3\\n\" +\n+    \t\t\t\t\"4000\\t4\\n\" +\n+    \t\t\t\t\"5000\\t5\\n\",\n+    \t\t\t\ttext\n+    \t\t);\n+\t\t} finally {\n+\t\t    extractor.close();\n+\t\t}\n \t}\n \n \tpublic void testWithComments() {\n@@ -272,15 +277,22 @@ public void testWithEmbeded() throws Exception {\n \t\tHSSFWorkbook wbB = new HSSFWorkbook(dirB, fs, true);\n \n \t\tExcelExtractor exA = new ExcelExtractor(wbA);\n-\t\tExcelExtractor exB = new ExcelExtractor(wbB);\n-\n-\t\tassertEquals(\"Sheet1\\nTest excel file\\nThis is the first file\\nSheet2\\nSheet3\\n\",\n-\t\t\t\texA.getText());\n-\t\tassertEquals(\"Sample Excel\", exA.getSummaryInformation().getTitle());\n-\n-\t\tassertEquals(\"Sheet1\\nAnother excel file\\nThis is the second file\\nSheet2\\nSheet3\\n\",\n-\t\t\t\texB.getText());\n-\t\tassertEquals(\"Sample Excel 2\", exB.getSummaryInformation().getTitle());\n+\t\ttry {\n+    \t\tExcelExtractor exB = new ExcelExtractor(wbB);\n+    \t\ttry {\n+        \t\tassertEquals(\"Sheet1\\nTest excel file\\nThis is the first file\\nSheet2\\nSheet3\\n\",\n+        \t\t\t\texA.getText());\n+        \t\tassertEquals(\"Sample Excel\", exA.getSummaryInformation().getTitle());\n+        \n+        \t\tassertEquals(\"Sheet1\\nAnother excel file\\nThis is the second file\\nSheet2\\nSheet3\\n\",\n+        \t\t\t\texB.getText());\n+        \t\tassertEquals(\"Sample Excel 2\", exB.getSummaryInformation().getTitle());\n+    \t\t} finally {\n+    \t\t    exB.close();\n+    \t\t}\n+\t\t} finally {\n+\t\t    exA.close();\n+\t\t}\n \t}\n \n \t/**\n@@ -299,21 +311,32 @@ public void testWithEmbededInOwn() throws Exception {\n \t\tHSSFWorkbook wbB = new HSSFWorkbook(dirB, fs, true);\n \n \t\tExcelExtractor exA = new ExcelExtractor(wbA);\n-\t\tExcelExtractor exB = new ExcelExtractor(wbB);\n-\n-\t\tassertEquals(\"Sheet1\\nTest excel file\\nThis is the first file\\nSheet2\\nSheet3\\n\",\n-\t\t\t\texA.getText());\n-\t\tassertEquals(\"Sample Excel\", exA.getSummaryInformation().getTitle());\n-\n-\t\tassertEquals(\"Sheet1\\nAnother excel file\\nThis is the second file\\nSheet2\\nSheet3\\n\",\n-\t\t\t\texB.getText());\n-\t\tassertEquals(\"Sample Excel 2\", exB.getSummaryInformation().getTitle());\n-\n-\t\t// And the base file too\n-\t\tExcelExtractor ex = new ExcelExtractor(fs);\n-\t\tassertEquals(\"Sheet1\\nI have lots of embeded files in me\\nSheet2\\nSheet3\\n\",\n-\t\t\t\tex.getText());\n-\t\tassertEquals(\"Excel With Embeded\", ex.getSummaryInformation().getTitle());\n+\t\ttry {\n+    \t\tExcelExtractor exB = new ExcelExtractor(wbB);\n+    \t\ttry {\n+        \t\tassertEquals(\"Sheet1\\nTest excel file\\nThis is the first file\\nSheet2\\nSheet3\\n\",\n+        \t\t\t\texA.getText());\n+        \t\tassertEquals(\"Sample Excel\", exA.getSummaryInformation().getTitle());\n+        \n+        \t\tassertEquals(\"Sheet1\\nAnother excel file\\nThis is the second file\\nSheet2\\nSheet3\\n\",\n+        \t\t\t\texB.getText());\n+        \t\tassertEquals(\"Sample Excel 2\", exB.getSummaryInformation().getTitle());\n+        \n+        \t\t// And the base file too\n+        \t\tExcelExtractor ex = new ExcelExtractor(fs);\n+        \t\ttry {\n+            \t\tassertEquals(\"Sheet1\\nI have lots of embeded files in me\\nSheet2\\nSheet3\\n\",\n+            \t\t\t\tex.getText());\n+            \t\tassertEquals(\"Excel With Embeded\", ex.getSummaryInformation().getTitle());\n+        \t\t} finally {\n+        \t\t    ex.close();\n+        \t\t}\n+            } finally {\n+                exB.close();\n+            }\n+        } finally {\n+            exA.close();\n+        }\n \t}\n \n \t/**",
                "raw_url": "https://github.com/apache/poi/raw/a3e087268a6ff9d5b90d3d334593d56693e400b8/src/testcases/org/apache/poi/hssf/extractor/TestExcelExtractor.java",
                "sha": "f7584ff11be2b4fbceb61c610d068ac78cb89d8a",
                "status": "modified"
            }
        ],
        "message": "* Verify some more Text-Extraction features as part of integration tests, fix some NullPointerExceptions that showed up now because the event-based extraction does not have a Document available\n* Also handle a XLSX which does not have row-numbers in the sheet-xml. Excel can read it so it makes sense to also allow to read it in the XSSFSheetXMLHandler \n* Remove some Eclipse warnings in test-code\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1662691 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/27c6da8286197840c0dbe909abb767a25fb5a28e",
        "patched_files": [
            "HSSFEventFactory.java",
            "ExtractorFactory.java",
            "POIXMLPropertiesTextExtractor.java",
            "ExcelExtractor.java",
            "XSSFEventBasedExcelExtractor.java",
            "XSSFSheetXMLHandler.java",
            "XSSFFileHandler.java",
            "AbstractFileHandler.java",
            "HPSFPropertiesExtractor.java",
            "HPSFFileHandler.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFEventBasedExcelExtractor.java",
            "TestHPSFPropertiesExtractor.java",
            "TestHSSFEventFactory.java",
            "TestExtractorFactory.java",
            "TestExcelExtractor.java"
        ]
    },
    "poi_a58d9dd": {
        "bug_id": "poi_a58d9dd",
        "commit": "https://github.com/apache/poi/commit/a58d9dd33ba004e2c3e98def20174fc63a743a7e",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=a58d9dd33ba004e2c3e98def20174fc63a743a7e",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.8-beta4\" date=\"2011-??-??\">\n+           <action dev=\"poi-developers\" type=\"fix\">51504 - avoid NPE when DefaultRowHeight or DefaultColumnWidth records are missing</action>\n            <action dev=\"poi-developers\" type=\"fix\">51502 - Correct Subtotal function javadoc entry</action>\n            <action dev=\"poi-developers\" type=\"add\">Support for hyperlinks in SXSSF</action>\n            <action dev=\"poi-developers\" type=\"fix\">49933 - Word 6/95 documents with sections cause ArrayIndexOutOfBoundsException</action>",
                "raw_url": "https://github.com/apache/poi/raw/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/documentation/content/xdocs/status.xml",
                "sha": "da2b6b8423f391b3f72ae7f0a0cd401b09e99a2c",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/java/org/apache/poi/hssf/model/InternalSheet.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/model/InternalSheet.java?ref=a58d9dd33ba004e2c3e98def20174fc63a743a7e",
                "deletions": 10,
                "filename": "src/java/org/apache/poi/hssf/model/InternalSheet.java",
                "patch": "@@ -65,12 +65,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hssf.record.aggregates.MergedCellsTable;\n import org.apache.poi.hssf.record.aggregates.PageSettingsBlock;\n import org.apache.poi.hssf.record.aggregates.RecordAggregate;\n-import org.apache.poi.hssf.record.aggregates.RowRecordsAggregate;\n-import org.apache.poi.hssf.record.aggregates.WorksheetProtectionBlock;\n import org.apache.poi.hssf.record.aggregates.RecordAggregate.PositionTrackingVisitor;\n import org.apache.poi.hssf.record.aggregates.RecordAggregate.RecordVisitor;\n-import org.apache.poi.ss.formula.FormulaShifter;\n+import org.apache.poi.hssf.record.aggregates.RowRecordsAggregate;\n+import org.apache.poi.hssf.record.aggregates.WorksheetProtectionBlock;\n import org.apache.poi.hssf.util.PaneInformation;\n+import org.apache.poi.ss.formula.FormulaShifter;\n import org.apache.poi.ss.util.CellRangeAddress;\n import org.apache.poi.util.Internal;\n import org.apache.poi.util.POILogFactory;\n@@ -110,8 +110,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     protected PrintGridlinesRecord       printGridlines    =     null;\n     protected GridsetRecord              gridset           =     null;\n     private   GutsRecord                 _gutsRecord;\n-    protected DefaultColWidthRecord      defaultcolwidth   =     null;\n-    protected DefaultRowHeightRecord     defaultrowheight  =     null;\n+    protected DefaultColWidthRecord      defaultcolwidth   =     new DefaultColWidthRecord();\n+    protected DefaultRowHeightRecord     defaultrowheight  =     new DefaultRowHeightRecord();\n     private PageSettingsBlock _psBlock;\n \n     /**\n@@ -272,7 +272,7 @@ private InternalSheet(RecordStream rs) {\n                 records.add(rec);\n                 continue;\n             }\n-            \n+\n             if (recSid == EOFRecord.sid) {\n                 records.add(rec);\n                 break;\n@@ -723,7 +723,7 @@ public void addRow(RowRecord row) {\n     public void removeRow(RowRecord row) {\n         _rowsAggregate.removeRow(row);\n     }\n-    \n+\n     /**\n      * Get all the value records (from LOC). Records will be returned from the first\n      *  record (starting at LOC) which is a value record.\n@@ -753,7 +753,7 @@ public void removeRow(RowRecord row) {\n      * subsequent calls will return values in (physical) sequence or NULL when you get to the end.\n      *\n      * @return Array of CellValueRecordInterface representing the remaining value records\n-     * @deprecated use {@link #getValueIterator()} instead\n+     * @deprecated use {@link #getCellValueIterator()} instead\n      */\n     @Deprecated\n     public CellValueRecordInterface[] getValueRecords() {\n@@ -934,7 +934,7 @@ private static DefaultRowHeightRecord createDefaultRowHeight() {\n         DefaultRowHeightRecord retval = new DefaultRowHeightRecord();\n \n         retval.setOptionFlags(( short ) 0);\n-        retval.setRowHeight(( short ) 0xff);\n+        retval.setRowHeight(DefaultRowHeightRecord.DEFAULT_ROW_HEIGHT);\n         return retval;\n     }\n \n@@ -955,7 +955,7 @@ private static WSBoolRecord createWSBool() {\n       */\n     private static DefaultColWidthRecord createDefaultColWidth() {\n         DefaultColWidthRecord retval = new DefaultColWidthRecord();\n-        retval.setColWidth(( short ) 8);\n+        retval.setColWidth(DefaultColWidthRecord.DEFAULT_COLUMN_WIDTH);\n         return retval;\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/java/org/apache/poi/hssf/model/InternalSheet.java",
                "sha": "a6a427262fec1ebb0e3a5bd28b1430c290a7d3ef",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/java/org/apache/poi/hssf/record/DefaultColWidthRecord.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/DefaultColWidthRecord.java?ref=a58d9dd33ba004e2c3e98def20174fc63a743a7e",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/record/DefaultColWidthRecord.java",
                "patch": "@@ -32,8 +32,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     public final static short sid = 0x0055;\n     private int             field_1_col_width;\n \n+    /**\n+     *  The default column width is 8 characters\n+     */\n+    public final static int DEFAULT_COLUMN_WIDTH = 0x0008;\n+\n     public DefaultColWidthRecord()\n     {\n+        field_1_col_width = DEFAULT_COLUMN_WIDTH;\n     }\n \n     public DefaultColWidthRecord(RecordInputStream in)",
                "raw_url": "https://github.com/apache/poi/raw/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/java/org/apache/poi/hssf/record/DefaultColWidthRecord.java",
                "sha": "6e3160ff6205d848ec09d9afe286b873ce8568e1",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/java/org/apache/poi/hssf/record/DefaultRowHeightRecord.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/DefaultRowHeightRecord.java?ref=a58d9dd33ba004e2c3e98def20174fc63a743a7e",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/DefaultRowHeightRecord.java",
                "patch": "@@ -15,7 +15,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ==================================================================== */\n-        \n+\n \n package org.apache.poi.hssf.record;\n \n@@ -38,8 +38,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private short             field_1_option_flags;\n     private short             field_2_row_height;\n \n+    /**\n+     * The default row height for empty rows is 255 twips (255 / 20 == 12.75 points)\n+     */\n+    public static final short DEFAULT_ROW_HEIGHT = 0xFF;\n+\n     public DefaultRowHeightRecord()\n     {\n+        field_1_option_flags = 0x0000;\n+        field_2_row_height = DEFAULT_ROW_HEIGHT;\n     }\n \n     public DefaultRowHeightRecord(RecordInputStream in)",
                "raw_url": "https://github.com/apache/poi/raw/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/java/org/apache/poi/hssf/record/DefaultRowHeightRecord.java",
                "sha": "0d015e09ab60ba551f3bbbf842f03cfeb8264df2",
                "status": "modified"
            },
            {
                "additions": 22,
                "blob_url": "https://github.com/apache/poi/blob/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java?ref=a58d9dd33ba004e2c3e98def20174fc63a743a7e",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "patch": "@@ -736,6 +736,28 @@ public void testColumnWidth() {\n         assertEquals(40000, sh.getColumnWidth(0));\n     }\n \n+\n+    public void testDefaultColumnWidth() {\n+        HSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook( \"12843-1.xls\" );\n+        HSSFSheet sheet = wb.getSheetAt( 7 );\n+        // shall not be NPE\n+        assertEquals(8, sheet.getDefaultColumnWidth());\n+        assertEquals(8*256, sheet.getColumnWidth(0));\n+\n+        assertEquals(0xFF, sheet.getDefaultRowHeight());\n+\n+        wb = HSSFTestDataSamples.openSampleWorkbook( \"34775.xls\" );\n+        // second and third sheets miss DefaultColWidthRecord\n+        for(int i = 1; i <= 2; i++){\n+            int dw = wb.getSheetAt( i ).getDefaultColumnWidth();\n+            assertEquals(8, dw);\n+            int cw = wb.getSheetAt( i ).getColumnWidth(0);\n+            assertEquals(8*256, cw);\n+\n+            assertEquals(0xFF, sheet.getDefaultRowHeight());\n+        }\n+    }\n+\n     /**\n      * Some utilities write Excel files without the ROW records.\n      * Excel, ooo, and google docs are OK with this.",
                "raw_url": "https://github.com/apache/poi/raw/a58d9dd33ba004e2c3e98def20174fc63a743a7e/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "sha": "85a4cb3b0acfabd44c704a87c86cab8cc03c9f57",
                "status": "modified"
            }
        ],
        "message": "Bug 51504 - avoid NPE when DefaultRowHeight or DefaultColumnWidth records are missing\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1147049 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/673891cc9ed0b3a19412a53aa8cbae19b5c41748",
        "patched_files": [
            "InternalSheet.java",
            "DefaultColWidthRecord.java",
            "HSSFSheet.java",
            "status.java",
            "DefaultRowHeightRecord.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHSSFSheet.java"
        ]
    },
    "poi_a9b2a8b": {
        "bug_id": "poi_a9b2a8b",
        "commit": "https://github.com/apache/poi/commit/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
        "file": [
            {
                "additions": 56,
                "blob_url": "https://github.com/apache/poi/blob/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/integrationtest/org/apache/poi/stress/SlideShowHandler.java",
                "changes": 80,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/integrationtest/org/apache/poi/stress/SlideShowHandler.java?ref=a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
                "deletions": 24,
                "filename": "src/integrationtest/org/apache/poi/stress/SlideShowHandler.java",
                "patch": "@@ -16,8 +16,18 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.stress;\n \n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import org.apache.poi.sl.draw.Drawable;\n+import org.apache.poi.sl.usermodel.GroupShape;\n+import org.apache.poi.sl.usermodel.Notes;\n+import org.apache.poi.sl.usermodel.PictureData;\n+import org.apache.poi.sl.usermodel.Shape;\n+import org.apache.poi.sl.usermodel.SimpleShape;\n+import org.apache.poi.sl.usermodel.Slide;\n+import org.apache.poi.sl.usermodel.SlideShow;\n+import org.apache.poi.sl.usermodel.SlideShowFactory;\n+import org.apache.poi.sl.usermodel.TextParagraph;\n+import org.apache.poi.sl.usermodel.TextRun;\n+import org.apache.poi.sl.usermodel.TextShape;\n \n import java.awt.Dimension;\n import java.awt.Graphics2D;\n@@ -28,16 +38,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.io.IOException;\n import java.lang.ref.WeakReference;\n \n-import org.apache.poi.sl.draw.Drawable;\n-import org.apache.poi.sl.usermodel.PictureData;\n-import org.apache.poi.sl.usermodel.Shape;\n-import org.apache.poi.sl.usermodel.ShapeContainer;\n-import org.apache.poi.sl.usermodel.Slide;\n-import org.apache.poi.sl.usermodel.SlideShow;\n-import org.apache.poi.sl.usermodel.SlideShowFactory;\n-import org.apache.poi.sl.usermodel.TextParagraph;\n-import org.apache.poi.sl.usermodel.TextRun;\n-import org.apache.poi.sl.usermodel.TextShape;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n \n public abstract class SlideShowHandler extends POIFSFileHandler {\n     public void handleSlideShow(SlideShow<?,?> ss) throws IOException {\n@@ -73,20 +75,50 @@ private ByteArrayOutputStream writeToArray(SlideShow<?,?> ss) throws IOException\n     private void readContent(SlideShow<?,?> ss) {\n         for (Slide<?,?> s : ss.getSlides()) {\n             s.getTitle();\n-            readText(s);\n-            readText(s.getNotes());\n-            readText(s.getMasterSheet());\n+\n+            for (Shape<?,?> shape : s) {\n+                readShapes(shape);\n+            }\n+\n+            Notes<?, ?> notes = s.getNotes();\n+            if(notes != null) {\n+                for (Shape<?, ?> shape : notes) {\n+                    readShapes(shape);\n+                }\n+            }\n+\n+            for (Shape<?,?> shape : s.getMasterSheet()) {\n+                readShapes(shape);\n+            }\n         }\n     }\n-    \n-    private void readText(ShapeContainer<?,?> sc) {\n-        if (sc == null) return;\n-        for (Shape<?,?> s : sc) {\n-            if (s instanceof TextShape) {\n-                for (TextParagraph<?,?,?> tp : (TextShape<?,?>)s) {\n-                    for (TextRun tr : tp) {\n-                        tr.getRawText();\n-                    }\n+\n+    private void readShapes(Shape<?,?> s) {\n+        // recursively walk group-shapes\n+        if(s instanceof GroupShape) {\n+            GroupShape<? extends Shape, ?> shapes = (GroupShape<? extends Shape, ?>) s;\n+            for (Shape<? extends Shape, ?> shape : shapes) {\n+                readShapes(shape);\n+            }\n+        }\n+\n+        if(s instanceof SimpleShape) {\n+            SimpleShape<?, ?> simpleShape = (SimpleShape<?, ?>) s;\n+\n+            simpleShape.getFillColor();\n+            simpleShape.getFillStyle();\n+            simpleShape.getStrokeStyle();\n+            simpleShape.getLineDecoration();\n+        }\n+\n+        readText(s);\n+    }\n+\n+    private void readText(Shape<?,?> s) {\n+        if (s instanceof TextShape) {\n+            for (TextParagraph<?,?,?> tp : (TextShape<?,?>)s) {\n+                for (TextRun tr : tp) {\n+                    tr.getRawText();\n                 }\n             }\n         }",
                "raw_url": "https://github.com/apache/poi/raw/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/integrationtest/org/apache/poi/stress/SlideShowHandler.java",
                "sha": "9c0e7316d0e89d18bbd62a9fbfdcb467cdca343d",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/java/org/apache/poi/sl/draw/DrawPaint.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/sl/draw/DrawPaint.java?ref=a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/sl/draw/DrawPaint.java",
                "patch": "@@ -407,7 +407,10 @@ protected Paint createLinearGradientPaint(GradientPaint fill, Graphics2D graphic\n //        snapToAnchor(p2, anchor);\n \n         // gradient paint on the same point throws an exception ... and doesn't make sense\n-        return (p1.equals(p2)) ? null : safeFractions((f,c)->new LinearGradientPaint(p1,p2,f,c), fill);\n+        // also having less than two fractions will not work\n+        return (p1.equals(p2) || fill.getGradientFractions().length < 2) ?\n+                null :\n+                safeFractions((f,c)->new LinearGradientPaint(p1,p2,f,c), fill);\n     }\n \n ",
                "raw_url": "https://github.com/apache/poi/raw/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/java/org/apache/poi/sl/draw/DrawPaint.java",
                "sha": "f012161b3c3727b6517fa518151f6b7d52bcd903",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/ooxml/java/org/apache/poi/xddf/usermodel/XDDFGradientFillProperties.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xddf/usermodel/XDDFGradientFillProperties.java?ref=a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xddf/usermodel/XDDFGradientFillProperties.java",
                "patch": "@@ -112,7 +112,7 @@ public XDDFGradientStop getGradientStop(int index) {\n                 .getGsLst()\n                 .getGsList()\n                 .stream()\n-                .map(gs -> new XDDFGradientStop(gs))\n+                .map(XDDFGradientStop::new)\n                 .collect(Collectors.toList()));\n         } else {\n             return Collections.emptyList();",
                "raw_url": "https://github.com/apache/poi/raw/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/ooxml/java/org/apache/poi/xddf/usermodel/XDDFGradientFillProperties.java",
                "sha": "ab05448eece2a902e1b7274b6a472e1716f15f1a",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java?ref=a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java",
                "patch": "@@ -431,7 +431,8 @@ public int getAlpha() {\n     protected static PaintStyle selectPaint(final CTGradientFillProperties gradFill, CTSchemeColor phClr, final XSLFTheme theme) {\n \n         @SuppressWarnings(\"deprecation\")\n-        final CTGradientStop[] gs = gradFill.getGsLst().getGsArray();\n+        final CTGradientStop[] gs = gradFill.getGsLst() == null ?\n+                new CTGradientStop[0] : gradFill.getGsLst().getGsArray();\n \n         Arrays.sort(gs, (o1, o2) -> {\n             int pos1 = o1.getPos();",
                "raw_url": "https://github.com/apache/poi/raw/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java",
                "sha": "3df55edbaa029fb4112969a6ff98acd3bbc3fb2b",
                "status": "modified"
            },
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/poi/blob/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java",
                "changes": 17,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java?ref=a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java",
                "patch": "@@ -966,4 +966,21 @@ public void bug62051() throws IOException {\n \n         }\n     }\n+\n+    @Test\n+    public void bug63200() throws Exception {\n+        try (XMLSlideShow ss1 = XSLFTestDataSamples.openSampleDocument(\"63200.pptx\")) {\n+            assertEquals(1, ss1.getSlides().size());\n+\n+            XSLFSlide slide = ss1.getSlides().get(0);\n+\n+            assertEquals(slide.getShapes().size(), 1);\n+            XSLFGroupShape group = (XSLFGroupShape) slide.getShapes().get(0);\n+            assertEquals(group.getShapes().size(), 2);\n+            XSLFAutoShape oval = (XSLFAutoShape) group.getShapes().get(0);\n+            XSLFAutoShape arrow = (XSLFAutoShape) group.getShapes().get(1);\n+            assertNull(oval.getFillColor());\n+            assertNull(arrow.getFillColor());\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/src/ooxml/testcases/org/apache/poi/xslf/TestXSLFBugs.java",
                "sha": "da25fc77e881c9646a511fe72706e267756117d5",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/test-data/slideshow/63200.pptx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/slideshow/63200.pptx?ref=a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968",
                "deletions": 0,
                "filename": "test-data/slideshow/63200.pptx",
                "raw_url": "https://github.com/apache/poi/raw/a9b2a8b2bd6e93ba85984be9a2aa8f9ac991c968/test-data/slideshow/63200.pptx",
                "sha": "6a8dc6cc84137574bf3ea9c32112606973e846e7",
                "status": "added"
            }
        ],
        "message": "Bug 63200: Avoid NullPointerException in XSLFShape.selectPaint() and check some more in integration tests\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1854639 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/53a30d796e27cf44eff2fdecf173b42e89430f61",
        "patched_files": [
            "SlideShowHandler.java",
            "DrawPaint.java",
            "XSLFShape.java",
            "63200.java",
            "XDDFGradientFillProperties.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSLFBugs.java",
            "TestXSLFShape.java"
        ]
    },
    "poi_af9142e": {
        "bug_id": "poi_af9142e",
        "commit": "https://github.com/apache/poi/commit/af9142e4b744638fa448f81081a7cda1bc376576",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/af9142e4b744638fa448f81081a7cda1bc376576/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFSDTContent.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFSDTContent.java?ref=af9142e4b744638fa448f81081a7cda1bc376576",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFSDTContent.java",
                "patch": "@@ -47,6 +47,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     private List<ISDTContents> bodyElements = new ArrayList<>();\n \n     public XWPFSDTContent(CTSdtContentRun sdtRun, IBody part, IRunBody parent) {\n+        if (sdtRun == null) {\n+            return;\n+        }\n         for (CTR ctr : sdtRun.getRArray()) {\n             XWPFRun run = new XWPFRun(ctr, parent);\n             // runs.add(run);\n@@ -55,6 +58,9 @@ public XWPFSDTContent(CTSdtContentRun sdtRun, IBody part, IRunBody parent) {\n     }\n \n     public XWPFSDTContent(CTSdtContentBlock block, IBody part, IRunBody parent) {\n+        if (block == null) {\n+            return;\n+        }\n         XmlCursor cursor = block.newCursor();\n         cursor.selectPath(\"./*\");\n         while (cursor.toNextSelection()) {",
                "raw_url": "https://github.com/apache/poi/raw/af9142e4b744638fa448f81081a7cda1bc376576/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFSDTContent.java",
                "sha": "f39c5cf482a733bb8b36b1474c74d17270a08834",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/af9142e4b744638fa448f81081a7cda1bc376576/src/ooxml/testcases/org/apache/poi/sl/TestFonts.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/sl/TestFonts.java?ref=af9142e4b744638fa448f81081a7cda1bc376576",
                "deletions": 1,
                "filename": "src/ooxml/testcases/org/apache/poi/sl/TestFonts.java",
                "patch": "@@ -74,7 +74,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n     // currently linux and mac return quite different values\n     private static final int[] expected_sizes = {\n             304, // windows 10, 1080p, MS Office 2016, system text scaling 100% instead of default 125%\n-            306, // Windows 10, 15.6\" 3840x2160\n+            306, 308,// Windows 10, 15.6\" 3840x2160\n             311, 312, 313, 318,\n             348, // Windows 10, 15.6\" 3840x2160\n             362, // Windows 10, 13.3\" 1080p high-dpi",
                "raw_url": "https://github.com/apache/poi/raw/af9142e4b744638fa448f81081a7cda1bc376576/src/ooxml/testcases/org/apache/poi/sl/TestFonts.java",
                "sha": "f35065de75b9b0d437f43848878b27bf4f80d911",
                "status": "modified"
            },
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/poi/blob/af9142e4b744638fa448f81081a7cda1bc376576/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java?ref=af9142e4b744638fa448f81081a7cda1bc376576",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java",
                "patch": "@@ -148,6 +148,19 @@ public void test60341() throws IOException {\n         assertEquals(\"\", sdts.get(0).getTitle());\n     }\n \n+    @Test\n+    public void test62859() throws IOException {\n+        //this doesn't test the exact code path for this issue, but\n+        //it does test for a related issue, and the fix fixes both.\n+        //We should try to add the actual triggering document\n+        //to our test suite.\n+        XWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Bug62859.docx\");\n+        List<XWPFAbstractSDT> sdts = extractAllSDTs(doc);\n+        assertEquals(1, sdts.size());\n+        assertEquals(\"\", sdts.get(0).getTag());\n+        assertEquals(\"\", sdts.get(0).getTitle());\n+    }\n+\n     private List<XWPFAbstractSDT> extractAllSDTs(XWPFDocument doc) {\n \n         List<XWPFAbstractSDT> sdts = new ArrayList<>();",
                "raw_url": "https://github.com/apache/poi/raw/af9142e4b744638fa448f81081a7cda1bc376576/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFSDT.java",
                "sha": "9388e087102658bf10e14d88f08a54a2848f8443",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/af9142e4b744638fa448f81081a7cda1bc376576/test-data/document/Bug62859.docx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/Bug62859.docx?ref=af9142e4b744638fa448f81081a7cda1bc376576",
                "deletions": 0,
                "filename": "test-data/document/Bug62859.docx",
                "raw_url": "https://github.com/apache/poi/raw/af9142e4b744638fa448f81081a7cda1bc376576/test-data/document/Bug62859.docx",
                "sha": "e0ede4a83db6a202989695236065e72c8884bf79",
                "status": "added"
            }
        ],
        "message": "bug 62859 -- fix two potential NPEs when initializing XWPFSDTContent\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1844920 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/960cbb77146c550661c7f75ef86a151c0f4528d5",
        "patched_files": [
            "XWPFSDT.java",
            "XWPFSDTContent.java",
            "Bug62859.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFSDT.java",
            "TestFonts.java"
        ]
    },
    "poi_afba4c2": {
        "bug_id": "poi_afba4c2",
        "commit": "https://github.com/apache/poi/commit/afba4c2a2d43049585e8b2b26f6369d716e5fd89",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/afba4c2a2d43049585e8b2b26f6369d716e5fd89/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=afba4c2a2d43049585e8b2b26f6369d716e5fd89",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.9-beta1\" date=\"2012-??-??\">\n+          <action dev=\"poi-developers\" type=\"fix\">54188 - Avoid NPE in PPT2PNG</action>\n           <action dev=\"poi-developers\" type=\"fix\">52628 - Replace System.err info messages with a POILogger</action>\n           <action dev=\"poi-developers\" type=\"fix\">54137 - improved performance of DataFormatter with Fractions</action>\n           <action dev=\"poi-developers\" type=\"fix\">54099 - Ensure that CTHMerge and CTTcBorders go to poi-ooxml-schemas jar</action>",
                "raw_url": "https://github.com/apache/poi/raw/afba4c2a2d43049585e8b2b26f6369d716e5fd89/src/documentation/content/xdocs/status.xml",
                "sha": "cd23b88fed9d9729a7068ee7a84f31eda5e11861",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/afba4c2a2d43049585e8b2b26f6369d716e5fd89/src/scratchpad/src/org/apache/poi/hslf/model/Freeform.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Freeform.java?ref=afba4c2a2d43049585e8b2b26f6369d716e5fd89",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Freeform.java",
                "patch": "@@ -244,6 +244,11 @@ public GeneralPath getPath(){\n \n     public java.awt.Shape getOutline(){\n         GeneralPath path =  getPath();\n+        if(path == null) {\n+            // return empty path if either GEOMETRY__VERTICES or GEOMETRY__SEGMENTINFO is missing, see Bugzilla 54188\n+            return new GeneralPath();\n+        }\n+\n         Rectangle2D anchor = getAnchor2D();\n         Rectangle2D bounds = path.getBounds2D();\n         AffineTransform at = new AffineTransform();",
                "raw_url": "https://github.com/apache/poi/raw/afba4c2a2d43049585e8b2b26f6369d716e5fd89/src/scratchpad/src/org/apache/poi/hslf/model/Freeform.java",
                "sha": "10c468ced7455c78009be05fd60b89479c5a21d0",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/afba4c2a2d43049585e8b2b26f6369d716e5fd89/src/scratchpad/testcases/org/apache/poi/hslf/model/TestFreeform.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestFreeform.java?ref=afba4c2a2d43049585e8b2b26f6369d716e5fd89",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestFreeform.java",
                "patch": "@@ -71,4 +71,16 @@ public void testRectangle() {\n         java.awt.Shape path2 = p.getOutline();\n         assertTrue(new Area(path1).equals(new Area(path2)));\n    }\n+\n+    /**\n+     * Avoid NPE in  Freeform.getOutline() if either GEOMETRY__VERTICES or\n+     * GEOMETRY__SEGMENTINFO is missing, see Bugzilla 54188\n+     */\n+    public void test54188() {\n+\n+        Freeform p = new Freeform();\n+        GeneralPath path = (GeneralPath)p.getOutline();\n+        GeneralPath emptyPath = new GeneralPath();\n+        assertEquals(emptyPath.getBounds2D(), path.getBounds2D());\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/afba4c2a2d43049585e8b2b26f6369d716e5fd89/src/scratchpad/testcases/org/apache/poi/hslf/model/TestFreeform.java",
                "sha": "6ff487038669f4845c73e14b2fdd6915864b3508",
                "status": "modified"
            }
        ],
        "message": "Bugzilla 54188 - Avoid NPE in PPT2PNG\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1413339 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/2599c4f9dffc2b6b0d70d1dd9eb723f3f36c73d7",
        "patched_files": [
            "Freeform.java",
            "status.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestFreeform.java"
        ]
    },
    "poi_b5653e8": {
        "bug_id": "poi_b5653e8",
        "commit": "https://github.com/apache/poi/commit/b5653e882986e219b3f2c0faf7b73c2d16f11f41",
        "file": [
            {
                "additions": 143,
                "blob_url": "https://github.com/apache/poi/blob/b5653e882986e219b3f2c0faf7b73c2d16f11f41/src/java/org/apache/poi/poifs/macros/VBAMacroReader.java",
                "changes": 159,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/poifs/macros/VBAMacroReader.java?ref=b5653e882986e219b3f2c0faf7b73c2d16f11f41",
                "deletions": 16,
                "filename": "src/java/org/apache/poi/poifs/macros/VBAMacroReader.java",
                "patch": "@@ -20,9 +20,19 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import static org.apache.poi.util.StringUtil.endsWithIgnoreCase;\n import static org.apache.poi.util.StringUtil.startsWithIgnoreCase;\n \n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipInputStream;\n@@ -39,6 +49,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.util.HexDump;\n import org.apache.poi.util.IOUtils;\n import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.util.POILogFactory;\n+import org.apache.poi.util.POILogger;\n import org.apache.poi.util.RLEDecompressingInputStream;\n import org.apache.poi.util.StringUtil;\n \n@@ -56,6 +68,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * @since 3.15-beta2\n  */\n public class VBAMacroReader implements Closeable {\n+    private static final POILogger LOGGER = POILogFactory.getLogger(VBAMacroReader.class);\n+\n     protected static final String VBA_PROJECT_OOXML = \"vbaProject.bin\";\n     protected static final String VBA_PROJECT_POIFS = \"VBA\";\n \n@@ -111,8 +125,13 @@ public void close() throws IOException {\n \n     public Map<String, Module> readMacroModules() throws IOException {\n         final ModuleMap modules = new ModuleMap();\n+        //ascii -> unicode mapping for module names\n+        //preserve insertion order\n+        final Map<String, String> moduleNameMap = new LinkedHashMap<>();\n+\n         findMacros(fs.getRoot(), modules);\n-        findProjectProperties(fs.getRoot(), modules);\n+        findModuleNameMap(fs.getRoot(), moduleNameMap, modules);\n+        findProjectProperties(fs.getRoot(), moduleNameMap, modules);\n \n         Map<String, Module> moduleSources = new HashMap<>();\n         for (Map.Entry<String, ModuleImpl> entry : modules.entrySet()) {\n@@ -327,16 +346,33 @@ protected void readMacros(DirectoryNode macroDir, ModuleMap modules) throws IOEx\n         }\n     }\n \n-    protected void findProjectProperties(DirectoryNode node, ModuleMap modules) throws IOException {\n+    protected void findProjectProperties(DirectoryNode node, Map<String, String> moduleNameMap, ModuleMap modules) throws IOException {\n         for (Entry entry : node) {\n             if (\"project\".equalsIgnoreCase(entry.getName())) {\n                 DocumentNode document = (DocumentNode)entry;\n                 DocumentInputStream dis = new DocumentInputStream(document);\n-                readProjectProperties(dis, modules);\n+                readProjectProperties(dis, moduleNameMap, modules);\n+            } else {\n+                for (Entry child : node) {\n+                    if (child instanceof DirectoryNode) {\n+                        findProjectProperties((DirectoryNode)child, moduleNameMap, modules);\n+                    }\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    protected void findModuleNameMap(DirectoryNode node, Map<String, String> moduleNameMap, ModuleMap modules) throws IOException {\n+        for (Entry entry : node) {\n+            if (\"projectwm\".equalsIgnoreCase(entry.getName())) {\n+                DocumentNode document = (DocumentNode)entry;\n+                DocumentInputStream dis = new DocumentInputStream(document);\n+                readNameMapRecords(dis, moduleNameMap, modules.charset);\n             } else {\n                 for (Entry child : node) {\n                     if (child instanceof DirectoryNode) {\n-                        findProjectProperties((DirectoryNode)child, modules);\n+                        findModuleNameMap((DirectoryNode)child, moduleNameMap, modules);\n                     }\n                 }\n \n@@ -559,6 +595,75 @@ private ASCIIUnicodeStringPair readStringPair(RLEDecompressingInputStream in, Ch\n         return new ASCIIUnicodeStringPair(ascii, unicode);\n     }\n \n+    private static void readNameMapRecords(InputStream is, Map<String, String> moduleNames, Charset charset) throws IOException {\n+        //see 2.3.3 PROJECTwm Stream: Module Name Information\n+        //multibytecharstring\n+        String mbcs = null;\n+        String unicode = null;\n+        do {\n+            try {\n+                mbcs = readMBCS(is, charset);\n+            } catch (EOFException e) {\n+                return;\n+            }\n+            if (mbcs == null) {\n+                return;\n+            }\n+            try {\n+                unicode = readUnicode(is);\n+            } catch (EOFException e) {\n+                return;\n+            }\n+            if (mbcs != null && unicode != null) {\n+                moduleNames.put(mbcs, unicode);\n+            }\n+        } while (mbcs != null && unicode != null);\n+    }\n+\n+    private static String readUnicode(InputStream is) throws IOException {\n+        //reads null-terminated unicode string\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        int b0 = is.read();\n+        int b1 = is.read();\n+\n+        while ((b0 + b1) != 0) {\n+            if (b0 == -1 || b1 == -1) {\n+                throw new EOFException();\n+            }\n+\n+            bos.write(b0);\n+            bos.write(b1);\n+            b0 = is.read();\n+            b1 = is.read();\n+        }\n+        return new String (bos.toByteArray(), StandardCharsets.UTF_16LE);\n+    }\n+\n+    //returns a string if any bytes are read or null if two 0x00 are read\n+    private static String readMBCS(InputStream is, Charset charset) throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        int len = 0;\n+        int b = is.read();\n+        while (b != 0) {\n+            ++len;\n+            if (b == -1) {\n+                throw new EOFException();\n+            }\n+            bos.write(b);\n+            b = is.read();\n+        }\n+        if (len == 0) {\n+            b = is.read();\n+            if (b == -1) {\n+                throw new EOFException();\n+            }\n+            if (b != 0) {\n+                LOGGER.log(POILogger.WARN, \"expected two 0x00 at end of module name map\");\n+            }\n+            return null;\n+        }\n+        return new String(bos.toByteArray(), charset);\n+    }\n \n     /**\n      * Read <tt>length</tt> bytes of MBCS (multi-byte character set) characters from the stream\n@@ -579,7 +684,8 @@ private static String readString(InputStream stream, int length, Charset charset\n         return new String(buffer, 0, length, charset);\n     }\n \n-    protected void readProjectProperties(DocumentInputStream dis, ModuleMap modules) throws IOException {\n+    protected void readProjectProperties(DocumentInputStream dis,\n+                                         Map<String, String> moduleNameMap, ModuleMap modules) throws IOException {\n         InputStreamReader reader = new InputStreamReader(dis, modules.charset);\n         StringBuilder builder = new StringBuilder();\n         char[] buffer = new char[512];\n@@ -588,29 +694,50 @@ protected void readProjectProperties(DocumentInputStream dis, ModuleMap modules)\n             builder.append(buffer, 0, read);\n         }\n         String properties = builder.toString();\n+        //the module name map names should be in exactly the same order\n+        //as the module names here. See 2.3.3 PROJECTwm Stream.\n+        //At some point, we might want to enforce that.\n         for (String line : properties.split(\"\\r\\n|\\n\\r\")) {\n             if (!line.startsWith(\"[\")) {\n                 String[] tokens = line.split(\"=\");\n                 if (tokens.length > 1 && tokens[1].length() > 1\n                         && tokens[1].startsWith(\"\\\"\") && tokens[1].endsWith(\"\\\"\")) {\n                     // Remove any double quotes\n                     tokens[1] = tokens[1].substring(1, tokens[1].length() - 1);\n-\n                 }\n-                if (\"Document\".equals(tokens[0])) {\n+                if (\"Document\".equals(tokens[0]) && tokens.length > 1) {\n                     String mn = tokens[1].substring(0, tokens[1].indexOf(\"/&H\"));\n-                    ModuleImpl module = modules.get(mn);\n-                    module.moduleType = ModuleType.Document;\n-                } else if (\"Module\".equals(tokens[0])) {\n-                    ModuleImpl module = modules.get(tokens[1]);\n-                    module.moduleType = ModuleType.Module;\n-                } else if (\"Class\".equals(tokens[0])) {\n-                    ModuleImpl module = modules.get(tokens[1]);\n-                    module.moduleType = ModuleType.Class;\n+                    ModuleImpl module = getModule(mn, moduleNameMap, modules);\n+                    if (module != null) {\n+                        module.moduleType = ModuleType.Document;\n+                    } else {\n+                        LOGGER.log(POILogger.WARN, \"couldn't find module with name: \"+mn);\n+                    }\n+                } else if (\"Module\".equals(tokens[0]) && tokens.length > 1) {\n+                    ModuleImpl module = getModule(tokens[1], moduleNameMap, modules);\n+                    if (module != null) {\n+                        module.moduleType = ModuleType.Module;\n+                    } else {\n+                        LOGGER.log(POILogger.WARN, \"couldn't find module with name: \"+tokens[1]);\n+                    }\n+                } else if (\"Class\".equals(tokens[0]) && tokens.length > 1) {\n+                    ModuleImpl module = getModule(tokens[1], moduleNameMap, modules);\n+                    if (module != null) {\n+                        module.moduleType = ModuleType.Class;\n+                    } else {\n+                        LOGGER.log(POILogger.WARN, \"couldn't find module with name: \"+tokens[1]);\n+                    }\n                 }\n             }\n         }\n     }\n+    //can return null!\n+    private ModuleImpl getModule(String moduleName, Map<String, String> moduleNameMap, ModuleMap moduleMap) {\n+        if (moduleNameMap.containsKey(moduleName)) {\n+            return moduleMap.get(moduleNameMap.get(moduleName));\n+        }\n+        return moduleMap.get(moduleName);\n+    }\n \n     private String readUnicodeString(RLEDecompressingInputStream in, int unicodeNameRecordLength) throws IOException {\n         byte[] buffer = IOUtils.safelyAllocate(unicodeNameRecordLength, 20000);",
                "raw_url": "https://github.com/apache/poi/raw/b5653e882986e219b3f2c0faf7b73c2d16f11f41/src/java/org/apache/poi/poifs/macros/VBAMacroReader.java",
                "sha": "cb6f3b91f3fa77a3ba03867c3abb9e51c47d70de",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/b5653e882986e219b3f2c0faf7b73c2d16f11f41/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java?ref=b5653e882986e219b3f2c0faf7b73c2d16f11f41",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "patch": "@@ -286,4 +286,18 @@ public void bug60279() throws IOException {\n         assertContains(content, \"Attribute VB_Customizable = True\");\n         r.close();\n     }\n+\n+    @Test\n+    public void bug62624() throws IOException {\n+        //macro comes from Common Crawl: HRLOXHGMGLFIJQQU27RIWXOARRHAAAAS\n+        File f = POIDataSamples.getSpreadSheetInstance().getFile(\"62624.bin\");\n+        VBAMacroReader r = new VBAMacroReader(f);\n+\n+        Map<String, Module> macros = r.readMacroModules();\n+        assertEquals(13, macros.size());\n+        assertNotNull(macros.get(\"M\\u00F3dulo1\"));\n+        assertContains(macros.get(\"M\\u00F3dulo1\").getContent(), \"Calcula_tributos\");\n+        assertEquals(Module.ModuleType.Module, macros.get(\"M\\u00F3dulo1\").geModuleType());\n+        r.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/b5653e882986e219b3f2c0faf7b73c2d16f11f41/src/testcases/org/apache/poi/poifs/macros/TestVBAMacroReader.java",
                "sha": "673f82e64f407d3f42965dbd94b505594350672c",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/b5653e882986e219b3f2c0faf7b73c2d16f11f41/test-data/spreadsheet/62624.bin",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/62624.bin?ref=b5653e882986e219b3f2c0faf7b73c2d16f11f41",
                "deletions": 0,
                "filename": "test-data/spreadsheet/62624.bin",
                "raw_url": "https://github.com/apache/poi/raw/b5653e882986e219b3f2c0faf7b73c2d16f11f41/test-data/spreadsheet/62624.bin",
                "sha": "9af59522e56e77d897ef90d3406004eb508bf3f7",
                "status": "added"
            }
        ],
        "message": "bug 62624 -- fix npe by adding processing of module name mapping in VBAMacroReader\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1845138 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/cc131eeab945f374729322f7e09ce31bce4dab05",
        "patched_files": [
            "VBAMacroReader.java",
            "62624.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestVBAMacroReader.java"
        ]
    },
    "poi_bae4602": {
        "bug_id": "poi_bae4602",
        "commit": "https://github.com/apache/poi/commit/bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91/src/ooxml/java/org/apache/poi/xssf/streaming/SXSSFCell.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/streaming/SXSSFCell.java?ref=bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/streaming/SXSSFCell.java",
                "patch": "@@ -248,7 +248,7 @@ public void setCellValue(String value)\n     {\n         ensureTypeOrFormulaType(CELL_TYPE_STRING);\n         \n-        if(value.length() > SpreadsheetVersion.EXCEL2007.getMaxTextLength()){\n+        if(value != null && value.length() > SpreadsheetVersion.EXCEL2007.getMaxTextLength()){\n             throw new IllegalArgumentException(\"The maximum length of cell contents (text) is 32,767 characters\");\n         }\n ",
                "raw_url": "https://github.com/apache/poi/raw/bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91/src/ooxml/java/org/apache/poi/xssf/streaming/SXSSFCell.java",
                "sha": "b0d35803ba696498667a9954551260f04114ef35",
                "status": "modified"
            },
            {
                "additions": 48,
                "blob_url": "https://github.com/apache/poi/blob/bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91/src/testcases/org/apache/poi/ss/usermodel/BaseTestBugzillaIssues.java",
                "changes": 54,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/usermodel/BaseTestBugzillaIssues.java?ref=bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91",
                "deletions": 6,
                "filename": "src/testcases/org/apache/poi/ss/usermodel/BaseTestBugzillaIssues.java",
                "patch": "@@ -32,6 +32,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.ss.ITestDataProvider;\n import org.apache.poi.ss.SpreadsheetVersion;\n import org.apache.poi.ss.util.CellRangeAddress;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n@@ -419,16 +420,16 @@ public void bug15353() {\n         Workbook wb = _testDataProvider.createWorkbook();\n         Sheet sheet = wb.createSheet(\"My sheet\");\n \n-        Row row = sheet.createRow( 0 );\n-        Cell cell = row.createCell( 0 );\n+        Row row = sheet.createRow(0);\n+        Cell cell = row.createCell(0);\n         cell.setCellFormula(hyperlinkF);\n         \n         assertEquals(hyperlinkF, cell.getCellFormula());\n \n         wb = _testDataProvider.writeOutAndReadBack(wb);\n         sheet = wb.getSheet(\"My Sheet\");\n-        row = sheet.getRow( 0 );\n-        cell = row.getCell( 0 );\n+        row = sheet.getRow(0);\n+        cell = row.getCell(0);\n         \n         assertEquals(hyperlinkF, cell.getCellFormula());\n     }\n@@ -691,7 +692,8 @@ private Cell evaluateCell(Workbook wb, Cell c) {\n      * TODO Fix this to evaluate for XSSF\n      * TODO Fix this to work at all for HSSF\n      */\n-//    @Test\n+    @Ignore(\"Fix this to evaluate for XSSF, Fix this to work at all for HSSF\")\n+    @Test\n     public void bug46670() throws Exception {\n         Workbook wb = _testDataProvider.createWorkbook();\n         Sheet s = wb.createSheet();\n@@ -730,7 +732,7 @@ public void bug46670() throws Exception {\n         assertEquals(refHttp,  c2.getCellFormula());\n \n         \n-        // Try to evalutate, without giving a way to get at the other file\n+        // Try to evaluate, without giving a way to get at the other file\n         try {\n             evaluateCell(wb, c1);\n             fail(\"Shouldn't be able to evaluate without the other file\");\n@@ -1003,4 +1005,44 @@ public void bug47815() {\n             fail();\n         } catch(IllegalStateException e) {}\n     }\n+    \n+    @Test\n+    public void test58113() {\n+        Workbook wb = _testDataProvider.createWorkbook();\n+        Sheet sheet = wb.createSheet( \"Test\" );\n+\n+        Row row = sheet.createRow(0);\n+\n+        Cell cell = row.createCell(0);\n+        // verify that null-values can be set, this was possible up to 3.11, but broken in 3.12 \n+        cell.setCellValue((String)null);\n+        String value = cell.getStringCellValue();\n+        assertTrue(\"HSSF will currently return empty string, XSSF/SXSSF will return null, but had: \" + value,\n+                value == null || value.length() == 0);\n+        \n+        cell = row.createCell(1);\n+        // also verify that setting formulas to null works  \n+        cell.setCellType(Cell.CELL_TYPE_FORMULA);\n+        cell.setCellValue((String)null);\n+        \n+        wb.getCreationHelper().createFormulaEvaluator().evaluateAll();\n+\n+        value = cell.getStringCellValue();\n+        assertTrue(\"HSSF will currently return empty string, XSSF/SXSSF will return null, but had: \" + value,\n+                value == null || value.length() == 0);\n+        \n+        // set some value\n+        cell.setCellType(Cell.CELL_TYPE_STRING);\n+        cell.setCellValue(\"somevalue\");\n+\n+        value = cell.getStringCellValue();\n+        assertTrue(\"can set value afterwards: \" + value,\n+                value.equals(\"somevalue\"));\n+\n+        // verify that the null-value is actually set even if there was some value in the cell before  \n+        cell.setCellValue((String)null);\n+        value = cell.getStringCellValue();\n+        assertTrue(\"HSSF will currently return empty string, XSSF/SXSSF will return null, but had: \" + value,\n+                value == null || value.length() == 0);\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/bae4602fa69a72c8d3e3ee4ecf354cf9a72f7e91/src/testcases/org/apache/poi/ss/usermodel/BaseTestBugzillaIssues.java",
                "sha": "9cbbac02d9f2d3004b78f9e071cd99f6bd36e811",
                "status": "modified"
            }
        ],
        "message": "Bug 58113: Fix regression: NullPointerException when setting cell value to null\nadd unit tests which verifies this for all three SS-implementations\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1690652 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1c69d7596cb247f4a786c0960369fd3c3631c918",
        "patched_files": [
            "SXSSFCell.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestSXSSFCell.java"
        ]
    },
    "poi_bd4852d": {
        "bug_id": "poi_bd4852d",
        "commit": "https://github.com/apache/poi/commit/bd4852d48bba8dc2036412ebf199a092eeac5f9a",
        "file": [
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 4,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java",
                "patch": "@@ -25,6 +25,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import org.apache.poi.POIDocument;\n import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.util.POILogger;\n+import org.apache.poi.util.POILogFactory;\n import org.apache.poi.poifs.filesystem.POIFSFileSystem;\n import org.apache.poi.poifs.filesystem.DocumentEntry;\n import org.apache.poi.poifs.filesystem.DocumentInputStream;\n@@ -50,6 +52,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n public class HSLFSlideShow extends POIDocument\n {\n+    // For logging\n+    protected POILogger logger = POILogFactory.getLogger(this.getClass());\n+\n \tprivate InputStream istream;\n \n \t// Holds metadata on where things are in our document\n@@ -226,7 +231,7 @@ private void readCurrentUserStream() {\n \t\ttry {\n \t\t\tcurrentUser = new CurrentUserAtom(filesystem);\n \t\t} catch(IOException ie) {\n-\t\t\tSystem.err.println(\"Error finding Current User Atom:\\n\" + ie);\n+\t\t\tlogger.log(POILogger.ERROR, \"Error finding Current User Atom:\\n\" + ie);\n \t\t\tcurrentUser = new CurrentUserAtom();\n \t\t}\n \t}\n@@ -281,8 +286,8 @@ private void readPictures() throws IOException {\n \n \t\t\t// If they type (including the bonus 0xF018) is 0, skip it\n \t\t\tif(type == 0) {\n-\t\t\t\tSystem.err.println(\"Problem reading picture: Invalid image type 0, on picture with length \" + imgsize + \".\\nYou document will probably become corrupted if you save it!\");\n-\t\t\t\tSystem.err.println(pos);\n+\t\t\t\tlogger.log(POILogger.ERROR, \"Problem reading picture: Invalid image type 0, on picture with length \" + imgsize + \".\\nYou document will probably become corrupted if you save it!\");\n+\t\t\t\tlogger.log(POILogger.ERROR, \"\" + pos);\n \t\t\t} else {\n \t            // Copy the data, ready to pass to PictureData\n \t            byte[] imgdata = new byte[imgsize];\n@@ -297,7 +302,7 @@ private void readPictures() throws IOException {\n \t\t\t\t\tpict.setOffset(offset);\n \t\t\t\t\tp.add(pict);\n \t\t\t\t} catch(IllegalArgumentException e) {\n-\t\t\t\t\tSystem.err.println(\"Problem reading picture: \" + e + \"\\nYou document will probably become corrupted if you save it!\");\n+\t\t\t\t\tlogger.log(POILogger.ERROR, \"Problem reading picture: \" + e + \"\\nYou document will probably become corrupted if you save it!\");\n \t\t\t\t}\n \t\t\t}\n             ",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/HSLFSlideShow.java",
                "sha": "84a03e7a52848c6c389731c1066d162e5484319c",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "changes": 19,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 7,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "patch": "@@ -21,6 +21,7 @@\n import org.apache.poi.hslf.usermodel.SlideShow;\n import org.apache.poi.hslf.record.Document;\n import org.apache.poi.hslf.blip.Bitmap;\n+import org.apache.poi.util.POILogger;\n \n import javax.imageio.ImageIO;\n import java.awt.image.BufferedImage;\n@@ -99,7 +100,7 @@ protected Picture(EscherContainerRecord escherRecord, Shape parent){\n     public int getPictureIndex(){\n         EscherOptRecord opt = (EscherOptRecord)getEscherChild(_escherContainer, EscherOptRecord.RECORD_ID);\n         EscherSimpleProperty prop = (EscherSimpleProperty)getEscherProperty(opt, EscherProperties.BLIP__BLIPTODISPLAY + 0x4000);\n-        return prop.getPropertyValue();\n+        return prop == null ? 0 : prop.getPropertyValue();\n     }\n \n     /**\n@@ -166,14 +167,18 @@ public PictureData getPictureData(){\n         EscherContainerRecord bstore = (EscherContainerRecord)Shape.getEscherChild(dggContainer, EscherContainerRecord.BSTORE_CONTAINER);\n \n         List lst = bstore.getChildRecords();\n-        int idx = getPictureIndex()-1;\n-        EscherBSERecord bse = (EscherBSERecord)lst.get(idx);\n-        for ( int i = 0; i < pict.length; i++ ) {\n-\t\t\tif (pict[i].getOffset() ==  bse.getOffset()){\n-                return pict[i];\n+        int idx = getPictureIndex();\n+        if (idx == 0){\n+            logger.log(POILogger.ERROR, \"no reference to picture data found \");\n+        } else {\n+            EscherBSERecord bse = (EscherBSERecord)lst.get(idx-1);\n+            for ( int i = 0; i < pict.length; i++ ) {\n+                if (pict[i].getOffset() ==  bse.getOffset()){\n+                    return pict[i];\n+                }\n             }\n+            logger.log(POILogger.ERROR, \"no picture found for our BSE offset \" + bse.getOffset());\n         }\n-\t\tSystem.err.println(\"Warning - no picture found for our BSE offset \" + bse.getOffset());\n         return null;\n     }\n ",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "sha": "d6f4887e2733a16a58f925cece7ea683584a1773",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/Shape.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Shape.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Shape.java",
                "patch": "@@ -19,6 +19,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.ddf.*;\n import org.apache.poi.hslf.model.ShapeTypes;\n import org.apache.poi.hslf.record.ColorSchemeAtom;\n+import org.apache.poi.util.POILogger;\n+import org.apache.poi.util.POILogFactory;\n \n import java.util.Iterator;\n import java.awt.*;\n@@ -41,6 +43,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  */\n public abstract class Shape {\n \n+    // For logging\n+    protected POILogger logger = POILogFactory.getLogger(this.getClass());\n+    \n     /**\n      * In Escher absolute distances are specified in\n      * English Metric Units (EMUs), occasionally referred to as A units;\n@@ -110,8 +115,7 @@ public Shape getParent(){\n      * @return name of the shape.\n      */\n     public String getShapeName(){\n-        EscherSpRecord spRecord = _escherContainer.getChildById(EscherSpRecord.RECORD_ID);\n-        return ShapeTypes.typeName(spRecord.getOptions() >> 4);\n+        return ShapeTypes.typeName(getShapeType());\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/Shape.java",
                "sha": "65827bf94d1afcc9d217d02340a636d15dac6f5a",
                "status": "modified"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java",
                "patch": "@@ -18,6 +18,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import org.apache.poi.ddf.*;\n import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.util.POILogger;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -69,7 +70,7 @@ protected ShapeGroup(EscherContainerRecord escherRecord, Shape parent){\n         \t} else {\n         \t\t// Should we do anything special with these non\n         \t\t//  Container records?\n-        \t\tSystem.err.println(\"Shape contained non container escher record, was \" + r.getClass().getName());\n+        \t\tlogger.log(POILogger.ERROR, \"Shape contained non container escher record, was \" + r.getClass().getName());\n         \t}\n         }\n         \n@@ -197,4 +198,17 @@ public void moveTo(int x, int y){\n         anchor.height = (spgr.getRectY2() - spgr.getRectY1())*POINT_DPI/MASTER_DPI;\n         return anchor;\n     }\n+\n+    /**\n+     * Return type of the shape.\n+     * In most cases shape group type is {@link org.apache.poi.hslf.model.ShapeTypes#NotPrimitive}\n+     *\n+     * @return type of the shape.\n+     */\n+    public int getShapeType(){\n+        EscherContainerRecord groupInfoContainer = (EscherContainerRecord)_escherContainer.getChild(0);\n+        EscherSpRecord spRecord = groupInfoContainer.getChildById(EscherSpRecord.RECORD_ID);\n+        return spRecord.getOptions() >> 4;\n+    }\n+\n }",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java",
                "sha": "d474a22f6f926585568975e1f78b6e4b910826e5",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java",
                "patch": "@@ -22,6 +22,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.hslf.record.*;\n import org.apache.poi.hslf.usermodel.RichTextRun;\n import org.apache.poi.hslf.exceptions.HSLFException;\n+import org.apache.poi.util.POILogger;\n \n import java.awt.*;\n import java.awt.font.FontRenderContext;\n@@ -500,7 +501,7 @@ private void initTextRun(){\n         \t_txtrun = new TextRun(tha,tca,sta);\n         } else {\n         \t// Empty text box\n-        \tSystem.err.println(\"Warning - no text records found for TextBox\");\n+        \tlogger.log(POILogger.WARN, \"no text records found for TextBox\");\n         }\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/src/org/apache/poi/hslf/model/TextBox.java",
                "sha": "82d9a4de7f369f56ceaa333ac8158368e206be88",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/testcases/org/apache/poi/hslf/data/42520.ppt",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/data/42520.ppt?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/data/42520.ppt",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/testcases/org/apache/poi/hslf/data/42520.ppt",
                "sha": "15bcf64106367b2c736d53a27bd1b116acfb73ec",
                "status": "added"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/testcases/org/apache/poi/hslf/model/TestSheet.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestSheet.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 1,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestSheet.java",
                "patch": "@@ -71,6 +71,8 @@ private void doSlideShow(SlideShow ppt) throws Exception {\n     }\r\n \r\n     private void verify(Sheet sheet){\r\n+        assertNotNull(sheet.getSlideShow());\r\n+\r\n         ColorSchemeAtom colorscheme = sheet.getColorScheme();\r\n         assertNotNull(colorscheme);\r\n \r\n@@ -92,9 +94,11 @@ private void verify(Sheet sheet){\n         Shape[] shape = sheet.getShapes();\r\n         assertTrue(shape != null);\r\n         for (int i = 0; i < shape.length; i++) {\r\n+            assertNotNull(shape[i].getSpContainer());\r\n             assertNotNull(shape[i].getSheet());\r\n+            assertNotNull(shape[i].getShapeName());\r\n+            assertNotNull(shape[i].getAnchor());\r\n         }\r\n \r\n-        assertNotNull(sheet.getSlideShow());\r\n     }\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/testcases/org/apache/poi/hslf/model/TestSheet.java",
                "sha": "be22db0d54e8a62ba88630976e66182c596bc733",
                "status": "modified"
            },
            {
                "additions": 68,
                "blob_url": "https://github.com/apache/poi/blob/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java?ref=bd4852d48bba8dc2036412ebf199a092eeac5f9a",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "patch": "@@ -20,10 +20,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.TestCase;\r\n import org.apache.poi.hslf.HSLFSlideShow;\r\n import org.apache.poi.hslf.model.*;\r\n+import org.apache.poi.hslf.model.Shape;\r\n \r\n import java.io.*;\r\n import java.util.HashSet;\r\n import java.util.HashMap;\r\n+import java.awt.*;\r\n \r\n /**\r\n  * Testcases for bugs entered in bugzilla\r\n@@ -201,4 +203,70 @@ public void test42486 () throws Exception {\n \r\n     }\r\n \r\n+    /**\r\n+     * Bug 42524:  NPE in Shape.getShapeType()\r\n+     */\r\n+    public void test42524 () throws Exception {\r\n+        FileInputStream is = new FileInputStream(new File(cwd, \"42486.ppt\")); //test file is the same as for Bug 42486\r\n+        HSLFSlideShow hslf = new HSLFSlideShow(is);\r\n+        is.close();\r\n+\r\n+        SlideShow ppt = new SlideShow(hslf);\r\n+        //walk down the tree and see if there were no errors while reading\r\n+        Slide[] slide = ppt.getSlides();\r\n+        for (int i = 0; i < slide.length; i++) {\r\n+            Shape[] shape = slide[i].getShapes();\r\n+            for (int j = 0; j < shape.length; j++) {\r\n+                assertNotNull(shape[j].getShapeName());\r\n+                if (shape[j] instanceof ShapeGroup){\r\n+                    ShapeGroup group = (ShapeGroup)shape[j];\r\n+                    Shape[] comps = group.getShapes();\r\n+                    for (int k = 0; k < comps.length; k++) {\r\n+                        assertNotNull(comps[k].getShapeName());\r\n+                   }\r\n+                }\r\n+            }\r\n+\r\n+        }\r\n+        assertTrue(\"No Exceptions while reading file\", true);\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Bug 42520:  NPE in Picture.getPictureData()\r\n+     */\r\n+    public void test42520 () throws Exception {\r\n+        FileInputStream is = new FileInputStream(new File(cwd, \"42520.ppt\")); //test file is the same as for Bug 42486\r\n+        HSLFSlideShow hslf = new HSLFSlideShow(is);\r\n+        is.close();\r\n+\r\n+        SlideShow ppt = new SlideShow(hslf);\r\n+\r\n+        //test case from the bug report\r\n+        ShapeGroup shapeGroup = (ShapeGroup)ppt.getSlides()[11].getShapes()[10];\r\n+        Picture picture = (Picture)shapeGroup.getShapes()[0];\r\n+        picture.getPictureData();\r\n+\r\n+        //walk down the tree and see if there were no errors while reading\r\n+        Slide[] slide = ppt.getSlides();\r\n+        for (int i = 0; i < slide.length; i++) {\r\n+            Shape[] shape = slide[i].getShapes();\r\n+            for (int j = 0; j < shape.length; j++) {\r\n+              if (shape[j] instanceof ShapeGroup){\r\n+                    ShapeGroup group = (ShapeGroup)shape[j];\r\n+                    Shape[] comps = group.getShapes();\r\n+                    for (int k = 0; k < comps.length; k++) {\r\n+                        Shape comp = comps[k];\r\n+                        if (comp instanceof Picture){\r\n+                            PictureData pict = ((Picture)comp).getPictureData();\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+        }\r\n+        assertTrue(\"No Exceptions while reading file\", true);\r\n+\r\n+    }\r\n+\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/bd4852d48bba8dc2036412ebf199a092eeac5f9a/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "sha": "800194e585746fc994d72b6df30d8ad999f26d8b",
                "status": "modified"
            }
        ],
        "message": "fixed bug 42520: NPE in Picture.getPictureData() and bug 42524:  NPE in Shape.getShapeType(); Also changed the code to write messages to POILogger instead of System.err/System.out\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@541867 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/98d43d24f8d554e55894f3cc2090cade68af3b29",
        "patched_files": [
            "42520.java",
            "Shape.java",
            "Sheet.java",
            "ShapeGroup.java",
            "Picture.java",
            "HSLFSlideShow.java",
            "TextBox.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestPicture.java",
            "TestShapeGroup.java",
            "TestBugs.java",
            "TestSheet.java",
            "TestHSLFSlideShow.java"
        ]
    },
    "poi_bf4396b": {
        "bug_id": "poi_bf4396b",
        "commit": "https://github.com/apache/poi/commit/bf4396b37591f9a4172a3a247ea6f8634ac82681",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/bf4396b37591f9a4172a3a247ea6f8634ac82681/src/java/org/apache/poi/hssf/record/common/UnicodeString.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/common/UnicodeString.java?ref=bf4396b37591f9a4172a3a247ea6f8634ac82681",
                "deletions": 6,
                "filename": "src/java/org/apache/poi/hssf/record/common/UnicodeString.java",
                "patch": "@@ -44,8 +44,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * REFERENCE:  PG 951 Excel Binary File Format (.xls) Structure Specification v20091214 \n  */\n public class UnicodeString implements Comparable<UnicodeString> {\n-    // TODO - make this final when the compatibility version is removed\n-    private static POILogger _logger = POILogFactory.getLogger(UnicodeString.class);\n+    private static final POILogger _logger = POILogFactory.getLogger(UnicodeString.class);\n \n     //arbitrarily selected; may need to increase\n     private static final int MAX_RECORD_LENGTH = 100_000;\n@@ -673,9 +672,11 @@ void setExtendedRst(ExtRst ext_rst) {\n      *  removed / re-ordered\n      */\n     public void swapFontUse(short oldFontIndex, short newFontIndex) {\n-        for (FormatRun run : field_4_format_runs) {\n-            if(run._fontIndex == oldFontIndex) {\n-                run._fontIndex = newFontIndex;\n+        if (field_4_format_runs != null) {\n+            for (FormatRun run : field_4_format_runs) {\n+                if(run._fontIndex == oldFontIndex) {\n+                    run._fontIndex = newFontIndex;\n+                }\n             }\n         }\n     }\n@@ -700,7 +701,7 @@ public String toString()\n      */\n     public String getDebugInfo()\n     {\n-        StringBuffer buffer = new StringBuffer();\n+        StringBuilder buffer = new StringBuilder();\n \n         buffer.append(\"[UNICODESTRING]\\n\");\n         buffer.append(\"    .charcount       = \")",
                "raw_url": "https://github.com/apache/poi/raw/bf4396b37591f9a4172a3a247ea6f8634ac82681/src/java/org/apache/poi/hssf/record/common/UnicodeString.java",
                "sha": "ef4016e598020f337dcad5c0cee03b639ac16bdf",
                "status": "modified"
            },
            {
                "additions": 37,
                "blob_url": "https://github.com/apache/poi/blob/bf4396b37591f9a4172a3a247ea6f8634ac82681/src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java",
                "changes": 47,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java?ref=bf4396b37591f9a4172a3a247ea6f8634ac82681",
                "deletions": 10,
                "filename": "src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java",
                "patch": "@@ -21,13 +21,20 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n \n import org.apache.poi.hssf.record.ContinueRecord;\n import org.apache.poi.hssf.record.RecordInputStream;\n import org.apache.poi.hssf.record.SSTRecord;\n import org.apache.poi.hssf.record.common.UnicodeString.ExtRst;\n import org.apache.poi.hssf.record.common.UnicodeString.FormatRun;\n import org.apache.poi.hssf.record.cont.ContinuableRecordOutput;\n+import org.apache.poi.hssf.usermodel.HSSFOptimiser;\n+import org.apache.poi.hssf.usermodel.HSSFWorkbook;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.CellStyle;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Sheet;\n import org.apache.poi.util.LittleEndianByteArrayInputStream;\n import org.apache.poi.util.LittleEndianByteArrayOutputStream;\n import org.apache.poi.util.LittleEndianConsts;\n@@ -344,26 +351,46 @@ public void extRstEqualsAndHashCode() {\n         assertEquals(extRst1.hashCode(), extRst2.hashCode());\n     }\n \n+    @Test\n+    public void unicodeStringsNullPointer() throws IOException {\n+        HSSFWorkbook wb = new HSSFWorkbook();\n+\n+        Sheet sheet = wb.createSheet(\"styles\");\n+        Row row = sheet.createRow(0);\n+        Cell cell = row.createCell(0);\n+\n+        CellStyle style = wb.createCellStyle();\n+        style.setFont(wb.createFont());\n+        cell.setCellStyle(style);\n+\n+        cell.setCellValue(\"test\");\n+\n+        HSSFOptimiser.optimiseFonts(wb);\n+\n+        wb.close();\n+    }\n+\n     private static UnicodeString makeUnicodeString(String s) {\n-      UnicodeString st = new UnicodeString(s);\n-      st.setOptionFlags((byte)0);\n-      return st;\n+        UnicodeString st = new UnicodeString(s);\n+        st.setOptionFlags((byte)0);\n+        return st;\n     }\n \n     private static UnicodeString makeUnicodeString(int numChars) {\n         return makeUnicodeString(numChars, false);\n     }\n+\n     /**\n      * @param is16Bit if <code>true</code> the created string will have characters > 0x00FF\n      * @return a string of the specified number of characters\n      */\n     private static UnicodeString makeUnicodeString(int numChars, boolean is16Bit) {\n-      StringBuffer b = new StringBuffer(numChars);\n-      int charBase = is16Bit ? 0x8A00 : 'A';\n-      for (int i=0;i<numChars;i++) {\n-        char ch = (char) ((i%16)+charBase);\n-        b.append(ch);\n-      }\n-      return makeUnicodeString(b.toString());\n+        StringBuilder b = new StringBuilder(numChars);\n+        int charBase = is16Bit ? 0x8A00 : 'A';\n+        for (int i = 0; i < numChars; i++) {\n+            char ch = (char) ((i % 16) + charBase);\n+            b.append(ch);\n+        }\n+        return makeUnicodeString(b.toString());\n     }\n }",
                "raw_url": "https://github.com/apache/poi/raw/bf4396b37591f9a4172a3a247ea6f8634ac82681/src/testcases/org/apache/poi/hssf/record/common/TestUnicodeString.java",
                "sha": "e9373049d42f02c300d77f2967747008cba58c7f",
                "status": "modified"
            }
        ],
        "message": "[bug-63151] handle NPE in UnicodeString\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1853859 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/37ff2b7fb24114750383cf4c5d0fa56f3e1a7aba",
        "patched_files": [
            "UnicodeString.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestUnicodeString.java"
        ]
    },
    "poi_c18b724": {
        "bug_id": "poi_c18b724",
        "commit": "https://github.com/apache/poi/commit/c18b7245e9bc78e3df2991ec7d6b4990a71ce500",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/c18b7245e9bc78e3df2991ec7d6b4990a71ce500/src/testcases/org/apache/poi/util/TestIOUtils.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/util/TestIOUtils.java?ref=c18b7245e9bc78e3df2991ec7d6b4990a71ce500",
                "deletions": 1,
                "filename": "src/testcases/org/apache/poi/util/TestIOUtils.java",
                "patch": "@@ -60,7 +60,7 @@ public static void setUp() throws IOException {\n \n     @AfterClass\n     public static void tearDown() {\n-        assertTrue(TMP.delete());\n+        if (TMP != null) assertTrue(TMP.delete());\n     }\n \n     @Test",
                "raw_url": "https://github.com/apache/poi/raw/c18b7245e9bc78e3df2991ec7d6b4990a71ce500/src/testcases/org/apache/poi/util/TestIOUtils.java",
                "sha": "a8e9bbfa373ebc2df05218d37f24ab1c0ec5b700",
                "status": "modified"
            }
        ],
        "message": "possible npe in test\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1855969 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/92232b921a9b797da1cbfd59f0c7f2dcc7bd9604",
        "patched_files": [
            "IOUtils.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestIOUtils.java"
        ]
    },
    "poi_c1c954d": {
        "bug_id": "poi_c1c954d",
        "commit": "https://github.com/apache/poi/commit/c1c954d14e190574c51b9106dd16a3d30d53e396",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/c1c954d14e190574c51b9106dd16a3d30d53e396/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=c1c954d14e190574c51b9106dd16a3d30d53e396",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.7-SNAPSHOT\" date=\"2010-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">49386 - avoid NPE when extracting OOXML file properties which are dates</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">49377 - only call DecimalFormat.setRoundingMode on Java 1.6 - it's needed to match excel's rendering of numbers</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">49378 - correct 1.6ism</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">Parse the HSMF headers chunk if present, and use it to find Dates in text extraction if needed</action>",
                "raw_url": "https://github.com/apache/poi/raw/c1c954d14e190574c51b9106dd16a3d30d53e396/src/documentation/content/xdocs/status.xml",
                "sha": "c29e9f9ee48ad3849876502cc5f43def176b3baf",
                "status": "modified"
            },
            {
                "additions": 55,
                "blob_url": "https://github.com/apache/poi/blob/c1c954d14e190574c51b9106dd16a3d30d53e396/src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java",
                "changes": 89,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java?ref=c1c954d14e190574c51b9106dd16a3d30d53e396",
                "deletions": 34,
                "filename": "src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java",
                "patch": "@@ -20,6 +20,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import org.apache.poi.openxml4j.opc.internal.PackagePropertiesPart;\n import org.openxmlformats.schemas.officeDocument.x2006.customProperties.CTProperty;\n \n+import java.util.Date;\n+\n /**\n  * A {@link POITextExtractor} for returning the textual\n  *  content of the OOXML file properties, eg author\n@@ -41,6 +43,24 @@ public POIXMLPropertiesTextExtractor(POIXMLDocument doc) {\n \tpublic POIXMLPropertiesTextExtractor(POIXMLTextExtractor otherExtractor) {\n \t\tsuper(otherExtractor.getDocument());\n \t}\n+\t\n+   private void appendIfPresent(StringBuffer text, String thing, boolean value) {\n+      appendIfPresent(text, thing, Boolean.toString(value));\n+   }\n+   private void appendIfPresent(StringBuffer text, String thing, int value) {\n+      appendIfPresent(text, thing, Integer.toString(value));\n+   }\n+   private void appendIfPresent(StringBuffer text, String thing, Date value) {\n+      if(value == null) { return; }\n+      appendIfPresent(text, thing, value.toString());\n+   }\n+\tprivate void appendIfPresent(StringBuffer text, String thing, String value) {\n+\t   if(value == null) { return; }\n+\t   text.append(thing);\n+\t   text.append(\" = \");\n+\t   text.append(value);\n+\t   text.append(\"\\n\");\n+\t}\n \n \t/**\n \t * Returns the core document properties, eg author\n@@ -50,25 +70,26 @@ public String getCorePropertiesText() {\n \t\tPackagePropertiesPart props =\n \t\t\tgetDocument().getProperties().getCoreProperties().getUnderlyingProperties();\n \n-\t\ttext.append(\"Category = \" + props.getCategoryProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"ContentStatus = \" + props.getContentStatusProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"ContentType = \" + props.getContentTypeProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Created = \" + props.getCreatedProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"CreatedString = \" + props.getCreatedPropertyString() + \"\\n\");\n-\t\ttext.append(\"Creator = \" + props.getCreatorProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Description = \" + props.getDescriptionProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Identifier = \" + props.getIdentifierProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Keywords = \" + props.getKeywordsProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Language = \" + props.getLanguageProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"LastModifiedBy = \" + props.getLastModifiedByProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"LastPrinted = \" + props.getLastPrintedProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"LastPrintedString = \" + props.getLastPrintedPropertyString() + \"\\n\");\n-\t\ttext.append(\"Modified = \" + props.getModifiedProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"ModifiedString = \" + props.getModifiedPropertyString() + \"\\n\");\n-\t\ttext.append(\"Revision = \" + props.getRevisionProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Subject = \" + props.getSubjectProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Title = \" + props.getTitleProperty().getValue() + \"\\n\");\n-\t\ttext.append(\"Version = \" + props.getVersionProperty().getValue() + \"\\n\");\n+\t\tappendIfPresent(text, \"Category\", props.getCategoryProperty().getValue());\n+\t\tappendIfPresent(text, \"Category\", props.getCategoryProperty().getValue());\n+\t\tappendIfPresent(text, \"ContentStatus\", props.getContentStatusProperty().getValue());\n+\t\tappendIfPresent(text, \"ContentType\", props.getContentTypeProperty().getValue());\n+\t\tappendIfPresent(text, \"Created\", props.getCreatedProperty().getValue());\n+\t\tappendIfPresent(text, \"CreatedString\", props.getCreatedPropertyString());\n+\t\tappendIfPresent(text, \"Creator\", props.getCreatorProperty().getValue());\n+\t\tappendIfPresent(text, \"Description\", props.getDescriptionProperty().getValue());\n+\t\tappendIfPresent(text, \"Identifier\", props.getIdentifierProperty().getValue());\n+\t\tappendIfPresent(text, \"Keywords\", props.getKeywordsProperty().getValue());\n+\t\tappendIfPresent(text, \"Language\", props.getLanguageProperty().getValue());\n+\t\tappendIfPresent(text, \"LastModifiedBy\", props.getLastModifiedByProperty().getValue());\n+\t\tappendIfPresent(text, \"LastPrinted\", props.getLastPrintedProperty().getValue());\n+\t\tappendIfPresent(text, \"LastPrintedString\", props.getLastPrintedPropertyString());\n+\t\tappendIfPresent(text, \"Modified\", props.getModifiedProperty().getValue());\n+\t\tappendIfPresent(text, \"ModifiedString\", props.getModifiedPropertyString());\n+\t\tappendIfPresent(text, \"Revision\", props.getRevisionProperty().getValue());\n+\t\tappendIfPresent(text, \"Subject\", props.getSubjectProperty().getValue());\n+\t\tappendIfPresent(text, \"Title\", props.getTitleProperty().getValue());\n+\t\tappendIfPresent(text, \"Version\", props.getVersionProperty().getValue());\n \n \t\treturn text.toString();\n \t}\n@@ -81,21 +102,21 @@ public String getExtendedPropertiesText() {\n \t\torg.openxmlformats.schemas.officeDocument.x2006.extendedProperties.CTProperties\n \t\t\tprops = getDocument().getProperties().getExtendedProperties().getUnderlyingProperties();\n \n-\t\ttext.append(\"Application = \" + props.getApplication() + \"\\n\");\n-\t\ttext.append(\"AppVersion = \" + props.getAppVersion() + \"\\n\");\n-\t\ttext.append(\"Characters = \" + props.getCharacters() + \"\\n\");\n-\t\ttext.append(\"CharactersWithSpaces = \" + props.getCharactersWithSpaces() + \"\\n\");\n-\t\ttext.append(\"Company = \" + props.getCompany() + \"\\n\");\n-\t\ttext.append(\"HyperlinkBase = \" + props.getHyperlinkBase() + \"\\n\");\n-\t\ttext.append(\"HyperlinksChanged = \" + props.getHyperlinksChanged() + \"\\n\");\n-\t\ttext.append(\"Lines = \" + props.getLines() + \"\\n\");\n-\t\ttext.append(\"LinksUpToDate = \" + props.getLinksUpToDate() + \"\\n\");\n-\t\ttext.append(\"Manager = \" + props.getManager() + \"\\n\");\n-\t\ttext.append(\"Pages = \" + props.getPages() + \"\\n\");\n-\t\ttext.append(\"Paragraphs = \" + props.getParagraphs() + \"\\n\");\n-\t\ttext.append(\"PresentationFormat = \" + props.getPresentationFormat() + \"\\n\");\n-\t\ttext.append(\"Template = \" + props.getTemplate() + \"\\n\");\n-\t\ttext.append(\"TotalTime = \" + props.getTotalTime() + \"\\n\");\n+\t\tappendIfPresent(text, \"Application\", props.getApplication());\n+\t\tappendIfPresent(text, \"AppVersion\", props.getAppVersion());\n+\t\tappendIfPresent(text, \"Characters\", props.getCharacters());\n+\t\tappendIfPresent(text, \"CharactersWithSpaces\", props.getCharactersWithSpaces());\n+\t\tappendIfPresent(text, \"Company\", props.getCompany());\n+\t\tappendIfPresent(text, \"HyperlinkBase\", props.getHyperlinkBase());\n+\t\tappendIfPresent(text, \"HyperlinksChanged\", props.getHyperlinksChanged());\n+\t\tappendIfPresent(text, \"Lines\", props.getLines());\n+\t\tappendIfPresent(text, \"LinksUpToDate\", props.getLinksUpToDate());\n+\t\tappendIfPresent(text, \"Manager\", props.getManager());\n+\t\tappendIfPresent(text, \"Pages\", props.getPages());\n+\t\tappendIfPresent(text, \"Paragraphs\", props.getParagraphs());\n+\t\tappendIfPresent(text, \"PresentationFormat\", props.getPresentationFormat());\n+\t\tappendIfPresent(text, \"Template\", props.getTemplate());\n+\t\tappendIfPresent(text, \"TotalTime\", props.getTotalTime());\n \n \t\treturn text.toString();\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/c1c954d14e190574c51b9106dd16a3d30d53e396/src/ooxml/java/org/apache/poi/POIXMLPropertiesTextExtractor.java",
                "sha": "6d313405572e96071b38eed414c2d63869baa320",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/c1c954d14e190574c51b9106dd16a3d30d53e396/src/ooxml/java/org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java?ref=c1c954d14e190574c51b9106dd16a3d30d53e396",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java",
                "patch": "@@ -583,10 +583,15 @@ private String getDateValue(Nullable<Date> d) {\n \t\tif (d == null) {\n \t\t\treturn \"\";\n \t\t}\n+\t\tDate date = d.getValue();\n+\t\tif (date == null) {\n+\t\t   return \"\";\n+\t\t}\n+\t\t\n \t\tSimpleDateFormat df = new SimpleDateFormat(\n \t\t\t\t\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n-        df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-\t\treturn df.format(d.getValue());\n+\t\tdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+\t\treturn df.format(date);\n \t}\n \n \t@Override",
                "raw_url": "https://github.com/apache/poi/raw/c1c954d14e190574c51b9106dd16a3d30d53e396/src/ooxml/java/org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java",
                "sha": "af40d361aa699b60c2a0165f33e448f6aeadce04",
                "status": "modified"
            },
            {
                "additions": 24,
                "blob_url": "https://github.com/apache/poi/blob/c1c954d14e190574c51b9106dd16a3d30d53e396/src/ooxml/testcases/org/apache/poi/TestXMLPropertiesTextExtractor.java",
                "changes": 29,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/TestXMLPropertiesTextExtractor.java?ref=c1c954d14e190574c51b9106dd16a3d30d53e396",
                "deletions": 5,
                "filename": "src/ooxml/testcases/org/apache/poi/TestXMLPropertiesTextExtractor.java",
                "patch": "@@ -16,17 +16,17 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi;\n \n-import java.io.File;\n+import junit.framework.TestCase;\n \n-import org.apache.poi.xssf.extractor.XSSFExcelExtractor;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n import org.apache.poi.openxml4j.opc.OPCPackage;\n import org.apache.poi.util.PackageHelper;\n-\n-import junit.framework.TestCase;\n+import org.apache.poi.xslf.XSLFSlideShow;\n+import org.apache.poi.xssf.extractor.XSSFExcelExtractor;\n+import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n \n public final class TestXMLPropertiesTextExtractor extends TestCase {\n     private static final POIDataSamples _ssSamples = POIDataSamples.getSpreadSheetInstance();\n+    private static final POIDataSamples _slSamples = POIDataSamples.getSlideShowInstance();\n \n \tpublic void testGetFromMainExtractor() throws Exception {\n \t\tOPCPackage pkg = PackageHelper.open(_ssSamples.openResourceAsStream(\"ExcelWithAttachments.xlsm\"));\n@@ -87,4 +87,23 @@ public void testExtended() throws Exception {\n \tpublic void testCustom() {\n \t\t// TODO!\n \t}\n+\t\n+\t/**\n+\t * Bug #49386 - some properties, especially\n+\t *  dates can be null\n+\t */\n+\tpublic void testWithSomeNulls() throws Exception {\n+      OPCPackage pkg = OPCPackage.open(\n+            _slSamples.openResourceAsStream(\"49386-null_dates.pptx\")\n+      );\n+      XSLFSlideShow sl = new XSLFSlideShow(pkg);\n+   \n+      POIXMLPropertiesTextExtractor ext = new POIXMLPropertiesTextExtractor(sl);\n+      ext.getText();\n+      \n+      String text = ext.getText();\n+      assertFalse(text.contains(\"Created =\")); // With date is null\n+      assertTrue(text.contains(\"CreatedString = \")); // Via string is blank\n+      assertTrue(text.contains(\"LastModifiedBy = IT Client Services\"));\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/c1c954d14e190574c51b9106dd16a3d30d53e396/src/ooxml/testcases/org/apache/poi/TestXMLPropertiesTextExtractor.java",
                "sha": "b19477f04cec7c617466ef82d5a94b3aa6a8d7e1",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/c1c954d14e190574c51b9106dd16a3d30d53e396/test-data/slideshow/49386-null_dates.pptx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/slideshow/49386-null_dates.pptx?ref=c1c954d14e190574c51b9106dd16a3d30d53e396",
                "deletions": 0,
                "filename": "test-data/slideshow/49386-null_dates.pptx",
                "raw_url": "https://github.com/apache/poi/raw/c1c954d14e190574c51b9106dd16a3d30d53e396/test-data/slideshow/49386-null_dates.pptx",
                "sha": "77fc378ce9fb2237c1cecf5c1649c6ad51afef4e",
                "status": "added"
            }
        ],
        "message": "Fix bug #49386 - avoid NPE when extracting OOXML file properties which are dates\nAlso tidy up POIXMLPropertiesTextExtractor to exclude properties which are missing\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@951384 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/bf86a2f7bf70941fa8c47540a46edbe71ca2bfcb",
        "patched_files": [
            "PackagePropertiesPart.java",
            "POIXMLPropertiesTextExtractor.java",
            "status.java",
            "49386-null_dates.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXMLPropertiesTextExtractor.java"
        ]
    },
    "poi_c233d8d": {
        "bug_id": "poi_c233d8d",
        "commit": "https://github.com/apache/poi/commit/c233d8db798fdc756d1091f3132e9ccb147bd28c",
        "file": [
            {
                "additions": 88,
                "blob_url": "https://github.com/apache/poi/blob/c233d8db798fdc756d1091f3132e9ccb147bd28c/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "changes": 90,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java?ref=c233d8db798fdc756d1091f3132e9ccb147bd28c",
                "deletions": 2,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "patch": "@@ -20,19 +20,21 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n-\n import org.apache.poi.POIXMLDocumentPart;\n import org.apache.poi.util.Internal;\n import org.apache.poi.wp.usermodel.Paragraph;\n import org.apache.xmlbeans.XmlCursor;\n import org.apache.xmlbeans.XmlObject;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBorder;\n+import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDecimalNumber;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFtnEdnRef;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHyperlink;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTJc;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLvl;\n+import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTNum;\n+import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTNumLvl;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTOnOff;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP;\n import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr;\n@@ -284,13 +286,97 @@ public String getNumFmt() {\n                         break;\n                     }\n                 }\n-                if(level != null)\n+                if(level != null && level.getNumFmt() != null\n+                    && level.getNumFmt().getVal() != null)\n                     return level.getNumFmt().getVal().toString();\n             }\n         }\n         return null;\n     }\n \n+    /**\n+     * Returns the text that should be used around the paragraph level numbers.\n+     *\n+     * @return a string (e.g. \"%1.\") or null if the value is not found.\n+     */\n+    public String getNumLevelText() {\n+        BigInteger numID = getNumID();\n+        XWPFNumbering numbering = document.getNumbering();\n+        if(numID != null && numbering != null) {\n+            XWPFNum num = numbering.getNum(numID);\n+            if(num != null) {\n+                BigInteger ilvl = getNumIlvl();\n+                CTNum ctNum = num.getCTNum();\n+                if (ctNum == null)\n+                    return null;\n+\n+                CTDecimalNumber ctDecimalNumber = ctNum.getAbstractNumId();\n+                if (ctDecimalNumber == null)\n+                    return null;\n+\n+                BigInteger abstractNumId = ctDecimalNumber.getVal();\n+                if (abstractNumId == null)\n+                    return null;\n+\n+                XWPFAbstractNum xwpfAbstractNum = numbering.getAbstractNum(abstractNumId);\n+\n+                if (xwpfAbstractNum == null)\n+                    return null;\n+\n+                CTAbstractNum anum = xwpfAbstractNum.getCTAbstractNum();\n+\n+                if (anum == null)\n+                    return null;\n+\n+                CTLvl level = null;\n+                for(int i = 0; i < anum.sizeOfLvlArray(); i++) {\n+                    CTLvl lvl = anum.getLvlArray(i);\n+                    if(lvl != null && lvl.getIlvl() != null && lvl.getIlvl().equals(ilvl)) {\n+                        level = lvl;\n+                        break;\n+                    }\n+                }\n+                if(level != null && level.getLvlText() != null\n+                    && level.getLvlText().getVal() != null)\n+                    return level.getLvlText().getVal().toString();\n+            }\n+        }\n+        return null;\n+    }\n+\n+\n+    /**\n+     * Gets the numstartOverride for the paragraph numbering for this paragraph.\n+     * @return returns the overridden start number or null if there is no override for this paragraph.\n+     */\n+    public BigInteger getNumStartOverride() {\n+        BigInteger numID = getNumID();\n+        XWPFNumbering numbering = document.getNumbering();\n+        if(numID != null && numbering != null) {\n+            XWPFNum num = numbering.getNum(numID);\n+\n+            if(num != null) {\n+                CTNum ctNum = num.getCTNum();\n+                if (ctNum == null) {\n+                    return null;\n+                }\n+                BigInteger ilvl = getNumIlvl();\n+                CTNumLvl level = null;\n+                for(int i = 0; i < ctNum.sizeOfLvlOverrideArray(); i++) {\n+                    CTNumLvl ctNumLvl = ctNum.getLvlOverrideArray(i);\n+                    if(ctNumLvl != null && ctNumLvl.getIlvl() != null &&\n+                        ctNumLvl.getIlvl().equals(ilvl)) {\n+                        level = ctNumLvl;\n+                        break;\n+                    }\n+                }\n+                if(level != null && level.getStartOverride() != null) {\n+                    return level.getStartOverride().getVal();\n+                }\n+            }\n+        }\n+        return null;\n+    }\n     /**\n      * setNumID of Paragraph\n      * @param numPos",
                "raw_url": "https://github.com/apache/poi/raw/c233d8db798fdc756d1091f3132e9ccb147bd28c/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFParagraph.java",
                "sha": "bc0ddf85a02e72c2fca51791f8a929d78e207249",
                "status": "modified"
            },
            {
                "additions": 33,
                "blob_url": "https://github.com/apache/poi/blob/c233d8db798fdc756d1091f3132e9ccb147bd28c/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFNumbering.java",
                "changes": 34,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFNumbering.java?ref=c233d8db798fdc756d1091f3132e9ccb147bd28c",
                "deletions": 1,
                "filename": "src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFNumbering.java",
                "patch": "@@ -26,7 +26,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n public class TestXWPFNumbering extends TestCase {\n \t\n-\tpublic void testCompareAbstractNum() throws IOException{\n+\tpublic void testCompareAbstractNum() throws IOException {\n \t\tXWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Numbering.docx\");\n \t\tXWPFNumbering numbering = doc.getNumbering();\n \t\tBigInteger numId = BigInteger.valueOf(1);\n@@ -74,4 +74,36 @@ public void testGetNumFmt() throws IOException{\n \t\tassertEquals(\"lowerLetter\", doc.getParagraphs().get(5).getNumFmt());\n \t\tassertEquals(\"lowerRoman\", doc.getParagraphs().get(6).getNumFmt());\n   }\n+\n+\tpublic void testLvlText() throws IOException {\n+\t\tXWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Numbering.docx\");\n+\n+\t\tassertEquals(\"%1.%2.%3.\", doc.getParagraphs().get(12).getNumLevelText());\n+\n+\t\tassertEquals(\"NEW-%1-FORMAT\", doc.getParagraphs().get(14).getNumLevelText());\n+\n+\t\tXWPFParagraph p = doc.getParagraphs().get(18);\n+\t\tassertEquals(\"%1.\", p.getNumLevelText());\n+\t\t//test that null doesn't throw NPE\n+\t\tassertNull(p.getNumFmt());\n+\t}\n+\n+\tpublic void testOverrideList() throws IOException {\n+\t\t//TODO: for now the try/catch block ensures loading/inclusion of CTNumLevel\n+\t\t//for down stream processing.\n+\t\t//Ideally, we should find files that actually use overrides and test against those.\n+\t\t//Use XWPFParagraph's getNumStartOverride() in the actual tests\n+\n+\t\tXWPFDocument doc = XWPFTestDataSamples.openSampleDocument(\"Numbering.docx\");\n+\t\tXWPFParagraph p = doc.getParagraphs().get(18);XWPFNumbering numbering = doc.getNumbering();\n+\t\tboolean ex = false;\n+\t\tassertNull(p.getNumStartOverride());\n+\t\ttry {\n+\t\t\tnumbering.getNum(p.getNumID()).getCTNum().getLvlOverrideArray(1);\n+\t\t} catch (IndexOutOfBoundsException e) {\n+\t\t\tex = true;\n+\t\t}\n+\t\tassertTrue(ex);\n+\t}\n+\n }",
                "raw_url": "https://github.com/apache/poi/raw/c233d8db798fdc756d1091f3132e9ccb147bd28c/src/ooxml/testcases/org/apache/poi/xwpf/usermodel/TestXWPFNumbering.java",
                "sha": "2cae023cf992c37a13cb46d16a0cacd0ab781d9a",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/c233d8db798fdc756d1091f3132e9ccb147bd28c/test-data/document/Numbering.docx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/Numbering.docx?ref=c233d8db798fdc756d1091f3132e9ccb147bd28c",
                "deletions": 0,
                "filename": "test-data/document/Numbering.docx",
                "raw_url": "https://github.com/apache/poi/raw/c233d8db798fdc756d1091f3132e9ccb147bd28c/test-data/document/Numbering.docx",
                "sha": "d5605c9f7861be2e225c74eec41c68012a233ee1",
                "status": "modified"
            }
        ],
        "message": "POI-57889 prevent NPE with on some documents with XWPFParagraph's getNumFmt() and add some other classes to enable calculation of paragraph numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1677723 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/4d0473912310532228099e83c41cba6e0577e5f4",
        "patched_files": [
            "Numbering.java",
            "XWPFNumbering.java",
            "XWPFParagraph.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFParagraph.java",
            "TestXWPFNumbering.java"
        ]
    },
    "poi_c2a0fd4": {
        "bug_id": "poi_c2a0fd4",
        "commit": "https://github.com/apache/poi/commit/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -925,6 +925,7 @@ public void shiftRows( int startRow, int endRow, int n )\n                 if ( cell != null )\n                     row2Replace.removeCell( cell );\n             }\n+\t    if (row == null) continue;\n             for ( short col = row.getFirstCellNum(); col <= row.getLastCellNum(); col++ )\n             {\n                 cell = row.getCell( col );",
                "raw_url": "https://github.com/apache/poi/raw/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "460ebfda35adaa87c3721150ac3c6af0ef97fdac",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "changes": 83,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java?ref=c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a",
                "deletions": 83,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "patch": "@@ -237,89 +237,6 @@ public void testCloneSheet() {\n         assertEquals(cloned.getRow((short)0).getCell((short)0).getStringCellValue(), \"clone_test\");\n     }\n \n-    /**\n-     * Tests the shiftRows function.  Does three different shifts.\n-     * After each shift, writes the workbook to file and reads back to\n-     * check.  This ensures that if some changes code that breaks\n-     * writing or what not, they realize it.\n-     *\n-     * Shawn Laubach (slaubach at apache dot org)\n-     */\n-    public void testShiftRows() throws Exception\n-    {\n-        // Read initial file in\n-        String filename = System.getProperty( \"HSSF.testdata.path\" );\n-        filename = filename + \"/SimpleMultiCell.xls\";\n-        FileInputStream fin = new FileInputStream( filename );\n-        HSSFWorkbook wb = new HSSFWorkbook( fin );\n-        fin.close();\n-        HSSFSheet s = wb.getSheetAt( 0 );\n-\n-        // Shift the second row down 1 and write to temp file\n-        s.shiftRows( 1, 1, 1 );\n-        File tempFile = File.createTempFile( \"shift\", \"test.xls\" );\n-        FileOutputStream fout = new FileOutputStream( tempFile );\n-        wb.write( fout );\n-        fout.close();\n-\n-        // Read from temp file and check the number of cells in each\n-        // row (in original file each row was unique)\n-        fin = new FileInputStream( tempFile );\n-        wb = new HSSFWorkbook( fin );\n-        fin.close();\n-        s = wb.getSheetAt( 0 );\n-\n-        assertEquals( s.getRow( 0 ).getPhysicalNumberOfCells(), 1 );\n-        assertTrue( s.getRow( 1 ) == null || s.getRow( 1 ).getPhysicalNumberOfCells() == 0 );\n-        assertEquals( s.getRow( 2 ).getPhysicalNumberOfCells(), 2 );\n-        assertEquals( s.getRow( 3 ).getPhysicalNumberOfCells(), 4 );\n-        assertEquals( s.getRow( 4 ).getPhysicalNumberOfCells(), 5 );\n-\n-        // Shift rows 1-3 down 3 in the current one.  This tests when\n-        // 1 row is blank.  Write to a another temp file\n-        s.shiftRows( 0, 2, 3 );\n-        tempFile = File.createTempFile( \"shift\", \"test.xls\" );\n-        fout = new FileOutputStream( tempFile );\n-        wb.write( fout );\n-        fout.close();\n-\n-        // Read and ensure things are where they should be\n-        fin = new FileInputStream( tempFile );\n-        wb = new HSSFWorkbook( fin );\n-        fin.close();\n-        s = wb.getSheetAt( 0 );\n-        assertTrue( s.getRow( 0 ) == null || s.getRow( 0 ).getPhysicalNumberOfCells() == 0 );\n-        assertTrue( s.getRow( 1 ) == null || s.getRow( 1 ).getPhysicalNumberOfCells() == 0 );\n-        assertTrue( s.getRow( 2 ) == null || s.getRow( 2 ).getPhysicalNumberOfCells() == 0 );\n-        assertEquals( s.getRow( 3 ).getPhysicalNumberOfCells(), 1 );\n-        assertTrue( s.getRow( 4 ) == null || s.getRow( 4 ).getPhysicalNumberOfCells() == 0 );\n-        assertEquals( s.getRow( 5 ).getPhysicalNumberOfCells(), 2 );\n-\n-        // Read the first file again\n-        fin = new FileInputStream( filename );\n-        wb = new HSSFWorkbook( fin );\n-        fin.close();\n-        s = wb.getSheetAt( 0 );\n-\n-        // Shift rows 3 and 4 up and write to temp file\n-        s.shiftRows( 2, 3, -2 );\n-        tempFile = File.createTempFile( \"shift\", \"test.xls\" );\n-        fout = new FileOutputStream( tempFile );\n-        wb.write( fout );\n-        fout.close();\n-\n-        // Read file and test\n-        fin = new FileInputStream( tempFile );\n-        wb = new HSSFWorkbook( fin );\n-        fin.close();\n-        s = wb.getSheetAt( 0 );\n-        assertEquals( s.getRow( 0 ).getPhysicalNumberOfCells(), 3 );\n-        assertEquals( s.getRow( 1 ).getPhysicalNumberOfCells(), 4 );\n-        assertTrue( s.getRow( 2 ) == null || s.getRow( 2 ).getPhysicalNumberOfCells() == 0 );\n-        assertTrue( s.getRow( 3 ) == null || s.getRow( 3 ).getPhysicalNumberOfCells() == 0 );\n-        assertEquals( s.getRow( 4 ).getPhysicalNumberOfCells(), 5 );\n-    }\n-\n     public void testZoom()\n             throws Exception\n     {",
                "raw_url": "https://github.com/apache/poi/raw/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a/src/testcases/org/apache/poi/hssf/usermodel/TestHSSFSheet.java",
                "sha": "8b1908bd0bfb6e29d797b859dfba751035e5ea54",
                "status": "modified"
            },
            {
                "additions": 179,
                "blob_url": "https://github.com/apache/poi/blob/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a/src/testcases/org/apache/poi/hssf/usermodel/TestSheetShiftRows.java",
                "changes": 179,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestSheetShiftRows.java?ref=c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestSheetShiftRows.java",
                "patch": "@@ -0,0 +1,179 @@\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache POI\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache POI\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.poi.hssf.usermodel;\n+\n+import junit.framework.TestCase;\n+import org.apache.poi.hssf.usermodel.HSSFSheet;\n+import org.apache.poi.hssf.usermodel.HSSFWorkbook;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+\n+/**\n+ * Tests row shifting capabilities.\n+ *\n+ *\n+ * @author Shawn Laubach (slaubach at apache dot com)\n+ * @author Toshiaki Kamoshida (kamoshida.toshiaki at future dot co dot jp)\n+ */\n+\n+public class TestSheetShiftRows extends TestCase {\n+\n+    /**\n+     * Constructor for TestSheetShiftRows.\n+     * @param arg0\n+     */\n+    public TestSheetShiftRows(String arg0) {\n+\tsuper(arg0);\n+    }\n+\n+    /**\n+     * Tests the shiftRows function.  Does three different shifts.\n+     * After each shift, writes the workbook to file and reads back to\n+     * check.  This ensures that if some changes code that breaks\n+     * writing or what not, they realize it.\n+     *\n+     * @author Shawn Laubach (slaubach at apache dot org)\n+     */\n+    public void testShiftRows() throws Exception\n+    {\n+        // Read initial file in\n+        String filename = System.getProperty( \"HSSF.testdata.path\" );\n+        filename = filename + \"/SimpleMultiCell.xls\";\n+        FileInputStream fin = new FileInputStream( filename );\n+        HSSFWorkbook wb = new HSSFWorkbook( fin );\n+        fin.close();\n+        HSSFSheet s = wb.getSheetAt( 0 );\n+\n+        // Shift the second row down 1 and write to temp file\n+        s.shiftRows( 1, 1, 1 );\n+        File tempFile = File.createTempFile( \"shift\", \"test.xls\" );\n+        FileOutputStream fout = new FileOutputStream( tempFile );\n+        wb.write( fout );\n+        fout.close();\n+\n+        // Read from temp file and check the number of cells in each\n+        // row (in original file each row was unique)\n+        fin = new FileInputStream( tempFile );\n+        wb = new HSSFWorkbook( fin );\n+        fin.close();\n+        s = wb.getSheetAt( 0 );\n+\n+        assertEquals( s.getRow( 0 ).getPhysicalNumberOfCells(), 1 );\n+        assertTrue( s.getRow( 1 ) == null || s.getRow( 1 ).getPhysicalNumberOfCells() == 0 );\n+        assertEquals( s.getRow( 2 ).getPhysicalNumberOfCells(), 2 );\n+        assertEquals( s.getRow( 3 ).getPhysicalNumberOfCells(), 4 );\n+        assertEquals( s.getRow( 4 ).getPhysicalNumberOfCells(), 5 );\n+\n+        // Shift rows 1-3 down 3 in the current one.  This tests when\n+        // 1 row is blank.  Write to a another temp file\n+        s.shiftRows( 0, 2, 3 );\n+        tempFile = File.createTempFile( \"shift\", \"test.xls\" );\n+        fout = new FileOutputStream( tempFile );\n+        wb.write( fout );\n+        fout.close();\n+\n+        // Read and ensure things are where they should be\n+        fin = new FileInputStream( tempFile );\n+        wb = new HSSFWorkbook( fin );\n+        fin.close();\n+        s = wb.getSheetAt( 0 );\n+        assertTrue( s.getRow( 0 ) == null || s.getRow( 0 ).getPhysicalNumberOfCells() == 0 );\n+        assertTrue( s.getRow( 1 ) == null || s.getRow( 1 ).getPhysicalNumberOfCells() == 0 );\n+        assertTrue( s.getRow( 2 ) == null || s.getRow( 2 ).getPhysicalNumberOfCells() == 0 );\n+        assertEquals( s.getRow( 3 ).getPhysicalNumberOfCells(), 1 );\n+        assertTrue( s.getRow( 4 ) == null || s.getRow( 4 ).getPhysicalNumberOfCells() == 0 );\n+        assertEquals( s.getRow( 5 ).getPhysicalNumberOfCells(), 2 );\n+\n+        // Read the first file again\n+        fin = new FileInputStream( filename );\n+        wb = new HSSFWorkbook( fin );\n+        fin.close();\n+        s = wb.getSheetAt( 0 );\n+\n+        // Shift rows 3 and 4 up and write to temp file\n+        s.shiftRows( 2, 3, -2 );\n+        tempFile = File.createTempFile( \"shift\", \"test.xls\" );\n+        fout = new FileOutputStream( tempFile );\n+        wb.write( fout );\n+        fout.close();\n+\n+        // Read file and test\n+        fin = new FileInputStream( tempFile );\n+        wb = new HSSFWorkbook( fin );\n+        fin.close();\n+        s = wb.getSheetAt( 0 );\n+        assertEquals( s.getRow( 0 ).getPhysicalNumberOfCells(), 3 );\n+        assertEquals( s.getRow( 1 ).getPhysicalNumberOfCells(), 4 );\n+        assertTrue( s.getRow( 2 ) == null || s.getRow( 2 ).getPhysicalNumberOfCells() == 0 );\n+        assertTrue( s.getRow( 3 ) == null || s.getRow( 3 ).getPhysicalNumberOfCells() == 0 );\n+        assertEquals( s.getRow( 4 ).getPhysicalNumberOfCells(), 5 );\n+    }\n+\n+    /**\n+     * Tests when rows are null.\n+     *\n+     * @author Toshiaki Kamoshida (kamoshida.toshiaki at future dot co dot jp)\n+     */\n+    public void testShiftRow(){\n+\tHSSFWorkbook b = new HSSFWorkbook();\n+\tHSSFSheet s    = b.createSheet();\n+\ts.createRow(0).createCell((short)0).setCellValue(\"TEST1\");\n+\ts.createRow(3).createCell((short)0).setCellValue(\"TEST2\");\n+\ts.shiftRows(0,4,1);\n+    }\n+}\n+",
                "raw_url": "https://github.com/apache/poi/raw/c2a0fd4fe6533e1d5aaf19a24e9e56a5e4d24e1a/src/testcases/org/apache/poi/hssf/usermodel/TestSheetShiftRows.java",
                "sha": "80a3cd8c6dd5ac18d45668c961235790aaf9b055",
                "status": "added"
            }
        ],
        "message": "Fix for bug #15019.  NullPointerException in shiftRows.  Added the test case and moved the other test case into the file.  Put Toshiaki Kamoshida as an author of the test case.  Test failed.  Added patch.  Test worked.\n\nPR:\nObtained from:\nSubmitted by:\nReviewed by:\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@353004 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/5bbf6e777428bcbdd6e7b9d3c521e6fc99074ddc",
        "patched_files": [
            "HSSFSheet.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestSheetShiftRows.java",
            "TestHSSFSheet.java"
        ]
    },
    "poi_c3adfba": {
        "bug_id": "poi_c3adfba",
        "commit": "https://github.com/apache/poi/commit/c3adfbaf480348ae3f6462562e8e334c70724940",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/c3adfbaf480348ae3f6462562e8e334c70724940/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java?ref=c3adfbaf480348ae3f6462562e8e334c70724940",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "patch": "@@ -299,7 +299,7 @@ public Color getLineColor() {\n     public void setLineWidth(double width) {\r\n         CTShapeProperties spPr = getSpPr();\r\n         if (width == 0.) {\r\n-            if (spPr.isSetLn())\r\n+            if (spPr.isSetLn() && spPr.getLn().isSetW())\r\n                 spPr.getLn().unsetW();\r\n         } else {\r\n             CTLineProperties ln = spPr.isSetLn() ? spPr.getLn() : spPr\r\n@@ -353,7 +353,7 @@ public boolean fetch(XSLFSimpleShape shape) {\n     public void setLineDash(LineDash dash) {\r\n         CTShapeProperties spPr = getSpPr();\r\n         if (dash == null) {\r\n-            if (spPr.isSetLn())\r\n+            if (spPr.isSetLn() &&  spPr.getLn().isSetPrstDash())\r\n                 spPr.getLn().unsetPrstDash();\r\n         } else {\r\n             CTPresetLineDashProperties val = CTPresetLineDashProperties.Factory\r\n@@ -406,7 +406,7 @@ public boolean fetch(XSLFSimpleShape shape) {\n     public void setLineCap(LineCap cap) {\r\n         CTShapeProperties spPr = getSpPr();\r\n         if (cap == null) {\r\n-            if (spPr.isSetLn())\r\n+            if (spPr.isSetLn() && spPr.getLn().isSetCap())\r\n                 spPr.getLn().unsetCap();\r\n         } else {\r\n             CTLineProperties ln = spPr.isSetLn() ? spPr.getLn() : spPr\r",
                "raw_url": "https://github.com/apache/poi/raw/c3adfbaf480348ae3f6462562e8e334c70724940/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFSimpleShape.java",
                "sha": "d6cfa7fba3c6efd0c5c489f7e9e88778c4f18606",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/poi/blob/c3adfbaf480348ae3f6462562e8e334c70724940/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFSimpleShape.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFSimpleShape.java?ref=c3adfbaf480348ae3f6462562e8e334c70724940",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFSimpleShape.java",
                "patch": "@@ -100,6 +100,20 @@ public void testLineStyles() {\n         assertEquals(null, shape.getLineColor());\r\n         // setting dash width to null unsets the SolidFill element\r\n         assertFalse(shape.getSpPr().getLn().isSetSolidFill());\r\n+\r\n+        XSLFSimpleShape ln2 = slide.createAutoShape();\r\n+        ln2.setLineDash(LineDash.DOT);\r\n+        assertEquals(LineDash.DOT, ln2.getLineDash());\r\n+        ln2.setLineWidth(0.);\r\n+        assertEquals(0., ln2.getLineWidth());\r\n+\r\n+        XSLFSimpleShape ln3 = slide.createAutoShape();\r\n+        ln3.setLineWidth(1.);\r\n+        assertEquals(1., ln3.getLineWidth());\r\n+        ln3.setLineDash(null);\r\n+        assertEquals(null, ln3.getLineDash());\r\n+        ln3.setLineCap(null);\r\n+        assertEquals(null, ln3.getLineDash());\r\n     }\r\n \r\n     public void testFill() {\r",
                "raw_url": "https://github.com/apache/poi/raw/c3adfbaf480348ae3f6462562e8e334c70724940/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFSimpleShape.java",
                "sha": "f0d57241dbf3446d564924480179b70ada9f3bcf",
                "status": "modified"
            }
        ],
        "message": "avoid NPE when setting line properties if linewidth is zero\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1356102 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1245dc7e79401502ead3d54b7e533184b1953a84",
        "patched_files": [
            "XSLFSimpleShape.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSLFSimpleShape.java"
        ]
    },
    "poi_c6f365f": {
        "bug_id": "poi_c6f365f",
        "commit": "https://github.com/apache/poi/commit/c6f365f4e438dc66d8810773c33e80d4feed82ca",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/c6f365f4e438dc66d8810773c33e80d4feed82ca/src/ooxml/java/org/apache/poi/xssf/usermodel/helpers/ColumnHelper.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/helpers/ColumnHelper.java?ref=c6f365f4e438dc66d8810773c33e80d4feed82ca",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/helpers/ColumnHelper.java",
                "patch": "@@ -319,6 +319,7 @@ private boolean columnExists(CTCols cols, long min, long max) {\n     }\n \n     public int getIndexOfColumn(CTCols cols, CTCol searchCol) {\n+        if (cols == null || searchCol == null) return -1;\n         int i = 0;\n         for (CTCol col : cols.getColArray()) {\n             if (col.getMin() == searchCol.getMin() && col.getMax() == searchCol.getMax()) {",
                "raw_url": "https://github.com/apache/poi/raw/c6f365f4e438dc66d8810773c33e80d4feed82ca/src/ooxml/java/org/apache/poi/xssf/usermodel/helpers/ColumnHelper.java",
                "sha": "b27100656beae45abe195a4b59afc2dddfceacd7",
                "status": "modified"
            }
        ],
        "message": "fix NPE\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1761844 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/5b6d4546c22e98d7e43bb9b1e65dcedf3be1348a",
        "patched_files": [
            "ColumnHelper.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestColumnHelper.java"
        ]
    },
    "poi_ca39856": {
        "bug_id": "poi_ca39856",
        "commit": "https://github.com/apache/poi/commit/ca39856e9106e4a03c1ffd2137d944851cd83c1c",
        "file": [
            {
                "additions": 36,
                "blob_url": "https://github.com/apache/poi/blob/ca39856e9106e4a03c1ffd2137d944851cd83c1c/src/scratchpad/src/org/apache/poi/hmef/extractor/HMEFContentsExtractor.java",
                "changes": 57,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hmef/extractor/HMEFContentsExtractor.java?ref=ca39856e9106e4a03c1ffd2137d944851cd83c1c",
                "deletions": 21,
                "filename": "src/scratchpad/src/org/apache/poi/hmef/extractor/HMEFContentsExtractor.java",
                "patch": "@@ -1,18 +1,18 @@\n /* ====================================================================\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n+    Licensed to the Apache Software Foundation (ASF) under one or more\n+    contributor license agreements.  See the NOTICE file distributed with\n+    this work for additional information regarding copyright ownership.\n+    The ASF licenses this file to You under the Apache License, Version 2.0\n+    (the \"License\"); you may not use this file except in compliance with\n+    the License.  You may obtain a copy of the License at\n \n-       http://www.apache.org/licenses/LICENSE-2.0\n+         http://www.apache.org/licenses/LICENSE-2.0\n \n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n ==================================================================== */\n \n package org.apache.poi.hmef.extractor;\n@@ -34,8 +34,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  *  from a HMEF/TNEF/winmail.dat file\n  */\n public final class HMEFContentsExtractor {\n-    public static void main(String[] args) throws Exception {\n-        if (args.length < 2) {\n+    /**\n+     * Usage: HMEFContentsExtractor &lt;filename&gt; &lt;output dir&gt;\n+     */\n+    public static void main(String[] args) throws IOException {\n+        if(args.length < 2) {\n             System.err.println(\"Use:\");\n             System.err.println(\"  HMEFContentsExtractor <filename> <output dir>\");\n             System.err.println(\"\");\n@@ -45,11 +48,14 @@ public static void main(String[] args) throws Exception {\n             System.exit(2);\n         }\n         \n-        HMEFContentsExtractor ext = new HMEFContentsExtractor(new File(args[0]));\n+        final String filename = args[0];\n+        final String outputDir = args[1];\n         \n-        File dir = new File(args[1]);\n+        HMEFContentsExtractor ext = new HMEFContentsExtractor(new File(filename));\n+        \n+        File dir = new File(outputDir);\n         File rtf = new File(dir, \"message.rtf\");\n-        if (! dir.exists()) {\n+        if(! dir.exists()) {\n             throw new FileNotFoundException(\"Output directory \" + dir.getName() + \" not found\");\n         }\n         \n@@ -59,7 +65,7 @@ public static void main(String[] args) throws Exception {\n         System.out.println(\"Extraction completed\");\n     }\n     \n-    private HMEFMessage message;\n+    private final HMEFMessage message;\n     public HMEFContentsExtractor(File filename) throws IOException {\n         this(new HMEFMessage(new FileInputStream(filename)));\n     }\n@@ -73,14 +79,23 @@ public HMEFContentsExtractor(HMEFMessage message) {\n     public void extractMessageBody(File dest) throws IOException {\n         OutputStream fout = new FileOutputStream(dest);\n         try {\n-            MAPIRtfAttribute body = (MAPIRtfAttribute)\n-                    message.getMessageMAPIAttribute(MAPIProperty.RTF_COMPRESSED);\n-            fout.write(body.getData());\n+            extractMessageBody(fout);\n         } finally {\n             fout.close();\n         }\n     }\n     \n+    /**\n+     * Extracts the RTF message body to the supplied stream\n+     */\n+    public void extractMessageBody(OutputStream out) throws IOException {\n+        MAPIRtfAttribute body = (MAPIRtfAttribute)\n+                message.getMessageMAPIAttribute(MAPIProperty.RTF_COMPRESSED);\n+        if (body != null) {\n+            out.write(body.getData());\n+        }\n+    }\n+    \n     /**\n      * Extracts all the message attachments to the supplied directory\n      */",
                "raw_url": "https://github.com/apache/poi/raw/ca39856e9106e4a03c1ffd2137d944851cd83c1c/src/scratchpad/src/org/apache/poi/hmef/extractor/HMEFContentsExtractor.java",
                "sha": "157856915be86b9a2ab9e88aa52987016535f8d2",
                "status": "modified"
            },
            {
                "additions": 78,
                "blob_url": "https://github.com/apache/poi/blob/ca39856e9106e4a03c1ffd2137d944851cd83c1c/src/scratchpad/testcases/org/apache/poi/hmef/extractor/TestHMEFContentsExtractor.java",
                "changes": 78,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hmef/extractor/TestHMEFContentsExtractor.java?ref=ca39856e9106e4a03c1ffd2137d944851cd83c1c",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hmef/extractor/TestHMEFContentsExtractor.java",
                "patch": "@@ -0,0 +1,78 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.hmef.extractor;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertArrayEquals;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.apache.poi.POIDataSamples;\n+import org.apache.poi.util.TempFile;\n+import org.junit.Test;\n+\n+public class TestHMEFContentsExtractor {\n+    @Test\n+    public void TestMain() throws IOException {\n+        POIDataSamples samples = POIDataSamples.getHMEFInstance();\n+        File message = samples.getFile(\"quick-winmail.dat\");\n+        File outputDirectory = TempFile.createTempDirectory(\"quick-winmail-main\");\n+        String[] args = new String[] { message.getAbsolutePath(), outputDirectory.getAbsolutePath() };\n+        HMEFContentsExtractor.main(args);\n+        \n+        String[] contents = new String[] {\n+                \"message.rtf\", // from extractMessageBody\n+                \"quick.txt\", \"quick.pdf\", \"quick.xml\", \"quick.doc\", \"quick.html\" // from extractAttachments\n+        };\n+        \n+        for (String filename : contents) {\n+            File f = new File(outputDirectory, filename);\n+            assertTrue(f + \" does not exist\", f.exists());\n+        }\n+\n+        outputDirectory.delete();\n+    }\n+    \n+    @Test\n+    public void TestExtractMessageBody_OutputStream() throws IOException {\n+        POIDataSamples samples = POIDataSamples.getHMEFInstance();\n+        File winmailTNEFFile = samples.getFile(\"quick-winmail.dat\");\n+        HMEFContentsExtractor extractor = new HMEFContentsExtractor(winmailTNEFFile);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        extractor.extractMessageBody(out);\n+        assertTrue(out.size() > 0);\n+        byte[] expectedMagic = new byte[] { '{', '\\\\', 'r', 't', 'f' };\n+        byte[] magic = Arrays.copyOf(out.toByteArray(), 5);\n+        assertArrayEquals(\"RTF magic number\", expectedMagic, magic);\n+        out.close();\n+    }\n+    \n+    @Test\n+    public void TestExtractMessageBody_File() throws IOException {\n+        POIDataSamples samples = POIDataSamples.getHMEFInstance();\n+        File winmailTNEFFile = samples.getFile(\"quick-winmail.dat\");\n+        HMEFContentsExtractor extractor = new HMEFContentsExtractor(winmailTNEFFile);\n+        File rtf = TempFile.createTempFile(\"quick-winmail-message-body\", \".rtf\");\n+        assertTrue(rtf.delete());\n+        extractor.extractMessageBody(rtf);\n+        assertTrue(\"RTF message body is empty\", rtf.length() > 0);\n+    }\n+}",
                "raw_url": "https://github.com/apache/poi/raw/ca39856e9106e4a03c1ffd2137d944851cd83c1c/src/scratchpad/testcases/org/apache/poi/hmef/extractor/TestHMEFContentsExtractor.java",
                "sha": "2cfd6449051ae470e82e042747d7b97b2b71fa0a",
                "status": "added"
            }
        ],
        "message": "bug 59786: fix NPE from winmail.dat files if message body is null\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1751180 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/549d12fbc249f712cffe8e0d579749a550ce43a4",
        "patched_files": [
            "HMEFContentsExtractor.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHMEFContentsExtractor.java"
        ]
    },
    "poi_cc51d8e": {
        "bug_id": "poi_cc51d8e",
        "commit": "https://github.com/apache/poi/commit/cc51d8eeb62ca138b72d37785cade16d7267a859",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java?ref=cc51d8eeb62ca138b72d37785cade16d7267a859",
                "deletions": 6,
                "filename": "src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "patch": "@@ -261,7 +261,6 @@ public void exportToXML(OutputStream os, String encoding, boolean validate) thro\n      * @return true, if document is valid\n      */\n     private boolean isValid(Document xml) throws SAXException{\n-        boolean isValid = false;\n         try{\n             String language = \"http://www.w3.org/2001/XMLSchema\";\n             SchemaFactory factory = SchemaFactory.newInstance(language);\n@@ -270,14 +269,14 @@ private boolean isValid(Document xml) throws SAXException{\n             Schema schema = factory.newSchema(source);\n             Validator validator = schema.newValidator();\n             validator.validate(new DOMSource(xml));\n+            \n             //if no exceptions where raised, the document is valid\n-            isValid=true;\n-\n-\n+            return true;\n         } catch(IOException e) {\n             e.printStackTrace();\n         }\n-        return isValid;\n+\n+        return false;\n     }\n \n \n@@ -517,7 +516,7 @@ private Node getComplexTypeNodeFromSchemaChildren(Node xmlSchema, Node complexTy\n                             Node sequence = complexTypeChildList.item(j);\n \n                             if ( sequence instanceof Element) {\n-                                if (sequence.getLocalName().equals(\"sequence\")) {\n+                                if (sequence.getLocalName().equals(\"sequence\") || sequence.getLocalName().equals(\"all\")) {\n                                     complexTypeNode = sequence;\n                                     break;\n                                 }",
                "raw_url": "https://github.com/apache/poi/raw/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java",
                "sha": "910741f5117a85780c8090ddfac017de81519141",
                "status": "modified"
            },
            {
                "additions": 536,
                "blob_url": "https://github.com/apache/poi/blob/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java.orig",
                "changes": 536,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java.orig?ref=cc51d8eeb62ca138b72d37785cade16d7267a859",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java.orig",
                "patch": "@@ -0,0 +1,536 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.xssf.extractor;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+import javax.xml.validation.Validator;\n+\n+import org.apache.poi.openxml4j.exceptions.InvalidFormatException;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.DateUtil;\n+import org.apache.poi.xssf.usermodel.XSSFCell;\n+import org.apache.poi.xssf.usermodel.XSSFMap;\n+import org.apache.poi.xssf.usermodel.XSSFRow;\n+import org.apache.poi.xssf.usermodel.XSSFSheet;\n+import org.apache.poi.xssf.usermodel.XSSFTable;\n+import org.apache.poi.xssf.usermodel.helpers.XSSFSingleXmlCell;\n+import org.apache.poi.xssf.usermodel.helpers.XSSFXmlColumnPr;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.STXmlDataType;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ *\n+ * Maps an XLSX to an XML according to one of the mapping defined.\n+ *\n+ *\n+ * The output XML Schema must respect this limitations:\n+ *\n+ * <ul>\n+ * <li> all mandatory elements and attributes must be mapped (enable validation to check this)</li>\n+ *\n+ * <li> no &lt;any&gt; in complex type/element declaration </li>\n+ * <li> no &lt;anyAttribute&gt; attributes declaration </li>\n+ * <li> no recursive structures: recursive structures can't be nested more than one level </li>\n+ * <li> no abstract elements: abstract complex types can be declared but must not be used in elements. </li>\n+ * <li> no mixed content: an element can't contain simple text and child element(s) together </li>\n+ * <li> no &lt;substitutionGroup&gt; in complex type/element declaration </li>\n+ * </ul>\n+ */\n+public class XSSFExportToXml implements Comparator<String>{\n+\n+    private XSSFMap map;\n+\n+    /**\n+     * Creates a new exporter and sets the mapping to be used when generating the XML output document\n+     *\n+     * @param map the mapping rule to be used\n+     */\n+    public XSSFExportToXml(XSSFMap map) {\n+        this.map = map;\n+    }\n+\n+    /**\n+     *\n+     * Exports the data in an XML stream\n+     *\n+     * @param os OutputStream in which will contain the output XML\n+     * @param validate if true, validates the XML againts the XML Schema\n+     * @throws SAXException\n+     * @throws TransformerException  \n+     * @throws ParserConfigurationException \n+     */\n+    public void exportToXML(OutputStream os, boolean validate) throws SAXException, ParserConfigurationException, TransformerException {\n+        exportToXML(os, \"UTF-8\", validate);\n+    }\n+\n+    private Document getEmptyDocument() throws ParserConfigurationException{\n+\n+        DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder docBuilder = dbfac.newDocumentBuilder();\n+        Document doc = docBuilder.newDocument();\n+\n+        return doc;\n+    }\n+\n+    /**\n+     * Exports the data in an XML stream\n+     *\n+     * @param os OutputStream in which will contain the output XML\n+     * @param encoding the output charset encoding\n+     * @param validate if true, validates the XML againts the XML Schema\n+     * @throws SAXException\n+     * @throws ParserConfigurationException \n+     * @throws TransformerException \n+     * @throws InvalidFormatException\n+     */\n+    public void exportToXML(OutputStream os, String encoding, boolean validate) throws SAXException, ParserConfigurationException, TransformerException{\n+        List<XSSFSingleXmlCell> singleXMLCells = map.getRelatedSingleXMLCell();\n+        List<XSSFTable> tables = map.getRelatedTables();\n+\n+        String rootElement = map.getCtMap().getRootElement();\n+\n+        Document doc = getEmptyDocument();\n+\n+        Element root = null;\n+\n+        if (isNamespaceDeclared()) {\n+            root=doc.createElementNS(getNamespace(),rootElement);\n+        } else {\n+            root = doc.createElementNS(\"\", rootElement);\n+        }\n+        doc.appendChild(root);\n+\n+\n+        List<String> xpaths = new Vector<String>();\n+        Map<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<String,XSSFSingleXmlCell>();\n+        Map<String,XSSFTable> tableMappings = new HashMap<String,XSSFTable>();\n+\n+        for(XSSFSingleXmlCell simpleXmlCell : singleXMLCells) {\n+            xpaths.add(simpleXmlCell.getXpath());\n+            singleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);\n+        }\n+        for(XSSFTable table : tables) {\n+            String commonXPath = table.getCommonXpath();\n+            xpaths.add(commonXPath);\n+            tableMappings.put(commonXPath, table);\n+        }\n+\n+\n+        Collections.sort(xpaths,this);\n+\n+        for(String xpath : xpaths) {\n+\n+            XSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);\n+            XSSFTable table = tableMappings.get(xpath);\n+\n+            if (!xpath.matches(\".*\\\\[.*\")) {\n+\n+                // Exports elements and attributes mapped with simpleXmlCell\n+                if (simpleXmlCell!=null) {\n+                    XSSFCell cell = simpleXmlCell.getReferencedCell();\n+                    if (cell!=null) {\n+                        Node currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);\n+                        STXmlDataType.Enum dataType = simpleXmlCell.getXmlDataType();\n+                        mapCellOnNode(cell,currentNode,dataType);\n+                        \n+                        //remove nodes which are empty in order to keep the output xml valid\n+                        if(\"\".equals(currentNode.getTextContent()) && currentNode.getParentNode() != null) {\n+                        \tcurrentNode.getParentNode().removeChild(currentNode);\n+                        }\n+                    }\n+                }\n+\n+                // Exports elements and attributes mapped with tables\n+                if (table!=null) {\n+\n+                    List<XSSFXmlColumnPr> tableColumns = table.getXmlColumnPrs();\n+\n+                    XSSFSheet sheet = table.getXSSFSheet();\n+\n+                    int startRow = table.getStartCellReference().getRow();\n+                    // In mappings created with Microsoft Excel the first row contains the table header and must be skipped\n+                    startRow +=1;\n+\n+                    int endRow = table.getEndCellReference().getRow();\n+\n+                    for(int i = startRow; i<= endRow; i++) {\n+                        XSSFRow row = sheet.getRow(i);\n+\n+                        Node tableRootNode = getNodeByXPath(table.getCommonXpath(),doc.getFirstChild(),doc,true);\n+\n+                        short startColumnIndex = table.getStartCellReference().getCol();\n+                        for(int j = startColumnIndex; j<= table.getEndCellReference().getCol();j++) {\n+                            XSSFCell cell = row.getCell(j);\n+                            if (cell!=null) {\n+                                XSSFXmlColumnPr pointer = tableColumns.get(j-startColumnIndex);\n+                                String localXPath = pointer.getLocalXPath();\n+                                Node currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);\n+                                STXmlDataType.Enum dataType = pointer.getXmlDataType();\n+\n+\n+                                mapCellOnNode(cell,currentNode,dataType);\n+                            }\n+\n+                        }\n+\n+                    }\n+\n+\n+\n+                }\n+            } else {\n+                // TODO:  implement filtering management in xpath\n+            }\n+        }\n+\n+        boolean isValid = true;\n+        if (validate) {\n+            isValid =isValid(doc);\n+        }\n+\n+\n+\n+        if (isValid) {\n+\n+            /////////////////\n+            //Output the XML\n+\n+            //set up a transformer\n+            TransformerFactory transfac = TransformerFactory.newInstance();\n+            Transformer trans = transfac.newTransformer();\n+            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n+            trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            trans.setOutputProperty(OutputKeys.ENCODING, encoding);\n+\n+            //create string from xml tree\n+\n+            StreamResult result = new StreamResult(os);\n+            DOMSource source = new DOMSource(doc);\n+            trans.transform(source, result);\n+\n+        }\n+    }\n+\n+\n+    /**\n+     * Validate the generated XML against the XML Schema associated with the XSSFMap\n+     *\n+     * @param xml the XML to validate\n+     * @return true, if document is valid\n+     */\n+    private boolean isValid(Document xml) throws SAXException{\n+        boolean isValid = false;\n+        try{\n+            String language = \"http://www.w3.org/2001/XMLSchema\";\n+            SchemaFactory factory = SchemaFactory.newInstance(language);\n+\n+            Source source = new DOMSource(map.getSchema());\n+            Schema schema = factory.newSchema(source);\n+            Validator validator = schema.newValidator();\n+            validator.validate(new DOMSource(xml));\n+            //if no exceptions where raised, the document is valid\n+            isValid=true;\n+\n+\n+        } catch(IOException e) {\n+            e.printStackTrace();\n+        }\n+        return isValid;\n+    }\n+\n+\n+    private void mapCellOnNode(XSSFCell cell, Node node, STXmlDataType.Enum  outputDataType) {\n+\n+        String value =\"\";\n+        switch (cell.getCellType()) {\n+\n+        case XSSFCell.CELL_TYPE_STRING: value = cell.getStringCellValue(); break;\n+        case XSSFCell.CELL_TYPE_BOOLEAN: value += cell.getBooleanCellValue(); break;\n+        case XSSFCell.CELL_TYPE_ERROR: value = cell.getErrorCellString();  break;\n+        case XSSFCell.CELL_TYPE_FORMULA:\n+           if (cell.getCachedFormulaResultType() == Cell.CELL_TYPE_STRING) {\n+               value = cell.getStringCellValue();\n+           } else {\n+               value += cell.getNumericCellValue();\n+           }\n+           break;\n+        \n+        case XSSFCell.CELL_TYPE_NUMERIC: \n+             if (DateUtil.isCellDateFormatted(cell)) {\n+                  DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n+                  value += sdf.format(cell.getDateCellValue());\n+              } else {\n+                 value += cell.getRawValue();\n+              }\n+            break;\n+\n+        default: ;\n+\n+        }\n+        if (node instanceof Element) {\n+            Element currentElement = (Element) node;\n+            currentElement.setTextContent(value);\n+        } else {\n+            node.setNodeValue(value);\n+        }\n+    }\n+\n+    private String removeNamespace(String elementName) {\n+        return elementName.matches(\".*:.*\")?elementName.split(\":\")[1]:elementName;\n+    }\n+\n+\n+\n+    private Node getNodeByXPath(String xpath,Node rootNode,Document doc,boolean createMultipleInstances) {\n+        String[] xpathTokens = xpath.split(\"/\");\n+\n+\n+        Node currentNode =rootNode;\n+        // The first token is empty, the second is the root node\n+        for(int i =2; i<xpathTokens.length;i++) {\n+\n+            String axisName = removeNamespace(xpathTokens[i]);\n+\n+\n+            if (!axisName.startsWith(\"@\")) {\n+\n+                NodeList list =currentNode.getChildNodes();\n+\n+                Node selectedNode = null;\n+                if (!(createMultipleInstances && i==xpathTokens.length-1) ) {\n+                    // select the last child node only if we need to map to a single cell\n+                    selectedNode = selectNode(axisName, list);\n+                }\n+                if (selectedNode==null) {\n+                    selectedNode = createElement(doc, currentNode, axisName);\n+                }\n+                currentNode = selectedNode;\n+            } else {\n+\n+\n+                Node attribute = createAttribute(doc, currentNode, axisName);\n+\n+                currentNode = attribute;\n+            }\n+        }\n+        return currentNode;\n+    }\n+\n+    private Node createAttribute(Document doc, Node currentNode, String axisName) {\n+        String attributeName = axisName.substring(1);\n+        NamedNodeMap attributesMap = currentNode.getAttributes();\n+        Node attribute = attributesMap.getNamedItem(attributeName);\n+        if (attribute==null) {\n+            attribute = doc.createAttributeNS(\"\", attributeName);\n+            attributesMap.setNamedItem(attribute);\n+        }\n+        return attribute;\n+    }\n+\n+    private Node createElement(Document doc, Node currentNode, String axisName) {\n+        Node selectedNode;\n+        if (isNamespaceDeclared()) {\n+            selectedNode =doc.createElementNS(getNamespace(),axisName);\n+        } else {\n+            selectedNode = doc.createElementNS(\"\", axisName);\n+        }\n+        currentNode.appendChild(selectedNode);\n+        return selectedNode;\n+    }\n+\n+    private Node selectNode(String axisName, NodeList list) {\n+        Node selectedNode = null;\n+        for(int j=0;j<list.getLength();j++) {\n+            Node node = list.item(j);\n+            if (node.getNodeName().equals(axisName)) {\n+                selectedNode=node;\n+                break;\n+            }\n+        }\n+        return selectedNode;\n+    }\n+\n+\n+    private boolean isNamespaceDeclared() {\n+        String schemaNamespace = getNamespace();\n+        return schemaNamespace!=null && !schemaNamespace.equals(\"\");\n+    }\n+\n+    private String getNamespace() {\n+        return map.getCTSchema().getNamespace();\n+    }\n+\n+\n+    /**\n+     * Compares two xpaths to define an ordering according to the XML Schema\n+     *\n+     */\n+    @Override\n+    public int compare(String leftXpath, String rightXpath) {\n+        Node xmlSchema = map.getSchema();\n+\n+        String[] leftTokens = leftXpath.split(\"/\");\n+        String[] rightTokens = rightXpath.split(\"/\");\n+\n+        int minLenght = leftTokens.length< rightTokens.length? leftTokens.length : rightTokens.length;\n+\n+        Node localComplexTypeRootNode = xmlSchema;\n+\n+        for(int i =1;i <minLenght; i++) {\n+\n+            String leftElementName =leftTokens[i];\n+            String rightElementName = rightTokens[i];\n+\n+            if (leftElementName.equals(rightElementName)) {\n+                Node complexType = getComplexTypeForElement(leftElementName, xmlSchema,localComplexTypeRootNode);\n+                localComplexTypeRootNode = complexType;\n+            } else {\n+                int leftIndex = indexOfElementInComplexType(leftElementName,localComplexTypeRootNode);\n+                int rightIndex = indexOfElementInComplexType(rightElementName,localComplexTypeRootNode);\n+                if (leftIndex!=-1 && rightIndex!=-1) {\n+                    if ( leftIndex < rightIndex) {\n+                        return -1;\n+                    }if ( leftIndex > rightIndex) {\n+                        return 1;\n+                    }\n+                } else {\n+                    // NOTE: the xpath doesn't match correctly in the schema\n+                }\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n+    private int indexOfElementInComplexType(String elementName,Node complexType) {\n+\n+        NodeList list  = complexType.getChildNodes();\n+        int indexOf = -1;\n+\n+        for(int i=0; i< list.getLength();i++) {\n+            Node node = list.item(i);\n+            if (node instanceof Element) {\n+                if (node.getLocalName().equals(\"element\")) {\n+                    Node nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n+                    if (nameAttribute.getNodeValue().equals(removeNamespace(elementName))) {\n+                        indexOf = i;\n+                        break;\n+                    }\n+\n+                }\n+            }\n+        }\n+        return indexOf;\n+    }\n+\n+    private Node getComplexTypeForElement(String elementName,Node xmlSchema,Node localComplexTypeRootNode) {\n+        String elementNameWithoutNamespace = removeNamespace(elementName);\n+\n+        String complexTypeName = getComplexTypeNameFromChildren(localComplexTypeRootNode, elementNameWithoutNamespace);\n+\n+        // Note: we expect that all the complex types are defined at root level\n+        Node complexTypeNode = null;\n+        if (!\"\".equals(complexTypeName)) {\n+            complexTypeNode = getComplexTypeNodeFromSchemaChildren(xmlSchema, complexTypeNode, complexTypeName);\n+        }\n+\n+        return complexTypeNode;\n+    }\n+\n+    private String getComplexTypeNameFromChildren(Node localComplexTypeRootNode,\n+            String elementNameWithoutNamespace) {\n+        NodeList  list  = localComplexTypeRootNode.getChildNodes();\n+        String complexTypeName = \"\";\n+\n+        for(int i=0; i< list.getLength();i++) {\n+            Node node = list.item(i);\n+            if ( node instanceof Element) {\n+                if (node.getLocalName().equals(\"element\")) {\n+                    Node nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n+                    if (nameAttribute.getNodeValue().equals(elementNameWithoutNamespace)) {\n+                        Node complexTypeAttribute = node.getAttributes().getNamedItem(\"type\");\n+                        if (complexTypeAttribute!=null) {\n+                            complexTypeName = complexTypeAttribute.getNodeValue();\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return complexTypeName;\n+    }\n+\n+    private Node getComplexTypeNodeFromSchemaChildren(Node xmlSchema, Node complexTypeNode,\n+            String complexTypeName) {\n+        NodeList  complexTypeList  = xmlSchema.getChildNodes();\n+        for(int i=0; i< complexTypeList.getLength();i++) {\n+            Node node = complexTypeList.item(i);\n+            if ( node instanceof Element) {\n+                if (node.getLocalName().equals(\"complexType\")) {\n+                    Node nameAttribute  = node.getAttributes().getNamedItem(\"name\");\n+                    if (nameAttribute.getNodeValue().equals(complexTypeName)) {\n+\n+                        NodeList complexTypeChildList  =node.getChildNodes();\n+                        for(int j=0; j<complexTypeChildList.getLength();j++) {\n+                            Node sequence = complexTypeChildList.item(j);\n+\n+                            if ( sequence instanceof Element) {\n+                                if (sequence.getLocalName().equals(\"sequence\")) {\n+                                    complexTypeNode = sequence;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        if (complexTypeNode!=null) {\n+                            break;\n+                        }\n+\n+                    }\n+                }\n+            }\n+        }\n+        return complexTypeNode;\n+    }\n+}\n\\ No newline at end of file",
                "raw_url": "https://github.com/apache/poi/raw/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/java/org/apache/poi/xssf/extractor/XSSFExportToXml.java.orig",
                "sha": "e0ee1ef88202b9a90957c662f93953fad7ea9068",
                "status": "added"
            },
            {
                "additions": 34,
                "blob_url": "https://github.com/apache/poi/blob/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java",
                "changes": 34,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java?ref=cc51d8eeb62ca138b72d37785cade16d7267a859",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java",
                "patch": "@@ -361,6 +361,40 @@ public void testXmlExportIgnoresEmptyCells_Bugzilla_55924() throws Exception {\n        assertTrue(found);\n    }\n \n+   public void testXmlExportSchemaWithXSAllTag_Bugzilla_56169() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"56169.xlsx\");\n+\n+       for (XSSFMap map : wb.getCustomXMLMappings()) {\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, true);\n+           String xmlData = os.toString(\"UTF-8\");\n+\n+           assertNotNull(xmlData);\n+           assertTrue(!xmlData.equals(\"\"));\n+\n+           String a = xmlData.split(\"<A>\")[1].split(\"</A>\")[0].trim();\n+           String a_b = a.split(\"<B>\")[1].split(\"</B>\")[0].trim();\n+           String a_b_c = a_b.split(\"<C>\")[1].split(\"</C>\")[0].trim();\n+           String a_b_c_e = a_b_c.split(\"<E>\")[1].split(\"</EA>\")[0].trim();\n+           String a_b_c_e_euro = a_b_c_e.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+           String a_b_c_e_chf = a_b_c_e.split(\"<CHF>\")[1].split(\"</CHF>\")[0].trim();\n+\n+           assertEquals(\"1\", a_b_c_e_euro);\n+           assertEquals(\"2\", a_b_c_e_chf);\n+\n+           String a_b_d = a_b.split(\"<D>\")[1].split(\"</Dd>\")[0].trim();\n+           String a_b_d_e = a_b_d.split(\"<E>\")[1].split(\"</EA>\")[0].trim();\n+\n+           String a_b_d_e_euro = a_b_d_e.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+           String a_b_d_e_chf = a_b_d_e.split(\"<CHF>\")[1].split(\"</CHF>\")[0].trim();\n+\n+           assertEquals(\"3\", a_b_d_e_euro);\n+           assertEquals(\"4\", a_b_d_e_chf);\n+       }\n+   }\n+   \n    public void testXmlExportCompare_Bug_55923() throws Exception {\n        XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55923.xlsx\");\n ",
                "raw_url": "https://github.com/apache/poi/raw/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java",
                "sha": "7726fc37fbfe0546794894c3c15ac1676b51d062",
                "status": "modified"
            },
            {
                "additions": 548,
                "blob_url": "https://github.com/apache/poi/blob/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java.orig",
                "changes": 548,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java.orig?ref=cc51d8eeb62ca138b72d37785cade16d7267a859",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java.orig",
                "patch": "@@ -0,0 +1,548 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.xssf.extractor;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.poi.POIXMLDocumentPart;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Sheet;\n+import org.apache.poi.xssf.XSSFTestDataSamples;\n+import org.apache.poi.xssf.model.MapInfo;\n+import org.apache.poi.xssf.usermodel.XSSFCell;\n+import org.apache.poi.xssf.usermodel.XSSFMap;\n+import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n+import org.junit.Test;\n+import org.xml.sax.EntityResolver;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * @author Roberto Manicardi\n+ */\n+public final class TestXSSFExportToXML extends TestCase {\n+\tpublic void testExportToXML() throws Exception {\n+\n+\t\tXSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"CustomXMLMappings.xlsx\");\n+\n+        boolean found = false;\n+\t\tfor (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+\t\t\tif (!(p instanceof MapInfo)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tMapInfo mapInfo = (MapInfo) p;\n+\n+\t\t\tXSSFMap map = mapInfo.getXSSFMapById(1);\n+\t\t\tXSSFExportToXml exporter = new XSSFExportToXml(map);\n+\t\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n+\t\t\texporter.exportToXML(os, true);\n+\t\t\tString xml = os.toString(\"UTF-8\");\n+\n+\t\t\tassertNotNull(xml);\n+\t\t\tassertFalse(xml.equals(\"\"));\n+\n+\t\t\tString docente = xml.split(\"<DOCENTE>\")[1].split(\"</DOCENTE>\")[0].trim();\n+\t\t\tString nome = xml.split(\"<NOME>\")[1].split(\"</NOME>\")[0].trim();\n+\t\t\tString tutor = xml.split(\"<TUTOR>\")[1].split(\"</TUTOR>\")[0].trim();\n+\t\t\tString cdl = xml.split(\"<CDL>\")[1].split(\"</CDL>\")[0].trim();\n+\t\t\tString durata = xml.split(\"<DURATA>\")[1].split(\"</DURATA>\")[0].trim();\n+\t\t\tString argomento = xml.split(\"<ARGOMENTO>\")[1].split(\"</ARGOMENTO>\")[0].trim();\n+\t\t\tString progetto = xml.split(\"<PROGETTO>\")[1].split(\"</PROGETTO>\")[0].trim();\n+\t\t\tString crediti = xml.split(\"<CREDITI>\")[1].split(\"</CREDITI>\")[0].trim();\n+\n+\t\t\tassertEquals(\"ro\", docente);\n+\t\t\tassertEquals(\"ro\", nome);\n+\t\t\tassertEquals(\"ds\", tutor);\n+\t\t\tassertEquals(\"gs\", cdl);\n+\t\t\tassertEquals(\"g\", durata);\n+\t\t\tassertEquals(\"gvvv\", argomento);\n+\t\t\tassertEquals(\"aaaa\", progetto);\n+\t\t\tassertEquals(\"aa\", crediti);\n+\t\t\t\n+\t\t\tparseXML(xml);\n+\t           \n+           found = true;\n+       }\n+       assertTrue(found);\n+\t}\n+\n+\tpublic void testExportToXMLInverseOrder() throws Exception {\n+\n+\t\tXSSFWorkbook wb = XSSFTestDataSamples\n+\t\t\t\t.openSampleWorkbook(\"CustomXmlMappings-inverse-order.xlsx\");\n+\n+\t\tMapInfo mapInfo = null;\n+\n+        boolean found = false;\n+\t\tfor (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+\t\t\tif (!(p instanceof MapInfo)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tmapInfo = (MapInfo) p;\n+\n+\t\t\tXSSFMap map = mapInfo.getXSSFMapById(1);\n+\t\t\tXSSFExportToXml exporter = new XSSFExportToXml(map);\n+\t\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n+\t\t\texporter.exportToXML(os, true);\n+\t\t\tString xml = os.toString(\"UTF-8\");\n+\n+\t\t\tassertNotNull(xml);\n+\t\t\tassertFalse(xml.equals(\"\"));\n+\n+\t\t\tString docente = xml.split(\"<DOCENTE>\")[1].split(\"</DOCENTE>\")[0].trim();\n+\t\t\tString nome = xml.split(\"<NOME>\")[1].split(\"</NOME>\")[0].trim();\n+\t\t\tString tutor = xml.split(\"<TUTOR>\")[1].split(\"</TUTOR>\")[0].trim();\n+\t\t\tString cdl = xml.split(\"<CDL>\")[1].split(\"</CDL>\")[0].trim();\n+\t\t\tString durata = xml.split(\"<DURATA>\")[1].split(\"</DURATA>\")[0].trim();\n+\t\t\tString argomento = xml.split(\"<ARGOMENTO>\")[1].split(\"</ARGOMENTO>\")[0].trim();\n+\t\t\tString progetto = xml.split(\"<PROGETTO>\")[1].split(\"</PROGETTO>\")[0].trim();\n+\t\t\tString crediti = xml.split(\"<CREDITI>\")[1].split(\"</CREDITI>\")[0].trim();\n+\n+\t\t\tassertEquals(\"aa\", nome);\n+\t\t\tassertEquals(\"aaaa\", docente);\n+\t\t\tassertEquals(\"gvvv\", tutor);\n+\t\t\tassertEquals(\"g\", cdl);\n+\t\t\tassertEquals(\"gs\", durata);\n+\t\t\tassertEquals(\"ds\", argomento);\n+\t\t\tassertEquals(\"ro\", progetto);\n+\t\t\tassertEquals(\"ro\", crediti);\n+\t\t\t\n+\t\t\tparseXML(xml);\n+\t           \n+           found = true;\n+       }\n+       assertTrue(found);\n+\t}\n+\n+\tpublic void testXPathOrdering() {\n+\n+\t\tXSSFWorkbook wb = XSSFTestDataSamples\n+\t\t\t\t.openSampleWorkbook(\"CustomXmlMappings-inverse-order.xlsx\");\n+\n+\t\tMapInfo mapInfo = null;\n+\n+        boolean found = false;\n+\t\tfor (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+\t\t\tif (p instanceof MapInfo) {\n+\t\t\t\tmapInfo = (MapInfo) p;\n+\n+\t\t\t\tXSSFMap map = mapInfo.getXSSFMapById(1);\n+\t\t\t\tXSSFExportToXml exporter = new XSSFExportToXml(map);\n+\n+\t\t\t\tassertEquals(1, exporter.compare(\"/CORSO/DOCENTE\", \"/CORSO/NOME\"));\n+\t\t\t\tassertEquals(-1, exporter.compare(\"/CORSO/NOME\", \"/CORSO/DOCENTE\"));\n+\t\t\t}\n+\t           \n+           found = true;\n+       }\n+       assertTrue(found);\n+\t}\n+\n+\tpublic void testMultiTable() throws Exception {\n+\n+\t\tXSSFWorkbook wb = XSSFTestDataSamples\n+\t\t\t\t.openSampleWorkbook(\"CustomXMLMappings-complex-type.xlsx\");\n+\n+\t\tboolean found = false;\n+\t\tfor (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+\t\t\tif (p instanceof MapInfo) {\n+\t\t\t\tMapInfo mapInfo = (MapInfo) p;\n+\n+\t\t\t\tXSSFMap map = mapInfo.getXSSFMapById(2);\n+\n+\t\t\t\tassertNotNull(map);\n+\n+\t\t\t\tXSSFExportToXml exporter = new XSSFExportToXml(map);\n+\t\t\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n+\t\t\t\texporter.exportToXML(os, true);\n+\t\t\t\tString xml = os.toString(\"UTF-8\");\n+\n+\t\t\t\tassertNotNull(xml);\n+\n+\t\t\t\tString[] regexConditions = {\n+\t\t\t\t\t\t\"<MapInfo\", \"</MapInfo>\",\n+\t\t\t\t\t\t\"<Schema ID=\\\"1\\\" Namespace=\\\"\\\" SchemaRef=\\\"\\\"/>\",\n+\t\t\t\t\t\t\"<Schema ID=\\\"4\\\" Namespace=\\\"\\\" SchemaRef=\\\"\\\"/>\",\n+\t\t\t\t\t\t\"DataBinding\",\n+\t\t\t\t\t\t\"Map Append=\\\"false\\\" AutoFit=\\\"false\\\" ID=\\\"1\\\"\",\n+\t\t\t\t\t\t\"Map Append=\\\"false\\\" AutoFit=\\\"false\\\" ID=\\\"5\\\"\",\n+\t\t\t\t};\n+\n+\t\t\t\tfor (String condition : regexConditions) {\n+\t\t\t\t\tPattern pattern = Pattern.compile(condition);\n+\t\t\t\t\tMatcher matcher = pattern.matcher(xml);\n+\t\t\t\t\tassertTrue(matcher.find());\n+\t\t\t\t}\n+\t\t\t}\n+\t           \n+           found = true;\n+       }\n+       assertTrue(found);\n+\t}\n+\n+    public void test55850ComplexXmlExport() throws Exception {\n+\n+        XSSFWorkbook wb = XSSFTestDataSamples\n+                .openSampleWorkbook(\"55850.xlsx\");\n+\n+        boolean found = false;\n+        for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+            if (!(p instanceof MapInfo)) {\n+                continue;\n+            }\n+            MapInfo mapInfo = (MapInfo) p;\n+\n+            XSSFMap map = mapInfo.getXSSFMapById(2);\n+\n+            assertNotNull(\"XSSFMap is null\", map);\n+\n+            XSSFExportToXml exporter = new XSSFExportToXml(map);\n+            ByteArrayOutputStream os = new ByteArrayOutputStream();\n+            exporter.exportToXML(os, true);\n+            String xmlData = os.toString(\"UTF-8\");\n+\n+            assertNotNull(xmlData);\n+            assertFalse(xmlData.equals(\"\"));\n+\n+            String a = xmlData.split(\"<A>\")[1].split(\"</A>\")[0].trim();\n+            String b = a.split(\"<B>\")[1].split(\"</B>\")[0].trim();\n+            String c = b.split(\"<C>\")[1].split(\"</C>\")[0].trim();\n+            String d = c.split(\"<D>\")[1].split(\"</Dd>\")[0].trim();\n+            String e = d.split(\"<E>\")[1].split(\"</EA>\")[0].trim();\n+\n+            String euro = e.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+            String chf = e.split(\"<CHF>\")[1].split(\"</CHF>\")[0].trim();\n+\n+            assertEquals(\"15\", euro);\n+            assertEquals(\"19\", chf);\n+            \n+            parseXML(xmlData);\n+            \n+            found = true;\n+        }\n+        assertTrue(found);\n+    }\n+\n+   public void testFormulaCells_Bugzilla_55927() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55927.xlsx\");\n+       \n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+           \n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+           \n+           XSSFMap map = mapInfo.getXSSFMapById(1);\n+           \n+           assertNotNull(\"XSSFMap is null\", map);\n+           \n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, true);\n+           String xmlData = os.toString(\"UTF-8\");\n+           \n+           assertNotNull(xmlData);\n+           assertFalse(xmlData.equals(\"\"));\n+           \n+           String date = xmlData.split(\"<DATE>\")[1].split(\"</DATE>\")[0].trim();\n+           assertEquals(\"2012-01-13\", date);\n+           \n+           parseXML(xmlData);\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+\n+   public void testFormulaCells_Bugzilla_55926() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55926.xlsx\");\n+\n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+\n+           XSSFMap map = mapInfo.getXSSFMapById(1);\n+\n+           assertNotNull(\"XSSFMap is null\", map);\n+\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, true);\n+           String xmlData = os.toString(\"UTF-8\");\n+\n+           assertNotNull(xmlData);\n+           assertFalse(xmlData.equals(\"\"));\n+           \n+           String a = xmlData.split(\"<A>\")[1].split(\"</A>\")[0].trim();\n+           String doubleValue = a.split(\"<DOUBLE>\")[1].split(\"</DOUBLE>\")[0].trim();\n+           String stringValue = a.split(\"<STRING>\")[1].split(\"</STRING>\")[0].trim();\n+           \n+           assertEquals(\"Hello World\", stringValue);\n+           assertEquals(\"5.1\", doubleValue);\n+           \n+           parseXML(xmlData);\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+   \n+   @Test\n+   public void testXmlExportIgnoresEmptyCells_Bugzilla_55924() throws Exception {\n+\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55924.xlsx\");\n+\n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+\n+           XSSFMap map = mapInfo.getXSSFMapById(1);\n+\n+           assertNotNull(\"XSSFMap is null\", map);\n+\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, true);\n+           String xmlData = os.toString(\"UTF-8\");\n+\n+           assertNotNull(xmlData);\n+           assertFalse(xmlData.equals(\"\"));\n+\n+           String a = xmlData.split(\"<A>\")[1].split(\"</A>\")[0].trim();\n+           String euro = a.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+           assertEquals(\"1\",euro);\n+           \n+           parseXML(xmlData);\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+\n+   public void testXmlExportCompare_Bug_55923() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55923.xlsx\");\n+\n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+\n+           XSSFMap map = mapInfo.getXSSFMapById(4);\n+\n+           assertNotNull(\"XSSFMap is null\", map);\n+\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           assertEquals(0, exporter.compare(\"\", \"\"));\n+           assertEquals(0, exporter.compare(\"/\", \"/\"));\n+           assertEquals(0, exporter.compare(\"//\", \"//\"));\n+           assertEquals(0, exporter.compare(\"/a/\", \"/b/\"));\n+           \n+           assertEquals(-1, exporter.compare(\"/ns1:Entry/ns1:A/ns1:B/ns1:C/ns1:E/ns1:EUR\",\n+                                           \"/ns1:Entry/ns1:A/ns1:B/ns1:C/ns1:E/ns1:CHF\"));\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+   \n+   public void testXmlExportSchemaOrderingBug_Bugzilla_55923() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55923.xlsx\");\n+\n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+\n+           XSSFMap map = mapInfo.getXSSFMapById(4);\n+\n+           assertNotNull(\"XSSFMap is null\", map);\n+\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, true);\n+           String xmlData = os.toString(\"UTF-8\");\n+\n+           assertNotNull(xmlData);\n+           assertFalse(xmlData.equals(\"\"));\n+           \n+           String a = xmlData.split(\"<A>\")[1].split(\"</A>\")[0].trim();\n+           String a_b = a.split(\"<B>\")[1].split(\"</B>\")[0].trim();\n+           String a_b_c = a_b.split(\"<C>\")[1].split(\"</C>\")[0].trim();\n+           String a_b_c_e = a_b_c.split(\"<E>\")[1].split(\"</EA>\")[0].trim();\n+           String a_b_c_e_euro = a_b_c_e.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+           String a_b_c_e_chf = a_b_c_e.split(\"<CHF>\")[1].split(\"</CHF>\")[0].trim();\n+           \n+           assertEquals(\"1\",a_b_c_e_euro);\n+           assertEquals(\"2\",a_b_c_e_chf);\n+           \n+           String a_b_d = a_b.split(\"<D>\")[1].split(\"</Dd>\")[0].trim();\n+           String a_b_d_e = a_b_d.split(\"<E>\")[1].split(\"</EA>\")[0].trim();\n+           \n+           String a_b_d_e_euro = a_b_d_e.split(\"<EUR>\")[1].split(\"</EUR>\")[0].trim();\n+           String a_b_d_e_chf = a_b_d_e.split(\"<CHF>\")[1].split(\"</CHF>\")[0].trim();\n+           \n+           assertEquals(\"3\",a_b_d_e_euro);\n+           assertEquals(\"4\",a_b_d_e_chf);\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+   \n+   private void parseXML(String xmlData) throws IOException, SAXException, ParserConfigurationException {\n+       DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n+       docBuilderFactory.setNamespaceAware(true);\n+       docBuilderFactory.setValidating(false);\n+       DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n+       docBuilder.setEntityResolver(new DummyEntityResolver());\n+\n+       docBuilder.parse(new ByteArrayInputStream(xmlData.getBytes(\"UTF-8\")));\n+   }\n+\n+   private static class DummyEntityResolver implements EntityResolver\n+   {\n+       @Override\n+       public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException\n+       {\n+           return null;\n+       }\n+   }\n+   \n+   public void testExportDataTypes() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55923.xlsx\");\n+       \n+       Sheet sheet = wb.getSheetAt(0);\n+       Row row = sheet.getRow(0);\n+       \n+       Cell cString = row.createCell(0);\n+       cString.setCellValue(\"somestring\");\n+       cString.setCellType(XSSFCell.CELL_TYPE_STRING);\n+       \n+       Cell cBoolean = row.createCell(1);\n+       cBoolean.setCellValue(true);\n+       cBoolean.setCellType(XSSFCell.CELL_TYPE_BOOLEAN);\n+       \n+       Cell cError = row.createCell(2);\n+       cError.setCellType(XSSFCell.CELL_TYPE_ERROR);\n+       \n+       Cell cFormulaString = row.createCell(3);\n+       cFormulaString.setCellFormula(\"A1\");\n+       cFormulaString.setCellType(XSSFCell.CELL_TYPE_FORMULA);\n+       \n+       Cell cFormulaNumeric = row.createCell(4);\n+       cFormulaNumeric.setCellFormula(\"F1\");\n+       cFormulaNumeric.setCellType(XSSFCell.CELL_TYPE_FORMULA);\n+       \n+       Cell cNumeric = row.createCell(5);\n+       cNumeric.setCellValue(1.2);\n+       cNumeric.setCellType(XSSFCell.CELL_TYPE_NUMERIC);\n+       \n+       Cell cDate = row.createCell(6);\n+       cDate.setCellValue(new Date());\n+       cDate.setCellType(XSSFCell.CELL_TYPE_NUMERIC);\n+       \n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+\n+           XSSFMap map = mapInfo.getXSSFMapById(4);\n+\n+           assertNotNull(\"XSSFMap is null\", map);\n+\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, true);\n+           String xmlData = os.toString(\"UTF-8\");\n+\n+           assertNotNull(xmlData);\n+           assertFalse(xmlData.equals(\"\"));\n+           \n+           parseXML(xmlData);\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+\n+   public void testValidateFalse() throws Exception {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"55923.xlsx\");\n+\n+       boolean found = false;\n+       for (POIXMLDocumentPart p : wb.getRelations()) {\n+\n+           if (!(p instanceof MapInfo)) {\n+               continue;\n+           }\n+           MapInfo mapInfo = (MapInfo) p;\n+\n+           XSSFMap map = mapInfo.getXSSFMapById(4);\n+\n+           assertNotNull(\"XSSFMap is null\", map);\n+\n+           XSSFExportToXml exporter = new XSSFExportToXml(map);\n+           ByteArrayOutputStream os = new ByteArrayOutputStream();\n+           exporter.exportToXML(os, false);\n+           String xmlData = os.toString(\"UTF-8\");\n+\n+           assertNotNull(xmlData);\n+           assertFalse(xmlData.equals(\"\"));\n+           \n+           parseXML(xmlData);\n+           \n+           found = true;\n+       }\n+       assertTrue(found);\n+   }\n+}",
                "raw_url": "https://github.com/apache/poi/raw/cc51d8eeb62ca138b72d37785cade16d7267a859/src/ooxml/testcases/org/apache/poi/xssf/extractor/TestXSSFExportToXML.java.orig",
                "sha": "4e112d268ffd4692d400da2eba2bf06f56e0c3ff",
                "status": "added"
            }
        ],
        "message": "Bug 56169: Fix NPE during export to XML with xs:all\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1577907 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/847e64cf35eae288d1de1e9551c2b8e6d383336b",
        "patched_files": [
            "XSSFExportToXml.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFExportToXML.java"
        ]
    },
    "poi_ce1f30e": {
        "bug_id": "poi_ce1f30e",
        "commit": "https://github.com/apache/poi/commit/ce1f30e57f21c03df2694d9139c8113afa5df5ca",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/java/org/apache/poi/hssf/usermodel/HSSFEvaluationWorkbook.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFEvaluationWorkbook.java?ref=ce1f30e57f21c03df2694d9139c8113afa5df5ca",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFEvaluationWorkbook.java",
                "patch": "@@ -265,10 +265,15 @@ private int getSheetExtIx(SheetIdentifier sheetIden) {\n         return extIx;\n     }\n \n+    @Override\n     public SpreadsheetVersion getSpreadsheetVersion(){\n         return SpreadsheetVersion.EXCEL97;\n     }\n \n+    /**\n+      * @throws IllegalStateException: data tables are not supported in Excel 97-2003 format\n+      */\n+    @Override\n     public Table getTable(String name) {\n         throw new IllegalStateException(\"XSSF-style tables are not supported for HSSF\");\n     }",
                "raw_url": "https://github.com/apache/poi/raw/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/java/org/apache/poi/hssf/usermodel/HSSFEvaluationWorkbook.java",
                "sha": "037d55d9f0af199d3bbfb5e572792436b4a7c36c",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/java/org/apache/poi/xssf/usermodel/BaseXSSFEvaluationWorkbook.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/BaseXSSFEvaluationWorkbook.java?ref=ce1f30e57f21c03df2694d9139c8113afa5df5ca",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/BaseXSSFEvaluationWorkbook.java",
                "patch": "@@ -353,8 +353,11 @@ public XSSFName createName() {\n      * @return The Data table in the workbook named <tt>name</tt>, or <tt>null</tt> if no table is named <tt>name</tt>.\n      * @since 3.15 beta 2\n      */\n+    @Override\n     public XSSFTable getTable(String name) {\n-        return getTableCache().get(name.toLowerCase(Locale.ROOT));\n+        if (name == null) return null;\n+        String lname = name.toLowerCase(Locale.ROOT);\n+        return getTableCache().get(lname);\n     }\n     \n     public UDFFinder getUDFFinder(){",
                "raw_url": "https://github.com/apache/poi/raw/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/java/org/apache/poi/xssf/usermodel/BaseXSSFEvaluationWorkbook.java",
                "sha": "8ef2c54392b4a4d67f8b4f4d95af18f43655b8dd",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java?ref=ce1f30e57f21c03df2694d9139c8113afa5df5ca",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java",
                "patch": "@@ -2271,7 +2271,7 @@ public SpreadsheetVersion getSpreadsheetVersion() {\n      * @since 3.15 beta 2\n      */\n     public XSSFTable getTable(String name) {\n-        if (sheets != null) {\n+        if (name != null && sheets != null) {\n             for (XSSFSheet sheet : sheets) {\n                 for (XSSFTable tbl : sheet.getTables()) {\n                     if (name.equalsIgnoreCase(tbl.getName())) {",
                "raw_url": "https://github.com/apache/poi/raw/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java",
                "sha": "74974fe7d2bb712f9172ffb8785e6e651e04ad15",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java?ref=ce1f30e57f21c03df2694d9139c8113afa5df5ca",
                "deletions": 1,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java",
                "patch": "@@ -1137,7 +1137,7 @@ public void bug49966() throws IOException {\n     }\n \n     /**\n-     * See bug #50829\n+     * See bug #50829 test data tables\n      */\n     @Test\n     public void tables() throws IOException {",
                "raw_url": "https://github.com/apache/poi/raw/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java",
                "sha": "868557ae158badebfd7d72fea8c92b39dca6a60b",
                "status": "modified"
            },
            {
                "additions": 32,
                "blob_url": "https://github.com/apache/poi/blob/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java?ref=ce1f30e57f21c03df2694d9139c8113afa5df5ca",
                "deletions": 0,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "patch": "@@ -1107,4 +1107,36 @@ public void testCloseBeforeWrite() throws IOException {\n \t\t\tassertTrue(\"Had: \" + e.getCause(), e.getCause() instanceof IOException);\n \t\t}\n \t}\n+\n+    /**\n+     * See bug #57840 test data tables\n+     */\n+    @Test\n+    public void getTable() throws IOException {\n+       XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"WithTable.xlsx\");\n+       XSSFTable table1 = wb.getTable(\"Tabella1\");\n+       assertNotNull(\"Tabella1 was not found in workbook\", table1);\n+       assertEquals(\"Table name\", \"Tabella1\", table1.getName());\n+       assertEquals(\"Sheet name\", \"Foglio1\", table1.getSheetName());\n+\n+       // Table lookup should be case-insensitive\n+       assertSame(\"Case insensitive table name lookup\", table1, wb.getTable(\"TABELLA1\"));\n+\n+       // If workbook does not contain any data tables matching the provided name, getTable should return null\n+       assertNull(\"Null table name should not throw NPE\", wb.getTable(null));\n+       assertNull(\"Should not be able to find non-existent table\", wb.getTable(\"Foglio1\"));\n+\n+       // If a table is added after getTable is called it should still be reachable by XSSFWorkbook.getTable\n+       // This test makes sure that if any caching is done that getTable never uses a stale cache\n+       XSSFTable table2 = wb.getSheet(\"Foglio2\").createTable();\n+       table2.setName(\"Table2\");\n+       assertSame(\"Did not find Table2\", table2, wb.getTable(\"Table2\"));\n+       \n+       // If table name is modified after getTable is called, the table can only be found by its new name\n+       // This test makes sure that if any caching is done that getTable never uses a stale cache\n+       table1.setName(\"Table1\");\n+       assertSame(\"Did not find Tabella1 renamed to Table1\", table1, wb.getTable(\"TABLE1\"));\n+\n+       wb.close();\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/ce1f30e57f21c03df2694d9139c8113afa5df5ca/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java",
                "sha": "f4a4687522690d4131a3f33e6d40d73ff1610494",
                "status": "modified"
            }
        ],
        "message": "bug 57840: check for null to avoid NPE; add unit test for XSSFWorkbook.getTable()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/xssf_structured_references@1747621 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/4b6821c5ae734d2d80cc4bd31229a390caef0068",
        "patched_files": [
            "XSSFWorkbook.java",
            "HSSFEvaluationWorkbook.java",
            "XSSFSheet.java",
            "BaseXSSFEvaluationWorkbook.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFSheet.java",
            "TestXSSFWorkbook.java"
        ]
    },
    "poi_cfde042": {
        "bug_id": "poi_cfde042",
        "commit": "https://github.com/apache/poi/commit/cfde042818dbac0b16072a05f31f78e5b72ccce3",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/cfde042818dbac0b16072a05f31f78e5b72ccce3/src/java/org/apache/poi/hssf/record/NameRecord.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/NameRecord.java?ref=cfde042818dbac0b16072a05f31f78e5b72ccce3",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/NameRecord.java",
                "patch": "@@ -755,7 +755,8 @@ public String toString() {\n             .append(\"\\n\");\n         buffer.append(\"    .Name (Unicode text)  = \").append( field_12_name_text )\n             .append(\"\\n\");\n-        buffer.append(\"    .Formula data (RPN token array without size field)      = \").append( HexDump.toHex( field_13_raw_name_definition ) )\n+        buffer.append(\"    .Formula data (RPN token array without size field)      = \").append( HexDump.toHex( \n+                       ((field_13_raw_name_definition != null) ? field_13_raw_name_definition : new byte[0] ) ) )\n             .append(\"\\n\");\n         buffer.append(\"    .Menu text (Unicode string without length field)        = \").append( field_14_custom_menu_text )\n             .append(\"\\n\");",
                "raw_url": "https://github.com/apache/poi/raw/cfde042818dbac0b16072a05f31f78e5b72ccce3/src/java/org/apache/poi/hssf/record/NameRecord.java",
                "sha": "be3c9d6c05a67b1f6a243643189256456433bbff",
                "status": "modified"
            }
        ],
        "message": "fixed bug http://nagoya.apache.org/bugzilla/show_bug.cgi?id=13092 NameRecord\nno longer throws an NPE.  I think this is due to unknown PTGs. -Andy\nPR:\nObtained from:\nSubmitted by:\nReviewed by:\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@352875 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e191c1b553a363ce49f79c2419d6862fa89243b9",
        "patched_files": [
            "NameRecord.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestNameRecord.java"
        ]
    },
    "poi_d1a2126": {
        "bug_id": "poi_d1a2126",
        "commit": "https://github.com/apache/poi/commit/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java?ref=d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb",
                "deletions": 0,
                "filename": "src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java",
                "patch": "@@ -866,6 +866,9 @@ public int getLastRowNum() {\n \n     public short getLeftCol() {\n         String cellRef = worksheet.getSheetViews().getSheetViewArray(0).getTopLeftCell();\n+        if(cellRef == null) {\n+        \treturn 0;\n+        }\n         CellReference cellReference = new CellReference(cellRef);\n         return cellReference.getCol();\n     }\n@@ -1178,6 +1181,9 @@ public boolean getScenarioProtect() {\n      */\n     public short getTopRow() {\n         String cellRef = getSheetTypeSheetView().getTopLeftCell();\n+        if(cellRef == null) {\n+        \treturn 0;\n+        }\n         CellReference cellReference = new CellReference(cellRef);\n         return (short) cellReference.getRow();\n     }",
                "raw_url": "https://github.com/apache/poi/raw/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb/src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFSheet.java",
                "sha": "58b4aebd9e73934484b0615e83de47a86012dc97",
                "status": "modified"
            },
            {
                "additions": 77,
                "blob_url": "https://github.com/apache/poi/blob/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java",
                "changes": 81,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java?ref=d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb",
                "deletions": 4,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java",
                "patch": "@@ -17,18 +17,29 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.xssf.usermodel;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.List;\n \n-import org.apache.poi.ss.usermodel.*;\n+import org.apache.poi.hssf.HSSFTestDataSamples;\n+import org.apache.poi.hssf.record.PasswordRecord;\n+import org.apache.poi.ss.usermodel.BaseTestSheet;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.CreationHelper;\n+import org.apache.poi.ss.usermodel.RichTextString;\n+import org.apache.poi.ss.usermodel.Sheet;\n+import org.apache.poi.ss.usermodel.Workbook;\n import org.apache.poi.ss.util.CellRangeAddress;\n+import org.apache.poi.util.HexDump;\n import org.apache.poi.xssf.XSSFITestDataProvider;\n import org.apache.poi.xssf.XSSFTestDataSamples;\n+import org.apache.poi.xssf.model.CalculationChain;\n import org.apache.poi.xssf.model.CommentsTable;\n import org.apache.poi.xssf.model.StylesTable;\n-import org.apache.poi.xssf.model.CalculationChain;\n+import org.apache.poi.xssf.streaming.SXSSFWorkbook;\n import org.apache.poi.xssf.usermodel.helpers.ColumnHelper;\n-import org.apache.poi.util.HexDump;\n-import org.apache.poi.hssf.record.PasswordRecord;\n import org.openxmlformats.schemas.spreadsheetml.x2006.main.*;\n \n \n@@ -1091,4 +1102,66 @@ public void testSetForceFormulaRecalculation() {\n          sheet = workbook.getSheet(\"Sheet 1\");\n          assertEquals(false, sheet.getForceFormulaRecalculation());\n \t}\n+\n+    public void test54607() {\n+    \t// run with the file provided in the Bug-Report\n+    \trunGetTopRow(\"54607.xlsx\", true, 1, 0, 0);    \t\n+    \trunGetLeftCol(\"54607.xlsx\", true, 0, 0, 0);    \t\n+    \t\n+    \t// run with some other flie to see \n+    \trunGetTopRow(\"54436.xlsx\", true, 0);\n+    \trunGetLeftCol(\"54436.xlsx\", true, 0);\n+    \trunGetTopRow(\"TwoSheetsNoneHidden.xlsx\", true, 0, 0);\n+    \trunGetLeftCol(\"TwoSheetsNoneHidden.xlsx\", true, 0, 0);\n+    \trunGetTopRow(\"TwoSheetsNoneHidden.xls\", false, 0, 0);\n+    \trunGetLeftCol(\"TwoSheetsNoneHidden.xls\", false, 0, 0);\n+    }\n+\n+\tprivate void runGetTopRow(String file, boolean isXSSF, int... topRows) {\n+\t\tfinal Workbook wb;\n+\t\tif(isXSSF) {\n+\t\t\twb = XSSFTestDataSamples.openSampleWorkbook(file);\n+\t\t} else {\n+\t\t\twb = HSSFTestDataSamples.openSampleWorkbook(file);\n+\t\t}\n+    \tfor (int si = 0; si < wb.getNumberOfSheets(); si++) {\n+    \t\tSheet sh = wb.getSheetAt(si);\n+    \t\tassertNotNull(sh.getSheetName());\n+    \t\tassertEquals(\"Did not match for sheet \" + si, topRows[si], sh.getTopRow());\n+    \t}\n+\n+    \t// for XSSF also test with SXSSF\n+    \tif(isXSSF) {\n+\t\t\tWorkbook swb = new SXSSFWorkbook((XSSFWorkbook) wb);\n+\t    \tfor (int si = 0; si < swb.getNumberOfSheets(); si++) {\n+\t    \t\tSheet sh = swb.getSheetAt(si);\n+\t    \t\tassertNotNull(sh.getSheetName());\n+\t    \t\tassertEquals(\"Did not match for sheet \" + si, topRows[si], sh.getTopRow());\n+\t    \t}\n+    \t}\n+\t}\n+\n+\tprivate void runGetLeftCol(String file, boolean isXSSF, int... topRows) {\n+\t\tfinal Workbook wb;\n+\t\tif(isXSSF) {\n+\t\t\twb = XSSFTestDataSamples.openSampleWorkbook(file);\n+\t\t} else {\n+\t\t\twb = HSSFTestDataSamples.openSampleWorkbook(file);\n+\t\t}\n+    \tfor (int si = 0; si < wb.getNumberOfSheets(); si++) {\n+    \t\tSheet sh = wb.getSheetAt(si);\n+    \t\tassertNotNull(sh.getSheetName());\n+    \t\tassertEquals(\"Did not match for sheet \" + si, topRows[si], sh.getLeftCol());\n+    \t}\n+\n+    \t// for XSSF also test with SXSSF\n+    \tif(isXSSF) {\n+\t\t\tWorkbook swb = new SXSSFWorkbook((XSSFWorkbook) wb);\n+\t    \tfor (int si = 0; si < swb.getNumberOfSheets(); si++) {\n+\t    \t\tSheet sh = swb.getSheetAt(si);\n+\t    \t\tassertNotNull(sh.getSheetName());\n+\t    \t\tassertEquals(\"Did not match for sheet \" + si, topRows[si], sh.getLeftCol());\n+\t    \t}\n+    \t}\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFSheet.java",
                "sha": "8c96fb817ae6258f3b9bab0b43e53579f4e5cb19",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb/test-data/spreadsheet/54607.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/54607.xlsx?ref=d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb",
                "deletions": 0,
                "filename": "test-data/spreadsheet/54607.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/d1a21260ca0ee0ca110a0f320fb1bd542c0a24fb/test-data/spreadsheet/54607.xlsx",
                "sha": "bdfe143bb3be84b388ea778715c52d95af9bf809",
                "status": "added"
            }
        ],
        "message": "Bug 54607: Add unit test and fix NPE for getTopRow() and getLeftCol()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1493686 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/fa1977747654220d2b1afc0077e61fa91e2e4587",
        "patched_files": [
            "XSSFSheet.java",
            "54607.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFSheet.java"
        ]
    },
    "poi_d20bc98": {
        "bug_id": "poi_d20bc98",
        "commit": "https://github.com/apache/poi/commit/d20bc98f70e62e2468d72d86b874b3ac23da0f0e",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/d20bc98f70e62e2468d72d86b874b3ac23da0f0e/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java?ref=d20bc98f70e62e2468d72d86b874b3ac23da0f0e",
                "deletions": 3,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java",
                "patch": "@@ -98,13 +98,18 @@ public XSLFSheet getSheet() {\n     }\n \n     @Override\n-    public String getShapeName(){\n-        return getCNvPr().getName();\n+    public String getShapeName() {\n+        CTNonVisualDrawingProps nonVisualDrawingProps = getCNvPr();\n+        return nonVisualDrawingProps == null ? null : nonVisualDrawingProps.getName();\n     }\n \n     @Override\n     public int getShapeId() {\n-        return (int)getCNvPr().getId();\n+        CTNonVisualDrawingProps nonVisualDrawingProps = getCNvPr();\n+        if (nonVisualDrawingProps == null) {\n+            throw new IllegalStateException(\"no underlying shape exists\");\n+        }\n+        return Math.toIntExact(nonVisualDrawingProps.getId());\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/poi/raw/d20bc98f70e62e2468d72d86b874b3ac23da0f0e/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFShape.java",
                "sha": "8227b46460b815faeadd37f6306ab74df70cee4c",
                "status": "modified"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/poi/blob/d20bc98f70e62e2468d72d86b874b3ac23da0f0e/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTableRow.java",
                "changes": 31,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTableRow.java?ref=d20bc98f70e62e2468d72d86b874b3ac23da0f0e",
                "deletions": 6,
                "filename": "src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTableRow.java",
                "patch": "@@ -16,12 +16,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n ==================================================================== */\n package org.apache.poi.xslf.usermodel;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.io.IOException;\n import java.util.List;\n@@ -128,4 +123,28 @@ public void getXmlObject() {\n         assertNotNull(ctrow);\n     }\n \n+\n+    @Test\n+    public void getShapeNameOfCells() throws Exception {\n+        try(XMLSlideShow ss1 = XSLFTestDataSamples.openSampleDocument(\"table_test.pptx\")) {\n+            for (XSLFSlide slide : ss1.getSlides()) {\n+                for (XSLFShape shape : slide.getShapes()) {\n+                    assertEquals(\"Table 3\", shape.getShapeName());\n+                    if (shape instanceof XSLFTable) {\n+                        for (XSLFTableRow row : ((XSLFTable) shape).getRows()) {\n+                            for (XSLFTableCell cell : row.getCells()) {\n+                                assertNull(cell.getShapeName()); // Do not throw NPE\n+                                try {\n+                                    cell.getShapeId();\n+                                    fail(\"expected getShapeId to fail\");\n+                                } catch (IllegalStateException ise) {\n+                                    // expected\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/d20bc98f70e62e2468d72d86b874b3ac23da0f0e/src/ooxml/testcases/org/apache/poi/xslf/usermodel/TestXSLFTableRow.java",
                "sha": "47345133b8454db903fa98d06ebc2ffc110745d0",
                "status": "modified"
            }
        ],
        "message": "[bug-63498] NPE when calling getShapeName on XSLFTableCell. Thanks to Mate Borcsok.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1861172 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/3e061ca74c0dc49a3e9639d02429c935e0cf58bf",
        "patched_files": [
            "XSLFTableRow.java",
            "XSLFShape.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSLFShape.java",
            "TestXSLFTableRow.java"
        ]
    },
    "poi_d52b3ed": {
        "bug_id": "poi_d52b3ed",
        "commit": "https://github.com/apache/poi/commit/d52b3ed45202198b67610d262988b6d7d80ff5e8",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/d52b3ed45202198b67610d262988b6d7d80ff5e8/src/java/org/apache/poi/hssf/record/LbsDataSubRecord.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/LbsDataSubRecord.java?ref=d52b3ed45202198b67610d262988b6d7d80ff5e8",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/hssf/record/LbsDataSubRecord.java",
                "patch": "@@ -243,7 +243,7 @@ public String toString() {\n         sb.append(\"[ftLbsData]\\n\");\r\n         sb.append(\"    .unknownShort1 =\").append(HexDump.shortToHex(_cbFContinued)).append(\"\\n\");\r\n         sb.append(\"    .formula        = \").append('\\n');\r\n-        sb.append(_linkPtg.toString()).append(_linkPtg.getRVAType()).append('\\n');\r\n+        if(_linkPtg != null) sb.append(_linkPtg.toString()).append(_linkPtg.getRVAType()).append('\\n');\r\n         sb.append(\"    .nEntryCount   =\").append(HexDump.shortToHex(_cLines)).append(\"\\n\");\r\n         sb.append(\"    .selEntryIx    =\").append(HexDump.shortToHex(_iSel)).append(\"\\n\");\r\n         sb.append(\"    .style         =\").append(HexDump.shortToHex(_flags)).append(\"\\n\");\r",
                "raw_url": "https://github.com/apache/poi/raw/d52b3ed45202198b67610d262988b6d7d80ff5e8/src/java/org/apache/poi/hssf/record/LbsDataSubRecord.java",
                "sha": "57ebb203965e77c9c65682c02b5eda99c16a7068",
                "status": "modified"
            }
        ],
        "message": "fixed possible NPE in LbsDataSubRecord.toString()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@892461 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/bed01967f0dd8dcc012b5011f6778f51d2d573c9",
        "patched_files": [
            "LbsDataSubRecord.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestLbsDataSubRecord.java"
        ]
    },
    "poi_d5e6485": {
        "bug_id": "poi_d5e6485",
        "commit": "https://github.com/apache/poi/commit/d5e64851f69b76853abfa69d9d69a0904e603991",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/d5e64851f69b76853abfa69d9d69a0904e603991/src/scratchpad/src/org/apache/poi/hslf/model/SimpleShape.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/SimpleShape.java?ref=d5e64851f69b76853abfa69d9d69a0904e603991",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/SimpleShape.java",
                "patch": "@@ -314,12 +314,17 @@ protected Record getClientDataRecord(int recordType) {\n         return null;\n     }\n \n+    /**\n+     * Search for EscherClientDataRecord, if found, convert its contents into an array of HSLF records\n+     *\n+     * @return an array of HSLF records contained in the shape's EscherClientDataRecord or <code>null</code>\n+     */\n     protected Record[] getClientRecords() {\n         if(_clientData == null){\n             EscherRecord r = Shape.getEscherChild(getSpContainer(), EscherClientDataRecord.RECORD_ID);\n             //ddf can return EscherContainerRecord with recordId=EscherClientDataRecord.RECORD_ID\n             //convert in to EscherClientDataRecord on the fly\n-            if(!(r instanceof EscherClientDataRecord)){\n+            if(r != null && !(r instanceof EscherClientDataRecord)){\n                 byte[] data = r.serialize();\n                 r = new EscherClientDataRecord();\n                 r.fillFields(data, 0, new DefaultEscherRecordFactory());",
                "raw_url": "https://github.com/apache/poi/raw/d5e64851f69b76853abfa69d9d69a0904e603991/src/scratchpad/src/org/apache/poi/hslf/model/SimpleShape.java",
                "sha": "b0bdcadcca7d2c8bf6c595bdb9f40d076ac78400",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/d5e64851f69b76853abfa69d9d69a0904e603991/src/scratchpad/testcases/org/apache/poi/hslf/extractor/TestExtractor.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/extractor/TestExtractor.java?ref=d5e64851f69b76853abfa69d9d69a0904e603991",
                "deletions": 8,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/extractor/TestExtractor.java",
                "patch": "@@ -237,14 +237,7 @@ public void testWithComments() throws Exception {\n \t\tfilename = dirname + \"/45543.ppt\";\n \t\tppe = new PowerPointExtractor(filename);\n \n-\t\ttry {\n-\t\t\ttext = ppe.getText();\n-\t\t} catch (NullPointerException e) {\n-\t\t\t// TODO - fix this failing test\n-\t\t\t// This test was failing here with NPE as at svn r745972.\n-\t\t\t// At that time, the class name was 'TextExtractor' which caused the build script to skip it\n-\t\t\treturn; // for the moment skip the rest of this test.\n-\t\t}\n+        text = ppe.getText();\n \t\tassertFalse(\"Comments not in by default\", contains(text, \"testdoc\"));\n \t\t\n \t\tppe.setCommentsByDefault(true);",
                "raw_url": "https://github.com/apache/poi/raw/d5e64851f69b76853abfa69d9d69a0904e603991/src/scratchpad/testcases/org/apache/poi/hslf/extractor/TestExtractor.java",
                "sha": "9c213d4773cdcfd835e47f4007da4e12a887e2ee",
                "status": "modified"
            }
        ],
        "message": "fixed a possible NPE in SimpleShape.getClientRecords()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@746238 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/b0d231437c30a3fc89d1e9c06265f09166e39698",
        "patched_files": [
            "SimpleShape.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestExtractor.java"
        ]
    },
    "poi_d76ef83": {
        "bug_id": "poi_d76ef83",
        "commit": "https://github.com/apache/poi/commit/d76ef83dc62f185838acf7c3731fb486c8b36b1a",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/d76ef83dc62f185838acf7c3731fb486c8b36b1a/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFRun.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFRun.java?ref=d76ef83dc62f185838acf7c3731fb486c8b36b1a",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFRun.java",
                "patch": "@@ -1077,7 +1077,7 @@ public String text() {\n                 if (ctfldChar.getFldCharType() == STFldCharType.BEGIN) {\n                     if (ctfldChar.getFfData() != null) {\n                         for (CTFFCheckBox checkBox : ctfldChar.getFfData().getCheckBoxList()) {\n-                            if (checkBox.getDefault().getVal() == STOnOff.X_1) {\n+                            if (checkBox.getDefault() != null && checkBox.getDefault().getVal() == STOnOff.X_1) {\n                                 text.append(\"|X|\");\n                             } else {\n                                 text.append(\"|_|\");",
                "raw_url": "https://github.com/apache/poi/raw/d76ef83dc62f185838acf7c3731fb486c8b36b1a/src/ooxml/java/org/apache/poi/xwpf/usermodel/XWPFRun.java",
                "sha": "c2718ab43ca6ee5b4732bf3084de3a1f1307ac88",
                "status": "modified"
            }
        ],
        "message": "BUG-60286 avoid NPE XWPFRun.  Didn't add unit test or document...didn't seem to be worth it.\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1765863 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/489bebba0ee749cc961ce092bb4007d7c23343d2",
        "patched_files": [
            "XWPFRun.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXWPFRun.java"
        ]
    },
    "poi_d8edfc6": {
        "bug_id": "poi_d8edfc6",
        "commit": "https://github.com/apache/poi/commit/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde/src/java/org/apache/poi/ss/formula/functions/Sumif.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/functions/Sumif.java?ref=d8edfc6e370f0ba54ae13a7c78d6486e465a8dde",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/ss/formula/functions/Sumif.java",
                "patch": "@@ -69,6 +69,12 @@ private static ValueEval eval(int srcRowIndex, int srcColumnIndex, ValueEval arg\n \t\t\tAreaEval aeSum) {\n \t\t// TODO - junit to prove last arg must be srcColumnIndex and not srcRowIndex\n \t\tI_MatchPredicate mp = Countif.createCriteriaPredicate(arg1, srcRowIndex, srcColumnIndex);\n+\t\t\n+\t\t// handle empty cells\n+\t\tif(mp == null) {\n+\t\t    return NumberEval.ZERO;\n+\t\t}\n+\n \t\tdouble result = sumMatchingCells(aeRange, mp, aeSum);\n \t\treturn new NumberEval(result);\n \t}",
                "raw_url": "https://github.com/apache/poi/raw/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde/src/java/org/apache/poi/ss/formula/functions/Sumif.java",
                "sha": "977647fd20669fada7ce71433b4ee96529905996",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/poi/blob/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java?ref=d8edfc6e370f0ba54ae13a7c78d6486e465a8dde",
                "deletions": 2,
                "filename": "src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "patch": "@@ -1538,7 +1538,6 @@ public void testBug53798XLS() throws IOException {\n      * SUMIF was throwing a NPE on some formulas\n      */\n     @Test\n-    @Ignore(\"This bug is still to be fixed\")\n     public void testBug56420SumIfNPE() throws Exception {\n         XSSFWorkbook wb = XSSFTestDataSamples.openSampleWorkbook(\"56420.xlsx\");\n         \n@@ -1548,7 +1547,8 @@ public void testBug56420SumIfNPE() throws Exception {\n         Row r = sheet.getRow(2);\n         Cell c = r.getCell(2);\n         assertEquals(\"SUMIF($A$1:$A$4,A3,$B$1:$B$4)\", c.getCellFormula());\n-        evaluator.evaluateInCell(c);\n+        Cell eval = evaluator.evaluateInCell(c);\n+        assertEquals(0.0, eval.getNumericCellValue(), 0.0001);\n     }\n \n     private void bug53798Work(Workbook wb, File xlsOutput) throws IOException {",
                "raw_url": "https://github.com/apache/poi/raw/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde/src/ooxml/testcases/org/apache/poi/xssf/usermodel/TestXSSFBugs.java",
                "sha": "646fe8e5bb7ae1a11e6fb49f0cc7b1c769b6dc33",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/poi/blob/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde/src/testcases/org/apache/poi/ss/formula/functions/TestSumif.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/formula/functions/TestSumif.java?ref=d8edfc6e370f0ba54ae13a7c78d6486e465a8dde",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/ss/formula/functions/TestSumif.java",
                "patch": "@@ -21,6 +21,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import junit.framework.TestCase;\n \n import org.apache.poi.ss.formula.eval.AreaEval;\n+import org.apache.poi.ss.formula.eval.BlankEval;\n+import org.apache.poi.ss.formula.eval.ErrorEval;\n import org.apache.poi.ss.formula.eval.NumberEval;\n import org.apache.poi.ss.formula.eval.NumericValueEval;\n import org.apache.poi.ss.formula.eval.StringEval;\n@@ -107,4 +109,11 @@ public void testCriteriaArgRange() {\n \n \t\tconfirmDouble(60, ve);\n \t}\n+\n+\tpublic void testEvaluateException() {\n+\t    assertEquals(ErrorEval.VALUE_INVALID, invokeSumif(-1, -1, BlankEval.instance, new NumberEval(30.0)));\n+        assertEquals(ErrorEval.VALUE_INVALID, invokeSumif(-1, -1, BlankEval.instance, new NumberEval(30.0), new NumberEval(30.0)));\n+        assertEquals(ErrorEval.VALUE_INVALID, invokeSumif(-1, -1, new NumberEval(30.0), BlankEval.instance, new NumberEval(30.0)));\n+        assertEquals(ErrorEval.VALUE_INVALID, invokeSumif(-1, -1, new NumberEval(30.0), new NumberEval(30.0), BlankEval.instance));\n+\t}\n }",
                "raw_url": "https://github.com/apache/poi/raw/d8edfc6e370f0ba54ae13a7c78d6486e465a8dde/src/testcases/org/apache/poi/ss/formula/functions/TestSumif.java",
                "sha": "c761d22f1ad7e37851652509fda682f94faf1036",
                "status": "modified"
            }
        ],
        "message": "Bug 56420: Fix possible NullPointerException when empty cell is included in Sumif calculation\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1686564 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/5562f55c778d87e674cce40b1ea72d2511849ce5",
        "patched_files": [
            "Sumif.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestXSSFBugs.java",
            "TestSumif.java"
        ]
    },
    "poi_d991494": {
        "bug_id": "poi_d991494",
        "commit": "https://github.com/apache/poi/commit/d99149477c5455104cf9fc892b03157d338d12c4",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/d99149477c5455104cf9fc892b03157d338d12c4/src/documentation/content/xdocs/changes.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=d99149477c5455104cf9fc892b03157d338d12c4",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -37,6 +37,7 @@\n \n \t\t<!-- Don't forget to update status.xml too! -->\n         <release version=\"3.5-beta4\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46122 - fixed Picture.draw to skip rendering if picture data was not found</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">15716 - memory usage optimisation - converted Ptg arrays into Formula objects</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">46065 - added implementation for VALUE function</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45966 - added implementation for FIND function</action>",
                "raw_url": "https://github.com/apache/poi/raw/d99149477c5455104cf9fc892b03157d338d12c4/src/documentation/content/xdocs/changes.xml",
                "sha": "ea02f6f303e5e114ddbc78c096ec72458161fe88",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/d99149477c5455104cf9fc892b03157d338d12c4/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=d99149477c5455104cf9fc892b03157d338d12c4",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \t<!-- Don't forget to update changes.xml too! -->\n     <changes>\n         <release version=\"3.5-beta4\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46122 - fixed Picture.draw to skip rendering if picture data was not found</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">15716 - memory usage optimisation - converted Ptg arrays into Formula objects</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">46065 - added implementation for VALUE function</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45966 - added implementation for FIND function</action>",
                "raw_url": "https://github.com/apache/poi/raw/d99149477c5455104cf9fc892b03157d338d12c4/src/documentation/content/xdocs/status.xml",
                "sha": "5a2cbf648135ae7fb4a1298951df501be082d15f",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/poi/blob/d99149477c5455104cf9fc892b03157d338d12c4/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java?ref=d99149477c5455104cf9fc892b03157d338d12c4",
                "deletions": 2,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "patch": "@@ -196,10 +196,14 @@ protected EscherBSERecord getEscherBSERecord(){\n         Document doc = ppt.getDocumentRecord();\n         EscherContainerRecord dggContainer = doc.getPPDrawingGroup().getDggContainer();\n         EscherContainerRecord bstore = (EscherContainerRecord)Shape.getEscherChild(dggContainer, EscherContainerRecord.BSTORE_CONTAINER);\n-\n+        if(bstore == null) {\n+            logger.log(POILogger.DEBUG, \"EscherContainerRecord.BSTORE_CONTAINER was not found \");\n+            return null;\n+        }\n         List lst = bstore.getChildRecords();\n         int idx = getPictureIndex();\n         if (idx == 0){\n+            logger.log(POILogger.DEBUG, \"picture index was not found, returning \");\n             return null;\n         } else {\n             return (EscherBSERecord)lst.get(idx-1);\n@@ -263,7 +267,7 @@ public void draw(Graphics2D graphics){\n         ShapePainter.paint(this, graphics);\n \n         PictureData data = getPictureData();\n-        data.draw(graphics, this);\n+        if(data != null) data.draw(graphics, this);\n \n         graphics.setTransform(at);\n     }",
                "raw_url": "https://github.com/apache/poi/raw/d99149477c5455104cf9fc892b03157d338d12c4/src/scratchpad/src/org/apache/poi/hslf/model/Picture.java",
                "sha": "db86f288115979d558d2632a44d1824cdb936d5e",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/d99149477c5455104cf9fc892b03157d338d12c4/src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java?ref=d99149477c5455104cf9fc892b03157d338d12c4",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java",
                "patch": "@@ -20,9 +20,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \r\n import java.io.FileOutputStream;\r\n import java.io.File;\r\n+import java.io.IOException;\r\n import java.awt.*;\r\n+import java.awt.image.BufferedImage;\r\n \r\n import org.apache.poi.hslf.usermodel.SlideShow;\r\n+import org.apache.poi.hslf.usermodel.PictureData;\r\n import org.apache.poi.hslf.HSLFSlideShow;\r\n import org.apache.poi.ddf.EscherBSERecord;\r\n \r\n@@ -70,4 +73,24 @@ public void testMultiplePictures() throws Exception {\n \r\n     }\r\n \r\n+    /**\r\n+     * Picture#getEscherBSERecord threw NullPointerException if EscherContainerRecord.BSTORE_CONTAINER\r\n+     * was not found. The correct behaviour is to return null.\r\n+     */\r\n+    public void test46122() throws IOException {\r\n+        SlideShow ppt = new SlideShow();\r\n+        Slide slide = ppt.createSlide();\r\n+\r\n+        Picture pict = new Picture(-1); //index to non-existing picture data\r\n+        pict.setSheet(slide);\r\n+        PictureData data = pict.getPictureData();\r\n+        assertNull(data);\r\n+\r\n+        BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);\r\n+        Graphics2D graphics = img.createGraphics();\r\n+        pict.draw(graphics);\r\n+\r\n+        assertTrue(\"no errors rendering Picture with null data\", true);\r\n+    }\r\n+\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/d99149477c5455104cf9fc892b03157d338d12c4/src/scratchpad/testcases/org/apache/poi/hslf/model/TestPicture.java",
                "sha": "b4a362ae8dced821e36ae1817b46df838bb6d0a1",
                "status": "modified"
            }
        ],
        "message": "fixed #46122: Picture#getEscherBSERecord threw NullPointerException if EscherContainerRecord.BSTORE_CONTAINER was not found\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@710114 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/bf3699bb17e47f3b9e3cb39a1c6b5b26645aa203",
        "patched_files": [
            "status.java",
            "Picture.java",
            "changes.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestPicture.java"
        ]
    },
    "poi_e538572": {
        "bug_id": "poi_e538572",
        "commit": "https://github.com/apache/poi/commit/e538572beaf8a8159aee5d8d3d58669952b7eaf6",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/e538572beaf8a8159aee5d8d3d58669952b7eaf6/src/java/org/apache/poi/ss/usermodel/DateUtil.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/usermodel/DateUtil.java?ref=e538572beaf8a8159aee5d8d3d58669952b7eaf6",
                "deletions": 7,
                "filename": "src/java/org/apache/poi/ss/usermodel/DateUtil.java",
                "patch": "@@ -146,7 +146,7 @@ private static double internalGetExcelDate(Calendar date, boolean use1904windowi\n      *  @return Java representation of the date, or null if date is not a valid Excel date\n      */\n     public static Date getJavaDate(double date, TimeZone tz) {\n-       return getJavaDate(date, false, tz);\n+       return getJavaDate(date, false, tz, false);\n     }\n     /**\n      *  Given an Excel date with using 1900 date windowing, and\n@@ -166,9 +166,9 @@ public static Date getJavaDate(double date, TimeZone tz) {\n      *  @see java.util.TimeZone\n      */\n     public static Date getJavaDate(double date) {\n-        return getJavaDate(date, (TimeZone)null);\n+        return getJavaDate(date, false, null, false);\n     }\n-    \n+\n     /**\n      *  Given an Excel date with either 1900 or 1904 date windowing,\n      *  converts it to a java.util.Date.\n@@ -185,7 +185,7 @@ public static Date getJavaDate(double date) {\n      *  @return Java representation of the date, or null if date is not a valid Excel date\n      */\n     public static Date getJavaDate(double date, boolean use1904windowing, TimeZone tz) {\n-        return getJavaCalendar(date, use1904windowing, tz, false).getTime();\n+        return getJavaDate(date, use1904windowing, tz, false);\n     }\n     \n     /**\n@@ -205,7 +205,8 @@ public static Date getJavaDate(double date, boolean use1904windowing, TimeZone t\n      *  @return Java representation of the date, or null if date is not a valid Excel date\n      */\n     public static Date getJavaDate(double date, boolean use1904windowing, TimeZone tz, boolean roundSeconds) {\n-        return getJavaCalendar(date, use1904windowing, tz, roundSeconds).getTime();\n+        Calendar calendar = getJavaCalendar(date, use1904windowing, tz, roundSeconds);\n+        return calendar == null ? null : calendar.getTime();\n     }\n     \n     /**\n@@ -228,10 +229,9 @@ public static Date getJavaDate(double date, boolean use1904windowing, TimeZone t\n      *  @see java.util.TimeZone\n      */\n     public static Date getJavaDate(double date, boolean use1904windowing) {\n-        return getJavaCalendar(date, use1904windowing, null, false).getTime();\n+        return getJavaDate(date, use1904windowing, null, false);\n     }\n \n-\n     public static void setCalendar(Calendar calendar, int wholeDays,\n             int millisecondsInDay, boolean use1904windowing, boolean roundSeconds) {\n         int startYear = 1900;",
                "raw_url": "https://github.com/apache/poi/raw/e538572beaf8a8159aee5d8d3d58669952b7eaf6/src/java/org/apache/poi/ss/usermodel/DateUtil.java",
                "sha": "ca1d7d46599ee988c72b52c23db661a7c6dc503d",
                "status": "modified"
            },
            {
                "additions": 92,
                "blob_url": "https://github.com/apache/poi/blob/e538572beaf8a8159aee5d8d3d58669952b7eaf6/src/testcases/org/apache/poi/ss/usermodel/TestDateUtil.java",
                "changes": 92,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/ss/usermodel/TestDateUtil.java?ref=e538572beaf8a8159aee5d8d3d58669952b7eaf6",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/ss/usermodel/TestDateUtil.java",
                "patch": "@@ -0,0 +1,92 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.ss.usermodel;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import org.junit.Test;\n+\n+public class TestDateUtil {\n+\n+    @Test\n+    public void getJavaDate_InvalidValue() {\n+        double dateValue = -1;\n+        TimeZone tz = TimeZone.getDefault();\n+        boolean use1904windowing = false;\n+        boolean roundSeconds = false;\n+\n+        assertEquals(null, DateUtil.getJavaDate(dateValue));\n+        assertEquals(null, DateUtil.getJavaDate(dateValue, tz));\n+        assertEquals(null, DateUtil.getJavaDate(dateValue, use1904windowing));\n+        assertEquals(null, DateUtil.getJavaDate(dateValue, use1904windowing, tz));\n+        assertEquals(null, DateUtil.getJavaDate(dateValue, use1904windowing, tz, roundSeconds));\n+    }\n+\n+    @Test\n+    public void getJavaDate_ValidValue() {\n+        double dateValue = 0;\n+        TimeZone tz = TimeZone.getDefault();\n+        boolean use1904windowing = false;\n+        boolean roundSeconds = false;\n+\n+        Calendar calendar = Calendar.getInstance(tz);\n+        calendar.set(1900, 0, 0, 0, 0, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        Date date = calendar.getTime();\n+\n+        assertEquals(date, DateUtil.getJavaDate(dateValue));\n+        assertEquals(date, DateUtil.getJavaDate(dateValue, tz));\n+        assertEquals(date, DateUtil.getJavaDate(dateValue, use1904windowing));\n+        assertEquals(date, DateUtil.getJavaDate(dateValue, use1904windowing, tz));\n+        assertEquals(date, DateUtil.getJavaDate(dateValue, use1904windowing, tz, roundSeconds));\n+    }\n+\n+    @Test\n+    public void getJavaCalendar_InvalidValue() {\n+        double dateValue = -1;\n+        TimeZone tz = TimeZone.getDefault();\n+        boolean use1904windowing = false;\n+        boolean roundSeconds = false;\n+\n+        assertEquals(null, DateUtil.getJavaCalendar(dateValue));\n+        assertEquals(null, DateUtil.getJavaCalendar(dateValue, use1904windowing));\n+        assertEquals(null, DateUtil.getJavaCalendar(dateValue, use1904windowing, tz));\n+        assertEquals(null, DateUtil.getJavaCalendar(dateValue, use1904windowing, tz, roundSeconds));\n+    }\n+\n+    @Test\n+    public void getJavaCalendar_ValidValue() {\n+        double dateValue = 0;\n+        TimeZone tz = TimeZone.getDefault();\n+        boolean use1904windowing = false;\n+        boolean roundSeconds = false;\n+\n+        Calendar calendar = Calendar.getInstance(tz);\n+        calendar.set(1900, 0, 0, 0, 0, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+\n+        assertEquals(calendar, DateUtil.getJavaCalendar(dateValue));\n+        assertEquals(calendar, DateUtil.getJavaCalendar(dateValue, use1904windowing));\n+        assertEquals(calendar, DateUtil.getJavaCalendar(dateValue, use1904windowing, tz));\n+        assertEquals(calendar, DateUtil.getJavaCalendar(dateValue, use1904windowing, tz, roundSeconds));\n+    }\n+}",
                "raw_url": "https://github.com/apache/poi/raw/e538572beaf8a8159aee5d8d3d58669952b7eaf6/src/testcases/org/apache/poi/ss/usermodel/TestDateUtil.java",
                "sha": "870cd9cb3564a97c240e7f4067c4a06645192442",
                "status": "added"
            }
        ],
        "message": "Patch from Ren\u00e9 Scheibe from bug #57512 - Fix potential NPE in DateUtil for invalid dates\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1682796 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/e5c1a36de91909b8f6b938f6f0c9d9f260368d48",
        "patched_files": [
            "DateUtil.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestDateUtil.java"
        ]
    },
    "poi_e79cc21": {
        "bug_id": "poi_e79cc21",
        "commit": "https://github.com/apache/poi/commit/e79cc21802e5204a508d177aa3ff5d1331101b46",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/e79cc21802e5204a508d177aa3ff5d1331101b46/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=e79cc21802e5204a508d177aa3ff5d1331101b46",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.7-SNAPSHOT\" date=\"2010-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">48846 - Avoid NPE when finding cell comments</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">49325 - Ensure that CTPhoneticPr is included in poi-ooxml jar</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">49191 - Fixed tests failing in non-english locales</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">48432 - Support for XSSF themes</action>",
                "raw_url": "https://github.com/apache/poi/raw/e79cc21802e5204a508d177aa3ff5d1331101b46/src/documentation/content/xdocs/status.xml",
                "sha": "bb66430073d56969cba62af3b056db0086b95f6a",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/poi/blob/e79cc21802e5204a508d177aa3ff5d1331101b46/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java?ref=e79cc21802e5204a508d177aa3ff5d1331101b46",
                "deletions": 6,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "patch": "@@ -1079,12 +1079,16 @@ protected static HSSFComment findCellComment(InternalSheet sheet, int row, int c\n                 if (note.getRow() == row && note.getColumn() == column) {\n                     if(i < noteTxo.size()) {\n                         TextObjectRecord txo = noteTxo.get(note.getShapeId());\n-                        comment = new HSSFComment(note, txo);\n-                        comment.setRow(note.getRow());\n-                        comment.setColumn((short) note.getColumn());\n-                        comment.setAuthor(note.getAuthor());\n-                        comment.setVisible(note.getFlags() == NoteRecord.NOTE_VISIBLE);\n-                        comment.setString(txo.getStr());\n+                        if(txo != null){\n+                            comment = new HSSFComment(note, txo);\n+                            comment.setRow(note.getRow());\n+                            comment.setColumn(note.getColumn());\n+                            comment.setAuthor(note.getAuthor());\n+                            comment.setVisible(note.getFlags() == NoteRecord.NOTE_VISIBLE);\n+                            comment.setString(txo.getStr());     \n+                        } else{\n+                            log.log(POILogger.WARN, \"Failed to match NoteRecord and TextObjectRecord, row: \" + row + \", column: \" + column);\n+                         }\n                     } else {\n                         log.log(POILogger.WARN, \"Failed to match NoteRecord and TextObjectRecord, row: \" + row + \", column: \" + column);\n                     }",
                "raw_url": "https://github.com/apache/poi/raw/e79cc21802e5204a508d177aa3ff5d1331101b46/src/java/org/apache/poi/hssf/usermodel/HSSFCell.java",
                "sha": "a490d44dfdeaf6529c79d467b51cddf086fe1560",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/e79cc21802e5204a508d177aa3ff5d1331101b46/test-data/spreadsheet/49325.xlsx",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/spreadsheet/49325.xlsx?ref=e79cc21802e5204a508d177aa3ff5d1331101b46",
                "deletions": 0,
                "filename": "test-data/spreadsheet/49325.xlsx",
                "raw_url": "https://github.com/apache/poi/raw/e79cc21802e5204a508d177aa3ff5d1331101b46/test-data/spreadsheet/49325.xlsx",
                "sha": "adcba90b778a8dabc785acebc3a65ca2dfe6e37e",
                "status": "added"
            }
        ],
        "message": "avoid NPE when finding cell comments, Bugzilla 48846\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@947315 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/267082051485df62e56d54486d20e1eb1660fcb1",
        "patched_files": [
            "HSSFCell.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHSSFCell.java"
        ]
    },
    "poi_f1b20be": {
        "bug_id": "poi_f1b20be",
        "commit": "https://github.com/apache/poi/commit/f1b20beca1975cd53c5337ad94b7cc516c158129",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/f1b20beca1975cd53c5337ad94b7cc516c158129/src/documentation/content/xdocs/changes.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/changes.xml?ref=f1b20beca1975cd53c5337ad94b7cc516c158129",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/changes.xml",
                "patch": "@@ -37,6 +37,7 @@\n \n \t\t<!-- Don't forget to update status.xml too! -->\n         <release version=\"3.5-beta5\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46472 - Avoid NPE in HPSFPropertiesExtractor when no properties exist</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">46479 - fixed bugs related to cached formula values and HSSFFormulaEvaluator.evaluateInCell()</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45031 - added implementation for CHOOSE() function</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">46361 - resolve licensing issues around the HDGF resource file, chunks_parse_cmds.tbl</action>",
                "raw_url": "https://github.com/apache/poi/raw/f1b20beca1975cd53c5337ad94b7cc516c158129/src/documentation/content/xdocs/changes.xml",
                "sha": "63002aae8da6e3fc6fd27174c5273bdd4f0e5829",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/f1b20beca1975cd53c5337ad94b7cc516c158129/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=f1b20beca1975cd53c5337ad94b7cc516c158129",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \t<!-- Don't forget to update changes.xml too! -->\n     <changes>\n         <release version=\"3.5-beta5\" date=\"2008-??-??\">\n+           <action dev=\"POI-DEVELOPERS\" type=\"fix\">46472 - Avoid NPE in HPSFPropertiesExtractor when no properties exist</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">46479 - fixed bugs related to cached formula values and HSSFFormulaEvaluator.evaluateInCell()</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"add\">45031 - added implementation for CHOOSE() function</action>\n            <action dev=\"POI-DEVELOPERS\" type=\"fix\">46361 - resolve licensing issues around the HDGF resource file, chunks_parse_cmds.tbl</action>",
                "raw_url": "https://github.com/apache/poi/raw/f1b20beca1975cd53c5337ad94b7cc516c158129/src/documentation/content/xdocs/status.xml",
                "sha": "8878fce6f8cfb4483c3334ae15b1fe0853f78c49",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/poi/blob/f1b20beca1975cd53c5337ad94b7cc516c158129/src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java?ref=f1b20beca1975cd53c5337ad94b7cc516c158129",
                "deletions": 5,
                "filename": "src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java",
                "patch": "@@ -56,11 +56,13 @@ public String getDocumentSummaryInformationText() {\n \t\t\n \t\t// Now custom ones\n \t\tCustomProperties cps = dsi.getCustomProperties();\n-\t\tIterator keys = cps.keySet().iterator();\n-\t\twhile(keys.hasNext()) {\n-\t\t\tString key = (String)keys.next();\n-\t\t\tString val = getPropertyValueText( cps.get(key) );\n-\t\t\ttext.append(key + \" = \" + val + \"\\n\");\n+\t\tif(cps != null) {\n+\t\t\tIterator keys = cps.keySet().iterator();\n+\t\t\twhile(keys.hasNext()) {\n+\t\t\t\tString key = (String)keys.next();\n+\t\t\t\tString val = getPropertyValueText( cps.get(key) );\n+\t\t\t\ttext.append(key + \" = \" + val + \"\\n\");\n+\t\t\t}\n \t\t}\n \t\t\n \t\t// All done",
                "raw_url": "https://github.com/apache/poi/raw/f1b20beca1975cd53c5337ad94b7cc516c158129/src/java/org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java",
                "sha": "ca1cfb46dd62a4ee8543645bd34a68bd7d357245",
                "status": "modified"
            }
        ],
        "message": "Fix bug #46472 - Avoid NPE in HPSFPropertiesExtractor when no properties exist\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@732058 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/96c48a981c682b69a18ae5b77bfea2e07f4cc53f",
        "patched_files": [
            "HPSFPropertiesExtractor.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestHPSFPropertiesExtractor.java"
        ]
    },
    "poi_f89c211": {
        "bug_id": "poi_f89c211",
        "commit": "https://github.com/apache/poi/commit/f89c2115397625fc9194f676eb7e0feb9a03ee95",
        "file": [
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/poi/blob/f89c2115397625fc9194f676eb7e0feb9a03ee95/src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java?ref=f89c2115397625fc9194f676eb7e0feb9a03ee95",
                "deletions": 0,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java",
                "patch": "@@ -179,4 +179,22 @@ public void moveTo(int x, int y){\n         }\n     }\n \n+    /**\n+     * Returns the anchor (the bounding box rectangle) of this shape group.\n+     * All coordinates are expressed in points (72 dpi).\n+     *\n+     * @return the anchor of this shape group\n+     */\n+    public java.awt.Rectangle getAnchor(){\n+        EscherContainerRecord groupInfoContainer = (EscherContainerRecord)_escherContainer.getChild(0);\n+        EscherSpgrRecord spgr = (EscherSpgrRecord)getEscherChild(groupInfoContainer, EscherSpgrRecord.RECORD_ID);\n+        java.awt.Rectangle anchor=null;\n+\n+        anchor = new java.awt.Rectangle();\n+        anchor.x = spgr.getRectX1()*POINT_DPI/MASTER_DPI;\n+        anchor.y = spgr.getRectY1()*POINT_DPI/MASTER_DPI;\n+        anchor.width = (spgr.getRectX2() - spgr.getRectX1())*POINT_DPI/MASTER_DPI;\n+        anchor.height = (spgr.getRectY2() - spgr.getRectY1())*POINT_DPI/MASTER_DPI;\n+        return anchor;\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/f89c2115397625fc9194f676eb7e0feb9a03ee95/src/scratchpad/src/org/apache/poi/hslf/model/ShapeGroup.java",
                "sha": "caea86ae6e17a4d9441266b41a2889ae7df5963b",
                "status": "modified"
            },
            {
                "additions": 23,
                "blob_url": "https://github.com/apache/poi/blob/f89c2115397625fc9194f676eb7e0feb9a03ee95/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java?ref=f89c2115397625fc9194f676eb7e0feb9a03ee95",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "patch": "@@ -140,4 +140,27 @@ public void test42485 () throws Exception {\n         }\r\n     }\r\n \r\n+    /**\r\n+     * Bug 42484: NullPointerException from ShapeGroup.getAnchor()\r\n+     */\r\n+    public void test42484 () throws Exception {\r\n+        FileInputStream is = new FileInputStream(new File(cwd, \"42485.ppt\")); //test file is the same as for bug 42485\r\n+        HSLFSlideShow hslf = new HSLFSlideShow(is);\r\n+        is.close();\r\n+\r\n+        SlideShow ppt = new SlideShow(hslf);\r\n+        Shape[] shape = ppt.getSlides()[0].getShapes();\r\n+        for (int i = 0; i < shape.length; i++) {\r\n+            if(shape[i] instanceof ShapeGroup){\r\n+                ShapeGroup  group = (ShapeGroup)shape[i];\r\n+                assertNotNull(group.getAnchor());\r\n+                Shape[] sh = group.getShapes();\r\n+                for (int j = 0; j < sh.length; j++) {\r\n+                    assertNotNull(sh[j].getAnchor());\r\n+                }\r\n+            }\r\n+        }\r\n+        assertTrue(\"No Exceptions while reading file\", true);\r\n+    }\r\n+\r\n }\r",
                "raw_url": "https://github.com/apache/poi/raw/f89c2115397625fc9194f676eb7e0feb9a03ee95/src/scratchpad/testcases/org/apache/poi/hslf/usermodel/TestBugs.java",
                "sha": "21540fb5e159e2ec881db501ff8f0c8f763007dd",
                "status": "modified"
            }
        ],
        "message": "fixed bug 42484: NullPointerException from ShapeGroup.getAnchor()\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/poi/trunk@541281 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/a0e489bb4d8d27f311cf5be7e75269a8f390ff8b",
        "patched_files": [
            "ShapeGroup.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestShapeGroup.java",
            "TestBugs.java"
        ]
    },
    "poi_f9814d5": {
        "bug_id": "poi_f9814d5",
        "commit": "https://github.com/apache/poi/commit/f9814d58e60840b4069a23409ea7871d3f5e7261",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/java/org/apache/poi/hssf/record/DVRecord.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/record/DVRecord.java?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 2,
                "filename": "src/java/org/apache/poi/hssf/record/DVRecord.java",
                "patch": "@@ -187,10 +187,13 @@ protected void fillFields(RecordInputStream in)\n        this.field_not_used_2 = in.readShort();\n \n        //read sec formula data condition\n-       // Not sure if this was needed or not...\n+       //Not sure if this was needed or not...\n        try {\n            in.skip(this.field_size_sec_formula);\n-       } catch(IOException e) { throw new IllegalStateException(e); } \n+       } catch(IOException e) {\n+           e.printStackTrace();\n+           throw new IllegalStateException(e.getMessage());\n+       }\n \n        token_pos = 0;\n        while (token_pos < this.field_size_sec_formula)",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/java/org/apache/poi/hssf/record/DVRecord.java",
                "sha": "a7b68a1743ff9f4d7cb13df8bec30e1ad40ca62c",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "changes": 41,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 20,
                "filename": "src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "patch": "@@ -1748,27 +1748,28 @@ public void autoSizeColumn(short column) {\n                 } else if (cell.getCellType() == HSSFCell.CELL_TYPE_BOOLEAN) {\n                     sval = String.valueOf(cell.getBooleanCellValue());\n                 }\n+                if(sval != null) {\n+                    String txt = sval + defaultChar;\n+                    str = new AttributedString(txt);\n+                    copyAttributes(font, str, 0, txt.length());\n \n-                String txt = sval + defaultChar;\n-                str = new AttributedString(txt);\n-                copyAttributes(font, str, 0, txt.length());\n-\n-                layout = new TextLayout(str.getIterator(), frc);\n-                if(style.getRotation() != 0){\n-                    /*\n-                     * Transform the text using a scale so that it's height is increased by a multiple of the leading,\n-                     * and then rotate the text before computing the bounds. The scale results in some whitespace around\n-                     * the unrotated top and bottom of the text that normally wouldn't be present if unscaled, but\n-                     * is added by the standard Excel autosize.\n-                     */\n-                    AffineTransform trans = new AffineTransform();\n-                    trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n-                    trans.concatenate(\n-                    AffineTransform.getScaleInstance(1, fontHeightMultiple)\n-                    );\n-                    width = Math.max(width, layout.getOutline(trans).getBounds().getWidth() / defaultCharWidth);\n-                } else {\n-                    width = Math.max(width, layout.getBounds().getWidth() / defaultCharWidth);\n+                    layout = new TextLayout(str.getIterator(), frc);\n+                    if(style.getRotation() != 0){\n+                        /*\n+                         * Transform the text using a scale so that it's height is increased by a multiple of the leading,\n+                         * and then rotate the text before computing the bounds. The scale results in some whitespace around\n+                         * the unrotated top and bottom of the text that normally wouldn't be present if unscaled, but\n+                         * is added by the standard Excel autosize.\n+                         */\n+                        AffineTransform trans = new AffineTransform();\n+                        trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n+                        trans.concatenate(\n+                        AffineTransform.getScaleInstance(1, fontHeightMultiple)\n+                        );\n+                        width = Math.max(width, layout.getOutline(trans).getBounds().getWidth() / defaultCharWidth);\n+                    } else {\n+                        width = Math.max(width, layout.getBounds().getWidth() / defaultCharWidth);\n+                    }\n                 }\n             }\n ",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/java/org/apache/poi/hssf/usermodel/HSSFSheet.java",
                "sha": "0250a4cbaab23ea830e847e518fbbb8a01d4d79a",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/data/37684-1.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/37684-1.xls?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/37684-1.xls",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/data/37684-1.xls",
                "sha": "a59769eb39c37bf489de8c1bba0d89882c2c120e",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/data/37684-2.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/37684-2.xls?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/37684-2.xls",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/data/37684-2.xls",
                "sha": "b17d0fa2271f9033a8252641b78ea4103cf0c32a",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/data/TestDataValidation.xls",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/data/TestDataValidation.xls?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/data/TestDataValidation.xls",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/data/TestDataValidation.xls",
                "sha": "a9460375cb21958270dc7234ef79e5152de86bab",
                "status": "modified"
            },
            {
                "additions": 57,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "changes": 57,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 0,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "patch": "@@ -954,6 +954,63 @@ public void test44201() throws Exception {\n         assertTrue(\"No Exceptions while reading file\", true);\n \n     }\n+\n+    /**\n+     * Bug 37684  : Unhandled Continue Record Error\n+     */\n+    public void test37684 () throws Exception {\n+        FileInputStream in = new FileInputStream(new File(cwd, \"37684-1.xls\"));\n+        HSSFWorkbook wb = new HSSFWorkbook(in);\n+        in.close();\n+\n+        assertTrue(\"No exceptions while reading workbook\", true);\n+\n+        //serialize and read again\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        wb.write(out);\n+        out.close();\n+        assertTrue(\"No exceptions while saving workbook\", true);\n+\n+        wb = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n+        assertTrue(\"No exceptions while reading saved stream\", true);\n+\n+\n+        in = new FileInputStream(new File(cwd, \"37684-2.xls\"));\n+        wb = new HSSFWorkbook(in);\n+        in.close();\n+\n+        assertTrue(\"No exceptions while reading workbook\", true);\n+\n+        //serialize and read again\n+        out = new ByteArrayOutputStream();\n+        wb.write(out);\n+        out.close();\n+        assertTrue(\"No exceptions while saving workbook\", true);\n+\n+        wb = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n+        assertTrue(\"No exceptions while reading saved stream\", true);\n+    }\n+\n+    /**\n+     * Bug 41139: Constructing HSSFWorkbook is failed,threw threw ArrayIndexOutOfBoundsException for creating UnknownRecord\n+     */\n+    public void test41139() throws Exception {\n+        FileInputStream in = new FileInputStream(new File(cwd, \"41139.xls\"));\n+        HSSFWorkbook wb = new HSSFWorkbook(in);\n+        in.close();\n+\n+        assertTrue(\"No Exceptions while reading file\", true);\n+\n+        //serialize and read again\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        wb.write(out);\n+        out.close();\n+\n+        wb = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n+        assertTrue(\"No Exceptions while reading file\", true);\n+\n+    }\n+\n }\n \n ",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/usermodel/TestBugs.java",
                "sha": "d0dc7203e1f127ee18b15cc86723e8f31093673c",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/usermodel/TestUnfixedBugs.java",
                "changes": 82,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/testcases/org/apache/poi/hssf/usermodel/TestUnfixedBugs.java?ref=f9814d58e60840b4069a23409ea7871d3f5e7261",
                "deletions": 74,
                "filename": "src/testcases/org/apache/poi/hssf/usermodel/TestUnfixedBugs.java",
                "patch": "@@ -44,79 +44,13 @@ public TestUnfixedBugs(String arg0) {\n \tprotected String cwd = System.getProperty(\"HSSF.testdata.path\");\n \t\n \t \n-\t /* ArrayIndexOutOfBound in BOFRecord */  \n-\t public void test28772() throws java.io.IOException {\n-       String filename = System.getProperty(\"HSSF.testdata.path\");\n-       filename=filename+\"/28772.xls\";\n-       FileInputStream in = new FileInputStream(filename);\n-       HSSFWorkbook wb = new HSSFWorkbook(in);\n-       assertTrue(\"Read book fine!\" , true);\n-   }\n-\t \n-\t /**\n-\t     * Bug 37684: Unhandled Continue Record Error\n-\t     * \n-\t     * BUT NOW(Jan07): It triggers bug 41026!!\n-\t     * \n-\t     * java.lang.ArrayIndexOutOfBoundsException: 30\n-         at org.apache.poi.hssf.record.aggregates.ValueRecordsAggregate.rowHasCells(ValueRecordsAggregate.java:219)\n-\t     */\n-\t    public void test37684() throws Exception {\n-\t        FileInputStream in = new FileInputStream(new File(cwd, \"37684.xls\"));\n-\t        HSSFWorkbook wb = new HSSFWorkbook(in);\n-\t        in.close();\n-\n-\t        HSSFSheet sheet = wb.getSheetAt( 0 );\n-\t        assertNotNull(sheet);\n-\n-\t        assertTrue(\"No Exceptions while reading file\", true);\n-\n-\t        //serialize and read again\n-\t        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t        wb.write(out);\n-\t        out.close();\n-\n-\t        wb = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n-\t        assertTrue(\"No Exceptions while reading file\", true);\n-\n-\t    }\n-\t    \n-\t    /**\n-\t     * Bug 41139: Constructing HSSFWorkbook is failed,threw threw ArrayIndexOutOfBoundsException for creating UnknownRecord\n-\t     * \n-\t     * BUT NOW (Jan07): It throws the following in write!!\n-\t     * java.lang.RuntimeException: Coding Error: This method should never be called. This ptg should be converted\n-         at org.apache.poi.hssf.record.formula.AreaNPtg.writeBytes(AreaNPtg.java:54)\n-         at org.apache.poi.hssf.record.formula.Ptg.serializePtgStack(Ptg.java:384)\n-         at org.apache.poi.hssf.record.NameRecord.serialize(NameRecord.java:544)\n-         at org.apache.poi.hssf.model.Workbook.serialize(Workbook.java:757)\n-         at org.apache.poi.hssf.usermodel.HSSFWorkbook.getBytes(HSSFWorkbook.java:952)\n-         at org.apache.poi.hssf.usermodel.HSSFWorkbook.write(HSSFWorkbook.java:898)\n-\n-\t     */\n-\t    public void test41139() throws Exception {\n-\t        FileInputStream in = new FileInputStream(new File(cwd, \"41139.xls\"));\n-\t        HSSFWorkbook wb = new HSSFWorkbook(in);\n-\t        in.close();\n-\n-\t        assertTrue(\"No Exceptions while reading file\", true);\n-\n-\t        //serialize and read again\n-\t        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t        wb.write(out);\n-\t        out.close();\n-\n-\t        wb = new HSSFWorkbook(new ByteArrayInputStream(out.toByteArray()));\n-\t        assertTrue(\"No Exceptions while reading file\", true);\n \n-\t    }\n-\t    \n-\t    public void test43493() throws Exception {\n-\t    \t// Has crazy corrup subrecords on\n-\t    \t//  a EmbeddedObjectRefSubRecord\n-\t    \tFile f = new File(cwd, \"43493.xls\");\n-\t    \tHSSFWorkbook wb = new HSSFWorkbook(\n-\t    \t\t\tnew FileInputStream(f)\n-\t    \t);\n-\t    }\n+    public void test43493() throws Exception {\n+        // Has crazy corrup subrecords on\n+        //  a EmbeddedObjectRefSubRecord\n+        File f = new File(cwd, \"43493.xls\");\n+        HSSFWorkbook wb = new HSSFWorkbook(\n+                new FileInputStream(f)\n+        );\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/f9814d58e60840b4069a23409ea7871d3f5e7261/src/testcases/org/apache/poi/hssf/usermodel/TestUnfixedBugs.java",
                "sha": "3f876c8663932ee765b234e6fcfc7e2a5d65d6a9",
                "status": "modified"
            }
        ],
        "message": "Merged revisions 613395-613401 via svnmerge from \nhttps://svn.apache.org/repos/asf/poi/trunk\n\n........\n  r613395 | yegor | 2008-01-19 15:27:02 +0100 (Sat, 19 Jan 2008) | 1 line\n  \n  use JDK 1.4 compatible constructor for IllegalStateException\n........\n  r613396 | yegor | 2008-01-19 15:28:10 +0100 (Sat, 19 Jan 2008) | 1 line\n  \n  add a check to prevent NPE in HSSFSheet.autoSizeColumn(). See Bug 44246\n........\n  r613400 | yegor | 2008-01-19 15:44:07 +0100 (Sat, 19 Jan 2008) | 1 line\n  \n  added unit tests for closed Bug 37684: Unhandled Continue Record Error\n........\n  r613401 | yegor | 2008-01-19 15:54:06 +0100 (Sat, 19 Jan 2008) | 1 line\n  \n  added a unit test for fixed bug 41139: Constructing HSSFWorkbook is failed,threw threw ArrayIndexOutOfBoundsException for creating UnknownRecord\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/branches/ooxml@613822 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/1ddcefa55ea5a9f8b52b9a51217b83ce3bf95b76",
        "patched_files": [
            "DataValidation.java",
            "37684-1.java",
            "DVRecord.java",
            "HSSFSheet.java",
            "37684-2.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestDataValidation.java",
            "TestBugs.java",
            "TestUnfixedBugs.java",
            "TestHSSFSheet.java"
        ]
    },
    "poi_fac34b6": {
        "bug_id": "poi_fac34b6",
        "commit": "https://github.com/apache/poi/commit/fac34b6740ae41756588c2e04e7087f9b1c238ca",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/poi/blob/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/java/org/apache/poi/poifs/crypt/CryptoFunctions.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/poifs/crypt/CryptoFunctions.java?ref=fac34b6740ae41756588c2e04e7087f9b1c238ca",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/poifs/crypt/CryptoFunctions.java",
                "patch": "@@ -374,6 +374,10 @@ public static void registerBouncyCastle() {\n      * @return the verifier (actually a short value)\n      */\n     public static int createXorVerifier1(String password) {\n+        if (password == null) {\n+            throw new IllegalArgumentException(\"Password cannot be null\");\n+        }\n+\n         byte[] arrByteChars = toAnsiPassword(password);\n         \n         // SET Verifier TO 0x0000\n@@ -412,6 +416,10 @@ public static int createXorVerifier1(String password) {\n      * @see <a href=\"http://www.aspose.com/blogs/aspose-blogs/vladimir-averkin/archive/2007/08/20/funny-how-the-new-powerful-cryptography-implemented-in-word-2007-turns-it-into-a-perfect-tool-for-document-password-removal.html\">Funny: How the new powerful cryptography implemented in Word 2007 turns it into a perfect tool for document password removal.</a>\n      */\n     public static int createXorVerifier2(String password) {\n+        if (password == null) {\n+            throw new IllegalArgumentException(\"Password cannot be null\");\n+        }\n+\n         //Array to hold Key Values\n         byte[] generatedKey = new byte[4];\n ",
                "raw_url": "https://github.com/apache/poi/raw/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/java/org/apache/poi/poifs/crypt/CryptoFunctions.java",
                "sha": "6a16e3f9dc53fd1e650732d75b31ae49216489f1",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/poi/blob/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/java/org/apache/poi/ss/formula/eval/StringEval.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/formula/eval/StringEval.java?ref=fac34b6740ae41756588c2e04e7087f9b1c238ca",
                "deletions": 0,
                "filename": "src/java/org/apache/poi/ss/formula/eval/StringEval.java",
                "patch": "@@ -17,6 +17,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n package org.apache.poi.ss.formula.eval;\n \n+//import org.checkerframework.checker.nullness.qual.NonNull;\n+\n import org.apache.poi.ss.formula.ptg.Ptg;\n import org.apache.poi.ss.formula.ptg.StringPtg;\n \n@@ -27,6 +29,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n \tpublic static final StringEval EMPTY_INSTANCE = new StringEval(\"\");\n \n+\t//@NotNull\n \tprivate final String _value;\n \n \tpublic StringEval(Ptg ptg) {",
                "raw_url": "https://github.com/apache/poi/raw/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/java/org/apache/poi/ss/formula/eval/StringEval.java",
                "sha": "61515e438f795535d31286bbffca9ab3c4607096",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/java/org/apache/poi/ss/usermodel/FractionFormat.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/java/org/apache/poi/ss/usermodel/FractionFormat.java?ref=fac34b6740ae41756588c2e04e7087f9b1c238ca",
                "deletions": 1,
                "filename": "src/java/org/apache/poi/ss/usermodel/FractionFormat.java",
                "patch": "@@ -150,7 +150,7 @@ public String format(Number num) {\n         }\n         \n         //if whole part has to go into the numerator\n-        if (wholePartFormatString.isEmpty()){\n+        if (wholePartFormatString == null || wholePartFormatString.isEmpty()){\n             int trueNum = (fract.getDenominator()*(int)wholePart)+fract.getNumerator();\n             sb.append(trueNum).append(\"/\").append(fract.getDenominator());\n             return sb.toString();",
                "raw_url": "https://github.com/apache/poi/raw/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/java/org/apache/poi/ss/usermodel/FractionFormat.java",
                "sha": "d90d50068b77250376fd40f3db4541f0b1f25fc2",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/ooxml/java/org/apache/poi/poifs/crypt/dsig/services/RelationshipTransformService.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/poifs/crypt/dsig/services/RelationshipTransformService.java?ref=fac34b6740ae41756588c2e04e7087f9b1c238ca",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/poifs/crypt/dsig/services/RelationshipTransformService.java",
                "patch": "@@ -205,7 +205,7 @@ public Data transform(Data data, XMLCryptoContext context) throws TransformExcep\n                 String id = el.getAttribute(\"Id\");\n                 if (sourceIds.contains(id)) {\n                     String targetMode = el.getAttribute(\"TargetMode\");\n-                    if (targetMode.isEmpty()) {\n+                    if (targetMode == null || targetMode.isEmpty()) {\n                         el.setAttribute(\"TargetMode\", \"Internal\");\n                     }\n                     rsList.put(id, el);",
                "raw_url": "https://github.com/apache/poi/raw/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/ooxml/java/org/apache/poi/poifs/crypt/dsig/services/RelationshipTransformService.java",
                "sha": "0b8037d3ae8c52fc61f46cd2435eacdc176feabf",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextRun.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextRun.java?ref=fac34b6740ae41756588c2e04e7087f9b1c238ca",
                "deletions": 1,
                "filename": "src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextRun.java",
                "patch": "@@ -845,7 +845,7 @@ private CTTextFont getCTTextFont(CTTextCharacterProperties props, boolean create\n                 }\n                 // SYMBOL is missing\n                 \n-                if (font == null || !font.isSetTypeface() || font.getTypeface().isEmpty()) {\n+                if (font == null || !font.isSetTypeface() || \"\".equals(font.getTypeface())) {\n                     font = coll.getLatin();\n                 }\n             }",
                "raw_url": "https://github.com/apache/poi/raw/fac34b6740ae41756588c2e04e7087f9b1c238ca/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFTextRun.java",
                "sha": "ea533600840cbe234585b9b7862bc31be3b79675",
                "status": "modified"
            }
        ],
        "message": "cleanup for r1812476: avoid NPEs from string.isEmpty()\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1812516 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/2ef3af567ce9a248dafb5e1f74bdadc5456f9ab0",
        "patched_files": [
            "FractionFormat.java",
            "XSLFTextRun.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestFractionFormat.java",
            "TestXSLFTextRun.java"
        ]
    },
    "poi_facbded": {
        "bug_id": "poi_facbded",
        "commit": "https://github.com/apache/poi/commit/facbded856036a978a7874e1b392f74a9baea252",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/facbded856036a978a7874e1b392f74a9baea252/src/scratchpad/src/org/apache/poi/hslf/model/Table.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hslf/model/Table.java?ref=facbded856036a978a7874e1b392f74a9baea252",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hslf/model/Table.java",
                "patch": "@@ -159,7 +159,7 @@ public int compare( Object o1, Object o2 ) {\n                 return delta;\n             }\n         });\n-        int y0 = -1;\n+        int y0 = (sh.length > 0) ? sh[0].getAnchor().y - 1 : -1;\n         int maxrowlen = 0;\n         ArrayList lst = new ArrayList();\n         ArrayList row = null;",
                "raw_url": "https://github.com/apache/poi/raw/facbded856036a978a7874e1b392f74a9baea252/src/scratchpad/src/org/apache/poi/hslf/model/Table.java",
                "sha": "bafc851824aec3994fc10701467c8ac8f192b020",
                "status": "modified"
            },
            {
                "additions": 32,
                "blob_url": "https://github.com/apache/poi/blob/facbded856036a978a7874e1b392f74a9baea252/src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java?ref=facbded856036a978a7874e1b392f74a9baea252",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java",
                "patch": "@@ -19,18 +19,24 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n \n import junit.framework.TestCase;\n \n+import org.apache.poi.POIDataSamples;\n+import org.apache.poi.hslf.HSLFSlideShow;\n+import org.apache.poi.hslf.extractor.PowerPointExtractor;\n import org.apache.poi.hslf.record.TextHeaderAtom;\n import org.apache.poi.hslf.usermodel.SlideShow;\n+import org.junit.Test;\n \n /**\n  * Test <code>Table</code> object.\n  *\n  * @author Yegor Kozlov\n  */\n public final class TestTable extends TestCase {\n+    private static POIDataSamples _slTests = POIDataSamples.getSlideShowInstance();\n \n     /**\n      * Test that ShapeFactory works properly and returns <code>Table</code>\n@@ -100,4 +106,30 @@ public void testIllegalCOnstruction(){\n \n         }\n     }\n+    \n+    /**\n+     * Bug 57820: initTable throws NullPointerException\n+     * when the table is positioned with its top at -1\n+     */\n+    @Test\n+    public void test57820() throws Exception {\n+        SlideShow ppt = new SlideShow(new HSLFSlideShow(_slTests.openResourceAsStream(\"bug57820-initTableNullRefrenceException.ppt\")));\n+\n+        Slide[] slides = ppt.getSlides();\n+        assertEquals(1, slides.length);\n+\n+        Shape[] shapes = slides[0].getShapes(); //throws NullPointerException\n+\n+        Table tbl = null;\n+        for(int idx = 0; idx < shapes.length; idx++) {\n+            if(shapes[idx] instanceof Table) {\n+                tbl = (Table)shapes[idx];\n+                break;\n+            }\n+        }\n+\n+        assertNotNull(tbl);\n+\n+        assertEquals(-1, tbl.getAnchor().y);\n+    }\n }",
                "raw_url": "https://github.com/apache/poi/raw/facbded856036a978a7874e1b392f74a9baea252/src/scratchpad/testcases/org/apache/poi/hslf/model/TestTable.java",
                "sha": "1740b46b408ebbe682563ce136d3d273ace9a449",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/facbded856036a978a7874e1b392f74a9baea252/test-data/slideshow/bug57820-initTableNullRefrenceException.ppt",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/slideshow/bug57820-initTableNullRefrenceException.ppt?ref=facbded856036a978a7874e1b392f74a9baea252",
                "deletions": 0,
                "filename": "test-data/slideshow/bug57820-initTableNullRefrenceException.ppt",
                "raw_url": "https://github.com/apache/poi/raw/facbded856036a978a7874e1b392f74a9baea252/test-data/slideshow/bug57820-initTableNullRefrenceException.ppt",
                "sha": "e7525f94562996735656bf7724a5389e3f81a949",
                "status": "added"
            }
        ],
        "message": "Patch from  Jon Scharff from bug #57820 - Avoid NPE on HSLF Tables with a top position of -1\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1674441 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/903b5c91c14b39a9f5c971f24fa0e5886c9e60cd",
        "patched_files": [
            "bug57820-initTableNullRefrenceException.java",
            "Table.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestTable.java"
        ]
    },
    "poi_fce9af1": {
        "bug_id": "poi_fce9af1",
        "commit": "https://github.com/apache/poi/commit/fce9af10cf542b064e7e1f58c0ae426743dd218b",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/poi/blob/fce9af10cf542b064e7e1f58c0ae426743dd218b/src/documentation/content/xdocs/status.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/documentation/content/xdocs/status.xml?ref=fce9af10cf542b064e7e1f58c0ae426743dd218b",
                "deletions": 0,
                "filename": "src/documentation/content/xdocs/status.xml",
                "patch": "@@ -34,6 +34,7 @@\n \n     <changes>\n         <release version=\"3.7-beta4\" date=\"2010-??-??\">\n+           <action dev=\"poi-developers\" type=\"fix\">50075 - avoid NPE in ListLevel.getNumberText() when numberText is null </action>\n            <action dev=\"poi-developers\" type=\"fix\">50067 - marked commons-logging and log4j as optional dependencies in POI poms</action>\n            <action dev=\"poi-developers\" type=\"add\">49928 - allow overridden built-in formats in XSSFCellStyle</action>\n            <action dev=\"poi-developers\" type=\"fix\">49919 - support for BorderCode in HWPF</action>",
                "raw_url": "https://github.com/apache/poi/raw/fce9af10cf542b064e7e1f58c0ae426743dd218b/src/documentation/content/xdocs/status.xml",
                "sha": "a0cf1a988a890c999eabfc21609e5d4a76d2a0b1",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/poi/blob/fce9af10cf542b064e7e1f58c0ae426743dd218b/src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java?ref=fce9af10cf542b064e7e1f58c0ae426743dd218b",
                "deletions": 1,
                "filename": "src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java",
                "patch": "@@ -141,7 +141,10 @@ public int getAlignment()\n \n   public String getNumberText()\n   {\n-    return new String(_numberText);\n+    if (_numberText != null)\n+      return new String(_numberText);\n+    else\n+      return null;\n   }\n \n   public void setStartAt(int startAt)",
                "raw_url": "https://github.com/apache/poi/raw/fce9af10cf542b064e7e1f58c0ae426743dd218b/src/scratchpad/src/org/apache/poi/hwpf/model/ListLevel.java",
                "sha": "b8939b381779a78ab7ba8587065e9f23d800551d",
                "status": "modified"
            },
            {
                "additions": 41,
                "blob_url": "https://github.com/apache/poi/blob/fce9af10cf542b064e7e1f58c0ae426743dd218b/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBug50075.java",
                "changes": 41,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBug50075.java?ref=fce9af10cf542b064e7e1f58c0ae426743dd218b",
                "deletions": 0,
                "filename": "src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBug50075.java",
                "patch": "@@ -0,0 +1,41 @@\n+/* ====================================================================\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+==================================================================== */\r\n+package org.apache.poi.hwpf.usermodel;\r\n+\r\n+import org.apache.poi.hwpf.HWPFDocument;\r\n+import org.apache.poi.hwpf.HWPFTestDataSamples;\r\n+import org.apache.poi.hwpf.model.ListFormatOverride;\r\n+import org.apache.poi.hwpf.model.ListLevel;\r\n+\r\n+import junit.framework.TestCase;\r\n+\r\n+public class TestBug50075 extends TestCase\r\n+{\r\n+\r\n+  public void test() {\r\n+    HWPFDocument doc = HWPFTestDataSamples.openSampleFile(\"Bug50075.doc\");\r\n+    Range range = doc.getRange();\r\n+    assertEquals(1, range.numParagraphs());\r\n+    ListEntry entry = (ListEntry) range.getParagraph(0);\r\n+    ListFormatOverride override = doc.getListTables().getOverride(entry.getIlfo());\r\n+    ListLevel level = doc.getListTables().getLevel(override.getLsid(), entry.getIlvl());\r\n+    \r\n+    // the bug reproduces, if this call fails with NullPointerException\r\n+    level.getNumberText();\r\n+  }\r\n+  \r\n+}\r",
                "raw_url": "https://github.com/apache/poi/raw/fce9af10cf542b064e7e1f58c0ae426743dd218b/src/scratchpad/testcases/org/apache/poi/hwpf/usermodel/TestBug50075.java",
                "sha": "24ac72fe402ed7909bef735ee9ac8c53b65985d1",
                "status": "added"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/poi/blob/fce9af10cf542b064e7e1f58c0ae426743dd218b/test-data/document/Bug50075.doc",
                "changes": 0,
                "contents_url": "https://api.github.com/repos/apache/poi/contents/test-data/document/Bug50075.doc?ref=fce9af10cf542b064e7e1f58c0ae426743dd218b",
                "deletions": 0,
                "filename": "test-data/document/Bug50075.doc",
                "raw_url": "https://github.com/apache/poi/raw/fce9af10cf542b064e7e1f58c0ae426743dd218b/test-data/document/Bug50075.doc",
                "sha": "15303a46fe5d99a65208e2525cfde9596fe70016",
                "status": "added"
            }
        ],
        "message": "avoid NPE in ListLevel.getNumberText() when numberText is null, see Bugzilla 50075\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1022456 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/poi/commit/6f62a4397dd74099c83ad49622afc22db28eaaa9",
        "patched_files": [
            "Bug50075.java",
            "ListLevel.java",
            "status.java"
        ],
        "repo": "poi",
        "unit_tests": [
            "TestBug50075.java"
        ]
    }
}