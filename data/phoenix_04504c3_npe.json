[
    {
        "repo": "phoenix",
        "commit": "https://github.com/apache/phoenix/commit/04504c34ffb2e39f38e1b37ee0d7f8f909537616",
        "bug_id": "phoenix_04504c3",
        "message": "PHOENIX-2600 NPE on immutable index creation over transactional table",
        "parent": "https://github.com/apache/phoenix/commit/763a3566ed7ade82b7ffbd56cf90ff264cdbe20a",
        "patched_files": [
            "MutationState.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 23,
                "raw_url": "https://github.com/apache/phoenix/raw/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpsertSelectIT.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpsertSelectIT.java?ref=04504c34ffb2e39f38e1b37ee0d7f8f909537616",
                "filename": "phoenix-core/src/it/java/org/apache/phoenix/end2end/UpsertSelectIT.java",
                "deletions": 0,
                "sha": "364b4232c88bee9e4b0a87498bf944750c345100",
                "blob_url": "https://github.com/apache/phoenix/blob/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpsertSelectIT.java",
                "patch": "@@ -1373,6 +1373,29 @@ public void testUpsertSelectWithFixedWidthNullByteSizeArray() throws Exception {\n         assertEquals(\"[[128,0,0,54], [128,0,4,0]]\", rs.getArray(2).toString());\n     }\n \n+\n+    @Test\n+    public void testParallelUpsertSelect() throws Exception {\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(QueryServices.MUTATE_BATCH_SIZE_ATTRIB, Integer.toString(3));\n+        props.setProperty(QueryServices.SCAN_CACHE_SIZE_ATTRIB, Integer.toString(3));\n+        props.setProperty(QueryServices.SCAN_RESULT_CHUNK_SIZE, Integer.toString(3));\n+        Connection conn = DriverManager.getConnection(getUrl(), props);\n+        conn.setAutoCommit(false);\n+        conn.createStatement().execute(\"CREATE SEQUENCE S1\");\n+        conn.createStatement().execute(\"CREATE TABLE SALTEDT1 (pk INTEGER PRIMARY KEY, val INTEGER) SALT_BUCKETS=4\");\n+        conn.createStatement().execute(\"CREATE TABLE T2 (pk INTEGER PRIMARY KEY, val INTEGER)\");\n+\n+        for (int i = 0; i < 100; i++) {\n+            conn.createStatement().execute(\"UPSERT INTO SALTEDT1 VALUES (NEXT VALUE FOR S1, \" + (i%10) + \")\");\n+        }\n+        conn.commit();\n+        conn.setAutoCommit(true);\n+        int upsertCount = conn.createStatement().executeUpdate(\"UPSERT INTO T2 SELECT pk, val FROM SALTEDT1\");\n+        assertEquals(100,upsertCount);\n+        conn.close();\n+    }\n+\n     private static Connection getConnection(long ts) throws SQLException {\n         Properties props = PropertiesUtil.deepCopy(TestUtil.TEST_PROPERTIES);\n         props.setProperty(PhoenixRuntime.CURRENT_SCN_ATTRIB, Long.toString(ts));",
                "changes": 23
            },
            {
                "status": "modified",
                "additions": 232,
                "raw_url": "https://github.com/apache/phoenix/raw/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/it/java/org/apache/phoenix/tx/TransactionIT.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/it/java/org/apache/phoenix/tx/TransactionIT.java?ref=04504c34ffb2e39f38e1b37ee0d7f8f909537616",
                "filename": "phoenix-core/src/it/java/org/apache/phoenix/tx/TransactionIT.java",
                "deletions": 210,
                "sha": "2794c477af4b0fd12e422b81999a2401a162eae6",
                "blob_url": "https://github.com/apache/phoenix/blob/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/it/java/org/apache/phoenix/tx/TransactionIT.java",
                "patch": "@@ -36,6 +36,12 @@\n import java.util.Map;\n import java.util.Properties;\n \n+import co.cask.tephra.TransactionContext;\n+import co.cask.tephra.TransactionSystemClient;\n+import co.cask.tephra.TxConstants;\n+import co.cask.tephra.hbase11.TransactionAwareHTable;\n+import co.cask.tephra.hbase11.coprocessor.TransactionProcessor;\n+\n import org.apache.hadoop.hbase.HColumnDescriptor;\n import org.apache.hadoop.hbase.HTableDescriptor;\n import org.apache.hadoop.hbase.TableName;\n@@ -68,16 +74,10 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n-import co.cask.tephra.TransactionContext;\n-import co.cask.tephra.TransactionSystemClient;\n-import co.cask.tephra.TxConstants;\n-import co.cask.tephra.hbase11.TransactionAwareHTable;\n-import co.cask.tephra.hbase11.coprocessor.TransactionProcessor;\n-\n public class TransactionIT extends BaseHBaseManagedTimeIT {\n-\t\n-\tprivate static final String FULL_TABLE_NAME = INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + TRANSACTIONAL_DATA_TABLE;\n-\t\n+    \n+    private static final String FULL_TABLE_NAME = INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + TRANSACTIONAL_DATA_TABLE;\n+    \n     @Before\n     public void setUp() throws SQLException {\n         ensureTableCreated(getUrl(), TRANSACTIONAL_DATA_TABLE);\n@@ -90,73 +90,73 @@ public static void doSetup() throws Exception {\n         props.put(QueryServices.TRANSACTIONS_ENABLED, Boolean.toString(true));\n         setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n     }\n-\t\t\n-\t@Test\n-\tpublic void testReadOwnWrites() throws Exception {\n-\t\tString selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n-\t\ttry (Connection conn = DriverManager.getConnection(getUrl())) {\n-\t\t\tconn.setAutoCommit(false);\n-\t\t\tResultSet rs = conn.createStatement().executeQuery(selectSql);\n-\t     \tassertFalse(rs.next());\n-\t     \t\n-\t        String upsert = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk) VALUES(?, ?, ?, ?, ?, ?)\";\n-\t        PreparedStatement stmt = conn.prepareStatement(upsert);\n-\t\t\t// upsert two rows\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.execute();\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 2);\n-\t\t\tstmt.execute();\n-\t        \n-\t        // verify rows can be read even though commit has not been called\n-\t\t\trs = conn.createStatement().executeQuery(selectSql);\n-\t\t\tTestUtil.validateRowKeyColumns(rs, 1);\n-\t\t\tTestUtil.validateRowKeyColumns(rs, 2);\n-\t        assertFalse(rs.next());\n-\t        \n-\t        conn.commit();\n-\t        \n-\t        // verify rows can be read after commit\n-\t        rs = conn.createStatement().executeQuery(selectSql);\n-\t        TestUtil.validateRowKeyColumns(rs, 1);\n-\t        TestUtil.validateRowKeyColumns(rs, 2);\n-\t        assertFalse(rs.next());\n-\t\t}\n-\t}\n-\t\n-\t@Test\n-\tpublic void testTxnClosedCorrecty() throws Exception {\n-\t\tString selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n-\t\ttry (Connection conn = DriverManager.getConnection(getUrl())) {\n-\t\t\tconn.setAutoCommit(false);\n-\t\t\tResultSet rs = conn.createStatement().executeQuery(selectSql);\n-\t     \tassertFalse(rs.next());\n-\t     \t\n-\t        String upsert = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk) VALUES(?, ?, ?, ?, ?, ?)\";\n-\t        PreparedStatement stmt = conn.prepareStatement(upsert);\n-\t\t\t// upsert two rows\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.execute();\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 2);\n-\t\t\tstmt.execute();\n-\t        \n-\t        // verify rows can be read even though commit has not been called\n-\t\t\trs = conn.createStatement().executeQuery(selectSql);\n-\t\t\tTestUtil.validateRowKeyColumns(rs, 1);\n-\t\t\tTestUtil.validateRowKeyColumns(rs, 2);\n-\t        assertFalse(rs.next());\n-\t        \n-\t        conn.close();\n-\t        // wait for any open txns to time out\n-\t        Thread.sleep(DEFAULT_TXN_TIMEOUT_SECONDS*1000+10000);\n-\t        assertTrue(\"There should be no invalid transactions\", txManager.getInvalidSize()==0);\n-\t\t}\n-\t}\n-\t\n+        \n+    @Test\n+    public void testReadOwnWrites() throws Exception {\n+        String selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(false);\n+            ResultSet rs = conn.createStatement().executeQuery(selectSql);\n+            assertFalse(rs.next());\n+            \n+            String upsert = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk) VALUES(?, ?, ?, ?, ?, ?)\";\n+            PreparedStatement stmt = conn.prepareStatement(upsert);\n+            // upsert two rows\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.execute();\n+            TestUtil.setRowKeyColumns(stmt, 2);\n+            stmt.execute();\n+            \n+            // verify rows can be read even though commit has not been called\n+            rs = conn.createStatement().executeQuery(selectSql);\n+            TestUtil.validateRowKeyColumns(rs, 1);\n+            TestUtil.validateRowKeyColumns(rs, 2);\n+            assertFalse(rs.next());\n+            \n+            conn.commit();\n+            \n+            // verify rows can be read after commit\n+            rs = conn.createStatement().executeQuery(selectSql);\n+            TestUtil.validateRowKeyColumns(rs, 1);\n+            TestUtil.validateRowKeyColumns(rs, 2);\n+            assertFalse(rs.next());\n+        }\n+    }\n+    \n+    @Test\n+    public void testTxnClosedCorrecty() throws Exception {\n+        String selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(false);\n+            ResultSet rs = conn.createStatement().executeQuery(selectSql);\n+            assertFalse(rs.next());\n+            \n+            String upsert = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk) VALUES(?, ?, ?, ?, ?, ?)\";\n+            PreparedStatement stmt = conn.prepareStatement(upsert);\n+            // upsert two rows\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.execute();\n+            TestUtil.setRowKeyColumns(stmt, 2);\n+            stmt.execute();\n+            \n+            // verify rows can be read even though commit has not been called\n+            rs = conn.createStatement().executeQuery(selectSql);\n+            TestUtil.validateRowKeyColumns(rs, 1);\n+            TestUtil.validateRowKeyColumns(rs, 2);\n+            assertFalse(rs.next());\n+            \n+            conn.close();\n+            // wait for any open txns to time out\n+            Thread.sleep(DEFAULT_TXN_TIMEOUT_SECONDS*1000+10000);\n+            assertTrue(\"There should be no invalid transactions\", txManager.getInvalidSize()==0);\n+        }\n+    }\n+    \n     @Test\n     public void testDelete() throws Exception {\n         String selectSQL = \"SELECT * FROM \" + FULL_TABLE_NAME;\n         try (Connection conn1 = DriverManager.getConnection(getUrl()); \n-        \t\tConnection conn2 = DriverManager.getConnection(getUrl())) {\n+                Connection conn2 = DriverManager.getConnection(getUrl())) {\n             conn1.setAutoCommit(false);\n             ResultSet rs = conn1.createStatement().executeQuery(selectSQL);\n             assertFalse(rs.next());\n@@ -188,107 +188,107 @@ public void testDelete() throws Exception {\n         }\n     }\n     \n-\t@Test\n-\tpublic void testAutoCommitQuerySingleTable() throws Exception {\n-\t\ttry (Connection conn = DriverManager.getConnection(getUrl())) {\n-\t\t\tconn.setAutoCommit(true);\n-\t\t\t// verify no rows returned\n-\t\t\tResultSet rs = conn.createStatement().executeQuery(\"SELECT * FROM \" + FULL_TABLE_NAME);\n-\t\t\tassertFalse(rs.next());\n-\t\t}\n-\t}\n-\t\n+    @Test\n+    public void testAutoCommitQuerySingleTable() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            // verify no rows returned\n+            ResultSet rs = conn.createStatement().executeQuery(\"SELECT * FROM \" + FULL_TABLE_NAME);\n+            assertFalse(rs.next());\n+        }\n+    }\n+    \n     @Test\n     public void testAutoCommitQueryMultiTables() throws Exception {\n-    \ttry (Connection conn = DriverManager.getConnection(getUrl())) {\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n             conn.setAutoCommit(true);\n             // verify no rows returned\n             ResultSet rs = conn.createStatement().executeQuery(\"SELECT * FROM \" + FULL_TABLE_NAME + \" a JOIN \" + FULL_TABLE_NAME + \" b ON (a.long_pk = b.int_pk)\");\n             assertFalse(rs.next());\n         } \n     }\n     \n-\t@Test\n-\tpublic void testColConflicts() throws Exception {\n-\t\ttry (Connection conn1 = DriverManager.getConnection(getUrl()); \n-        \t\tConnection conn2 = DriverManager.getConnection(getUrl())) {\n-\t\t\tconn1.setAutoCommit(false);\n-\t\t\tconn2.setAutoCommit(false);\n-\t\t\tString selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n-\t\t\tconn1.setAutoCommit(false);\n-\t\t\tResultSet rs = conn1.createStatement().executeQuery(selectSql);\n-\t     \tassertFalse(rs.next());\n-\t\t\t// upsert row using conn1\n-\t\t\tString upsertSql = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk, a.int_col1) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n-\t\t\tPreparedStatement stmt = conn1.prepareStatement(upsertSql);\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.setInt(7, 10);\n-\t        stmt.execute();\n-\t        // upsert row using conn2\n- \t\t\tstmt = conn2.prepareStatement(upsertSql);\n- \t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.setInt(7, 11);\n-\t        stmt.execute();\n- \t        \n- \t        conn1.commit();\n-\t        //second commit should fail\n- \t        try {\n- \t \t        conn2.commit();\n- \t \t        fail();\n- \t        }\t\n- \t        catch (SQLException e) {\n- \t        \tassertEquals(e.getErrorCode(), SQLExceptionCode.TRANSACTION_CONFLICT_EXCEPTION.getErrorCode());\n- \t        }\n-\t\t}\n-\t}\n-\t\n-\tprivate void testRowConflicts() throws Exception {\n-\t\ttry (Connection conn1 = DriverManager.getConnection(getUrl()); \n-        \t\tConnection conn2 = DriverManager.getConnection(getUrl())) {\n-\t\t\tconn1.setAutoCommit(false);\n-\t\t\tconn2.setAutoCommit(false);\n-\t\t\tString selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n-\t\t\tconn1.setAutoCommit(false);\n-\t\t\tResultSet rs = conn1.createStatement().executeQuery(selectSql);\n-\t\t\tboolean immutableRows = conn1.unwrap(PhoenixConnection.class).getTable(new PTableKey(null, FULL_TABLE_NAME)).isImmutableRows();\n-\t     \tassertFalse(rs.next());\n-\t\t\t// upsert row using conn1\n-\t\t\tString upsertSql = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk, a.int_col1) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n-\t\t\tPreparedStatement stmt = conn1.prepareStatement(upsertSql);\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.setInt(7, 10);\n-\t        stmt.execute();\n-\t        // upsert row using conn2\n-\t        upsertSql = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk, b.int_col2) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n- \t\t\tstmt = conn2.prepareStatement(upsertSql);\n- \t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.setInt(7, 11);\n- \t        stmt.execute();\n- \t        \n- \t        conn1.commit();\n-\t        //second commit should fail\n- \t        try {\n- \t \t        conn2.commit();\n- \t \t        if (!immutableRows) fail();\n- \t        }\t\n- \t        catch (SQLException e) {\n- \t        \tif (immutableRows) fail();\n- \t        \tassertEquals(e.getErrorCode(), SQLExceptionCode.TRANSACTION_CONFLICT_EXCEPTION.getErrorCode());\n- \t        }\n-\t\t}\n-\t}\n-\t\n-\t@Test\n-\tpublic void testRowConflictDetected() throws Exception {\n-\t\ttestRowConflicts();\n-\t}\n-\t\n-\t@Test\n-\tpublic void testNoConflictDetectionForImmutableRows() throws Exception {\n-\t\tConnection conn = DriverManager.getConnection(getUrl());\n-\t\tconn.createStatement().execute(\"ALTER TABLE \" + FULL_TABLE_NAME + \" SET IMMUTABLE_ROWS=true\");\n-\t\ttestRowConflicts();\n-\t}\n+    @Test\n+    public void testColConflicts() throws Exception {\n+        try (Connection conn1 = DriverManager.getConnection(getUrl()); \n+                Connection conn2 = DriverManager.getConnection(getUrl())) {\n+            conn1.setAutoCommit(false);\n+            conn2.setAutoCommit(false);\n+            String selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n+            conn1.setAutoCommit(false);\n+            ResultSet rs = conn1.createStatement().executeQuery(selectSql);\n+            assertFalse(rs.next());\n+            // upsert row using conn1\n+            String upsertSql = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk, a.int_col1) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n+            PreparedStatement stmt = conn1.prepareStatement(upsertSql);\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.setInt(7, 10);\n+            stmt.execute();\n+            // upsert row using conn2\n+            stmt = conn2.prepareStatement(upsertSql);\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.setInt(7, 11);\n+            stmt.execute();\n+            \n+            conn1.commit();\n+            //second commit should fail\n+            try {\n+                conn2.commit();\n+                fail();\n+            }   \n+            catch (SQLException e) {\n+                assertEquals(e.getErrorCode(), SQLExceptionCode.TRANSACTION_CONFLICT_EXCEPTION.getErrorCode());\n+            }\n+        }\n+    }\n+    \n+    private void testRowConflicts() throws Exception {\n+        try (Connection conn1 = DriverManager.getConnection(getUrl()); \n+                Connection conn2 = DriverManager.getConnection(getUrl())) {\n+            conn1.setAutoCommit(false);\n+            conn2.setAutoCommit(false);\n+            String selectSql = \"SELECT * FROM \"+FULL_TABLE_NAME;\n+            conn1.setAutoCommit(false);\n+            ResultSet rs = conn1.createStatement().executeQuery(selectSql);\n+            boolean immutableRows = conn1.unwrap(PhoenixConnection.class).getTable(new PTableKey(null, FULL_TABLE_NAME)).isImmutableRows();\n+            assertFalse(rs.next());\n+            // upsert row using conn1\n+            String upsertSql = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk, a.int_col1) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n+            PreparedStatement stmt = conn1.prepareStatement(upsertSql);\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.setInt(7, 10);\n+            stmt.execute();\n+            // upsert row using conn2\n+            upsertSql = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk, b.int_col2) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n+            stmt = conn2.prepareStatement(upsertSql);\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.setInt(7, 11);\n+            stmt.execute();\n+            \n+            conn1.commit();\n+            //second commit should fail\n+            try {\n+                conn2.commit();\n+                if (!immutableRows) fail();\n+            }   \n+            catch (SQLException e) {\n+                if (immutableRows) fail();\n+                assertEquals(e.getErrorCode(), SQLExceptionCode.TRANSACTION_CONFLICT_EXCEPTION.getErrorCode());\n+            }\n+        }\n+    }\n+    \n+    @Test\n+    public void testRowConflictDetected() throws Exception {\n+        testRowConflicts();\n+    }\n+    \n+    @Test\n+    public void testNoConflictDetectionForImmutableRows() throws Exception {\n+        Connection conn = DriverManager.getConnection(getUrl());\n+        conn.createStatement().execute(\"ALTER TABLE \" + FULL_TABLE_NAME + \" SET IMMUTABLE_ROWS=true\");\n+        testRowConflicts();\n+    }\n     \n     @Test\n     public void testNonTxToTxTable() throws Exception {\n@@ -514,33 +514,33 @@ public void testCreateTableToBeTransactional() throws Exception {\n     }\n \n     public void testCurrentDate() throws Exception {\n-\t\tString selectSql = \"SELECT current_date() FROM \"+FULL_TABLE_NAME;\n-\t\ttry (Connection conn = DriverManager.getConnection(getUrl())) {\n-\t\t\tconn.setAutoCommit(false);\n-\t\t\tResultSet rs = conn.createStatement().executeQuery(selectSql);\n-\t     \tassertFalse(rs.next());\n-\t     \t\n-\t        String upsert = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk) VALUES(?, ?, ?, ?, ?, ?)\";\n-\t        PreparedStatement stmt = conn.prepareStatement(upsert);\n-\t\t\t// upsert two rows\n-\t\t\tTestUtil.setRowKeyColumns(stmt, 1);\n-\t\t\tstmt.execute();\n-\t\t\tconn.commit();\n-\t\t\t\n-\t\t\trs = conn.createStatement().executeQuery(selectSql);\n-\t\t\tassertTrue(rs.next());\n-\t\t\tDate date1 = rs.getDate(1);\n-\t     \tassertFalse(rs.next());\n-\t     \t\n-\t     \tThread.sleep(1000);\n-\t     \t\n-\t     \trs = conn.createStatement().executeQuery(selectSql);\n-\t\t\tassertTrue(rs.next());\n-\t\t\tDate date2 = rs.getDate(1);\n-\t     \tassertFalse(rs.next());\n-\t     \tassertTrue(\"current_date() should change while executing multiple statements\", date2.getTime() > date1.getTime());\n-\t\t}\n-\t}\n+        String selectSql = \"SELECT current_date() FROM \"+FULL_TABLE_NAME;\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(false);\n+            ResultSet rs = conn.createStatement().executeQuery(selectSql);\n+            assertFalse(rs.next());\n+            \n+            String upsert = \"UPSERT INTO \" + FULL_TABLE_NAME + \"(varchar_pk, char_pk, int_pk, long_pk, decimal_pk, date_pk) VALUES(?, ?, ?, ?, ?, ?)\";\n+            PreparedStatement stmt = conn.prepareStatement(upsert);\n+            // upsert two rows\n+            TestUtil.setRowKeyColumns(stmt, 1);\n+            stmt.execute();\n+            conn.commit();\n+            \n+            rs = conn.createStatement().executeQuery(selectSql);\n+            assertTrue(rs.next());\n+            Date date1 = rs.getDate(1);\n+            assertFalse(rs.next());\n+            \n+            Thread.sleep(1000);\n+            \n+            rs = conn.createStatement().executeQuery(selectSql);\n+            assertTrue(rs.next());\n+            Date date2 = rs.getDate(1);\n+            assertFalse(rs.next());\n+            assertTrue(\"current_date() should change while executing multiple statements\", date2.getTime() > date1.getTime());\n+        }\n+    }\n     \n     @Test\n     public void testReCreateTxnTableAfterDroppingExistingNonTxnTable() throws SQLException {\n@@ -558,32 +558,32 @@ public void testReCreateTxnTableAfterDroppingExistingNonTxnTable() throws SQLExc\n     \n     @Test\n     public void testRowTimestampDisabled() throws SQLException {\n-    \tProperties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n-\t        conn.setAutoCommit(false);\n-\t        Statement stmt = conn.createStatement();\n-\t        try {\n-\t        \tstmt.execute(\"CREATE TABLE DEMO(k VARCHAR, v VARCHAR, d DATE NOT NULL, CONSTRAINT PK PRIMARY KEY(k,d ROW_TIMESTAMP)) TRANSACTIONAL=true\");\n-\t        \tfail();\n-\t        }\n-        \tcatch(SQLException e) {\n-        \t\tassertEquals(SQLExceptionCode.CANNOT_CREATE_TXN_TABLE_WITH_ROW_TIMESTAMP.getErrorCode(), e.getErrorCode());\n-        \t}\n-\t        stmt.execute(\"CREATE TABLE DEMO(k VARCHAR, v VARCHAR, d DATE NOT NULL, CONSTRAINT PK PRIMARY KEY(k,d ROW_TIMESTAMP))\");\n-\t        try {\n-\t        \tstmt.execute(\"ALTER TABLE DEMO SET TRANSACTIONAL=true\");\n-\t        \tfail();\n-\t        }\n-        \tcatch(SQLException e) {\n-        \t\tassertEquals(SQLExceptionCode.CANNOT_ALTER_TO_BE_TXN_WITH_ROW_TIMESTAMP.getErrorCode(), e.getErrorCode());\n-        \t}\n+            conn.setAutoCommit(false);\n+            Statement stmt = conn.createStatement();\n+            try {\n+                stmt.execute(\"CREATE TABLE DEMO(k VARCHAR, v VARCHAR, d DATE NOT NULL, CONSTRAINT PK PRIMARY KEY(k,d ROW_TIMESTAMP)) TRANSACTIONAL=true\");\n+                fail();\n+            }\n+            catch(SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_CREATE_TXN_TABLE_WITH_ROW_TIMESTAMP.getErrorCode(), e.getErrorCode());\n+            }\n+            stmt.execute(\"CREATE TABLE DEMO(k VARCHAR, v VARCHAR, d DATE NOT NULL, CONSTRAINT PK PRIMARY KEY(k,d ROW_TIMESTAMP))\");\n+            try {\n+                stmt.execute(\"ALTER TABLE DEMO SET TRANSACTIONAL=true\");\n+                fail();\n+            }\n+            catch(SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_ALTER_TO_BE_TXN_WITH_ROW_TIMESTAMP.getErrorCode(), e.getErrorCode());\n+            }\n         }\n     }\n     \n     @Test\n     public void testReadOnlyView() throws Exception {\n         Connection conn = DriverManager.getConnection(getUrl());\n-\t\tString ddl = \"CREATE TABLE t (k INTEGER NOT NULL PRIMARY KEY, v1 DATE) TRANSACTIONAL=true\";\n+        String ddl = \"CREATE TABLE t (k INTEGER NOT NULL PRIMARY KEY, v1 DATE) TRANSACTIONAL=true\";\n         conn.createStatement().execute(ddl);\n         ddl = \"CREATE VIEW v (v2 VARCHAR) AS SELECT * FROM t where k>4\";\n         conn.createStatement().execute(ddl);\n@@ -870,4 +870,26 @@ public void testInflightDeleteNotSeen() throws Exception {\n             assertFalse(rs.next());\n         }\n     }\n+\n+    @Test\n+    public void testParallelUpsertSelect() throws Exception {\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(QueryServices.MUTATE_BATCH_SIZE_ATTRIB, Integer.toString(3));\n+        props.setProperty(QueryServices.SCAN_CACHE_SIZE_ATTRIB, Integer.toString(3));\n+        props.setProperty(QueryServices.SCAN_RESULT_CHUNK_SIZE, Integer.toString(3));\n+        Connection conn = DriverManager.getConnection(getUrl(), props);\n+        conn.setAutoCommit(false);\n+        conn.createStatement().execute(\"CREATE SEQUENCE S1\");\n+        conn.createStatement().execute(\"CREATE TABLE SALTEDT1 (pk INTEGER PRIMARY KEY, val INTEGER) SALT_BUCKETS=4,TRANSACTIONAL=true\");\n+        conn.createStatement().execute(\"CREATE TABLE T2 (pk INTEGER PRIMARY KEY, val INTEGER) TRANSACTIONAL=true\");\n+\n+        for (int i = 0; i < 100; i++) {\n+            conn.createStatement().execute(\"UPSERT INTO SALTEDT1 VALUES (NEXT VALUE FOR S1, \" + (i%10) + \")\");\n+        }\n+        conn.commit();\n+        conn.setAutoCommit(true);\n+        int upsertCount = conn.createStatement().executeUpdate(\"UPSERT INTO T2 SELECT pk, val FROM SALTEDT1\");\n+        assertEquals(100,upsertCount);\n+        conn.close();\n+    }\n }",
                "changes": 442
            },
            {
                "status": "modified",
                "additions": 0,
                "raw_url": "https://github.com/apache/phoenix/raw/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java?ref=04504c34ffb2e39f38e1b37ee0d7f8f909537616",
                "filename": "phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java",
                "deletions": 1,
                "sha": "4c41f82ca3d44238447d32a6c336baad6a08d613",
                "blob_url": "https://github.com/apache/phoenix/blob/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/main/java/org/apache/phoenix/compile/DeleteCompiler.java",
                "patch": "@@ -395,7 +395,6 @@ else if (table.isTransactional() && connection.getSCN() != null) {\n             break;\n         }\n         final QueryPlan dataPlan = dataPlanToBe;\n-        final ColumnResolver resolver = resolverToBe;\n         final boolean hasImmutableIndexes = !immutableIndex.isEmpty();\n         // tableRefs is parallel with queryPlans\n         TableRef[] tableRefs = new TableRef[hasImmutableIndexes ? immutableIndex.size() : 1];",
                "changes": 1
            },
            {
                "status": "modified",
                "additions": 25,
                "raw_url": "https://github.com/apache/phoenix/raw/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java?ref=04504c34ffb2e39f38e1b37ee0d7f8f909537616",
                "filename": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java",
                "deletions": 15,
                "sha": "35a36e60141d6483a82bd9964eea85b7aae1dfa5",
                "blob_url": "https://github.com/apache/phoenix/blob/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java",
                "patch": "@@ -37,6 +37,18 @@\n import javax.annotation.Nonnull;\n import javax.annotation.concurrent.Immutable;\n \n+import co.cask.tephra.Transaction;\n+import co.cask.tephra.Transaction.VisibilityLevel;\n+import co.cask.tephra.TransactionAware;\n+import co.cask.tephra.TransactionCodec;\n+import co.cask.tephra.TransactionConflictException;\n+import co.cask.tephra.TransactionContext;\n+import co.cask.tephra.TransactionFailureException;\n+import co.cask.tephra.TransactionSystemClient;\n+import co.cask.tephra.hbase11.TransactionAwareHTable;\n+import co.cask.tephra.visibility.FenceWait;\n+import co.cask.tephra.visibility.VisibilityFence;\n+\n import org.apache.hadoop.hbase.HConstants;\n import org.apache.hadoop.hbase.client.Delete;\n import org.apache.hadoop.hbase.client.HTableInterface;\n@@ -98,18 +110,6 @@\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n \n-import co.cask.tephra.Transaction;\n-import co.cask.tephra.Transaction.VisibilityLevel;\n-import co.cask.tephra.TransactionAware;\n-import co.cask.tephra.TransactionCodec;\n-import co.cask.tephra.TransactionConflictException;\n-import co.cask.tephra.TransactionContext;\n-import co.cask.tephra.TransactionFailureException;\n-import co.cask.tephra.TransactionSystemClient;\n-import co.cask.tephra.hbase11.TransactionAwareHTable;\n-import co.cask.tephra.visibility.FenceWait;\n-import co.cask.tephra.visibility.VisibilityFence;\n-\n /**\n  * \n  * Tracks the uncommitted state\n@@ -242,7 +242,18 @@ public void commitWriteFence(PTable dataTable) throws SQLException {\n         }\n     }\n     \n-    private void addReadFence(PTable dataTable) throws SQLException {\n+    /**\n+     * Add an entry to the change set representing the DML operation that is starting.\n+     * These entries will not conflict with each other, but they will conflict with a\n+     * DDL operation of creating an index. See {@link #addReadFence(PTable)} and TEPHRA-157\n+     * for more information.\n+     * @param dataTable the table which is doing DML\n+     * @throws SQLException\n+     */\n+    public void addReadFence(PTable dataTable) throws SQLException {\n+        if (this.txContext == null) {\n+            throw new SQLExceptionInfo.Builder(SQLExceptionCode.NULL_TRANSACTION_CONTEXT).build().buildException();\n+        }\n         byte[] logicalKey = SchemaUtil.getTableKey(dataTable);\n         this.txContext.addTransactionAware(VisibilityFence.create(logicalKey));\n         byte[] physicalKey = dataTable.getPhysicalName().getBytes();\n@@ -848,8 +859,7 @@ private void send(Iterator<TableRef> tableRefIterator) throws SQLException {\n \t            final PTable table = tableRef.getTable();\n \t            // Track tables to which we've sent uncommitted data\n \t            if (isTransactional = table.isTransactional()) {\n-\t                addReadFence(table);\n-                    txTableRefs.add(tableRef);\n+\t                txTableRefs.add(tableRef);\n \t                uncommittedPhysicalNames.add(table.getPhysicalName().getString());\n \t            }\n \t            boolean isDataTable = true;",
                "changes": 40
            },
            {
                "status": "modified",
                "additions": 1,
                "raw_url": "https://github.com/apache/phoenix/raw/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/main/java/org/apache/phoenix/jdbc/PhoenixStatement.java",
                "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/jdbc/PhoenixStatement.java?ref=04504c34ffb2e39f38e1b37ee0d7f8f909537616",
                "filename": "phoenix-core/src/main/java/org/apache/phoenix/jdbc/PhoenixStatement.java",
                "deletions": 0,
                "sha": "6bb57224b260af6cb82e945abb6523a953a04ef8",
                "blob_url": "https://github.com/apache/phoenix/blob/04504c34ffb2e39f38e1b37ee0d7f8f909537616/phoenix-core/src/main/java/org/apache/phoenix/jdbc/PhoenixStatement.java",
                "patch": "@@ -331,6 +331,7 @@ public Integer call() throws SQLException {\n                                 MutationPlan plan = stmt.compilePlan(PhoenixStatement.this, Sequence.ValueOp.VALIDATE_SEQUENCE);\n                                 if (plan.getTargetRef() != null && plan.getTargetRef().getTable() != null && plan.getTargetRef().getTable().isTransactional()) {\n                                     state.startTransaction();\n+                                    state.addReadFence(plan.getTargetRef().getTable());\n                                 }\n                                 Iterator<TableRef> tableRefs = plan.getSourceRefs().iterator();\n                                 state.sendUncommitted(tableRefs);",
                "changes": 1
            }
        ],
        "unit_tests": [
            "MutationStateTest.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "phoenix-core/src/test/java/org/apache/phoenix/execute/MutationStateTest.java",
        "buggy_files": [
            "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java"
        ],
        "fixed": true
    }
]