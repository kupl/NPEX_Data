[{"commit": "https://github.com/apache/aries-rsa/commit/362b68d69225f78002e7db0118b76c9cec1b4b4f", "parent": "https://github.com/apache/aries-rsa/commit/75448368d0efecbef48464bbf10791986e20c4b0", "message": "Fix for NPE", "bug_id": "aries-rsa_1", "file": [{"additions": 6, "raw_url": "https://github.com/apache/aries-rsa/raw/362b68d69225f78002e7db0118b76c9cec1b4b4f/discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java", "blob_url": "https://github.com/apache/aries-rsa/blob/362b68d69225f78002e7db0118b76c9cec1b4b4f/discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java", "sha": "6e2641f905344ab0327ad4fcc1e8c74e7e9513d1", "changes": 8, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java?ref=362b68d69225f78002e7db0118b76c9cec1b4b4f", "patch": "@@ -247,13 +247,17 @@ private void handleZNodeChanged(String path) {\n     private void handleRemoved(String path) {\n         EndpointDescription endpoint = nodes.remove(path);\n         EndpointEvent event = new EndpointEvent(EndpointEvent.REMOVED, endpoint);\n-        listener.endpointChanged(event, null);\n+        if (listener != null) {\n+            listener.endpointChanged(event, null);\n+        }\n     }\n \n     private void handleChanged(String path, EndpointDescription endpoint) {\n         EndpointDescription old = nodes.put(path, endpoint);\n         EndpointEvent event = new EndpointEvent(old == null ? EndpointEvent.ADDED : EndpointEvent.MODIFIED, endpoint);\n-        listener.endpointChanged(event, null);\n+        if (listener != null) {\n+            listener.endpointChanged(event, null);\n+        }\n     }\n \n }", "filename": "discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/55ab0a11a8354cee7c0733439fc672acc0febf14", "parent": "https://github.com/apache/aries-rsa/commit/19849747e5d300e4613bd9759cacdfe0570edad9", "message": "[ARIES-1774] Fix for NPE when a node has no children", "bug_id": "aries-rsa_2", "file": [{"additions": 3, "raw_url": "https://github.com/apache/aries-rsa/raw/55ab0a11a8354cee7c0733439fc672acc0febf14/discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java", "blob_url": "https://github.com/apache/aries-rsa/blob/55ab0a11a8354cee7c0733439fc672acc0febf14/discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java", "sha": "e290e654d4d8b8eb4113e8d188b4d0de0d299302", "changes": 3, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java?ref=55ab0a11a8354cee7c0733439fc672acc0febf14", "patch": "@@ -173,6 +173,9 @@ private void watchRecursive(String path) {\n         handleZNodeChanged(path);\n         try {\n             List<String> children = zk.getChildren(path, this);\n+            if (children == null) {\n+                return;\n+            }\n             for (String child : children) {\n                 String childPath = (path.endsWith(\"/\") ? path : path + \"/\") + child;\n                 watchRecursive(childPath);", "filename": "discovery/zookeeper/src/main/java/org/apache/aries/rsa/discovery/zookeeper/repository/ZookeeperEndpointRepository.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/b4a95725d1e151967c858a9bb39205045ae4a20d", "parent": "https://github.com/apache/aries-rsa/commit/90205645cca228f23a217cceae46c86da945edb0", "message": "Avoid NPE and use a more meaningful exception for the case of an unregistered service", "bug_id": "aries-rsa_3", "file": [{"additions": 5, "raw_url": "https://github.com/apache/aries-rsa/raw/b4a95725d1e151967c858a9bb39205045ae4a20d/rsa/src/main/java/org/apache/aries/rsa/core/RemoteServiceAdminCore.java", "blob_url": "https://github.com/apache/aries-rsa/blob/b4a95725d1e151967c858a9bb39205045ae4a20d/rsa/src/main/java/org/apache/aries/rsa/core/RemoteServiceAdminCore.java", "sha": "fa04b10098e32f98366658f875ce9127cd66a008", "changes": 6, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/rsa/src/main/java/org/apache/aries/rsa/core/RemoteServiceAdminCore.java?ref=b4a95725d1e151967c858a9bb39205045ae4a20d", "patch": "@@ -201,7 +201,11 @@ private ExportRegistration exportService(List<String> interfaceNames,\n         try {\n             Class<?>[] interfaces = getInterfaces(interfaceNames, serviceReference.getBundle());\n             Map<String, Object> eprops = createEndpointProps(serviceProperties, interfaces);\n-            BundleContext serviceContext = serviceReference.getBundle().getBundleContext();\n+            Bundle bundle = serviceReference.getBundle();\n+            if (bundle == null) {\n+                throw new IllegalStateException(\"Service is already unregistered\");\n+            }\n+            BundleContext serviceContext = bundle.getBundleContext();\n             \n             // TODO unget service when export is destroyed\n             Object serviceO = serviceContext.getService(serviceReference);", "filename": "rsa/src/main/java/org/apache/aries/rsa/core/RemoteServiceAdminCore.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/15f4e7763d73004d7832aa43bcdca67eb7713a9c", "parent": "https://github.com/apache/aries-rsa/commit/f7e799df3f39805a3f66dc6f86bb4f579884cde3", "message": "Fix possible NPE", "bug_id": "aries-rsa_4", "file": [{"additions": 3, "raw_url": "https://github.com/apache/aries-rsa/raw/15f4e7763d73004d7832aa43bcdca67eb7713a9c/rsa/src/main/java/org/apache/aries/rsa/core/ExportRegistrationImpl.java", "blob_url": "https://github.com/apache/aries-rsa/blob/15f4e7763d73004d7832aa43bcdca67eb7713a9c/rsa/src/main/java/org/apache/aries/rsa/core/ExportRegistrationImpl.java", "sha": "0f0dcef5b0b2241c39cc7f2cd99277c1f09a9d4e", "changes": 4, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/rsa/src/main/java/org/apache/aries/rsa/core/ExportRegistrationImpl.java?ref=15f4e7763d73004d7832aa43bcdca67eb7713a9c", "patch": "@@ -98,7 +98,9 @@ public final void close() {\n         }\n \n         rsaCore.removeExportRegistration(this);\n-        exportReference.close();\n+        if (exportReference != null) {\n+            exportReference.close();\n+        }\n         parent.removeInstance();\n     }\n ", "filename": "rsa/src/main/java/org/apache/aries/rsa/core/ExportRegistrationImpl.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/c848ffb4270729043d5f32c1af44291dcd97d4c6", "parent": "https://github.com/apache/aries-rsa/commit/da63f3671760bf514aea6480b27d1f0c025479c1", "message": "ARIES-1519 - NPE when DistributionProvider has no\nremote.intents.supported\n\nadds a null check and defaults to an empty string if either\nremote.intents.supported or remote.configs.supported is not set by a\ndistribution provider", "bug_id": "aries-rsa_5", "file": [{"additions": 8, "raw_url": "https://github.com/apache/aries-rsa/raw/c848ffb4270729043d5f32c1af44291dcd97d4c6/rsa/src/main/java/org/apache/aries/rsa/core/DistributionProviderTracker.java", "blob_url": "https://github.com/apache/aries-rsa/blob/c848ffb4270729043d5f32c1af44291dcd97d4c6/rsa/src/main/java/org/apache/aries/rsa/core/DistributionProviderTracker.java", "sha": "ea45c652ea21e2515696356364586012f71349d4", "changes": 10, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/rsa/src/main/java/org/apache/aries/rsa/core/DistributionProviderTracker.java?ref=c848ffb4270729043d5f32c1af44291dcd97d4c6", "patch": "@@ -28,6 +28,7 @@\n import org.osgi.framework.FrameworkUtil;\n import org.osgi.framework.ServiceReference;\n import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.remoteserviceadmin.RemoteConstants;\n import org.osgi.service.remoteserviceadmin.RemoteServiceAdmin;\n import org.osgi.util.tracker.ServiceTracker;\n import org.slf4j.Logger;\n@@ -51,8 +52,13 @@ public ServiceRegistration addingService(ServiceReference<DistributionProvider>\n                                                                     provider);\n         RemoteServiceadminFactory rsaf = new RemoteServiceadminFactory(rsaCore);\n         Dictionary<String, Object> props = new Hashtable<String, Object>();\n-        props.put(\"remote.intents.supported\", reference.getProperty(\"remote.intents.supported\"));\n-        props.put(\"remote.configs.supported\", reference.getProperty(\"remote.configs.supported\"));\n+        Object value = reference.getProperty(RemoteConstants.REMOTE_INTENTS_SUPPORTED);\n+        value = value == null ? \"\" : value;\n+        props.put(RemoteConstants.REMOTE_INTENTS_SUPPORTED, value);\n+\n+        value = reference.getProperty(RemoteConstants.REMOTE_CONFIGS_SUPPORTED);\n+        value = value == null ? \"\" : value;\n+        props.put(RemoteConstants.REMOTE_CONFIGS_SUPPORTED, value);\n         LOG.info(\"Registering RemoteServiceAdmin for provider \" + provider.getClass().getName());\n         return context.registerService(RemoteServiceAdmin.class.getName(), rsaf, props);\n     }", "filename": "rsa/src/main/java/org/apache/aries/rsa/core/DistributionProviderTracker.java"}, {"additions": 33, "raw_url": "https://github.com/apache/aries-rsa/raw/c848ffb4270729043d5f32c1af44291dcd97d4c6/rsa/src/test/java/org/apache/aries/rsa/core/DistributionProviderTrackerTest.java", "blob_url": "https://github.com/apache/aries-rsa/blob/c848ffb4270729043d5f32c1af44291dcd97d4c6/rsa/src/test/java/org/apache/aries/rsa/core/DistributionProviderTrackerTest.java", "sha": "9a4de6bfa57259788e77af8b0c6a71ba7dfbd185", "changes": 33, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/rsa/src/test/java/org/apache/aries/rsa/core/DistributionProviderTrackerTest.java?ref=c848ffb4270729043d5f32c1af44291dcd97d4c6", "patch": "@@ -79,4 +79,37 @@ protected BundleContext getAPIContext() {\n         tracker.removedService(providerRef, rsaReg);\n         c.verify();\n     }\n+\n+    @Test\n+    public void testAddingWithNullValues() throws InvalidSyntaxException {\n+        IMocksControl c = EasyMock.createControl();\n+        DistributionProvider provider = c.createMock(DistributionProvider.class);\n+\n+        ServiceReference<DistributionProvider> providerRef = c.createMock(ServiceReference.class);\n+        EasyMock.expect(providerRef.getProperty(RemoteConstants.REMOTE_INTENTS_SUPPORTED)).andReturn(null);\n+        EasyMock.expect(providerRef.getProperty(RemoteConstants.REMOTE_CONFIGS_SUPPORTED)).andReturn(null);\n+\n+        BundleContext context = c.createMock(BundleContext.class);\n+        String filterSt = String.format(\"(objectClass=%s)\", DistributionProvider.class.getName());\n+        Filter filter = FrameworkUtil.createFilter(filterSt);\n+        EasyMock.expect(context.createFilter(filterSt)).andReturn(filter);\n+        EasyMock.expect(context.getService(providerRef)).andReturn(provider);\n+        ServiceRegistration rsaReg = c.createMock(ServiceRegistration.class);\n+        EasyMock.expect(context.registerService(EasyMock.isA(String.class), EasyMock.isA(ServiceFactory.class),\n+                                                EasyMock.isA(Dictionary.class)))\n+            .andReturn(rsaReg).atLeastOnce();\n+\n+        context.addServiceListener(EasyMock.isA(ServiceListener.class), EasyMock.isA(String.class));\n+        EasyMock.expectLastCall();\n+\n+        final BundleContext apiContext = c.createMock(BundleContext.class);\n+        c.replay();\n+        DistributionProviderTracker tracker = new DistributionProviderTracker(context) {\n+            protected BundleContext getAPIContext() {\n+                return apiContext;\n+            };\n+        };\n+        tracker.addingService(providerRef);\n+        c.verify();\n+    }\n }", "filename": "rsa/src/test/java/org/apache/aries/rsa/core/DistributionProviderTrackerTest.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/a359e7e1007c83fcfdf4272252f443e24a1882f2", "parent": "https://github.com/apache/aries-rsa/commit/2d1774fe3e340b2bac4d999aea5918a1e921ddd8", "message": "Fix for NPE when running in Equinox\n\ngit-svn-id: https://svn.apache.org/repos/asf/cxf/dosgi/trunk@1434115 13f79535-47bb-0310-9956-ffa450edef68", "bug_id": "aries-rsa_6", "file": [{"additions": 3, "raw_url": "https://github.com/apache/aries-rsa/raw/a359e7e1007c83fcfdf4272252f443e24a1882f2/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/importer/EndpointListenerManager.java", "blob_url": "https://github.com/apache/aries-rsa/blob/a359e7e1007c83fcfdf4272252f443e24a1882f2/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/importer/EndpointListenerManager.java", "sha": "524838bc024e0f09f006fde76d1d02b8fdf3b62b", "changes": 4, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/importer/EndpointListenerManager.java?ref=a359e7e1007c83fcfdf4272252f443e24a1882f2", "patch": "@@ -92,7 +92,9 @@ protected void reduceScope(String filter) {\n     }\n \n     private void updateRegistration() {\n-        serviceRegistration.setProperties(getRegistrationProperties());\n+        if (serviceRegistration != null) {\n+            serviceRegistration.setProperties(getRegistrationProperties());\n+        }\n     }\n \n }", "filename": "dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/importer/EndpointListenerManager.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/c54491cdb857a25346c568c1b7c6bf178a67cc79", "parent": "https://github.com/apache/aries-rsa/commit/8726d51106452221ad6f728856ac02d0711e63fa", "message": "DOSGI-120 Added a safeguard vs to avoid NPE\n\ngit-svn-id: https://svn.apache.org/repos/asf/cxf/dosgi/trunk@1404969 13f79535-47bb-0310-9956-ffa450edef68", "bug_id": "aries-rsa_7", "file": [{"additions": 1, "raw_url": "https://github.com/apache/aries-rsa/raw/c54491cdb857a25346c568c1b7c6bf178a67cc79/dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/service/RemoteServiceAdminCore.java", "blob_url": "https://github.com/apache/aries-rsa/blob/c54491cdb857a25346c568c1b7c6bf178a67cc79/dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/service/RemoteServiceAdminCore.java", "sha": "78974c03b740994abe4ff3307ae31b3b77db7be9", "changes": 2, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/service/RemoteServiceAdminCore.java?ref=c54491cdb857a25346c568c1b7c6bf178a67cc79", "patch": "@@ -302,7 +302,7 @@ public RemoteServiceAdminCore(BundleContext bc, IntentMap intentMap) {\n     }\n \n     private boolean isCreatedByThisRSA(ServiceReference sref) {\n-        return sref.getBundle().equals(bctx.getBundle());\n+        return (sref.getBundle() != null ) && sref.getBundle().equals(bctx.getBundle());\n     }\n \n     public Collection<ExportReference> getExportedServices() {", "filename": "dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/service/RemoteServiceAdminCore.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/3e12204f80e667c85bb56837232a1559345db1a3", "parent": "https://github.com/apache/aries-rsa/commit/dd2409513c541273200b7f7814d9a1a71eda5846", "message": "DOSGI-129 Fixing NPE, better handling of exceptions\n\ngit-svn-id: https://svn.apache.org/repos/asf/cxf/dosgi/trunk@1401715 13f79535-47bb-0310-9956-ffa450edef68", "bug_id": "aries-rsa_8", "file": [{"additions": 101, "raw_url": "https://github.com/apache/aries-rsa/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java", "blob_url": "https://github.com/apache/aries-rsa/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java", "sha": "1b3f7e683b892e36c6fe43ecfac1e9be19cc575b", "changes": 188, "status": "modified", "deletions": 87, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java?ref=3e12204f80e667c85bb56837232a1559345db1a3", "patch": "@@ -18,6 +18,7 @@\n  */\n package org.apache.cxf.dosgi.topologymanager;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Dictionary;\n@@ -131,15 +132,9 @@ protected void removeRemoteServiceAdmin(RemoteServiceAdmin rsa) {\n                     Collection<ExportRegistration> endpoints = exports.getValue().get(rsa);\n                     // TODO for each notify discovery......\n \n-                    try {\n-                        ServiceReference[] refs = Utils.getEndpointListeners(bctx);\n-                        if (refs != null) {\n-                            for (ServiceReference sref : refs) {\n-                                notifyListenersOfRemovalIfAppropriate(sref, endpoints);\n-                            }\n-                        }\n-                    } catch (InvalidSyntaxException e) {\n-                        LOG.log(Level.SEVERE, e.getMessage(), e);\n+                    ServiceReference[] refs = getEndpointListeners(bctx);\n+                    for (ServiceReference sref : refs) {\n+                        notifyListenersOfRemovalIfAppropriate(sref, endpoints);\n                     }\n \n                     // remove all management information for the RemoteServiceAdmin\n@@ -227,14 +222,12 @@ protected void exportService(ServiceReference sref) {\n                                  new LinkedHashMap<RemoteServiceAdmin, Collection<ExportRegistration>>());\n         }\n \n-        // trigger the export\n         triggerExport(sref);\n \n     }\n \n     private void triggerExport(final ServiceReference sref) {\n         execService.execute(new Runnable() {\n-            @SuppressWarnings(\"unchecked\")\n             public void run() {\n                 LOG.finer(\"TopologyManager: exporting service ...\");\n \n@@ -273,8 +266,7 @@ public void run() {\n                                     // enqueue in local list of endpoints\n                                     exports.put(remoteServiceAdmin, endpoints);\n \n-                                    // publish to endpoint listeners\n-                                    nofifyListeners(endpoints);\n+                                    nofifyEndpointListenersOfAdding(endpoints);\n                                 }\n                             }\n                         }\n@@ -285,21 +277,28 @@ public void run() {\n         });\n     }\n \n-    protected void nofifyListeners(Collection<ExportRegistration> exportRegistrations) {\n-        try {\n-            // Find all EndpointListeners; They must have the Scope property otherwise they have to be ignored\n-            ServiceReference[] refs = Utils.getEndpointListeners(bctx);\n-\n-            if (refs != null) {\n-                for (ServiceReference sref : refs) {\n-                    notifyListenerOfAddingIfAppropriate(sref, exportRegistrations);\n-                }\n-            }\n+    protected void nofifyEndpointListenersOfAdding(Collection<ExportRegistration> exportRegistrations) {\n+        ServiceReference[] epListeners = getEndpointListeners(bctx);\n+        for (ServiceReference sref : epListeners) {\n+            notifyListenerOfAddingIfAppropriate(sref, exportRegistrations);\n+        }\n+    }\n \n+     /** \n+      * Find all EndpointListeners; They must have the Scope property otherwise they have to be ignored\n+      * @param bctx\n+      * @return\n+      * @throws InvalidSyntaxException\n+      */\n+    protected static ServiceReference[] getEndpointListeners(BundleContext bctx) {\n+        ServiceReference[] result = null;\n+        try {\n+            String filter = \"(\" + EndpointListener.ENDPOINT_LISTENER_SCOPE + \"=*)\";\n+            result = bctx.getServiceReferences(EndpointListener.class.getName(), filter);\n         } catch (InvalidSyntaxException e) {\n             LOG.log(Level.SEVERE, e.getMessage(), e);\n         }\n-\n+        return (result == null) ? new ServiceReference[]{} : result;\n     }\n \n     /**\n@@ -311,91 +310,84 @@ protected void nofifyListeners(Collection<ExportRegistration> exportRegistration\n     protected void notifyListenerOfAddingIfAppropriate(ServiceReference sref,\n                                                        Collection<ExportRegistration> exportRegistrations) {\n \n-        // if (sref.getBundle().equals(bctx.getBundle())) {\n-        // LOG\n-        // .info(\"TopologyManager: notifyListenerOfAddingIfAppropriate() called for own listener -> skipping \");\n-        // return;\n-        // }\n-\n         EndpointListener epl = (EndpointListener)bctx.getService(sref);\n-\n         LOG.finer(\"TopologyManager: notifyListenerOfAddingIfAppropriate() \");\n+        List<Filter> filters = getFiltersFromEndpointListenerScope(sref, bctx);\n \n-        try {\n-\n-            List<Filter> filters = Utils.normalizeScope(sref, bctx);\n-\n-            for (ExportRegistration exReg : exportRegistrations) {\n-\n-                // FIXME!!!!!!!!!!!!! There needs to be a better way ?!?!?!\n-                Map props = exReg.getExportReference().getExportedEndpoint().getProperties();\n-                Dictionary d = new Hashtable(props);\n-\n-                if (LOG.isLoggable(Level.FINE)) {\n-                    for (Filter filter : filters) {\n-                        LOG.fine(\"Matching: \" + filter + \"  against \" + d);\n-                    }\n-                }\n-\n-                for (Filter filter : filters) {\n-                    if (filter.match(d)) {\n-                        LOG.fine(\"Listener mached one of the Endpoints !!!!: \" + epl);\n-\n-                        epl.endpointAdded(exReg.getExportReference().getExportedEndpoint(), filter\n-                                .toString());\n-                    }\n-                }\n+        for (ExportRegistration exReg : exportRegistrations) {\n+            EndpointDescription endpoint = getExportedEndpoint(exReg);\n+            List<Filter> matchingFilters = getMatchingFilters(filters, endpoint);\n+            for (Filter filter : matchingFilters) {\n+                epl.endpointAdded(endpoint, filter.toString());\n             }\n-\n-        } catch (InvalidSyntaxException e) {\n-            LOG.log(Level.SEVERE, e.getMessage(), e);\n         }\n+\n     }\n \n     protected void notifyListenersOfRemovalIfAppropriate(ServiceReference sref,\n-                                                         Collection<ExportRegistration> exportRegistrations) {\n-\n-        EndpointListener epl = (EndpointListener)bctx.getService(sref);\n+            Collection<ExportRegistration> exportRegistrations) {\n \n+        EndpointListener epl = (EndpointListener) bctx.getService(sref);\n         LOG.finer(\"TopologyManager: notifyListenerOfREMOVALIfAppropriate() \");\n+        List<Filter> filters = getFiltersFromEndpointListenerScope(sref, bctx);\n \n-        List<Filter> filters;\n+        for (ExportRegistration exReg : exportRegistrations) {\n+            EndpointDescription endpoint = getExportedEndpoint(exReg);\n+            List<Filter> matchingFilters = getMatchingFilters(filters, endpoint);\n+            for (Filter filter : matchingFilters) {\n+                epl.endpointRemoved(endpoint, filter.toString());\n+            }\n+        }\n+    }\n+    \n+    static List<Filter> getFiltersFromEndpointListenerScope(ServiceReference sref,BundleContext bctx) {\n+        List<Filter> filters = new ArrayList<Filter>();\n         try {\n-            filters = Utils.normalizeScope(sref, bctx);\n-\n-            for (ExportRegistration exReg : exportRegistrations) {\n-\n-                // FIXME!!!!!!!!!!!!! There needs to be a better way ?!?!?!\n-            \tExportReference ref = exReg.getExportReference(); \n-            \tEndpointDescription endpoint = ref.getExportedEndpoint(); \n-                Map props = endpoint.getProperties();\n-                Dictionary d = new Hashtable(props);\n-\n-                if (LOG.isLoggable(Level.FINE)) {\n-                    for (Filter filter : filters) {\n-                        LOG.fine(\"Matching: \" + filter + \"  against \" + d);\n-                    }\n+            Object fo = sref.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE);\n+            if (fo instanceof String) {\n+                filters.add(bctx.createFilter((String) fo));\n+            } else if (fo instanceof String[]) {\n+                String[] foArray = (String[]) fo;\n+                for (String f : foArray) {\n+                    filters.add(bctx.createFilter(f));\n                 }\n-\n-                for (Filter filter : filters) {\n-                    if (filter.match(d)) {\n-                        LOG.fine(\"Listener matched one of the Endpoints !!!! --> calling removed() ...\");\n-\n-                        epl.endpointRemoved(exReg.getExportReference().getExportedEndpoint(), filter\n-                            .toString());\n+            } else if (fo instanceof Collection) {\n+                @SuppressWarnings(\"rawtypes\")\n+                Collection c = (Collection) fo;\n+                for (Object o : c) {\n+                    if (o instanceof String) {\n+                        filters.add(bctx.createFilter((String) o));\n+                    } else {\n+                        LOG.warning(\"Component of a filter is not a string -> skipped !\");\n                     }\n                 }\n             }\n         } catch (InvalidSyntaxException e) {\n             LOG.log(Level.SEVERE, e.getMessage(), e);\n         }\n+        return filters;\n+    }\n+\n+    private List<Filter> getMatchingFilters(List<Filter> filters,\n+            EndpointDescription endpoint) {\n+        List<Filter> matchingFilters = new ArrayList<Filter>();\n+        Dictionary<String, Object> d = getEndpointProperties(endpoint);\n \n+        for (Filter filter : filters) {\n+            if (LOG.isLoggable(Level.FINE)) {\n+                LOG.fine(\"Matching: \" + filter + \"  against \" + d);\n+            }\n+            if (filter.match(d)) {\n+                LOG.fine(\"Listener matched one of the Endpoints !!!! --> calling removed() ...\");\n+                matchingFilters.add(filter);\n+            }\n+        }\n+        return matchingFilters;\n     }\n \n     private void checkExistingServices() throws InvalidSyntaxException {\n-        ServiceReference[] references = bctx\n-            .getServiceReferences(null, \"(\" + RemoteConstants.SERVICE_EXPORTED_INTERFACES + \"=*)\");\n-        // + \"(\"+org.apache.cxf.dosgi.dsw.Constants.EXPORTED_INTERFACES_OLD + \"=*))\");\n+        String filter = \"(\" + RemoteConstants.SERVICE_EXPORTED_INTERFACES + \"=*)\";\n+        ServiceReference[] references = bctx.getServiceReferences(null, filter);\n \n         if (references != null) {\n             for (ServiceReference sref : references) {\n@@ -411,7 +403,6 @@ public void removeExportRegistration(ExportRegistration exportRegistration) {\n \n                 Map<RemoteServiceAdmin, Collection<ExportRegistration>> ex = exportedServices.get(sref);\n                 if (ex != null) {\n-                    EndpointDescription ep = exportRegistration.getExportReference().getExportedEndpoint();\n                     for (Map.Entry<RemoteServiceAdmin, Collection<ExportRegistration>> export : ex.entrySet()) {\n                         export.getValue().contains(exportRegistration);\n                     }\n@@ -432,4 +423,27 @@ public void removeExportReference(ExportReference anyObject) {\n         // LOG.severe(\"NOT implemented !!!\");\n     }\n \n+    /**\n+     * Retrieve exported Endpoint while handling null\n+     * @param exReg\n+     * @return exported Endpoint or null if not present\n+     */\n+    private EndpointDescription getExportedEndpoint(ExportRegistration exReg) {\n+        ExportReference ref = (exReg == null) ? null : exReg.getExportReference();\n+        return (ref == null) ? null : ref.getExportedEndpoint(); \n+    }\n+    \n+    /**\n+     * Retrieve endpoint properties as Dictionary\n+     * \n+     * @param ep\n+     * @return endpoint properties (will never return null) \n+     */\n+    private Dictionary<String, Object> getEndpointProperties(EndpointDescription ep) {\n+        if (ep == null || ep.getProperties() == null) {\n+            return new Hashtable<String, Object>();\n+        } else {\n+            return new Hashtable<String, Object>(ep.getProperties());\n+        }\n+    }\n }", "filename": "dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java"}, {"additions": 0, "raw_url": "https://github.com/apache/aries-rsa/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java", "blob_url": "https://github.com/apache/aries-rsa/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java", "sha": "a198580d8d404b3a4013b052a939d6d93bf5f8ee", "changes": 43, "status": "modified", "deletions": 43, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java?ref=3e12204f80e667c85bb56837232a1559345db1a3", "patch": "@@ -18,57 +18,14 @@\n   */\n package org.apache.cxf.dosgi.topologymanager;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n import java.util.UUID;\n-import java.util.logging.Logger;\n \n import org.osgi.framework.BundleContext;\n-import org.osgi.framework.Filter;\n-import org.osgi.framework.InvalidSyntaxException;\n-import org.osgi.framework.ServiceReference;\n-import org.osgi.service.remoteserviceadmin.EndpointListener;\n import org.osgi.service.remoteserviceadmin.RemoteConstants;\n \n \n public class Utils {\n \n-    private static final Logger LOG = Logger.getLogger(Utils.class.getName());\n-    \n-    protected static ServiceReference[] getEndpointListeners(BundleContext bctx) throws InvalidSyntaxException {\n-        ServiceReference[] refs = bctx\n-            .getServiceReferences(EndpointListener.class.getName(),\n-                                  \"(\" + EndpointListener.ENDPOINT_LISTENER_SCOPE + \"=*)\");\n-        return refs;\n-    }\n-\n-    public static List<Filter> normalizeScope(ServiceReference sref,BundleContext bctx) throws InvalidSyntaxException {\n-        List<Filter> filters = new ArrayList<Filter>();\n-    \n-        Object fo = sref.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE);\n-        if (fo instanceof String) {\n-            filters.add(bctx.createFilter((String)fo));\n-        } else if (fo instanceof String[]) {\n-            String[] foArray = (String[])fo;\n-            for (String f : foArray) {\n-                filters.add(bctx.createFilter(f));\n-            }\n-        } else if (fo instanceof Collection) {\n-            Collection c = (Collection)fo;\n-            for (Object o : c) {\n-                if (o instanceof String) {\n-                    filters.add(bctx.createFilter((String)o));\n-                } else {\n-                    LOG.info(\"Component of a filter is not a string -> skipped !\");\n-                }\n-            }\n-        }\n-    \n-        return filters;\n-    }\n-\n-    \n     public static String getUUID(BundleContext bctx) {\n         synchronized (\"org.osgi.framework.uuid\") {\n             String uuid = bctx.getProperty(\"org.osgi.framework.uuid\");", "filename": "dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java"}, {"additions": 101, "raw_url": "https://github.com/apache/aries-rsa/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java", "blob_url": "https://github.com/apache/aries-rsa/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java", "sha": "b232a52f2b61ddc695644786f73f5f8a8b339795", "changes": 103, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java?ref=3e12204f80e667c85bb56837232a1559345db1a3", "patch": "@@ -18,7 +18,10 @@\n   */\n package org.apache.cxf.dosgi.topologymanager;\n \n+import static org.junit.Assert.assertEquals;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -56,12 +59,12 @@ public void testNotifyListenersOfRemovalIfAppropriate() throws InvalidSyntaxExce\n         ExportReference exRef2 = c.createMock(ExportReference.class);\n         \n         \n-        Map props = new HashMap();\n+        Map<String, Object> props = new HashMap<String, Object>();\n         String[] oc = new String[1];\n         oc[0] = \"myClass\";\n         props.put(\"objectClass\", oc);\n         \n-        Map props2 = new HashMap();\n+        Map<String, Object> props2 = new HashMap<String, Object>();\n         oc = new String[1];\n         oc[0] = \"notMyClass\";\n         props2.put(\"objectClass\", oc);\n@@ -106,4 +109,100 @@ public Filter answer() throws Throwable {\n \n     }\n \n+    @Test\n+    public void testNomalizeScopeForSingleString() {\n+\n+        try {\n+            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n+            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n+                .andReturn(\"Filterstring\");\n+\n+            Filter f = EasyMock.createNiceMock(Filter.class);\n+            \n+            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n+            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f);\n+\n+            EasyMock.replay(sr);\n+            EasyMock.replay(bc);\n+\n+            List<Filter> res = TopologyManager.getFiltersFromEndpointListenerScope(sr, bc);\n+\n+            assertEquals(1, res.size());\n+            assertEquals(f, res.get(0));\n+\n+            EasyMock.verify(sr);\n+            EasyMock.verify(bc);\n+        } catch (InvalidSyntaxException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    \n+    @Test\n+    public void testNomalizeScopeForStringArray() {\n+\n+        try {\n+            \n+            String[] filterStrings = {\"f1\",\"f2\",\"f3\"};\n+            \n+            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n+            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n+                .andReturn(filterStrings);\n+\n+            Filter f = EasyMock.createNiceMock(Filter.class);\n+            \n+            \n+            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n+            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(filterStrings.length);\n+\n+            EasyMock.replay(sr);\n+            EasyMock.replay(bc);\n+\n+            List<Filter> res = TopologyManager.getFiltersFromEndpointListenerScope(sr, bc);\n+\n+            assertEquals(filterStrings.length, res.size());\n+            assertEquals(f, res.get(0));\n+\n+            EasyMock.verify(sr);\n+            EasyMock.verify(bc);\n+        } catch (InvalidSyntaxException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    @Test\n+    public void testNomalizeScopeForCollection() {\n+\n+        try {\n+            \n+            \n+            Collection<String> collection = new ArrayList<String>();\n+            collection.add(\"f1\");\n+            collection.add(\"f2\");\n+            collection.add(\"f3\");\n+            \n+            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n+            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n+                .andReturn(collection);\n+\n+            Filter f = EasyMock.createNiceMock(Filter.class);\n+            \n+            \n+            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n+            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(collection.size());\n+\n+            EasyMock.replay(sr);\n+            EasyMock.replay(bc);\n+\n+            List<Filter> res = TopologyManager.getFiltersFromEndpointListenerScope(sr, bc);\n+\n+            assertEquals(collection.size(), res.size());\n+            assertEquals(f, res.get(0));\n+\n+            EasyMock.verify(sr);\n+            EasyMock.verify(bc);\n+        } catch (InvalidSyntaxException e) {\n+            e.printStackTrace();\n+        }\n+    }\n }", "filename": "dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java"}, {"additions": 7, "raw_url": "https://github.com/apache/aries-rsa/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java", "blob_url": "https://github.com/apache/aries-rsa/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java", "sha": "c6baa8a1e764e5a9068bc92d176b6ab00327ece9", "changes": 124, "status": "modified", "deletions": 117, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java?ref=3e12204f80e667c85bb56837232a1559345db1a3", "patch": "@@ -18,130 +18,23 @@\n   */\n package org.apache.cxf.dosgi.topologymanager;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n import java.util.Dictionary;\n-import java.util.HashMap;\n import java.util.Hashtable;\n-import java.util.List;\n-import java.util.Map;\n-\n \n import org.easymock.classextension.EasyMock;\n+import org.junit.Test;\n import org.osgi.framework.BundleContext;\n import org.osgi.framework.Filter;\n import org.osgi.framework.FrameworkUtil;\n import org.osgi.framework.InvalidSyntaxException;\n-import org.osgi.framework.ServiceReference;\n-import org.osgi.service.remoteserviceadmin.EndpointListener;\n import org.osgi.service.remoteserviceadmin.RemoteConstants;\n \n-import org.junit.Test;\n-\n public class UtilsTest {\n-\n-    @Test\n-    public void testNomalizeScopeForSingleString() {\n-\n-        try {\n-            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n-            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n-                .andReturn(\"Filterstring\");\n-\n-            Filter f = EasyMock.createNiceMock(Filter.class);\n-            \n-            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n-            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f);\n-\n-            EasyMock.replay(sr);\n-            EasyMock.replay(bc);\n-\n-            List<Filter> res = Utils.normalizeScope(sr, bc);\n-\n-            assertEquals(1, res.size());\n-            assertEquals(f, res.get(0));\n-\n-            EasyMock.verify(sr);\n-            EasyMock.verify(bc);\n-        } catch (InvalidSyntaxException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n-    \n-    @Test\n-    public void testNomalizeScopeForStringArray() {\n-\n-        try {\n-            \n-            String[] filterStrings = {\"f1\",\"f2\",\"f3\"};\n-            \n-            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n-            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n-                .andReturn(filterStrings);\n-\n-            Filter f = EasyMock.createNiceMock(Filter.class);\n-            \n-            \n-            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n-            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(filterStrings.length);\n-\n-            EasyMock.replay(sr);\n-            EasyMock.replay(bc);\n-\n-            List<Filter> res = Utils.normalizeScope(sr, bc);\n-\n-            assertEquals(filterStrings.length, res.size());\n-            assertEquals(f, res.get(0));\n-\n-            EasyMock.verify(sr);\n-            EasyMock.verify(bc);\n-        } catch (InvalidSyntaxException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n-    \n-    \n-    @Test\n-    public void testNomalizeScopeForCollection() {\n-\n-        try {\n-            \n-            \n-            Collection<String> collection = new ArrayList<String>();\n-            collection.add(\"f1\");\n-            collection.add(\"f2\");\n-            collection.add(\"f3\");\n-            \n-            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n-            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n-                .andReturn(collection);\n-\n-            Filter f = EasyMock.createNiceMock(Filter.class);\n-            \n-            \n-            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n-            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(collection.size());\n-\n-            EasyMock.replay(sr);\n-            EasyMock.replay(bc);\n-\n-            List<Filter> res = Utils.normalizeScope(sr, bc);\n-\n-            assertEquals(collection.size(), res.size());\n-            assertEquals(f, res.get(0));\n-\n-            EasyMock.verify(sr);\n-            EasyMock.verify(bc);\n-        } catch (InvalidSyntaxException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n     \n     @Test\n     public void testGetNewUUID(){\n@@ -155,9 +48,7 @@ public void testGetNewUUID(){\n         \n         EasyMock.verify(bc);\n     }\n-     \n-    \n-    \n+\n     @Test\n     public void testGetExistingUUID(){\n         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n@@ -170,7 +61,6 @@ public void testGetExistingUUID(){\n         EasyMock.verify(bc);\n     }\n \n-    \n     @Test\n     public void testUUIDFilterExtension() throws InvalidSyntaxException{\n         String filter = \"(a=b)\";\n@@ -184,7 +74,7 @@ public void testUUIDFilterExtension() throws InvalidSyntaxException{\n         \n         Filter f = FrameworkUtil.createFilter(filter);\n         \n-        Dictionary m = new Hashtable();\n+        Dictionary<String, String> m = new Hashtable<String, String>();\n         m.put(\"a\", \"b\");\n         \n         assertTrue(filter+\" filter must match as uuid is missing\",f.match(m));      ", "filename": "dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java"}], "repo": "aries-rsa"}, {"commit": "https://github.com/apache/aries-rsa/commit/ff032a6277da02170bd09c325c5b2cf9d54782fb", "parent": "https://github.com/apache/aries-rsa/commit/e0797f3298fb138d2155b6cb922534afad5fc321", "message": "[DOSGI-77] Adding a couple of NPE guards\n\ngit-svn-id: https://svn.apache.org/repos/asf/cxf/dosgi/trunk@1215333 13f79535-47bb-0310-9956-ffa450edef68", "bug_id": "aries-rsa_9", "file": [{"additions": 9, "raw_url": "https://github.com/apache/aries-rsa/raw/ff032a6277da02170bd09c325c5b2cf9d54782fb/dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/OsgiUtils.java", "blob_url": "https://github.com/apache/aries-rsa/blob/ff032a6277da02170bd09c325c5b2cf9d54782fb/dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/OsgiUtils.java", "sha": "5b39a00fa7a040778211f10d0fbd7a459ae280f9", "changes": 15, "status": "modified", "deletions": 6, "contents_url": "https://api.github.com/repos/apache/aries-rsa/contents/dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/OsgiUtils.java?ref=ff032a6277da02170bd09c325c5b2cf9d54782fb", "patch": "@@ -589,12 +589,15 @@ public static String getVersion(Class<?> iClass, BundleContext bc) {\n \n             String pack = iClass.getPackage().getName();\n             LOG.finest(\"Looking for Package: \" + pack);\n-\n-            for (ExportedPackage p : ep) {\n-                if (pack.equals(p.getName())) {\n-                    LOG.fine(\"found package -> Version: \" + p.getVersion());\n-                    return p.getVersion().toString();\n-                }\n+            if (ep != null) {\n+\t            for (ExportedPackage p : ep) {\n+\t            \tif (p != null) {\n+\t\t                if (pack.equals(p.getName())) {\n+\t\t                    LOG.fine(\"found package -> Version: \" + p.getVersion());\n+\t\t                    return p.getVersion().toString();\n+\t\t                }\n+\t            \t}\n+\t            }\n             }\n         } else {\n             LOG.severe(\"Was unable to obtain the package admin service -> can't resolve interface versions\");", "filename": "dsw/cxf-dsw/src/main/java/org/apache/cxf/dosgi/dsw/OsgiUtils.java"}], "repo": "aries-rsa"}]
