{
    "usergrid_09151ea": {
        "bug_id": "usergrid_09151ea",
        "commit": "https://github.com/apache/usergrid/commit/09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
        "file": [
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/usergrid/blob/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java?ref=09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
                "deletions": 2,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java",
                "patch": "@@ -59,6 +59,13 @@ protected void configure() {\n         // bind our migration manager\n         bind( MigrationManager.class ).to( MigrationManagerImpl.class );\n \n+\n+\n+        //do multibindings for migrations\n+        Multibinder<Migration> migrationBinding = Multibinder.newSetBinder( binder(), Migration.class );\n+        migrationBinding.addBinding().to( Key.get( MigrationInfoSerialization.class ) );\n+\n+\n         bind( TimeService.class ).to( TimeServiceImpl.class );\n \n         bind( CassandraConfig.class ).to( CassandraConfigImpl.class );\n@@ -71,8 +78,11 @@ protected void configure() {\n \n         bind( DataMigrationManager.class ).to( DataMigrationManagerImpl.class );\n \n+\n+\n         //do multibindings for migrations\n-        Multibinder<Migration> migrationBinding = Multibinder.newSetBinder( binder(), Migration.class );\n-        migrationBinding.addBinding().to( Key.get( MigrationInfoSerialization.class ) );\n+        Multibinder<DataMigrationManager> dataMigrationManagerMultibinder = Multibinder.newSetBinder( binder(), DataMigrationManager.class );\n+//        migrationBinding.addBinding().to( Key.get( MigrationInfoSerialization.class ) );\n+\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java",
                "sha": "e37067fcfe126b08f02ef7e5f3258871fa7dd86d",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManager.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManager.java?ref=09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
                "deletions": 0,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManager.java",
                "patch": "@@ -41,6 +41,12 @@\n      */\n     public boolean isRunning();\n \n+    /**\n+     * Get the current version of the schema\n+     * @return\n+     */\n+    public int getCurrentVersion();\n+\n \n     /**\n      * Return that last status of the migration",
                "raw_url": "https://github.com/apache/usergrid/raw/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManager.java",
                "sha": "3357ed4b7e280f10e3d42110f47f95bad24bab4c",
                "status": "modified"
            },
            {
                "additions": 48,
                "blob_url": "https://github.com/apache/usergrid/blob/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManagerImpl.java",
                "changes": 65,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManagerImpl.java?ref=09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
                "deletions": 17,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManagerImpl.java",
                "patch": "@@ -27,12 +27,18 @@\n import java.util.NavigableMap;\n import java.util.Set;\n import java.util.TreeMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import org.apache.usergrid.persistence.core.migration.schema.MigrationException;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n import com.google.inject.Inject;\n import com.google.inject.Singleton;\n \n@@ -46,14 +52,33 @@\n \n     private final MigrationInfoSerialization migrationInfoSerialization;\n \n+    /**\n+     * Cache to cache versions temporarily\n+     */\n+    private final LoadingCache<String, Integer> versionCache = CacheBuilder.newBuilder()\n+            //cache the local value for 1 minute\n+            .expireAfterWrite( 1, TimeUnit.MINUTES ).build( new CacheLoader<String, Integer>() {\n+                @Override\n+                public Integer load( final String key ) throws Exception {\n+                    return migrationInfoSerialization.getVersion();\n+                }\n+            } );\n+\n \n     @Inject\n     public DataMigrationManagerImpl( final MigrationInfoSerialization migrationInfoSerialization,\n                                      final Set<DataMigration> migrations ) {\n+        Preconditions.checkNotNull( migrationInfoSerialization, \"migrationInfoSerialization must not be null\" );\n+        Preconditions.checkNotNull( migrations, \"migrations must not be null\" );\n+\n         this.migrationInfoSerialization = migrationInfoSerialization;\n \n+\n+\n         for ( DataMigration migration : migrations ) {\n \n+            Preconditions.checkNotNull( migration, \"A migration instance in the set of migrations was null.  This is not allowed\" );\n+\n             final int version = migration.getVersion();\n \n             final DataMigration existing = migrationTreeMap.get( version );\n@@ -103,7 +128,7 @@ public void migrate() throws MigrationException {\n \n             LOG.info( \"Running migration version {}\", migrationVersion );\n \n-            observer.update( migrationVersion,  \"Starting migration\" );\n+            observer.update( migrationVersion, \"Starting migration\" );\n \n \n             //perform this migration, if it fails, short circuit\n@@ -119,7 +144,7 @@ public void migrate() throws MigrationException {\n             }\n \n             //we had an unhandled exception or the migration failed, short circuit\n-            if(observer.failed){\n+            if ( observer.failed ) {\n                 return;\n             }\n \n@@ -128,13 +153,9 @@ public void migrate() throws MigrationException {\n \n             //update the observer for progress so other nodes can see it\n             observer.update( migrationVersion, \"Completed successfully\" );\n-\n-\n         }\n \n         migrationInfoSerialization.setStatusCode( StatusCode.COMPLETE.status );\n-\n-\n     }\n \n \n@@ -144,6 +165,17 @@ public boolean isRunning() {\n     }\n \n \n+    @Override\n+    public int getCurrentVersion() {\n+        try {\n+            return versionCache.get( \"currentVersion\" );\n+        }\n+        catch ( ExecutionException e ) {\n+            throw new DataMigrationException( \"Unable to get current version\", e );\n+        }\n+    }\n+\n+\n     @Override\n     public String getLastStatus() {\n         return migrationInfoSerialization.getStatusMessage();\n@@ -153,10 +185,10 @@ public String getLastStatus() {\n     /**\n      * Different status enums\n      */\n-    public enum StatusCode{\n-        COMPLETE(1),\n-        RUNNING(2),\n-        ERROR(3);\n+    public enum StatusCode {\n+        COMPLETE( 1 ),\n+        RUNNING( 2 ),\n+        ERROR( 3 );\n \n         public final int status;\n \n@@ -170,14 +202,13 @@ public String getLastStatus() {\n         private boolean failed = false;\n \n \n-\n         @Override\n         public void failed( final int migrationVersion, final String reason ) {\n \n-            final String storedMessage = String.format( \"Failed to migrate, reason is appended.  Error '%s'\", reason);\n+            final String storedMessage = String.format( \"Failed to migrate, reason is appended.  Error '%s'\", reason );\n \n \n-            update(migrationVersion,  storedMessage );\n+            update( migrationVersion, storedMessage );\n \n             LOG.error( storedMessage );\n \n@@ -193,9 +224,10 @@ public void failed( final int migrationVersion, final String reason, final Throw\n             throwable.printStackTrace( new PrintWriter( stackTrace ) );\n \n \n-            final String storedMessage = String.format( \"Failed to migrate, reason is appended.  Error '%s' %s\", reason, stackTrace.toString() );\n+            final String storedMessage = String.format( \"Failed to migrate, reason is appended.  Error '%s' %s\", reason,\n+                    stackTrace.toString() );\n \n-            update(migrationVersion,  storedMessage );\n+            update( migrationVersion, storedMessage );\n \n \n             LOG.error( \"Unable to migrate version {} due to reason {}.\", migrationVersion, reason, throwable );\n@@ -208,15 +240,14 @@ public void failed( final int migrationVersion, final String reason, final Throw\n \n         @Override\n         public void update( final int migrationVersion, final String message ) {\n-            final String error = String.format( \"Migration version %d.  %s\", migrationVersion, message);\n+            final String error = String.format( \"Migration version %d.  %s\", migrationVersion, message );\n \n             migrationInfoSerialization.setStatusMessage( error );\n         }\n \n \n         /**\n          * Return true if we failed\n-         * @return\n          */\n         public boolean isFailed() {\n             return failed;",
                "raw_url": "https://github.com/apache/usergrid/raw/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/migration/data/DataMigrationManagerImpl.java",
                "sha": "4cc98df583fb68dc2caed929ef15c07f8aac90e2",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/usergrid/blob/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/guice/GraphModule.java",
                "changes": 40,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/guice/GraphModule.java?ref=09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
                "deletions": 30,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/guice/GraphModule.java",
                "patch": "@@ -27,6 +27,7 @@\n import org.apache.usergrid.persistence.core.guice.CurrentImpl;\n import org.apache.usergrid.persistence.core.guice.PreviousImpl;\n import org.apache.usergrid.persistence.core.guice.ProxyImpl;\n+import org.apache.usergrid.persistence.core.migration.data.DataMigrationManager;\n import org.apache.usergrid.persistence.core.migration.schema.Migration;\n import org.apache.usergrid.persistence.core.task.NamedTaskExecutorImpl;\n import org.apache.usergrid.persistence.core.task.TaskExecutor;\n@@ -157,6 +158,15 @@ protected void configure() {\n         //Get the old version and the new one\n         migrationBinding.addBinding().to( Key.get( EdgeMetadataSerialization.class, PreviousImpl.class) );\n         migrationBinding.addBinding().to( Key.get( EdgeMetadataSerialization.class, CurrentImpl.class  ) );\n+\n+\n+        /**\n+         * Migrations of our edge meta serialization\n+         */\n+\n+        bind(EdgeMetadataSerialization.class).annotatedWith( PreviousImpl.class ).to( EdgeMetadataSerializationV1Impl.class  );\n+        bind(EdgeMetadataSerialization.class).annotatedWith( CurrentImpl.class ).to( EdgeMetadataSerializationV2Impl.class  );\n+        bind(EdgeMetadataSerialization.class).annotatedWith( ProxyImpl.class ).to( EdgeMetadataSerializationProxyImpl.class  );\n     }\n \n \n@@ -170,36 +180,6 @@ public TaskExecutor graphTaskExecutor( final GraphFig graphFig ) {\n     }\n \n \n-    @Inject\n-    @Singleton\n-    @Provides\n-    @PreviousImpl\n-    public EdgeMetadataSerialization getPreviousEdgeMetaSerialization( final Keyspace keyspace,\n-                                                                       final CassandraConfig cassandraConfig,\n-                                                                       final GraphFig graphFig ) {\n-        return new EdgeMetadataSerializationV1Impl( keyspace, cassandraConfig, graphFig );\n-    }\n-\n-\n-    @Inject\n-    @Singleton\n-    @Provides\n-    @CurrentImpl\n-    public EdgeMetadataSerialization getCurrentEdgeMetaSerialization( final Keyspace keyspace,\n-                                                                      final CassandraConfig cassandraConfig,\n-                                                                      final GraphFig graphFig ) {\n-        return new EdgeMetadataSerializationV2Impl( keyspace, cassandraConfig, graphFig );\n-    }\n-\n-\n-    @Inject\n-    @Singleton\n-    @Provides\n-    @ProxyImpl\n-    public EdgeMetadataSerialization getCurrentEdgeMetaSerialization( @PreviousImpl final EdgeMetadataSerialization previous,\n-                                                   @CurrentImpl final EdgeMetadataSerialization current ) {\n-       return new EdgeMetadataSerializationProxyImpl( previous, current );\n-    }\n }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/guice/GraphModule.java",
                "sha": "dee53d458bd9b7263aad86461968d6fdcbb55ec6",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java?ref=09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
                "deletions": 3,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java",
                "patch": "@@ -92,9 +92,11 @@\n     @Inject\n     public GraphManagerImpl( @ProxyImpl final EdgeMetadataSerialization edgeMetadataSerialization,\n                              final EdgeSerialization storageEdgeSerialization,\n-                             final NodeSerialization nodeSerialization, final GraphFig graphFig,\n-                             @Assisted final ApplicationScope scope, final EdgeDeleteListener edgeDeleteListener,\n-                             final NodeDeleteListener nodeDeleteListener ) {\n+                             final NodeSerialization nodeSerialization,\n+                             final GraphFig graphFig,\n+                             final EdgeDeleteListener edgeDeleteListener,\n+                             final NodeDeleteListener nodeDeleteListener,\n+                             @Assisted final ApplicationScope scope) {\n \n \n         ValidationUtils.validateApplicationScope( scope );\n@@ -103,6 +105,7 @@ public GraphManagerImpl( @ProxyImpl final EdgeMetadataSerialization edgeMetadata\n         Preconditions.checkNotNull( nodeSerialization, \"nodeSerialization must not be null\" );\n         Preconditions.checkNotNull( graphFig, \"consistencyFig must not be null\" );\n         Preconditions.checkNotNull( scope, \"scope must not be null\" );\n+        Preconditions.checkNotNull( nodeDeleteListener, \"nodeDeleteListener must not be null\" );\n \n         this.scope = scope;\n         this.edgeMetadataSerialization = edgeMetadataSerialization;",
                "raw_url": "https://github.com/apache/usergrid/raw/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java",
                "sha": "df10816df2781107daa9924a28edf72980de1e19",
                "status": "modified"
            },
            {
                "additions": 147,
                "blob_url": "https://github.com/apache/usergrid/blob/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationProxyImpl.java",
                "changes": 165,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationProxyImpl.java?ref=09151ea0e9dd1f33dceddd6f33ada54389c42fd6",
                "deletions": 18,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationProxyImpl.java",
                "patch": "@@ -23,11 +23,13 @@\n \n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Iterator;\n \n import org.apache.usergrid.persistence.core.astyanax.MultiTennantColumnFamilyDefinition;\n import org.apache.usergrid.persistence.core.guice.CurrentImpl;\n import org.apache.usergrid.persistence.core.guice.PreviousImpl;\n+import org.apache.usergrid.persistence.core.migration.data.DataMigrationManager;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.SearchEdgeType;\n@@ -37,111 +39,238 @@\n \n import com.google.inject.Inject;\n import com.google.inject.Singleton;\n+import com.netflix.astyanax.Keyspace;\n import com.netflix.astyanax.MutationBatch;\n \n \n @Singleton\n public class EdgeMetadataSerializationProxyImpl implements EdgeMetadataSerialization {\n \n-    private EdgeMetadataSerialization previous;\n-    private EdgeMetadataSerialization current;\n+    private static final int MIGRATION_VERSION = 1;\n+\n+    private final DataMigrationManager dataMigrationManager;\n+    private final Keyspace keyspace;\n+    private final EdgeMetadataSerialization previous;\n+    private final EdgeMetadataSerialization current;\n \n \n     /**\n-     * TODO fin\n+     * Handles routing data to the right implementation, based on the current system migration version\n      */\n     @Inject\n-    public EdgeMetadataSerializationProxyImpl( @PreviousImpl final EdgeMetadataSerialization previous,\n+    public EdgeMetadataSerializationProxyImpl( final DataMigrationManager dataMigrationManager, final Keyspace keyspace,\n+                                               @PreviousImpl final EdgeMetadataSerialization previous,\n                                                @CurrentImpl final EdgeMetadataSerialization current ) {\n+        this.dataMigrationManager = dataMigrationManager;\n+        this.keyspace = keyspace;\n         this.previous = previous;\n         this.current = current;\n     }\n \n \n     @Override\n     public MutationBatch writeEdge( final ApplicationScope scope, final Edge edge ) {\n-        return null;\n+\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.writeEdge( scope, edge ) );\n+            aggregateBatch.mergeShallow( current.writeEdge( scope, edge ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.writeEdge( scope, edge );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeFromSource( final ApplicationScope scope, final Edge edge ) {\n-        return null;\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeEdgeTypeFromSource( scope, edge ) );\n+            aggregateBatch.mergeShallow( current.removeEdgeTypeFromSource( scope, edge ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeEdgeTypeFromSource( scope, edge );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeFromSource( final ApplicationScope scope, final Id sourceNode, final String type,\n                                                    final long timestamp ) {\n-        return null;\n+\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeEdgeTypeFromSource( scope, sourceNode, type, timestamp ) );\n+            aggregateBatch.mergeShallow( current.removeEdgeTypeFromSource( scope, sourceNode, type, timestamp ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeEdgeTypeFromSource( scope, sourceNode, type, timestamp );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeFromSource( final ApplicationScope scope, final Edge edge ) {\n-        return null;\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeIdTypeFromSource( scope, edge ) );\n+            aggregateBatch.mergeShallow( current.removeIdTypeFromSource( scope, edge ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeIdTypeFromSource( scope, edge );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeFromSource( final ApplicationScope scope, final Id sourceNode, final String type,\n                                                  final String idType, final long timestamp ) {\n-        return null;\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch\n+                    .mergeShallow( previous.removeIdTypeFromSource( scope, sourceNode, type, idType, timestamp ) );\n+            aggregateBatch.mergeShallow( current.removeIdTypeFromSource( scope, sourceNode, type, idType, timestamp ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeIdTypeFromSource( scope, sourceNode, type, idType, timestamp );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeToTarget( final ApplicationScope scope, final Edge edge ) {\n-        return null;\n+\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeEdgeTypeToTarget( scope, edge ) );\n+            aggregateBatch.mergeShallow( current.removeEdgeTypeToTarget( scope, edge ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeEdgeTypeToTarget( scope, edge );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeToTarget( final ApplicationScope scope, final Id targetNode, final String type,\n                                                  final long timestamp ) {\n-        return null;\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeEdgeTypeToTarget( scope, targetNode, type, timestamp ) );\n+            aggregateBatch.mergeShallow( current.removeEdgeTypeToTarget( scope, targetNode, type, timestamp ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeEdgeTypeToTarget( scope, targetNode, type, timestamp );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeToTarget( final ApplicationScope scope, final Edge edge ) {\n-        return null;\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeIdTypeFromSource( scope, edge ) );\n+            aggregateBatch.mergeShallow( current.removeIdTypeFromSource( scope, edge ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeIdTypeFromSource( scope, edge );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeToTarget( final ApplicationScope scope, final Id targetNode, final String type,\n                                                final String idType, final long timestamp ) {\n-        return null;\n+\n+\n+        if ( isOldVersion() ) {\n+            final MutationBatch aggregateBatch = keyspace.prepareMutationBatch();\n+\n+            aggregateBatch.mergeShallow( previous.removeIdTypeToTarget( scope, targetNode, type, idType, timestamp ) );\n+            aggregateBatch.mergeShallow( current.removeIdTypeToTarget( scope, targetNode, type, idType, timestamp ) );\n+\n+            return aggregateBatch;\n+        }\n+\n+        return current.removeIdTypeToTarget( scope, targetNode, type, idType, timestamp );\n     }\n \n \n     @Override\n     public Iterator<String> getEdgeTypesFromSource( final ApplicationScope scope, final SearchEdgeType search ) {\n-        return null;\n+        if ( isOldVersion() ) {\n+            return previous.getEdgeTypesFromSource( scope, search );\n+        }\n+\n+        return current.getEdgeTypesFromSource( scope, search );\n     }\n \n \n     @Override\n     public Iterator<String> getIdTypesFromSource( final ApplicationScope scope, final SearchIdType search ) {\n-        return null;\n+        if ( isOldVersion() ) {\n+            return previous.getIdTypesFromSource( scope, search );\n+        }\n+\n+        return current.getIdTypesFromSource( scope, search );\n     }\n \n \n     @Override\n     public Iterator<String> getEdgeTypesToTarget( final ApplicationScope scope, final SearchEdgeType search ) {\n-        return null;\n+        if ( isOldVersion() ) {\n+            return previous.getEdgeTypesToTarget( scope, search );\n+        }\n+\n+        return current.getEdgeTypesToTarget( scope, search );\n     }\n \n \n     @Override\n     public Iterator<String> getIdTypesToTarget( final ApplicationScope scope, final SearchIdType search ) {\n-        return null;\n+        if ( isOldVersion() ) {\n+            return previous.getIdTypesToTarget( scope, search );\n+        }\n+\n+        return current.getIdTypesToTarget( scope, search );\n     }\n \n \n     @Override\n     public Collection<MultiTennantColumnFamilyDefinition> getColumnFamilies() {\n-        return null;\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+\n+    /**\n+     * Return true if we're on an old version\n+     */\n+    private boolean isOldVersion() {\n+        return dataMigrationManager.getCurrentVersion() < MIGRATION_VERSION;\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/09151ea0e9dd1f33dceddd6f33ada54389c42fd6/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationProxyImpl.java",
                "sha": "cc5134937469f80048f4993da99c6b3de9bfa647",
                "status": "modified"
            }
        ],
        "message": "Cleaned up some code.  Need to remove Jukito or disable auto proxying.  Incorrect proxy wiring is causing NPE",
        "parent": "https://github.com/apache/usergrid/commit/dfed6a025a7fcb4c49decb4b3cf8bee37abeb1e7",
        "patched_files": [
            "DataMigrationManagerImpl.java",
            "CommonModule.java",
            "GraphModule.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "DataMigrationManagerImplTest.java",
            "TestGraphModule.java",
            "TestCommonModule.java"
        ]
    },
    "usergrid_183e0ea": {
        "bug_id": "usergrid_183e0ea",
        "commit": "https://github.com/apache/usergrid/commit/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/config/src/main/resources/corepersistence.properties",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/config/src/main/resources/corepersistence.properties?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/config/src/main/resources/corepersistence.properties",
                "patch": "@@ -36,7 +36,7 @@ collections.keyspace.strategy.class=org.apache.cassandra.locator.SimpleStrategy\n collection.stage.transient.timeout=60\n \n elasticsearch.embedded=true\n-elasticsearch.cluster_name=usergrid\n+elasticsearch.cluster_name=usergrid_test\n elasticsearch.index_prefix=usergrid\n elasticsearch.hosts=127.0.0.1\n elasticsearch.port=9300",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/config/src/main/resources/corepersistence.properties",
                "sha": "566e259afc61c31661c97dac40e0b36f39656fed",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/pom.xml",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/pom.xml?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 6,
                "filename": "stack/core/pom.xml",
                "patch": "@@ -506,12 +506,12 @@\n \t    <type>jar</type>\n     </dependency>\n \n-    <dependency>\n-      <artifactId>lucene-core</artifactId>\n-      <groupId>org.apache.lucene</groupId>\n-      <type>jar</type>\n-      <version>4.7.2</version>\n-    </dependency>\n+    <!--<dependency>-->\n+      <!--<artifactId>lucene-core</artifactId>-->\n+      <!--<groupId>org.apache.lucene</groupId>-->\n+      <!--<type>jar</type>-->\n+      <!--<version>4.7.2</version>-->\n+    <!--</dependency>-->\n \n     <dependency>\n         <groupId>org.jukito</groupId>",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/pom.xml",
                "sha": "12e282a706da192ebec83c5877a981f411b52788",
                "status": "modified"
            },
            {
                "additions": 324,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManager.java",
                "changes": 393,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManager.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 69,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManager.java",
                "patch": "@@ -30,6 +30,19 @@\n import java.util.TreeSet;\n import java.util.UUID;\n \n+import java.util.*;\n+\n+import javax.annotation.Resource;\n+\n+import org.apache.usergrid.persistence.*;\n+import org.apache.usergrid.persistence.EntityRef;\n+import org.apache.usergrid.persistence.Results;\n+import org.apache.usergrid.persistence.SimpleEntityRef;\n+import org.apache.usergrid.persistence.cassandra.*;\n+import org.apache.usergrid.persistence.entities.*;\n+import org.apache.usergrid.persistence.index.query.*;\n+import org.apache.usergrid.persistence.model.util.UUIDGenerator;\n+import org.apache.usergrid.utils.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.util.Assert;\n@@ -56,15 +69,13 @@\n import org.apache.usergrid.persistence.cassandra.ConnectionRefImpl;\n import org.apache.usergrid.persistence.cassandra.CounterUtils;\n import org.apache.usergrid.persistence.cassandra.GeoIndexManager;\n+\n import org.apache.usergrid.persistence.cassandra.util.TraceParticipant;\n import org.apache.usergrid.persistence.collection.CollectionScope;\n import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n import org.apache.usergrid.persistence.collection.exception.WriteUniqueVerifyException;\n import org.apache.usergrid.persistence.collection.impl.CollectionScopeImpl;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n-import org.apache.usergrid.persistence.entities.Application;\n-import org.apache.usergrid.persistence.entities.Event;\n-import org.apache.usergrid.persistence.entities.Role;\n import org.apache.usergrid.persistence.exceptions.DuplicateUniquePropertyExistsException;\n import org.apache.usergrid.persistence.exceptions.RequiredPropertyNotFoundException;\n import org.apache.usergrid.persistence.index.EntityIndex;\n@@ -73,6 +84,7 @@\n import org.apache.usergrid.persistence.index.query.CounterResolution;\n import org.apache.usergrid.persistence.index.query.Identifier;\n import org.apache.usergrid.persistence.index.query.Query;\n+\n import org.apache.usergrid.persistence.index.query.Query.Level;\n import org.apache.usergrid.persistence.model.entity.Id;\n import org.apache.usergrid.persistence.model.entity.SimpleId;\n@@ -98,9 +110,11 @@\n import me.prettyprint.hector.api.query.MultigetSliceCounterQuery;\n import me.prettyprint.hector.api.query.QueryResult;\n import me.prettyprint.hector.api.query.SliceCounterQuery;\n+import rx.Observable;\n \n import static java.lang.String.CASE_INSENSITIVE_ORDER;\n import static java.util.Arrays.asList;\n+import java.util.HashSet;\n \n import static me.prettyprint.hector.api.factory.HFactory.createCounterSliceQuery;\n import static me.prettyprint.hector.api.factory.HFactory.createMutator;\n@@ -117,6 +131,10 @@\n import static org.apache.usergrid.persistence.SimpleEntityRef.getUuid;\n import static org.apache.usergrid.persistence.SimpleEntityRef.ref;\n import static org.apache.usergrid.persistence.cassandra.ApplicationCF.APPLICATION_AGGREGATE_COUNTERS;\n+import static org.apache.usergrid.persistence.Schema.*;\n+import static org.apache.usergrid.persistence.SimpleEntityRef.ref;\n+import static org.apache.usergrid.persistence.SimpleRoleRef.getIdForGroupIdAndRoleName;\n+import static org.apache.usergrid.persistence.SimpleRoleRef.getIdForRoleName;\n import static org.apache.usergrid.persistence.cassandra.ApplicationCF.ENTITY_COMPOSITE_DICTIONARIES;\n import static org.apache.usergrid.persistence.cassandra.ApplicationCF.ENTITY_COUNTERS;\n import static org.apache.usergrid.persistence.cassandra.ApplicationCF.ENTITY_DICTIONARIES;\n@@ -148,10 +166,11 @@\n public class CpEntityManager implements EntityManager {\n     private static final Logger logger = LoggerFactory.getLogger( CpEntityManager.class );\n \n-    private static final String COLL_SUFFIX = \"zzzcollzzz\";\n     public static final String APPLICATION_COLLECTION = \"application.collection.\";\n     public static final String APPLICATION_ENTITIES = \"application.entities\";\n     public static final long ONE_COUNT = 1L;\n+    private static final String COLL_SUFFIX = \"zzzcollzzz\";\n+    private static final String CONN_SUFFIX = \"zzzconnzzz\"; \n \n     private UUID applicationId;\n     private Application application;\n@@ -226,10 +245,16 @@ static String getCollectionScopeNameFromEntityType( String type) {\n     }\n \n \n-   static String getCollectionScopeNameFromCollectionName( String name ) {\n-       String csn = name + COLL_SUFFIX;\n-       return csn;\n-   }\n+    static String getCollectionScopeNameFromCollectionName( String name ) {\n+        String csn = name + COLL_SUFFIX;\n+        return csn;\n+    }\n+\n+\n+    static String getConnectionScopeName( String connectionType ) {\n+        String csn = connectionType + CONN_SUFFIX;\n+        return csn;\n+    }\n \n \n     @Override\n@@ -515,6 +540,10 @@ private void updateEntityIndexes( Entity entity,\n \n     @Override\n     public void delete( EntityRef entityRef ) throws Exception {\n+        deleteAsync( entityRef ).toBlockingObservable().last();\n+    }\n+\n+    private Observable deleteAsync( EntityRef entityRef ) throws Exception {\n \n         CollectionScope collectionScope = new CollectionScopeImpl( \n             appScope.getApplication(), \n@@ -571,7 +600,9 @@ public void delete( EntityRef entityRef ) throws Exception {\n \n \n             // and finally...\n-            ecm.delete( entityId ).toBlockingObservable().last();\n+            return ecm.delete( entityId );\n+        }else{\n+            return Observable.empty();\n         }\n     }\n \n@@ -1315,127 +1346,295 @@ public Results searchConnectedEntities(\n \n     @Override\n     public Map<String, String> getRoles() throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        return cast( getDictionaryAsMap( getApplicationRef(), DICTIONARY_ROLENAMES ) );\n     }\n \n     @Override\n     public void resetRoles() throws Exception {\n-        // TODO\n+        try {\n+            createRole( \"admin\", \"Administrator\", 0 );\n+        }\n+        catch ( Exception e ) {\n+            logger.error( \"Could not create admin role, may already exist\", e );\n+        }\n+\n+        try {\n+            createRole( \"default\", \"Default\", 0 );\n+        }\n+        catch ( Exception e ) {\n+            logger.error( \"Could not create default role, may already exist\", e );\n+        }\n+\n+        try {\n+            createRole( \"guest\", \"Guest\", 0 );\n+        }\n+        catch ( Exception e ) {\n+            logger.error( \"Could not create guest role, may already exist\", e );\n+        }\n+\n+        try {\n+            grantRolePermissions( \"default\", Arrays.asList(\"get,put,post,delete:/**\") );\n+        }\n+        catch ( Exception e ) {\n+            logger.error( \"Could not populate default role\", e );\n+        }\n+\n+        try {\n+            grantRolePermissions( \"guest\", Arrays.asList( \"post:/users\", \"post:/devices\", \"put:/devices/*\" ) );\n+        }\n+        catch ( Exception e ) {\n+            logger.error( \"Could not populate guest role\", e );\n+        }\n     }\n \n     @Override\n     public Entity createRole(String roleName, String roleTitle, long inactivity) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+\n+        String propertyName = roleName;\n+        UUID ownerId = applicationId;\n+        String batchRoleName = StringUtils.stringOrSubstringAfterLast(roleName.toLowerCase(), ':');\n+        return batchCreateRole(batchRoleName, roleTitle, inactivity, propertyName, ownerId,null);\n     }\n \n+    private Entity batchCreateRole(String roleName, String roleTitle, long inactivity, String propertyName, UUID ownerId,Map<String, Object> additionalProperties ) throws Exception {\n+        UUID timestampUuid = newTimeUUID();\n+        long timestamp = getTimestampInMicros(timestampUuid);\n+\n+        Map<String, Object> properties = new TreeMap<>( CASE_INSENSITIVE_ORDER );\n+        properties.put( PROPERTY_TYPE, Role.ENTITY_TYPE );\n+        properties.put( PROPERTY_NAME, propertyName );\n+        properties.put( \"roleName\", roleName );\n+        properties.put( \"title\", roleTitle );\n+        properties.put( PROPERTY_INACTIVITY, inactivity );\n+        if(additionalProperties!=null) {\n+            for (String key : additionalProperties.keySet()) {\n+                properties.put(key, additionalProperties.get(key));\n+            }\n+        }\n+\n+        UUID id = UUIDGenerator.newTimeUUID();\n+        batchCreate( null, Role.ENTITY_TYPE, null, properties,  id, timestampUuid );\n+\n+        Mutator<ByteBuffer> batch = createMutator( cass.getApplicationKeyspace( applicationId ), be );\n+        addInsertToMutator( batch, ENTITY_DICTIONARIES, key( ownerId, Schema.DICTIONARY_ROLENAMES ),\n+                roleName, roleTitle, timestamp );\n+        addInsertToMutator( batch, ENTITY_DICTIONARIES, key( ownerId, Schema.DICTIONARY_ROLETIMES ),\n+                roleName, inactivity, timestamp );\n+        addInsertToMutator( batch, ENTITY_DICTIONARIES, key(  ownerId, DICTIONARY_SETS ),\n+                Schema.DICTIONARY_ROLENAMES, null, timestamp );\n+\n+        batchExecute( batch, CassandraService.RETRY_COUNT );\n+\n+        return get( id ,Role.class );\n+    }\n+\n+\n     @Override\n     public void grantRolePermission(String roleName, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        permission = permission.toLowerCase();\n+        long timestamp = cass.createTimestamp();\n+        Mutator<ByteBuffer> batch = createMutator( cass.getApplicationKeyspace( applicationId ), be );\n+        addInsertToMutator( batch, ApplicationCF.ENTITY_DICTIONARIES, getRolePermissionsKey( roleName ), permission,\n+                ByteBuffer.allocate( 0 ), timestamp );\n+        batchExecute( batch, CassandraService.RETRY_COUNT );\n     }\n \n     @Override\n     public void grantRolePermissions(\n             String roleName, Collection<String> permissions) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        long timestamp = cass.createTimestamp();\n+        Mutator<ByteBuffer> batch = createMutator( cass.getApplicationKeyspace( applicationId ), be );\n+        for ( String permission : permissions ) {\n+            permission = permission.toLowerCase();\n+            addInsertToMutator( batch, ApplicationCF.ENTITY_DICTIONARIES, getRolePermissionsKey( roleName ), permission,\n+                    ByteBuffer.allocate( 0 ), timestamp );\n+        }\n+        batchExecute( batch, CassandraService.RETRY_COUNT );\n+    }\n+\n+    private Object getRolePermissionsKey( String roleName ) {\n+        return key( getIdForRoleName( roleName ), DICTIONARY_PERMISSIONS );\n+    }\n+\n+    private Object getRolePermissionsKey( UUID groupId, String roleName ) {\n+        return key( getIdForGroupIdAndRoleName( groupId, roleName ), DICTIONARY_PERMISSIONS );\n     }\n \n     @Override\n     public void revokeRolePermission(String roleName, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        permission = permission.toLowerCase();\n+        long timestamp = cass.createTimestamp();\n+        Mutator<ByteBuffer> batch = createMutator( cass.getApplicationKeyspace( applicationId ), be );\n+        CassandraPersistenceUtils\n+                .addDeleteToMutator(batch, ApplicationCF.ENTITY_DICTIONARIES, getRolePermissionsKey(roleName),\n+                        permission, timestamp);\n+        batchExecute( batch, CassandraService.RETRY_COUNT );\n     }\n \n     @Override\n     public Set<String> getRolePermissions(String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        return cass.getAllColumnNames( cass.getApplicationKeyspace( applicationId ), ApplicationCF.ENTITY_DICTIONARIES,\n+                getRolePermissionsKey( roleName ) );\n     }\n \n     @Override\n     public void deleteRole(String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        removeFromDictionary( getApplicationRef(), DICTIONARY_ROLENAMES, roleName );\n+        removeFromDictionary( getApplicationRef(), DICTIONARY_ROLETIMES, roleName );\n+        EntityRef entity = getRoleRef(roleName);\n+        if(entity != null) {\n+            delete(entity);\n+        }\n     }\n \n     @Override\n     public Map<String, String> getGroupRoles(UUID groupId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        return cast(getDictionaryAsMap(new SimpleEntityRef(Group.ENTITY_TYPE, groupId), DICTIONARY_ROLENAMES));\n     }\n \n     @Override\n     public Entity createGroupRole(UUID groupId, String roleName, long inactivity) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        String batchRoleName = StringUtils.stringOrSubstringAfterLast(roleName.toLowerCase(), ':');\n+        String roleTitle = batchRoleName;\n+        String propertyName = groupId + \":\" + batchRoleName;\n+        Map<String, Object> properties = new TreeMap<String, Object>( CASE_INSENSITIVE_ORDER );\n+        properties.put( \"group\", groupId );\n+\n+        Entity entity =  batchCreateRole(roleName,roleTitle,inactivity,propertyName,groupId,properties);\n+        getRelationManager(  new SimpleEntityRef(Group.ENTITY_TYPE,groupId) ).addToCollection(COLLECTION_ROLES, entity);\n+\n+        return entity;\n     }\n \n     @Override\n-    public void grantGroupRolePermission(\n-            UUID groupId, String roleName, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void grantGroupRolePermission( UUID groupId, String roleName, String permission ) throws Exception {\n+        roleName = roleName.toLowerCase();\n+        permission = permission.toLowerCase();\n+        long timestamp = cass.createTimestamp();\n+        Mutator<ByteBuffer> batch = createMutator( cass.getApplicationKeyspace( applicationId ), be );\n+        addInsertToMutator( batch, ApplicationCF.ENTITY_DICTIONARIES, getRolePermissionsKey( groupId, roleName ),\n+                permission, ByteBuffer.allocate( 0 ), timestamp );\n+        batchExecute( batch, CassandraService.RETRY_COUNT );\n     }\n \n+\n     @Override\n-    public void revokeGroupRolePermission(\n-            UUID groupId, String roleName, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void revokeGroupRolePermission( UUID groupId, String roleName, String permission ) throws Exception {\n+        roleName = roleName.toLowerCase();\n+        permission = permission.toLowerCase();\n+        long timestamp = cass.createTimestamp();\n+        Mutator<ByteBuffer> batch = createMutator( cass.getApplicationKeyspace( applicationId ), be );\n+        CassandraPersistenceUtils.addDeleteToMutator( batch, ApplicationCF.ENTITY_DICTIONARIES,\n+                getRolePermissionsKey( groupId, roleName ), permission, timestamp );\n+        batchExecute( batch, CassandraService.RETRY_COUNT );\n     }\n \n     @Override\n     public Set<String> getGroupRolePermissions(UUID groupId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        return cass.getAllColumnNames( cass.getApplicationKeyspace( applicationId ), ApplicationCF.ENTITY_DICTIONARIES,\n+                getRolePermissionsKey( groupId, roleName ) );\n     }\n \n     @Override\n     public void deleteGroupRole(UUID groupId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        removeFromDictionary( new SimpleEntityRef(Group.ENTITY_TYPE ,groupId ), DICTIONARY_ROLENAMES, roleName );\n+        cass.deleteRow( cass.getApplicationKeyspace( applicationId ), ApplicationCF.ENTITY_DICTIONARIES,\n+                getIdForGroupIdAndRoleName( groupId, roleName ) );\n     }\n \n     @Override\n-    public Set<String> getUserRoles(UUID userId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public Set<String> getUserRoles( UUID userId ) throws Exception {\n+        return cast( getDictionaryAsSet( userRef( userId ), DICTIONARY_ROLENAMES ) );\n     }\n \n     @Override\n     public void addUserToRole(UUID userId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        addToDictionary( userRef(userId), DICTIONARY_ROLENAMES, roleName, roleName );\n+        addToCollection( userRef( userId ), COLLECTION_ROLES, getRoleRef(roleName) );\n     }\n \n+    private EntityRef userRef(UUID userId){\n+        return new SimpleEntityRef(User.ENTITY_TYPE,userId);\n+    }\n     @Override\n     public void removeUserFromRole(UUID userId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        removeFromDictionary( userRef(userId), DICTIONARY_ROLENAMES, roleName );\n+        removeFromCollection( userRef(userId), COLLECTION_ROLES, getRoleRef(roleName) );\n     }\n \n     @Override\n     public Set<String> getUserPermissions(UUID userId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        return cast( getDictionaryAsSet( new SimpleEntityRef( User.ENTITY_TYPE,userId ), Schema.DICTIONARY_PERMISSIONS ) );\n     }\n \n     @Override\n     public void grantUserPermission(UUID userId, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        permission = permission.toLowerCase();\n+        addToDictionary( userRef(userId), DICTIONARY_PERMISSIONS, permission );\n     }\n \n     @Override\n-    public void revokeUserPermission(UUID userId, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void revokeUserPermission( UUID userId, String permission ) throws Exception {\n+        permission = permission.toLowerCase();\n+        removeFromDictionary( userRef(userId), DICTIONARY_PERMISSIONS, permission );\n     }\n \n+\n     @Override\n-    public Map<String, String> getUserGroupRoles(UUID userId, UUID groupId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public Map<String, String> getUserGroupRoles( UUID userId, UUID groupId ) throws Exception {\n+        // TODO this never returns anything - write path not invoked\n+        EntityRef userRef =  userRef(userId);\n+        return cast( getDictionaryAsMap( userRef, DICTIONARY_ROLENAMES ) );\n     }\n \n+\n     @Override\n     public void addUserToGroupRole(UUID userId, UUID groupId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        EntityRef userRef =  userRef(userId);\n+        EntityRef roleRef = getRoleRef(roleName);\n+        addToDictionary( userRef, DICTIONARY_ROLENAMES, roleName, roleName );\n+        addToCollection( userRef, COLLECTION_ROLES, roleRef );\n+        addToCollection( roleRef, COLLECTION_USERS, userRef );\n     }\n \n     @Override\n     public void removeUserFromGroupRole(UUID userId, UUID groupId, String roleName) \n             throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        roleName = roleName.toLowerCase();\n+        EntityRef memberRef = userRef(userId);\n+        EntityRef roleRef = getRoleRef(roleName);\n+        removeFromDictionary( memberRef, DICTIONARY_ROLENAMES, roleName );\n+        removeFromCollection( memberRef, COLLECTION_ROLES, roleRef );\n+        removeFromCollection( roleRef, COLLECTION_USERS, userRef( userId ) );\n     }\n \n     @Override\n     public Results getUsersInGroupRole(\n             UUID groupId, String roleName, Level level) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        return this.getCollection( getRoleRef(roleName), COLLECTION_USERS, null, 10000, level, false );\n+    }\n+    private EntityRef getRoleRef(String roleName) throws Exception{\n+        Results results = this.searchCollection(\n+                new SimpleEntityRef(\"application\", applicationId),\n+                Schema.defaultCollectionName(Role.ENTITY_TYPE),\n+                Query.findForProperty(\"roleName\", roleName)\n+        );\n+        Iterator<Entity> iterator = results.iterator();\n+        EntityRef roleRef = null;\n+        while(iterator.hasNext()) {\n+            roleRef = iterator.next();\n+        }\n+        return roleRef;\n     }\n \n     @Override\n@@ -1457,6 +1656,7 @@ private void incrementAggregateCounters( UUID userId, UUID groupId, String categ\n \n             batchExecute( m, CassandraService.RETRY_COUNT );\n         }\n+\n     }\n \n     @Override\n@@ -1465,6 +1665,7 @@ public Results getAggregateCounters(\n             CounterResolution resolution, long start, long finish, boolean pad) {\n         return this.getAggregateCounters(\n                 userId, groupId, null, category, counterName, resolution, start, finish, pad );\n+\n     }\n \n     @Override\n@@ -1502,6 +1703,7 @@ public Results getAggregateCounters(\n             }\n         }\n         return Results.fromCounters( new AggregateCounterSet( counterName, userId, groupId, category, counters ) );\n+\n     }\n \n     @Override\n@@ -1587,8 +1789,9 @@ public int compare( AggregateCounterSet o1, AggregateCounterSet o2 ) {\n         return Results.fromCounters( countSets );\n     }\n \n+\n     @Override\n-    public EntityRef getUserByIdentifier(Identifier identifier) throws Exception {\n+    public EntityRef getUserByIdentifier( Identifier identifier ) throws Exception {\n         if ( identifier == null ) {\n             return null;\n         }\n@@ -1622,8 +1825,9 @@ public EntityRef getUserByIdentifier(Identifier identifier) throws Exception {\n         return null;\n     }\n \n+\n     @Override\n-    public EntityRef getGroupByIdentifier(Identifier identifier) throws Exception {\n+    public EntityRef getGroupByIdentifier( Identifier identifier ) throws Exception {\n         if ( identifier == null ) {\n             return null;\n         }\n@@ -1644,6 +1848,7 @@ public EntityRef getGroupByIdentifier(Identifier identifier) throws Exception {\n         Set<String> nameSet = cast( getDictionaryAsSet( getApplicationRef(), Schema.DICTIONARY_COUNTERS ) );\n         names.addAll( nameSet );\n         return names;\n+\n     }\n \n     @Override\n@@ -1658,23 +1863,27 @@ public EntityRef getGroupByIdentifier(Identifier identifier) throws Exception {\n             counters.put( column.getName(), column.getValue() );\n         }\n         return counters;\n+\n     }\n \n     @Override\n     public Map<String, Long> getApplicationCounters() throws Exception {\n         return getEntityCounters( applicationId );\n+\n     }\n \n     @Override\n     public void incrementAggregateCounters(\n             UUID userId, UUID groupId, String category, Map<String, Long> counters) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+\n+        // TODO: add an implementation here...\n     }\n \n     @Override\n     public boolean isPropertyValueUniqueForEntity(\n             String entityType, String propertyName, Object propertyValue) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+\n+        return true; // TODO: is it OK to rely on Core Persistence write-time check for this?\n     }\n \n     @Override\n@@ -1719,47 +1928,101 @@ public Results getEntities(List<UUID> ids, String type) {\n \n     @Override\n     public Map<String, Role> getRolesWithTitles(Set<String> roleNames) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        Map<String, Role> rolesWithTitles = new HashMap<String, Role>();\n+\n+        Map<String, Object> nameResults = null;\n+\n+        if ( roleNames != null ) {\n+            nameResults = getDictionaryElementValues( getApplicationRef(), DICTIONARY_ROLENAMES,\n+                    roleNames.toArray(new String[roleNames.size()]));\n+        }\n+        else {\n+            nameResults = cast( getDictionaryAsMap( getApplicationRef(), DICTIONARY_ROLENAMES ) );\n+            roleNames = nameResults.keySet();\n+        }\n+        Map<String, Object> timeResults = getDictionaryElementValues( getApplicationRef(), DICTIONARY_ROLETIMES,\n+                roleNames.toArray(new String[roleNames.size()]));\n+\n+        for ( String roleName : roleNames ) {\n+\n+            String savedTitle = string( nameResults.get( roleName ) );\n+\n+            // no title, skip the role\n+            if ( savedTitle == null ) {\n+                continue;\n+            }\n+\n+            Role newRole = new Role();\n+            newRole.setName( roleName );\n+            newRole.setTitle( savedTitle );\n+            newRole.setInactivity( getLong( timeResults.get( roleName ) ) );\n+\n+            rolesWithTitles.put( roleName, newRole );\n+        }\n+\n+        return rolesWithTitles;\n     }\n \n     @Override\n     public String getRoleTitle(String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+        String title = string( getDictionaryElementValue( getApplicationRef(), DICTIONARY_ROLENAMES, roleName ) );\n+        if ( title == null ) {\n+            title = roleName;\n+        }\n+        return title;\n     }\n \n+    @SuppressWarnings( \"unchecked\" )\n     @Override\n-    public Map<String, Role> getUserRolesWithTitles(UUID userId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public Map<String, Role> getUserRolesWithTitles( UUID userId ) throws Exception {\n+        return getRolesWithTitles(\n+                ( Set<String> ) cast( getDictionaryAsSet( userRef( userId ), DICTIONARY_ROLENAMES ) ) );\n     }\n \n+    @SuppressWarnings( \"unchecked\" )\n     @Override\n-    public Map<String, Role> getGroupRolesWithTitles(UUID userId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public Map<String, Role> getGroupRolesWithTitles( UUID groupId ) throws Exception {\n+        return getRolesWithTitles(\n+                ( Set<String> ) cast( getDictionaryAsSet( groupRef( groupId ), DICTIONARY_ROLENAMES ) ) );\n     }\n \n     @Override\n-    public void addGroupToRole(UUID userId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void addGroupToRole( UUID groupId, String roleName ) throws Exception {\n+        roleName = roleName.toLowerCase();\n+        addToDictionary( groupRef( groupId ), DICTIONARY_ROLENAMES, roleName, roleName );\n+        addToCollection( groupRef( groupId ), COLLECTION_ROLES, getRoleRef( roleName ) );\n     }\n \n+\n     @Override\n-    public void removeGroupFromRole(UUID userId, String roleName) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void removeGroupFromRole( UUID groupId, String roleName ) throws Exception {\n+        roleName = roleName.toLowerCase();\n+        removeFromDictionary( groupRef( groupId ), DICTIONARY_ROLENAMES, roleName );\n+        removeFromCollection( groupRef( groupId ), COLLECTION_ROLES, getRoleRef( roleName ) );\n     }\n \n+\n     @Override\n-    public Set<String> getGroupPermissions(UUID groupId) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public Set<String> getGroupPermissions( UUID groupId ) throws Exception {\n+        return cast( getDictionaryAsSet( groupRef( groupId ), Schema.DICTIONARY_PERMISSIONS ) );\n     }\n \n+\n     @Override\n-    public void grantGroupPermission(UUID groupId, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void grantGroupPermission( UUID groupId, String permission ) throws Exception {\n+        permission = permission.toLowerCase();\n+        addToDictionary( groupRef( groupId ), DICTIONARY_PERMISSIONS, permission );\n     }\n \n+\n     @Override\n-    public void revokeGroupPermission(UUID groupId, String permission) throws Exception {\n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n+    public void revokeGroupPermission( UUID groupId, String permission ) throws Exception {\n+        permission = permission.toLowerCase();\n+        removeFromDictionary( groupRef( groupId ), DICTIONARY_PERMISSIONS, permission );\n+    }\n+\n+    private EntityRef groupRef(UUID groupId){\n+        return new SimpleEntityRef( Group.ENTITY_TYPE, groupId );\n     }\n \n     @Override\n@@ -2001,6 +2264,7 @@ private void incrementEntityCollection( String collection_name, long cassandraTi\n         }\n     }\n \n+\n     private void handleWriteUniqueVerifyException( Entity entity, WriteUniqueVerifyException wuve) \n             throws DuplicateUniquePropertyExistsException {\n \n@@ -2012,15 +2276,6 @@ private void handleWriteUniqueVerifyException( Entity entity, WriteUniqueVerifyE\n             entity.getType(), conflict.getName(), conflict.getValue()); \n     }\n     \n-\n-    @Override\n-    public void batchCreateRole(\n-            Mutator<ByteBuffer> batch, UUID groupId, String roleName, String roleTitle, \n-            long inactivity, RoleRef roleRef, UUID timestampUuid) throws Exception {\n-        \n-        throw new UnsupportedOperationException(\"Not supported yet.\"); \n-    }\n-\n     @Override\n     public Mutator<ByteBuffer> batchSetProperty(\n             Mutator<ByteBuffer> batch, EntityRef entity, String propertyName, Object propertyValue, ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManager.java",
                "sha": "c600554a1b70ba021b0f963b55c49aa44949eec0",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManagerFactory.java",
                "changes": 38,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManagerFactory.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 19,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManagerFactory.java",
                "patch": "@@ -233,8 +233,7 @@ public UUID initializeApplication( String organizationName, UUID applicationId,\n         if ( orgUuid == null ) {\n           \n             // organization does not exist, create it.\n-            Entity orgInfoEntity = new Entity(\n-                new SimpleId(UUIDGenerator.newTimeUUID(), \"organization\" ));\n+            Entity orgInfoEntity = new Entity(generateOrgId( UUIDGenerator.newTimeUUID() ));\n \n             orgUuid = orgInfoEntity.getId().getUuid();\n \n@@ -258,8 +257,7 @@ public UUID initializeApplication( String organizationName, UUID applicationId,\n         }\n         properties.put( PROPERTY_NAME, appName );\n \n-        Entity appInfoEntity = new Entity(\n-            new SimpleId(UUIDGenerator.newTimeUUID(), \"application\" ));\n+        Entity appInfoEntity = new Entity(generateApplicationId( UUIDGenerator.newTimeUUID() ));\n \n         long timestamp = System.currentTimeMillis();\n         appInfoEntity.setField( new LongField( PROPERTY_CREATED, (long)(timestamp / 1000)));\n@@ -290,22 +288,11 @@ public UUID initializeApplication( String organizationName, UUID applicationId,\n \n     public ApplicationScope getApplicationScope( UUID applicationId ) {\n \n-        Query q = Query.fromQL( PROPERTY_UUID + \" = '\" + applicationId.toString() + \"'\");\n+        //We can always generate a scope, it doesn't matter if  the application exists yet or not.\n \n-        EntityCollectionManager em= getManagerCache().getEntityCollectionManager(SYSTEM_APP_SCOPE);\n-        EntityIndex ei = getManagerCache().getEntityIndex( SYSTEM_APPS_INDEX_SCOPE );\n-        CandidateResults results = ei.search( q );\n-\n-        if ( results.isEmpty() ) {\n-            return null;\n-        }\n-\n-        CandidateResult candidateResult = results.iterator().next(); \n-\n-        Entity appEntity = em.load( candidateResult.getId() ).toBlockingObservable().last();\n+        final ApplicationScopeImpl scope = new ApplicationScopeImpl( generateApplicationId( applicationId ) );\n \n-        return new ApplicationScopeImpl(\n-            new SimpleId( appEntity.getId().getUuid(), \"application\"));\n+        return scope;\n     }\n     \n \n@@ -379,7 +366,7 @@ public UUID lookupApplication( String name) throws Exception {\n     \n     @Override\n     public void setup() throws Exception {\n-        // no op?\n+        getSetup().init();\n     }\n \n     \n@@ -489,6 +476,11 @@ public ApplicationContext getApplicationContext() {\n     @Override\n     public void setApplicationContext( ApplicationContext applicationContext ) throws BeansException {\n         this.applicationContext = applicationContext;\n+        try {\n+            setup();\n+        } catch (Exception ex) {\n+            logger.error(\"Error setting up EMF\", ex);\n+        }\n     }\n \n     /**\n@@ -511,6 +503,14 @@ public UUID getDefaultAppId() {\n         return DEFAULT_APPLICATION_ID; \n     }\n \n+    private Id generateOrgId(UUID id){\n+        return new SimpleId( id, \"organization\" );\n+    }\n+\n+\n+    private Id generateApplicationId(UUID id){\n+        return new SimpleId( id, \"application\" );\n+    }\n     \n     /**\n      * Gets the setup.",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManagerFactory.java",
                "sha": "c2ab923c0ff397b4aca8684827d1d8e45907a8a3",
                "status": "modified"
            },
            {
                "additions": 89,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "changes": 141,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 52,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "patch": "@@ -64,7 +64,7 @@\n import org.apache.usergrid.persistence.geo.model.Point;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.GraphManager;\n-import org.apache.usergrid.persistence.graph.impl.SimpleMarkedEdge;\n+import org.apache.usergrid.persistence.graph.impl.SimpleEdge;\n import org.apache.usergrid.persistence.graph.impl.SimpleSearchByEdge;\n import org.apache.usergrid.persistence.graph.impl.SimpleSearchByEdgeType;\n import org.apache.usergrid.persistence.graph.impl.SimpleSearchEdgeType;\n@@ -78,7 +78,6 @@\n import org.apache.usergrid.persistence.index.query.Query.Level;\n import org.apache.usergrid.persistence.model.entity.Id;\n import org.apache.usergrid.persistence.model.entity.SimpleId;\n-import org.apache.usergrid.persistence.model.util.UUIDGenerator;\n \n import org.apache.usergrid.persistence.query.ir.AllNode;\n import org.apache.usergrid.persistence.query.ir.NameIdentifierNode;\n@@ -281,7 +280,7 @@ public String getConnectionName( String edgeType ) {\n             String edgeType = edgeTypes.next();\n \n             Observable<Edge> edges = gm.loadEdgesToTarget( new SimpleSearchByEdgeType( \n-                cpHeadEntity.getId(), edgeType, cpHeadEntity.getVersion(), null ));\n+                cpHeadEntity.getId(), edgeType, Long.MAX_VALUE, null ));\n \n             Iterator<Edge> iter = edges.toBlockingObservable().getIterator();\n             while ( iter.hasNext() ) {\n@@ -328,7 +327,7 @@ public boolean isCollectionMember(String collName, EntityRef entity) throws Exce\n                     new SimpleId(headEntity.getUuid(), headEntity.getType()), \n                     collName,  \n                     entityId, \n-                    UUIDGenerator.newTimeUUID(), \n+                    Long.MAX_VALUE,\n                     null));\n \n         return edges.toBlockingObservable().firstOrDefault(null) != null;\n@@ -403,9 +402,9 @@ public Entity addToCollection(String collName, EntityRef memberRef) throws Excep\n         }\n \n         // create graph edge connection from head entity to member entity\n-        Edge edge = new SimpleMarkedEdge( \n+        Edge edge = new SimpleEdge(\n             cpHeadEntity.getId(), getEdgeTypeFromCollectionName( collName ), memberEntity.getId(), \n-            UUIDGenerator.newTimeUUID(), false );\n+           memberEntity.getId().getUuid().timestamp() );\n \n         GraphManager gm = managerCache.getGraphManager(applicationScope);\n         gm.writeEdge(edge).toBlockingObservable().last();\n@@ -539,9 +538,9 @@ public void removeFromCollection(String collName, EntityRef memberRef) throws Ex\n         ei.deindex( memberEntity );\n \n         // remove collection edge\n-        Edge edge = new SimpleMarkedEdge( cpHeadEntity.getId(), \n+        Edge edge = new SimpleEdge( cpHeadEntity.getId(),\n             getEdgeTypeFromCollectionName( collName ), memberEntity.getId(), \n-            UUIDGenerator.newTimeUUID(), false );\n+           memberEntity.getId().getUuid().timestamp() );\n         GraphManager gm = managerCache.getGraphManager(applicationScope);\n         gm.deleteEdge(edge).toBlockingObservable().last();\n \n@@ -631,8 +630,8 @@ public ConnectionRef createConnection(\n                 .toBlockingObservable().last();\n \n         // create graph edge connection from head entity to member entity\n-        Edge edge = new SimpleMarkedEdge( cpHeadEntity.getId(), connectionType, \n-            targetEntity.getId(), UUIDGenerator.newTimeUUID(), false );\n+        Edge edge = new SimpleEdge( cpHeadEntity.getId(), connectionType,\n+            targetEntity.getId(), System.currentTimeMillis() );\n \n         GraphManager gm = managerCache.getGraphManager(applicationScope);\n         gm.writeEdge(edge).toBlockingObservable().last();\n@@ -641,7 +640,7 @@ public ConnectionRef createConnection(\n         IndexScope indexScope = new IndexScopeImpl(\n             applicationScope.getApplication(), \n             cpHeadEntity.getId(), \n-            CpEntityManager.getCollectionScopeNameFromEntityType( connectionType ) );\n+            CpEntityManager.getConnectionScopeName( connectionType ));\n         EntityIndex ei = managerCache.getEntityIndex(indexScope);\n         ei.index( targetEntity );\n \n@@ -719,23 +718,59 @@ public void deleteConnection(ConnectionRef connectionRef) throws Exception {\n         throw new UnsupportedOperationException(\"Not supported yet.\"); \n     }\n \n+\n     @Override\n-    public Results getConnectedEntities(String connectionType, String connectedEntityType, \n-            Level resultsLevel) throws Exception {\n+    public Results getConnectedEntities(\n+        String connectionType, String connectedEntityType, Level resultsLevel) throws Exception {\n+\n+        Results raw = null;\n \n         Query query = new Query();\n         query.setConnectionType(connectionType);\n         query.setEntityType(connectedEntityType);\n-        return searchConnectedEntities( query );\n+\n+        if ( connectionType == null ) {\n+            raw = searchConnectedEntities( query );\n+\n+        } else {\n+\n+            headEntity = em.validate( headEntity );\n+\n+            IndexScope indexScope = new IndexScopeImpl(\n+                applicationScope.getApplication(), \n+                cpHeadEntity.getId(), \n+                CpEntityManager.getConnectionScopeName( connectionType ));\n+            EntityIndex ei = managerCache.getEntityIndex(indexScope);\n+        \n+            logger.debug(\"Searching connections from all-types scope {}:{}:{}\", new String[] { \n+                indexScope.getApplication().toString(), \n+                indexScope.getOwner().toString(),\n+                indexScope.getName()}); \n+\n+            query = adjustQuery( query );\n+            CandidateResults crs = ei.search( query );\n+\n+            raw = buildResults( query , crs, query.getConnectionType() );\n+        }\n+\n+        List<ConnectionRef> crefs = new ArrayList<ConnectionRef>();\n+        for ( Entity e : raw.getEntities() ) {\n+            ConnectionRef cref = new ConnectionRefImpl( headEntity, connectionType, e );\n+            crefs.add( cref );\n+        }\n+\n+        return Results.fromConnections( crefs );\n     }\n \n+\n     @Override\n     public Results getConnectingEntities(String connectionType, String connectedEntityType, \n             Level resultsLevel) throws Exception {\n \n         return getConnectingEntities( connectionType, connectedEntityType, resultsLevel, -1 );\n     }\n \n+\n     @Override\n     public Results getConnectingEntities(String connectionType, String entityType, \n             Level level, int count) throws Exception {\n@@ -901,21 +936,6 @@ private Results buildResults(Query query, CandidateResults crs, String collName\n \n         } else {\n \n-            CollectionScope collScope = new CollectionScopeImpl( \n-                applicationScope.getApplication(), \n-                applicationScope.getApplication(), \n-                CpEntityManager.getCollectionScopeNameFromEntityType( query.getEntityType() ));\n-            EntityCollectionManager ecm = managerCache.getEntityCollectionManager(collScope);\n-\n-            if ( logger.isDebugEnabled() ) {\n-                logger.debug(\"Loading entities from scope\\n   app {}\\n   owner {}\\n   name {}\", \n-                new Object[] { \n-                    collScope.getApplication(), \n-                    collScope.getOwner(), \n-                    collScope.getName() \n-                });\n-            }\n-\n             // first, build map of latest versions of entities\n             Map<Id, org.apache.usergrid.persistence.model.entity.Entity> latestVersions = \n                 new LinkedHashMap<Id, org.apache.usergrid.persistence.model.entity.Entity>();\n@@ -925,18 +945,33 @@ private Results buildResults(Query query, CandidateResults crs, String collName\n \n                 CandidateResult cr = iter.next();\n \n+                CollectionScope collScope = new CollectionScopeImpl( \n+                    applicationScope.getApplication(), \n+                    applicationScope.getApplication(), \n+                    CpEntityManager.getCollectionScopeNameFromEntityType( cr.getId().getType() ));\n+                EntityCollectionManager ecm = managerCache.getEntityCollectionManager(collScope);\n+\n+                if ( logger.isDebugEnabled() ) {\n+                    logger.debug(\"Loading entity {} from scope\\n   app {}\\n   owner {}\\n   name {}\", \n+                    new Object[] { \n+                        cr.getId(),\n+                        collScope.getApplication(), \n+                        collScope.getOwner(), \n+                        collScope.getName() \n+                    });\n+                }\n+\n                 org.apache.usergrid.persistence.model.entity.Entity e =\n                     ecm.load( cr.getId() ).toBlockingObservable().last();\n \n                 if ( cr.getVersion().compareTo( e.getVersion()) < 0 )  {\n-                    logger.debug(\"Stale version uuid:{} type:{} v:{}\", \n+                    logger.debug(\"Stale version uuid:{} type:{} version:{}\", \n                         new Object[] {cr.getId().getUuid(), cr.getId().getType(), cr.getVersion()});\n                     continue;\n                 }\n \n                 org.apache.usergrid.persistence.model.entity.Entity alreadySeen = \n-                    latestVersions.get( e.getId() );\n-\n+                    latestVersions.get( e.getId() ); \n                 if ( alreadySeen == null ) { // never seen it, so add to map\n                     latestVersions.put( e.getId(), e);\n \n@@ -980,9 +1015,8 @@ public void batchUpdateSetIndexes( Mutator<ByteBuffer> batch, String setName, Ob\n \n         elementValue = getDefaultSchema().validateEntitySetValue( entity.getType(), setName, elementValue );\n \n-        IndexUpdate indexUpdate =\n-                batchStartIndexUpdate( batch, entity, setName, elementValue, timestampUuid, true, true, removeFromSet,\n-                        false );\n+        IndexUpdate indexUpdate = batchStartIndexUpdate( batch, entity, setName, elementValue, \n+                timestampUuid, true, true, removeFromSet, false );\n \n         // Update collections\n         Map<String, Set<CollectionInfo>> containers =\n@@ -1027,16 +1061,17 @@ public void batchUpdateSetIndexes( Mutator<ByteBuffer> batch, String setName, Ob\n      * @throws Exception the exception\n      */\n     @Metered(group = \"core\", name = \"RelationManager_batchUpdateCollectionIndex\")\n-    public IndexUpdate batchUpdateCollectionIndex( IndexUpdate indexUpdate, EntityRef owner, String collectionName )\n+    public IndexUpdate batchUpdateCollectionIndex( \n+            IndexUpdate indexUpdate, EntityRef owner, String collectionName )\n             throws Exception {\n \n         logger.debug( \"batchUpdateCollectionIndex\" );\n \n         Entity indexedEntity = indexUpdate.getEntity();\n \n-        String bucketId = indexBucketLocator\n-                .getBucket( applicationId, IndexBucketLocator.IndexType.COLLECTION, indexedEntity.getUuid(), indexedEntity.getType(),\n-                        indexUpdate.getEntryName() );\n+        String bucketId = indexBucketLocator .getBucket( applicationId, \n+                IndexBucketLocator.IndexType.COLLECTION, indexedEntity.getUuid(), \n+                indexedEntity.getType(), indexUpdate.getEntryName() );\n \n         // the root name without the bucket\n         // entity_id,collection_name,prop_name,\n@@ -1054,22 +1089,23 @@ public IndexUpdate batchUpdateCollectionIndex( IndexUpdate indexUpdate, EntityRe\n \n                 index_key = key( index_name, bucketId );\n \n-                addDeleteToMutator( indexUpdate.getBatch(), ENTITY_INDEX, index_key, entry.getIndexComposite(),\n-                        indexUpdate.getTimestamp() );\n+                addDeleteToMutator( indexUpdate.getBatch(), ENTITY_INDEX, index_key, \n+                        entry.getIndexComposite(), indexUpdate.getTimestamp() );\n \n                 if ( \"location.coordinates\".equals( entry.getPath() ) ) {\n-                    EntityLocationRef loc = new EntityLocationRef( indexUpdate.getEntity(), entry.getTimestampUuid(),\n-                            entry.getValue().toString() );\n-                    batchRemoveLocationFromCollectionIndex( indexUpdate.getBatch(), indexBucketLocator, applicationId,\n-                            index_name, loc );\n+                    EntityLocationRef loc = new EntityLocationRef( indexUpdate.getEntity(), \n+                            entry.getTimestampUuid(), entry.getValue().toString() );\n+                    batchRemoveLocationFromCollectionIndex( indexUpdate.getBatch(), \n+                            indexBucketLocator, applicationId, index_name, loc );\n                 }\n             }\n             else {\n                 logger.error( \"Unexpected condition - deserialized property value is null\" );\n             }\n         }\n \n-        if ( ( indexUpdate.getNewEntries().size() > 0 ) && ( !indexUpdate.isMultiValue() || ( indexUpdate.isMultiValue()\n+        if ( ( indexUpdate.getNewEntries().size() > 0 ) \n+                && ( !indexUpdate.isMultiValue() || ( indexUpdate.isMultiValue()\n                 && !indexUpdate.isRemoveListEntry() ) ) ) {\n \n             for ( IndexUpdate.IndexEntry indexEntry : indexUpdate.getNewEntries() ) {\n@@ -1082,14 +1118,15 @@ public IndexUpdate batchUpdateCollectionIndex( IndexUpdate indexUpdate, EntityRe\n \n                 // int i = 0;\n \n-                addInsertToMutator( indexUpdate.getBatch(), ENTITY_INDEX, index_key, indexEntry.getIndexComposite(),\n-                        null, indexUpdate.getTimestamp() );\n+                addInsertToMutator( indexUpdate.getBatch(), ENTITY_INDEX, index_key, \n+                        indexEntry.getIndexComposite(), null, indexUpdate.getTimestamp() );\n \n                 if ( \"location.coordinates\".equals( indexEntry.getPath() ) ) {\n-                    EntityLocationRef loc =\n-                            new EntityLocationRef( indexUpdate.getEntity(), indexEntry.getTimestampUuid(),\n-                                    indexEntry.getValue().toString() );\n-                    batchStoreLocationInCollectionIndex( indexUpdate.getBatch(), indexBucketLocator, applicationId,\n+                    EntityLocationRef loc = new EntityLocationRef( \n+                            indexUpdate.getEntity(), indexEntry.getTimestampUuid(),\n+                            indexEntry.getValue().toString() );\n+                    batchStoreLocationInCollectionIndex( indexUpdate.getBatch(), \n+                            indexBucketLocator, applicationId,\n                             index_name, indexedEntity.getUuid(), loc );\n                 }\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "sha": "0b5dc0d6671be3a42b6689519771b03eab1f1cf8",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpSetup.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpSetup.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/CpSetup.java",
                "patch": "@@ -34,8 +34,11 @@\n import static org.apache.usergrid.persistence.cassandra.CassandraService.DEFAULT_APPLICATION;\n import static org.apache.usergrid.persistence.cassandra.CassandraService.DEFAULT_ORGANIZATION;\n import static org.apache.usergrid.persistence.cassandra.CassandraService.MANAGEMENT_APPLICATION;\n+import static org.apache.usergrid.persistence.cassandra.CassandraService.PRINCIPAL_TOKEN_CF;\n+import static org.apache.usergrid.persistence.cassandra.CassandraService.PROPERTIES_CF;\n import static org.apache.usergrid.persistence.cassandra.CassandraService.STATIC_APPLICATION_KEYSPACE;\n import static org.apache.usergrid.persistence.cassandra.CassandraService.SYSTEM_KEYSPACE;\n+import static org.apache.usergrid.persistence.cassandra.CassandraService.TOKENS_CF;\n import static org.apache.usergrid.persistence.cassandra.CassandraService.USE_VIRTUAL_KEYSPACES;\n import static org.apache.usergrid.persistence.cassandra.CassandraService.keyspaceForApplication;\n import org.apache.usergrid.persistence.cassandra.Setup;\n@@ -139,7 +142,22 @@ public static Application getDefaultApp() {\n \n     @Override\n     public void setupSystemKeyspace() throws Exception {\n-        // no-op\n+\n+        logger.info( \"Initialize system keyspace\" );\n+\n+        cass.createColumnFamily( SYSTEM_KEYSPACE, createColumnFamilyDefinition( \n+                SYSTEM_KEYSPACE, APPLICATIONS_CF, ComparatorType.BYTESTYPE ) );\n+\n+        cass.createColumnFamily( SYSTEM_KEYSPACE, createColumnFamilyDefinition( \n+                SYSTEM_KEYSPACE, PROPERTIES_CF, ComparatorType.BYTESTYPE ) );\n+\n+        cass.createColumnFamily( SYSTEM_KEYSPACE, createColumnFamilyDefinition( \n+                SYSTEM_KEYSPACE, TOKENS_CF, ComparatorType.BYTESTYPE ) );\n+\n+        cass.createColumnFamily( SYSTEM_KEYSPACE, createColumnFamilyDefinition( \n+                SYSTEM_KEYSPACE, PRINCIPAL_TOKEN_CF, ComparatorType.UUIDTYPE ) );\n+\n+        logger.info( \"System keyspace initialized\" );\n     }\n \n     ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpSetup.java",
                "sha": "1b63ce78db132433a17b89c15e4214e127f56aaf",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/persistence/EntityManager.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/persistence/EntityManager.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 4,
                "filename": "stack/core/src/main/java/org/apache/usergrid/persistence/EntityManager.java",
                "patch": "@@ -604,10 +604,6 @@ public boolean isPropertyValueUniqueForEntity(\n     <A extends Entity> A batchCreate(Mutator<ByteBuffer> m, String entityType, \n             Class<A> entityClass, Map<String, Object> properties, \n             UUID importId, UUID timestampUuid) throws Exception;\n-\n-    void batchCreateRole(Mutator<ByteBuffer> batch, UUID groupId, String roleName, \n-            String roleTitle, long inactivity, RoleRef roleRef, UUID timestampUuid) throws Exception;\n-\n     /**\n      * Batch dictionary property.\n      *",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/main/java/org/apache/usergrid/persistence/EntityManager.java",
                "sha": "750efc011fd973f2025af957b3932cdf0c1cd9a1",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 0,
                "filename": "stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java",
                "patch": "@@ -73,6 +73,8 @@ public void testEntityConnectionsSimple() throws Exception {\n \n         em.createConnection( firstUserEntity, \"likes\", secondUserEntity );\n \n+        em.refreshIndex();\n+\n         Results r = em.getConnectedEntities( firstUserEntity, \"likes\", null, Level.IDS );\n \n         List<ConnectionRef> connections = r.getConnections();\n@@ -139,6 +141,8 @@ public void testEntityConnections() throws Exception {\n         LOG.info( \"\\n\\nConnecting \" + awardA.getUuid() + \" \\\"awarded\\\" \" + catB.getUuid() + \"\\n\" );\n         em.createConnection( awardA, \"awarded\", catB );\n \n+        em.refreshIndex();\n+\n         // List forward connections for cat A\n \n         // Thread.sleep(5000);\n@@ -158,6 +162,8 @@ public void testEntityConnections() throws Exception {\n         LOG.info( \"\\n\\nConnecting \" + awardA.getUuid() + \" \\\"awarded\\\" \" + catA.getUuid() + \"\\n\" );\n         em.createConnection( awardA, \"awarded\", catA );\n \n+        em.refreshIndex();\n+\n         // List forward connections for cat A\n \n         testEntityConnections( applicationId, catA.getUuid(), \"cat\", 1 );\n@@ -266,6 +272,7 @@ public void testEntityConnectionsMembership() throws Exception {\n \n         em.createConnection( secondUserEntity, \"likes\", arrogantbutcher );\n \n+        em.refreshIndex();\n \n         Results r = em.getConnectedEntities( firstUserEntity, \"likes\", \"restaurant\", Level.IDS );\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java",
                "sha": "f442cd5b19654fb10c30fc477dc04e17fbce1ecb",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/test/java/org/apache/usergrid/persistence/PermissionsIT.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/apache/usergrid/persistence/PermissionsIT.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 0,
                "filename": "stack/core/src/test/java/org/apache/usergrid/persistence/PermissionsIT.java",
                "patch": "@@ -147,8 +147,10 @@ public void testPermissions() throws Exception {\n         assertEquals( \"proper number of group roles not set\", 1, roles.size() );\n         dump( \"group roles\", roles );\n \n+        em.refreshIndex();\n         em.addUserToGroupRole( user.getUuid(), group.getUuid(), \"admin\" );\n \n+        em.refreshIndex();\n         Results r = em.getUsersInGroupRole( group.getUuid(), \"admin\", Level.ALL_PROPERTIES );\n         assertEquals( \"proper number of users in group role not set\", 1, r.size() );\n         dump( \"entities\", r.getEntities() );",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/test/java/org/apache/usergrid/persistence/PermissionsIT.java",
                "sha": "87aca6453170256128fa1b95f38aafbffda28bcc",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/test/resources/log4j.properties",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/resources/log4j.properties?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 3,
                "filename": "stack/core/src/test/resources/log4j.properties",
                "patch": "@@ -38,13 +38,13 @@ log4j.appender.stdout.layout.ConversionPattern=%d %p (%t) %c{1} - %m%n\n #log4j.logger.org.apache.usergrid.locking.singlenode.SingleNodeLockManagerImpl=DEBUG, stdout\n \n log4j.logger.org.apache.usergrid.persistence=INFO\n-#log4j.logger.org.apache.usergrid.corepersistence=DEBUG\n+log4j.logger.org.apache.usergrid.corepersistence=DEBUG\n #log4j.logger.com.netflix.hystrix=DEBUG\n #log4j.logger.org.antlr=DEBUG\n \n #log4j.logger.org.apache.usergrid.persistence.CollectionIT=DEBUG\n-#log4j.logger.org.apache.usergrid.persistence.index=DEBUG\n-#log4j.logger.org.apache.usergrid.persistence.query=DEBUG\n+log4j.logger.org.apache.usergrid.persistence.index=DEBUG\n+log4j.logger.org.apache.usergrid.persistence.query=DEBUG\n #log4j.logger.org.apache.usergrid.persistence.collection=DEBUG\n #log4j.logger.org.elasticsearch=DEBUG\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/core/src/test/resources/log4j.properties",
                "sha": "b42a590558909d42272445ca484b8fbfbfda6464",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/astyanax/ColumnTypes.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/astyanax/ColumnTypes.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 8,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/astyanax/ColumnTypes.java",
                "patch": "@@ -1,7 +1,6 @@\n package org.apache.usergrid.persistence.core.astyanax;\n \n \n-import org.apache.cassandra.db.marshal.BooleanType;\n import org.apache.cassandra.db.marshal.DynamicCompositeType;\n \n \n@@ -11,22 +10,27 @@\n  */\n public class ColumnTypes {\n \n+\n     /**\n-     * UUID from max by the row key to min at the end of the row\n+     * Long time with max by the row key and min at the end of the row\n      */\n+    public static final String LONG_TYPE_REVERSED = \"LongType(reversed=true)\";\n+\n+\n     public static final String UUID_TYPE_REVERSED = \"UUIDType(reversed=true)\";\n+\n+\n+\n     /**\n      * Constant for the dynamic composite comparator type we'll need\n      */\n     public static final String DYNAMIC_COMPOSITE_TYPE = DynamicCompositeType.class.getSimpleName() + \"(a=>AsciiType,b=>BytesType,i=>IntegerType,x=>LexicalUUIDType,l=>LongType,\" +\n                         \"t=>TimeUUIDType,s=>UTF8Type,u=>UUIDType,A=>AsciiType(reversed=true),B=>BytesType(reversed=true),\" +\n-                        \"I=>IntegerType(reversed=true),X=>LexicalUUIDType(reversed=true),L=>LongType(reversed=true),\" +\n-                        \"T=>TimeUUIDType(reversed=true),S=>UTF8Type(reversed=true),U=>\"+UUID_TYPE_REVERSED+ \")\";\n+                        \"I=>IntegerType(reversed=true),X=>LexicalUUIDType(reversed=true),L=>\"+LONG_TYPE_REVERSED+\",\" +\n+                        \"T=>TimeUUIDType(reversed=true),S=>UTF8Type(reversed=true),U=>\"+UUID_TYPE_REVERSED+\")\";\n+\n+\n \n-    /**\n-     * Long time with max by the row key and min at the end of the row\n-     */\n-    public static final String LONG_TYPE_REVERSED = \"LongType(reversed=true)\";\n \n \n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/astyanax/ColumnTypes.java",
                "sha": "b5e41ff02ad0974476d10fccbfb756f7c8276fff",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessor.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessor.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 0,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessor.java",
                "patch": "@@ -27,6 +27,15 @@\n  */\n public interface AsyncProcessor<T> {\n \n+    /**\n+     * Start the consumption of the timeout events\n+     */\n+    public void start();\n+\n+    /**\n+     * Stop consumption\n+     */\n+    public void stop();\n \n     /**\n      * The processor implementation is responsible for guaranteeing the events fire in the runtime environment. This",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessor.java",
                "sha": "48a41cf7046dc8be1d27a95db2a8aa079e7c50a8",
                "status": "modified"
            },
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorFactoryImpl.java",
                "changes": 49,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorFactoryImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 21,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorFactoryImpl.java",
                "patch": "@@ -20,14 +20,12 @@\n \n \n import java.io.Serializable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n import com.google.inject.Inject;\n import com.google.inject.Singleton;\n \n@@ -43,19 +41,8 @@\n     private final TimeoutQueueFactory queueFactory;\n     private final ConsistencyFig consistencyFig;\n \n-    private final LoadingCache<Class<? extends Serializable>, AsyncProcessor<? extends Serializable>> loadedProcessors = CacheBuilder.newBuilder()\n-           .maximumSize( 1000 )\n-           .build( new CacheLoader<Class<? extends Serializable>, AsyncProcessor<? extends Serializable>>() {\n-\n-               @Override\n-               public AsyncProcessor<? extends Serializable> load( final Class<? extends Serializable> key ) throws Exception {\n-                   LOG.info( \"Creating queue from factory for event key {}\", key );\n-\n-                   final TimeoutQueue queue = queueFactory.getQueue( key );\n-\n-                   return  new AsyncProcessorImpl( queue, consistencyFig );\n-               }\n-           } );\n+    private final Map<Class<? extends Serializable>, AsyncProcessor<? extends Serializable>> instances =\n+            new HashMap( 100 );\n \n \n     @Inject\n@@ -67,11 +54,31 @@ public AsyncProcessorFactoryImpl( final TimeoutQueueFactory queueFactory, final\n \n     @Override\n     public <T extends Serializable> AsyncProcessor<T> getProcessor( final Class<T> eventClass ) {\n-        try {\n-            return ( AsyncProcessor<T> ) loadedProcessors.get( eventClass );\n+\n+        AsyncProcessor<T> processor = ( AsyncProcessor<T> ) instances.get( eventClass );\n+\n+\n+        if ( processor != null ) {\n+            return processor;\n         }\n-        catch ( ExecutionException e ) {\n-            throw new RuntimeException( \"Unable to load from cache\", e );\n+\n+\n+        synchronized ( this ) {\n+            processor = ( AsyncProcessor<T> ) instances.get( eventClass );\n+\n+\n+            if ( processor != null ) {\n+                return processor;\n+            }\n+\n+            TimeoutQueue queue = queueFactory.getQueue( eventClass );\n+            AsyncProcessorImpl newProcessor = new AsyncProcessorImpl( queue, consistencyFig );\n+\n+            instances.put( eventClass, newProcessor );\n+\n+            newProcessor.start();\n+\n+            return newProcessor;\n         }\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorFactoryImpl.java",
                "sha": "ad798049406c8dcf51786649f13dc5535d5b8c38",
                "status": "modified"
            },
            {
                "additions": 40,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorImpl.java",
                "changes": 48,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 8,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorImpl.java",
                "patch": "@@ -34,6 +34,7 @@\n import com.google.inject.Singleton;\n \n import rx.Observable;\n+import rx.Scheduler;\n import rx.Subscriber;\n import rx.functions.FuncN;\n import rx.schedulers.Schedulers;\n@@ -53,23 +54,49 @@\n     private static final Logger LOG = LoggerFactory.getLogger( AsyncProcessor.class );\n \n     protected final TimeoutQueue<T> queue;\n-//    protected final ConsistencyFig consistencyFig;\n+    protected final ConsistencyFig consistencyFig;\n     protected final List<MessageListener<T, ?>> listeners = new ArrayList<>();\n \n \n     protected List<ErrorListener<T>> errorListeners = new ArrayList<ErrorListener<T>>();\n     protected List<CompleteListener<T>> completeListeners = new ArrayList<CompleteListener<T>>();\n \n+    private Scheduler.Worker worker;\n+\n \n     @Inject\n     public AsyncProcessorImpl( final TimeoutQueue<T> queue, final ConsistencyFig consistencyFig ) {\n         this.queue = queue;\n-//        this.consistencyFig = consistencyFig;\n+        this.consistencyFig = consistencyFig;\n+    }\n+\n+\n+    @Override\n+    public void start() {\n+        synchronized ( this ) {\n+            if ( worker != null ) {\n+                return;\n+            }\n \n-        //we purposefully use a new thread.  We don't want to use one of the I/O threads to run this task\n-        //in the event the scheduler is full, we'll end up rejecting the reschedule of this task\n-        Schedulers.newThread().createWorker().schedulePeriodically( new TimeoutTask<T>( this, consistencyFig ), consistencyFig.getTaskLoopTime(),\n-                consistencyFig.getTaskLoopTime(), TimeUnit.MILLISECONDS );\n+\n+            worker = Schedulers.newThread().createWorker();\n+\n+\n+            worker.schedulePeriodically( new TimeoutTask<T>( this, consistencyFig ), consistencyFig.getTaskLoopTime(),\n+                    consistencyFig.getTaskLoopTime(), TimeUnit.MILLISECONDS );\n+        }\n+    }\n+\n+\n+    @Override\n+    public void stop() {\n+        synchronized ( this ) {\n+            if ( worker == null ) {\n+                return;\n+            }\n+\n+            worker.unsubscribe();\n+        }\n     }\n \n \n@@ -81,12 +108,19 @@ public AsyncProcessorImpl( final TimeoutQueue<T> queue, final ConsistencyFig con\n \n     @Override\n     public void start( final AsynchronousMessage<T> event ) {\n+\n+//        This is helpful for detecting wiring issues.  Uncomment this to find the issue at queue time\n+        if ( listeners.size() == 0 ) {\n+            LOG.warn( \"Nothing is listening for event of class {}.  You're talking to /dev/null!\", event.getEvent().getClass() );\n+        }\n+\n         final T data = event.getEvent();\n         /**\n          * Execute all listeners in parallel\n          */\n         List<Observable<?>> observables = new ArrayList<Observable<?>>( listeners.size() );\n \n+\n         for ( MessageListener<T, ?> listener : listeners ) {\n             observables.add( HystrixObservable.async( listener.receive( data ) ).subscribeOn( Schedulers.io() ) );\n         }\n@@ -136,8 +170,6 @@ public void onNext( final AsynchronousMessage<T> tAsynchronousMessage ) {\n     }\n \n \n-\n-\n     @Override\n     public <R> void addListener( final MessageListener<T, R> listener ) {\n         this.listeners.add( listener );",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/consistency/AsyncProcessorImpl.java",
                "sha": "ad0f40b3ebd1c30f37a37711c6394967d69319c4",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java",
                "patch": "@@ -69,7 +69,7 @@ protected void configure() {\n \n         bind( CassandraConfig.class ).to( CassandraConfigImpl.class );\n \n-        bind(AsyncProcessorFactory.class).to( AsyncProcessorFactoryImpl.class );\n+        bind(AsyncProcessorFactory.class).to( AsyncProcessorFactoryImpl.class ).asEagerSingleton();\n \n         bindTimeoutQueueFactory();\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/guice/CommonModule.java",
                "sha": "6d663fa12001ab795afc521111c1270d0be1bd20",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/hystrix/HystrixObservable.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/hystrix/HystrixObservable.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 3,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/hystrix/HystrixObservable.java",
                "patch": "@@ -20,11 +20,8 @@\n package org.apache.usergrid.persistence.core.hystrix;\n \n \n-import com.netflix.config.ConfigurationManager;\n import com.netflix.hystrix.HystrixCommandGroupKey;\n-import com.netflix.hystrix.HystrixCommandProperties;\n import com.netflix.hystrix.HystrixObservableCommand;\n-import com.netflix.hystrix.HystrixThreadPoolProperties.Setter;\n \n import rx.Observable;\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/hystrix/HystrixObservable.java",
                "sha": "c38c4b84f8db1c7016d34f7a697b047f90ddd743",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/scope/ApplicationScopeImpl.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/scope/ApplicationScopeImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 7,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/scope/ApplicationScopeImpl.java",
                "patch": "@@ -29,16 +29,16 @@\n  */\n public class ApplicationScopeImpl implements ApplicationScope {\n \n-    protected final Id organization;\n+    protected final Id application;\n \n \n-    public ApplicationScopeImpl( final Id organization ) {\n-        this.organization = organization;}\n+    public ApplicationScopeImpl( final Id application ) {\n+        this.application = application;}\n \n \n     @Override\n     public Id getApplication() {\n-        return this.organization;\n+        return this.application;\n     }\n \n \n@@ -53,7 +53,7 @@ public boolean equals( final Object o ) {\n \n         final ApplicationScopeImpl that = ( ApplicationScopeImpl ) o;\n \n-        if ( !organization.equals( that.organization ) ) {\n+        if ( !application.equals( that.application ) ) {\n             return false;\n         }\n \n@@ -63,14 +63,14 @@ public boolean equals( final Object o ) {\n \n     @Override\n     public int hashCode() {\n-        return organization.hashCode();\n+        return application.hashCode();\n     }\n \n \n     @Override\n     public String toString() {\n         return \"ApplicationScopeImpl{\" +\n-                \"organization=\" + organization +\n+                \"application=\" + application +\n                 '}';\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/scope/ApplicationScopeImpl.java",
                "sha": "692ba49291251e22425e326dae4bc014fc662957",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/Edge.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/Edge.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/Edge.java",
                "patch": "@@ -53,5 +53,5 @@\n     /**\n      * Get the version (as a type 1 time uuid) of this edge\n      */\n-    UUID getVersion();\n+    long getTimestamp();\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/Edge.java",
                "sha": "21f804a62f05dd143479834514d01d0a10c73acc",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/GraphManager.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/GraphManager.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 2,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/GraphManager.java",
                "patch": "@@ -74,10 +74,12 @@\n      *\n      * Remove the node from the graph.\n      *\n-     * @param node\n+     * @param node The node to remove\n+     * @param timestamp The timestamp to apply the delete operation.  Any edges connected to this node with a timestmap\n+     * <= the specified time will be removed from the graph\n      * @return\n      */\n-    Observable<Id> deleteNode(Id node);\n+    Observable<Id> deleteNode(Id node, long timestamp);\n \n     /**\n      * Get all versions of this edge where versions <= max version",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/GraphManager.java",
                "sha": "aa1a4a8712b3dc5c6f531b899ef65507bc2b8bb1",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdge.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdge.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 4,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdge.java",
                "patch": "@@ -54,11 +54,11 @@\n     String getType();\n \n     /**\n-     * Get the Maximum Version of an edge we can return.\n-     * This should always be a type 1 time uuid.\n-     * @return\n+     * Get the Maximum timestamp of an edge we can return.\n+\n+     * @return The max timestamp as a long\n      */\n-    UUID getMaxVersion();\n+    long getMaxTimestamp();\n \n     /**\n      * The optional start parameter.  All edges emitted with be > the specified start edge.",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdge.java",
                "sha": "8deeb69e30f6b5e84ff6f1aa666c39c2667e638f",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdgeType.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdgeType.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdgeType.java",
                "patch": "@@ -52,7 +52,7 @@\n      * This should always be a type 1 time uuid.\n      * @return\n      */\n-    UUID getMaxVersion();\n+    long getMaxTimestamp();\n \n     /**\n      * The optional start parameter.  All edges emitted with be > the specified start edge.",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/SearchByEdgeType.java",
                "sha": "97c01c04403d16371eb05a3014d481af21455e1e",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListener.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListener.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 3,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListener.java",
                "patch": "@@ -63,7 +63,7 @@ public EdgeDeleteListener( final AsyncProcessorFactory asyncProcessorFactory,\n \n         final MarkedEdge edge = delete.getData();\n         final ApplicationScope scope = delete.getApplicationScope();\n-        final UUID maxVersion = edge.getVersion();\n+        final long maxTimestamp = edge.getTimestamp();\n \n \n         return edgeDeleteRepair.repair( scope, edge, delete.getTimestamp() )\n@@ -73,11 +73,11 @@ public EdgeDeleteListener( final AsyncProcessorFactory asyncProcessorFactory,\n \n                                        Observable<Integer> sourceDelete = edgeMetaRepair\n                                                .repairSources( scope, edge.getSourceNode(), edge.getType(),\n-                                                       maxVersion );\n+                                                       maxTimestamp );\n \n                                        Observable<Integer> targetDelete = edgeMetaRepair\n                                                .repairTargets( scope, edge.getTargetNode(), edge.getType(),\n-                                                       maxVersion );\n+                                                       maxTimestamp );\n \n                                        return Observable.zip( sourceDelete, targetDelete,\n                                                new Func2<Integer, Integer, Integer>() {",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListener.java",
                "sha": "278abb4dfbde11adf406c6f10b9a6f2843ffc161",
                "status": "modified"
            },
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java",
                "changes": 54,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 26,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java",
                "patch": "@@ -32,6 +32,7 @@\n import org.apache.usergrid.persistence.core.consistency.AsyncProcessorFactory;\n import org.apache.usergrid.persistence.core.consistency.AsynchronousMessage;\n import org.apache.usergrid.persistence.core.consistency.ConsistencyFig;\n+import org.apache.usergrid.persistence.core.consistency.TimeService;\n import org.apache.usergrid.persistence.core.hystrix.HystrixObservable;\n import org.apache.usergrid.persistence.core.rx.ObservableIterator;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n@@ -90,15 +91,15 @@\n     private final GraphFig graphFig;\n     private final ConsistencyFig consistencyFig;\n \n-\n     @Inject\n     public GraphManagerImpl( final EdgeMetadataSerialization edgeMetadataSerialization,\n                              @CommitLogEdgeSerialization final EdgeSerialization commitLogSerialization,\n                              final NodeSerialization nodeSerialization, final GraphFig graphFig,\n-                             final AsyncProcessorFactory asyncProcessorFactory,\n-                             final MergedEdgeReader mergedEdgeReader,\n+                             final AsyncProcessorFactory asyncProcessorFactory, final MergedEdgeReader mergedEdgeReader,\n                              final ConsistencyFig consistencyFig,\n-                             @Assisted final ApplicationScope scope) {\n+                             @Assisted final ApplicationScope scope\n+                             ) {\n+\n \n \n         ValidationUtils.validateApplicationScope( scope );\n@@ -119,6 +120,7 @@ public GraphManagerImpl( final EdgeMetadataSerialization edgeMetadataSerializati\n         this.graphFig = graphFig;\n         this.consistencyFig = consistencyFig;\n \n+\n         this.edgeDeleteAsyncProcessor = asyncProcessorFactory.getProcessor( EdgeDeleteEvent.class );\n \n         this.nodeDeleteAsyncProcessor = asyncProcessorFactory.getProcessor( NodeDeleteEvent.class );\n@@ -208,19 +210,19 @@ public Edge call( final MarkedEdge edge ) {\n \n \n     @Override\n-    public Observable<Id> deleteNode( final Id node ) {\n+    public Observable<Id> deleteNode( final Id node, final long timestamp ) {\n         return HystrixObservable\n                 .user( Observable.from( node ).subscribeOn( Schedulers.io() ).map( new Func1<Id, Id>() {\n                     @Override\n                     public Id call( final Id id ) {\n \n                         //mark the node as deleted\n-                        final UUID deleteTime = UUIDGenerator.newTimeUUID();\n \n-                        final MutationBatch nodeMutation = nodeSerialization.mark( scope, id, deleteTime );\n+\n+                        final MutationBatch nodeMutation = nodeSerialization.mark( scope, id, timestamp );\n \n                         final AsynchronousMessage<NodeDeleteEvent> event = nodeDeleteAsyncProcessor\n-                                .setVerification( new NodeDeleteEvent( scope, deleteTime, node ), getTimeout() );\n+                                .setVerification( new NodeDeleteEvent( scope, UUIDGenerator.newTimeUUID(), timestamp, node ), getTimeout() );\n \n \n                         try {\n@@ -243,7 +245,7 @@ public Id call( final Id id ) {\n     public Observable<Edge> loadEdgeVersions( final SearchByEdge searchByEdge ) {\n         return HystrixObservable\n                 .user( mergedEdgeReader.getEdgeVersions( scope, searchByEdge ).buffer( graphFig.getScanPageSize() )\n-                                       .flatMap( new EdgeBufferFilter( searchByEdge.getMaxVersion() ) )\n+                                       .flatMap( new EdgeBufferFilter( searchByEdge.getMaxTimestamp() ) )\n                                        .cast( Edge.class ) );\n     }\n \n@@ -252,23 +254,23 @@ public Id call( final Id id ) {\n     public Observable<Edge> loadEdgesFromSource( final SearchByEdgeType search ) {\n         return HystrixObservable\n                 .user( mergedEdgeReader.getEdgesFromSource( scope, search ).buffer( graphFig.getScanPageSize() )\n-                                       .flatMap( new EdgeBufferFilter( search.getMaxVersion() ) ).cast( Edge.class ) );\n+                                       .flatMap( new EdgeBufferFilter( search.getMaxTimestamp() ) ).cast( Edge.class ) );\n     }\n \n \n     @Override\n     public Observable<Edge> loadEdgesToTarget( final SearchByEdgeType search ) {\n         return HystrixObservable\n                 .user( mergedEdgeReader.getEdgesToTarget( scope, search ).buffer( graphFig.getScanPageSize() )\n-                                       .flatMap( new EdgeBufferFilter( search.getMaxVersion() ) ).cast( Edge.class ) );\n+                                       .flatMap( new EdgeBufferFilter( search.getMaxTimestamp() ) ).cast( Edge.class ) );\n     }\n \n \n     @Override\n     public Observable<Edge> loadEdgesFromSourceByType( final SearchByIdType search ) {\n         return HystrixObservable.user( mergedEdgeReader.getEdgesFromSourceByTargetType( scope, search )\n                                                        .buffer( graphFig.getScanPageSize() )\n-                                                       .flatMap( new EdgeBufferFilter( search.getMaxVersion() ) )\n+                                                       .flatMap( new EdgeBufferFilter( search.getMaxTimestamp() ) )\n \n                                                        .cast( Edge.class ) );\n     }\n@@ -278,7 +280,7 @@ public Id call( final Id id ) {\n     public Observable<Edge> loadEdgesToTargetByType( final SearchByIdType search ) {\n         return HystrixObservable.user( mergedEdgeReader.getEdgesToTargetBySourceType( scope, search )\n                                                        .buffer( graphFig.getScanPageSize() )\n-                                                       .flatMap( new EdgeBufferFilter( search.getMaxVersion() ) )\n+                                                       .flatMap( new EdgeBufferFilter( search.getMaxTimestamp() ) )\n                                                        .cast( Edge.class ) );\n     }\n \n@@ -345,10 +347,10 @@ private long getTimeout() {\n      */\n     private class EdgeBufferFilter implements Func1<List<MarkedEdge>, Observable<MarkedEdge>> {\n \n-        private final UUID maxVersion;\n+        private final long maxVersion;\n \n \n-        private EdgeBufferFilter( final UUID maxVersion ) {\n+        private EdgeBufferFilter( final long maxVersion ) {\n             this.maxVersion = maxVersion;\n         }\n \n@@ -363,7 +365,7 @@ private EdgeBufferFilter( final UUID maxVersion ) {\n         @Override\n         public Observable<MarkedEdge> call( final List<MarkedEdge> markedEdges ) {\n \n-            final Map<Id, UUID> markedVersions = nodeSerialization.getMaxVersions( scope, markedEdges );\n+            final Map<Id, Long> markedVersions = nodeSerialization.getMaxVersions( scope, markedEdges );\n             return Observable.from( markedEdges ).filter( new EdgeFilter( this.maxVersion, markedVersions ) );\n         }\n     }\n@@ -374,13 +376,13 @@ private EdgeBufferFilter( final UUID maxVersion ) {\n      */\n     private static class EdgeFilter implements Func1<MarkedEdge, Boolean> {\n \n-        private final UUID maxVersion;\n+        private final long maxTimestamp;\n \n-        private final Map<Id, UUID> markCache;\n+        private final Map<Id, Long> markCache;\n \n \n-        private EdgeFilter( final UUID maxVersion, Map<Id, UUID> markCache ) {\n-            this.maxVersion = maxVersion;\n+        private EdgeFilter( final long maxTimestamp, Map<Id, Long> markCache ) {\n+            this.maxTimestamp = maxTimestamp;\n             this.markCache = markCache;\n         }\n \n@@ -389,27 +391,27 @@ private EdgeFilter( final UUID maxVersion, Map<Id, UUID> markCache ) {\n         public Boolean call( final MarkedEdge edge ) {\n \n \n-            final UUID edgeVersion = edge.getVersion();\n+            final long edgeTimestamp = edge.getTimestamp();\n \n             //our edge needs to not be deleted and have a version that's > max Version\n-            if ( edge.isDeleted() || UUIDComparator.staticCompare( edgeVersion, maxVersion ) > 0 ) {\n+            if ( edge.isDeleted() || Long.compare( edgeTimestamp, maxTimestamp )> 0 ) {\n                 return false;\n             }\n \n \n-            final UUID sourceVersion = markCache.get( edge.getSourceNode() );\n+            final Long sourceTimestamp = markCache.get( edge.getSourceNode() );\n \n             //the source Id has been marked for deletion.  It's version is <= to the marked version for deletion,\n             // so we need to discard it\n-            if ( sourceVersion != null && UUIDComparator.staticCompare( edgeVersion, sourceVersion ) < 1 ) {\n+            if ( sourceTimestamp != null && Long.compare( edgeTimestamp, sourceTimestamp ) < 1 ) {\n                 return false;\n             }\n \n-            final UUID targetVersion = markCache.get( edge.getTargetNode() );\n+            final Long targetTimestamp = markCache.get( edge.getTargetNode() );\n \n             //the target Id has been marked for deletion.  It's version is <= to the marked version for deletion,\n             // so we need to discard it\n-            if ( targetVersion != null && UUIDComparator.staticCompare( edgeVersion, targetVersion ) < 1 ) {\n+            if ( targetTimestamp != null &&  Long.compare( edgeTimestamp, targetTimestamp ) < 1 ) {\n                 return false;\n             }\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/GraphManagerImpl.java",
                "sha": "9708fd3fd33bdbb9b39ba9f1283c416cd8dc39f6",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteEvent.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteEvent.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 2,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteEvent.java",
                "patch": "@@ -30,7 +30,11 @@\n  * Event for when a node is deleted\n  */\n public class NodeDeleteEvent extends EdgeEvent<Id> {\n-    public NodeDeleteEvent( final ApplicationScope applicationScope, final UUID version, final Id id ) {\n-        super( applicationScope, version, id );\n+\n+    private final long timestamp;\n+\n+    public NodeDeleteEvent( final ApplicationScope applicationScope, final UUID eventTime, final long timestamp, final Id id ) {\n+        super( applicationScope, eventTime, id );\n+        this.timestamp = timestamp;\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteEvent.java",
                "sha": "236950267e2d9e922a9516a4f583ed662167dde2",
                "status": "modified"
            },
            {
                "additions": 25,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListener.java",
                "changes": 50,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListener.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 25,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListener.java",
                "patch": "@@ -104,16 +104,16 @@ public NodeDeleteListener( final NodeSerialization nodeSerialization,\n     /**\n      * Removes this node from the graph.\n      *\n-     * @param edgeEvent The edge event that was fired.\n+     * @param nodeDeleteEvent The edge event that was fired.\n      *\n      * @return An observable that emits the total number of edges that have been removed with this node both as the\n      *         target and source\n      */\n     @Override\n-    public Observable<Integer> receive( final NodeDeleteEvent edgeEvent ) {\n+    public Observable<Integer> receive( final NodeDeleteEvent nodeDeleteEvent ) {\n \n-        final Id node = edgeEvent.getData();\n-        final ApplicationScope scope = edgeEvent.getApplicationScope();\n+        final Id node = nodeDeleteEvent.getData();\n+        final ApplicationScope scope = nodeDeleteEvent.getApplicationScope();\n \n \n         return Observable.from( node )\n@@ -123,7 +123,7 @@ public NodeDeleteListener( final NodeSerialization nodeSerialization,\n                     @Override\n                     public Observable<Integer> call( final Id node ) {\n \n-                        final Optional<UUID> maxVersion = nodeSerialization.getMaxVersion( scope, node );\n+                        final Optional<Long> maxVersion = nodeSerialization.getMaxVersion( scope, node );\n \n                         LOG.debug( \"Node with id {} has max version of {}\", node, maxVersion.orNull() );\n \n@@ -132,26 +132,26 @@ public NodeDeleteListener( final NodeSerialization nodeSerialization,\n                             return Observable.empty();\n                         }\n \n-                        maxVersion.get();\n+\n \n                         //do all the delete, then when done, delete the node\n-                        return doDeletes( node, scope, maxVersion.get() ).count()\n+                        return doDeletes( node, scope, maxVersion.get(), nodeDeleteEvent.getTimestamp() ).count()\n                                 //if nothing is ever emitted, emit 0 so that we know no operations took place.\n                                 // Finally remove\n                                 // the\n                                 // target node in the mark\n                                .doOnCompleted( new Action0() {\n-                                    @Override\n-                                    public void call() {\n-                                        try {\n-                                            nodeSerialization.delete( scope, node, maxVersion.get() ).execute();\n-                                        }\n-                                        catch ( ConnectionException e ) {\n-                                            throw new RuntimeException( \"Unable to delete marked graph node \" + node,\n-                                                    e );\n-                                        }\n-                                    }\n-                                } );\n+                                   @Override\n+                                   public void call() {\n+                                       try {\n+                                           nodeSerialization.delete( scope, node, maxVersion.get() ).execute();\n+                                       }\n+                                       catch ( ConnectionException e ) {\n+                                           throw new RuntimeException( \"Unable to delete marked graph node \" + node,\n+                                                   e );\n+                                       }\n+                                   }\n+                               } );\n                     }\n                 } ).defaultIfEmpty( 0 );\n     }\n@@ -160,7 +160,7 @@ public void call() {\n     /**\n      * Do the deletes\n      */\n-    private Observable<MarkedEdge> doDeletes( final Id node, final ApplicationScope scope, final UUID version ) {\n+    private Observable<MarkedEdge> doDeletes( final Id node, final ApplicationScope scope, final long maxVersion, final UUID eventTimestamp ) {\n         /**\n          * Note that while we're processing, returned edges could be moved from the commit log to storage.  As a result,\n          * we need to issue a delete with the same version as the node delete on both commit log and storage for\n@@ -176,7 +176,7 @@ public void call() {\n                             @Override\n                             public Observable<MarkedEdge> call( final String edgeType ) {\n                                 return mergedEdgeReader.getEdgesToTarget( scope,\n-                                        new SimpleSearchByEdgeType( node, edgeType, version, null ) );\n+                                        new SimpleSearchByEdgeType( node, edgeType, maxVersion, null ) );\n                             }\n                         } );\n \n@@ -188,7 +188,7 @@ public void call() {\n                             @Override\n                             public Observable<MarkedEdge> call( final String edgeType ) {\n                                 return mergedEdgeReader.getEdgesFromSource( scope,\n-                                        new SimpleSearchByEdgeType( node, edgeType, version, null ) );\n+                                        new SimpleSearchByEdgeType( node, edgeType, maxVersion, null ) );\n                             }\n                         } );\n \n@@ -213,8 +213,8 @@ public void call() {\n \n                             //we use the version specified on the delete purposefully.  If these edges are re-written\n                             //at a greater time we want them to exit\n-                            batch.mergeShallow( commitLogSerialization.deleteEdge( scope, edge, version ) );\n-                            batch.mergeShallow( storageSerialization.deleteEdge( scope, edge, version ) );\n+                            batch.mergeShallow( commitLogSerialization.deleteEdge( scope, edge, eventTimestamp ) );\n+                            batch.mergeShallow( storageSerialization.deleteEdge( scope, edge, eventTimestamp ) );\n \n                             sourceNodes.add( new TargetPair( edge.getSourceNode(), edge.getType() ) );\n                             targetNodes.add( new TargetPair( edge.getTargetNode(), edge.getType() ) );\n@@ -243,7 +243,7 @@ public void call() {\n                                     @Override\n                                     public Observable<Integer> call( final TargetPair targetPair ) {\n                                         return edgeMetaRepair\n-                                                .repairSources( scope, targetPair.id, targetPair.edgeType, version );\n+                                                .repairSources( scope, targetPair.id, targetPair.edgeType, maxVersion );\n                                     }\n                                 } ).last();\n \n@@ -255,7 +255,7 @@ public void call() {\n                                     @Override\n                                     public Observable<Integer> call( final TargetPair targetPair ) {\n                                         return edgeMetaRepair\n-                                                .repairTargets( scope, targetPair.id, targetPair.edgeType, version );\n+                                                .repairTargets( scope, targetPair.id, targetPair.edgeType, maxVersion );\n                                     }\n                                 } ).last();\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListener.java",
                "sha": "7c67f0466e13067827959a7c7f81383ea0c9c404",
                "status": "modified"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleEdge.java",
                "changes": 43,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleEdge.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 27,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleEdge.java",
                "patch": "@@ -20,11 +20,11 @@\n package org.apache.usergrid.persistence.graph.impl;\n \n \n-import java.io.Serializable;\n import java.util.UUID;\n \n import org.apache.usergrid.persistence.core.util.ValidationUtils;\n import org.apache.usergrid.persistence.graph.Edge;\n+import org.apache.usergrid.persistence.graph.serialization.util.EdgeUtils;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n \n@@ -37,19 +37,16 @@\n     protected final Id sourceNode;\n     protected final String type;\n     protected final Id targetNode;\n-    protected final UUID version;\n+    protected final long timestamp;\n \n \n-    public SimpleEdge( final Id sourceNode, final String type, final Id targetNode, final UUID version ) {\n-\n-        ValidationUtils.verifyIdentity( sourceNode );\n-        ValidationUtils.verifyString( type, \"type\" );\n-        ValidationUtils.verifyIdentity( targetNode );\n-        ValidationUtils.verifyTimeUuid( version, \"version\" );\n+    public SimpleEdge( final Id sourceNode, final String type, final Id targetNode, final long timestamp ) {\n         this.sourceNode = sourceNode;\n         this.type = type;\n         this.targetNode = targetNode;\n-        this.version = version;\n+        this.timestamp = timestamp;\n+\n+        EdgeUtils.validateEdge( this );\n     }\n \n \n@@ -71,18 +68,11 @@ public Id getTargetNode() {\n     }\n \n \n-    public UUID getVersion() {\n-        return version;\n+    public long getTimestamp() {\n+        return timestamp;\n     }\n \n \n-\n-    /**\n-     * Test if the 2 edges are equal to one another.  Note that this is an edge comparison, not a marked edge comparison\n-     * @param o\n-     * @return\n-     */\n-\n     @Override\n     public boolean equals( final Object o ) {\n         if ( this == o ) {\n@@ -92,19 +82,18 @@ public boolean equals( final Object o ) {\n             return false;\n         }\n \n-        final Edge that = ( Edge ) o;\n-\n+        final SimpleEdge that = ( SimpleEdge ) o;\n \n-        if ( !sourceNode.equals( that.getSourceNode() ) ) {\n+        if ( timestamp != that.timestamp ) {\n             return false;\n         }\n-        if ( !targetNode.equals( that.getTargetNode() ) ) {\n+        if ( !sourceNode.equals( that.sourceNode ) ) {\n             return false;\n         }\n-        if ( !type.equals( that.getType() ) ) {\n+        if ( !targetNode.equals( that.targetNode ) ) {\n             return false;\n         }\n-        if ( !version.equals( that.getVersion() ) ) {\n+        if ( !type.equals( that.type ) ) {\n             return false;\n         }\n \n@@ -117,18 +106,18 @@ public int hashCode() {\n         int result = sourceNode.hashCode();\n         result = 31 * result + type.hashCode();\n         result = 31 * result + targetNode.hashCode();\n-        result = 31 * result + version.hashCode();\n+        result = 31 * result + ( int ) ( timestamp ^ ( timestamp >>> 32 ) );\n         return result;\n     }\n \n \n     @Override\n     public String toString() {\n-        return \"SimpleMarkedEdge{\" +\n+        return \"SimpleEdge{\" +\n                 \"sourceNode=\" + sourceNode +\n                 \", type='\" + type + '\\'' +\n                 \", targetNode=\" + targetNode +\n-                \", version=\" + version +\n+                \", timestamp=\" + timestamp +\n                 '}';\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleEdge.java",
                "sha": "576d9dd203d21a4027e3d27396f5b61d57c8e3e0",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleMarkedEdge.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleMarkedEdge.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 9,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleMarkedEdge.java",
                "patch": "@@ -36,15 +36,15 @@\n     private final boolean deleted;\n \n \n-    public SimpleMarkedEdge( final Id sourceNode, final String type, final Id targetNode, final UUID version, final boolean deleted) {\n+    public SimpleMarkedEdge( final Id sourceNode, final String type, final Id targetNode, final long timestamp, final boolean deleted) {\n \n-        super(sourceNode, type, targetNode, version);\n+        super(sourceNode, type, targetNode, timestamp);\n         this.deleted = deleted;\n     }\n \n \n     public SimpleMarkedEdge(final Edge edge, final boolean deleted){\n-        this(edge.getSourceNode(), edge.getType(), edge.getTargetNode(), edge.getVersion(), deleted);\n+        this(edge.getSourceNode(), edge.getType(), edge.getTargetNode(), edge.getTimestamp(), deleted);\n     }\n \n \n@@ -88,11 +88,7 @@ public int hashCode() {\n     @Override\n     public String toString() {\n         return \"SimpleMarkedEdge{\" +\n-                \"sourceNode=\" + sourceNode +\n-                \", type='\" + type + '\\'' +\n-                \", targetNode=\" + targetNode +\n-                \", version=\" + version +\n-                \", deleted=\" + deleted +\n-                '}';\n+                \"deleted=\" + deleted +\n+                \"} \" + super.toString();\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleMarkedEdge.java",
                "sha": "a5b4f2e5ef9b181dd20bba3d5491da3aacae4278",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdge.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdge.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 7,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdge.java",
                "patch": "@@ -25,6 +25,7 @@\n import org.apache.usergrid.persistence.core.util.ValidationUtils;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.SearchByEdge;\n+import org.apache.usergrid.persistence.graph.serialization.util.EdgeUtils;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.common.base.Optional;\n@@ -39,7 +40,7 @@\n     private final Id sourceNode;\n     private final Id targetNode;\n     private final String type;\n-    private final UUID maxVersion;\n+    private final long maxTimestamp;\n     private final Optional<Edge> last;\n \n \n@@ -48,20 +49,20 @@\n      * @param sourceNode The source node of the edge\n      * @param targetNode The target node of the edge\n      * @param type The edge type\n-     * @param maxVersion The maximum version to return\n+     * @param maxTimestamp The maximum timestamp to seek from\n      * @param last The value to start seeking from.  Must be >= this value\n      */\n-    public SimpleSearchByEdge( final Id sourceNode, final String type, final Id targetNode, final UUID maxVersion, final Edge last ) {\n+    public SimpleSearchByEdge( final Id sourceNode, final String type, final Id targetNode, final long maxTimestamp, final Edge last ) {\n         ValidationUtils.verifyIdentity(sourceNode);\n         ValidationUtils.verifyIdentity(targetNode);\n         ValidationUtils.verifyString( type, \"type\" );\n-        ValidationUtils.verifyTimeUuid( maxVersion, \"maxVersion\" );\n+        EdgeUtils.validateTimestamp(  maxTimestamp, \"maxTimestamp\" );\n \n \n         this.sourceNode = sourceNode;\n         this.targetNode = targetNode;\n         this.type = type;\n-        this.maxVersion = maxVersion;\n+        this.maxTimestamp = maxTimestamp;\n         this.last = Optional.fromNullable(last);\n     }\n \n@@ -85,8 +86,8 @@ public String getType() {\n \n \n     @Override\n-    public UUID getMaxVersion() {\n-        return maxVersion;\n+    public long getMaxTimestamp() {\n+        return maxTimestamp;\n     }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdge.java",
                "sha": "e0dbc296323cc3678cc3287f0cb79884d45f0901",
                "status": "modified"
            },
            {
                "additions": 12,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdgeType.java",
                "changes": 23,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdgeType.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 11,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdgeType.java",
                "patch": "@@ -25,6 +25,7 @@\n import org.apache.usergrid.persistence.core.util.ValidationUtils;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.SearchByEdgeType;\n+import org.apache.usergrid.persistence.graph.serialization.util.EdgeUtils;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.common.base.Optional;\n@@ -38,26 +39,26 @@\n \n     private final Id node;\n     private final String type;\n-    private final UUID maxVersion;\n+    private final long maxTimestamp;\n     private final Optional<Edge> last;\n \n \n     /**\n      * Create the search modules\n      * @param node The node to search from\n      * @param type The edge type\n-     * @param maxVersion The maximum version to return\n+     * @param maxTimestamp The maximum timestamp to return\n      * @param last The value to start seeking from.  Must be >= this value\n      */\n-    public SimpleSearchByEdgeType( final Id node, final String type, final UUID maxVersion, final Edge last ) {\n+    public SimpleSearchByEdgeType( final Id node, final String type, final long maxTimestamp, final Edge last ) {\n         ValidationUtils.verifyIdentity(node);\n         ValidationUtils.verifyString( type, \"type\" );\n-        ValidationUtils.verifyTimeUuid( maxVersion, \"maxVersion\" );\n+        EdgeUtils.validateTimestamp(maxTimestamp, \"maxTimestamp\");\n \n \n         this.node = node;\n         this.type = type;\n-        this.maxVersion = maxVersion;\n+        this.maxTimestamp = maxTimestamp;\n         this.last = Optional.fromNullable(last);\n     }\n \n@@ -75,8 +76,8 @@ public String getType() {\n \n \n     @Override\n-    public UUID getMaxVersion() {\n-        return maxVersion;\n+    public long getMaxTimestamp() {\n+        return maxTimestamp;\n     }\n \n \n@@ -91,16 +92,16 @@ public boolean equals( final Object o ) {\n         if ( this == o ) {\n             return true;\n         }\n-        if ( o == null || getClass() != o.getClass() ) {\n+        if ( !( o instanceof SimpleSearchByEdgeType ) ) {\n             return false;\n         }\n \n         final SimpleSearchByEdgeType that = ( SimpleSearchByEdgeType ) o;\n \n-        if ( !last.equals( that.last ) ) {\n+        if ( maxTimestamp != that.maxTimestamp ) {\n             return false;\n         }\n-        if ( !maxVersion.equals( that.maxVersion ) ) {\n+        if ( !last.equals( that.last ) ) {\n             return false;\n         }\n         if ( !node.equals( that.node ) ) {\n@@ -118,7 +119,7 @@ public boolean equals( final Object o ) {\n     public int hashCode() {\n         int result = node.hashCode();\n         result = 31 * result + type.hashCode();\n-        result = 31 * result + maxVersion.hashCode();\n+        result = 31 * result + ( int ) ( maxTimestamp ^ ( maxTimestamp >>> 32 ) );\n         result = 31 * result + last.hashCode();\n         return result;\n     }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByEdgeType.java",
                "sha": "75e921788ffa8c8a255684c2bf93915df4d11508",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByIdType.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByIdType.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 3,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByIdType.java",
                "patch": "@@ -41,13 +41,13 @@\n      *\n      * @param node The node to search from\n      * @param type The edge type\n-     * @param maxVersion The maximum version to return\n+     * @param maxTimestamp The maximum version to search\n      * @param idType The id type on the edge\n      * @param last The value to start seeking from.  Must be >= this value\n \n      */\n-    public SimpleSearchByIdType( final Id node, final String type, final UUID maxVersion, final String idType, final Edge last  ) {\n-        super( node, type, maxVersion, last );\n+    public SimpleSearchByIdType( final Id node, final String type, final long maxTimestamp, final String idType, final Edge last  ) {\n+        super( node, type, maxTimestamp, last );\n \n         ValidationUtils.verifyString( idType, \"idType\" );\n         this.idType = idType;",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/SimpleSearchByIdType.java",
                "sha": "6d5fb9f8f46bf6798fd8a225a876eaeed7a3267c",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairImpl.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairImpl.java",
                "patch": "@@ -138,7 +138,7 @@ public void call( final MarkedEdge markedEdge ) {\n \n                 final SimpleSearchByEdge search =\n                         new SimpleSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getTargetNode(),\n-                                edge.getVersion(), null );\n+                                edge.getTimestamp(), null );\n \n                 return serialization.getEdgeVersions( scope, search );\n             }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairImpl.java",
                "sha": "554a3ba703de8aa86cace53e2fa1cbe4252a037f",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepair.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepair.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 4,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepair.java",
                "patch": "@@ -39,12 +39,12 @@\n      * @param scope The scope to use\n      * @param sourceId The source Id to use\n      * @param edgeType The edge type\n-     * @param version The max version to clean\n+     * @param maxTimestamp The max timestamp to clean\n      *\n      * @return An observable that emits the total number of sub types still in use.  0 implies the type and subtypes\n      *         have been removed.  Anything > 0 implies the edgeType and subTypes are still in use\n      */\n-    public Observable<Integer> repairSources( ApplicationScope scope, Id sourceId, String edgeType, UUID version );\n+    public Observable<Integer> repairSources( ApplicationScope scope, Id sourceId, String edgeType, long maxTimestamp );\n \n \n     /**\n@@ -53,10 +53,10 @@\n      * @param scope The scope to use\n      * @param targetId The target Id to use\n      * @param edgeType The edge type\n-     * @param version The max version to clean\n+     * @param maxTimestamp The max version to clean\n      *\n      * @return An observable that emits the total number of sub types still in use.  0 implies the type and subtypes\n      *         have been removed.  Anything > 0 implies the edgeType and subTypes are still in use\n      */\n-    public Observable<Integer> repairTargets( ApplicationScope scope, Id targetId, String edgeType, UUID version );\n+    public Observable<Integer> repairTargets( ApplicationScope scope, Id targetId, String edgeType, long maxTimestamp );\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepair.java",
                "sha": "f98b0fa1d4fdfe699e71a556d5a06810e2e76850",
                "status": "modified"
            },
            {
                "additions": 33,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairImpl.java",
                "changes": 65,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 32,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairImpl.java",
                "patch": "@@ -38,6 +38,7 @@\n import org.apache.usergrid.persistence.graph.serialization.EdgeMetadataSerialization;\n import org.apache.usergrid.persistence.graph.serialization.impl.MergedEdgeReader;\n import org.apache.usergrid.persistence.core.rx.ObservableIterator;\n+import org.apache.usergrid.persistence.graph.serialization.util.EdgeUtils;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.common.base.Preconditions;\n@@ -90,31 +91,31 @@ public EdgeMetaRepairImpl( final EdgeMetadataSerialization edgeMetadataSerializa\n \n     @Override\n     public Observable<Integer> repairSources( final ApplicationScope scope, final Id sourceId, final String edgeType,\n-                                              final UUID version ) {\n+                                              final long maxTimestamp ) {\n \n \n-        return clearTypes( scope, sourceId, edgeType, version, source );\n+        return clearTypes( scope, sourceId, edgeType, maxTimestamp, source );\n     }\n \n \n     @Override\n     public Observable<Integer> repairTargets( final ApplicationScope scope, final Id targetId, final String edgeType,\n-                                              final UUID version ) {\n-        return clearTypes( scope, targetId, edgeType, version, target );\n+                                              final long maxTimestamp) {\n+        return clearTypes( scope, targetId, edgeType, maxTimestamp, target );\n     }\n \n \n     private Observable<Integer> clearTypes( final ApplicationScope scope, final Id node, final String edgeType,\n-                                            final UUID version, final CleanSerialization serialization ) {\n+                                            final long maxTimestamp, final CleanSerialization serialization ) {\n \n         ValidationUtils.validateApplicationScope( scope );\n         ValidationUtils.verifyIdentity( node );\n         Preconditions.checkNotNull( edgeType, \"edge type is required\" );\n-        Preconditions.checkNotNull( version, \"version is required\" );\n+        EdgeUtils.validateTimestamp( maxTimestamp, \"maxTimestamp\" );\n         Preconditions.checkNotNull( serialization, \"serialization is required\" );\n \n \n-        Observable<Integer> deleteCounts = serialization.loadEdgeSubTypes( scope, node, edgeType, version )\n+        Observable<Integer> deleteCounts = serialization.loadEdgeSubTypes( scope, node, edgeType, maxTimestamp )\n                 .buffer( graphFig.getRepairConcurrentSize() )\n                         //buffer them into concurrent groups based on the concurrent repair size\n                 .flatMap( new Func1<List<String>, Observable<Integer>>() {\n@@ -135,7 +136,7 @@ public EdgeMetaRepairImpl( final EdgeMetadataSerialization edgeMetadataSerializa\n \n                             Observable<Integer> search =\n                                     //load each edge in it's own thread\n-                                    serialization.loadEdges( scope, node, edgeType, subType, version ).doOnNext( RX_LOG ).take( 1 ).count()\n+                                    serialization.loadEdges( scope, node, edgeType, subType, maxTimestamp ).doOnNext( RX_LOG ).take( 1 ).count()\n                                                  .doOnNext( new Action1<Integer>() {\n \n                                                      @Override\n@@ -163,7 +164,7 @@ public void call( final Integer count ) {\n                                                                  subType );\n                                                          batch.mergeShallow( serialization\n                                                                  .removeEdgeSubType( scope, node, edgeType, subType,\n-                                                                         version ) );\n+                                                                         maxTimestamp ) );\n                                                      }\n                                                  } );\n \n@@ -210,15 +211,15 @@ public void call( final Integer subTypeUsedCount ) {\n                  * We can only execute deleting this type if no sub types were deleted\n                  */\n                 if ( subTypeUsedCount != 0 ) {\n-                    LOG.debug( \"Type {} has {} subtypes in use as of version {}.  Not deleting type.\", edgeType,\n-                            subTypeUsedCount, version );\n+                    LOG.debug( \"Type {} has {} subtypes in use as of maxTimestamp {}.  Not deleting type.\", edgeType,\n+                            subTypeUsedCount, maxTimestamp );\n                     return;\n                 }\n \n                 try {\n \n-                    LOG.debug( \"Type {} has no subtypes in use as of version {}.  Deleting type.\", edgeType, version );\n-                    serialization.removeEdgeType( scope, node, edgeType, version ).execute();\n+                    LOG.debug( \"Type {} has no subtypes in use as of maxTimestamp {}.  Deleting type.\", edgeType, maxTimestamp );\n+                    serialization.removeEdgeType( scope, node, edgeType, maxTimestamp ).execute();\n                 }\n                 catch ( ConnectionException e ) {\n                     throw new RuntimeException( \"Unable to execute mutation\" );\n@@ -234,29 +235,29 @@ public void call( final Integer subTypeUsedCount ) {\n     private static interface CleanSerialization {\n \n         /**\n-         * Load all subtypes for the edge with a version <= the provided version\n+         * Load all subtypes for the edge with a maxTimestamp <= the provided maxTimestamp\n          */\n         Observable<String> loadEdgeSubTypes( final ApplicationScope scope, final Id nodeId, final String type,\n-                                             final UUID version );\n+                                             final long maxTimestamp );\n \n \n         /**\n          * Load an observable with edges from the details provided\n          */\n         Observable<MarkedEdge> loadEdges( final ApplicationScope scope, final Id nodeId, final String edgeType,\n-                                          final String subType, final UUID version );\n+                                          final String subType, final long maxTimestamp );\n \n         /**\n          * Remove the sub type specified\n          */\n         MutationBatch removeEdgeSubType( final ApplicationScope scope, final Id nodeId, final String edgeType,\n-                                         final String subType, final UUID version );\n+                                         final String subType, final long maxTimestamp );\n \n         /**\n          * Remove the edge type\n          */\n         MutationBatch removeEdgeType( final ApplicationScope scope, final Id nodeId, final String type,\n-                                      final UUID version );\n+                                      final long maxTimestamp );\n     }\n \n \n@@ -268,7 +269,7 @@ MutationBatch removeEdgeType( final ApplicationScope scope, final Id nodeId, fin\n \n         @Override\n         public Observable<String> loadEdgeSubTypes( final ApplicationScope scope, final Id nodeId,\n-                                                    final String edgeType, final UUID version ) {\n+                                                    final String edgeType, final long maxTimestamp ) {\n \n \n             return Observable.create( new ObservableIterator<String>( \"edgeTargetIdTypes\" ) {\n@@ -283,23 +284,23 @@ MutationBatch removeEdgeType( final ApplicationScope scope, final Id nodeId, fin\n \n         @Override\n         public Observable<MarkedEdge> loadEdges( final ApplicationScope scope, final Id nodeId, final String edgeType,\n-                                                 final String subType, final UUID version ) {\n+                                                 final String subType, final long maxTimestamp ) {\n             return mergedEdgeReader.getEdgesToTargetBySourceType( scope,\n-                    new SimpleSearchByIdType( nodeId, edgeType, version, subType, null ) );\n+                    new SimpleSearchByIdType( nodeId, edgeType, maxTimestamp, subType, null ) );\n         }\n \n \n         @Override\n         public MutationBatch removeEdgeSubType( final ApplicationScope scope, final Id nodeId, final String type,\n-                                                final String subType, final UUID version ) {\n-            return edgeMetadataSerialization.removeIdTypeToTarget( scope, nodeId, type, subType, version );\n+                                                final String subType, final long maxTimestamp ) {\n+            return edgeMetadataSerialization.removeIdTypeToTarget( scope, nodeId, type, subType, maxTimestamp );\n         }\n \n \n         @Override\n         public MutationBatch removeEdgeType( final ApplicationScope scope, final Id nodeId, final String type,\n-                                             final UUID version ) {\n-            return edgeMetadataSerialization.removeEdgeTypeToTarget( scope, nodeId, type, version );\n+                                             final long maxTimestamp ) {\n+            return edgeMetadataSerialization.removeEdgeTypeToTarget( scope, nodeId, type, maxTimestamp );\n         }\n     };\n \n@@ -310,7 +311,7 @@ public MutationBatch removeEdgeType( final ApplicationScope scope, final Id node\n \n         @Override\n         public Observable<String> loadEdgeSubTypes( final ApplicationScope scope, final Id nodeId,\n-                                                    final String edgeType, final UUID version ) {\n+                                                    final String edgeType, final long maxTimestamp ) {\n             return Observable.create( new ObservableIterator<String>( \"edgeSourceIdTypes\" ) {\n                 @Override\n                 protected Iterator<String> getIterator() {\n@@ -323,24 +324,24 @@ public MutationBatch removeEdgeType( final ApplicationScope scope, final Id node\n \n         @Override\n         public Observable<MarkedEdge> loadEdges( final ApplicationScope scope, final Id nodeId, final String edgeType,\n-                                                 final String subType, final UUID version ) {\n+                                                 final String subType, final long maxTimestamp ) {\n \n             return mergedEdgeReader.getEdgesFromSourceByTargetType( scope,\n-                    new SimpleSearchByIdType( nodeId, edgeType, version, subType, null ) );\n+                    new SimpleSearchByIdType( nodeId, edgeType, maxTimestamp, subType, null ) );\n         }\n \n \n         @Override\n         public MutationBatch removeEdgeSubType( final ApplicationScope scope, final Id nodeId, final String type,\n-                                                final String subType, final UUID version ) {\n-            return edgeMetadataSerialization.removeIdTypeFromSource( scope, nodeId, type, subType, version );\n+                                                final String subType, final long maxTimestamp ) {\n+            return edgeMetadataSerialization.removeIdTypeFromSource( scope, nodeId, type, subType, maxTimestamp );\n         }\n \n \n         @Override\n         public MutationBatch removeEdgeType( final ApplicationScope scope, final Id nodeId, final String type,\n-                                             final UUID version ) {\n-            return edgeMetadataSerialization.removeEdgeTypeFromSource( scope, nodeId, type, version );\n+                                             final long maxTimestamp ) {\n+            return edgeMetadataSerialization.removeEdgeTypeFromSource( scope, nodeId, type, maxTimestamp );\n         }\n     };\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairImpl.java",
                "sha": "01ad9c435914bffd10e6565089763c20ed70571b",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeWriteCompactImpl.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeWriteCompactImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 5,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeWriteCompactImpl.java",
                "patch": "@@ -78,18 +78,18 @@ public EdgeWriteCompactImpl( @CommitLogEdgeSerialization final EdgeSerialization\n        }\n \n     @Override\n-    public Observable<Integer> compact( final ApplicationScope scope, final MarkedEdge edge, final UUID timestamp ) {\n+    public Observable<Integer> compact( final ApplicationScope scope, final MarkedEdge edge, final UUID operationTimestamp ) {\n         final Edge writtenEdge = edge;\n \n-              final UUID writeVersion = edge.getVersion();\n+              final long timestamp = edge.getTimestamp();\n \n               return Observable.create( new ObservableIterator<MarkedEdge>( \"getEdgeVersions\" ) {\n                   @Override\n                   protected Iterator<MarkedEdge> getIterator() {\n                       //get our edge as it exists in the commit log\n                       return commitLog.getEdgeVersions( scope,\n                               new SimpleSearchByEdge( writtenEdge.getSourceNode(), writtenEdge.getType(),\n-                                      writtenEdge.getTargetNode(), writeVersion, null ) );\n+                                      writtenEdge.getTargetNode(), timestamp, null ) );\n                   }\n               } )\n                               //buffer them, then execute mutations in batch\n@@ -106,10 +106,10 @@ public EdgeWriteCompactImpl( @CommitLogEdgeSerialization final EdgeSerialization\n                                   LOG.debug( \"Buffering edge {} to permanent storage and removing from commitlog\", edge );\n \n                                   //batch the write\n-                                  storageWriteBatch.mergeShallow( permanentStorage.writeEdge( scope, edge, timestamp ) );\n+                                  storageWriteBatch.mergeShallow( permanentStorage.writeEdge( scope, edge, operationTimestamp ) );\n \n                                   //batch the cleanup\n-                                  commitlogCleanBatch.mergeShallow( commitLog.deleteEdge( scope, edge, timestamp ) );\n+                                  commitlogCleanBatch.mergeShallow( commitLog.deleteEdge( scope, edge, operationTimestamp ) );\n                               }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeWriteCompactImpl.java",
                "sha": "3a89c7806a8412016c6e90292644ac7a751cef4d",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerialization.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerialization.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 8,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerialization.java",
                "patch": "@@ -62,11 +62,11 @@\n      * @param scope Organization scope\n      * @param sourceNode Source node\n      * @param type The edge type\n-     * @param version The version to use on the delete\n+     * @param timestamp The version to use on the delete\n      *\n      * @return A mutation batch to use on issuing the delelete\n      */\n-    MutationBatch removeEdgeTypeFromSource( ApplicationScope scope, Id sourceNode, String type, UUID version );\n+    MutationBatch removeEdgeTypeFromSource( ApplicationScope scope, Id sourceNode, String type, long timestamp );\n \n     /**\n      * Remove all meta data from the source to the target type.  The caller must ensure that this is the last edge with\n@@ -88,12 +88,12 @@\n      * @param sourceNode Source node\n      * @param type The edge type\n      * @param idType The idType to use\n-     * @param version The version to use on the delete\n+     * @param timestamp The version to use on the delete\n      *\n      * @return a mutation batch with the delete operations\n      */\n     MutationBatch removeIdTypeFromSource( ApplicationScope scope, Id sourceNode, String type, String idType,\n-                                          UUID version );\n+                                          long timestamp );\n \n     /**\n      * Remove all meta data from the target to the source type.  The caller must ensure that this is the last edge with\n@@ -114,11 +114,11 @@ MutationBatch removeIdTypeFromSource( ApplicationScope scope, Id sourceNode, Str\n      * @param scope Organization scope\n      * @param targetNode Source node\n      * @param type The edge type\n-     * @param version The version to use on the delete\n+     * @param timestamp The version to use on the delete\n      *\n      * @return A mutation batch to use on issuing the delelete\n      */\n-    MutationBatch removeEdgeTypeToTarget( ApplicationScope scope, Id targetNode, String type, UUID version );\n+    MutationBatch removeEdgeTypeToTarget( ApplicationScope scope, Id targetNode, String type, long timestamp );\n \n \n     /**\n@@ -141,12 +141,12 @@ MutationBatch removeIdTypeFromSource( ApplicationScope scope, Id sourceNode, Str\n      * @param targetNode Source node\n      * @param type The edge type\n      * @param idType The idType to use\n-     * @param version The version to use on the delete\n+     * @param timestamp The version to use on the delete\n      *\n      * @return a mutation batch with the delete operations\n      */\n     MutationBatch removeIdTypeToTarget( ApplicationScope scope, Id targetNode, String type, String idType,\n-                                        UUID version );\n+                                        long timestamp );\n \n     /**\n      * Get all edge types from the given source node",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerialization.java",
                "sha": "cc62a42589cbcee939cee241d392974ac020317c",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/NodeSerialization.java",
                "changes": 14,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/NodeSerialization.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 7,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/NodeSerialization.java",
                "patch": "@@ -44,9 +44,9 @@\n      *\n      * @param scope The org scope of the graph\n      * @param node The node to mark\n-     * @param version The version to mark for deletion\n+     * @param timestamp The timestamp to mark for deletion.  Anything <= this time is considered deleted from the graph\n      */\n-    MutationBatch mark( ApplicationScope scope, Id node, UUID version );\n+    MutationBatch mark( ApplicationScope scope, Id node, long timestamp );\n \n \n     /**\n@@ -55,16 +55,16 @@\n      * @param node\n      * @return\n      */\n-    MutationBatch delete( ApplicationScope scope, Id node, UUID version );\n+    MutationBatch delete( ApplicationScope scope, Id node, long timestamp );\n \n     /**\n-     * Get the maximum version of a node marked for deletion.  If the node has no mark\n+     * Get the maximum timestamp of a node marked for deletion.  If the node has no mark\n      * the optional will return empty\n      * @param scope The scope to search in\n      * @param nodeId The node id\n-     * @return The optional uuid.  If none is present, the node is not currently marked\n+     * @return The optional timestamp.  If none is present, the node is not currently marked\n      */\n-    Optional<UUID> getMaxVersion(ApplicationScope scope, Id nodeId);\n+    Optional<Long> getMaxVersion(ApplicationScope scope, Id nodeId);\n \n     /**\n      * Return a map with all max versions from the specified nodeIds.  If no max version is present\n@@ -74,5 +74,5 @@\n      * @param edges The collection of edges we need to check against.  Both the source and target Id's will be added\n      * @return A map of all marked Id's, with the mark version as the value\n      */\n-    Map<Id, UUID> getMaxVersions(ApplicationScope scope, Collection<? extends Edge> edges);\n+    Map<Id, Long> getMaxVersions(ApplicationScope scope, Collection<? extends Edge> edges);\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/NodeSerialization.java",
                "sha": "96f869dcc0b1861eb257cb3420efbdccd9661539",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationImpl.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 18,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationImpl.java",
                "patch": "@@ -141,7 +141,7 @@ public MutationBatch writeEdge( final ApplicationScope scope, final Edge edge )\n         final Id source = edge.getSourceNode();\n         final Id target = edge.getTargetNode();\n         final String edgeType = edge.getType();\n-        final long timestamp = CassUtils.getTimestamp( edge.getVersion() );\n+        final long timestamp = edge.getTimestamp();\n \n         final MutationBatch batch = keyspace.prepareMutationBatch().withConsistencyLevel( cassandraConfig.getWriteCL() ).withTimestamp( timestamp );\n \n@@ -184,54 +184,54 @@ public MutationBatch writeEdge( final ApplicationScope scope, final Edge edge )\n \n     @Override\n     public MutationBatch removeEdgeTypeFromSource( final ApplicationScope scope, final Edge edge ) {\n-        return removeEdgeTypeFromSource( scope, edge.getSourceNode(), edge.getType(), edge.getVersion() );\n+        return removeEdgeTypeFromSource( scope, edge.getSourceNode(), edge.getType(), edge.getTimestamp() );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeFromSource( final ApplicationScope scope, final Id sourceNode,\n-                                                   final String type, final UUID version ) {\n+                                                   final String type, final long version ) {\n         return removeEdgeType( scope, sourceNode, type, version, CF_SOURCE_EDGE_TYPES );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeFromSource( final ApplicationScope scope, final Edge edge ) {\n         return removeIdTypeFromSource( scope, edge.getSourceNode(), edge.getType(), edge.getTargetNode().getType(),\n-                edge.getVersion() );\n+                edge.getTimestamp() );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeFromSource( final ApplicationScope scope, final Id sourceNode, final String type,\n-                                                 final String idType, final UUID version ) {\n+                                                 final String idType, final long version ) {\n         return removeIdType( scope, sourceNode, idType, type, version, CF_SOURCE_EDGE_ID_TYPES );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeToTarget( final ApplicationScope scope, final Edge edge ) {\n-        return removeEdgeTypeToTarget( scope, edge.getTargetNode(), edge.getType(), edge.getVersion() );\n+        return removeEdgeTypeToTarget( scope, edge.getTargetNode(), edge.getType(), edge.getTimestamp() );\n     }\n \n \n     @Override\n     public MutationBatch removeEdgeTypeToTarget( final ApplicationScope scope, final Id targetNode, final String type,\n-                                                 final UUID version ) {\n+                                                 final long version ) {\n         return removeEdgeType( scope, targetNode, type, version, CF_TARGET_EDGE_TYPES );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeToTarget( final ApplicationScope scope, final Edge edge ) {\n         return removeIdTypeToTarget( scope, edge.getTargetNode(), edge.getType(), edge.getSourceNode().getType(),\n-                edge.getVersion() );\n+                edge.getTimestamp() );\n     }\n \n \n     @Override\n     public MutationBatch removeIdTypeToTarget( final ApplicationScope scope, final Id targetNode, final String type,\n-                                               final String idType, final UUID version ) {\n+                                               final String idType, final long version ) {\n         return removeIdType( scope, targetNode, idType, type, version, CF_TARGET_EDGE_ID_TYPES );\n     }\n \n@@ -246,17 +246,16 @@ public MutationBatch removeIdTypeToTarget( final ApplicationScope scope, final I\n      * @param cf The column family\n      */\n     private MutationBatch removeEdgeType( final ApplicationScope scope, final Id rowKeyId, final String edgeType,\n-                                          final UUID version,\n+                                          final long version,\n                                           final MultiTennantColumnFamily<ApplicationScope, Id, String> cf ) {\n \n-        final long timestamp = CassUtils.getTimestamp( version );\n+\n \n \n         //write target<--source edge type meta data\n         final ScopedRowKey<ApplicationScope, Id> rowKey = new ScopedRowKey<ApplicationScope, Id>( scope, rowKeyId );\n \n-\n-        final MutationBatch batch = keyspace.prepareMutationBatch().withTimestamp( timestamp );\n+        final MutationBatch batch = keyspace.prepareMutationBatch().withTimestamp( version );\n \n         batch.withRow( cf, rowKey ).deleteColumn( edgeType );\n \n@@ -277,14 +276,11 @@ private MutationBatch removeEdgeType( final ApplicationScope scope, final Id row\n      * @return A populated mutation with the remove operations\n      */\n     private MutationBatch removeIdType( final ApplicationScope scope, final Id rowId, final String idType,\n-                                        final String edgeType, final UUID version,\n+                                        final String edgeType, final long version,\n                                         final MultiTennantColumnFamily<ApplicationScope, EdgeIdTypeKey, String> cf ) {\n \n \n-\n-        final long timestamp = CassUtils.getTimestamp( version );\n-\n-        final   MutationBatch batch = keyspace.prepareMutationBatch().withTimestamp( timestamp );\n+          final   MutationBatch batch = keyspace.prepareMutationBatch().withTimestamp( version );\n \n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeMetadataSerializationImpl.java",
                "sha": "dba8356198c9e7081a8174294961b17e1b025d5e",
                "status": "modified"
            },
            {
                "additions": 125,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeSerializationImpl.java",
                "changes": 242,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeSerializationImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 117,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeSerializationImpl.java",
                "patch": "@@ -30,20 +30,21 @@\n import javax.inject.Inject;\n \n import org.apache.cassandra.db.marshal.BytesType;\n+import org.apache.cassandra.db.marshal.DynamicCompositeType;\n \n import org.apache.usergrid.persistence.core.astyanax.CassandraConfig;\n-import org.apache.usergrid.persistence.core.astyanax.ColumnTypes;\n-import org.apache.usergrid.persistence.core.astyanax.OrganizationScopedRowKeySerializer;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.core.astyanax.ColumnNameIterator;\n import org.apache.usergrid.persistence.core.astyanax.ColumnParser;\n+import org.apache.usergrid.persistence.core.astyanax.ColumnTypes;\n import org.apache.usergrid.persistence.core.astyanax.CompositeFieldSerializer;\n import org.apache.usergrid.persistence.core.astyanax.IdColDynamicCompositeSerializer;\n import org.apache.usergrid.persistence.core.astyanax.IdRowCompositeSerializer;\n import org.apache.usergrid.persistence.core.astyanax.MultiTennantColumnFamily;\n import org.apache.usergrid.persistence.core.astyanax.MultiTennantColumnFamilyDefinition;\n+import org.apache.usergrid.persistence.core.astyanax.OrganizationScopedRowKeySerializer;\n import org.apache.usergrid.persistence.core.astyanax.ScopedRowKey;\n import org.apache.usergrid.persistence.core.migration.Migration;\n+import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.core.util.ValidationUtils;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.GraphFig;\n@@ -71,15 +72,18 @@\n import com.netflix.astyanax.model.DynamicComposite;\n import com.netflix.astyanax.query.RowQuery;\n import com.netflix.astyanax.serializers.AbstractSerializer;\n+import com.netflix.astyanax.serializers.LongSerializer;\n+import com.netflix.astyanax.serializers.StringSerializer;\n import com.netflix.astyanax.serializers.UUIDSerializer;\n import com.netflix.astyanax.util.RangeBuilder;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.apache.usergrid.persistence.core.astyanax.ColumnTypes.LONG_TYPE_REVERSED;\n+import static org.apache.usergrid.persistence.core.astyanax.ColumnTypes.UUID_TYPE_REVERSED;\n \n \n /**\n- *  Serialization for edges.  Delegates partitioning to the sharding strategy.\n- *\n+ * Serialization for edges.  Delegates partitioning to the sharding strategy.\n  */\n @Singleton\n public class EdgeSerializationImpl implements EdgeSerialization, Migration {\n@@ -96,13 +100,23 @@\n     //Edge serializers\n     private static final EdgeSerializer EDGE_SERIALIZER = new EdgeSerializer();\n \n-    private static final UUIDSerializer UUID_SERIALIZER = UUIDSerializer.get();\n+    private static final LongSerializer LONG_SERIALIZER = LongSerializer.get();\n+\n+\n+    /**\n+     * Constant for the dynamic composite comparator type we'll need\n+     */\n+    public static final String EDGE_DYNAMIC_COMPOSITE_TYPE =\n+            //we purposefully associate lower case \"l\" and \"u\" with reversed types.  This way we can use\n+            //the default serialization in Astayanax, but get reverse order in cassandra\n+            DynamicCompositeType.class.getSimpleName() + \"(s=>UTF8Type,l=>\" + LONG_TYPE_REVERSED + \",u=>\"\n+                    + UUID_TYPE_REVERSED + \")\";\n \n \n     /**\n      * Get all graph edge versions\n      */\n-    private final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, UUID> graphEdgeVersionsCf;\n+    private final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, Long> graphEdgeVersionsCf;\n \n \n     // column families\n@@ -153,31 +167,26 @@ public EdgeSerializationImpl( final Keyspace keyspace, final CassandraConfig cas\n         this.edgeShardStrategy = edgeShardStrategy;\n \n         //initialize the CF's from our implementation\n-        sourceNodeEdgesCf = new MultiTennantColumnFamily<ApplicationScope, RowKey, DirectedEdge>(\n-                edgeShardStrategy.getSourceNodeCfName(),\n-                new OrganizationScopedRowKeySerializer<RowKey>( ROW_SERIALIZER ), EDGE_SERIALIZER );\n+        sourceNodeEdgesCf = new MultiTennantColumnFamily<>( edgeShardStrategy.getSourceNodeCfName(),\n+                new OrganizationScopedRowKeySerializer<>( ROW_SERIALIZER ), EDGE_SERIALIZER );\n \n \n-        targetNodeEdgesCf = new MultiTennantColumnFamily<ApplicationScope, RowKey, DirectedEdge>(\n-                edgeShardStrategy.getTargetNodeCfName(),\n-                new OrganizationScopedRowKeySerializer<RowKey>( ROW_SERIALIZER ), EDGE_SERIALIZER );\n+        targetNodeEdgesCf = new MultiTennantColumnFamily<>( edgeShardStrategy.getTargetNodeCfName(),\n+                new OrganizationScopedRowKeySerializer<>( ROW_SERIALIZER ), EDGE_SERIALIZER );\n \n \n-        sourceNodeTargetTypeCf = new MultiTennantColumnFamily<ApplicationScope, RowKeyType, DirectedEdge>(\n-                edgeShardStrategy.getSourceNodeTargetTypeCfName(),\n-                new OrganizationScopedRowKeySerializer<RowKeyType>( ROW_TYPE_SERIALIZER ), EDGE_SERIALIZER );\n+        sourceNodeTargetTypeCf = new MultiTennantColumnFamily<>( edgeShardStrategy.getSourceNodeTargetTypeCfName(),\n+                new OrganizationScopedRowKeySerializer<>( ROW_TYPE_SERIALIZER ), EDGE_SERIALIZER );\n \n \n         /**\n          * The edges that are to the target node with the source type.  The target node is the row key\n          */\n-        targetNodeSourceTypeCf = new MultiTennantColumnFamily<ApplicationScope, RowKeyType, DirectedEdge>(\n-                edgeShardStrategy.getTargetNodeSourceTypeCfName(),\n-                new OrganizationScopedRowKeySerializer<RowKeyType>( ROW_TYPE_SERIALIZER ), EDGE_SERIALIZER );\n+        targetNodeSourceTypeCf = new MultiTennantColumnFamily<>( edgeShardStrategy.getTargetNodeSourceTypeCfName(),\n+                new OrganizationScopedRowKeySerializer<>( ROW_TYPE_SERIALIZER ), EDGE_SERIALIZER );\n \n-        graphEdgeVersionsCf = new MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, UUID>(\n-                edgeShardStrategy.getGraphEdgeVersions(),\n-                new OrganizationScopedRowKeySerializer<EdgeRowKey>( EDGE_ROW_KEY_SERIALIZER ), UUID_SERIALIZER );\n+        graphEdgeVersionsCf = new MultiTennantColumnFamily<>( edgeShardStrategy.getGraphEdgeVersions(),\n+                new OrganizationScopedRowKeySerializer<>( EDGE_ROW_KEY_SERIALIZER ), LONG_SERIALIZER );\n     }\n \n \n@@ -188,8 +197,8 @@ public MutationBatch writeEdge( final ApplicationScope scope, final MarkedEdge m\n         ValidationUtils.verifyTimeUuid( timestamp, \"timestamp\" );\n \n \n-        final MutationBatch batch =\n-                keyspace.prepareMutationBatch().withConsistencyLevel( cassandraConfig.getWriteCL() ).withTimestamp( timestamp.timestamp() );\n+        final MutationBatch batch = keyspace.prepareMutationBatch().withConsistencyLevel( cassandraConfig.getWriteCL() )\n+                                            .withTimestamp( timestamp.timestamp() );\n \n         final boolean isDeleted = markedEdge.isDeleted();\n \n@@ -209,9 +218,9 @@ public void countEdge( final Id rowId, final long shardId, final String... types\n \n \n             @Override\n-            public void writeVersion( final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, UUID> columnFamily,\n-                                      final EdgeRowKey rowKey, final UUID version ) {\n-                batch.withRow( columnFamily, ScopedRowKey.fromKey( scope, rowKey ) ).putColumn( version, isDeleted );\n+            public void writeVersion( final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, Long> columnFamily,\n+                                      final EdgeRowKey rowKey, final long timestamp ) {\n+                batch.withRow( columnFamily, ScopedRowKey.fromKey( scope, rowKey ) ).putColumn( timestamp, isDeleted );\n             }\n         } );\n \n@@ -227,8 +236,8 @@ public MutationBatch deleteEdge( final ApplicationScope scope, final MarkedEdge\n         ValidationUtils.verifyTimeUuid( timestamp, \"timestamp\" );\n \n \n-        final MutationBatch batch =\n-                keyspace.prepareMutationBatch().withConsistencyLevel( cassandraConfig.getWriteCL() ).withTimestamp( timestamp.timestamp() );\n+        final MutationBatch batch = keyspace.prepareMutationBatch().withConsistencyLevel( cassandraConfig.getWriteCL() )\n+                                            .withTimestamp( timestamp.timestamp() );\n \n \n         doWrite( scope, markedEdge, new RowOp<RowKey>() {\n@@ -246,9 +255,9 @@ public void countEdge( final Id rowId, final long shardId, final String... types\n \n \n             @Override\n-            public void writeVersion( final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, UUID> columnFamily,\n-                                      final EdgeRowKey rowKey, final UUID version ) {\n-                batch.withRow( columnFamily, ScopedRowKey.fromKey( scope, rowKey ) ).deleteColumn( version );\n+            public void writeVersion( final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, Long> columnFamily,\n+                                      final EdgeRowKey rowKey, final long timestamp ) {\n+                batch.withRow( columnFamily, ScopedRowKey.fromKey( scope, rowKey ) ).deleteColumn( timestamp );\n             }\n         } );\n \n@@ -270,34 +279,34 @@ private void doWrite( final ApplicationScope scope, final MarkedEdge edge, final\n \n         final Id sourceNodeId = edge.getSourceNode();\n         final Id targetNodeId = edge.getTargetNode();\n-        final UUID version = edge.getVersion();\n+        final long timestamp = edge.getTimestamp();\n         final String type = edge.getType();\n \n \n         /**\n          * Key in the serializers based on the edge\n          */\n \n-        final RowKey sourceRowKey =\n-                new RowKey( sourceNodeId, type, edgeShardStrategy.getWriteShard( scope, sourceNodeId, version, type ) );\n+        final RowKey sourceRowKey = new RowKey( sourceNodeId, type,\n+                edgeShardStrategy.getWriteShard( scope, sourceNodeId, timestamp, type ) );\n \n         final RowKeyType sourceRowKeyType = new RowKeyType( sourceNodeId, type, targetNodeId,\n-                edgeShardStrategy.getWriteShard( scope, sourceNodeId, version, type, targetNodeId.getType() ) );\n+                edgeShardStrategy.getWriteShard( scope, sourceNodeId, timestamp, type, targetNodeId.getType() ) );\n \n-        final DirectedEdge sourceEdge = new DirectedEdge( targetNodeId, version );\n+        final DirectedEdge sourceEdge = new DirectedEdge( targetNodeId, timestamp );\n \n \n-        final RowKey targetRowKey =\n-                new RowKey( targetNodeId, type, edgeShardStrategy.getWriteShard( scope, targetNodeId, version, type ) );\n+        final RowKey targetRowKey = new RowKey( targetNodeId, type,\n+                edgeShardStrategy.getWriteShard( scope, targetNodeId, timestamp, type ) );\n \n         final RowKeyType targetRowKeyType = new RowKeyType( targetNodeId, type, sourceNodeId,\n-                edgeShardStrategy.getWriteShard( scope, targetNodeId, version, type, sourceNodeId.getType() ) );\n+                edgeShardStrategy.getWriteShard( scope, targetNodeId, timestamp, type, sourceNodeId.getType() ) );\n \n-        final DirectedEdge targetEdge = new DirectedEdge( sourceNodeId, version );\n+        final DirectedEdge targetEdge = new DirectedEdge( sourceNodeId, timestamp );\n \n \n         final EdgeRowKey edgeRowKey = new EdgeRowKey( sourceNodeId, type, targetNodeId, edgeShardStrategy\n-                .getWriteShard( scope, sourceNodeId, version, type, targetNodeId.getUuid().toString(),\n+                .getWriteShard( scope, sourceNodeId, timestamp, type, targetNodeId.getUuid().toString(),\n                         targetNodeId.getType() ) );\n \n \n@@ -319,9 +328,9 @@ private void doWrite( final ApplicationScope scope, final MarkedEdge edge, final\n \n \n         /**\n-         * Write this in the version log for this edge of source->target\n+         * Write this in the timestamp log for this edge of source->target\n          */\n-        op.writeVersion( graphEdgeVersionsCf, edgeRowKey, version );\n+        op.writeVersion( graphEdgeVersionsCf, edgeRowKey, timestamp );\n     }\n \n \n@@ -333,15 +342,15 @@ private void doWrite( final ApplicationScope scope, final MarkedEdge edge, final\n         final Id targetId = search.targetNode();\n         final Id sourceId = search.sourceNode();\n         final String type = search.getType();\n-        final UUID maxVersion = search.getMaxVersion();\n+        final long maxTimestamp = search.getMaxTimestamp();\n \n-        final EdgeSearcher<EdgeRowKey, UUID, MarkedEdge> searcher =\n-                new EdgeSearcher<EdgeRowKey, UUID, MarkedEdge>( scope, maxVersion, search.last(),\n-                        edgeShardStrategy.getReadShards( scope, sourceId, maxVersion, type ) ) {\n+        final EdgeSearcher<EdgeRowKey, Long, MarkedEdge> searcher =\n+                new EdgeSearcher<EdgeRowKey, Long, MarkedEdge>( scope, maxTimestamp, search.last(),\n+                        edgeShardStrategy.getReadShards( scope, sourceId, maxTimestamp, type ) ) {\n \n                     @Override\n-                    protected Serializer<UUID> getSerializer() {\n-                        return UUID_SERIALIZER;\n+                    protected Serializer<Long> getSerializer() {\n+                        return LONG_SERIALIZER;\n                     }\n \n \n@@ -355,7 +364,7 @@ public void setRange( final RangeBuilder builder ) {\n                         }\n \n                         //start seeking at a value < our max version\n-                        builder.setStart( maxVersion, UUID_SERIALIZER );\n+                        builder.setStart( maxTimestamp );\n                     }\n \n \n@@ -366,14 +375,14 @@ protected EdgeRowKey generateRowKey( long shard ) {\n \n \n                     @Override\n-                    protected UUID getStartColumn( final Edge last ) {\n-                        return last.getVersion();\n+                    protected Long getStartColumn( final Edge last ) {\n+                        return last.getTimestamp();\n                     }\n \n \n                     @Override\n-                    protected MarkedEdge createEdge( final UUID version, final boolean marked ) {\n-                        return new SimpleMarkedEdge( sourceId, type, targetId, version, marked );\n+                    protected MarkedEdge createEdge( final Long column, final boolean marked ) {\n+                        return new SimpleMarkedEdge( sourceId, type, targetId, column.longValue(), marked );\n                     }\n                 };\n \n@@ -389,11 +398,11 @@ protected MarkedEdge createEdge( final UUID version, final boolean marked ) {\n \n         final Id sourceId = edgeType.getNode();\n         final String type = edgeType.getType();\n-        final UUID maxVersion = edgeType.getMaxVersion();\n+        final long maxTimestamp = edgeType.getMaxTimestamp();\n \n         final EdgeSearcher<RowKey, DirectedEdge, MarkedEdge> searcher =\n-                new EdgeSearcher<RowKey, DirectedEdge, MarkedEdge>( scope, maxVersion, edgeType.last(),\n-                        edgeShardStrategy.getReadShards( scope, sourceId, maxVersion, type ) ) {\n+                new EdgeSearcher<RowKey, DirectedEdge, MarkedEdge>( scope, maxTimestamp, edgeType.last(),\n+                        edgeShardStrategy.getReadShards( scope, sourceId, maxTimestamp, type ) ) {\n \n \n                     @Override\n@@ -410,13 +419,13 @@ protected RowKey generateRowKey( long shard ) {\n \n                     @Override\n                     protected DirectedEdge getStartColumn( final Edge last ) {\n-                        return new DirectedEdge( last.getTargetNode(), last.getVersion() );\n+                        return new DirectedEdge( last.getTargetNode(), last.getTimestamp() );\n                     }\n \n \n                     @Override\n                     protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked ) {\n-                        return new SimpleMarkedEdge( sourceId, type, edge.id, edge.version, marked );\n+                        return new SimpleMarkedEdge( sourceId, type, edge.id, edge.timestamp, marked );\n                     }\n                 };\n \n@@ -434,11 +443,11 @@ protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked )\n         final Id targetId = edgeType.getNode();\n         final String type = edgeType.getType();\n         final String targetType = edgeType.getIdType();\n-        final UUID maxVersion = edgeType.getMaxVersion();\n+        final long maxTimestamp = edgeType.getMaxTimestamp();\n \n         final EdgeSearcher<RowKeyType, DirectedEdge, MarkedEdge> searcher =\n-                new EdgeSearcher<RowKeyType, DirectedEdge, MarkedEdge>( scope, maxVersion, edgeType.last(),\n-                        edgeShardStrategy.getReadShards( scope, targetId, maxVersion, type, targetType ) ) {\n+                new EdgeSearcher<RowKeyType, DirectedEdge, MarkedEdge>( scope, maxTimestamp, edgeType.last(),\n+                        edgeShardStrategy.getReadShards( scope, targetId, maxTimestamp, type, targetType ) ) {\n \n                     @Override\n                     protected Serializer<DirectedEdge> getSerializer() {\n@@ -454,13 +463,13 @@ protected RowKeyType generateRowKey( long shard ) {\n \n                     @Override\n                     protected DirectedEdge getStartColumn( final Edge last ) {\n-                        return new DirectedEdge( last.getTargetNode(), last.getVersion() );\n+                        return new DirectedEdge( last.getTargetNode(), last.getTimestamp() );\n                     }\n \n \n                     @Override\n                     protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked ) {\n-                        return new SimpleMarkedEdge( targetId, type, edge.id, edge.version, marked );\n+                        return new SimpleMarkedEdge( targetId, type, edge.id, edge.timestamp, marked );\n                     }\n                 };\n \n@@ -476,11 +485,11 @@ protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked )\n \n         final Id targetId = edgeType.getNode();\n         final String type = edgeType.getType();\n-        final UUID maxVersion = edgeType.getMaxVersion();\n+        final long maxTimestamp = edgeType.getMaxTimestamp();\n \n         final EdgeSearcher<RowKey, DirectedEdge, MarkedEdge> searcher =\n-                new EdgeSearcher<RowKey, DirectedEdge, MarkedEdge>( scope, maxVersion, edgeType.last(),\n-                        edgeShardStrategy.getReadShards( scope, targetId, maxVersion, type ) ) {\n+                new EdgeSearcher<RowKey, DirectedEdge, MarkedEdge>( scope, maxTimestamp, edgeType.last(),\n+                        edgeShardStrategy.getReadShards( scope, targetId, maxTimestamp, type ) ) {\n \n                     @Override\n                     protected Serializer<DirectedEdge> getSerializer() {\n@@ -496,13 +505,13 @@ protected RowKey generateRowKey( long shard ) {\n \n                     @Override\n                     protected DirectedEdge getStartColumn( final Edge last ) {\n-                        return new DirectedEdge( last.getSourceNode(), last.getVersion() );\n+                        return new DirectedEdge( last.getSourceNode(), last.getTimestamp() );\n                     }\n \n \n                     @Override\n                     protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked ) {\n-                        return new SimpleMarkedEdge( edge.id, type, targetId, edge.version, marked );\n+                        return new SimpleMarkedEdge( edge.id, type, targetId, edge.timestamp, marked );\n                     }\n                 };\n \n@@ -521,12 +530,12 @@ protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked )\n         final Id targetId = edgeType.getNode();\n         final String sourceType = edgeType.getIdType();\n         final String type = edgeType.getType();\n-        final UUID maxVersion = edgeType.getMaxVersion();\n+        final long maxTimestamp = edgeType.getMaxTimestamp();\n \n \n         final EdgeSearcher<RowKeyType, DirectedEdge, MarkedEdge> searcher =\n-                new EdgeSearcher<RowKeyType, DirectedEdge, MarkedEdge>( scope, maxVersion, edgeType.last(),\n-                        edgeShardStrategy.getReadShards( scope, targetId, maxVersion, type, sourceType ) ) {\n+                new EdgeSearcher<RowKeyType, DirectedEdge, MarkedEdge>( scope, maxTimestamp, edgeType.last(),\n+                        edgeShardStrategy.getReadShards( scope, targetId, maxTimestamp, type, sourceType ) ) {\n                     @Override\n                     protected Serializer<DirectedEdge> getSerializer() {\n                         return EDGE_SERIALIZER;\n@@ -541,13 +550,13 @@ protected RowKeyType generateRowKey( final long shard ) {\n \n                     @Override\n                     protected DirectedEdge getStartColumn( final Edge last ) {\n-                        return new DirectedEdge( last.getTargetNode(), last.getVersion() );\n+                        return new DirectedEdge( last.getTargetNode(), last.getTimestamp() );\n                     }\n \n \n                     @Override\n                     protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked ) {\n-                        return new SimpleMarkedEdge( edge.id, type, targetId, edge.version, marked );\n+                        return new SimpleMarkedEdge( edge.id, type, targetId, edge.timestamp, marked );\n                     }\n                 };\n \n@@ -557,21 +566,21 @@ protected MarkedEdge createEdge( final DirectedEdge edge, final boolean marked )\n \n     @Override\n     public Collection<MultiTennantColumnFamilyDefinition> getColumnFamilies() {\n-        return Arrays.asList( graphCf( sourceNodeEdgesCf ), graphCf( targetNodeEdgesCf ),\n-                graphCf( sourceNodeTargetTypeCf ), graphCf( targetNodeSourceTypeCf ),\n-                new MultiTennantColumnFamilyDefinition( graphEdgeVersionsCf, BytesType.class.getSimpleName(),\n-                        ColumnTypes.UUID_TYPE_REVERSED, BytesType.class.getSimpleName(),\n-                        MultiTennantColumnFamilyDefinition.CacheOption.KEYS ) );\n+        return Arrays\n+                .asList( graphCf( sourceNodeEdgesCf ), graphCf( targetNodeEdgesCf ), graphCf( sourceNodeTargetTypeCf ),\n+                        graphCf( targetNodeSourceTypeCf ),\n+                        new MultiTennantColumnFamilyDefinition( graphEdgeVersionsCf, BytesType.class.getSimpleName(),\n+                                ColumnTypes.LONG_TYPE_REVERSED, BytesType.class.getSimpleName(),\n+                                MultiTennantColumnFamilyDefinition.CacheOption.KEYS ) );\n     }\n \n \n     /**\n      * Helper to generate an edge definition by the type\n      */\n     private MultiTennantColumnFamilyDefinition graphCf( MultiTennantColumnFamily cf ) {\n-        return new MultiTennantColumnFamilyDefinition( cf, BytesType.class.getSimpleName(),\n-                ColumnTypes.DYNAMIC_COMPOSITE_TYPE, BytesType.class.getSimpleName(),\n-                MultiTennantColumnFamilyDefinition.CacheOption.KEYS );\n+        return new MultiTennantColumnFamilyDefinition( cf, BytesType.class.getSimpleName(), EDGE_DYNAMIC_COMPOSITE_TYPE,\n+                BytesType.class.getSimpleName(), MultiTennantColumnFamilyDefinition.CacheOption.KEYS );\n     }\n \n \n@@ -580,12 +589,12 @@ private MultiTennantColumnFamilyDefinition graphCf( MultiTennantColumnFamily cf\n      */\n     private static class DirectedEdge {\n \n-        public final UUID version;\n+        public final long timestamp;\n         public final Id id;\n \n \n-        private DirectedEdge( final Id id, final UUID version ) {\n-            this.version = version;\n+        private DirectedEdge( final Id id, final long timestamp ) {\n+            this.timestamp = timestamp;\n             this.id = id;\n         }\n     }\n@@ -597,16 +606,33 @@ private DirectedEdge( final Id id, final UUID version ) {\n      */\n     private static class EdgeSerializer extends AbstractSerializer<DirectedEdge> {\n \n-        private static final IdColDynamicCompositeSerializer ID_COL_SERIALIZER = IdColDynamicCompositeSerializer.get();\n-\n-        private static final UUIDSerializer UUID_SERIALIZER = UUIDSerializer.get();\n+                private static final IdColDynamicCompositeSerializer ID_COL_SERIALIZER =  IdColDynamicCompositeSerializer.get();\n+//        private static final UUIDSerializer UUID_SERIALIZER = UUIDSerializer.get();\n+//        private static final StringSerializer STRING_SERIALIZER = StringSerializer.get().getString(;\n+//        )\n \n \n         @Override\n         public ByteBuffer toByteBuffer( final DirectedEdge edge ) {\n-            final DynamicComposite colValue = createComposite( edge, AbstractComposite.ComponentEquality.EQUAL );\n \n-            return colValue.serialize();\n+            DynamicComposite composite = new DynamicComposite();\n+\n+//            //add our edge\n+//            composite.addComponent( edge.timestamp, LONG_SERIALIZER, LONG_TYPE_REVERSED,\n+//                    AbstractComposite.ComponentEquality.EQUAL );\n+\n+//            //we do this explicity instead of re-using the id composite serializer b/c we want high order\n+//            //time uuids first, not second. In this column family, there is no sort\n+//            composite.addComponent( edge.id.getUuid(), UUID_SERIALIZER, UUID_TYPE_REVERSED,\n+//                    AbstractComposite.ComponentEquality.EQUAL );\n+//\n+//            composite.addComponent( edge.id.getType(), STRING_SERIALIZER );\n+\n+            composite.addComponent( edge.timestamp, LONG_SERIALIZER );\n+\n+            ID_COL_SERIALIZER.toComposite( composite, edge.id);\n+\n+            return composite.serialize();\n         }\n \n \n@@ -618,31 +644,14 @@ public DirectedEdge fromByteBuffer( final ByteBuffer byteBuffer ) {\n \n \n             //return the version\n-            final UUID version = composite.get( 0, UUID_SERIALIZER );\n+            final long timestamp = composite.get( 0, LONG_SERIALIZER );\n \n \n             //parse our id\n             final Id id = ID_COL_SERIALIZER.fromComposite( composite, 1 );\n \n \n-            return new DirectedEdge( id, version );\n-        }\n-\n-\n-        /**\n-         * Create the dynamic composite for this directed edge\n-         */\n-        private DynamicComposite createComposite( DirectedEdge edge, AbstractComposite.ComponentEquality equality ) {\n-            DynamicComposite composite = new DynamicComposite();\n-\n-            //add our edge\n-            composite.addComponent( edge.version, UUID_SERIALIZER, ColumnTypes.UUID_TYPE_REVERSED, equality );\n-\n-\n-            ID_COL_SERIALIZER.toComposite( composite, edge.id );\n-\n-\n-            return composite;\n+            return new DirectedEdge( id, timestamp );\n         }\n     }\n \n@@ -740,15 +749,15 @@ private EdgeRowKey( final Id sourceId, final String edgeType, final Id targetId,\n             implements ColumnParser<C, T>, Iterator<ScopedRowKey<ApplicationScope, R>> {\n \n         protected final Optional<Edge> last;\n-        protected final UUID maxVersion;\n+        protected final long maxTimestamp;\n         protected final ApplicationScope scope;\n         protected final Iterator<Long> shards;\n \n \n-        protected EdgeSearcher( final ApplicationScope scope, final UUID maxVersion, final Optional<Edge> last,\n+        protected EdgeSearcher( final ApplicationScope scope, final long maxTimestamp, final Optional<Edge> last,\n                                 final Iterator<Long> shards ) {\n             this.scope = scope;\n-            this.maxVersion = maxVersion;\n+            this.maxTimestamp = maxTimestamp;\n             this.last = last;\n             this.shards = shards;\n         }\n@@ -952,8 +961,8 @@ void writeEdge( final MultiTennantColumnFamily<ApplicationScope, R, DirectedEdge\n         /**\n          * Write the edge into the version cf\n          */\n-        void writeVersion( final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, UUID> columnFamily,\n-                           EdgeRowKey rowKey, UUID version );\n+        void writeVersion( final MultiTennantColumnFamily<ApplicationScope, EdgeRowKey, Long> columnFamily,\n+                           EdgeRowKey rowKey, long timestamp );\n     }\n \n \n@@ -1039,8 +1048,7 @@ private void advanceRow() {\n                             .autoPaginate( true ).withColumnRange( rangeBuilder.build() );\n \n \n-            currentColumnIterator =\n-                    new ColumnNameIterator<C, T>( query, searcher, searcher.hasPage() );\n+            currentColumnIterator = new ColumnNameIterator<C, T>( query, searcher, searcher.hasPage() );\n         }\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/EdgeSerializationImpl.java",
                "sha": "b61616e85eec1ccae57f91f8eba4474e5f784d19",
                "status": "modified"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImpl.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 10,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImpl.java",
                "patch": "@@ -381,7 +381,7 @@ public int compare( final SourceAwareMarkedEdge o1, final SourceAwareMarkedEdge\n      * want descending ordering\n      */\n     public static int compareVersions( final MarkedEdge o1, final MarkedEdge o2 ) {\n-        return UUIDComparator.staticCompare( o1.getVersion(), o2.getVersion() );\n+        return Long.compare( o1.getTimestamp(), o2.getTimestamp() );\n     }\n \n \n@@ -437,7 +437,7 @@ public String toString() {\n         @Override\n         public EdgeKey call( final MarkedEdge markedEdge ) {\n             return new EdgeKey( markedEdge.getSourceNode(), markedEdge.getType(), markedEdge.getTargetNode(),\n-                    markedEdge.getVersion() );\n+                    markedEdge.getTimestamp() );\n         }\n     }\n \n@@ -449,14 +449,14 @@ public EdgeKey call( final MarkedEdge markedEdge ) {\n         private final Id sourceNode;\n         private final String type;\n         private final Id targetNode;\n-        private final UUID version;\n+        private final long timestamp;\n \n \n-        private EdgeKey( final Id sourceNode, final String type, final Id targetNode, final UUID version ) {\n+        private EdgeKey( final Id sourceNode, final String type, final Id targetNode, final long timestamp ) {\n             this.sourceNode = sourceNode;\n             this.type = type;\n             this.targetNode = targetNode;\n-            this.version = version;\n+            this.timestamp = timestamp;\n         }\n \n \n@@ -465,12 +465,15 @@ public boolean equals( final Object o ) {\n             if ( this == o ) {\n                 return true;\n             }\n-            if ( !( o instanceof EdgeKey ) ) {\n+            if ( o == null || getClass() != o.getClass() ) {\n                 return false;\n             }\n \n             final EdgeKey edgeKey = ( EdgeKey ) o;\n \n+            if ( timestamp != edgeKey.timestamp ) {\n+                return false;\n+            }\n             if ( !sourceNode.equals( edgeKey.sourceNode ) ) {\n                 return false;\n             }\n@@ -480,9 +483,6 @@ public boolean equals( final Object o ) {\n             if ( !type.equals( edgeKey.type ) ) {\n                 return false;\n             }\n-            if ( !version.equals( edgeKey.version ) ) {\n-                return false;\n-            }\n \n             return true;\n         }\n@@ -493,8 +493,9 @@ public int hashCode() {\n             int result = sourceNode.hashCode();\n             result = 31 * result + type.hashCode();\n             result = 31 * result + targetNode.hashCode();\n-            result = 31 * result + version.hashCode();\n+            result = 31 * result + ( int ) ( timestamp ^ ( timestamp >>> 32 ) );\n             return result;\n         }\n     }\n+\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImpl.java",
                "sha": "e578b083fef4cbc1a12b35ea3d77eab704698aa9",
                "status": "modified"
            },
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/NodeSerializationImpl.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/NodeSerializationImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 13,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/NodeSerializationImpl.java",
                "patch": "@@ -26,7 +26,6 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.UUID;\n \n import javax.inject.Inject;\n \n@@ -44,6 +43,7 @@\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.core.astyanax.CassandraConfig;\n import org.apache.usergrid.persistence.graph.serialization.NodeSerialization;\n+import org.apache.usergrid.persistence.graph.serialization.util.EdgeUtils;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.common.base.Optional;\n@@ -112,37 +112,37 @@ public NodeSerializationImpl( final Keyspace keyspace, final CassandraConfig fig\n \n \n     @Override\n-    public MutationBatch mark( final ApplicationScope scope, final Id node, final UUID version ) {\n+    public MutationBatch mark( final ApplicationScope scope, final Id node, final long timestamp ) {\n         ValidationUtils.validateApplicationScope( scope );\n         ValidationUtils.verifyIdentity( node );\n-        ValidationUtils.verifyTimeUuid( version, \"version\" );\n+        EdgeUtils.validateTimestamp(timestamp, \"timestamp\");\n \n         MutationBatch batch = keyspace.prepareMutationBatch().withConsistencyLevel( fig.getWriteCL() );\n \n-        batch.withRow( GRAPH_DELETE, ScopedRowKey.fromKey( scope, node ) ).setTimestamp( version.timestamp() )\n-             .putColumn( COLUMN_NAME, version );\n+        batch.withRow( GRAPH_DELETE, ScopedRowKey.fromKey( scope, node ) ).setTimestamp(timestamp )\n+             .putColumn( COLUMN_NAME, timestamp );\n \n         return batch;\n     }\n \n \n     @Override\n-    public MutationBatch delete( final ApplicationScope scope, final Id node, final UUID version ) {\n+    public MutationBatch delete( final ApplicationScope scope, final Id node, final long timestamp ) {\n         ValidationUtils.validateApplicationScope( scope );\n         ValidationUtils.verifyIdentity( node );\n-        ValidationUtils.verifyTimeUuid( version, \"version\" );\n+        EdgeUtils.validateTimestamp( timestamp, \"timestamp\" );\n \n         MutationBatch batch = keyspace.prepareMutationBatch().withConsistencyLevel( fig.getWriteCL() );\n \n-        batch.withRow( GRAPH_DELETE, ScopedRowKey.fromKey( scope, node ) ).setTimestamp( version.timestamp() )\n+        batch.withRow( GRAPH_DELETE, ScopedRowKey.fromKey( scope, node ) ).setTimestamp( timestamp )\n              .deleteColumn( COLUMN_NAME );\n \n         return batch;\n     }\n \n \n     @Override\n-    public Optional<UUID> getMaxVersion( final ApplicationScope scope, final Id node ) {\n+    public Optional<Long> getMaxVersion( final ApplicationScope scope, final Id node ) {\n         ValidationUtils.validateApplicationScope( scope );\n         ValidationUtils.verifyIdentity( node );\n \n@@ -154,7 +154,7 @@ public MutationBatch delete( final ApplicationScope scope, final Id node, final\n             Column<Boolean> result =\n                     query.getKey( ScopedRowKey.fromKey( scope, node ) ).getColumn( COLUMN_NAME ).execute().getResult();\n \n-            return Optional.of( result.getUUIDValue() );\n+            return Optional.of( result.getLongValue() );\n         }\n         catch ( NotFoundException e ) {\n             //swallow, there's just no column\n@@ -167,7 +167,7 @@ public MutationBatch delete( final ApplicationScope scope, final Id node, final\n \n \n     @Override\n-    public Map<Id, UUID> getMaxVersions( final ApplicationScope scope, final Collection<? extends Edge> nodeIds ) {\n+    public Map<Id, Long> getMaxVersions( final ApplicationScope scope, final Collection<? extends Edge> nodeIds ) {\n         ValidationUtils.validateApplicationScope( scope );\n         Preconditions.checkNotNull( nodeIds, \"nodeIds cannot be null\" );\n \n@@ -178,7 +178,7 @@ public MutationBatch delete( final ApplicationScope scope, final Id node, final\n         final List<ScopedRowKey<ApplicationScope, Id>> keys = new ArrayList<ScopedRowKey<ApplicationScope, Id>>(nodeIds.size());\n \n         //worst case all are marked\n-        final Map<Id, UUID> versions = new HashMap<Id, UUID>(nodeIds.size());\n+        final Map<Id, Long> versions = new HashMap<>(nodeIds.size());\n \n         for(final Edge edge: nodeIds){\n             keys.add( ScopedRowKey.fromKey( scope, edge.getSourceNode() ) );\n@@ -193,7 +193,7 @@ public MutationBatch delete( final ApplicationScope scope, final Id node, final\n                 Column<Boolean> column = row.getColumns().getColumnByName( COLUMN_NAME );\n \n                 if(column != null){\n-                    versions.put( row.getKey().getKey(), column.getUUIDValue() );\n+                    versions.put( row.getKey().getKey(), column.getLongValue() );\n                 }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/NodeSerializationImpl.java",
                "sha": "2acc5a834e710440cb765545d7219b5deea7fc4e",
                "status": "modified"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/EdgeShardStrategy.java",
                "changes": 21,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/EdgeShardStrategy.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 6,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/EdgeShardStrategy.java",
                "patch": "@@ -31,23 +31,32 @@\n \n     /**\n      * Get the shard key used for writing this shard.  CUD operations should use this\n+     *\n+     * @param scope The application's scope\n+     * @param rowKeyId The id being used in the row key\n+     * @param timestamp The timestamp on the edge\n+     * @param types The types in the edge\n      */\n-    public long getWriteShard(final ApplicationScope scope, final Id rowKeyId, final  UUID version, final String... types );\n+    public long getWriteShard(final ApplicationScope scope, final Id rowKeyId, final  long timestamp, final String... types );\n \n \n     /**\n      * Get the iterator of all shards for this entity\n+     *\n+     * @param scope The application scope\n+     * @param rowKeyId The id used in the row key\n+     * @param maxTimestamp The max timestamp to use\n+     * @param types the types in the edge\n      */\n-    public Iterator<Long> getReadShards(final ApplicationScope scope,final  Id rowKeyId, final UUID maxVersion,final  String... types );\n+    public Iterator<Long> getReadShards(final ApplicationScope scope,final  Id rowKeyId, final long maxTimestamp,final  String... types );\n \n     /**\n      * Increment our count meta data by the passed value.  Can be a positive or a negative number.\n-     * @param batch The batch to add the count to\n-     * @param scope\n-     * @param rowKeyId\n+     * @param scope The scope in the application\n+     * @param rowKeyId The row key id\n      * @param shardId The shard id to use\n      * @param count The amount to increment or decrement\n-     * @param types\n+     * @param types The types\n      * @return\n      */\n     public void increment(final ApplicationScope scope,final  Id rowKeyId, long shardId, long count ,final  String... types );",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/EdgeShardStrategy.java",
                "sha": "09436acc363a62e110574bec909d3fdb6045b9f1",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCache.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCache.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 4,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCache.java",
                "patch": "@@ -37,20 +37,20 @@\n     /**\n      * Get the time meta data for the given node\n      * @param nodeId\n-     * @param version The time to select the slice for.\n+     * @param timestamp The time to select the slice for.\n      * @param edgeType\n      */\n-    public long getSlice(final ApplicationScope scope, final Id nodeId, final UUID version, final String... edgeType);\n+    public long getSlice(final ApplicationScope scope, final Id nodeId, final long timestamp, final String... edgeType);\n \n     /**\n      * Get an iterator of all versions <= the version\n      * @param scope\n      * @param nodeId\n-     * @param maxVersion\n+     * @param maxTimestamp The highest timestamp\n      * @param edgeType\n      * @return\n      */\n-    public Iterator<Long> getVersions(final ApplicationScope scope, final Id nodeId, final UUID maxVersion, final String... edgeType);\n+    public Iterator<Long> getVersions(final ApplicationScope scope, final Id nodeId, final long  maxTimestamp, final String... edgeType);\n \n \n     /**",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCache.java",
                "sha": "7845ab08c0584047e3099d2757dd01a0892ee87a",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardApproximationImpl.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardApproximationImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 21,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardApproximationImpl.java",
                "patch": "@@ -37,38 +37,20 @@\n \n \n /**\n- * Implementation for doing approximation.  Uses hy perlog log.\n+ * Implementation for doing edge approximation based on counters.  Uses a guava loading cache to load values from\n+ * cassandra, and flush them on cache eviction.\n  *\n- *\n- * http://blog.aggregateknowledge.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/\n- *\n- * See also\n- *\n- * http://blog.aggregateknowledge.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/\n- *\n- * See also\n- *\n- * https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/stream/cardinality\n- * /HyperLogLog.java\n  */\n-\n-\n public class NodeShardApproximationImpl implements NodeShardApproximation {\n \n-    private final GraphFig graphFig;\n-\n-    //TODO, replace with with our counters. This is just a POC for now.  HyperLogLog appears to use too much ram, waiting\n-    //to hear back on http://dsiutils.di.unimi.it/#install\n-    //for our use case\n-    private final LoadingCache<ShardKey, AtomicLong> graphLogs;\n+       private final LoadingCache<ShardKey, AtomicLong> graphLogs;\n \n \n     /**\n      * Create a time shard approximation with the correct configuration.\n      */\n     @Inject\n     public NodeShardApproximationImpl( final GraphFig graphFig) {\n-        this.graphFig = graphFig;\n \n         graphLogs = CacheBuilder.newBuilder()\n                .maximumSize( graphFig.getShardCacheSize() )",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardApproximationImpl.java",
                "sha": "54d8c3c80bf20190e6debef7275db6c5d87d4d3b",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardCacheImpl.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardCacheImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 4,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardCacheImpl.java",
                "patch": "@@ -96,7 +96,7 @@ public void propertyChange( final PropertyChangeEvent evt ) {\n \n \n     @Override\n-    public long getSlice( final ApplicationScope scope, final Id nodeId, final UUID time, final String... edgeType ) {\n+    public long getSlice( final ApplicationScope scope, final Id nodeId, final long timestamp, final String... edgeType ) {\n \n \n         final CacheKey key = new CacheKey( scope, nodeId, edgeType );\n@@ -109,7 +109,7 @@ public long getSlice( final ApplicationScope scope, final Id nodeId, final UUID\n             throw new RuntimeException( \"Unable to load shard key for graph\", e );\n         }\n \n-        final Long shardId = entry.getShardId( time.timestamp() );\n+        final Long shardId = entry.getShardId( timestamp );\n \n         if ( shardId != null ) {\n             return shardId;\n@@ -121,7 +121,7 @@ public long getSlice( final ApplicationScope scope, final Id nodeId, final UUID\n \n \n     @Override\n-    public Iterator<Long> getVersions( final ApplicationScope scope, final Id nodeId, final UUID maxVersion,\n+    public Iterator<Long> getVersions( final ApplicationScope scope, final Id nodeId, final long maxTimestamp,\n                                        final String... edgeType ) {\n         final CacheKey key = new CacheKey( scope, nodeId, edgeType );\n               CacheEntry entry;\n@@ -133,7 +133,7 @@ public long getSlice( final ApplicationScope scope, final Id nodeId, final UUID\n                   throw new RuntimeException( \"Unable to load shard key for graph\", e );\n               }\n \n-        Iterator<Long> iterator = entry.getShards( maxVersion.timestamp() );\n+        Iterator<Long> iterator = entry.getShards( maxTimestamp );\n \n         if(iterator == null){\n             return Collections.<Long>emptyList().iterator();",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/NodeShardCacheImpl.java",
                "sha": "c11da7b85f09649ba03a94d9e38cd761d1850397",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/SizebasedEdgeShardStrategy.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/SizebasedEdgeShardStrategy.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 4,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/SizebasedEdgeShardStrategy.java",
                "patch": "@@ -48,16 +48,16 @@\n \n \n     @Override\n-    public long getWriteShard( final ApplicationScope scope, final Id rowKeyId, final UUID version,\n+    public long getWriteShard( final ApplicationScope scope, final Id rowKeyId, final long timestamp,\n                                final String... types ) {\n-        return shardCache.getSlice( scope, rowKeyId, version, types );\n+        return shardCache.getSlice( scope, rowKeyId, timestamp, types );\n     }\n \n \n     @Override\n-    public Iterator<Long> getReadShards( final ApplicationScope scope, final Id rowKeyId, final UUID maxVersion,\n+    public Iterator<Long> getReadShards( final ApplicationScope scope, final Id rowKeyId, final long maxTimestamp,\n                                          final String... types ) {\n-        return shardCache.getVersions( scope, rowKeyId, maxVersion, types );\n+        return shardCache.getVersions( scope, rowKeyId, maxTimestamp, types );\n     }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/SizebasedEdgeShardStrategy.java",
                "sha": "c1dd2dcfa7812e54e623fa930bfbfdb89fe69327",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/TimebasedEdgeShardStrategy.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/TimebasedEdgeShardStrategy.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 2,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/TimebasedEdgeShardStrategy.java",
                "patch": "@@ -44,14 +44,14 @@\n \n \n     @Override\n-    public long getWriteShard( final ApplicationScope scope, final Id rowKeyId, final UUID version,\n+    public long getWriteShard( final ApplicationScope scope, final Id rowKeyId, final long timestamp,\n                                final String... types ) {\n         return 0;  //To change body of implemented methods use File | Settings | File Templates.\n     }\n \n \n     @Override\n-    public Iterator<Long> getReadShards( final ApplicationScope scope, final Id rowKeyId, final UUID maxVersion,\n+    public Iterator<Long> getReadShards( final ApplicationScope scope, final Id rowKeyId, final long maxTimestamp,\n                                          final String... types ) {\n         return Collections.singleton(0l).iterator();\n     }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/impl/TimebasedEdgeShardStrategy.java",
                "sha": "396410eec9446b5f98ccb72ab51de7c40072da3e",
                "status": "modified"
            },
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/util/EdgeUtils.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/util/EdgeUtils.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 3,
                "filename": "stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/util/EdgeUtils.java",
                "patch": "@@ -47,10 +47,20 @@ public static void validateEdge( Edge e ) {\n         ValidationUtils.verifyIdentity( e.getSourceNode() );\n         ValidationUtils.verifyIdentity( e.getTargetNode() );\n         ValidationUtils.verifyString( e.getType(), \"type\" );\n-        ValidationUtils.verifyTimeUuid( e.getVersion(), \"version\" );\n+        validateTimestamp( e.getTimestamp(), \"timestamp\" );\n+\n     }\n \n \n+    /**\n+     * Validate the timestamp is set\n+     * @param value\n+     * @param fieldName\n+     */\n+    public static void validateTimestamp(final long value, final String fieldName){\n+        Preconditions.checkArgument( value > -1, fieldName );\n+    }\n+\n     /**\n      * Validate the search edge\n      */\n@@ -80,7 +90,7 @@ public static void validateSearchByEdgeType( final SearchByEdgeType search ) {\n \n         ValidationUtils.verifyIdentity( search.getNode() );\n         ValidationUtils.verifyString( search.getType(), \"type\" );\n-        ValidationUtils.verifyTimeUuid( search.getMaxVersion(), \"maxVersion\" );\n+        validateTimestamp( search.getMaxTimestamp(), \"maxTimestamp\" );\n \n         //only validate if the value is present\n         if(search.last().isPresent()){\n@@ -98,7 +108,7 @@ public static void validateSearchByEdge( final SearchByEdge search ) {\n            ValidationUtils.verifyIdentity( search.sourceNode() );\n            ValidationUtils.verifyIdentity( search.targetNode() );\n            ValidationUtils.verifyString( search.getType(), \"type\" );\n-           ValidationUtils.verifyTimeUuid( search.getMaxVersion(), \"maxVersion\" );\n+           validateTimestamp( search.getMaxTimestamp(), \"maxTimestamp\" );\n \n            //only validate if the value is present\n            if(search.last().isPresent()){",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/main/java/org/apache/usergrid/persistence/graph/serialization/util/EdgeUtils.java",
                "sha": "b1919572c969fbc0f1f8a992d0ce0e3edad25f3f",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/ComittedGraphManagerIT.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/ComittedGraphManagerIT.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 2,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/ComittedGraphManagerIT.java",
                "patch": "@@ -75,8 +75,8 @@ public ComittedGraphTestHelper( final GraphManager graphManager ) {\n \n \n         @Override\n-        public Observable<Id> deleteNode( final Id node ) {\n-            return graphManager.deleteNode( node );\n+        public Observable<Id> deleteNode( final Id node, final long timestamp) {\n+            return graphManager.deleteNode( node, timestamp );\n         }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/ComittedGraphManagerIT.java",
                "sha": "596480d2805620c8a9a872d782d56f9ae9f4591d",
                "status": "modified"
            },
            {
                "additions": 75,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerIT.java",
                "changes": 204,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerIT.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 129,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerIT.java",
                "patch": "@@ -104,7 +104,7 @@ public void testWriteReadEdgeTypeSource() throws TimeoutException, InterruptedEx\n \n         //now test retrieving it\n \n-        SearchByEdgeType search = createSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getVersion(), null );\n+        SearchByEdgeType search = createSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesFromSource( search );\n \n@@ -114,7 +114,7 @@ public void testWriteReadEdgeTypeSource() throws TimeoutException, InterruptedEx\n         assertEquals( \"Correct edge returned\", edge, returned );\n \n         //change edge type to be invalid, shouldn't get a result\n-        search = createSearchByEdge( edge.getSourceNode(), edge.getType() + \"invalid\", edge.getVersion(), null );\n+        search = createSearchByEdge( edge.getSourceNode(), edge.getType() + \"invalid\", edge.getTimestamp(), null );\n \n         edges = gm.loadEdgesFromSource( search );\n \n@@ -136,7 +136,7 @@ public void testWriteReadEdgeTypeTarget() throws TimeoutException, InterruptedEx\n \n         //now test retrieving it\n \n-        SearchByEdgeType search = createSearchByEdge( edge.getTargetNode(), edge.getType(), edge.getVersion(), null );\n+        SearchByEdgeType search = createSearchByEdge( edge.getTargetNode(), edge.getType(), edge.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesToTarget( search );\n \n@@ -146,7 +146,7 @@ public void testWriteReadEdgeTypeTarget() throws TimeoutException, InterruptedEx\n         assertEquals( \"Correct edge returned\", edge, returned );\n \n         //change edge type to be invalid, shouldn't get a result\n-        search = createSearchByEdge( edge.getTargetNode(), edge.getType() + \"invalid\", edge.getVersion(), null );\n+        search = createSearchByEdge( edge.getTargetNode(), edge.getType() + \"invalid\", edge.getTimestamp(), null );\n \n         edges = gm.loadEdgesToTarget( search );\n \n@@ -162,15 +162,15 @@ public void testWriteReadEdgeTypeVersionSource() throws TimeoutException, Interr\n \n         GraphManager gm = getHelper( emf.createEdgeManager( scope ) );\n \n-        final UUID earlyVersion = UUIDGenerator.newTimeUUID();\n+        final long earlyVersion = 1000l;\n \n-        Edge edge = createEdge( \"source\", \"test\", \"target\" );\n+        Edge edge = createEdge( \"source\", \"test\", \"target\", earlyVersion);\n \n         gm.writeEdge( edge ).toBlockingObservable().last();\n \n         //now test retrieving it\n \n-        SearchByEdgeType search = createSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getVersion(), null );\n+        SearchByEdgeType search = createSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesFromSource( search );\n \n@@ -180,7 +180,7 @@ public void testWriteReadEdgeTypeVersionSource() throws TimeoutException, Interr\n         assertEquals( \"Correct edge returned\", edge, returned );\n \n         //now test with an earlier version, we shouldn't get the edge back\n-        search = createSearchByEdge( edge.getSourceNode(), edge.getType(), earlyVersion, null );\n+        search = createSearchByEdge( edge.getSourceNode(), edge.getType(), earlyVersion-1, null );\n \n         edges = gm.loadEdgesFromSource( search );\n \n@@ -196,16 +196,16 @@ public void testWriteReadEdgeTypeVersionTarget() throws TimeoutException, Interr\n \n         GraphManager gm = getHelper( emf.createEdgeManager( scope ) );\n \n-        final UUID earlyVersion = UUIDGenerator.newTimeUUID();\n+        final long earlyVersion = 10000l;\n \n \n-        Edge edge = createEdge( \"source\", \"test\", \"target\" );\n+        Edge edge = createEdge( \"source\", \"test\", \"target\", earlyVersion);\n \n         gm.writeEdge( edge ).toBlockingObservable().last();\n \n         //now test retrieving it\n \n-        SearchByEdgeType search = createSearchByEdge( edge.getTargetNode(), edge.getType(), edge.getVersion(), null );\n+        SearchByEdgeType search = createSearchByEdge( edge.getTargetNode(), edge.getType(), edge.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesToTarget( search );\n \n@@ -215,7 +215,7 @@ public void testWriteReadEdgeTypeVersionTarget() throws TimeoutException, Interr\n         assertEquals( \"Correct edge returned\", edge, returned );\n \n         //change edge type to be invalid, shouldn't get a result\n-        search = createSearchByEdge( edge.getTargetNode(), edge.getType(), earlyVersion, null );\n+        search = createSearchByEdge( edge.getTargetNode(), edge.getType(), earlyVersion-1, null );\n \n         edges = gm.loadEdgesToTarget( search );\n \n@@ -234,30 +234,30 @@ public void testWriteReadEdgeTypeVersionSourceDistinct() throws TimeoutException\n \n         GraphManager gm = getHelper( emf.createEdgeManager( scope ) );\n \n-        final UUID earlyVersion = UUIDGenerator.newTimeUUID();\n+        final long earlyVersion = 10000l;\n \n \n-        Edge edge1 = createEdge( \"source\", \"test\", \"target\" );\n+        Edge edge1 = createEdge( \"source\", \"test\", \"target\", earlyVersion + 1 );\n \n         final Id sourceId = edge1.getSourceNode();\n         final Id targetId = edge1.getTargetNode();\n \n \n         gm.writeEdge( edge1 ).toBlockingObservable().last();\n \n-        Edge edge2 = createEdge( sourceId, edge1.getType(), targetId );\n+        Edge edge2 = createEdge( sourceId, edge1.getType(), targetId, earlyVersion + 2 );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().last();\n \n-        Edge edge3 = createEdge( sourceId, edge1.getType(), targetId );\n+        Edge edge3 = createEdge( sourceId, edge1.getType(), targetId, earlyVersion + 3 );\n \n         gm.writeEdge( edge3 ).toBlockingObservable().last();\n \n \n         //now test retrieving it, we should only get edge3, since it's the latest\n \n         SearchByEdgeType search =\n-                createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge3.getVersion(), null );\n+                createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge3.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesFromSource( search );\n \n@@ -270,7 +270,7 @@ public void testWriteReadEdgeTypeVersionSourceDistinct() throws TimeoutException\n         assertFalse( \"No more edges\", returned.hasNext() );\n \n         //now test with an earlier version, we shouldn't get the edge back\n-        search = createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge2.getVersion(), null );\n+        search = createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge2.getTimestamp(), null );\n \n         edges = gm.loadEdgesFromSource( search );\n \n@@ -280,7 +280,7 @@ public void testWriteReadEdgeTypeVersionSourceDistinct() throws TimeoutException\n         assertEquals( \"Correct edge returned\", edge1, returned.next() );\n         assertFalse( \"No more edges\", returned.hasNext() );\n \n-        search = createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge1.getVersion(), null );\n+        search = createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge1.getTimestamp(), null );\n \n         edges = gm.loadEdgesFromSource( search );\n \n@@ -305,33 +305,33 @@ public void testWriteReadEdgeTypeVersionTargetDistinct() throws TimeoutException\n \n \n         GraphManager gm = getHelper( emf.createEdgeManager( scope ) );\n-        ;\n \n \n-        final UUID earlyVersion = UUIDGenerator.newTimeUUID();\n+\n+        final long earlyVersion = 10000l;\n \n \n-        Edge edge1 = createEdge( \"source\", \"test\", \"target\" );\n+        Edge edge1 = createEdge( \"source\", \"test\", \"target\", earlyVersion+1 );\n \n         final Id sourceId = edge1.getSourceNode();\n         final Id targetId = edge1.getTargetNode();\n \n \n         gm.writeEdge( edge1 ).toBlockingObservable().last();\n \n-        Edge edge2 = createEdge( sourceId, edge1.getType(), targetId );\n+        Edge edge2 = createEdge( sourceId, edge1.getType(), targetId, earlyVersion+2 );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().last();\n \n-        Edge edge3 = createEdge( sourceId, edge1.getType(), targetId );\n+        Edge edge3 = createEdge( sourceId, edge1.getType(), targetId, earlyVersion +3 );\n \n         gm.writeEdge( edge3 ).toBlockingObservable().last();\n \n \n         //now test retrieving it, we should only get edge3, since it's the latest\n \n         SearchByEdgeType search =\n-                createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge3.getVersion(), null );\n+                createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge3.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesToTarget( search );\n \n@@ -344,7 +344,7 @@ public void testWriteReadEdgeTypeVersionTargetDistinct() throws TimeoutException\n         assertFalse( \"No more edges\", returned.hasNext() );\n \n         //now test with an earlier version, we shouldn't get the edge back\n-        search = createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge2.getVersion(), null );\n+        search = createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge2.getTimestamp(), null );\n \n         edges = gm.loadEdgesToTarget( search );\n \n@@ -354,7 +354,7 @@ public void testWriteReadEdgeTypeVersionTargetDistinct() throws TimeoutException\n         assertEquals( \"Correct edge returned\", edge1, returned.next() );\n         assertFalse( \"No more edges\", returned.hasNext() );\n \n-        search = createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge1.getVersion(), null );\n+        search = createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge1.getTimestamp(), null );\n \n         edges = gm.loadEdgesToTarget( search );\n \n@@ -397,7 +397,7 @@ public void testWriteReadEdgeTypePagingSource() throws TimeoutException, Interru\n         //now test retrieving it\n \n         SearchByEdgeType search =\n-                createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge3.getVersion(), null );\n+                createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge3.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesFromSource( search );\n \n@@ -415,7 +415,7 @@ public void testWriteReadEdgeTypePagingSource() throws TimeoutException, Interru\n         assertFalse( \"No more edges\", returned.hasNext() );\n \n         //still edge 3 is our max version, but we start with edge 2 as our last read\n-        search = createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge3.getVersion(), edge2 );\n+        search = createSearchByEdge( edge1.getSourceNode(), edge1.getType(), edge3.getTimestamp(), edge2 );\n \n         edges = gm.loadEdgesFromSource( search );\n \n@@ -453,7 +453,7 @@ public void testWriteReadEdgeTypePagingTarget() {\n         //now test retrieving it\n \n         SearchByEdgeType search =\n-                createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge3.getVersion(), null );\n+                createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge3.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesToTarget( search );\n \n@@ -471,7 +471,7 @@ public void testWriteReadEdgeTypePagingTarget() {\n \n         assertFalse( \"No more edges\", returned.hasNext() );\n \n-        search = createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge3.getVersion(), edge2 );\n+        search = createSearchByEdge( edge1.getTargetNode(), edge1.getType(), edge3.getTimestamp(), edge2 );\n \n         edges = gm.loadEdgesToTarget( search );\n \n@@ -496,7 +496,7 @@ public void testWriteReadEdgeTypeTargetTypeSource() {\n \n         //now test retrieving it\n \n-        SearchByIdType search = createSearchByEdgeAndId( edge.getSourceNode(), edge.getType(), edge.getVersion(),\n+        SearchByIdType search = createSearchByEdgeAndId( edge.getSourceNode(), edge.getType(), edge.getTimestamp(),\n                 edge.getTargetNode().getType(), null );\n \n         Observable<Edge> edges = gm.loadEdgesFromSourceByType( search );\n@@ -508,7 +508,7 @@ public void testWriteReadEdgeTypeTargetTypeSource() {\n \n \n         //change edge type to be invalid, shouldn't get a result\n-        search = createSearchByEdgeAndId( edge.getSourceNode(), edge.getType(), edge.getVersion(),\n+        search = createSearchByEdgeAndId( edge.getSourceNode(), edge.getType(), edge.getTimestamp(),\n                 edge.getTargetNode().getType() + \"invalid\", null );\n \n         edges = gm.loadEdgesFromSourceByType( search );\n@@ -533,7 +533,7 @@ public void testWriteReadEdgeTypeTargetTypeTarget() {\n \n         //now test retrieving it\n \n-        SearchByIdType search = createSearchByEdgeAndId( edge.getTargetNode(), edge.getType(), edge.getVersion(),\n+        SearchByIdType search = createSearchByEdgeAndId( edge.getTargetNode(), edge.getType(), edge.getTimestamp(),\n                 edge.getSourceNode().getType(), null );\n \n         Observable<Edge> edges = gm.loadEdgesToTargetByType( search );\n@@ -545,7 +545,7 @@ public void testWriteReadEdgeTypeTargetTypeTarget() {\n \n \n         //change edge type to be invalid, shouldn't get a result\n-        search = createSearchByEdgeAndId( edge.getTargetNode(), edge.getType(), edge.getVersion(),\n+        search = createSearchByEdgeAndId( edge.getTargetNode(), edge.getType(), edge.getTimestamp(),\n                 edge.getSourceNode().getType() + \"invalid\", null );\n \n         edges = gm.loadEdgesToTargetByType( search );\n@@ -570,7 +570,7 @@ public void testWriteReadEdgeDeleteSource() {\n         //now test retrieving it\n \n \n-        SearchByEdgeType search = createSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getVersion(), null );\n+        SearchByEdgeType search = createSearchByEdge( edge.getSourceNode(), edge.getType(), edge.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesFromSource( search );\n \n@@ -579,7 +579,7 @@ public void testWriteReadEdgeDeleteSource() {\n \n         assertEquals( \"Correct edge returned\", edge, returned );\n \n-        SearchByIdType searchById = createSearchByEdgeAndId( edge.getSourceNode(), edge.getType(), edge.getVersion(),\n+        SearchByIdType searchById = createSearchByEdgeAndId( edge.getSourceNode(), edge.getType(), edge.getTimestamp(),\n                 edge.getTargetNode().getType(), null );\n \n         edges = gm.loadEdgesFromSourceByType( searchById );\n@@ -590,7 +590,7 @@ public void testWriteReadEdgeDeleteSource() {\n         assertEquals( \"Correct edge returned\", edge, returned );\n \n         final SearchByEdge searchByEdge =\n-                createGetByEdge( edge.getSourceNode(), edge.getType(), edge.getTargetNode(), edge.getVersion(), null );\n+                createGetByEdge( edge.getSourceNode(), edge.getType(), edge.getTargetNode(), edge.getTimestamp(), null );\n \n         returned = gm.loadEdgeVersions( searchByEdge ).toBlockingObservable().single();\n \n@@ -640,7 +640,7 @@ public void testWriteReadEdgeDeleteTarget() {\n         //now test retrieving it\n \n \n-        SearchByEdgeType search = createSearchByEdge( edge.getTargetNode(), edge.getType(), edge.getVersion(), null );\n+        SearchByEdgeType search = createSearchByEdge( edge.getTargetNode(), edge.getType(), edge.getTimestamp(), null );\n \n         Observable<Edge> edges = gm.loadEdgesToTarget( search );\n \n@@ -649,7 +649,7 @@ public void testWriteReadEdgeDeleteTarget() {\n \n         assertEquals( \"Correct edge returned\", edge, returned );\n \n-        SearchByIdType searchById = createSearchByEdgeAndId( edge.getTargetNode(), edge.getType(), edge.getVersion(),\n+        SearchByIdType searchById = createSearchByEdgeAndId( edge.getTargetNode(), edge.getType(), edge.getTimestamp(),\n                 edge.getSourceNode().getType(), null );\n \n         edges = gm.loadEdgesToTargetByType( searchById );\n@@ -692,16 +692,16 @@ public void testWriteReadEdgeTypesSourceTypes() {\n         Id targetId1 = new SimpleId( \"target\" );\n         Id targetId2 = new SimpleId( \"target2\" );\n \n-        Edge testTargetEdge = createEdge( sourceId, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge testTargetEdge = createEdge( sourceId, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( testTargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge testTarget2Edge = createEdge( sourceId, \"test\", targetId2, UUIDGenerator.newTimeUUID() );\n+        Edge testTarget2Edge = createEdge( sourceId, \"test\", targetId2, System.currentTimeMillis() );\n \n         gm.writeEdge( testTarget2Edge ).toBlockingObservable().singleOrDefault( null );\n \n \n-        Edge test2TargetEdge = createEdge( sourceId, \"test2\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge test2TargetEdge = createEdge( sourceId, \"test2\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( test2TargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n@@ -755,16 +755,16 @@ public void testWriteReadEdgeTypesTargetTypes() {\n         Id targetId1 = new SimpleId( \"target\" );\n \n \n-        Edge testTargetEdge = createEdge( sourceId1, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge testTargetEdge = createEdge( sourceId1, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( testTargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge testTarget2Edge = createEdge( sourceId2, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge testTarget2Edge = createEdge( sourceId2, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( testTarget2Edge ).toBlockingObservable().singleOrDefault( null );\n \n \n-        Edge test2TargetEdge = createEdge( sourceId1, \"test2\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge test2TargetEdge = createEdge( sourceId1, \"test2\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( test2TargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n@@ -820,17 +820,17 @@ public void testWriteReadEdgeTypesSourceTypesPaging() {\n         Id targetId2 = new SimpleId( \"target2\" );\n \n \n-        Edge testTargetEdge = createEdge( sourceId1, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge testTargetEdge = createEdge( sourceId1, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( testTargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n \n-        Edge testTargetEdge2 = createEdge( sourceId1, \"test\", targetId2, UUIDGenerator.newTimeUUID() );\n+        Edge testTargetEdge2 = createEdge( sourceId1, \"test\", targetId2, System.currentTimeMillis() );\n \n         gm.writeEdge( testTargetEdge2 ).toBlockingObservable().singleOrDefault( null );\n \n \n-        Edge test2TargetEdge = createEdge( sourceId1, \"test2\", targetId2, UUIDGenerator.newTimeUUID() );\n+        Edge test2TargetEdge = createEdge( sourceId1, \"test2\", targetId2, System.currentTimeMillis() );\n \n         gm.writeEdge( test2TargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n@@ -898,16 +898,16 @@ public void testWriteReadEdgeTypesTargetTypesPaging() {\n         Id targetId = new SimpleId( \"target\" );\n \n \n-        Edge testTargetEdge = createEdge( sourceId1, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge testTargetEdge = createEdge( sourceId1, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( testTargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n \n-        Edge testTargetEdge2 = createEdge( sourceId2, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge testTargetEdge2 = createEdge( sourceId2, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( testTargetEdge2 ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge test2TargetEdge = createEdge( sourceId2, \"test2\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge test2TargetEdge = createEdge( sourceId2, \"test2\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( test2TargetEdge ).toBlockingObservable().singleOrDefault( null );\n \n@@ -978,31 +978,25 @@ public void testMarkSourceEdges() throws InterruptedException {\n         Id targetId1 = new SimpleId( \"target\" );\n         Id targetId2 = new SimpleId( \"target2\" );\n \n-        Edge edge1 = createEdge( sourceId, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+\n+        Edge edge1 = createEdge( sourceId, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( edge1 ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge edge2 = createEdge( sourceId, \"test\", targetId2, UUIDGenerator.newTimeUUID() );\n+        Edge edge2 = createEdge( sourceId, \"test\", targetId2, System.currentTimeMillis() );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().singleOrDefault( null );\n \n \n-        final UUID maxVersion = UUIDGenerator.newTimeUUID();\n-\n+        final long maxVersion = System.currentTimeMillis();\n \n \n-        assertTrue( UUIDComparator.staticCompare( maxVersion, edge2.getVersion() ) > 0);\n-        assertTrue( UUIDComparator.staticCompare( maxVersion, edge1.getVersion() ) > 0);\n \n-        ByteBuffer edge1Buff = UUIDSerializer.get().toByteBuffer( edge1.getVersion() );\n-        ByteBuffer edge2Buff = UUIDSerializer.get().toByteBuffer( edge2.getVersion() );\n-        ByteBuffer maxBuff = UUIDSerializer.get().toByteBuffer( maxVersion );\n+        assertTrue( Long.compare( maxVersion, edge2.getTimestamp() ) > 0);\n+        assertTrue( Long.compare( maxVersion, edge1.getTimestamp() ) > 0);\n \n \n \n-        assertTrue( UUIDType.instance.compare( maxBuff.duplicate(), edge1Buff.duplicate() ) > 0);\n-        assertTrue( UUIDType.instance.compare( maxBuff.duplicate(), edge2Buff.duplicate() ) > 0);\n-\n \n         //get our 2 edges\n         Observable<Edge> edges = gm.loadEdgesFromSource(\n@@ -1071,16 +1065,16 @@ public void testMarkTargetEdges() {\n         Id sourceId2 = new SimpleId( \"source2\" );\n         Id targetId = new SimpleId( \"target\" );\n \n-        Edge edge1 = createEdge( sourceId1, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge edge1 = createEdge( sourceId1, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( edge1 ).toBlockingObservable().last();\n \n-        Edge edge2 = createEdge( sourceId2, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge edge2 = createEdge( sourceId2, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().last();\n \n \n-        final UUID maxVersion = UUIDGenerator.newTimeUUID();\n+        final long maxVersion = System.currentTimeMillis();\n \n \n         //get our 2 edges\n@@ -1139,16 +1133,16 @@ public void testMarkSourceEdgesType() {\n         Id targetId1 = new SimpleId( \"target\" );\n         Id targetId2 = new SimpleId( \"target2\" );\n \n-        Edge edge1 = createEdge( sourceId, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge edge1 = createEdge( sourceId, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( edge1 ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge edge2 = createEdge( sourceId, \"test\", targetId2, UUIDGenerator.newTimeUUID() );\n+        Edge edge2 = createEdge( sourceId, \"test\", targetId2, System.currentTimeMillis() );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().singleOrDefault( null );\n \n \n-        final UUID maxVersion = UUIDGenerator.newTimeUUID();\n+        final long maxVersion = System.currentTimeMillis();\n \n \n         //get our 2 edges\n@@ -1217,16 +1211,16 @@ public void testMarkTargetEdgesType() {\n         Id sourceId2 = new SimpleId( \"source2\" );\n         Id targetId = new SimpleId( \"target\" );\n \n-        Edge edge1 = createEdge( sourceId1, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge edge1 = createEdge( sourceId1, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( edge1 ).toBlockingObservable().last();\n \n-        Edge edge2 = createEdge( sourceId2, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge edge2 = createEdge( sourceId2, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().last();\n \n \n-        final UUID maxVersion = UUIDGenerator.newTimeUUID();\n+        final long maxVersion = System.currentTimeMillis();\n \n         //get our 2 edges\n         Observable<Edge> edges = gm.loadEdgesToTargetByType(\n@@ -1295,16 +1289,16 @@ public void markSourceNode() {\n         Id targetId1 = new SimpleId( \"target\" );\n         Id targetId2 = new SimpleId( \"target2\" );\n \n-        Edge edge1 = createEdge( sourceId, \"test\", targetId1, UUIDGenerator.newTimeUUID() );\n+        Edge edge1 = createEdge( sourceId, \"test\", targetId1, System.currentTimeMillis() );\n \n         gm.writeEdge( edge1 ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge edge2 = createEdge( sourceId, \"test\", targetId2, UUIDGenerator.newTimeUUID() );\n+        Edge edge2 = createEdge( sourceId, \"test\", targetId2, System.currentTimeMillis() );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().singleOrDefault( null );\n \n \n-        final UUID maxVersion = UUIDGenerator.newTimeUUID();\n+        final long maxVersion = System.currentTimeMillis();\n \n         Iterator<Edge> results =\n                 gm.loadEdgesFromSource( createSearchByEdge( sourceId, edge1.getType(), maxVersion, null ) )\n@@ -1339,7 +1333,7 @@ public void markSourceNode() {\n         assertFalse( \"No more edges\", results.hasNext() );\n \n         //mark the source node\n-        gm.deleteNode( sourceId ).toBlockingObservable().last();\n+        gm.deleteNode( sourceId, edge2.getTimestamp() ).toBlockingObservable().last();\n \n \n         //now re-read, nothing should be there since they're marked\n@@ -1377,16 +1371,16 @@ public void markTargetNode() {\n         Id sourceId2 = new SimpleId( \"source2\" );\n         Id targetId = new SimpleId( \"target\" );\n \n-        Edge edge1 = createEdge( sourceId1, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge edge1 = createEdge( sourceId1, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( edge1 ).toBlockingObservable().singleOrDefault( null );\n \n-        Edge edge2 = createEdge( sourceId2, \"test\", targetId, UUIDGenerator.newTimeUUID() );\n+        Edge edge2 = createEdge( sourceId2, \"test\", targetId, System.currentTimeMillis() );\n \n         gm.writeEdge( edge2 ).toBlockingObservable().singleOrDefault( null );\n \n \n-        final UUID maxVersion = UUIDGenerator.newTimeUUID();\n+        final long maxVersion = System.currentTimeMillis();\n \n         Iterator<Edge> results =\n                 gm.loadEdgesToTarget( createSearchByEdge( targetId, edge1.getType(), maxVersion, null ) )\n@@ -1421,7 +1415,7 @@ public void markTargetNode() {\n         assertFalse( \"No more edges\", results.hasNext() );\n \n         //mark the source node\n-        gm.deleteNode( targetId ).toBlockingObservable().last();\n+        gm.deleteNode( targetId, edge2.getTimestamp() ).toBlockingObservable().last();\n \n \n         //now re-read, nothing should be there since they're marked\n@@ -1464,54 +1458,6 @@ public void invalidEdgeTypesDelete( @All Edge edge ) {\n \n         em.deleteEdge( edge );\n     }\n-\n-    //\n-    //    public static class InvalidInput extends JukitoModule {\n-    //\n-    //        @Override\n-    //        protected void configureTest() {\n-    //create all edge types of junk input\n-    //\n-    //            final UUID version = UUIDGenerator.newTimeUUID();\n-    //\n-    //            Id nullUuid = mock( Id.class );\n-    //            when( nullUuid.getUuid() ).thenReturn( null );\n-    //\n-    //\n-    //            Id nullType = mock( Id.class );\n-    //            when( nullType.getType() ).thenReturn( \"type\" );\n-    //\n-    //            Edge[] edges = new Edge[] {\n-    //                    mockEdge( nullUuid, \"test\", createId( \"target\" ), version ),\n-    //\n-    //                    mockEdge( nullType, \"test\", createId( \"target\" ), version ),\n-    //\n-    //                    mockEdge( createId( \"source\" ), null, createId( \"target\" ), version ),\n-    //\n-    //                    mockEdge( createId( \"source\" ), \"test\", nullUuid, version ),\n-    //\n-    //                    mockEdge( createId( \"source\" ), \"test\", nullType, version ),\n-    //\n-    //                    mockEdge( createId( \"source\" ), \"test\", createId( \"target\" ), null )\n-    //            };\n-    //\n-    //\n-    //            bindManyInstances( Edge.class, edges );\n-    //\n-    //        }\n-    //\n-    //\n-    //        private Edge mockEdge( final Id sourceId, final String type, final Id targetId, final UUID version ) {\n-    //            Edge edge = mock( Edge.class );\n-    //\n-    //            when( edge.getSourceNode() ).thenReturn( sourceId );\n-    //            when( edge.getType() ).thenReturn( type );\n-    //            when( edge.getTargetNode() ).thenReturn( targetId );\n-    //            when( edge.getTimestamp() ).thenReturn( version );\n-    //\n-    //            return edge;\n-    //        }\n-    //    }\n }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerIT.java",
                "sha": "0c8ccdd2216a2a2faa1f835910fc940cd39a0cf1",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerLoadTest.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerLoadTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 7,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerLoadTest.java",
                "patch": "@@ -113,9 +113,7 @@ public Edge newEdge() {\n \n             @Override\n             public Observable<Edge> doSearch( final GraphManager manager ) {\n-                UUID uuid = UUIDGenerator.newTimeUUID();\n-\n-                return manager.loadEdgesFromSource( new SimpleSearchByEdgeType( sourceId, \"test\", uuid, null ) );\n+                 return manager.loadEdgesFromSource( new SimpleSearchByEdgeType( sourceId, \"test\", System.currentTimeMillis(), null ) );\n             }\n         };\n \n@@ -142,9 +140,7 @@ public Edge newEdge() {\n \n             @Override\n             public Observable<Edge> doSearch( final GraphManager manager ) {\n-                UUID uuid = UUIDGenerator.newTimeUUID();\n-\n-                return manager.loadEdgesToTarget( new SimpleSearchByEdgeType( targetId, \"test\", uuid, null ) );\n+                return manager.loadEdgesToTarget( new SimpleSearchByEdgeType( targetId, \"test\", System.currentTimeMillis(), null ) );\n             }\n         };\n \n@@ -205,7 +201,7 @@ public Boolean call() throws Exception {\n                 Edge returned = manager.writeEdge( edge ).toBlockingObservable().last();\n \n \n-                assertNotNull( \"Returned has a version\", returned.getVersion() );\n+                assertNotNull( \"Returned has a version\", returned.getTimestamp() );\n \n \n                 if ( i % 1000 == 0 ) {",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerLoadTest.java",
                "sha": "9302d544dc14613e359a592eb7a8cff1ea0e2d87",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerStressTest.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerStressTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 8,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerStressTest.java",
                "patch": "@@ -108,7 +108,7 @@ public Edge newEdge() {\n             public Observable<Edge> doSearch( final GraphManager manager ) {\n \n \n-                final UUID uuid = UUIDGenerator.newTimeUUID();\n+                final long timestamp = System.currentTimeMillis();\n \n \n                 return Observable.create( new Observable.OnSubscribe<Edge>() {\n@@ -119,7 +119,7 @@ public void call( final Subscriber<? super Edge> subscriber ) {\n                             for ( Id sourceId : sourceIds ) {\n \n                                 final Iterable<Edge> edges = manager.loadEdgesFromSource(\n-                                        new SimpleSearchByEdgeType( sourceId, \"test\", uuid, null ) )\n+                                        new SimpleSearchByEdgeType( sourceId, \"test\", timestamp, null ) )\n                                                                     .toBlockingObservable().toIterable();\n \n                                 for ( Edge edge : edges ) {\n@@ -193,9 +193,7 @@ public Edge newEdge() {\n \n             @Override\n             public Observable<Edge> doSearch( final GraphManager manager ) {\n-                UUID uuid = UUIDGenerator.newTimeUUID();\n-\n-                return manager.loadEdgesFromSource( new SimpleSearchByEdgeType( sourceId, \"test\", uuid, null ) );\n+                return manager.loadEdgesFromSource( new SimpleSearchByEdgeType( sourceId, \"test\", System.currentTimeMillis(), null ) );\n             }\n         };\n \n@@ -222,9 +220,8 @@ public Edge newEdge() {\n \n             @Override\n             public Observable<Edge> doSearch( final GraphManager manager ) {\n-                UUID uuid = UUIDGenerator.newTimeUUID();\n \n-                return manager.loadEdgesToTarget( new SimpleSearchByEdgeType( targetId, \"test\", uuid, null ) );\n+                return manager.loadEdgesToTarget( new SimpleSearchByEdgeType( targetId, \"test\", System.currentTimeMillis(), null ) );\n             }\n         };\n \n@@ -251,7 +248,7 @@ private void doTest( EdgeGenerator generator ) throws InterruptedException {\n             Edge returned = manager.writeEdge( edge ).toBlockingObservable().last();\n \n \n-            assertNotNull( \"Returned has a version\", returned.getVersion() );\n+            assertNotNull( \"Returned has a version\", returned.getTimestamp() );\n \n             ids.add( returned );\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/GraphManagerStressTest.java",
                "sha": "4b3bba45ec3c7073208c115d02cda6f6fed2e7c4",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/StorageGraphManagerIT.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/StorageGraphManagerIT.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 10,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/StorageGraphManagerIT.java",
                "patch": "@@ -27,6 +27,8 @@\n import org.jukito.UseModules;\n import org.junit.Before;\n import org.junit.runner.RunWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import org.apache.usergrid.persistence.core.cassandra.ITRunner;\n import org.apache.usergrid.persistence.core.consistency.AsyncProcessor;\n@@ -54,6 +56,7 @@\n @UseModules( { TestGraphModule.class } )\n public class StorageGraphManagerIT extends GraphManagerIT {\n \n+    private static final Logger LOG = LoggerFactory.getLogger( StorageGraphManagerIT.class );\n \n     @Inject\n     protected AsyncProcessor<EdgeDeleteEvent> edgeDelete;\n@@ -150,22 +153,22 @@ public ComittedGraphTestHelper( final GraphManager graphManager ) {\n \n         @Override\n         public Observable<Edge> writeEdge( final Edge edge ) {\n-            completeInvocations.decrementAndGet();\n+            completeInvocations.incrementAndGet();\n             return graphManager.writeEdge( edge );\n         }\n \n \n         @Override\n         public Observable<Edge> deleteEdge( final Edge edge ) {\n-            completeInvocations.decrementAndGet();\n+            completeInvocations.incrementAndGet();\n             return graphManager.deleteEdge( edge );\n         }\n \n \n         @Override\n-        public Observable<Id> deleteNode( final Id node ) {\n-            completeInvocations.decrementAndGet();\n-            return graphManager.deleteNode( node );\n+        public Observable<Id> deleteNode( final Id node, final long timestamp ) {\n+            completeInvocations.incrementAndGet();\n+            return graphManager.deleteNode( node, timestamp );\n         }\n \n \n@@ -233,13 +236,13 @@ public ComittedGraphTestHelper( final GraphManager graphManager ) {\n \n \n         public void complete() {\n-            completeInvocations.incrementAndGet();\n+            completeInvocations.decrementAndGet();\n             tryWake();\n         }\n \n \n         public void error() {\n-            errorInvocations.incrementAndGet();\n+            errorInvocations.decrementAndGet();\n             tryWake();\n         }\n \n@@ -255,12 +258,13 @@ public void tryWake() {\n          * Away for our invocations to be 0\n          */\n         public void await() {\n-            while (  completeInvocations.get() != 0 ) {\n+            while (  completeInvocations.get() > 0 ) {\n+\n+                LOG.info( \"Waiting for more invocations, count is {} \", completeInvocations.get() );\n \n                 synchronized ( mutex ) {\n                     try {\n-\n-                        mutex.wait();\n+                        mutex.wait(1000 );\n                     }\n                     catch ( InterruptedException e ) {\n                         //no op",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/StorageGraphManagerIT.java",
                "sha": "8c7692496cb914b2dce60c401a3b93645d123f9d",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListenerTest.java",
                "changes": 50,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListenerTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 24,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListenerTest.java",
                "patch": "@@ -137,20 +137,20 @@ public void testDeleteIT() throws ConnectionException {\n         final Id targetId = createId( \"target\" );\n \n \n-        MarkedEdge edgeV1 = createMarkedEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV2 = createMarkedEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV3 = createMarkedEdge( sourceId, edgeType, targetId );\n+        final long edgeTimestamp = 1000l;\n \n+        MarkedEdge edgeV1 = createMarkedEdge( sourceId, edgeType, targetId, edgeTimestamp );\n+        MarkedEdge edgeV2 = createMarkedEdge( sourceId, edgeType, targetId, edgeTimestamp + 1 );\n+        MarkedEdge edgeV3 = createMarkedEdge( sourceId, edgeType, targetId, edgeTimestamp + 2 );\n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n \n-        commitLogEdgeSerialization.writeEdge( scope, edgeV1, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV2, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV3, timestamp ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV1, UUIDGenerator.newTimeUUID() ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV2, UUIDGenerator.newTimeUUID() ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV3, UUIDGenerator.newTimeUUID() ).execute();\n \n-        storageEdgeSerialization.writeEdge( scope, edgeV1, timestamp ).execute();\n-        storageEdgeSerialization.writeEdge( scope, edgeV2, timestamp ).execute();\n-        storageEdgeSerialization.writeEdge( scope, edgeV3, timestamp ).execute();\n+        storageEdgeSerialization.writeEdge( scope, edgeV1, UUIDGenerator.newTimeUUID() ).execute();\n+        storageEdgeSerialization.writeEdge( scope, edgeV2, UUIDGenerator.newTimeUUID() ).execute();\n+        storageEdgeSerialization.writeEdge( scope, edgeV3, UUIDGenerator.newTimeUUID() ).execute();\n \n \n \n@@ -163,7 +163,7 @@ public void testDeleteIT() throws ConnectionException {\n         assertEquals( edgeV3, returned.getData() );\n \n         //now validate there's nothing in the commit log.\n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         /******\n          * Ensure everything is removed from the commit log\n@@ -278,20 +278,22 @@ public void testDeleteAllIT() throws ConnectionException {\n         final Id targetId = createId( \"target\" );\n \n \n-        MarkedEdge edgeV1 = createMarkedEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV2 = createMarkedEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV3 = createMarkedEdge( sourceId, edgeType, targetId );\n+        final long timestamp = 1000l;\n+\n+        MarkedEdge edgeV1 = createMarkedEdge( sourceId, edgeType, targetId, timestamp );\n+        MarkedEdge edgeV2 = createMarkedEdge( sourceId, edgeType, targetId, timestamp + 1 );\n+        MarkedEdge edgeV3 = createMarkedEdge( sourceId, edgeType, targetId, timestamp + 2);\n \n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n+        final UUID foobar = UUIDGenerator.newTimeUUID();\n \n-        commitLogEdgeSerialization.writeEdge( scope, edgeV1, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV2, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV3, timestamp ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV1, foobar ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV2, foobar ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV3, foobar ).execute();\n \n-        storageEdgeSerialization.writeEdge( scope, edgeV1, timestamp ).execute();\n-        storageEdgeSerialization.writeEdge( scope, edgeV2, timestamp ).execute();\n-        storageEdgeSerialization.writeEdge( scope, edgeV3, timestamp ).execute();\n+        storageEdgeSerialization.writeEdge( scope, edgeV1, foobar ).execute();\n+        storageEdgeSerialization.writeEdge( scope, edgeV2, foobar ).execute();\n+        storageEdgeSerialization.writeEdge( scope, edgeV3, foobar ).execute();\n \n         edgeMetadataSerialization.writeEdge( scope, edgeV1 ).execute();\n         edgeMetadataSerialization.writeEdge( scope, edgeV2 ).execute();\n@@ -317,7 +319,7 @@ public void testDeleteAllIT() throws ConnectionException {\n \n \n         //now validate there's nothing in the commit log.\n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         /******\n          * Ensure everything is removed from the commit log\n@@ -472,7 +474,7 @@ public void writeFailsCommitLogUnwritten() throws ConnectionException {\n         when(edgeProcessor.getProcessor( EdgeWriteEvent.class )).thenReturn( processor );\n \n \n-        EdgeWriteEvent edgeWriteEvent = new EdgeWriteEvent( scope, edgeV1.getVersion(), edgeV1 );\n+        EdgeWriteEvent edgeWriteEvent = new EdgeWriteEvent( scope,  UUIDGenerator.newTimeUUID(), edgeV1 );\n \n         Keyspace keyspace = mock( Keyspace.class );\n \n@@ -489,7 +491,7 @@ public void writeFailsCommitLogUnwritten() throws ConnectionException {\n          */\n         when( commitLog.getEdgeVersions( same( scope ), any( SearchByEdge.class ) ) ).thenReturn( Collections\n                 .singletonList( createEdge( edgeV1.getSourceNode(), edgeV1.getType(), edgeV1.getTargetNode(),\n-                        edgeV1.getVersion() ) ).iterator() );\n+                        edgeV1.getTimestamp() ) ).iterator() );\n \n \n         /**",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeDeleteListenerTest.java",
                "sha": "d54c0c93aefb6882596c1aa9772b3b4a28c296b1",
                "status": "modified"
            },
            {
                "additions": 20,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeWriteListenerTest.java",
                "changes": 38,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeWriteListenerTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 18,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeWriteListenerTest.java",
                "patch": "@@ -68,6 +68,7 @@\n import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n@@ -130,16 +131,16 @@ public void testWriteIT() throws ConnectionException {\n         final Id targetId = createId( \"target\" );\n \n \n-        MarkedEdge edgeV1 = createEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV2 = createEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV3 = createEdge( sourceId, edgeType, targetId );\n+        final long timestamp = 1000l;\n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n+        MarkedEdge edgeV1 = createEdge( sourceId, edgeType, targetId, timestamp);\n+        MarkedEdge edgeV2 = createEdge( sourceId, edgeType, targetId, timestamp + 1 );\n+        MarkedEdge edgeV3 = createEdge( sourceId, edgeType, targetId, timestamp + 2 );\n \n \n-        commitLogEdgeSerialization.writeEdge( scope, edgeV1, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV2, timestamp).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV3, timestamp ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV1,  UUIDGenerator.newTimeUUID() ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV2,  UUIDGenerator.newTimeUUID()).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV3,  UUIDGenerator.newTimeUUID() ).execute();\n \n         EdgeWriteEvent edgeWriteEvent = new EdgeWriteEvent( scope, UUIDGenerator.newTimeUUID(), edgeV3 );\n \n@@ -149,7 +150,7 @@ public void testWriteIT() throws ConnectionException {\n         assertEquals( 3, returned.intValue() );\n \n         //now validate there's nothing in the commit log.\n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         /******\n          * Ensure everything is removed from the commit log\n@@ -260,16 +261,17 @@ public void testWritePreviousVersionIT() throws ConnectionException {\n         final String edgeType = \"test\";\n         final Id targetId = createId( \"target\" );\n \n+        final long timestamp = 10000;\n \n-        MarkedEdge edgeV1 = createEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV2 = createEdge( sourceId, edgeType, targetId );\n-        MarkedEdge edgeV3 = createEdge( sourceId, edgeType, targetId );\n+\n+        MarkedEdge edgeV1 = createEdge( sourceId, edgeType, targetId, timestamp );\n+        MarkedEdge edgeV2 = createEdge( sourceId, edgeType, targetId, timestamp+1 );\n+        MarkedEdge edgeV3 = createEdge( sourceId, edgeType, targetId, timestamp+2 );\n \n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV1, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV2, timestamp ).execute();\n-        commitLogEdgeSerialization.writeEdge( scope, edgeV3, timestamp ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV1,  UUIDGenerator.newTimeUUID() ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV2,  UUIDGenerator.newTimeUUID() ).execute();\n+        commitLogEdgeSerialization.writeEdge( scope, edgeV3,  UUIDGenerator.newTimeUUID() ).execute();\n \n         EdgeWriteEvent edgeWriteEvent = new EdgeWriteEvent( scope, UUIDGenerator.newTimeUUID(), edgeV2 );\n \n@@ -279,7 +281,7 @@ public void testWritePreviousVersionIT() throws ConnectionException {\n         assertEquals( 2, returned.intValue() );\n \n         //now validate there's nothing in the commit log.\n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         /******\n          * Ensure everything is removed from the commit log\n@@ -412,7 +414,7 @@ public void writeFailsCommitLogUnwritten() throws ConnectionException {\n         when(edgeProcessor.getProcessor( EdgeWriteEvent.class )).thenReturn( processor );\n \n \n-        EdgeWriteEvent edgeWriteEvent = new EdgeWriteEvent( scope, edgeV1.getVersion(), edgeV1 );\n+        EdgeWriteEvent edgeWriteEvent = new EdgeWriteEvent( scope, UUIDGenerator.newTimeUUID(), edgeV1 );\n \n         Keyspace keyspace = mock( Keyspace.class );\n \n@@ -430,7 +432,7 @@ public void writeFailsCommitLogUnwritten() throws ConnectionException {\n          */\n         when( commitLog.getEdgeVersions( same(scope), any( SearchByEdge.class ) ) ).thenReturn( Collections\n                 .singletonList( createEdge( edgeV1.getSourceNode(), edgeV1.getType(), edgeV1.getTargetNode(),\n-                        edgeV1.getVersion() ) ).iterator() );\n+                        edgeV1.getTimestamp() ) ).iterator() );\n \n \n         /**",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/EdgeWriteListenerTest.java",
                "sha": "a6ea2b07dee11001fb24de3b9f03802310a4253b",
                "status": "modified"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListenerTest.java",
                "changes": 34,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListenerTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 18,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListenerTest.java",
                "patch": "@@ -134,21 +134,17 @@ public void testNoDeletionMarked() {\n \n         Id targetNode = edge.getTargetNode();\n \n-        UUID version = UUIDGenerator.newTimeUUID();\n+        UUID eventTime = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n \n-        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, version, sourceNode );\n+        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, eventTime, now, sourceNode );\n \n         int count = deleteListener.receive( deleteEvent ).toBlockingObservable().last();\n \n         assertEquals( \"Mark was not set, no delete should be executed\", 0, count );\n \n \n-        deleteEvent = new NodeDeleteEvent( scope, version, targetNode );\n-\n-        count = deleteListener.receive( deleteEvent ).toBlockingObservable().last();\n-\n-        assertEquals( \"Mark was not set, no delete should be executed\", 0, count );\n     }\n \n \n@@ -175,11 +171,12 @@ public void testRemoveSourceNode() throws ConnectionException {\n \n \n         //mark the node so\n-        UUID deleteVersion = UUIDGenerator.newTimeUUID();\n+        UUID deleteEventTimestamp = UUIDGenerator.newTimeUUID();\n+        long timestamp = System.currentTimeMillis();\n \n-        nodeSerialization.mark( scope, sourceNode, deleteVersion ).execute();\n+        nodeSerialization.mark( scope, sourceNode, timestamp ).execute();\n \n-        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, deleteVersion, sourceNode );\n+        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, deleteEventTimestamp, timestamp, sourceNode );\n \n \n         int count = deleteListener.receive( deleteEvent ).toBlockingObservable().last();\n@@ -188,7 +185,7 @@ public void testRemoveSourceNode() throws ConnectionException {\n \n         //now verify we can't get any of the info back\n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n \n         Iterator<MarkedEdge> returned = edgeSerialization\n@@ -263,11 +260,12 @@ public void testRemoveTargetNode() throws ConnectionException {\n \n \n         //mark the node so\n-        UUID deleteVersion = UUIDGenerator.newTimeUUID();\n+        UUID deleteEventTimestamp = UUIDGenerator.newTimeUUID();\n+        long deleteTimestamp = System.currentTimeMillis();\n \n-        nodeSerialization.mark( scope, targetNode, deleteVersion ).execute();\n+        nodeSerialization.mark( scope, targetNode, deleteTimestamp ).execute();\n \n-        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, deleteVersion, targetNode );\n+        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, deleteEventTimestamp, deleteTimestamp, targetNode );\n \n \n         int count = deleteListener.receive( deleteEvent ).toBlockingObservable().last();\n@@ -276,7 +274,7 @@ public void testRemoveTargetNode() throws ConnectionException {\n \n         //now verify we can't get any of the info back\n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n \n         Iterator<MarkedEdge> returned = edgeSerialization\n@@ -376,11 +374,11 @@ public void testMultiDelete() throws ConnectionException, InterruptedException {\n         log.info( \"Saved {} source edges\", sourceCount );\n         log.info( \"Saved {} target edges\", targetCount );\n \n-        UUID deleteVersion = UUID.fromString( \"ffffffff-ffff-1fff-bfff-ffffffffffff\" );\n+        long deleteVersion = Long.MAX_VALUE;\n \n         nodeSerialization.mark( scope, toDelete, deleteVersion ).execute();\n \n-        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, deleteVersion, toDelete );\n+        NodeDeleteEvent deleteEvent = new NodeDeleteEvent( scope, UUIDGenerator.newTimeUUID(), deleteVersion, toDelete );\n \n \n         int count = deleteListener.receive( deleteEvent ).toBlockingObservable().last();\n@@ -390,7 +388,7 @@ public void testMultiDelete() throws ConnectionException, InterruptedException {\n \n         //now verify we can't get any of the info back\n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n \n            //validate it's not returned by the",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/NodeDeleteListenerTest.java",
                "sha": "f65d7a4746e583595deeb824d01104cc18926630",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairTest.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 5,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairTest.java",
                "patch": "@@ -129,7 +129,7 @@ public void commitLogTest() throws ConnectionException {\n \n         //write it as non deleted to storage\n         final MarkedEdge edge1NotDeleted =\n-                createEdge( edge1.getSourceNode(), edgeType, edge1.getTargetNode(), edge1.getVersion(), false );\n+                createEdge( edge1.getSourceNode(), edgeType, edge1.getTargetNode(), edge1.getTimestamp(), false );\n \n         storageEdgeSerialization.writeEdge( scope, edge1NotDeleted,  UUIDGenerator.newTimeUUID() ).execute();\n \n@@ -141,14 +141,14 @@ public void commitLogTest() throws ConnectionException {\n         //now repair delete the first edge\n \n         Iterator<MarkedEdge> itr = commitLogEdgeSerialization.getEdgeVersions( scope,\n-                new SimpleSearchByEdge( sourceId, edgeType, targetId, UUIDGenerator.newTimeUUID(), null ) );\n+                new SimpleSearchByEdge( sourceId, edgeType, targetId, System.currentTimeMillis(), null ) );\n \n         assertEquals( edge2, itr.next() );\n         assertEquals( edge1, itr.next() );\n         assertFalse( itr.hasNext() );\n \n         itr =  storageEdgeSerialization.getEdgeVersions( scope,\n-                new SimpleSearchByEdge( sourceId, edgeType, targetId, UUIDGenerator.newTimeUUID(), null ) );\n+                new SimpleSearchByEdge( sourceId, edgeType, targetId, System.currentTimeMillis(), null ) );\n \n         assertEquals( edge2, itr.next() );\n         assertEquals( edge1NotDeleted, itr.next() );\n@@ -159,13 +159,13 @@ public void commitLogTest() throws ConnectionException {\n         assertEquals( edge1, deleted );\n \n         itr = commitLogEdgeSerialization.getEdgeVersions( scope,\n-                new SimpleSearchByEdge( sourceId, edgeType, targetId, UUIDGenerator.newTimeUUID(), null ) );\n+                new SimpleSearchByEdge( sourceId, edgeType, targetId,System.currentTimeMillis(), null ) );\n \n         assertEquals( edge2, itr.next() );\n         assertFalse( itr.hasNext() );\n \n         itr = storageEdgeSerialization.getEdgeVersions( scope,\n-                new SimpleSearchByEdge( sourceId, edgeType, targetId, UUIDGenerator.newTimeUUID(), null ) );\n+                new SimpleSearchByEdge( sourceId, edgeType, targetId, System.currentTimeMillis(), null ) );\n \n         assertEquals( edge2, itr.next() );\n         assertFalse( itr.hasNext() );",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeDeleteRepairTest.java",
                "sha": "f71a8ea8176d81207d2c87dd6e1e1a2288fdb46e",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairTest.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 9,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairTest.java",
                "patch": "@@ -110,7 +110,7 @@ public void cleanTargetNoEdgesNoMeta() {\n \n         final Id targetId = createId( \"target\" );\n         final String test = \"test\";\n-        final UUID version = UUIDGenerator.newTimeUUID();\n+        final long version = System.currentTimeMillis();\n \n         int value = edgeMetaRepair.repairTargets( scope, targetId, test, version ).toBlockingObservable().single();\n \n@@ -126,7 +126,7 @@ public void cleanTargetSingleEdge() throws ConnectionException {\n \n         edgeMetadataSerialization.writeEdge( scope, edge ).execute();\n \n-        int value = edgeMetaRepair.repairTargets( scope, edge.getTargetNode(), edge.getType(), edge.getVersion() )\n+        int value = edgeMetaRepair.repairTargets( scope, edge.getTargetNode(), edge.getType(), edge.getTimestamp() )\n                                   .toBlockingObservable().single();\n \n         assertEquals( \"No subtypes removed, edge exists\", 1, value );\n@@ -135,7 +135,7 @@ public void cleanTargetSingleEdge() throws ConnectionException {\n \n         storageEdgeSerialization.deleteEdge( scope, edge, UUIDGenerator.newTimeUUID() ).execute();\n \n-        value = edgeMetaRepair.repairTargets( scope, edge.getTargetNode(), edge.getType(), edge.getVersion() )\n+        value = edgeMetaRepair.repairTargets( scope, edge.getTargetNode(), edge.getType(), edge.getTimestamp() )\n                               .toBlockingObservable().single();\n \n         assertEquals( \"Single subtype should be removed\", 0, value );\n@@ -180,7 +180,7 @@ public void cleanTargetMultipleEdge() throws ConnectionException {\n         edgeMetadataSerialization.writeEdge( scope, edge3 ).execute();\n \n \n-        UUID cleanupVersion = UUIDGenerator.newTimeUUID();\n+        long cleanupVersion = System.currentTimeMillis();\n \n         int value = edgeMetaRepair.repairTargets( scope, edge1.getTargetNode(), edge1.getType(), cleanupVersion )\n                                   .toBlockingObservable().single();\n@@ -248,7 +248,7 @@ public void cleanTargetMultipleEdgeBuffer() throws ConnectionException {\n         }\n \n \n-        UUID cleanupVersion = UUIDGenerator.newTimeUUID();\n+        long cleanupVersion = System.currentTimeMillis();\n \n         int value = edgeMetaRepair.repairTargets( scope, targetId, edgeType, cleanupVersion ).toBlockingObservable()\n                                   .single();\n@@ -289,7 +289,7 @@ public void cleanSourceSingleEdge() throws ConnectionException {\n \n         edgeMetadataSerialization.writeEdge( scope, edge ).execute();\n \n-        int value = edgeMetaRepair.repairSources( scope, edge.getSourceNode(), edge.getType(), edge.getVersion() )\n+        int value = edgeMetaRepair.repairSources( scope, edge.getSourceNode(), edge.getType(), edge.getTimestamp() )\n                                   .toBlockingObservable().single();\n \n         assertEquals( \"No subtypes removed, edge exists\", 1, value );\n@@ -298,7 +298,7 @@ public void cleanSourceSingleEdge() throws ConnectionException {\n \n         storageEdgeSerialization.deleteEdge( scope, edge, UUIDGenerator.newTimeUUID() ).execute();\n \n-        value = edgeMetaRepair.repairSources( scope, edge.getSourceNode(), edge.getType(), edge.getVersion() )\n+        value = edgeMetaRepair.repairSources( scope, edge.getSourceNode(), edge.getType(), edge.getTimestamp() )\n                               .toBlockingObservable().single();\n \n         assertEquals( \"Single subtype should be removed\", 0, value );\n@@ -343,7 +343,7 @@ public void cleanSourceMultipleEdge() throws ConnectionException {\n         edgeMetadataSerialization.writeEdge( scope, edge3 ).execute();\n \n \n-        UUID cleanupVersion = UUIDGenerator.newTimeUUID();\n+        long cleanupVersion = System.currentTimeMillis();\n \n         int value = edgeMetaRepair.repairSources( scope, edge1.getSourceNode(), edge1.getType(), cleanupVersion )\n                                   .toBlockingObservable().single();\n@@ -412,7 +412,7 @@ public void cleanSourceMultipleEdgeBuffer() throws ConnectionException {\n         }\n \n \n-        UUID cleanupVersion = UUIDGenerator.newTimeUUID();\n+        long cleanupVersion = System.currentTimeMillis();\n \n         int value = edgeMetaRepair.repairSources( scope, sourceId, edgeType, cleanupVersion ).toBlockingObservable()\n                                   .single();",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/impl/stage/EdgeMetaRepairTest.java",
                "sha": "dc7c148ee0ad1c004c96b81c598e9db536b661ff",
                "status": "modified"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerializationTest.java",
                "changes": 25,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerializationTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 9,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerializationTest.java",
                "patch": "@@ -259,13 +259,14 @@ public void readSourceEdgeIdTypes() throws ConnectionException {\n      */\n     @Test\n     public void deleteTargetEdgeTypes() throws ConnectionException {\n-        final Edge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+        final long timestamp = 1000l;\n+        final Edge edge1 = createEdge( \"source\", \"edge\", \"target\", timestamp );\n \n         final Id sourceId = edge1.getSourceNode();\n \n-        final Edge edge2 = createEdge( sourceId, \"edge\", createId( \"target2\" ) );\n+        final Edge edge2 = createEdge( sourceId, \"edge\", createId( \"target2\" ), timestamp + 1 );\n \n-        final Edge edge3 = createEdge( sourceId, \"edge2\", createId( \"target3\" ) );\n+        final Edge edge3 = createEdge( sourceId, \"edge2\", createId( \"target3\" ), timestamp + 2 );\n \n         //set writing the edge\n         serialization.writeEdge( scope, edge1 ).execute();\n@@ -365,13 +366,16 @@ public void deleteSourceEdgeTypes() throws ConnectionException {\n      */\n     @Test\n     public void deleteTargetIdTypes() throws ConnectionException {\n-        final Edge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+\n+        final long timestamp = 1000l;\n+\n+        final Edge edge1 = createEdge( \"source\", \"edge\", \"target\", timestamp );\n \n         final Id sourceId = edge1.getSourceNode();\n \n-        final Edge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ) );\n+        final Edge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ), timestamp + 1 );\n \n-        final Edge edge3 = createEdge( sourceId, \"edge\", createId( \"target2\" ) );\n+        final Edge edge3 = createEdge( sourceId, \"edge\", createId( \"target2\" ), timestamp + 2 );\n \n         //set writing the edge\n         serialization.writeEdge( scope, edge1 ).execute();\n@@ -419,13 +423,16 @@ public void deleteTargetIdTypes() throws ConnectionException {\n      */\n     @Test\n     public void deleteSourceIdTypes() throws ConnectionException {\n-        final Edge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+\n+        final long timestamp = 1000l;\n+\n+        final Edge edge1 = createEdge( \"source\", \"edge\", \"target\", timestamp );\n \n         final Id targetId = edge1.getTargetNode();\n \n-        final Edge edge2 = createEdge( createId( \"source\" ), \"edge\", targetId );\n+        final Edge edge2 = createEdge( createId( \"source\" ), \"edge\", targetId, timestamp+1 );\n \n-        final Edge edge3 = createEdge( createId( \"source2\" ), \"edge\", targetId );\n+        final Edge edge3 = createEdge( createId( \"source2\" ), \"edge\", targetId, timestamp+2 );\n \n         //set writing the edge\n         serialization.writeEdge( scope, edge1 ).execute();",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeMetadataSerializationTest.java",
                "sha": "530da50b1de3b06d6e4f50a7d718bc790d62f08e",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationChopTest.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationChopTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationChopTest.java",
                "patch": "@@ -110,7 +110,7 @@ public void mixedEdgeTypes() throws ConnectionException {\n         serialization.writeEdge( scope, edge, UUIDGenerator.newTimeUUID() ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationChopTest.java",
                "sha": "e45ea8e65e7868c8009834590f8bd53931e70c6a",
                "status": "modified"
            },
            {
                "additions": 64,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationTest.java",
                "changes": 125,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 61,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationTest.java",
                "patch": "@@ -136,7 +136,7 @@ public void mixedEdgeTypes() throws ConnectionException {\n         serialization.writeEdge( scope, edge2, timestamp ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n \n@@ -170,25 +170,29 @@ public void mixedEdgeTypes() throws ConnectionException {\n      */\n     @Test\n     public void testPaging() throws ConnectionException {\n-        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+\n+        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\", 0);\n \n         final Id sourceId = edge1.getSourceNode();\n         final Id targetId = edge1.getTargetNode();\n \n \n-        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", targetId );\n+        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", targetId, 1 );\n \n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n-\n-        serialization.writeEdge( scope, edge1, timestamp ).execute();\n-        serialization.writeEdge( scope, edge2, timestamp ).execute();\n+        serialization.writeEdge( scope, edge1, UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, edge2, UUIDGenerator.newTimeUUID() ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n \n+\n+\n+\n+\n+\n         Iterator<MarkedEdge> results =\n                 serialization.getEdgesFromSource( scope, createSearchByEdge( sourceId, \"edge\", now, edge2 ) );\n \n@@ -219,33 +223,33 @@ public void testPaging() throws ConnectionException {\n      */\n     @Test\n     public void directEdgeGets() throws ConnectionException {\n-        final MarkedEdge edgev1 = createEdge( \"source\", \"edge1\", \"target\" );\n+\n+        long timestamp = 1000;\n+        final MarkedEdge edgev1 = createEdge( \"source\", \"edge1\", \"target\", timestamp );\n \n         final Id sourceId = edgev1.getSourceNode();\n         final Id targetId = edgev1.getTargetNode();\n \n \n-        final MarkedEdge edgev2 = createEdge( sourceId, \"edge1\", targetId );\n+        final MarkedEdge edgev2 = createEdge( sourceId, \"edge1\", targetId, timestamp+1 );\n \n         //we shouldn't get this one back\n         final MarkedEdge diffTarget = createEdge( sourceId, \"edge1\", createId( \"newTarget\" ) );\n \n         assertTrue( \"Edge version 1 has lower time uuid\",\n-                UUIDComparator.staticCompare( edgev1.getVersion(), edgev2.getVersion() ) < 0 );\n+                Long.compare( edgev1.getTimestamp(), edgev2.getTimestamp() ) < 0 );\n \n         //create edge type 2 to ensure we don't get it in results\n         final MarkedEdge edgeType2V1 = createEdge( sourceId, \"edge2\", targetId );\n \n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n-\n \n-        serialization.writeEdge( scope, edgev1, timestamp ).execute();\n-        serialization.writeEdge( scope, edgev2, timestamp ).execute();\n-        serialization.writeEdge( scope, edgeType2V1, timestamp ).execute();\n-        serialization.writeEdge( scope, diffTarget, timestamp ).execute();\n+        serialization.writeEdge( scope, edgev1, UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, edgev2, UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, edgeType2V1, UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, diffTarget, UUIDGenerator.newTimeUUID() ).execute();\n \n-        final UUID now = UUIDGenerator.newTimeUUID();\n+        final long now = System.currentTimeMillis();\n \n \n         SearchByEdge search = createGetByEdge( sourceId, \"edge1\", targetId, now, null );\n@@ -259,7 +263,7 @@ public void directEdgeGets() throws ConnectionException {\n         //max version test\n \n         //test max version\n-        search = createGetByEdge( sourceId, \"edge1\", targetId, edgev1.getVersion(), null );\n+        search = createGetByEdge( sourceId, \"edge1\", targetId, edgev1.getTimestamp(), null );\n \n         results = serialization.getEdgeVersions( scope, search );\n \n@@ -290,7 +294,7 @@ public void mixedIdTypes() throws ConnectionException {\n         serialization.writeEdge( scope, edge2, timestamp ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n \n@@ -327,23 +331,23 @@ public void mixedIdTypes() throws ConnectionException {\n      */\n     @Test\n     public void idTypesPaging() throws ConnectionException {\n-        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+        final long timestamp = 1000;\n+        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\", timestamp );\n \n         final Id sourceId = edge1.getSourceNode();\n         final Id targetId1 = edge1.getTargetNode();\n \n \n-        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ) );\n+        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ), timestamp+1 );\n \n         final Id targetId2 = edge2.getTargetNode();\n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n \n-        serialization.writeEdge( scope, edge1, timestamp ).execute();\n-        serialization.writeEdge( scope, edge2, timestamp ).execute();\n+        serialization.writeEdge( scope, edge1, UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, edge2, UUIDGenerator.newTimeUUID() ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n \n@@ -385,23 +389,23 @@ public void idTypesPaging() throws ConnectionException {\n      */\n     @Test\n     public void delete() throws ConnectionException {\n-        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+        //we purposefully use the same timestamp\n+        final long timestamp = 1000l;\n+        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\", timestamp );\n \n         final Id sourceId = edge1.getSourceNode();\n         final Id targetId1 = edge1.getTargetNode();\n \n \n-        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ) );\n+        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ), timestamp );\n \n         final Id targetId2 = edge2.getTargetNode();\n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n-\n-        serialization.writeEdge( scope, edge1, timestamp ).execute();\n-        serialization.writeEdge( scope, edge2, timestamp ).execute();\n+        serialization.writeEdge( scope, edge1,  UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, edge2,  UUIDGenerator.newTimeUUID() ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n         Iterator<MarkedEdge> results = serialization.getEdgesFromSourceByTargetType( scope,\n@@ -494,23 +498,23 @@ public void delete() throws ConnectionException {\n      */\n     @Test\n     public void mark() throws ConnectionException {\n-        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\" );\n+        final long timestamp = 1000l;\n+        final MarkedEdge edge1 = createEdge( \"source\", \"edge\", \"target\", timestamp );\n \n         final Id sourceId = edge1.getSourceNode();\n         final Id targetId1 = edge1.getTargetNode();\n \n \n-        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ) );\n+        final MarkedEdge edge2 = createEdge( sourceId, \"edge\", createId( \"target\" ), timestamp+1 );\n \n         final Id targetId2 = edge2.getTargetNode();\n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n \n-        serialization.writeEdge( scope, edge1, timestamp ).execute();\n-        serialization.writeEdge( scope, edge2, timestamp ).execute();\n+        serialization.writeEdge( scope, edge1,  UUIDGenerator.newTimeUUID() ).execute();\n+        serialization.writeEdge( scope, edge2,  UUIDGenerator.newTimeUUID() ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n         Iterator<MarkedEdge> results = serialization.getEdgesFromSourceByTargetType( scope,\n@@ -557,10 +561,10 @@ public void mark() throws ConnectionException {\n         //now we've validated everything exists, lets blitz the data and ensure it's removed\n \n         final MarkedEdge mark1 =\n-                createEdge( edge1.getSourceNode(), edge1.getType(), edge1.getTargetNode(), edge1.getVersion(), true );\n+                createEdge( edge1.getSourceNode(), edge1.getType(), edge1.getTargetNode(), edge1.getTimestamp(), true );\n \n         final MarkedEdge mark2 =\n-                createEdge( edge2.getSourceNode(), edge2.getType(), edge2.getTargetNode(), edge2.getVersion(), true );\n+                createEdge( edge2.getSourceNode(), edge2.getType(), edge2.getTargetNode(), edge2.getTimestamp(), true );\n \n \n         final UUID timestamp2 = UUIDGenerator.newTimeUUID();\n@@ -662,23 +666,23 @@ public void pageIteration() throws ConnectionException {\n         Set<Edge> edges = new HashSet<Edge>( size );\n \n \n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n+       long timestamp = 0;\n \n         for ( int i = 0; i < size; i++ ) {\n-            final MarkedEdge edge = createEdge( sourceId, type, createId( \"target\" ) );\n+            final MarkedEdge edge = createEdge( sourceId, type, createId( \"target\" ), timestamp );\n \n-            serialization.writeEdge( scope, edge, timestamp ).execute();\n+            serialization.writeEdge( scope, edge, UUIDGenerator.newTimeUUID() ).execute();\n             edges.add( edge );\n-        }\n \n+            timestamp++;\n+        }\n \n-        UUID now = UUIDGenerator.newTimeUUID();\n \n         //get our edges out by name\n         Iterator<MarkedEdge> results =\n-                serialization.getEdgesFromSource( scope, createSearchByEdge( sourceId, type, now, null ) );\n+                serialization.getEdgesFromSource( scope, createSearchByEdge( sourceId, type, timestamp, null ) );\n \n-        for ( MarkedEdge edge : new IterableWrapper<MarkedEdge>( results ) ) {\n+        for ( MarkedEdge edge : new IterableWrapper<>( results ) ) {\n             assertTrue( \"Removed edge from write set\", edges.remove( edge ) );\n         }\n \n@@ -704,48 +708,47 @@ public void testIteratorPaging() throws ConnectionException {\n \n         final MutationBatch batch = keyspace.prepareMutationBatch();\n \n-        UUID lastMax = null;\n-\n-        final UUID timestamp = UUIDGenerator.newTimeUUID();\n+        long timestamp = 10000l;\n \n         for ( int i = 0; i < writeCount; i++ ) {\n \n-            final MarkedEdge edge = createEdge( sourceId, edgeType, targetId );\n+            final MarkedEdge edge = createEdge( sourceId, edgeType, targetId, timestamp );\n \n-            lastMax = edge.getVersion();\n+            batch.mergeShallow( serialization.writeEdge( scope, edge, UUIDGenerator.newTimeUUID() ) );\n \n-            batch.mergeShallow( serialization.writeEdge( scope, edge, timestamp ) );\n+            //increment timestamp (not done inline on purpose) If we do System.currentMillis we get the same edge on fast systems\n+            timestamp++;\n         }\n \n         log.info( \"Flushing edges\" );\n         batch.execute();\n \n \n         Iterator<MarkedEdge> results =\n-                serialization.getEdgeVersions( scope, createGetByEdge( sourceId, edgeType, targetId, lastMax, null ) );\n+                serialization.getEdgeVersions( scope, createGetByEdge( sourceId, edgeType, targetId, timestamp, null ) );\n \n         verify( results, writeCount );\n \n \n         //get them all from source\n-        results = serialization.getEdgesFromSource( scope, createSearchByEdge( sourceId, edgeType, lastMax, null ) );\n+        results = serialization.getEdgesFromSource( scope, createSearchByEdge( sourceId, edgeType, timestamp, null ) );\n \n         verify( results, writeCount );\n \n \n         results = serialization.getEdgesFromSourceByTargetType( scope,\n-                createSearchByEdgeAndId( sourceId, edgeType, lastMax, targetId.getType(), null ) );\n+                createSearchByEdgeAndId( sourceId, edgeType, timestamp, targetId.getType(), null ) );\n \n         verify( results, writeCount );\n \n \n-        results = serialization.getEdgesToTarget( scope, createSearchByEdge( targetId, edgeType, lastMax, null ) );\n+        results = serialization.getEdgesToTarget( scope, createSearchByEdge( targetId, edgeType, timestamp, null ) );\n \n         verify( results, writeCount );\n \n \n         results = serialization.getEdgesToTargetBySourceType( scope,\n-                createSearchByEdgeAndId( targetId, edgeType, lastMax, sourceId.getType(), null ) );\n+                createSearchByEdgeAndId( targetId, edgeType, timestamp, sourceId.getType(), null ) );\n \n         verify( results, writeCount );\n     }\n@@ -771,7 +774,7 @@ public void successiveWriteReturnSource() throws ConnectionException {\n         serialization.writeEdge( scope, edge1, timestamp2 ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n \n@@ -862,7 +865,7 @@ public void successiveWriteReturnTarget() throws ConnectionException {\n         serialization.writeEdge( scope, edge1, timestamp2 ).execute();\n \n \n-        UUID now = UUIDGenerator.newTimeUUID();\n+        long now = System.currentTimeMillis();\n \n         //get our edges out by name\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/EdgeSerializationTest.java",
                "sha": "9c29d56b6eb66e67444971754aa2de7364493e93",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/NodeSerializationTest.java",
                "changes": 28,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/NodeSerializationTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 14,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/NodeSerializationTest.java",
                "patch": "@@ -87,13 +87,13 @@ public void setup() {\n     public void writeReadDelete() throws ConnectionException {\n \n         final Id nodeId = createId( \"test\" );\n-        final UUID version = UUIDGenerator.newTimeUUID();\n+        final long version = System.currentTimeMillis();\n \n         serialization.mark( scope, nodeId, version ).execute();\n \n-        Optional<UUID> returned = serialization.getMaxVersion( scope, nodeId );\n+        Optional<Long> returned = serialization.getMaxVersion( scope, nodeId );\n \n-        assertEquals( version, returned.get() );\n+        assertEquals( version, returned.get().longValue() );\n \n         serialization.delete( scope, nodeId, returned.get() ).execute();\n \n@@ -114,7 +114,7 @@ public void noDeleteVersion() {\n \n         final Id nodeId = createId( \"test\" );\n \n-        Optional<UUID> returned = serialization.getMaxVersion( scope, nodeId );\n+        Optional<Long>returned = serialization.getMaxVersion( scope, nodeId );\n \n         /**\n          * Verifies we didnt' get anything back when nothing has been marked\n@@ -130,14 +130,14 @@ public void noDeleteVersion() {\n     public void oldVersionDiscarded() throws ConnectionException {\n \n         final Id nodeId = createId( \"test\" );\n-        final UUID version1 = UUIDGenerator.newTimeUUID();\n-        final UUID version2 = UUIDGenerator.newTimeUUID();\n+        final long version1 = System.currentTimeMillis();\n+        final long version2 = version1+1;\n \n         serialization.mark( scope, nodeId, version2 ).execute();\n \n-        Optional<UUID> returned = serialization.getMaxVersion( scope, nodeId );\n+        Optional<Long>returned = serialization.getMaxVersion( scope, nodeId );\n \n-        assertEquals( version2, returned.get() );\n+        assertEquals( version2, returned.get().longValue() );\n \n         //now write version1, it should be discarded\n \n@@ -148,14 +148,14 @@ public void oldVersionDiscarded() throws ConnectionException {\n         /**\n          * Verifies that it is deleted\n          */\n-        assertEquals( version2, returned.get() );\n+        assertEquals( version2, returned.get().longValue() );\n \n         //perform a delete with v1, we shouldn't lose the column\n         serialization.delete( scope, nodeId, version1 ).execute();\n \n         returned = serialization.getMaxVersion( scope, nodeId );\n \n-        assertEquals( version2, returned.get() );\n+        assertEquals( version2, returned.get().longValue() );\n \n         //now delete v2\n         serialization.delete( scope, nodeId, version2 ).execute();\n@@ -177,17 +177,17 @@ public void multiGet() throws ConnectionException {\n         final Id nodeId3 = createId( \"test\" );\n \n \n-        final UUID version = UUIDGenerator.newTimeUUID();\n+        final long version = System.currentTimeMillis();\n \n         serialization.mark( scope, nodeId1, version ).execute();\n         serialization.mark( scope, nodeId2, version ).execute();\n \n-        Map<Id, UUID> marks = serialization.getMaxVersions( scope,\n+        Map<Id, Long> marks = serialization.getMaxVersions( scope,\n                 Arrays.asList( createEdge( nodeId1, \"test\", nodeId2 ), createEdge( nodeId2, \"test\", nodeId3 ) ) );\n \n \n-        assertEquals( version, marks.get( nodeId1 ) );\n-        assertEquals( version, marks.get( nodeId2 ) );\n+        assertEquals( version, marks.get( nodeId1 ).longValue() );\n+        assertEquals( version, marks.get( nodeId2 ).longValue() );\n         assertFalse( marks.containsKey( nodeId3 ) );\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/NodeSerializationTest.java",
                "sha": "a731bab61751cd255abaab37ddd81eefc9855850",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImplComparatorTest.java",
                "changes": 32,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImplComparatorTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 11,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImplComparatorTest.java",
                "patch": "@@ -67,7 +67,7 @@ public void testDifferentTargetSourceEdges() {\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), createId( \"target\" ),\n-                        first.edge.getVersion() ), edgeSerialization );\n+                        first.edge.getTimestamp() ), edgeSerialization );\n \n \n         int compare = new MergedEdgeReaderImpl.SourceEdgeComparator( edgeSerialization ).compare( first, second );\n@@ -78,14 +78,17 @@ public void testDifferentTargetSourceEdges() {\n \n     @Test\n     public void testDifferentVersionSourceEdges() {\n+        final long firstTime = 1000l;\n+               final long secondTime = firstTime +1;\n+\n \n         MergedEdgeReaderImpl.SourceAwareMarkedEdge first =\n-                new MergedEdgeReaderImpl.SourceAwareMarkedEdge( createEdge( \"source\", \"edge\", \"target\" ),\n+                new MergedEdgeReaderImpl.SourceAwareMarkedEdge( createEdge( \"source\", \"edge\", \"target\", firstTime ),\n                         edgeSerialization );\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), first.edge.getTargetNode(),\n-                        UUIDGenerator.newTimeUUID() ), edgeSerialization );\n+                       secondTime), edgeSerialization );\n \n \n         int compare = new MergedEdgeReaderImpl.SourceEdgeComparator( edgeSerialization ).compare( first, second );\n@@ -105,7 +108,7 @@ public void testDifferentSourceIteratorsSourceEdges() {\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), first.edge.getTargetNode(),\n-                        first.edge.getVersion() ), other );\n+                        first.edge.getTimestamp() ), other );\n \n         MergedEdgeReaderImpl.SourceEdgeComparator comparator =\n                 new MergedEdgeReaderImpl.SourceEdgeComparator( edgeSerialization );\n@@ -146,7 +149,7 @@ public void testDifferentTargetTargetEdges() {\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( createId( \"source\" ), first.edge.getType(), first.edge.getTargetNode(),\n-                        first.edge.getVersion() ), edgeSerialization );\n+                        first.edge.getTimestamp() ), edgeSerialization );\n         ;\n \n \n@@ -159,13 +162,17 @@ public void testDifferentTargetTargetEdges() {\n     @Test\n     public void testDifferentVersionTargetEdges() {\n \n+        final long firstTime = 1000l;\n+                      final long secondTime = firstTime +1;\n+\n+\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge first =\n-                new MergedEdgeReaderImpl.SourceAwareMarkedEdge( createEdge( \"source\", \"edge\", \"target\" ),\n+                new MergedEdgeReaderImpl.SourceAwareMarkedEdge( createEdge( \"source\", \"edge\", \"target\", firstTime),\n                         edgeSerialization );\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), first.edge.getTargetNode(),\n-                        UUIDGenerator.newTimeUUID() ), edgeSerialization );\n+                        secondTime ), edgeSerialization );\n \n \n         int compare = new MergedEdgeReaderImpl.TargetEdgeComparator( edgeSerialization ).compare( first, second );\n@@ -185,7 +192,7 @@ public void testDifferentDeleteTargetEdges() {\n \n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), first.edge.getTargetNode(),\n-                        first.edge.getVersion() ), other );\n+                        first.edge.getTimestamp() ), other );\n \n         MergedEdgeReaderImpl.TargetEdgeComparator comparator =\n                 new MergedEdgeReaderImpl.TargetEdgeComparator( edgeSerialization );\n@@ -203,13 +210,16 @@ public void testDifferentDeleteTargetEdges() {\n     @Test\n     public void testDifferentVersion() {\n \n+        final long firstTime = 1000l;\n+        final long secondTime = firstTime +1;\n+\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge first =\n-                new MergedEdgeReaderImpl.SourceAwareMarkedEdge( createEdge( \"source\", \"edge\", \"target\" ),\n+                new MergedEdgeReaderImpl.SourceAwareMarkedEdge( createEdge( \"source\", \"edge\", \"target\", firstTime),\n                         edgeSerialization );\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), first.edge.getTargetNode(),\n-                        UUIDGenerator.newTimeUUID() ), edgeSerialization );\n+                       secondTime ), edgeSerialization );\n \n         int compare = new MergedEdgeReaderImpl.EdgeVersionComparator( edgeSerialization ).compare( first, second );\n \n@@ -228,7 +238,7 @@ public void testDifferentMark() {\n         //same as first, just with large target node\n         MergedEdgeReaderImpl.SourceAwareMarkedEdge second = new MergedEdgeReaderImpl.SourceAwareMarkedEdge(\n                 createEdge( first.edge.getSourceNode(), first.edge.getType(), first.edge.getTargetNode(),\n-                        first.edge.getVersion() ), otherSerialization );\n+                        first.edge.getTimestamp() ), otherSerialization );\n \n         MergedEdgeReaderImpl.EdgeVersionComparator comparator =\n                 new MergedEdgeReaderImpl.EdgeVersionComparator( edgeSerialization );",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderImplComparatorTest.java",
                "sha": "3e467c124a01a855625ac1afe19777e38afb7fa7",
                "status": "modified"
            },
            {
                "additions": 101,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderTest.java",
                "changes": 170,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 69,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderTest.java",
                "patch": "@@ -34,8 +34,6 @@\n import org.apache.usergrid.persistence.model.entity.Id;\n import org.apache.usergrid.persistence.model.util.UUIDGenerator;\n \n-import com.fasterxml.uuid.UUIDComparator;\n-\n import static org.apache.usergrid.persistence.graph.test.util.EdgeTestUtils.createEdge;\n import static org.apache.usergrid.persistence.graph.test.util.EdgeTestUtils.createId;\n import static org.apache.usergrid.persistence.graph.test.util.EdgeTestUtils.createSearchByEdge;\n@@ -83,24 +81,29 @@ public void testOrderedMergeSource() {\n         final Id sourceId = createId( \"source\" );\n         final String type = \"test\";\n \n+        final long timestamp1 = 1000l;\n+        final long timestamp2 = timestamp1 + 100l;\n+        final long timestamp3 = timestamp2 + 100l;\n+        final long timestamp4 = timestamp3 + 100l;\n+\n \n-        MarkedEdge commitLogEdge1 = createEdge( sourceId, type, createId( \"target1\" ) );\n-        MarkedEdge storageEdge1 = createEdge( sourceId, type, createId( \"target2\" ) );\n-        MarkedEdge commitLogEdge2 = createEdge( sourceId, type, createId( \"target3\" ) );\n-        MarkedEdge storageEdge2 = createEdge( sourceId, type, createId( \"target4\" ) );\n+        MarkedEdge commitLogEdge1 = createEdge( sourceId, type, createId( \"target1\" ), timestamp1 );\n+        MarkedEdge storageEdge1 = createEdge( sourceId, type, createId( \"target2\" ), timestamp2 );\n+        MarkedEdge commitLogEdge2 = createEdge( sourceId, type, createId( \"target3\" ), timestamp3 );\n+        MarkedEdge storageEdge2 = createEdge( sourceId, type, createId( \"target4\" ), timestamp4 );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( storageEdge1.getVersion(), commitLogEdge2.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( storageEdge1.getTimestamp(), commitLogEdge2.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) < 0 );\n \n-        SearchByEdgeType searchByEdgeType = createSearchByEdge( sourceId, type, UUIDGenerator.newTimeUUID(), null );\n+        SearchByEdgeType searchByEdgeType = createSearchByEdge( sourceId, type, System.currentTimeMillis(), null );\n \n         /**\n          * Mock up the commit log\n          */\n         when( commitLog.getEdgesFromSource( scope, searchByEdgeType ) )\n-                .thenReturn( Arrays.asList( commitLogEdge2, commitLogEdge1).iterator() );\n+                .thenReturn( Arrays.asList( commitLogEdge2, commitLogEdge1 ).iterator() );\n \n         /**\n          * Mock up the storage\n@@ -136,16 +139,20 @@ public void testOrderedMergeSourceDeleted() {\n         final String type = \"test\";\n \n \n-        MarkedEdge commitLogEdge1 = createEdge( sourceId, type, createId( \"target\" ), UUIDGenerator.newTimeUUID(), true );\n-        MarkedEdge storageEdge1 =   createEdge( sourceId, type, commitLogEdge1.getTargetNode(), commitLogEdge1.getVersion(), false );\n-        MarkedEdge commitLogEdge2 =  createEdge( sourceId, type, createId( \"target\" ), UUIDGenerator.newTimeUUID(), true );\n-        MarkedEdge storageEdge2 =  createEdge( sourceId, type, commitLogEdge2.getTargetNode(), commitLogEdge2.getVersion(), false );\n+        MarkedEdge commitLogEdge1 =\n+                createEdge( sourceId, type, createId( \"target\" ), System.currentTimeMillis(), true );\n+        MarkedEdge storageEdge1 =\n+                createEdge( sourceId, type, commitLogEdge1.getTargetNode(), commitLogEdge1.getTimestamp(), false );\n+        MarkedEdge commitLogEdge2 =\n+                createEdge( sourceId, type, createId( \"target\" ), System.currentTimeMillis(), true );\n+        MarkedEdge storageEdge2 =\n+                createEdge( sourceId, type, commitLogEdge2.getTargetNode(), commitLogEdge2.getTimestamp(), false );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) ==  0 );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) == 0 );\n \n-        SearchByEdgeType searchByEdgeType = createSearchByEdge( sourceId, type, UUIDGenerator.newTimeUUID(), null );\n+        SearchByEdgeType searchByEdgeType = createSearchByEdge( sourceId, type, System.currentTimeMillis(), null );\n \n         /**\n          * Mock up the commit log\n@@ -182,18 +189,23 @@ public void testOrderedMergeSourceTargetType() {\n         final String type = \"test\";\n         final String targetIdType = \"target\";\n \n-        MarkedEdge commitLogEdge1 = createEdge( sourceId, type, createId( targetIdType ) );\n-        MarkedEdge storageEdge1 = createEdge( sourceId, type, createId( targetIdType ) );\n-        MarkedEdge commitLogEdge2 = createEdge( sourceId, type, createId( targetIdType ) );\n-        MarkedEdge storageEdge2 = createEdge( sourceId, type, createId( targetIdType ) );\n+        final long timestamp1 = 1000l;\n+        final long timestamp2 = timestamp1 + 100l;\n+        final long timestamp3 = timestamp2 + 100l;\n+        final long timestamp4 = timestamp3 + 100l;\n+\n+        MarkedEdge commitLogEdge1 = createEdge( sourceId, type, createId( targetIdType ), timestamp1 );\n+        MarkedEdge storageEdge1 = createEdge( sourceId, type, createId( targetIdType ), timestamp2 );\n+        MarkedEdge commitLogEdge2 = createEdge( sourceId, type, createId( targetIdType ), timestamp3 );\n+        MarkedEdge storageEdge2 = createEdge( sourceId, type, createId( targetIdType ), timestamp4 );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( storageEdge1.getVersion(), commitLogEdge2.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( storageEdge1.getTimestamp(), commitLogEdge2.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) < 0 );\n \n         SearchByIdType searchByEdgeType =\n-                createSearchByEdgeAndId( sourceId, type, UUIDGenerator.newTimeUUID(), targetIdType, null );\n+                createSearchByEdgeAndId( sourceId, type, System.currentTimeMillis(), targetIdType, null );\n \n         /**\n          * Mock up the commit log\n@@ -221,6 +233,7 @@ public void testOrderedMergeSourceTargetType() {\n         assertFalse( marked.hasNext() );\n     }\n \n+\n     @Test\n     public void testOrderedMergeSourceTargetTypeDeleted() {\n \n@@ -232,17 +245,21 @@ public void testOrderedMergeSourceTargetTypeDeleted() {\n         final String type = \"test\";\n         final String targetIdType = \"target\";\n \n-        MarkedEdge commitLogEdge1 = createEdge( sourceId, type, createId( targetIdType ), UUIDGenerator.newTimeUUID(), true );\n-        MarkedEdge storageEdge1 = createEdge( sourceId, type, commitLogEdge1.getTargetNode(), commitLogEdge1.getVersion(), false );\n-        MarkedEdge commitLogEdge2 = createEdge( sourceId, type, createId( targetIdType ) , UUIDGenerator.newTimeUUID(), true);\n-        MarkedEdge storageEdge2 = createEdge( sourceId, type, commitLogEdge2.getTargetNode(), commitLogEdge2.getVersion(), false );\n+        MarkedEdge commitLogEdge1 =\n+                createEdge( sourceId, type, createId( targetIdType ), System.currentTimeMillis(), true );\n+        MarkedEdge storageEdge1 =\n+                createEdge( sourceId, type, commitLogEdge1.getTargetNode(), commitLogEdge1.getTimestamp(), false );\n+        MarkedEdge commitLogEdge2 =\n+                createEdge( sourceId, type, createId( targetIdType ), System.currentTimeMillis(), true );\n+        MarkedEdge storageEdge2 =\n+                createEdge( sourceId, type, commitLogEdge2.getTargetNode(), commitLogEdge2.getTimestamp(), false );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) == 0  );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) == 0 );\n \n         SearchByIdType searchByEdgeType =\n-                createSearchByEdgeAndId( sourceId, type, UUIDGenerator.newTimeUUID(), targetIdType, null );\n+                createSearchByEdgeAndId( sourceId, type, System.currentTimeMillis(), targetIdType, null );\n \n         /**\n          * Mock up the commit log\n@@ -268,9 +285,6 @@ public void testOrderedMergeSourceTargetTypeDeleted() {\n     }\n \n \n-\n-\n-\n     @Test\n     public void testOrderedMergeTarget() {\n \n@@ -281,18 +295,22 @@ public void testOrderedMergeTarget() {\n         final Id targetId = createId( \"target\" );\n         final String type = \"test\";\n \n+        final long timestamp1 = 1000l;\n+        final long timestamp2 = timestamp1 + 100l;\n+        final long timestamp3 = timestamp2 + 100l;\n+        final long timestamp4 = timestamp3 + 100l;\n \n-        MarkedEdge commitLogEdge1 = createEdge( createId( \"source\" ), type, targetId );\n-        MarkedEdge storageEdge1 = createEdge( createId( \"source\" ), type, targetId );\n-        MarkedEdge commitLogEdge2 = createEdge( createId( \"source\" ), type, targetId );\n-        MarkedEdge storageEdge2 = createEdge( createId( \"source\" ), type, targetId );\n+        MarkedEdge commitLogEdge1 = createEdge( createId( \"source\" ), type, targetId, timestamp1 );\n+        MarkedEdge storageEdge1 = createEdge( createId( \"source\" ), type, targetId, timestamp2 );\n+        MarkedEdge commitLogEdge2 = createEdge( createId( \"source\" ), type, targetId, timestamp3 );\n+        MarkedEdge storageEdge2 = createEdge( createId( \"source\" ), type, targetId, timestamp4 );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( storageEdge1.getVersion(), commitLogEdge2.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( storageEdge1.getTimestamp(), commitLogEdge2.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) < 0 );\n \n-        SearchByEdgeType searchByEdgeType = createSearchByEdge( targetId, type, UUIDGenerator.newTimeUUID(), null );\n+        SearchByEdgeType searchByEdgeType = createSearchByEdge( targetId, type, System.currentTimeMillis(), null );\n \n         /**\n          * Mock up the commit log\n@@ -333,19 +351,24 @@ public void testOrderedMergeTargetDeleted() {\n         final Id targetId = createId( \"target\" );\n         final String type = \"test\";\n \n+        final long timestamp1 = 1000l;\n+              final long timestamp2 = timestamp1 + 100l;\n+\n \n         MarkedEdge commitLogEdge1 =\n-                createEdge( createId( \"source\" ), type, targetId, UUIDGenerator.newTimeUUID(), true );\n-        MarkedEdge storageEdge1 = createEdge( commitLogEdge1.getSourceNode(), type, commitLogEdge1.getTargetNode(), commitLogEdge1.getVersion(), false );\n+                createEdge( createId( \"source\" ), type, targetId, timestamp1, true );\n+        MarkedEdge storageEdge1 = createEdge( commitLogEdge1.getSourceNode(), type, commitLogEdge1.getTargetNode(),\n+                commitLogEdge1.getTimestamp(), false );\n         MarkedEdge commitLogEdge2 =\n-                createEdge( createId( \"source\" ), type, targetId, UUIDGenerator.newTimeUUID(), true );\n-        MarkedEdge storageEdge2 = createEdge( commitLogEdge2.getSourceNode(), type, commitLogEdge2.getTargetNode(), commitLogEdge2.getVersion(), false );\n+                createEdge( createId( \"source\" ), type, targetId, timestamp2, true );\n+        MarkedEdge storageEdge2 = createEdge( commitLogEdge2.getSourceNode(), type, commitLogEdge2.getTargetNode(),\n+                commitLogEdge2.getTimestamp(), false );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) ==  0 );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) == 0 );\n \n-        SearchByEdgeType searchByEdgeType = createSearchByEdge( targetId, type, UUIDGenerator.newTimeUUID(), null );\n+        SearchByEdgeType searchByEdgeType = createSearchByEdge( targetId, type, System.currentTimeMillis(), null );\n \n         /**\n          * Mock up the commit log\n@@ -383,18 +406,24 @@ public void testOrderedMergeTargetSourceType() {\n         final String type = \"test\";\n         final String sourceIdType = \"source\";\n \n-        MarkedEdge commitLogEdge1 = createEdge( createId( sourceIdType), type, targetId );\n-        MarkedEdge storageEdge1 = createEdge( createId( sourceIdType ), type, targetId );\n-        MarkedEdge commitLogEdge2 = createEdge( createId( sourceIdType), type, targetId );\n-        MarkedEdge storageEdge2 = createEdge( createId( sourceIdType ), type, targetId );\n+        final long timestamp1 = 1000l;\n+        final long timestamp2 = timestamp1 + 100l;\n+        final long timestamp3 = timestamp2 + 100l;\n+        final long timestamp4 = timestamp3 + 100l;\n+\n+\n+        MarkedEdge commitLogEdge1 = createEdge( createId( sourceIdType ), type, targetId, timestamp1 );\n+        MarkedEdge storageEdge1 = createEdge( createId( sourceIdType ), type, targetId, timestamp2 );\n+        MarkedEdge commitLogEdge2 = createEdge( createId( sourceIdType ), type, targetId, timestamp3 );\n+        MarkedEdge storageEdge2 = createEdge( createId( sourceIdType ), type, targetId, timestamp4 );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( storageEdge1.getVersion(), commitLogEdge2.getVersion() ) < 0 );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( storageEdge1.getTimestamp(), commitLogEdge2.getTimestamp() ) < 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) < 0 );\n \n         SearchByIdType searchByEdgeType =\n-                createSearchByEdgeAndId( targetId, type, UUIDGenerator.newTimeUUID(), sourceIdType, null );\n+                createSearchByEdgeAndId( targetId, type, System.currentTimeMillis(), sourceIdType, null );\n \n         /**\n          * Mock up the commit log\n@@ -415,8 +444,6 @@ public void testOrderedMergeTargetSourceType() {\n                 read.getEdgesToTargetBySourceType( scope, searchByEdgeType ).toBlockingObservable().getIterator();\n \n \n-\n-\n         assertEquals( storageEdge2, marked.next() );\n         assertEquals( commitLogEdge2, marked.next() );\n         assertEquals( storageEdge1, marked.next() );\n@@ -425,6 +452,7 @@ public void testOrderedMergeTargetSourceType() {\n         assertFalse( marked.hasNext() );\n     }\n \n+\n     @Test\n     public void testOrderedMergeTargetSourceTypeDeleted() {\n \n@@ -436,17 +464,22 @@ public void testOrderedMergeTargetSourceTypeDeleted() {\n         final String type = \"test\";\n         final String sourceIdType = \"target\";\n \n-        MarkedEdge commitLogEdge1 = createEdge( createId( sourceIdType), type, targetId, UUIDGenerator.newTimeUUID(), true );\n-        MarkedEdge storageEdge1 = createEdge( commitLogEdge1.getSourceNode(), type, commitLogEdge1.getTargetNode(), commitLogEdge1.getVersion(), false );\n-        MarkedEdge commitLogEdge2 = createEdge( createId( sourceIdType), type, targetId , UUIDGenerator.newTimeUUID(), true);\n-        MarkedEdge storageEdge2 = createEdge( commitLogEdge2.getSourceNode(), type, commitLogEdge2.getTargetNode(), commitLogEdge2.getVersion(), false );\n+        final long timestamp1 = 10000l;\n+        final long timestamp2 = timestamp1 + 100;\n+\n+        MarkedEdge commitLogEdge1 = createEdge( createId( sourceIdType ), type, targetId, timestamp1, true );\n+        MarkedEdge storageEdge1 = createEdge( commitLogEdge1.getSourceNode(), type, commitLogEdge1.getTargetNode(),\n+                commitLogEdge1.getTimestamp(), false );\n+        MarkedEdge commitLogEdge2 = createEdge( createId( sourceIdType ), type, targetId, timestamp2, true );\n+        MarkedEdge storageEdge2 = createEdge( commitLogEdge2.getSourceNode(), type, commitLogEdge2.getTargetNode(),\n+                commitLogEdge2.getTimestamp(), false );\n \n         //verify our versions are as expected\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge1.getVersion(), storageEdge1.getVersion() ) == 0  );\n-        assertTrue( UUIDComparator.staticCompare( commitLogEdge2.getVersion(), storageEdge2.getVersion() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge1.getTimestamp(), storageEdge1.getTimestamp() ) == 0 );\n+        assertTrue( Long.compare( commitLogEdge2.getTimestamp(), storageEdge2.getTimestamp() ) == 0 );\n \n         SearchByIdType searchByEdgeType =\n-                createSearchByEdgeAndId( targetId, type, UUIDGenerator.newTimeUUID(), sourceIdType, null );\n+                createSearchByEdgeAndId( targetId, type, System.currentTimeMillis(), sourceIdType, null );\n \n         /**\n          * Mock up the commit log\n@@ -471,5 +504,4 @@ public void testOrderedMergeTargetSourceTypeDeleted() {\n \n         assertFalse( marked.hasNext() );\n     }\n-\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/MergedEdgeReaderTest.java",
                "sha": "d54349a5ab67b134bfd6a2aea1d7013577bb051b",
                "status": "modified"
            },
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCacheTest.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCacheTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 13,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCacheTest.java",
                "patch": "@@ -83,7 +83,7 @@ public void testNoShards() throws ConnectionException {\n         final String otherIdType = \"type\";\n \n \n-        UUID newTime = UUIDGenerator.newTimeUUID();\n+        final long newTime = 10000l;\n \n \n         NodeShardCache cache = new NodeShardCacheImpl( allocation, graphFig );\n@@ -128,7 +128,7 @@ public void testSingleExistingShard() {\n         final String otherIdType = \"type\";\n \n \n-        UUID newTime = UUIDGenerator.newTimeUUID();\n+        final long newTime = 10000l;\n \n         final long min = 0;\n \n@@ -196,54 +196,54 @@ public void testRangeShard() {\n \n         //check getting equal to our min, mid and max\n \n-        long slice = cache.getSlice( scope, id, EdgeTestUtils.setTimestamp(min), edgeType, otherIdType );\n+        long slice = cache.getSlice( scope, id, min, edgeType, otherIdType );\n \n \n         //we return the min UUID possible, all edges should start by writing to this edge\n         assertEquals( min, slice );\n \n-        slice = cache.getSlice( scope, id, EdgeTestUtils.setTimestamp(mid),\n+        slice = cache.getSlice( scope, id, mid,\n                 edgeType, otherIdType );\n \n \n         //we return the mid UUID possible, all edges should start by writing to this edge\n         assertEquals( mid, slice );\n \n-        slice = cache.getSlice( scope, id, EdgeTestUtils.setTimestamp(max) ,\n+        slice = cache.getSlice( scope, id, max ,\n                 edgeType, otherIdType );\n \n \n         //we return the mid UUID possible, all edges should start by writing to this edge\n         assertEquals( max, slice );\n \n         //now test in between\n-        slice = cache.getSlice( scope, id, EdgeTestUtils.setTimestamp( min+1 ), edgeType, otherIdType );\n+        slice = cache.getSlice( scope, id, min+1, edgeType, otherIdType );\n \n \n         //we return the min UUID possible, all edges should start by writing to this edge\n         assertEquals( min, slice );\n \n-        slice = cache.getSlice( scope, id,  EdgeTestUtils.setTimestamp(  mid-1 ), edgeType, otherIdType );\n+        slice = cache.getSlice( scope, id,   mid-1, edgeType, otherIdType );\n \n \n         //we return the min UUID possible, all edges should start by writing to this edge\n         assertEquals( min, slice );\n \n \n-        slice = cache.getSlice( scope, id,  EdgeTestUtils.setTimestamp(  mid+1 ), edgeType, otherIdType );\n+        slice = cache.getSlice( scope, id,   mid+1, edgeType, otherIdType );\n \n \n         //we return the mid UUID possible, all edges should start by writing to this edge\n         assertEquals( mid, slice );\n \n-        slice = cache.getSlice( scope, id,  EdgeTestUtils.setTimestamp( max-1), edgeType, otherIdType );\n+        slice = cache.getSlice( scope, id,  max-1, edgeType, otherIdType );\n \n \n         //we return the mid UUID possible, all edges should start by writing to this edge\n         assertEquals( mid, slice );\n \n \n-        slice = cache.getSlice( scope, id,  EdgeTestUtils.setTimestamp(  max ), edgeType, otherIdType );\n+        slice = cache.getSlice( scope, id,   max, edgeType, otherIdType );\n \n \n         //we return the mid UUID possible, all edges should start by writing to this edge\n@@ -295,22 +295,22 @@ public void testRangeShardIterator() {\n         //check getting equal to our min, mid and max\n \n         Iterator<Long> slice =\n-                cache.getVersions( scope, id,  EdgeTestUtils.setTimestamp(  max ), edgeType, otherIdType );\n+                cache.getVersions( scope, id,   max, edgeType, otherIdType );\n \n \n         assertEquals( max, slice.next().longValue() );\n         assertEquals( mid, slice.next().longValue() );\n         assertEquals( min, slice.next().longValue() );\n \n \n-        slice = cache.getVersions( scope, id,  EdgeTestUtils.setTimestamp(  mid ),\n+        slice = cache.getVersions( scope, id,   mid,\n                 edgeType, otherIdType );\n \n         assertEquals( mid, slice.next().longValue() );\n         assertEquals( min, slice.next().longValue() );\n \n \n-        slice = cache.getVersions( scope, id,  EdgeTestUtils.setTimestamp(  min ),\n+        slice = cache.getVersions( scope, id,   min,\n                 edgeType, otherIdType );\n \n         assertEquals( min, slice.next().longValue() );",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/serialization/impl/shard/NodeShardCacheTest.java",
                "sha": "6c46c324c5d1423a56f499f7053716b580054bc8",
                "status": "modified"
            },
            {
                "additions": 124,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/test/util/EdgeTestUtils.java",
                "changes": 224,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/test/util/EdgeTestUtils.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 100,
                "filename": "stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/test/util/EdgeTestUtils.java",
                "patch": "@@ -67,10 +67,26 @@\n      * @return an Edge for testing\n      */\n     public static MarkedEdge createEdge( final String sourceType, final String edgeType, final String targetType ) {\n-        return createEdge( createId( sourceType ), edgeType, createId( targetType ), UUIDGenerator.newTimeUUID() );\n+        return createEdge( createId( sourceType ), edgeType, createId( targetType ), System.currentTimeMillis() );\n     }\n \n \n+    /**\n+     * Create an edge for testing\n+     *\n+     * @param sourceType The source type to use in the id\n+     * @param edgeType The edge type to use\n+     * @param targetType The target type to use\n+     * @param timestamp the edge's timestamp\n+     *\n+     * @return an Edge for testing\n+     */\n+    public static MarkedEdge createEdge( final String sourceType, final String edgeType, final String targetType, final long timestamp ) {\n+        return createEdge( createId( sourceType ), edgeType, createId( targetType ), timestamp );\n+    }\n+\n+\n+\n     /**\n      * Create an edge for testing\n      *\n@@ -82,7 +98,7 @@ public static MarkedEdge createEdge( final String sourceType, final String edgeT\n      */\n     public static MarkedEdge createMarkedEdge( final String sourceType, final String edgeType,\n                                                final String targetType ) {\n-        return createEdge( createId( sourceType ), edgeType, createId( targetType ), UUIDGenerator.newTimeUUID(),\n+        return createEdge( createId( sourceType ), edgeType, createId( targetType ), System.currentTimeMillis(),\n                 true );\n     }\n \n@@ -91,41 +107,49 @@ public static MarkedEdge createMarkedEdge( final String sourceType, final String\n      * Create an edge for testing\n      */\n     public static MarkedEdge createEdge( final Id sourceId, final String edgeType, final Id targetId ) {\n-        return createEdge( sourceId, edgeType, targetId, UUIDGenerator.newTimeUUID() );\n+        return createEdge( sourceId, edgeType, targetId, System.currentTimeMillis() );\n     }\n \n \n     /**\n      * Create an edge that is marked\n      */\n     public static MarkedEdge createMarkedEdge( final Id sourceId, final String edgeType, final Id targetId ) {\n-        return createEdge( sourceId, edgeType, targetId, UUIDGenerator.newTimeUUID(), true );\n+        return createEdge( sourceId, edgeType, targetId, System.currentTimeMillis(), true );\n     }\n \n \n+    /**\n+        * Create an edge that is marked\n+        */\n+       public static MarkedEdge createMarkedEdge( final Id sourceId, final String edgeType, final Id targetId, final long timestamp) {\n+           return createEdge( sourceId, edgeType, targetId, timestamp, true );\n+       }\n+\n+\n     /**\n      * Create an edge with the specified params\n      */\n     public static MarkedEdge createEdge( final Id sourceId, final String edgeType, final Id targetId,\n-                                         final UUID version ) {\n-        return createEdge( sourceId, edgeType, targetId, version, false );\n+                                         final long timestamp ) {\n+        return createEdge( sourceId, edgeType, targetId, timestamp, false );\n     }\n \n \n     /**\n      * Create an edge with the specified params\n      */\n     public static MarkedEdge createEdge( final Id sourceId, final String edgeType, final Id targetId,\n-                                         final UUID version, final boolean deleted ) {\n-        return new SimpleMarkedEdge( sourceId, edgeType, targetId, version, deleted );\n+                                         final long timestamp, final boolean deleted ) {\n+        return new SimpleMarkedEdge( sourceId, edgeType, targetId, timestamp, deleted );\n     }\n \n \n     /**\n      * Create the id\n      */\n     public static Id createId( String type ) {\n-        return createId( UUIDGenerator.newTimeUUID(), type );\n+        return createId(UUIDGenerator.newTimeUUID(), type );\n     }\n \n \n@@ -148,7 +172,7 @@ public static Id createId( UUID id, String type ) {\n      * @param last\n      * @return\n      */\n-    public static SearchByEdgeType createSearchByEdge( final Id sourceId, final String type, final UUID maxVersion,\n+    public static SearchByEdgeType createSearchByEdge( final Id sourceId, final String type, final long maxVersion,\n                                                        final Edge last ) {\n         return new SimpleSearchByEdgeType( sourceId, type, maxVersion, last );\n     }\n@@ -163,7 +187,7 @@ public static SearchByEdgeType createSearchByEdge( final Id sourceId, final Stri\n      * @param last\n      * @return\n      */\n-    public static SearchByIdType createSearchByEdgeAndId( final Id sourceId, final String type, final UUID maxVersion,\n+    public static SearchByIdType createSearchByEdgeAndId( final Id sourceId, final String type, final long maxVersion,\n                                                           final String idType, final Edge last ) {\n         return new SimpleSearchByIdType( sourceId, type, maxVersion, idType, last );\n     }\n@@ -192,98 +216,98 @@ public static SimpleSearchIdType createSearchIdType( final Id sourceId, final St\n      * Get the edge by type\n      */\n     public static SearchByEdge createGetByEdge( final Id sourceId, final String type, final Id targetId,\n-                                                final UUID maxVersion, final Edge last ) {\n+                                                final long maxVersion, final Edge last ) {\n         return new SimpleSearchByEdge( sourceId, type, targetId, maxVersion, last );\n     }\n \n-\n-    /**\n-     * NEVER USE THIS IN A REAL ENV.  Setting timestamps in anything but the present can result in collections Copied\n-     * from fasterxml uuid utils\n-     */\n-    public static UUID setTimestamp( long timestamp ) {\n-\n-        byte[] uuidBytes = new byte[16];\n-        EthernetAddress _ethernetAddress = EthernetAddress.constructMulticastAddress();\n-        _ethernetAddress.toByteArray( uuidBytes, 10 );\n-        // and add clock sequence\n-        int clockSeq = timer.getClockSequence();\n-        uuidBytes[UUIDUtil.BYTE_OFFSET_CLOCK_SEQUENCE] = ( byte ) ( clockSeq >> 8 );\n-        uuidBytes[UUIDUtil.BYTE_OFFSET_CLOCK_SEQUENCE + 1] = ( byte ) clockSeq;\n-        long l2 = gatherLong( uuidBytes, 8 );\n-        long _uuidL2 = UUIDUtil.initUUIDSecondLong( l2 );\n-\n-\n-        final long rawTimestamp = timestamp;\n-        // Time field components are kind of shuffled, need to slice:\n-        int clockHi = ( int ) ( rawTimestamp >>> 32 );\n-        int clockLo = ( int ) rawTimestamp;\n-        // and dice\n-        int midhi = ( clockHi << 16 ) | ( clockHi >>> 16 );\n-        // need to squeeze in type (4 MSBs in byte 6, clock hi)\n-        midhi &= ~0xF000; // remove high nibble of 6th byte\n-        midhi |= 0x1000; // type 1\n-        long midhiL = ( long ) midhi;\n-        midhiL = ( ( midhiL << 32 ) >>> 32 ); // to get rid of sign extension\n-        // and reconstruct\n-        long l1 = ( ( ( long ) clockLo ) << 32 ) | midhiL;\n-        // last detail: must force 2 MSB to be '10'\n-        return new UUID( l1, _uuidL2 );\n-    }\n-\n-    /*\n-    /********************************************************************************\n-    /* Internal helper methods\n-    /********************************************************************************\n-     */\n-\n-\n-    protected final static long gatherLong( byte[] buffer, int offset ) {\n-        long hi = ( ( long ) _gatherInt( buffer, offset ) ) << 32;\n-        //long lo = ((long) _gatherInt(buffer, offset+4)) & MASK_LOW_INT;\n-        long lo = ( ( ( long ) _gatherInt( buffer, offset + 4 ) ) << 32 ) >>> 32;\n-        return hi | lo;\n-    }\n-\n-\n-    private final static int _gatherInt( byte[] buffer, int offset ) {\n-        return ( buffer[offset] << 24 ) | ( ( buffer[offset + 1] & 0xFF ) << 16 ) | ( ( buffer[offset + 2] & 0xFF )\n-                << 8 ) | ( buffer[offset + 3] & 0xFF );\n-    }\n-\n-\n-    private static final Random random = new Random();\n-    private static final UUIDTimer timer;\n-\n-\n-    /**\n-     * Lame, but required\n-     */\n-    static {\n-        try {\n-            timer = new UUIDTimer( random, new TimestampSynchronizer() {\n-                @Override\n-                protected long initialize() throws IOException {\n-                    return System.currentTimeMillis();\n-                }\n-\n-\n-                @Override\n-                protected void deactivate() throws IOException {\n-\n-                }\n-\n-\n-                @Override\n-                protected long update( final long now ) throws IOException {\n-                    return now;\n-                }\n-            } );\n-        }\n-        catch ( IOException e ) {\n-            throw new RuntimeException( \"Couldn't intialize timer\", e );\n-        }\n-    }\n+//\n+//    /**\n+//     * NEVER USE THIS IN A REAL ENV.  Setting timestamps in anything but the present can result in collections Copied\n+//     * from fasterxml uuid utils\n+//     */\n+//    public static UUID setTimestamp( long timestamp ) {\n+//\n+//        byte[] uuidBytes = new byte[16];\n+//        EthernetAddress _ethernetAddress = EthernetAddress.constructMulticastAddress();\n+//        _ethernetAddress.toByteArray( uuidBytes, 10 );\n+//        // and add clock sequence\n+//        int clockSeq = timer.getClockSequence();\n+//        uuidBytes[UUIDUtil.BYTE_OFFSET_CLOCK_SEQUENCE] = ( byte ) ( clockSeq >> 8 );\n+//        uuidBytes[UUIDUtil.BYTE_OFFSET_CLOCK_SEQUENCE + 1] = ( byte ) clockSeq;\n+//        long l2 = gatherLong( uuidBytes, 8 );\n+//        long _uuidL2 = UUIDUtil.initUUIDSecondLong( l2 );\n+//\n+//\n+//        final long rawTimestamp = timestamp;\n+//        // Time field components are kind of shuffled, need to slice:\n+//        int clockHi = ( int ) ( rawTimestamp >>> 32 );\n+//        int clockLo = ( int ) rawTimestamp;\n+//        // and dice\n+//        int midhi = ( clockHi << 16 ) | ( clockHi >>> 16 );\n+//        // need to squeeze in type (4 MSBs in byte 6, clock hi)\n+//        midhi &= ~0xF000; // remove high nibble of 6th byte\n+//        midhi |= 0x1000; // type 1\n+//        long midhiL = ( long ) midhi;\n+//        midhiL = ( ( midhiL << 32 ) >>> 32 ); // to get rid of sign extension\n+//        // and reconstruct\n+//        long l1 = ( ( ( long ) clockLo ) << 32 ) | midhiL;\n+//        // last detail: must force 2 MSB to be '10'\n+//        return new UUID( l1, _uuidL2 );\n+//    }\n+//\n+//    /*\n+//    /********************************************************************************\n+//    /* Internal helper methods\n+//    /********************************************************************************\n+//     */\n+//\n+//\n+//    protected final static long gatherLong( byte[] buffer, int offset ) {\n+//        long hi = ( ( long ) _gatherInt( buffer, offset ) ) << 32;\n+//        //long lo = ((long) _gatherInt(buffer, offset+4)) & MASK_LOW_INT;\n+//        long lo = ( ( ( long ) _gatherInt( buffer, offset + 4 ) ) << 32 ) >>> 32;\n+//        return hi | lo;\n+//    }\n+//\n+//\n+//    private final static int _gatherInt( byte[] buffer, int offset ) {\n+//        return ( buffer[offset] << 24 ) | ( ( buffer[offset + 1] & 0xFF ) << 16 ) | ( ( buffer[offset + 2] & 0xFF )\n+//                << 8 ) | ( buffer[offset + 3] & 0xFF );\n+//    }\n+//\n+//\n+//    private static final Random random = new Random();\n+//    private static final UUIDTimer timer;\n+//\n+//\n+//    /**\n+//     * Lame, but required\n+//     */\n+//    static {\n+//        try {\n+//            timer = new UUIDTimer( random, new TimestampSynchronizer() {\n+//                @Override\n+//                protected long initialize() throws IOException {\n+//                    return System.currentTimeMillis();\n+//                }\n+//\n+//\n+//                @Override\n+//                protected void deactivate() throws IOException {\n+//\n+//                }\n+//\n+//\n+//                @Override\n+//                protected long update( final long now ) throws IOException {\n+//                    return now;\n+//                }\n+//            } );\n+//        }\n+//        catch ( IOException e ) {\n+//            throw new RuntimeException( \"Couldn't intialize timer\", e );\n+//        }\n+//    }\n }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/graph/src/test/java/org/apache/usergrid/persistence/graph/test/util/EdgeTestUtils.java",
                "sha": "dd577ab51f7793af15931e02888ea51813e51d73",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/pom.xml",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/pom.xml?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 1,
                "filename": "stack/corepersistence/pom.xml",
                "patch": "@@ -26,7 +26,7 @@\n         <commons.collections.version>3.2.1</commons.collections.version>\n         <commons.io.version>2.4</commons.io.version>\n         <commons.lang.version>3.1</commons.lang.version>\n-        <elasticsearch.version>1.1.1</elasticsearch.version>\n+        <elasticsearch.version>1.2.0</elasticsearch.version>\n         <fasterxml-uuid.version>3.1.3</fasterxml-uuid.version>\n         <guava.version>15.0</guava.version>\n         <guice.version>3.0</guice.version>",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/pom.xml",
                "sha": "be8c445ab16d79becdd1883cf7c6dc6ecb643115",
                "status": "modified"
            },
            {
                "additions": 40,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsProvider.java",
                "changes": 81,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsProvider.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 41,
                "filename": "stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsProvider.java",
                "patch": "@@ -18,89 +18,88 @@\n  */\n package org.apache.usergrid.persistence.index.impl;\n \n-import com.google.inject.Inject;\n-import com.google.inject.Singleton;\n-import org.apache.usergrid.persistence.core.util.AvailablePortFinder;\n-import org.apache.usergrid.persistence.index.IndexFig;\n+\n import org.elasticsearch.client.Client;\n-import org.elasticsearch.client.transport.TransportClient;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.transport.InetSocketTransportAddress;\n import org.elasticsearch.node.Node;\n import org.elasticsearch.node.NodeBuilder;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import org.apache.usergrid.persistence.core.util.AvailablePortFinder;\n+import org.apache.usergrid.persistence.index.IndexFig;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+\n /**\n  * Provides access to ElasticSearch client.\n  */\n @Singleton\n public class EsProvider {\n \n-    private static final Logger log = LoggerFactory.getLogger(EsProvider.class);\n+    private static final Logger log = LoggerFactory.getLogger( EsProvider.class );\n \n     private final IndexFig indexFig;\n     private static Client client;\n \n+\n     @Inject\n-    public EsProvider(IndexFig fig) {\n+    public EsProvider( IndexFig fig ) {\n         this.indexFig = fig;\n     }\n \n+\n     public synchronized Client getClient() {\n-        if (client == null) {\n-            client = getClient(indexFig);\n+        if ( client == null ) {\n+            client = getClient( indexFig );\n         }\n         return client;\n     }\n \n-    public static synchronized Client getClient(IndexFig fig) {\n \n-        if (client == null) {\n+    public static synchronized Client getClient( IndexFig fig ) {\n+\n+        if ( client == null ) {\n \n             Client newClient = null;\n \n-            if (fig.isEmbedded()) {\n+            if ( fig.isEmbedded() ) {\n \n                 int port = AvailablePortFinder.getNextAvailable( 2000 );\n \n-                Settings settings = ImmutableSettings.settingsBuilder()\n-                        .put(\"node.http.enabled\", true)\n-                        .put(\"transport.tcp.port\", port)\n-                        .put(\"path.logs\", \"target/elasticsearch/logs_\" + port)\n-                        .put(\"path.data\", \"target/elasticsearch/data_\" + port)\n-                        .put(\"gateway.type\", \"none\")\n-                        .put(\"index.store.type\", \"memory\")\n-                        .put(\"index.number_of_shards\", 1)\n-                        .put(\"index.number_of_replicas\", 1)\n-                        .build();\n+                Settings settings = ImmutableSettings.settingsBuilder().put( \"node.http.enabled\", true )\n+                                                     .put( \"transport.tcp.port\", port )\n+                                                     .put( \"path.logs\", \"target/elasticsearch/logs_\" + port )\n+                                                     .put( \"path.data\", \"target/elasticsearch/data_\" + port )\n+                                                     .put( \"gateway.type\", \"none\" ).put( \"index.store.type\", \"memory\" )\n+                                                     .put( \"index.number_of_shards\", 1 )\n+                                                     .put( \"index.number_of_replicas\", 1 ).build();\n \n-                log.info(\"Starting ElasticSearch embedded with settings: \" +  settings.getAsMap());\n+                log.info( \"Starting ElasticSearch embedded with settings: \" + settings.getAsMap() );\n \n-                Node node = NodeBuilder.nodeBuilder().local(true).settings(settings).node();\n+                Node node = NodeBuilder.nodeBuilder().local( true ).settings( settings ).node();\n                 newClient = node.client();\n+            }\n+            else { // build client that connects to all hosts\n+                final String hosts = fig.getHosts();\n \n-            } else { // build client that connects to all hosts\n+                Settings settings =\n+                        ImmutableSettings.settingsBuilder().put( \"client.transport.ping_timeout\", 2000 ) // milliseconds\n+                                .put( \"client.transport.nodes_sampler_interval\", 100 ).put( \"http.enabled\", false )\n \n-                Settings settings = ImmutableSettings.settingsBuilder()\n-                        .put(\"cluster.name\", fig.getClusterName() )\n-                        // TODO: consider making these configurable\n-                        .put(\"client.transport.ignore_cluster_name\", true )\n-                        .put(\"client.transport.ping_timeout\", 2000) // milliseconds\n-                        .put(\"client.transport.nodes_sampler_interval\", 100 )\n-                        .build();\n+                                //this assumes that we're using zen for host discovery.  Putting an explicit set of\n+                                // bootstrap hosts ensures we connect to a valid cluster.\n+                                .put( \"discovery.zen.ping.unicast.hosts\", hosts ).build();\n \n-                log.info(\"Creating ElasticSearch client with settings: \" +  settings.getAsMap());\n+                Node node = NodeBuilder.nodeBuilder().settings( settings ).clusterName( fig.getClusterName() )\n+                                       .client( true ).node();\n+\n+                newClient = node.client();\n \n-                TransportClient transportClient = new TransportClient(settings);\n \n-                for (String host : fig.getHosts().split(\",\")) {\n-                    transportClient.addTransportAddress(\n-                            new InetSocketTransportAddress(host.trim(), fig.getPort()));\n-                    log.info(\"   Added transport for ElasticSearch host {}:{}\", host.trim(), fig.getPort() ) ;\n-                }\n-                newClient = transportClient;\n             }\n             client = newClient;\n         }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsProvider.java",
                "sha": "b448c61150f67c8de45d761e004819a2d1f0a19a",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/ElasticSearchTest.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/ElasticSearchTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 6,
                "filename": "stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/ElasticSearchTest.java",
                "patch": "@@ -91,12 +91,12 @@ public void testSimpleCrud() {\n             getResponse.getSource().get( \"message\" ) );\n \n         // update via script\n-        client.prepareUpdate( indexName, collectionName, id)\n-            .setScript( \"ctx._source.message = \\\"coming out of a keen city in the sky\\\"\" )\n-            .execute().actionGet();\n-        getResponse = client.prepareGet( indexName, collectionName, id).get();\n-        assertEquals(\"coming out of a keen city in the sky\", \n-            getResponse.getSource().get( \"message\" ) );\n+//        client.prepareUpdate( indexName, collectionName, id)\n+//            .setScript( \"ctx._source.message = \\\"coming out of a keen city in the sky\\\"\" )\n+//            .execute().actionGet();\n+//        getResponse = client.prepareGet( indexName, collectionName, id).get();\n+//        assertEquals(\"coming out of a keen city in the sky\", \n+//            getResponse.getSource().get( \"message\" ) );\n \n         // delete\n         client.prepareDelete(indexName, collectionName, id).execute().actionGet();",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/ElasticSearchTest.java",
                "sha": "29106a26fa168eb9d8d89a8a4bb8f60e6763acb5",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityConnectionIndexImplTest.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityConnectionIndexImplTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 3,
                "filename": "stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityConnectionIndexImplTest.java",
                "patch": "@@ -30,8 +30,6 @@\n import org.slf4j.LoggerFactory;\n \n import org.apache.usergrid.persistence.collection.CollectionScope;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n import org.apache.usergrid.persistence.collection.guice.MigrationManagerRule;\n import org.apache.usergrid.persistence.collection.impl.CollectionScopeImpl;\n import org.apache.usergrid.persistence.collection.util.EntityUtils;\n@@ -42,7 +40,6 @@\n import org.apache.usergrid.persistence.index.IndexScope;\n import org.apache.usergrid.persistence.index.guice.TestIndexModule;\n import org.apache.usergrid.persistence.index.query.CandidateResults;\n-import org.apache.usergrid.persistence.index.query.EntityResults;\n import org.apache.usergrid.persistence.index.query.Query;\n import org.apache.usergrid.persistence.model.entity.Entity;\n import org.apache.usergrid.persistence.model.entity.Id;",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityConnectionIndexImplTest.java",
                "sha": "75d5e09dea62b99b3824e7e2073a1645a509e7dd",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityIndexTest.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityIndexTest.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 11,
                "filename": "stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityIndexTest.java",
                "patch": "@@ -21,14 +21,11 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n \n import org.jukito.UseModules;\n-import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -39,23 +36,16 @@\n import org.apache.commons.lang3.time.StopWatch;\n \n import org.apache.usergrid.persistence.collection.CollectionScope;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n import org.apache.usergrid.persistence.collection.guice.MigrationManagerRule;\n import org.apache.usergrid.persistence.collection.impl.CollectionScopeImpl;\n-import org.apache.usergrid.persistence.collection.mvcc.entity.impl.MvccEntityDeleteEvent;\n import org.apache.usergrid.persistence.collection.util.EntityUtils;\n import org.apache.usergrid.persistence.core.cassandra.CassandraRule;\n import org.apache.usergrid.persistence.core.cassandra.ITRunner;\n-import org.apache.usergrid.persistence.core.consistency.AsyncProcessor;\n-import org.apache.usergrid.persistence.core.consistency.AsyncProcessorFactory;\n-import org.apache.usergrid.persistence.core.consistency.QueueListenerHelper;\n import org.apache.usergrid.persistence.index.EntityIndex;\n import org.apache.usergrid.persistence.index.EntityIndexFactory;\n import org.apache.usergrid.persistence.index.IndexScope;\n import org.apache.usergrid.persistence.index.guice.TestIndexModule;\n import org.apache.usergrid.persistence.index.query.CandidateResults;\n-import org.apache.usergrid.persistence.index.query.EntityResults;\n import org.apache.usergrid.persistence.index.query.Query;\n import org.apache.usergrid.persistence.index.utils.UUIDUtils;\n import org.apache.usergrid.persistence.model.entity.Entity;\n@@ -72,7 +62,6 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n \n \n @RunWith(ITRunner.class)",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/corepersistence/queryindex/src/test/java/org/apache/usergrid/persistence/index/impl/EntityIndexTest.java",
                "sha": "4b1b8526ec52c1f57c7b8107ba5900b14e609608",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/pom.xml",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/pom.xml?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 0,
                "filename": "stack/pom.xml",
                "patch": "@@ -1837,6 +1837,7 @@\n                     <exclude>**/src/main/dist/webapps/**</exclude>\n \n                     <!-- TODO: need to add headers to many files in corepersistence -->\n+                    <exclude>**/launcher-vagrant/**</exclude>\n                     <exclude>**/corepersistence/**</exclude>\n                     <exclude>**/awscluster/**</exclude>\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/pom.xml",
                "sha": "b672e1c708c3b66df29e2b1da843eb046d9dd8ce",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/QueryTokenExceptionMapper.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/QueryTokenExceptionMapper.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 2,
                "filename": "stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/QueryTokenExceptionMapper.java",
                "patch": "@@ -20,10 +20,8 @@\n import javax.ws.rs.core.Response;\n import javax.ws.rs.ext.Provider;\n \n-import org.apache.usergrid.persistence.exceptions.QueryParseException;\n import org.apache.usergrid.persistence.exceptions.QueryTokenException;\n \n-import antlr.NoViableAltException;\n \n import static javax.ws.rs.core.Response.Status.BAD_REQUEST;\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/QueryTokenExceptionMapper.java",
                "sha": "906811cd77518f5b7884026386d2eb1f7a6e946e",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/services/src/main/java/org/apache/usergrid/security/tokens/TokenCategory.java",
                "changes": 10,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/apache/usergrid/security/tokens/TokenCategory.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 2,
                "filename": "stack/services/src/main/java/org/apache/usergrid/security/tokens/TokenCategory.java",
                "patch": "@@ -32,11 +32,17 @@\n     private final String prefix;\n     private final String base64Prefix;\n     private final boolean expires;\n-    private static final Map<String, TokenCategory> prefixes = new ConcurrentHashMap<String, TokenCategory>();\n-    private static final Map<String, TokenCategory> base64Prefixes = new ConcurrentHashMap<String, TokenCategory>();\n+    private static Map<String, TokenCategory> prefixes;\n+    private static Map<String, TokenCategory> base64Prefixes;\n \n \n     private synchronized static void register( TokenCategory type ) {\n+        if ( prefixes == null ) {\n+            prefixes = new ConcurrentHashMap<String, TokenCategory>();\n+        }\n+        if ( base64Prefixes == null ) {\n+            base64Prefixes = new ConcurrentHashMap<String, TokenCategory>();\n+        }\n         prefixes.put( type.getPrefix(), type );\n         base64Prefixes.put( type.getBase64Prefix(), type );\n     }",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/services/src/main/java/org/apache/usergrid/security/tokens/TokenCategory.java",
                "sha": "121901d248b1e4d2dfe7857c7d0458b09898263c",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/services/src/main/java/org/apache/usergrid/security/tokens/cassandra/TokenServiceImpl.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/apache/usergrid/security/tokens/cassandra/TokenServiceImpl.java?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 6,
                "filename": "stack/services/src/main/java/org/apache/usergrid/security/tokens/cassandra/TokenServiceImpl.java",
                "patch": "@@ -499,13 +499,7 @@ private ByteBuffer principalKey( AuthPrincipalInfo principalInfo ) {\n \n \n     private UUID getUUIDForToken( String token ) throws ExpiredTokenException, BadTokenException {\n-\n         TokenCategory tokenCategory = TokenCategory.getFromBase64String( token );\n-\n-        if( tokenCategory == null){\n-            return null;\n-        }\n-\n         byte[] bytes = decodeBase64( token.substring( TokenCategory.BASE64_PREFIX_LENGTH ) );\n         UUID uuid = uuid( bytes );\n         int i = 16;",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/services/src/main/java/org/apache/usergrid/security/tokens/cassandra/TokenServiceImpl.java",
                "sha": "50156b5ac4b69be8fbfa1a829ca7eeaf04e668de",
                "status": "modified"
            },
            {
                "additions": 28,
                "blob_url": "https://github.com/apache/usergrid/blob/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/services/src/test/resources/usergrid-test-context.xml",
                "changes": 50,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/test/resources/usergrid-test-context.xml?ref=183e0eaaae2af9e3d83a5920fd012d7e8d12e06f",
                "deletions": 22,
                "filename": "stack/services/src/test/resources/usergrid-test-context.xml",
                "patch": "@@ -16,32 +16,38 @@\n     limitations under the License.\r\n -->\r\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n-\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\"\r\n-\txmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\"\r\n-\txsi:schemaLocation=\"\r\n+       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\"\r\n+       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\"\r\n+       xsi:schemaLocation=\"\r\n \thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\r\n \thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\r\n \thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd\">\r\n \r\n-\t<bean id=\"properties\"\r\n-\t\tclass=\"org.springframework.beans.factory.config.PropertiesFactoryBean\">\r\n-\t\t<property name=\"singleton\" value=\"true\" />\r\n-\t\t<property name=\"ignoreResourceNotFound\" value=\"true\" />\r\n-\t\t<property name=\"locations\">\r\n-\t\t\t<list>\r\n-\t\t\t\t<value>classpath:/usergrid-default.properties</value>\r\n-\t\t\t\t<value>classpath:/usergrid-test.properties</value>\r\n-\t\t\t\t<value>${usergrid-custom-spring-test-properties}</value>\r\n-\t\t\t</list>\r\n-\t\t</property>\r\n-\t</bean>\r\n-\r\n-\t<import resource=\"classpath:/usergrid-services-context.xml\" />\r\n-\r\n-    <bean id=\"setup\" class=\"org.apache.usergrid.persistence.cassandra.Setup\">\r\n+    <bean id=\"properties\"\r\n+          class=\"org.springframework.beans.factory.config.PropertiesFactoryBean\">\r\n+        <property name=\"singleton\" value=\"true\" />\r\n+        <property name=\"ignoreResourceNotFound\" value=\"true\" />\r\n+        <property name=\"locations\">\r\n+            <list>\r\n+                <value>classpath:/usergrid-default.properties</value>\r\n+                <value>classpath:/usergrid-test.properties</value>\r\n+                <value>${usergrid-custom-spring-test-properties}</value>\r\n+            </list>\r\n+        </property>\r\n+    </bean>\r\n+\r\n+    <import resource=\"classpath:/usergrid-services-context.xml\" />\r\n+\r\n+    <bean id=\"setup\" class=\"org.apache.usergrid.corepersistence.CpSetup\">\r\n         <constructor-arg ref=\"entityManagerFactory\"/>\r\n         <constructor-arg ref=\"cassandraService\"/>\r\n     </bean>\r\n+\r\n+    <!--  <bean id=\"setup\" class=\"org.apache.usergrid.persistence.cassandra.Setup\">\r\n+      <constructor-arg ref=\"entityManagerFactory\"/>\r\n+      <constructor-arg ref=\"cassandraService\"/>\r\n+    </bean>-->\r\n+\r\n     <!-- The default schema manager -->\r\n     <!-- refer to a named schemaManager from the DataControl annotation thusly -->\r\n     <bean id=\"coreManager\" class=\"org.apache.usergrid.persistence.CoreSchemaManager\">\r\n@@ -54,9 +60,9 @@\n     </bean>\r\n \r\n     <!--<bean id=\"binaryStore\" class=\"org.apache.usergrid.services.assets.data.S3BinaryStore\">-->\r\n-        <!--<constructor-arg name=\"accessId\" value=\"xx\" />-->\r\n-        <!--<constructor-arg name=\"secretKey\" value=\"xx\" />-->\r\n-        <!--<constructor-arg name=\"bucketName\" value=\"xx\" />-->\r\n+    <!--<constructor-arg name=\"accessId\" value=\"xx\" />-->\r\n+    <!--<constructor-arg name=\"secretKey\" value=\"xx\" />-->\r\n+    <!--<constructor-arg name=\"bucketName\" value=\"xx\" />-->\r\n     <!--</bean>-->\r\n \r\n </beans>\r",
                "raw_url": "https://github.com/apache/usergrid/raw/183e0eaaae2af9e3d83a5920fd012d7e8d12e06f/stack/services/src/test/resources/usergrid-test-context.xml",
                "sha": "af11880886ebbb171526270f43db3186d142783f",
                "status": "modified"
            }
        ],
        "message": "Merge branch 'two-dot-o' of https://github.com/usergrid/usergrid into DPS-1042_import-counters\n\n# By Shawn Feldman (6) and others\n# Via Dave Johnson (6) and others\n* 'two-dot-o' of https://github.com/usergrid/usergrid:\n  All EntityConnectionsIT tests now passing.\n  RAT ignore for Vagrant temp files\n  remove logging, refresh index\n  remove comment\n  adding rest of groups and roles f(x)\n  adding majority of methods back to cpentitymanager\n  Changed error to warning\n  Fix test failures, clean up imports.\n  Merged remote fixes\n  Upgraded to ES 1.2.0.\n  Longs for versions instead of time UUIDs.\n  Work to get services module tests working.\n  All tests pass with new long timestamp\n  removing simpleroleref\n  Revert \"Missed null check may cause NPE\"\n  check for nulls\n  Changed edge interface to have timestamps on the edge.\n  Changed edge interface to have timestamps on the edge.\n\nConflicts:\n\tstack/core/src/main/java/org/apache/usergrid/corepersistence/CpEntityManager.java",
        "parent": "https://github.com/apache/usergrid/commit/6664dc28ffce57a43e10a228a5a7776389e5706a",
        "patched_files": [
            "EntityConnectionsIT.java",
            "corepersistence.properties",
            "log4j.properties",
            "CpRelationManager.java",
            "EsProvider.java",
            "AsyncProcessorFactoryImpl.java",
            "EntityManager.java",
            "EdgeWriteCompactImpl.java",
            "Edge.java",
            "EdgeSerialization.java",
            "SimpleEdge.java",
            "SizebasedEdgeShardStrategy.java",
            "NodeSerialization.java",
            "EdgeMetaRepairImpl.java",
            "NodeDeleteEvent.java",
            "NodeShardApproximationImpl.java",
            "NodeShardCache.java",
            "EdgeDeleteRepairImpl.java",
            "QueryTokenExceptionMapper.java",
            "SimpleMarkedEdge.java",
            "StorageGraphManagerIT.java",
            "AsyncProcessor.java",
            "EdgeTestUtils.java",
            "EdgeMetadataSerializationImpl.java",
            "EntityIndex.java",
            "CpEntityManagerFactory.java",
            "TokenServiceImpl.java",
            "AsyncProcessorImpl.java",
            "ComittedGraphManagerIT.java",
            "EdgeDeleteRepair.java",
            "EdgeSerializationImpl.java",
            "MergedEdgeReader.java",
            "usergrid-test-context.xml",
            "PermissionsIT.java",
            "EdgeWriteListener.java",
            "CpEntityManager.java",
            "GraphManagerIT.java",
            "ApplicationScopeImpl.java",
            "CommonModule.java",
            "MergedEdgeReaderImpl.java",
            "SearchByEdgeType.java",
            "SimpleSearchByIdType.java",
            "EdgeMetaRepair.java",
            "EdgeDeleteListener.java",
            "NodeDeleteListener.java",
            "TokenCategory.java",
            "SearchByEdge.java",
            "NodeShardCacheImpl.java",
            "TimebasedEdgeShardStrategy.java",
            "EdgeUtils.java",
            "EdgeMetadataSerialization.java",
            "SimpleSearchByEdgeType.java",
            "ColumnTypes.java",
            "SimpleSearchByEdge.java",
            "EdgeShardStrategy.java",
            "GraphManagerImpl.java",
            "GraphManager.java",
            "CpSetup.java",
            "pom.xml",
            "NodeSerializationImpl.java",
            "HystrixObservable.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "EdgeMetaRepairTest.java",
            "GraphManagerStressTest.java",
            "EdgeWriteListenerTest.java",
            "EntityConnectionIndexImplTest.java",
            "EdgeSerializationTest.java",
            "AsyncProcessorTest.java",
            "MergedEdgeReaderImplComparatorTest.java",
            "EdgeMetadataSerializationTest.java",
            "GraphManagerLoadTest.java",
            "EdgeDeleteRepairTest.java",
            "MergedEdgeReaderTest.java",
            "EntityIndexTest.java",
            "NodeShardCacheTest.java",
            "NodeDeleteListenerTest.java",
            "EdgeDeleteListenerTest.java",
            "NodeSerializationTest.java",
            "EdgeSerializationChopTest.java",
            "ElasticSearchTest.java"
        ]
    },
    "usergrid_1bf64fc": {
        "bug_id": "usergrid_1bf64fc",
        "commit": "https://github.com/apache/usergrid/commit/1bf64fc9e07b57be874d3b232af9dcb3317d7d35",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/1bf64fc9e07b57be874d3b232af9dcb3317d7d35/stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java?ref=1bf64fc9e07b57be874d3b232af9dcb3317d7d35",
                "deletions": 2,
                "filename": "stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java",
                "patch": "@@ -349,7 +349,7 @@ public Viewable handlePasswordResetForm(@Context UriInfo ui,\n \n             if (!useReCaptcha()) {\n                 management.startAppUserPasswordResetFlow(getApplicationId(),\n-                        user);\n+                \t\tgetUser());\n                 return handleViewable(\"resetpw_email_success\", this);\n             }\n \n@@ -362,7 +362,7 @@ public Viewable handlePasswordResetForm(@Context UriInfo ui,\n \n             if (reCaptchaResponse.isValid()) {\n                 management.startAppUserPasswordResetFlow(getApplicationId(),\n-                        user);\n+                        getUser());\n                 return handleViewable(\"resetpw_email_success\", this);\n             } else {\n                 errorMsg = \"Incorrect Captcha\";",
                "raw_url": "https://github.com/apache/usergrid/raw/1bf64fc9e07b57be874d3b232af9dcb3317d7d35/stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java",
                "sha": "53c2578df9a27706f9d1f6e2e3951498567f93a8",
                "status": "modified"
            }
        ],
        "message": "fixed application user password reset flow NPE",
        "parent": "https://github.com/apache/usergrid/commit/a72d805d279decd5024daf6e57bacedcd1544f99",
        "patched_files": [
            "UserResource.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "UserResourceTest.java"
        ]
    },
    "usergrid_326e414": {
        "bug_id": "usergrid_326e414",
        "commit": "https://github.com/apache/usergrid/commit/326e414acc7d382f73e952b5d59fc8ce18e94c54",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/326e414acc7d382f73e952b5d59fc8ce18e94c54/stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java?ref=326e414acc7d382f73e952b5d59fc8ce18e94c54",
                "deletions": 1,
                "filename": "stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java",
                "patch": "@@ -364,7 +364,7 @@ public ServiceResults postItemById(ServiceContext context, UUID id)\n \n \t\tEntity entity = em.get(id);\n \t\tif (entity == null) {\n-\t\t\treturn null;\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tentity = importEntity(context, entity);\n \n@@ -402,6 +402,9 @@ public ServiceResults deleteItemById(ServiceContext context, UUID id)\n \t\t}\n \n \t\tEntity item = em.get(id);\n+\t\tif (item == null) {\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n+\t\t}\n \t\titem = importEntity(context, item);\n \n \t\tem.removeFromCollection(context.getOwner(),\n@@ -425,6 +428,9 @@ public ServiceResults deleteItemByName(ServiceContext context, String name)\n \t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tEntity entity = em.get(ref);\n+\t\tif (entity == null) {\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n+\t\t}\n \t\tentity = importEntity(context, entity);\n \n \t\tcheckPermissionsForEntity(context, entity);",
                "raw_url": "https://github.com/apache/usergrid/raw/326e414acc7d382f73e952b5d59fc8ce18e94c54/stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java",
                "sha": "64701d7234cdf32073ca251444602fac17ea5441",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/326e414acc7d382f73e952b5d59fc8ce18e94c54/stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java?ref=326e414acc7d382f73e952b5d59fc8ce18e94c54",
                "deletions": 6,
                "filename": "stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java",
                "patch": "@@ -295,7 +295,7 @@ public ServiceResults postItemById(ServiceContext context, UUID id)\n \n \t\tEntity entity = em.get(id);\n \t\tif (entity == null) {\n-\t\t\treturn null;\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tentity = importEntity(context, entity);\n \n@@ -331,11 +331,11 @@ public ServiceResults postItemsByQuery(ServiceContext context, Query query)\n \n \t\t\tEntityRef ref = em.getAlias(query.getEntityType(), name);\n \t\t\tif (ref == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tEntity entity = em.get(ref);\n \t\t\tif (entity == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tentity = importEntity(context, entity);\n \n@@ -362,7 +362,7 @@ public ServiceResults deleteItemById(ServiceContext context, UUID id)\n \n \t\tEntity entity = em.get(id);\n \t\tif (entity == null) {\n-\t\t\treturn null;\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tentity = importEntity(context, entity);\n \n@@ -392,11 +392,11 @@ public ServiceResults deleteItemsByQuery(ServiceContext context, Query query)\n \n \t\t\tEntityRef ref = em.getAlias(query.getEntityType(), name);\n \t\t\tif (ref == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tEntity entity = em.get(ref);\n \t\t\tif (entity == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tentity = importEntity(context, entity);\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/326e414acc7d382f73e952b5d59fc8ce18e94c54/stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java",
                "sha": "2542fc22fe0be2c58bdfd7f369923dfba7a39b65",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/326e414acc7d382f73e952b5d59fc8ce18e94c54/stack/services/src/main/java/org/usergrid/services/AbstractService.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/AbstractService.java?ref=326e414acc7d382f73e952b5d59fc8ce18e94c54",
                "deletions": 0,
                "filename": "stack/services/src/main/java/org/usergrid/services/AbstractService.java",
                "patch": "@@ -294,6 +294,10 @@ public Entity importEntity(ServiceContext context, Entity entity)\n \t@Override\n \tpublic Entity importEntity(ServiceRequest request, Entity entity)\n \t\t\tthrows Exception {\n+\t\tif (entity == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tif (!isRootService()) {\n \t\t\treturn sm.importEntity(request, entity);\n \t\t}",
                "raw_url": "https://github.com/apache/usergrid/raw/326e414acc7d382f73e952b5d59fc8ce18e94c54/stack/services/src/main/java/org/usergrid/services/AbstractService.java",
                "sha": "1879215e73885b45f41c1105adcabd99c34ec1ac",
                "status": "modified"
            }
        ],
        "message": "Merge pull request #54 from apigee/fix-npe-on-entity-not-found\n\nfix npe when entity not found, throw service_resource_not_found instead",
        "parent": "https://github.com/apache/usergrid/commit/ce78e78f334dd0da507f06ba4f49c42081b4af69",
        "patched_files": [
            "AbstractService.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "AbstractServiceTest.java"
        ]
    },
    "usergrid_5233567": {
        "bug_id": "usergrid_5233567",
        "commit": "https://github.com/apache/usergrid/commit/52335673b3f9b1dd63300654785a28c9278d22ea",
        "file": [
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/usergrid/blob/52335673b3f9b1dd63300654785a28c9278d22ea/stack/services/src/main/java/org/apache/usergrid/management/AppInfoMigrationPlugin.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/apache/usergrid/management/AppInfoMigrationPlugin.java?ref=52335673b3f9b1dd63300654785a28c9278d22ea",
                "deletions": 0,
                "filename": "stack/services/src/main/java/org/apache/usergrid/management/AppInfoMigrationPlugin.java",
                "patch": "@@ -178,6 +178,8 @@ private void migrateAppInfo( org.apache.usergrid.persistence.model.entity.Entity\n \n         final String name = ( String ) oldAppInfoMap.get( PROPERTY_NAME );\n \n+        logger.info( \"Attempting to migrate app {}\", name );\n+\n         try {\n             final String orgName = name.split( \"/\" )[0];\n             final String appName = name.split( \"/\" )[1];\n@@ -190,6 +192,15 @@ private void migrateAppInfo( org.apache.usergrid.persistence.model.entity.Entity\n             //avoid management org\n \n             EntityRef orgRef = managementEm.getAlias( Group.ENTITY_TYPE, orgName );\n+\n+            /**\n+             * No op, we couldn't find the org, so we can't roll the app forward\n+             */\n+            if(orgRef == null){\n+                logger.error( \"Unable to retrieve ref for org {}.  Not migrating app {}\", orgName, appName );\n+                return;\n+            }\n+\n             // create and connect new APPLICATION_INFO oldAppInfo to Organization\n             managementService.createApplication( orgRef.getUuid(), name, applicationId, null );\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/52335673b3f9b1dd63300654785a28c9278d22ea/stack/services/src/main/java/org/apache/usergrid/management/AppInfoMigrationPlugin.java",
                "sha": "b78b64637b2fcd6ef0f63a08c281d1268dd3555f",
                "status": "modified"
            }
        ],
        "message": "Fixes NPE from missing org during testing",
        "parent": "https://github.com/apache/usergrid/commit/0b243c4d516e0f6ae58421c63787421b8b806052",
        "patched_files": [
            "AppInfoMigrationPlugin.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "AppInfoMigrationPluginTest.java"
        ]
    },
    "usergrid_5d75a29": {
        "bug_id": "usergrid_5d75a29",
        "commit": "https://github.com/apache/usergrid/commit/5d75a2992475ab907b15e4a2f86ab50ae89a1e40",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/5d75a2992475ab907b15e4a2f86ab50ae89a1e40/stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java?ref=5d75a2992475ab907b15e4a2f86ab50ae89a1e40",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java",
                "patch": "@@ -58,7 +58,14 @@ public UnionIterator( int pageSize, int id, ByteBuffer minUuid ) {\n         super( pageSize );\n \n         this.id = id;\n-        list = new SortedColumnList( pageSize, UUID_SERIALIZER.fromByteBuffer( minUuid ) );\n+\n+        UUID parseMinUuid = null;\n+\n+        if(minUuid != null)      {\n+            parseMinUuid = UUID_SERIALIZER.fromByteBuffer( minUuid );\n+        }\n+\n+        list = new SortedColumnList( pageSize, parseMinUuid );\n     }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/5d75a2992475ab907b15e4a2f86ab50ae89a1e40/stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java",
                "sha": "00e90b881a8b11eb13b2fb2cfe062676c170f49b",
                "status": "modified"
            },
            {
                "additions": 70,
                "blob_url": "https://github.com/apache/usergrid/blob/5d75a2992475ab907b15e4a2f86ab50ae89a1e40/stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java",
                "changes": 70,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java?ref=5d75a2992475ab907b15e4a2f86ab50ae89a1e40",
                "deletions": 0,
                "filename": "stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java",
                "patch": "@@ -16,13 +16,16 @@\n package org.usergrid.persistence.query.ir.result;\n \n \n+import java.nio.ByteBuffer;\n import java.util.HashSet;\n import java.util.Set;\n import java.util.UUID;\n \n import org.junit.Test;\n import org.usergrid.utils.UUIDUtils;\n \n+import me.prettyprint.cassandra.serializers.UUIDSerializer;\n+\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNull;\n@@ -295,6 +298,73 @@ public void iterationCompleted() {\n     }\n \n \n+    @Test\n+    public void nullCursorBytes() {\n+\n+        UUID id1 = UUIDUtils.minTimeUUID( 1 );\n+        UUID id2 = UUIDUtils.minTimeUUID( 2 );\n+        UUID id3 = UUIDUtils.minTimeUUID( 3 );\n+        UUID id4 = UUIDUtils.minTimeUUID( 4 );\n+        UUID id5 = UUIDUtils.minTimeUUID( 5 );\n+\n+\n+        InOrderIterator second = new InOrderIterator( 100 );\n+        second.add( id1 );\n+        second.add( id2 );\n+        second.add( id3 );\n+        second.add( id4 );\n+        second.add( id5 );\n+\n+        UnionIterator union = new UnionIterator( 100, 1, null );\n+\n+        union.addIterator( second );\n+\n+        Set<ScanColumn> ids = union.next();\n+\n+        // now make sure it's right, only 1, 3 and 8 intersect\n+        assertTrue( ids.contains( uuidColumn( id1 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id2 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id3 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id4 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id5 ) ) );\n+    }\n+\n+\n+    @Test\n+    public void validCursorBytes() {\n+\n+\n+        ByteBuffer cursor = UUIDSerializer.get().toByteBuffer( UUIDUtils.minTimeUUID( 4 ) );\n+\n+        UUID id1 = UUIDUtils.minTimeUUID( 1 );\n+        UUID id2 = UUIDUtils.minTimeUUID( 2 );\n+        UUID id3 = UUIDUtils.minTimeUUID( 3 );\n+        UUID id4 = UUIDUtils.minTimeUUID( 4 );\n+        UUID id5 = UUIDUtils.minTimeUUID( 5 );\n+\n+\n+        InOrderIterator second = new InOrderIterator( 100 );\n+        second.add( id1 );\n+        second.add( id2 );\n+        second.add( id3 );\n+        second.add( id4 );\n+        second.add( id5 );\n+\n+        UnionIterator union = new UnionIterator( 100, 1, cursor );\n+\n+        union.addIterator( second );\n+\n+        Set<ScanColumn> ids = union.next();\n+\n+        // now make sure it's right, only 1, 3 and 8 intersect\n+        assertFalse( ids.contains( uuidColumn( id1 ) ) );\n+        assertFalse( ids.contains( uuidColumn( id2 ) ) );\n+        assertFalse( ids.contains( uuidColumn( id3 ) ) );\n+        assertFalse( ids.contains( uuidColumn( id4 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id5 ) ) );\n+    }\n+\n+\n     private void reverse( UUID[] array ) {\n \n         UUID temp = null;",
                "raw_url": "https://github.com/apache/usergrid/raw/5d75a2992475ab907b15e4a2f86ab50ae89a1e40/stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java",
                "sha": "8fd9ea80099eb580bf87af0cd8fcbfa73eb41572",
                "status": "modified"
            }
        ],
        "message": "Fixes NPE issue in the union iterator",
        "parent": "https://github.com/apache/usergrid/commit/9dd14f1863b714e224531aa45595b0ed03731163",
        "patched_files": [
            "UnionIterator.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "UnionIteratorTest.java"
        ]
    },
    "usergrid_5fc3c50": {
        "bug_id": "usergrid_5fc3c50",
        "commit": "https://github.com/apache/usergrid/commit/5fc3c506a14ac28a702a2c146466b9f3907e4125",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/search/CandidateEntityFilter.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/search/CandidateEntityFilter.java?ref=5fc3c506a14ac28a702a2c146466b9f3907e4125",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/search/CandidateEntityFilter.java",
                "patch": "@@ -27,6 +27,7 @@\n import org.apache.usergrid.persistence.Schema;\n import org.apache.usergrid.persistence.index.*;\n import org.apache.usergrid.persistence.index.impl.IndexProducer;\n+import org.apache.usergrid.persistence.index.query.ParsedQuery;\n import org.apache.usergrid.persistence.model.entity.SimpleId;\n import org.apache.usergrid.persistence.model.field.DistanceField;\n import org.apache.usergrid.persistence.model.field.EntityObjectField;\n@@ -103,7 +104,8 @@ public CandidateEntityFilter( final EntityCollectionManagerFactory entityCollect\n \n         boolean keepStaleEntries = pipelineContext.getKeepStaleEntries();\n         String query = pipelineContext.getQuery();\n-        boolean isDirectQuery = pipelineContext.getParsedQuery().isDirectQuery();\n+        ParsedQuery parsedQuery = pipelineContext.getParsedQuery();\n+        boolean isDirectQuery = parsedQuery == null ? false : parsedQuery.isDirectQuery();\n \n         //buffer them to get a page size we can make 1 network hop\n         final Observable<FilterResult<Entity>> searchIdSetObservable =",
                "raw_url": "https://github.com/apache/usergrid/raw/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/search/CandidateEntityFilter.java",
                "sha": "c0db02f94aeafb048185def76aac4422f8743210",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java?ref=5fc3c506a14ac28a702a2c146466b9f3907e4125",
                "deletions": 2,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java",
                "patch": "@@ -84,8 +84,11 @@ public ConnectionServiceImpl( final PipelineBuilderFactory pipelineBuilderFactor\n         final Optional<String> query = search.getQuery();\n \n         final IdBuilder pipelineBuilder =\n-            pipelineBuilderFactory.create( search.getApplicationScope() ).withCursor( search.getCursor() )\n-                                  .withLimit( search.getLimit() ).fromId( search.getSourceNodeId() );\n+            pipelineBuilderFactory.create( search.getApplicationScope() )\n+            \t.withCursor( search.getCursor() )\n+            \t.withLimit( search.getLimit() )\n+            \t.query(query)\n+            \t.fromId( search.getSourceNodeId() );\n \n \n         //we want to load all entities",
                "raw_url": "https://github.com/apache/usergrid/raw/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java",
                "sha": "c476f1fc57635e43cbf07bccdf5a61d1047603e0",
                "status": "modified"
            },
            {
                "additions": 30,
                "blob_url": "https://github.com/apache/usergrid/blob/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/core/src/test/java/org/apache/usergrid/persistence/CollectionDeleteTest.java",
                "changes": 62,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/apache/usergrid/persistence/CollectionDeleteTest.java?ref=5fc3c506a14ac28a702a2c146466b9f3907e4125",
                "deletions": 32,
                "filename": "stack/core/src/test/java/org/apache/usergrid/persistence/CollectionDeleteTest.java",
                "patch": "@@ -17,33 +17,31 @@\n package org.apache.usergrid.persistence;\n \n \n-import com.codahale.metrics.MetricRegistry;\n-import com.google.inject.Injector;\n-import net.jcip.annotations.NotThreadSafe;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n import org.apache.commons.lang.RandomStringUtils;\n import org.apache.usergrid.AbstractCoreIT;\n-import org.apache.usergrid.cassandra.SpringResource;\n-import org.apache.usergrid.corepersistence.index.*;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScopeImpl;\n-import org.apache.usergrid.persistence.index.EntityIndex;\n-import org.apache.usergrid.persistence.index.EntityIndexFactory;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-import org.apache.usergrid.persistence.model.entity.SimpleId;\n+import org.apache.usergrid.corepersistence.index.CollectionDeleteRequestBuilder;\n+import org.apache.usergrid.corepersistence.index.CollectionDeleteService;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n-import org.junit.Ignore;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.*;\n+import com.codahale.metrics.MetricRegistry;\n \n-import static org.junit.Assert.*;\n \n \n-@NotThreadSafe\n-@Ignore(\"fix later\")\n public class CollectionDeleteTest extends AbstractCoreIT {\n     private static final Logger logger = LoggerFactory.getLogger( CollectionDeleteTest.class );\n \n@@ -201,9 +199,10 @@ private void waitForDelete( final CollectionDeleteService.CollectionDeleteStatus\n \n     private int retryReadData(EntityManager em, String collectionName, int expectedEntities,  int retry) throws Exception {\n         int count = -1;\n+        Set<Entity> uniqueRemEnts = new HashSet<Entity>();\n         do {\n             try {\n-                count = readData(em, collectionName, expectedEntities);\n+                count = readData(em, collectionName, expectedEntities, uniqueRemEnts);\n             } catch (Exception ignore) {\n                 logger.info( \"caught exception \", ignore);\n             }\n@@ -213,53 +212,52 @@ private int retryReadData(EntityManager em, String collectionName, int expectedE\n         return count;\n     }\n \n-    private int readData(EntityManager em, String collectionName, int expectedEntities)\n+    private int readData(EntityManager em, String collectionName, int expectedEntities, Set<Entity> uniqueRemEnts)\n         throws Exception {\n \n         app.waitForQueueDrainAndRefreshIndex();\n \n         Results results = em.getCollection(em.getApplicationRef(), collectionName, null, expectedEntities,\n             Query.Level.ALL_PROPERTIES, false);\n \n-        int count = 0;\n-        List<Entity> list = new ArrayList<>();\n+        \n         while ( true ) {\n \n             if (results.getEntities().size() == 0) {\n                 break;\n             }\n+            \n \n             UUID lastEntityUUID = null;\n             for ( Entity e : results.getEntities() ) {\n \n                 assertEquals(2000, e.getProperty(\"key2\"));\n \n-                if (count % 100 == 0) {\n-                    logger.info(\"read {} entities\", count);\n+                if (uniqueRemEnts.size() % 100 == 0) {\n+                    logger.info(\"read {} entities\", uniqueRemEnts.size());\n                 }\n                 lastEntityUUID = e.getUuid();\n-                count++;\n-                list.add(e);\n+                uniqueRemEnts.add(e);\n+                logger.info(\"Found remaining entity {}\", lastEntityUUID);\n             }\n \n             results = em.getCollection(em.getApplicationRef(), collectionName, lastEntityUUID, expectedEntities,\n                 Query.Level.ALL_PROPERTIES, false);\n \n         }\n-        logger.info(\"read {} total entities\", count);\n \n-        if (count != expectedEntities) {\n-            logger.info(\"Expected {} did not match actual {}\", expectedEntities, count);\n-            if (count < 20) {\n-                for (Entity e : list) {\n+        if (uniqueRemEnts.size() != expectedEntities) {\n+            logger.info(\"Expected {} did not match actual {}\", expectedEntities, uniqueRemEnts.size());\n+            if (uniqueRemEnts.size() < 20) {\n+                for (Entity e : uniqueRemEnts) {\n                     Object key = e.getProperty(\"key2\");\n-                    logger.info(\"Entity key {} ceated {}\", key, e.getCreated());\n+                    logger.info(\"Entity key {} uuid {} created {}\", key,e.getUuid(), e.getCreated());\n                 }\n             }\n         }\n \n-        assertEquals( \"Did not get expected entities\", expectedEntities, count );\n-        return count;\n+        assertEquals( \"Did not get expected entities\", expectedEntities, uniqueRemEnts.size() );\n+        return uniqueRemEnts.size();\n     }\n \n     private int countEntities( EntityManager em, String collectionName, int expectedEntities)",
                "raw_url": "https://github.com/apache/usergrid/raw/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/core/src/test/java/org/apache/usergrid/persistence/CollectionDeleteTest.java",
                "sha": "c22a62756f966242a60bc7df5722cbd33811e0e3",
                "status": "modified"
            },
            {
                "additions": 18,
                "blob_url": "https://github.com/apache/usergrid/blob/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/TooManyDirectEntitiesExceptionMapper.java",
                "changes": 18,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/TooManyDirectEntitiesExceptionMapper.java?ref=5fc3c506a14ac28a702a2c146466b9f3907e4125",
                "deletions": 0,
                "filename": "stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/TooManyDirectEntitiesExceptionMapper.java",
                "patch": "@@ -1,3 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n package org.apache.usergrid.rest.exceptions;\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/rest/src/main/java/org/apache/usergrid/rest/exceptions/TooManyDirectEntitiesExceptionMapper.java",
                "sha": "06226a5d6c9a6709588c7ff981834900674e049a",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/rest/src/test/java/org/apache/usergrid/rest/applications/queries/AndOrQueryTest.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/rest/src/test/java/org/apache/usergrid/rest/applications/queries/AndOrQueryTest.java?ref=5fc3c506a14ac28a702a2c146466b9f3907e4125",
                "deletions": 0,
                "filename": "stack/rest/src/test/java/org/apache/usergrid/rest/applications/queries/AndOrQueryTest.java",
                "patch": "@@ -24,6 +24,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import net.jcip.annotations.NotThreadSafe;\n+\n import java.io.IOException;\n import java.util.List;\n \n@@ -35,6 +37,7 @@\n  *\n  * @since 4.0\n  */\n+@NotThreadSafe\n public class AndOrQueryTest extends QueryTestBase {\n     private static final Logger logger = LoggerFactory.getLogger(AndOrQueryTest.class);\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/5fc3c506a14ac28a702a2c146466b9f3907e4125/stack/rest/src/test/java/org/apache/usergrid/rest/applications/queries/AndOrQueryTest.java",
                "sha": "61e2760745b670ed6361b5ca13c5c17a3d65cce6",
                "status": "modified"
            }
        ],
        "message": "Fixed failing tests and bugs\n-Fixed issue where query was not being passed correctly for ql search on\nconnections\n-Fixed NPE for direct query\n-Fixed tests that were failing sometimes due to parallel execution\n-Fixed CollectionDeleteTest so that it doesn not have to be ignored",
        "parent": "https://github.com/apache/usergrid/commit/749a97f86e8f7470a73a90a0f6221a9dba9c4cf6",
        "patched_files": [
            "ConnectionServiceImpl.java",
            "CandidateEntityFilter.java",
            "TooManyDirectEntitiesExceptionMapper.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "CollectionDeleteTest.java",
            "AndOrQueryTest.java",
            "ConnectionServiceImplTest.java"
        ]
    },
    "usergrid_7b21525": {
        "bug_id": "usergrid_7b21525",
        "commit": "https://github.com/apache/usergrid/commit/7b215250afce3303af6a26ecf4ec8918840e37e0",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 3,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "patch": "@@ -32,7 +32,6 @@\n \n import org.apache.usergrid.corepersistence.asyncevents.AsyncEventService;\n import org.apache.usergrid.corepersistence.pipeline.PipelineBuilderFactory;\n-import org.apache.usergrid.corepersistence.pipeline.PipelineResult;\n import org.apache.usergrid.corepersistence.pipeline.read.ReadPipelineBuilder;\n import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n import org.apache.usergrid.corepersistence.results.ObservableQueryExecutor;\n@@ -648,7 +647,7 @@ public Results searchCollection( String collName, Query query ) throws Exception\n         }\n \n \n-        final Observable<PipelineResult<ResultsPage>> resultsObservable = readPipelineBuilder.execute();\n+        final Observable<ResultsPage> resultsObservable = readPipelineBuilder.execute();\n \n         return new ObservableQueryExecutor( resultsObservable ).next();\n     }\n@@ -917,7 +916,7 @@ public Results searchConnectedEntities( Query query ) throws Exception {\n         }\n \n \n-        final Observable<PipelineResult<ResultsPage>> resultsObservable = readPipelineBuilder.execute();\n+        final Observable<ResultsPage> resultsObservable = readPipelineBuilder.execute();\n \n         return new ObservableQueryExecutor( resultsObservable ).next();\n     }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "sha": "6adeefcd589bdf5eaf32b39922699c390922c484",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/Pipeline.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/Pipeline.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 7,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/Pipeline.java",
                "patch": "@@ -25,7 +25,7 @@\n import org.apache.usergrid.corepersistence.pipeline.cursor.RequestCursor;\n import org.apache.usergrid.corepersistence.pipeline.cursor.ResponseCursor;\n import org.apache.usergrid.corepersistence.pipeline.read.Collector;\n-import org.apache.usergrid.corepersistence.pipeline.read.PipelineOperation;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n \n import com.google.common.base.Optional;\n@@ -47,7 +47,6 @@\n     private final List<PipelineOperation> idPipelineOperationList;\n     private final Collector<?, R> collector;\n     private final RequestCursor requestCursor;\n-    private final ResponseCursor responseCursor;\n \n     private final int limit;\n \n@@ -69,18 +68,17 @@ public Pipeline( final ApplicationScope applicationScope, final List<PipelineOpe\n         this.limit = limit;\n \n         this.requestCursor = new RequestCursor( cursor );\n-        this.responseCursor = new ResponseCursor();\n     }\n \n \n     /**\n      * Execute the pipline construction, returning an observable of results\n      * @return\n      */\n-    public Observable<PipelineResult<R>> execute(){\n+    public Observable<R> execute(){\n \n \n-        Observable traverseObservable = Observable.just( applicationScope.getApplication() );\n+        Observable traverseObservable = Observable.just( new FilterResult<>( applicationScope.getApplication(), Optional.absent() ));\n \n         //build our traversal commands\n         for ( PipelineOperation pipelineOperation : idPipelineOperationList ) {\n@@ -99,7 +97,7 @@ public Pipeline( final ApplicationScope applicationScope, final List<PipelineOpe\n \n \n         //append the optional cursor into the response for the caller to use\n-        return response.map( result -> new PipelineResult<>( result, responseCursor ) );\n+        return response;\n     }\n \n \n@@ -111,7 +109,7 @@ public Pipeline( final ApplicationScope applicationScope, final List<PipelineOpe\n     private void setState( final PipelineOperation pipelineOperation ) {\n \n \n-        final PipelineContext context = new PipelineContext( applicationScope, requestCursor, responseCursor,\n+        final PipelineContext context = new PipelineContext( applicationScope, requestCursor,\n             limit, idCount );\n \n         pipelineOperation.setContext( context );",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/Pipeline.java",
                "sha": "26cf3468aa7d4e86bfe5e41c12ad9a144ddd8f75",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineContext.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineContext.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 14,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineContext.java",
                "patch": "@@ -38,16 +38,13 @@\n     private final int id;\n     private final ApplicationScope applicationScope;\n     private final RequestCursor requestCursor;\n-    private final ResponseCursor responseCursor;\n     private final int limit;\n \n \n-    public PipelineContext( final ApplicationScope applicationScope, final RequestCursor requestCursor,\n-                            final ResponseCursor responseCursor, final int limit, final int id ) {\n+    public PipelineContext( final ApplicationScope applicationScope, final RequestCursor requestCursor, final int limit, final int id ) {\n \n         this.applicationScope = applicationScope;\n         this.requestCursor = requestCursor;\n-        this.responseCursor = responseCursor;\n         this.limit = limit;\n         this.id = id;\n     }\n@@ -64,7 +61,7 @@ public int getId() {\n \n \n     /**\n-     * Get our cursor value if present\n+     * Get our cursor value if present from our pipline\n      * @param serializer\n      */\n     public <T extends Serializable> Optional<T> getCursor( final CursorSerializer<T> serializer ) {\n@@ -73,15 +70,6 @@ public int getId() {\n         return Optional.fromNullable( value );\n     }\n \n-\n-    /**\n-     * Set the cursor value into our resposne\n-     */\n-    public <T extends Serializable> void setCursorValue( final T value, final CursorSerializer<T> serializer ) {\n-        responseCursor.setCursor( id, value, serializer );\n-    }\n-\n-\n     /**\n      * Get the limit for this execution\n      * @return",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineContext.java",
                "sha": "018abb74e51d0c297f5f2bf36b41f686941db84e",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineOperation.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineOperation.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 4,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineOperation.java",
                "patch": "@@ -17,10 +17,11 @@\n  * under the License.\n  */\n \n-package org.apache.usergrid.corepersistence.pipeline.read;\n+package org.apache.usergrid.corepersistence.pipeline;\n \n \n import org.apache.usergrid.corepersistence.pipeline.PipelineContext;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n \n import rx.Observable;\n \n@@ -29,10 +30,10 @@\n  * Interface for filtering commands.  All filters must take an observable of Id's as an input.  Output is then determined by subclasses.\n   * This takes an input of Id, performs some operation, and emits values for further processing in the Observable\n   * pipeline\n- * @param <T> The input type\n- * @param <R>\n+ * @param <T> The input type of the filter value\n+ * @param <R> The output type of the filter value\n  */\n-public interface PipelineOperation< T, R> extends Observable.Transformer<T, R> {\n+public interface PipelineOperation<T, R> extends Observable.Transformer<FilterResult<T>, R> {\n \n     void setContext(final PipelineContext pipelineContext);\n }",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/PipelineOperation.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineOperation.java",
                "sha": "d2fa16c9f9d0238e4bd19408578464f98ca09f5f",
                "status": "renamed"
            },
            {
                "additions": 40,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/cursor/ResponseCursor.java",
                "changes": 81,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/cursor/ResponseCursor.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 41,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/cursor/ResponseCursor.java",
                "patch": "@@ -20,12 +20,10 @@\n package org.apache.usergrid.corepersistence.pipeline.cursor;\n \n \n-import java.io.Serializable;\n import java.util.Base64;\n-import java.util.HashMap;\n-import java.util.Map;\n \n-import com.fasterxml.jackson.core.Base64Variant;\n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n+\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n@@ -41,71 +39,72 @@\n \n     private static final ObjectMapper MAPPER = CursorSerializerUtil.getMapper();\n \n+\n     /**\n-     * We use a map b/c some indexes might be skipped\n+     * The pointer to the first edge path.  Evaluation is lazily performed in the case the caller does not care about\n+     * the cursor.\n      */\n-    private Map<Integer, CursorEntry<?>> cursors = new HashMap<>();\n+    private final Optional<EdgePath> edgePath;\n \n+    private Optional<String> encodedValue = null;\n \n-    /**\n-     * Set the possible cursor value into the index. DOES NOT parse the cursor.  This is intentional for performance\n-     */\n-    public <T extends Serializable> void setCursor( final int id, final T cursor,\n-                                                    final CursorSerializer<T> serializer ) {\n \n-        final CursorEntry<T> newEntry = new CursorEntry<>( cursor, serializer );\n-        cursors.put( id, newEntry );\n-    }\n+    public ResponseCursor( final Optional<EdgePath> edgePath ) {this.edgePath = edgePath;}\n \n \n     /**\n-     * now we're done, encode as a string\n+     * Lazyily encoded deliberately.  If the user doesn't care about a cursor and is using streams, we dont' want to take the\n+     * time to calculate it\n      */\n     public Optional<String> encodeAsString() {\n-        try {\n \n-            if(cursors.isEmpty()){\n-                return Optional.absent();\n-            }\n+        //always return cached if we are called 2x\n+        if ( encodedValue != null ) {\n+            return encodedValue;\n+        }\n+\n+        if ( !edgePath.isPresent() ) {\n+            encodedValue = Optional.absent();\n+            return encodedValue;\n+        }\n+\n+\n+        try {\n \n+            //no edge path, short circuit\n \n             final ObjectNode map = MAPPER.createObjectNode();\n \n-            for ( Map.Entry<Integer, CursorEntry<?>> entry : cursors.entrySet() ) {\n \n-                final CursorEntry cursorEntry = entry.getValue();\n+            Optional<EdgePath> current = edgePath;\n \n-                final JsonNode serialized = cursorEntry.serializer.toNode( MAPPER, cursorEntry.cursor );\n \n-                map.put( entry.getKey().toString(), serialized );\n-            }\n+            //traverse each edge and add them to our json\n+            do {\n+\n+                final EdgePath edgePath = current.get();\n+                final Object cursorValue = edgePath.getCursorValue();\n+                final CursorSerializer serializer = edgePath.getSerializer();\n+                final int filterId = edgePath.getFilterId();\n+\n+                final JsonNode serialized = serializer.toNode( MAPPER, cursorValue );\n+                map.put( String.valueOf( filterId ), serialized );\n \n+                current = current.get().getPrevious();\n+            }\n+            while ( current.isPresent() );\n \n-            final byte[] output = MAPPER.writeValueAsBytes(map);\n+            final byte[] output = MAPPER.writeValueAsBytes( map );\n \n             //generate a base64 url save string\n             final String value = Base64.getUrlEncoder().encodeToString( output );\n \n-            return Optional.of( value );\n-\n+            encodedValue =  Optional.of( value );\n         }\n         catch ( JsonProcessingException e ) {\n             throw new CursorParseException( \"Unable to serialize cursor\", e );\n         }\n-    }\n \n-\n-    /**\n-     * Interal pointer to the cursor and it's serialzed value\n-     */\n-    private static final class CursorEntry<T> {\n-        private final T cursor;\n-        private final CursorSerializer<T> serializer;\n-\n-\n-        private CursorEntry( final T cursor, final CursorSerializer<T> serializer ) {\n-            this.cursor = cursor;\n-            this.serializer = serializer;\n-        }\n+        return encodedValue;\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/cursor/ResponseCursor.java",
                "sha": "dbd8b88a2833496bcfe608e082d4a83a60b034e6",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractFilter.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractFilter.java",
                "patch": "@@ -21,14 +21,15 @@\n \n \n import org.apache.usergrid.corepersistence.pipeline.PipelineContext;\n+import org.apache.usergrid.corepersistence.pipeline.PipelineOperation;\n \n \n /**\n  * Basic functionality for our commands to handle cursor IO\n  * @param <T> the input type\n  * @param <R> The output Type\n  */\n-public abstract class AbstractPipelineOperation<T, R> implements PipelineOperation<T, R> {\n+public abstract class AbstractFilter<T, R> implements Filter<T, R> {\n \n \n     protected PipelineContext pipelineContext;",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractPipelineOperation.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractFilter.java",
                "sha": "e4d5d447b264287381a2dd0d0fa1a8845379a71c",
                "status": "renamed"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractPathFilter.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractPathFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 4,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractPathFilter.java",
                "patch": "@@ -33,7 +33,7 @@\n  * @param <R> The response type\n  * @param <C> The cursor type\n  */\n-public abstract class AbstractSeekingFilter<T, R, C extends Serializable> extends AbstractPipelineOperation<T, R> implements Filter<T, R> {\n+public abstract class AbstractPathFilter<T, R, C extends Serializable> extends AbstractFilter<T, R> implements Filter<T, R> {\n \n \n \n@@ -58,10 +58,17 @@\n \n     /**\n      * Sets the cursor into our pipeline context\n-     * @param newValue\n      */\n-    protected void setCursor(final C newValue){\n-        pipelineContext.setCursorValue( newValue, getCursorSerializer() );\n+    protected FilterResult<R> createFilterResult( final R emit, final C cursorValue, final Optional<EdgePath> parent ){\n+\n+\n+        //create a current path, and append our parent path to it\n+        final EdgePath<C> newEdgePath =\n+            new EdgePath<>( pipelineContext.getId(), cursorValue, getCursorSerializer(), parent );\n+\n+        //emit our value with the parent path\n+        return new FilterResult<>( emit, Optional.of( newEdgePath ) );\n+\n     }\n \n ",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractSeekingFilter.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/AbstractPathFilter.java",
                "sha": "c68dc4a8f22b6bf930186eb101f279ee137da8ac",
                "status": "renamed"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Collector.java",
                "changes": 13,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Collector.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 3,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Collector.java",
                "patch": "@@ -20,11 +20,18 @@\n package org.apache.usergrid.corepersistence.pipeline.read;\n \n \n+import org.apache.usergrid.corepersistence.pipeline.PipelineOperation;\n+\n+\n /**\n- * A command that is used to reduce our stream of results into a final output\n- * @param <T>\n+ * A command that is used to reduce our stream of results into a stream of final batch outputs.  When used\n+ * no further transformation or encoding should occur.  Otherwise EdgePath data will be lost, and serialization cannot occur\n+ * across requests\n+ *\n+ * @param <T>  The input type\n+ * @param <R> The output type\n  */\n-public interface Collector<T, R> extends PipelineOperation<T, R> {\n+public interface Collector<T, R> extends PipelineOperation<T,R> {\n \n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Collector.java",
                "sha": "e28ce4411ba00e1ce639fccc832dbb52ce4ab7a7",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/CollectorFactory.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/CollectorFactory.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 9,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/CollectorFactory.java",
                "patch": "@@ -20,25 +20,19 @@\n package org.apache.usergrid.corepersistence.pipeline.read;\n \n \n-import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.CandidateResultsEntityResultsCollector;\n-import org.apache.usergrid.corepersistence.pipeline.read.entity.EntityLoadCollector;\n+import org.apache.usergrid.corepersistence.pipeline.read.collect.ResultsPageCollector;\n \n \n /**\n  * A factory for generating collectors\n  */\n public interface CollectorFactory {\n \n-    /**\n-     * Generate a new instance of the command with the specified parameters\n-     */\n-    EntityLoadCollector entityLoadCollector();\n \n     /**\n-     * Get the collector for collection candidate results to entities\n+     * Get the results page collector\n      * @return\n      */\n-    CandidateResultsEntityResultsCollector candidateResultsEntityResultsCollector();\n-\n+   ResultsPageCollector getResultsPageCollector();\n \n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/CollectorFactory.java",
                "sha": "dd200b5b68b0114adf06e7e97e41a2bbb754482c",
                "status": "modified"
            },
            {
                "additions": 79,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/EdgePath.java",
                "changes": 79,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/EdgePath.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/EdgePath.java",
                "patch": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read;\n+\n+\n+import org.apache.usergrid.corepersistence.pipeline.cursor.CursorSerializer;\n+\n+import com.google.common.base.Optional;\n+\n+\n+/**\n+ * A path from our input element to our emitted element.  A list of EdgePaths comprise a path through the graph.  The chains of edge paths will result\n+ * in a cursor when aggregated.  If a graph traversal is the following\n+ *\n+ * applicationId(1) - \"users\" -> userId(2) - \"devices\" -> deviceId(3).  There would be 2 EdgePath\n+ *\n+ *  EdgePath(\"users\"->userId(2)) <- parent - EdgePath(\"devices\" -> deviceId(3))\n+ */\n+public class EdgePath<C> {\n+\n+\n+    private final int filterId;\n+    private final C cursorValue;\n+    private final CursorSerializer<C> serializer;\n+    private final Optional<EdgePath> previous;\n+\n+\n+    /**\n+     *\n+     * @param filterId The id of the filter that generated this path\n+     * @param cursorValue The value to resume seeking on the path\n+     * @param serializer The serializer to serialize the value\n+     * @param parent The parent graph path edge to reach this path\n+     */\n+    public EdgePath( final int filterId, final C cursorValue, final CursorSerializer<C> serializer,\n+                     final Optional<EdgePath> parent ) {\n+        this.filterId = filterId;\n+        this.cursorValue = cursorValue;\n+        this.serializer = serializer;\n+        this.previous = parent;\n+    }\n+\n+\n+    public C getCursorValue() {\n+        return cursorValue;\n+    }\n+\n+\n+    public int getFilterId() {\n+        return filterId;\n+    }\n+\n+\n+    public Optional<EdgePath> getPrevious() {\n+        return previous;\n+    }\n+\n+\n+    public CursorSerializer<C> getSerializer() {\n+        return serializer;\n+    }\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/EdgePath.java",
                "sha": "c560fad9d3542948f7d1bb52ac35be33735d8a3d",
                "status": "added"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Filter.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Filter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 4,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Filter.java",
                "patch": "@@ -20,11 +20,12 @@\n package org.apache.usergrid.corepersistence.pipeline.read;\n \n \n-import org.apache.usergrid.persistence.model.entity.Id;\n+import org.apache.usergrid.corepersistence.pipeline.PipelineOperation;\n \n \n /**\n- * Traverses edges in the graph.  Either by query or graph traversal.  Take an observable of ids, and emits\n- * an observable of ids\n+ * Traverses edges in the graph.  Either by query or graph traversal.  Take an observable of FilterResult, and emits\n+ * an observable of FilterResults.  Filters should never emit groups or objects that represent collections.  Items should\n+ * always be emitted 1 at a time.  It is the responsibility of the collector to aggregate results.\n  */\n-public interface Filter<T, R> extends PipelineOperation<T, R> {}\n+public interface Filter<T, R> extends PipelineOperation<T, FilterResult<R>> {}",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/Filter.java",
                "sha": "054a85a11de3ac71db0b04e9c339b4f62ce21738",
                "status": "modified"
            },
            {
                "additions": 34,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java",
                "changes": 40,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 6,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java",
                "patch": "@@ -20,10 +20,14 @@\n package org.apache.usergrid.corepersistence.pipeline.read;\n \n \n-import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.CandidateResultsIdVerifyFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.collect.EntityFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.collect.IdCursorSerializer;\n+import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.CandidateEntityFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.CandidateIdFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.ElasticSearchCollectionFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.ElasticSearchConnectionFilter;\n-import org.apache.usergrid.corepersistence.pipeline.read.entity.EntityIdFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.graph.EntityIdFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.graph.EntityLoadFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.graph.ReadGraphCollectionByIdFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.graph.ReadGraphCollectionFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.graph.ReadGraphConnectionByIdFilter;\n@@ -43,6 +47,7 @@\n \n     /**\n      * Generate a new instance of the command with the specified parameters\n+     *\n      * @param collectionName The collection name to use when reading the graph\n      */\n     ReadGraphCollectionFilter readGraphCollectionFilter( final String collectionName );\n@@ -57,12 +62,14 @@\n \n     /**\n      * Generate a new instance of the command with the specified parameters\n+     *\n      * @param connectionName The connection name to use when traversing the graph\n      */\n     ReadGraphConnectionFilter readGraphConnectionFilter( final String connectionName );\n \n     /**\n      * Generate a new instance of the command with the specified parameters\n+     *\n      * @param connectionName The connection name to use when traversing the graph\n      * @param entityType The entity type to use when traversing the graph\n      */\n@@ -72,13 +79,15 @@ ReadGraphConnectionByTypeFilter readGraphConnectionByTypeFilter(\n \n     /**\n      * Read a connection directly between two identifiers\n+     *\n      * @param connectionName The connection name to use when traversing the graph\n-     * @param targetId  The target Id to use when traversing the graph\n+     * @param targetId The target Id to use when traversing the graph\n      */\n     ReadGraphConnectionByIdFilter readGraphConnectionByIdFilter( final String connectionName, final Id targetId );\n \n     /**\n      * Generate a new instance of the command with the specified parameters\n+     *\n      * @param query The query to use when querying the entities in the collection\n      * @param collectionName The collection name to use when querying\n      */\n@@ -90,6 +99,7 @@ ElasticSearchCollectionFilter elasticSearchCollectionFilter( @Assisted( \"query\"\n \n     /**\n      * Generate a new instance of the command with the specified parameters\n+     *\n      * @param query The query to use when querying the entities in the connection\n      * @param connectionName The type of connection to query\n      * @param connectedEntityType The type of entity in the connection.  Leave absent to query all entity types\n@@ -102,14 +112,32 @@ ElasticSearchConnectionFilter elasticSearchConnectionFilter( @Assisted( \"query\"\n \n \n     /**\n-     * Get a candidate ids verifier for collection results.  Should be inserted into pipelines where a query filter is an intermediate step,\n-     * not a final filter before collectors\n+     * Generate a new instance of the command with the specified parameters\n+     */\n+    EntityLoadFilter entityLoadFilter();\n+\n+    /**\n+     * Get the collector for collection candidate results to entities\n+     */\n+    CandidateEntityFilter candidateEntityFilter();\n+\n+    /**\n+     * Get a candidate ids verifier for collection results.  Should be inserted into pipelines where a query filter is\n+     * an intermediate step, not a final filter before collectors\n      */\n-    CandidateResultsIdVerifyFilter candidateResultsIdVerifyFilter();\n+    CandidateIdFilter candidateResultsIdVerifyFilter();\n \n     /**\n      * Get an entity id filter.  Used as a 1.0->2.0 bridge since we're not doing full traversals\n+     *\n      * @param entityId The entity id to emit\n      */\n     EntityIdFilter getEntityIdFilter( final Id entityId );\n+\n+\n+    /**\n+     * Create a new instance of our entity filter\n+     * @return\n+     */\n+    EntityFilter entityFilter();\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java",
                "sha": "a2f160568c483d0312f0c53b1c30153f273c7aeb",
                "status": "modified"
            },
            {
                "additions": 20,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterResult.java",
                "changes": 41,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterResult.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 21,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterResult.java",
                "patch": "@@ -17,41 +17,40 @@\n  * under the License.\n  */\n \n-package org.apache.usergrid.corepersistence.pipeline;\n+package org.apache.usergrid.corepersistence.pipeline.read;\n \n \n-import org.apache.usergrid.corepersistence.pipeline.cursor.ResponseCursor;\n-\n import com.google.common.base.Optional;\n \n \n /**\n- * Intermediate observable that will return results, as well as an optional cursor\n- * @param <R>\n+ * A bean that is passed between filters with immutable cursor state\n+ * @param <T>\n  */\n-public class PipelineResult<R> {\n-\n+public class FilterResult<T> {\n+    private final T value;\n+    private final Optional<EdgePath> path;\n \n-    private final R result;\n \n-    private final ResponseCursor responseCursor;\n+    /**\n+     * Create a new immutable filtervalue\n+     * @param value The value the filter emits\n+     * @param path The path to this value, if created\n+     */\n+    public FilterResult( final T value, final Optional<EdgePath> path ) {\n+        this.value = value;\n+        this.path = path;\n+    }\n \n \n-    public PipelineResult( final R result, final ResponseCursor responseCursor ) {\n-        this.result = result;\n-        this.responseCursor = responseCursor;\n+    public T getValue() {\n+        return value;\n     }\n \n \n-    /**\n-     * If the user requests our cursor, return the cursor\n-     * @return\n-     */\n-    public Optional<String> getCursor(){\n-        return this.responseCursor.encodeAsString();\n+    public Optional<EdgePath> getPath() {\n+        return path;\n     }\n \n-    public R getResult(){\n-        return result;\n-    }\n+\n }",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/PipelineResult.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterResult.java",
                "sha": "3c41a2bd60fe44b56515d84dcc23ca62b0b215ae",
                "status": "renamed"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilder.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilder.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 4,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilder.java",
                "patch": "@@ -20,9 +20,6 @@\n package org.apache.usergrid.corepersistence.pipeline.read;\n \n \n-import org.apache.usergrid.corepersistence.pipeline.PipelineResult;\n-import org.apache.usergrid.persistence.Entity;\n-import org.apache.usergrid.persistence.Results;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.common.base.Optional;\n@@ -103,5 +100,5 @@ ReadPipelineBuilder getConnectionWithQuery( final String connectionName, final O\n      * Load our entity results when our previous filter calls graph\n      * @return\n      */\n-    Observable<PipelineResult<ResultsPage>> execute();\n+    Observable<ResultsPage> execute();\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilder.java",
                "sha": "d0e87b3ea6ecd66a09005daaa113a3505056f704",
                "status": "modified"
            },
            {
                "additions": 51,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilderImpl.java",
                "changes": 80,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilderImpl.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 29,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilderImpl.java",
                "patch": "@@ -24,11 +24,11 @@\n import java.util.List;\n \n import org.apache.usergrid.corepersistence.pipeline.Pipeline;\n-import org.apache.usergrid.corepersistence.pipeline.PipelineResult;\n-import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.CandidateResultsEntityResultsCollector;\n-import org.apache.usergrid.corepersistence.pipeline.read.entity.EntityLoadCollector;\n+import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.CandidateEntityFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.graph.EntityLoadFilter;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.core.util.ValidationUtils;\n+import org.apache.usergrid.persistence.model.entity.Entity;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.common.base.Optional;\n@@ -52,6 +52,8 @@\n \n     private final ApplicationScope applicationScope;\n \n+    private final CollectorFactory collectorFactory;\n+\n \n     /**\n      * Our pointer to our collect filter. Set or cleared with each operation that's performed so the correct results are\n@@ -70,6 +72,7 @@ public ReadPipelineBuilderImpl( final FilterFactory filterFactory, final Collect\n         this.filterFactory = filterFactory;\n \n         this.applicationScope = applicationScope;\n+        this.collectorFactory = collectorFactory;\n \n         //init our cursor to empty\n         this.cursor = Optional.absent();\n@@ -78,7 +81,7 @@ public ReadPipelineBuilderImpl( final FilterFactory filterFactory, final Collect\n         this.limit = DEFAULT_LIMIT;\n \n \n-        this.collectorState = new CollectorState( collectorFactory );\n+        this.collectorState = new CollectorState( );\n \n         this.filters = new ArrayList<>();\n     }\n@@ -120,7 +123,7 @@ public ReadPipelineBuilder getEntityViaCollection( final String collectionName,\n \n         filters.add( filterFactory.readGraphCollectionByIdFilter( collectionName, entityId ) );\n \n-        this.collectorState.setEntityLoaderCollector();\n+        this.collectorState.setIdEntityLoaderFilter();\n \n         return this;\n     }\n@@ -132,7 +135,7 @@ public ReadPipelineBuilder getCollection( final String collectionName ) {\n \n         filters.add( filterFactory.readGraphCollectionFilter( collectionName ) );\n \n-        this.collectorState.setEntityLoaderCollector();\n+        this.collectorState.setIdEntityLoaderFilter();\n \n         return this;\n     }\n@@ -147,7 +150,7 @@ public ReadPipelineBuilder getCollectionWithQuery( final String collectionName,\n \n         filters.add( filterFactory.elasticSearchCollectionFilter( query, collectionName, entityType ) );\n \n-        this.collectorState.setCandidateResultsEntityResultsCollector();\n+        this.collectorState.setCandidateEntityFilter();\n \n         return this;\n     }\n@@ -159,7 +162,7 @@ public ReadPipelineBuilder getEntityViaConnection( final String connectionName,\n         ValidationUtils.verifyIdentity( entityId );\n \n         filters.add( filterFactory.readGraphConnectionByIdFilter( connectionName, entityId ) );\n-        collectorState.setEntityLoaderCollector();\n+        collectorState.setIdEntityLoaderFilter();\n \n         return this;\n     }\n@@ -169,7 +172,7 @@ public ReadPipelineBuilder getEntityViaConnection( final String connectionName,\n     public ReadPipelineBuilder getConnection( final String connectionName ) {\n         Preconditions.checkNotNull( connectionName, \"connectionName must not be null\" );\n         filters.add( filterFactory.readGraphConnectionFilter( connectionName ) );\n-        collectorState.setEntityLoaderCollector();\n+        collectorState.setIdEntityLoaderFilter();\n \n         return this;\n     }\n@@ -182,7 +185,7 @@ public ReadPipelineBuilder getConnection( final String connectionName, final Str\n \n         filters.add( filterFactory.readGraphConnectionByTypeFilter( connectionName, entityType ) );\n \n-        collectorState.setEntityLoaderCollector();\n+        collectorState.setIdEntityLoaderFilter();\n         return this;\n     }\n \n@@ -196,17 +199,30 @@ public ReadPipelineBuilder getConnectionWithQuery( final String connectionName,\n         Preconditions.checkNotNull( query, \"query must not be null\" );\n \n         filters.add( filterFactory.elasticSearchConnectionFilter( query, connectionName, entityType ) );\n-        collectorState.setCandidateResultsEntityResultsCollector();\n+        collectorState.setCandidateEntityFilter();\n         return this;\n     }\n \n \n     @Override\n-    public Observable<PipelineResult<ResultsPage>> execute() {\n+    public Observable<ResultsPage> execute() {\n \n         ValidationUtils.validateApplicationScope( applicationScope );\n \n-        final Collector<?, ResultsPage> collector = collectorState.getCollector();\n+\n+        //add our last filter that will generate entities\n+        final Filter<?, Entity> entityLoadFilter = collectorState.getFinalFilter();\n+\n+        filters.add( entityLoadFilter );\n+\n+        //add the filter that skips the first result on resume\n+        final Filter<Entity, Entity>  cursorEntityFilter = filterFactory.entityFilter();\n+\n+        filters.add( cursorEntityFilter );\n+\n+\n+        //execute our collector\n+        final Collector<?, ResultsPage> collector = collectorFactory.getResultsPageCollector();\n \n         Preconditions.checkNotNull( collector,\n             \"You have not specified an operation that creates a collection filter.  This is required for loading \"\n@@ -229,46 +245,52 @@ public ReadPipelineBuilder getConnectionWithQuery( final String connectionName,\n      * A mutable state for our collectors.  Rather than create a new instance each time, we create a singleton\n      * collector\n      */\n-    private static final class CollectorState {\n-        private final CollectorFactory collectorFactory;\n+    private final class CollectorState {\n+\n \n-        private EntityLoadCollector entityLoadCollector;\n+        private EntityLoadFilter entityLoadCollector;\n \n-        private CandidateResultsEntityResultsCollector candidateResultsEntityResultsCollector;\n+        private CandidateEntityFilter candidateEntityFilter;\n \n+        private Filter entityLoadFilter;\n \n-        private Collector<?, ResultsPage> collector = null;\n \n \n-        private CollectorState( final CollectorFactory collectorFactory ) {this.collectorFactory = collectorFactory;}\n+        private CollectorState( ){}\n \n \n-        public void setEntityLoaderCollector() {\n+        /**\n+         * Set our final filter to be a load entity by Id filter\n+         */\n+        public void setIdEntityLoaderFilter() {\n             if ( entityLoadCollector == null ) {\n-                entityLoadCollector = collectorFactory.entityLoadCollector();\n+                entityLoadCollector = filterFactory.entityLoadFilter();\n             }\n \n \n-            collector = entityLoadCollector;\n+            entityLoadFilter = entityLoadCollector;\n         }\n \n \n-        public void setCandidateResultsEntityResultsCollector() {\n-            if ( candidateResultsEntityResultsCollector == null ) {\n-                candidateResultsEntityResultsCollector = collectorFactory.candidateResultsEntityResultsCollector();\n+        /**\n+         * Set our final filter to be a load entity by candidate filter\n+         */\n+        public void setCandidateEntityFilter() {\n+            if ( candidateEntityFilter == null ) {\n+                candidateEntityFilter = filterFactory.candidateEntityFilter();\n             }\n \n-            collector = candidateResultsEntityResultsCollector;\n+            entityLoadFilter = candidateEntityFilter;\n         }\n \n \n         public void clear() {\n-            collector = null;\n+            entityLoadFilter = null;\n         }\n \n \n-        public Collector<?, ResultsPage> getCollector() {\n-            return collector;\n+        public Filter<?, Entity> getFinalFilter() {\n+            return entityLoadFilter;\n         }\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ReadPipelineBuilderImpl.java",
                "sha": "28446ad4295ecb5c414ac9b77dc8815a3961c991",
                "status": "modified"
            },
            {
                "additions": 21,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ResultsPage.java",
                "changes": 26,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ResultsPage.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 5,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ResultsPage.java",
                "patch": "@@ -22,18 +22,28 @@\n \n import java.util.List;\n \n+import org.apache.usergrid.corepersistence.pipeline.cursor.ResponseCursor;\n import org.apache.usergrid.persistence.model.entity.Entity;\n \n \n /**\n- * An encapsulation of entities as a group of responses.  Ordered by the requesting filters.  Each set should be considered a \"page\" of results.\n+ * An encapsulation of entities as a group of responses.  Ordered by the requesting filters.  Each set should be\n+ * considered a \"page\" of results.  A hold over from 1.0.  We shouldn't need this when we fully move away from the EM/RM\n  */\n public class ResultsPage {\n \n     private final List<Entity> entityList;\n \n+    private final int limit;\n \n-    public ResultsPage( final List<Entity> entityList ) {this.entityList = entityList;}\n+    private final ResponseCursor responseCursor;\n+\n+\n+    public ResultsPage( final List<Entity> entityList, final ResponseCursor responseCursor, final int limit ) {\n+        this.entityList = entityList;\n+        this.responseCursor = responseCursor;\n+        this.limit = limit;\n+    }\n \n \n     public List<Entity> getEntityList() {\n@@ -43,9 +53,15 @@\n \n     /**\n      * Return true if the results page is empty\n-     * @return\n      */\n-    public boolean isEmpty(){\n-        return entityList == null || entityList.isEmpty();\n+    public boolean hasMoreResults() {\n+        return entityList != null && entityList.size() == limit;\n+    }\n+\n+\n+\n+\n+    public ResponseCursor getResponseCursor() {\n+        return responseCursor;\n     }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/ResultsPage.java",
                "sha": "1810d65410984b819a37ef3ed369b0e1cf834a64",
                "status": "modified"
            },
            {
                "additions": 46,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/AbstractCollector.java",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/AbstractCollector.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/AbstractCollector.java",
                "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read.collect;\n+\n+\n+import org.apache.usergrid.corepersistence.pipeline.PipelineContext;\n+import org.apache.usergrid.corepersistence.pipeline.read.Collector;\n+import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+\n+\n+/**\n+ * Basic functionality for our commands to handle cursor IO\n+ * @param <T> the input type\n+ * @param <R> The output Type\n+ */\n+public abstract class AbstractCollector<T, R> implements Collector<T, R> {\n+\n+\n+    protected PipelineContext pipelineContext;\n+\n+\n+    @Override\n+    public void setContext( final PipelineContext pipelineContext ) {\n+        this.pipelineContext = pipelineContext;\n+    }\n+\n+\n+\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/AbstractCollector.java",
                "sha": "1c5175da04bdc45a277cff6d1fa1e60cf4a67866",
                "status": "added"
            },
            {
                "additions": 68,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/EntityFilter.java",
                "changes": 68,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/EntityFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/EntityFilter.java",
                "patch": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read.collect;\n+\n+\n+import org.apache.usergrid.corepersistence.pipeline.cursor.CursorSerializer;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractPathFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n+import org.apache.usergrid.persistence.model.entity.Entity;\n+import org.apache.usergrid.persistence.model.entity.Id;\n+\n+import com.google.common.base.Optional;\n+\n+import rx.Observable;\n+\n+\n+/**\n+ * A filter that is used when we can potentially serialize pages via cursor.  This will filter the first result, only if\n+ * it matches the Id that was set\n+ */\n+public class EntityFilter extends AbstractPathFilter<Entity, Entity, Id> implements Filter<Entity, Entity> {\n+\n+\n+    @Override\n+    public Observable<FilterResult<Entity>> call( final Observable<FilterResult<Entity>> filterResultObservable ) {\n+\n+        //filter only the first id, then map into our path for our next pass\n+\n+\n+        return filterResultObservable.skipWhile( filterResult -> {\n+\n+            final Optional<Id> startFromCursor = getSeekValue();\n+\n+            return startFromCursor.isPresent() && startFromCursor.get().equals( filterResult.getValue().getId() );\n+        } ).map( filterResult -> {\n+\n+\n+            final Entity entity = filterResult.getValue();\n+            final Id entityId = entity.getId();\n+\n+            return createFilterResult( entity, entityId, filterResult.getPath() );\n+        } );\n+    }\n+\n+\n+    @Override\n+    protected CursorSerializer<Id> getCursorSerializer() {\n+        return IdCursorSerializer.INSTANCE;\n+    }\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/EntityFilter.java",
                "sha": "daf2e7fe0401c6ad62677803d27cf18a6f0d913d",
                "status": "added"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/IdCursorSerializer.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/IdCursorSerializer.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 5,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/IdCursorSerializer.java",
                "patch": "@@ -17,15 +17,25 @@\n  * under the License.\n  */\n \n-package org.apache.usergrid.corepersistence.pipeline.read;\n+package org.apache.usergrid.corepersistence.pipeline.read.collect;\n \n \n-import org.apache.usergrid.persistence.index.CandidateResults;\n+import org.apache.usergrid.corepersistence.pipeline.cursor.AbstractCursorSerializer;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n \n /**\n- * Traverses edges in the graph.  Either by query or graph traversal.  Take an observable of ids, and emits\n- * an observable of ids\n+ * cursor serializer for Ids\n  */\n-public interface CandidateResultsFilter extends PipelineOperation<Id, CandidateResults> {}\n+public class IdCursorSerializer extends AbstractCursorSerializer<Id> {\n+\n+\n+    public static final IdCursorSerializer INSTANCE = new IdCursorSerializer();\n+\n+    @Override\n+    protected Class<Id> getType() {\n+        return Id.class;\n+    }\n+\n+\n+}",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/CandidateResultsFilter.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/IdCursorSerializer.java",
                "sha": "d96b9f2f01a23f5158b27d25cb70d715e8560905",
                "status": "renamed"
            },
            {
                "additions": 80,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/ResultsPageCollector.java",
                "changes": 80,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/ResultsPageCollector.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/ResultsPageCollector.java",
                "patch": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read.collect;\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.usergrid.corepersistence.pipeline.cursor.ResponseCursor;\n+import org.apache.usergrid.corepersistence.pipeline.read.Collector;\n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n+import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n+import org.apache.usergrid.persistence.model.entity.Entity;\n+\n+import com.google.common.base.Optional;\n+\n+import rx.Observable;\n+\n+\n+/**\n+ * Takes entities and collects them into results.  This mostly exists for 1.0 compatibility.  Eventually this will\n+ * become the only collector in our pipline and be used when rendering results, both on GET, PUT and POST.\n+ */\n+public class ResultsPageCollector extends AbstractCollector<Entity, ResultsPage>\n+    implements Collector<Entity, ResultsPage> {\n+\n+\n+    @Override\n+    public Observable<ResultsPage> call( final Observable<FilterResult<Entity>> filterResultObservable ) {\n+\n+        final int limit = pipelineContext.getLimit();\n+\n+        return filterResultObservable.buffer( limit ).flatMap( buffer -> Observable.from( buffer ).collect(\n+            () -> new ResultsPageWithCursorCollector( limit ), ( collector, entity ) -> {\n+                collector.add( entity );\n+            } ) ).map( resultsPageCollector -> new ResultsPage( resultsPageCollector.results,\n+            new ResponseCursor( resultsPageCollector.lastPath ), pipelineContext.getLimit() ) );\n+    }\n+\n+\n+    /**\n+     * A collector that will aggregate our results together\n+     */\n+    private static class ResultsPageWithCursorCollector {\n+\n+\n+        private final List<Entity> results;\n+\n+        private Optional<EdgePath> lastPath;\n+\n+\n+        private ResultsPageWithCursorCollector( final int limit ) {\n+            this.results = new ArrayList<>( limit );\n+        }\n+\n+\n+        public void add( final FilterResult<Entity> result ) {\n+            this.results.add( result.getValue() );\n+            this.lastPath = result.getPath();\n+        }\n+    }\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/collect/ResultsPageCollector.java",
                "sha": "84654aa67530f57811b2eb89fa1edc3a5bdb16c6",
                "status": "added"
            },
            {
                "additions": 30,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/AbstractElasticSearchFilter.java",
                "changes": 45,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/AbstractElasticSearchFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 15,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/AbstractElasticSearchFilter.java",
                "patch": "@@ -24,11 +24,13 @@\n import org.slf4j.LoggerFactory;\n \n import org.apache.usergrid.corepersistence.pipeline.cursor.CursorSerializer;\n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractSeekingFilter;\n-import org.apache.usergrid.corepersistence.pipeline.read.CandidateResultsFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractPathFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.core.metrics.MetricsFactory;\n import org.apache.usergrid.persistence.core.metrics.ObservableTimer;\n import org.apache.usergrid.persistence.index.ApplicationEntityIndex;\n+import org.apache.usergrid.persistence.index.CandidateResult;\n import org.apache.usergrid.persistence.index.CandidateResults;\n import org.apache.usergrid.persistence.index.EntityIndexFactory;\n import org.apache.usergrid.persistence.index.SearchEdge;\n@@ -44,8 +46,8 @@\n /**\n  * Command for reading graph edges\n  */\n-public abstract class AbstractElasticSearchFilter extends AbstractSeekingFilter<Id, CandidateResults, Integer>\n-    implements CandidateResultsFilter {\n+public abstract class AbstractElasticSearchFilter extends AbstractPathFilter<Id, Candidate, Integer>\n+    implements Filter<Id, Candidate> {\n \n     private static final Logger log = LoggerFactory.getLogger( AbstractElasticSearchFilter.class );\n \n@@ -66,7 +68,7 @@ public AbstractElasticSearchFilter( final EntityIndexFactory entityIndexFactory,\n \n \n     @Override\n-    public Observable<CandidateResults> call( final Observable<Id> observable ) {\n+    public Observable<FilterResult<Candidate>> call( final Observable<FilterResult<Id>> observable ) {\n \n         //get the graph manager\n         final ApplicationEntityIndex applicationEntityIndex =\n@@ -80,12 +82,12 @@ public AbstractElasticSearchFilter( final EntityIndexFactory entityIndexFactory,\n \n \n         //return all ids that are emitted from this edge\n-        return observable.flatMap( id -> {\n+        return observable.flatMap( idFilterResult -> {\n \n-            final SearchEdge searchEdge = getSearchEdge( id );\n+            final SearchEdge searchEdge = getSearchEdge( idFilterResult.getValue() );\n \n \n-            final Observable<CandidateResults> candidates = Observable.create( subscriber -> {\n+            final Observable<FilterResult<Candidate>> candidates = Observable.create( subscriber -> {\n \n                 //our offset to our start value.  This will be set the first time we emit\n                 //after we receive new ids, we want to reset this to 0\n@@ -98,28 +100,41 @@ public AbstractElasticSearchFilter( final EntityIndexFactory entityIndexFactory,\n \n                 subscriber.onStart();\n \n-                //emit while we have values from ES\n-                while ( true ) {\n+                //emit while we have values from ES and someone is subscribed\n+                while ( !subscriber.isUnsubscribed() ) {\n \n \n                     try {\n                         final CandidateResults candidateResults =\n                             applicationEntityIndex.search( searchEdge, searchTypes, query, limit, currentOffSet );\n \n-                        currentOffSet += candidateResults.size();\n \n-                        //set the cursor for the next value\n-                        setCursor( currentOffSet );\n+\n+                        for( CandidateResult candidateResult: candidateResults){\n+\n+                            //our subscriber unsubscribed, break out\n+                            if(subscriber.isUnsubscribed()){\n+                                return;\n+                            }\n+\n+                            final Candidate candidate = new Candidate( candidateResult, searchEdge );\n+\n+                            final FilterResult<Candidate>\n+                                result = createFilterResult( candidate, currentOffSet, idFilterResult.getPath() );\n+\n+                            subscriber.onNext( result );\n+\n+                            currentOffSet++;\n+                        }\n \n                         /**\n                          * No candidates, we're done\n                          */\n-                        if ( candidateResults.size() == 0 ) {\n+                        if (candidateResults.size() < limit) {\n                             subscriber.onCompleted();\n                             return;\n                         }\n \n-                        subscriber.onNext( candidateResults );\n                     }\n                     catch ( Throwable t ) {\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/AbstractElasticSearchFilter.java",
                "sha": "f403e21fc6beae59c349cb7a707de775b5d46637",
                "status": "modified"
            },
            {
                "additions": 26,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/Candidate.java",
                "changes": 38,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/Candidate.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 12,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/Candidate.java",
                "patch": "@@ -7,7 +7,7 @@\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n  *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n@@ -17,25 +17,39 @@\n  * under the License.\n  */\n \n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n+package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch;\n \n \n-import org.apache.usergrid.persistence.Query;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n+import org.apache.usergrid.persistence.index.CandidateResult;\n import org.apache.usergrid.persistence.index.SearchEdge;\n \n \n /**\n- * Factory for creating results\n+ * Create a candidate. This holds the original candidate, as well as the search scope it was found it\n  */\n-public interface ResultsLoaderFactory {\n+public class Candidate {\n+\n+    private final CandidateResult candidateResult;\n+    private final SearchEdge searchEdge;\n+\n \n     /**\n-     * Get the loader for results\n-     * @param applicationScope The application scope used to load results\n-     * @param indexScope The index scope used in the search\n-     * @param\n+     * Create a new Candidate for further processing\n+     * @param candidateResult  The candidate result\n+     * @param searchEdge The search edge this was searched on\n      */\n-    ResultsLoader getLoader( final ApplicationScope applicationScope, final SearchEdge indexScope,\n-                             final Query.Level resultsLevel );\n+    public Candidate( final CandidateResult candidateResult, final SearchEdge searchEdge ) {\n+        this.candidateResult = candidateResult;\n+        this.searchEdge = searchEdge;\n+    }\n+\n+\n+    public CandidateResult getCandidateResult() {\n+        return candidateResult;\n+    }\n+\n+\n+    public SearchEdge getSearchEdge() {\n+        return searchEdge;\n+    }\n }",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsLoaderFactory.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/Candidate.java",
                "sha": "ab9d5d9485aa679dcf2ce9aa277bf4ab9a8677a7",
                "status": "renamed"
            },
            {
                "additions": 58,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateEntityFilter.java",
                "changes": 99,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateEntityFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 41,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateEntityFilter.java",
                "patch": "@@ -27,49 +27,53 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractPipelineOperation;\n-import org.apache.usergrid.corepersistence.pipeline.read.Collector;\n-import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n+import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n import org.apache.usergrid.persistence.collection.EntitySet;\n import org.apache.usergrid.persistence.collection.MvccEntity;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.index.ApplicationEntityIndex;\n import org.apache.usergrid.persistence.index.CandidateResult;\n-import org.apache.usergrid.persistence.index.CandidateResults;\n import org.apache.usergrid.persistence.index.EntityIndexBatch;\n import org.apache.usergrid.persistence.index.EntityIndexFactory;\n import org.apache.usergrid.persistence.index.SearchEdge;\n import org.apache.usergrid.persistence.model.entity.Entity;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.fasterxml.uuid.UUIDComparator;\n+import com.google.common.base.Optional;\n import com.google.inject.Inject;\n \n import rx.Observable;\n \n \n /**\n- * Loads entities from an incoming CandidateResults object and return them as results\n+ * Loads entities from an incoming CandidateResult emissions into entities, then streams them on\n+ * performs internal buffering for efficiency.  Note that all entities may not be emitted if our load crosses page boundaries.  It is up to the\n+ * collector to determine when to stop streaming entities.\n  */\n-public class CandidateResultsEntityResultsCollector extends AbstractPipelineOperation<CandidateResults, ResultsPage>\n-    implements Collector<CandidateResults, ResultsPage> {\n+public class CandidateEntityFilter extends AbstractFilter<Candidate, Entity>\n+    implements Filter<Candidate, Entity> {\n \n     private final EntityCollectionManagerFactory entityCollectionManagerFactory;\n     private final EntityIndexFactory entityIndexFactory;\n \n \n     @Inject\n-    public CandidateResultsEntityResultsCollector( final EntityCollectionManagerFactory entityCollectionManagerFactory,\n-                                                   final EntityIndexFactory entityIndexFactory ) {\n+    public CandidateEntityFilter( final EntityCollectionManagerFactory entityCollectionManagerFactory,\n+                                  final EntityIndexFactory entityIndexFactory ) {\n         this.entityCollectionManagerFactory = entityCollectionManagerFactory;\n         this.entityIndexFactory = entityIndexFactory;\n     }\n \n \n     @Override\n-    public Observable<ResultsPage> call( final Observable<CandidateResults> candidateResultsObservable ) {\n+       public Observable<FilterResult<Entity>> call(\n+           final Observable<FilterResult<Candidate>> candidateResultsObservable ) {\n \n \n         /**\n@@ -86,43 +90,50 @@ public CandidateResultsEntityResultsCollector( final EntityCollectionManagerFact\n         final ApplicationEntityIndex applicationIndex =\n             entityIndexFactory.createApplicationEntityIndex( applicationScope );\n \n-        final Observable<ResultsPage> searchIdSetObservable = candidateResultsObservable.flatMap( candidateResults -> {\n-            //flatten toa list of ids to load\n-            final Observable<List<Id>> candidateIds =\n-                Observable.from( candidateResults ).map( candidate -> candidate.getId() ).toList();\n+        //buffer them to get a page size we can make 1 network hop\n+        final Observable<FilterResult<Entity>> searchIdSetObservable = candidateResultsObservable.buffer( pipelineContext.getLimit() )\n \n-            //load the ids\n-            final Observable<EntitySet> entitySetObservable =\n-                candidateIds.flatMap( ids -> entityCollectionManager.load( ids ) );\n+            //load them\n+            .flatMap( candidateResults -> {\n+                    //flatten toa list of ids to load\n+                    final Observable<List<Id>> candidateIds =\n+                        Observable.from( candidateResults ).map( filterResultCandidate -> filterResultCandidate.getValue().getCandidateResult().getId() ).toList();\n \n-            //now we have a collection, validate our canidate set is correct.\n+                    //load the ids\n+                    final Observable<EntitySet> entitySetObservable =\n+                        candidateIds.flatMap( ids -> entityCollectionManager.load( ids ) );\n \n-            return entitySetObservable\n-                .map( entitySet -> new EntityCollector( applicationIndex.createBatch(), entitySet, candidateResults ) )\n-                .doOnNext( entityCollector -> entityCollector.merge() )\n-                .map( entityCollector -> entityCollector.getResults() );\n-        } );\n+                    //now we have a collection, validate our canidate set is correct.\n+\n+                    return entitySetObservable.map(\n+                        entitySet -> new EntityVerifier( applicationIndex.createBatch(), entitySet,\n+                            candidateResults ) ).doOnNext( entityCollector -> entityCollector.merge() )\n+                                              .flatMap(\n+                                                  entityCollector -> Observable.from( entityCollector.getResults() ) );\n+                } );\n \n         //if we filter all our results, we want to continue to try the next page\n         return searchIdSetObservable;\n     }\n \n \n+\n+\n     /**\n      * Our collector to collect entities.  Not quite a true collector, but works within our operational flow as this state is mutable and difficult to represent functionally\n      */\n-    private static final class EntityCollector {\n+    private static final class EntityVerifier {\n \n-        private static final Logger logger = LoggerFactory.getLogger( EntityCollector.class );\n-        private List<Entity> results = new ArrayList<>();\n+        private static final Logger logger = LoggerFactory.getLogger( EntityVerifier.class );\n+        private List<FilterResult<Entity>> results = new ArrayList<>();\n \n         private final EntityIndexBatch batch;\n-        private final CandidateResults candidateResults;\n+        private final List<FilterResult<Candidate>> candidateResults;\n         private final EntitySet entitySet;\n \n \n-        public EntityCollector( final EntityIndexBatch batch, final EntitySet entitySet,\n-                                final CandidateResults candidateResults ) {\n+        public EntityVerifier( final EntityIndexBatch batch, final EntitySet entitySet,\n+                               final List<FilterResult<Candidate>> candidateResults ) {\n             this.batch = batch;\n             this.entitySet = entitySet;\n             this.candidateResults = candidateResults;\n@@ -135,16 +146,16 @@ public EntityCollector( final EntityIndexBatch batch, final EntitySet entitySet,\n          */\n         public void merge() {\n \n-            for ( final CandidateResult candidateResult : candidateResults ) {\n+            for ( final FilterResult<Candidate> candidateResult : candidateResults ) {\n                 validate( candidateResult );\n             }\n \n             batch.execute();\n         }\n \n \n-        public ResultsPage getResults() {\n-            return new ResultsPage( results );\n+        public List<FilterResult<Entity>> getResults() {\n+            return results;\n         }\n \n \n@@ -153,8 +164,11 @@ public EntityIndexBatch getBatch() {\n         }\n \n \n-        private void validate( final CandidateResult candidateResult ) {\n+        private void validate( final FilterResult<Candidate> filterResult ) {\n \n+            final Candidate candidate = filterResult.getValue();\n+            final CandidateResult candidateResult = candidate.getCandidateResult();\n+            final SearchEdge searchEdge = candidate.getSearchEdge();\n             final Id candidateId = candidateResult.getId();\n             final UUID candidateVersion = candidateResult.getVersion();\n \n@@ -178,13 +192,14 @@ private void validate( final CandidateResult candidateResult ) {\n \n \n             final UUID entityVersion = entity.getVersion();\n+            final Id entityId = entity.getId();\n+\n \n \n-            //entity is newer than ES version, could be an update or the entity is marked as deleted\n-            if ( UUIDComparator.staticCompare( entityVersion, candidateVersion ) > 0) {\n \n-                final Id entityId = entity.getId();\n-                final SearchEdge searchEdge = candidateResults.getSearchEdge();\n+\n+            //entity is newer than ES version, could be an update or the entity is marked as deleted\n+            if ( UUIDComparator.staticCompare( entityVersion, candidateVersion ) > 0 || !entity.getEntity().isPresent()) {\n \n                 logger.warn( \"Deindexing stale entity on edge {} for entityId {} and version {}\",\n                     new Object[] { searchEdge, entityId, entityVersion } );\n@@ -196,9 +211,6 @@ private void validate( final CandidateResult candidateResult ) {\n             //remove the ES record, since the read in cass should cause a read repair, just ignore\n             if ( UUIDComparator.staticCompare( candidateVersion, entityVersion ) > 0 ) {\n \n-                final Id entityId = entity.getId();\n-                final SearchEdge searchEdge = candidateResults.getSearchEdge();\n-\n                 logger.warn(\n                     \"Found a newer version in ES over cassandra for edge {} for entityId {} and version {}.  Repair \"\n                         + \"should be run\", new Object[] { searchEdge, entityId, entityVersion } );\n@@ -210,8 +222,13 @@ private void validate( final CandidateResult candidateResult ) {\n \n             //they're the same add it\n \n+            final Entity returnEntity = entity.getEntity().get();\n+\n+            final Optional<EdgePath> parent = filterResult.getPath();\n+\n+            final FilterResult<Entity> toReturn = new FilterResult<>( returnEntity, parent );\n \n-            results.add( entity.getEntity().get() );\n+            results.add( toReturn );\n         }\n     }\n }",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateResultsEntityResultsCollector.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateEntityFilter.java",
                "sha": "d30917c971a7fadb725f72ba72c1ff30bcc277c4",
                "status": "renamed"
            },
            {
                "additions": 40,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateIdFilter.java",
                "changes": 72,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateIdFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 32,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateIdFilter.java",
                "patch": "@@ -27,16 +27,17 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractPipelineOperation;\n-import org.apache.usergrid.corepersistence.pipeline.read.PipelineOperation;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractFilter;\n+import org.apache.usergrid.corepersistence.pipeline.PipelineOperation;\n+import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n import org.apache.usergrid.persistence.collection.MvccLogEntry;\n import org.apache.usergrid.persistence.collection.VersionSet;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.index.ApplicationEntityIndex;\n import org.apache.usergrid.persistence.index.CandidateResult;\n-import org.apache.usergrid.persistence.index.CandidateResults;\n import org.apache.usergrid.persistence.index.EntityIndexBatch;\n import org.apache.usergrid.persistence.index.EntityIndexFactory;\n import org.apache.usergrid.persistence.index.SearchEdge;\n@@ -52,24 +53,24 @@\n  * Responsible for verifying candidate result versions, then emitting the Ids of these versions\n  * Input is a batch of candidate results, output is a stream of validated Ids\n  */\n-public class CandidateResultsIdVerifyFilter extends AbstractPipelineOperation<CandidateResults, Id>\n-    implements PipelineOperation<CandidateResults, Id> {\n+public class CandidateIdFilter extends AbstractFilter<Candidate, Id>\n+    implements Filter<Candidate, Id> {\n \n     private final EntityCollectionManagerFactory entityCollectionManagerFactory;\n     private final EntityIndexFactory entityIndexFactory;\n \n \n     @Inject\n-    public CandidateResultsIdVerifyFilter( final EntityCollectionManagerFactory entityCollectionManagerFactory,\n-                                           final EntityIndexFactory entityIndexFactory ) {\n+    public CandidateIdFilter( final EntityCollectionManagerFactory entityCollectionManagerFactory,\n+                              final EntityIndexFactory entityIndexFactory ) {\n         this.entityCollectionManagerFactory = entityCollectionManagerFactory;\n         this.entityIndexFactory = entityIndexFactory;\n     }\n \n \n \n     @Override\n-    public Observable<Id> call( final Observable<CandidateResults> observable ) {\n+      public Observable<FilterResult<Id>> call( final Observable<FilterResult<Candidate>> filterResultObservable ) {\n \n \n         /**\n@@ -86,42 +87,47 @@ public CandidateResultsIdVerifyFilter( final EntityCollectionManagerFactory enti\n         final ApplicationEntityIndex applicationIndex =\n             entityIndexFactory.createApplicationEntityIndex( applicationScope );\n \n-        final Observable<Id> searchIdSetObservable = observable.flatMap( candidateResults -> {\n-            //flatten toa list of ids to load\n-            final Observable<List<Id>> candidateIds =\n-                Observable.from( candidateResults ).map( candidate -> candidate.getId() ).toList();\n+        final Observable<FilterResult<Id>> searchIdSetObservable = filterResultObservable.buffer( pipelineContext.getLimit() ).flatMap(\n+            candidateResults -> {\n+                //flatten toa list of ids to load\n+                final Observable<List<Id>> candidateIds =\n+                    Observable.from( candidateResults ).map( candidate -> candidate.getValue().getCandidateResult().getId() )\n+                              .toList();\n \n-            //load the ids\n-            final Observable<VersionSet> versionSetObservable =\n-                candidateIds.flatMap( ids -> entityCollectionManager.getLatestVersion( ids ) );\n+                //load the ids\n+                final Observable<VersionSet> versionSetObservable =\n+                    candidateIds.flatMap( ids -> entityCollectionManager.getLatestVersion( ids ) );\n \n-            //now we have a collection, validate our canidate set is correct.\n+                //now we have a collection, validate our canidate set is correct.\n \n-            return versionSetObservable\n-                .map( entitySet -> new EntityCollector( applicationIndex.createBatch(), entitySet, candidateResults ) )\n-                .doOnNext( entityCollector -> entityCollector.merge() )\n-                .flatMap( entityCollector -> Observable.from(  entityCollector.collectResults() ) );\n+                return versionSetObservable.map(\n+                    entitySet -> new EntityCollector( applicationIndex.createBatch(), entitySet, candidateResults ) )\n+                                           .doOnNext( entityCollector -> entityCollector.merge() ).flatMap(\n+                        entityCollector -> Observable.from( entityCollector.collectResults() ) );\n         } );\n \n         return searchIdSetObservable;\n     }\n \n \n+\n+\n+\n     /**\n      * Map a new cp entity to an old entity.  May be null if not present\n      */\n     private static final class EntityCollector {\n \n         private static final Logger logger = LoggerFactory.getLogger( EntityCollector.class );\n-        private List<Id> results = new ArrayList<>();\n+        private List<FilterResult<Id>> results = new ArrayList<>();\n \n         private final EntityIndexBatch batch;\n-        private final CandidateResults candidateResults;\n+        private final List<FilterResult<Candidate>> candidateResults;\n         private final VersionSet versionSet;\n \n \n         public EntityCollector( final EntityIndexBatch batch, final VersionSet versionSet,\n-                                final CandidateResults candidateResults ) {\n+                                final List<FilterResult<Candidate>> candidateResults ) {\n             this.batch = batch;\n             this.versionSet = versionSet;\n             this.candidateResults = candidateResults;\n@@ -134,24 +140,28 @@ public EntityCollector( final EntityIndexBatch batch, final VersionSet versionSe\n          */\n         public void merge() {\n \n-            for ( final CandidateResult candidateResult : candidateResults ) {\n+            for ( final FilterResult<Candidate> candidateResult : candidateResults ) {\n                 validate( candidateResult );\n             }\n \n             batch.execute();\n         }\n \n \n-        public List<Id> collectResults() {\n+        public List<FilterResult<Id>> collectResults() {\n             return results;\n         }\n \n \n         /**\n          * Validate each candidate results vs the data loaded from cass\n-         * @param candidateResult\n+         * @param filterCandidate\n          */\n-        private void validate( final CandidateResult candidateResult ) {\n+        private void validate( final FilterResult<Candidate> filterCandidate ) {\n+\n+            final CandidateResult candidateResult = filterCandidate.getValue().getCandidateResult();\n+\n+            final SearchEdge searchEdge = filterCandidate.getValue().getSearchEdge();\n \n             final MvccLogEntry logEntry = versionSet.getMaxVersion( candidateResult.getId() );\n \n@@ -164,8 +174,6 @@ private void validate( final CandidateResult candidateResult ) {\n             //entity is newer than ES version\n             if ( UUIDComparator.staticCompare( entityVersion, candidateVersion ) > 0 ) {\n \n-                final SearchEdge searchEdge = candidateResults.getSearchEdge();\n-\n                 logger.warn( \"Deindexing stale entity on edge {} for entityId {} and version {}\",\n                     new Object[] { searchEdge, entityId, entityVersion } );\n                 batch.deindex( searchEdge, entityId, entityVersion );\n@@ -176,16 +184,16 @@ private void validate( final CandidateResult candidateResult ) {\n             //remove the ES record, since the read in cass should cause a read repair, just ignore\n             if ( UUIDComparator.staticCompare( candidateVersion, entityVersion ) > 0 ) {\n \n-                final SearchEdge searchEdge = candidateResults.getSearchEdge();\n-\n                 logger.warn(\n                     \"Found a newer version in ES over cassandra for edge {} for entityId {} and version {}.  Repair \"\n                         + \"should be run\", new Object[] { searchEdge, entityId, entityVersion } );\n             }\n \n             //they're the same add it\n \n-            results.add( entityId );\n+            final FilterResult<Id> result = new FilterResult<>( entityId, filterCandidate.getPath()  );\n+\n+            results.add( result );\n         }\n     }\n ",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateResultsIdVerifyFilter.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/CandidateIdFilter.java",
                "sha": "56e1c1cef0358a2ed9b0ffd2ecb0bd094c3163af",
                "status": "renamed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionRefsVerifier.java",
                "changes": 44,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionRefsVerifier.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 44,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionRefsVerifier.java",
                "patch": "@@ -1,44 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-\n-import org.apache.usergrid.persistence.EntityRef;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.SimpleEntityRef;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-\n-public class CollectionRefsVerifier extends VersionVerifier {\n-\n-\n-\n-    @Override\n-    public Results getResults( final Collection<Id> ids ) {\n-        List<EntityRef> refs = new ArrayList<EntityRef>(ids.size());\n-        for ( Id id : ids ) {\n-            refs.add( new SimpleEntityRef( id.getType(), id.getUuid() ) );\n-        }\n-        return Results.fromRefList( refs );\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionRefsVerifier.java",
                "sha": "cc966333c16e14fde566cf4160acabc14b75dd24",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionResultsLoaderFactoryImpl.java",
                "changes": 65,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionResultsLoaderFactoryImpl.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 65,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionResultsLoaderFactoryImpl.java",
                "patch": "@@ -1,65 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import org.apache.usergrid.persistence.Query;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n-import org.apache.usergrid.persistence.index.ApplicationEntityIndex;\n-import org.apache.usergrid.persistence.index.SearchEdge;\n-\n-\n-/**\n- * Factory for creating results\n- */\n-public class CollectionResultsLoaderFactoryImpl implements ResultsLoaderFactory {\n-\n-    private final EntityCollectionManager entityCollectionManager;\n-    private final ApplicationEntityIndex applicationEntityIndex;\n-\n-\n-    public CollectionResultsLoaderFactoryImpl( final EntityCollectionManager entityCollectionManager,\n-        final ApplicationEntityIndex applicationEntityIndex ) {\n-        this.entityCollectionManager = entityCollectionManager;\n-        this.applicationEntityIndex = applicationEntityIndex;\n-    }\n-\n-\n-    @Override\n-    public ResultsLoader getLoader( final ApplicationScope applicationScope, final SearchEdge scope,\n-                                    final Query.Level resultsLevel ) {\n-\n-        ResultsVerifier verifier;\n-\n-        if ( resultsLevel == Query.Level.REFS ) {\n-            verifier = new CollectionRefsVerifier();\n-        }\n-        else if ( resultsLevel == Query.Level.IDS ) {\n-            verifier = new IdsVerifier();\n-        }\n-        else {\n-            verifier = new EntityVerifier( Query.MAX_LIMIT );\n-        }\n-\n-        return new FilteringLoader( entityCollectionManager, applicationEntityIndex, verifier, applicationScope,\n-            scope );\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/CollectionResultsLoaderFactoryImpl.java",
                "sha": "94c91d9750be5d4e1d147b92b3c03eb5786fb1d5",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionRefsVerifier.java",
                "changes": 59,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionRefsVerifier.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 59,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionRefsVerifier.java",
                "patch": "@@ -1,59 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-\n-import org.apache.usergrid.persistence.ConnectionRef;\n-import org.apache.usergrid.persistence.EntityRef;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.cassandra.ConnectionRefImpl;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-import static org.apache.usergrid.persistence.SimpleEntityRef.ref;\n-\n-\n-/**\n- * Verifier for creating connections\n- */\n-public class ConnectionRefsVerifier extends VersionVerifier {\n-\n-\n-    private final EntityRef ownerId;\n-    private final String connectionType;\n-\n-\n-    public ConnectionRefsVerifier( final EntityRef ownerId, final String connectionType ) {\n-        this.ownerId = ownerId;\n-        this.connectionType = connectionType;\n-    }\n-\n-    @Override\n-    public Results getResults( final Collection<Id> ids ) {\n-        List<ConnectionRef> refs = new ArrayList<>();\n-        for ( Id id : ids ) {\n-            refs.add( new ConnectionRefImpl( ownerId, connectionType, ref(id.getType(), id.getUuid())  ));\n-        }\n-\n-        return Results.fromConnections( refs );\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionRefsVerifier.java",
                "sha": "6b7bddeb048dcb9b39cf3c62bab5d3546d458726",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionResultsLoaderFactoryImpl.java",
                "changes": 73,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionResultsLoaderFactoryImpl.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 73,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionResultsLoaderFactoryImpl.java",
                "patch": "@@ -1,73 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import org.apache.usergrid.persistence.EntityRef;\n-import org.apache.usergrid.persistence.Query;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n-import org.apache.usergrid.persistence.index.ApplicationEntityIndex;\n-import org.apache.usergrid.persistence.index.EntityIndexFactory;\n-import org.apache.usergrid.persistence.index.SearchEdge;\n-\n-\n-/**\n- * Factory for creating results\n- */\n-public class ConnectionResultsLoaderFactoryImpl implements ResultsLoaderFactory {\n-\n-    private final EntityCollectionManager entityCollectionManager;\n-    private final ApplicationEntityIndex applicationEntityIndex;\n-    private final EntityRef ownerId;\n-    private final String connectionType;\n-\n-\n-    public ConnectionResultsLoaderFactoryImpl( final EntityCollectionManager entityCollectionManager,\n-                                               final ApplicationEntityIndex applicationEntityIndex, final EntityRef ownerId,\n-                                               final String connectionType ) {\n-        this.entityCollectionManager = entityCollectionManager;\n-        this.applicationEntityIndex = applicationEntityIndex;\n-        this.ownerId = ownerId;\n-        this.connectionType = connectionType;\n-    }\n-\n-\n-    @Override\n-    public ResultsLoader getLoader( final ApplicationScope applicationScope, final SearchEdge scope,\n-                                    final Query.Level resultsLevel ) {\n-\n-        ResultsVerifier verifier;\n-\n-        if ( resultsLevel == Query.Level.REFS ) {\n-            verifier = new ConnectionRefsVerifier( ownerId, connectionType );\n-        }\n-        else if ( resultsLevel == Query.Level.IDS ) {\n-            verifier = new ConnectionRefsVerifier( ownerId, connectionType );\n-            ;\n-        }\n-        else {\n-            verifier = new EntityVerifier( Query.MAX_LIMIT );\n-        }\n-\n-        return new FilteringLoader( entityCollectionManager, applicationEntityIndex, verifier, applicationScope, scope );\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ConnectionResultsLoaderFactoryImpl.java",
                "sha": "55b95a93efd565fadf0ad517b59d3bbf5f9f64c4",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ElasticSearchQueryExecutor.java",
                "changes": 224,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ElasticSearchQueryExecutor.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 224,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ElasticSearchQueryExecutor.java",
                "patch": "@@ -1,224 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.Iterator;\n-import java.util.NoSuchElementException;\n-\n-import org.apache.usergrid.persistence.index.*;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.usergrid.persistence.Query;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n-\n-import com.google.common.base.Optional;\n-\n-\n-public class ElasticSearchQueryExecutor implements Iterable<Results>, Iterator<Results> {\n-\n-    private static final Logger logger = LoggerFactory.getLogger( ElasticSearchQueryExecutor.class );\n-\n-    private final ResultsLoaderFactory resultsLoaderFactory;\n-\n-    private final ApplicationScope applicationScope;\n-\n-    private final ApplicationEntityIndex entityIndex;\n-\n-    private final SearchEdge indexScope;\n-\n-    private final SearchTypes types;\n-\n-    private final String query;\n-\n-    private final Optional<Integer> setOffsetFromCursor;\n-\n-    private final int limit;\n-\n-    private int offset;\n-\n-\n-    private Results currentResults;\n-\n-    private boolean moreToLoad = true;\n-\n-\n-\n-\n-    public ElasticSearchQueryExecutor( final ResultsLoaderFactory resultsLoaderFactory, final ApplicationEntityIndex entityIndex,\n-                                       final ApplicationScope applicationScope, final SearchEdge indexScope,\n-                                       final SearchTypes types, final String query, final Optional<Integer> setOffsetFromCursor, final int limit ) {\n-        this.resultsLoaderFactory = resultsLoaderFactory;\n-        this.applicationScope = applicationScope;\n-        this.entityIndex = entityIndex;\n-        this.indexScope = indexScope;\n-        this.types = types;\n-        this.setOffsetFromCursor = setOffsetFromCursor;\n-\n-        //we must deep copy the query passed.  Otherwise we will modify it's state with cursors.  Won't fix, not relevant\n-        //once we start subscribing to streams.\n-        this.query = query;\n-        this.limit = limit;\n-    }\n-\n-\n-    @Override\n-    public Iterator<Results> iterator() {\n-        return this;\n-    }\n-\n-\n-    private void loadNextPage() {\n-        // Because of possible stale entities, which are filtered out by buildResults(),\n-        // we loop until the we've got enough results to satisfy the query limit.\n-\n-        final int maxQueries = 10; // max re-queries to satisfy query limit\n-\n-\n-        Results results = null;\n-        int queryCount = 0;\n-\n-\n-        CandidateResults crs = null;\n-\n-        int newLimit = limit;\n-\n-        while ( queryCount++ < maxQueries ) {\n-\n-            crs = entityIndex.search( indexScope, types, query, newLimit , offset);\n-\n-\n-            logger.debug( \"Calling build results with crs {}\", crs );\n-            results = buildResults( indexScope, crs );\n-\n-            /**\n-             * In an edge case where we delete stale entities, we could potentially get less results than expected.\n-             * This will only occur once during the repair phase.\n-             * We need to ensure that we short circuit before we overflow the requested limit during a repair.\n-             */\n-            if ( crs.isEmpty() || !crs.hasOffset() || results.size() > 0 ) { // no results, no cursor, can't get more\n-                break;\n-            }\n-\n-\n-            //we didn't load anything, but there was a cursor, this means a read repair occured.  We have to short\n-            //circuit to avoid over returning the result set\n-\n-\n-            // need to query for more\n-            // ask for just what we need to satisfy, don't want to exceed limit\n-            newLimit =  newLimit - results.size();\n-\n-            logger.warn( \"Satisfy query limit {}, new limit {} query count {}\", new Object[] {\n-                limit, newLimit, queryCount\n-            } );\n-        }\n-\n-        //now set our cursor if we have one for the next iteration\n-        if ( results.hasCursor() ) {\n-            moreToLoad = true;\n-        }\n-\n-        else {\n-            moreToLoad = false;\n-        }\n-\n-//\n-//        //set our select subjects into our query if provided\n-//        if(crs != null){\n-//            query.setSelectSubjects( crs.getGetFieldMappings() );\n-//        }\n-//\n-\n-        //set our current results and the flag\n-        this.currentResults = results;\n-    }\n-\n-\n-\n-    /**\n-     * Build results from a set of candidates, and discard those that represent stale indexes.\n-     *\n-     * @param indexScope The index scope to execute the search on\n-     * @param crs Candidates to be considered for results\n-     */\n-    private Results buildResults( final SearchEdge indexScope, final CandidateResults crs ) {\n-\n-        logger.debug( \"buildResults()  from {} candidates\", crs.size() );\n-\n-        //get an instance of our results loader\n-        final ResultsLoader resultsLoader =\n-            this.resultsLoaderFactory.getLoader( applicationScope, indexScope, Query.Level.ALL_PROPERTIES );\n-\n-        //load the results\n-        final Results results = resultsLoader.loadResults(crs);\n-\n-        //signal for post processing\n-        resultsLoader.postProcess();\n-\n-        //set offset into query\n-\n-        logger.debug( \"Returning results size {}\", results.size() );\n-\n-        return results;\n-    }\n-\n-\n-    @Override\n-    public boolean hasNext() {\n-\n-        //we've tried to load and it's empty and we have more to load, load the next page\n-        if ( currentResults == null ) {\n-            //there's nothing left to load, nothing to do\n-            if ( !moreToLoad ) {\n-                return false;\n-            }\n-\n-            //load the page\n-\n-            loadNextPage();\n-        }\n-\n-\n-        //see if our current results are not null\n-        return currentResults != null;\n-    }\n-\n-\n-    @Override\n-    public Results next() {\n-        if ( !hasNext() ) {\n-            throw new NoSuchElementException( \"No more results present\" );\n-        }\n-\n-        final Results toReturn = currentResults;\n-\n-        currentResults = null;\n-\n-        return toReturn;\n-    }\n-\n-    @Override\n-    public void remove() {\n-        throw new RuntimeException(\"Remove not implemented!!\");\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ElasticSearchQueryExecutor.java",
                "sha": "6e170f88c07b3c8d8a55883edc138319d57820ec",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/EntityVerifier.java",
                "changes": 127,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/EntityVerifier.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 127,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/EntityVerifier.java",
                "patch": "@@ -1,127 +0,0 @@\n-/*\n- *\n- *  * Licensed to the Apache Software Foundation (ASF) under one or more\n- *  *  contributor license agreements.  The ASF licenses this file to You\n- *  * under the Apache License, Version 2.0 (the \"License\"); you may not\n- *  * use this file except in compliance with the License.\n- *  * You may obtain a copy of the License at\n- *  *\n- *  *     http://www.apache.org/licenses/LICENSE-2.0\n- *  *\n- *  * Unless required by applicable law or agreed to in writing, software\n- *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  * See the License for the specific language governing permissions and\n- *  * limitations under the License.  For additional information regarding\n- *  * copyright in this work, please see the NOTICE file in the top level\n- *  * directory of this distribution.\n- *\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.UUID;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.usergrid.corepersistence.util.CpEntityMapUtils;\n-import org.apache.usergrid.persistence.Entity;\n-import org.apache.usergrid.persistence.EntityFactory;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.EntitySet;\n-import org.apache.usergrid.persistence.collection.MvccEntity;\n-import org.apache.usergrid.persistence.index.CandidateResult;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-import com.fasterxml.uuid.UUIDComparator;\n-import com.google.common.base.Optional;\n-\n-\n-/**\n- * A loader that verifies versions are correct in cassandra and match elasticsearch\n- */\n-public class EntityVerifier implements ResultsVerifier {\n-\n-    private static final Logger logger = LoggerFactory.getLogger( EntityVerifier.class );\n-\n-    private EntitySet ids;\n-\n-    private Map<Id, org.apache.usergrid.persistence.model.entity.Entity> entityMapping;\n-\n-\n-    public EntityVerifier( final int maxSize ) {\n-        this.entityMapping = new HashMap<>( maxSize );\n-    }\n-\n-\n-    @Override\n-    public void loadResults( final Collection<Id> idsToLoad, final EntityCollectionManager ecm ) {\n-        ids = ecm.load( idsToLoad ).toBlocking().last();\n-        logger.debug(\"loadResults() asked for {} ids and got {}\", idsToLoad.size(), ids.size());\n-    }\n-\n-\n-    @Override\n-    public boolean isValid( final CandidateResult candidateResult ) {\n-        final Id entityId = candidateResult.getId();\n-\n-        final MvccEntity savedEntity = ids.getEntity( entityId );\n-\n-        //version wasn't found deindex\n-        if ( savedEntity == null ) {\n-            logger.warn( \"Version for Entity {}:{} not found\", entityId.getType(), entityId.getUuid() );\n-            return false;\n-        }\n-\n-        final UUID candidateVersion = candidateResult.getVersion();\n-        final UUID savedVersion = savedEntity.getVersion();\n-\n-        if ( UUIDComparator.staticCompare( savedVersion, candidateVersion ) > 0 ) {\n-            logger.warn( \"Stale version of Entity uuid:{} type:{}, stale v:{}, latest v:{}\", new Object[] {\n-                    entityId.getUuid(), entityId.getType(), candidateVersion, savedEntity\n-            } );\n-\n-            return false;\n-        }\n-\n-\n-        final Optional<org.apache.usergrid.persistence.model.entity.Entity> entity = savedEntity.getEntity();\n-\n-        if ( !entity.isPresent() ) {\n-            logger.warn( \"Entity uuid:{} version v:{} is deleted but indexed, this is a bug \",\n-                    entityId.getUuid(), savedEntity.getEntity() );\n-            return false;\n-        }\n-\n-        entityMapping.put( entityId, entity.get() );\n-\n-        return true;\n-    }\n-\n-\n-    @Override\n-    public Results getResults( final Collection<Id> ids ) {\n-\n-        final List<Entity> ugEntities = new ArrayList<>( ids.size() );\n-\n-        for ( final Id id : ids ) {\n-            final org.apache.usergrid.persistence.model.entity.Entity cpEntity = entityMapping.get( id );\n-\n-            Entity entity = EntityFactory.newEntity( id.getUuid(), id.getType() );\n-\n-            Map<String, Object> entityMap = CpEntityMapUtils.toMap( cpEntity );\n-            entity.addProperties( entityMap );\n-            ugEntities.add( entity );\n-        }\n-\n-        return Results.fromEntities( ugEntities );\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/EntityVerifier.java",
                "sha": "d73c73169e4d2abbd998eb213b5af0b00b82f30f",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/FilteringLoader.java",
                "changes": 219,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/FilteringLoader.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 219,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/FilteringLoader.java",
                "patch": "@@ -1,219 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.TreeMap;\n-import java.util.UUID;\n-\n-import javax.annotation.Nullable;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.usergrid.corepersistence.ManagerCache;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n-import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n-import org.apache.usergrid.persistence.index.ApplicationEntityIndex;\n-import org.apache.usergrid.persistence.index.EntityIndexBatch;\n-import org.apache.usergrid.persistence.index.EntityIndexFactory;\n-import org.apache.usergrid.persistence.index.SearchEdge;\n-import org.apache.usergrid.persistence.index.CandidateResult;\n-import org.apache.usergrid.persistence.index.CandidateResults;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-import com.fasterxml.uuid.UUIDComparator;\n-import com.google.common.base.Function;\n-import com.google.common.collect.Collections2;\n-\n-\n-public class FilteringLoader implements ResultsLoader {\n-\n-    private static final Logger logger = LoggerFactory.getLogger( FilteringLoader.class );\n-\n-    private final EntityCollectionManager entityCollectionManager;\n-    private final ResultsVerifier resultsVerifier;\n-    private final ApplicationScope applicationScope;\n-    private final SearchEdge indexScope;\n-    private final EntityIndexBatch indexBatch;\n-\n-\n-    /**\n-     * Create an instance of a filter loader\n-     *\n-     * @param entityCollectionManager The entityCollectionManagerFactory\n-     * @param resultsVerifier The verifier to verify the candidate results\n-     * @param applicationScope The application scope to perform the load\n-     * @param indexScope The index scope used in the search\n-     */\n-    protected FilteringLoader( final  EntityCollectionManager entityCollectionManager, final ApplicationEntityIndex applicationEntityIndex,  final ResultsVerifier resultsVerifier,\n-                               final ApplicationScope applicationScope, final SearchEdge indexScope ) {\n-\n-        this.entityCollectionManager = entityCollectionManager;\n-        this.resultsVerifier = resultsVerifier;\n-        this.applicationScope = applicationScope;\n-        this.indexScope = indexScope;\n-\n-        indexBatch = applicationEntityIndex.createBatch();\n-    }\n-\n-\n-    @Override\n-    public Results loadResults( final CandidateResults crs ) {\n-\n-\n-        if ( crs.size() == 0 ) {\n-            return new Results();\n-        }\n-\n-\n-        // For each entity, holds the index it appears in our candidates for keeping ordering correct\n-        final Map<Id, Integer> orderIndex = new HashMap<>( crs.size() );\n-\n-        // Maps the entity ids to our candidates\n-        final Map<Id, CandidateResult> maxCandidateMapping = new HashMap<>( crs.size() );\n-\n-\n-        final Iterator<CandidateResult> iter = crs.iterator();\n-\n-\n-        // TODO, in this case we're \"optimizing\" due to the limitations of collection scope.\n-        // Perhaps  we should change the API to just be an application, then an \"owner\" scope?\n-\n-        // Go through the candidates and group them by scope for more efficient retrieval.\n-        // Also remove duplicates before we even make a network call\n-        for ( int i = 0; iter.hasNext(); i++ ) {\n-\n-            final CandidateResult currentCandidate = iter.next();\n-\n-            final Id entityId = currentCandidate.getId();\n-\n-            //check if we've seen this candidate by id\n-            final CandidateResult previousMax = maxCandidateMapping.get( entityId );\n-\n-            //its not been seen, save it\n-            if ( previousMax == null ) {\n-                maxCandidateMapping.put( entityId, currentCandidate );\n-                orderIndex.put( entityId, i );\n-                continue;\n-            }\n-\n-            //we have seen it, compare them\n-\n-            final UUID previousMaxVersion = previousMax.getVersion();\n-\n-            final UUID currentVersion = currentCandidate.getVersion();\n-\n-\n-            final CandidateResult toRemove;\n-            final CandidateResult toKeep;\n-\n-            //current is newer than previous.  Remove previous and keep current\n-            if ( UUIDComparator.staticCompare( currentVersion, previousMaxVersion ) > 0 ) {\n-                toRemove = previousMax;\n-                toKeep = currentCandidate;\n-            }\n-            //previously seen value is newer than current.  Remove the current and keep the previously seen value\n-            else {\n-                toRemove = currentCandidate;\n-                toKeep = previousMax;\n-            }\n-\n-            //this is a newer version, we know we already have a stale entity, add it to be cleaned up\n-\n-\n-            //de-index it\n-            logger.warn( \"Stale version of Entity uuid:{} type:{}, stale v:{}, latest v:{}\", new Object[] {\n-                    entityId.getUuid(), entityId.getType(), toRemove.getVersion(), toKeep.getVersion()\n-                } );\n-\n-            //deindex this document, and remove the previous maxVersion\n-            //we have to deindex this from our ownerId, since this is what gave us the reference\n-            indexBatch.deindex( indexScope, toRemove );\n-\n-\n-            //TODO, fire the entity repair cleanup task here instead of de-indexing\n-\n-            //replace the value with a more current version\n-            maxCandidateMapping.put( entityId, toKeep );\n-            orderIndex.put( entityId, i );\n-        }\n-\n-\n-        //now everything is ordered, and older versions are removed.  Batch fetch versions to verify\n-        // existence and correct versions\n-\n-        final TreeMap<Integer, Id> sortedResults = new TreeMap<>();\n-\n-\n-        final Collection<Id> idsToLoad =\n-            Collections2.transform( maxCandidateMapping.values(), new Function<CandidateResult, Id>() {\n-                @Nullable\n-                @Override\n-                public Id apply( @Nullable final CandidateResult input ) {\n-                    //NOTE this is never null, we won't need to check\n-                    return input.getId();\n-                }\n-            } );\n-\n-\n-        //now using the scope, load the collection\n-\n-\n-\n-        //load the results into the loader for this scope for validation\n-        resultsVerifier.loadResults( idsToLoad, entityCollectionManager );\n-\n-        //now let the loader validate each candidate.  For instance, the \"max\" in this candidate\n-        //could still be a stale result, so it needs validated\n-        for ( final Id requestedId : idsToLoad ) {\n-\n-            final CandidateResult cr = maxCandidateMapping.get( requestedId );\n-\n-            //ask the loader if this is valid, if not discard it and de-index it\n-            if ( !resultsVerifier.isValid( cr ) ) {\n-                indexBatch.deindex( indexScope, cr );\n-                continue;\n-            }\n-\n-            //if we get here we're good, we need to add this to our results\n-            final int candidateIndex = orderIndex.get( requestedId );\n-\n-            sortedResults.put( candidateIndex, requestedId );\n-        }\n-\n-\n-        // NOTE DO NOT execute the batch here.\n-        // It changes the results and we need consistent paging until we aggregate all results\n-        return resultsVerifier.getResults( sortedResults.values() );\n-    }\n-\n-\n-    @Override\n-    public void postProcess() {\n-        this.indexBatch.execute();\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/FilteringLoader.java",
                "sha": "ade64a24327841010609dcd9070ff42dc06d323a",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/IdsVerifier.java",
                "changes": 46,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/IdsVerifier.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 46,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/IdsVerifier.java",
                "patch": "@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.UUID;\n-\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-\n-public class IdsVerifier extends VersionVerifier {\n-\n-    @Override\n-    public Results getResults( final Collection<Id> ids ) {\n-\n-        final List<UUID> returnIds = new ArrayList<>( ids.size() );\n-\n-        for ( final Id id : ids ) {\n-            returnIds.add( id.getUuid() );\n-        }\n-\n-\n-        return Results.fromIdList( returnIds );\n-    }\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/IdsVerifier.java",
                "sha": "4a3bfcd8c6dcbf9cad7af09b863c0ffa6c95804a",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsLoader.java",
                "changes": 43,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsLoader.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 43,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsLoader.java",
                "patch": "@@ -1,43 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.index.CandidateResults;\n-\n-\n-/**\n- * Interface for loading results\n- */\n-public interface ResultsLoader {\n-\n-    /**\n-     * Using the candidate results, load our results.  Should filter stale results\n-     * @param  crs The candidate result set\n-     * @return Results.  Null safe, but may be empty\n-     */\n-    public Results loadResults( final CandidateResults crs);\n-\n-    /**\n-     * Post process the load operation\n-     */\n-    public void postProcess();\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsLoader.java",
                "sha": "c2a3e9a5b4d3c2dda0dbcc965fcee36e275d81a8",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsVerifier.java",
                "changes": 52,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsVerifier.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 52,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsVerifier.java",
                "patch": "@@ -1,52 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.Collection;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.index.CandidateResult;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-\n-public interface ResultsVerifier {\n-\n-    /**\n-     * Load all the candidate ides for verification\n-     * @param ids The Id's to load\n-     * @param ecm The entity collection manager\n-     */\n-    public void loadResults(Collection<Id> ids, EntityCollectionManager ecm);\n-\n-    /**\n-     * Return true if the candidate result is a valid result that should be retained. If it should\n-     * not it should also be removed from the list of possible return values in this loader\n-     * @param candidateResult\n-     */\n-    public boolean isValid(CandidateResult candidateResult);\n-\n-\n-    /**\n-     * Load the result set with the given ids\n-     * @return\n-     */\n-    public Results getResults(Collection<Id> ids);\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/ResultsVerifier.java",
                "sha": "fe72ca2e7db74eada85e1712d04b0097699a9682",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/VersionVerifier.java",
                "changes": 85,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/VersionVerifier.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 85,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/VersionVerifier.java",
                "patch": "@@ -1,85 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.impl;\n-\n-\n-import java.util.Collection;\n-import java.util.UUID;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.MvccLogEntry;\n-import org.apache.usergrid.persistence.collection.VersionSet;\n-import org.apache.usergrid.persistence.index.CandidateResult;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-import com.fasterxml.uuid.UUIDComparator;\n-\n-\n-/**\n- * A loader that verifies versions are correct in Cassandra and match ElasticSearch\n- */\n-public abstract class VersionVerifier implements ResultsVerifier {\n-\n-    private static final Logger logger = LoggerFactory.getLogger( VersionVerifier.class );\n-\n-    private VersionSet ids;\n-\n-\n-    @Override\n-    public void loadResults( final Collection<Id> idsToLoad, final EntityCollectionManager ecm ) {\n-        ids = ecm.getLatestVersion( idsToLoad ).toBlocking().last();\n-    }\n-\n-\n-    @Override\n-    public boolean isValid( final CandidateResult candidateResult ) {\n-        final Id entityId = candidateResult.getId();\n-\n-        final MvccLogEntry version = ids.getMaxVersion( entityId );\n-\n-        //version wasn't found ,deindex\n-        if ( version == null ) {\n-            logger.warn( \"Version for Entity {}:{} not found\",\n-                    entityId.getUuid(), entityId.getUuid() );\n-\n-            return false;\n-        }\n-\n-        final UUID savedVersion = version.getVersion();\n-\n-        if ( UUIDComparator.staticCompare( savedVersion, candidateResult.getVersion() ) > 0 ) {\n-            logger.debug( \"Stale version of Entity uuid:{} type:{}, stale v:{}, latest v:{}\",\n-                new Object[] {\n-                    entityId.getUuid(),\n-                    entityId.getType(),\n-                    candidateResult.getVersion(),\n-                    savedVersion\n-            } );\n-\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/elasticsearch/impl/VersionVerifier.java",
                "sha": "c49fb28cb0b720fa71a45cd50bbb77c4b363e9ec",
                "status": "removed"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/usergrid/blob/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/entity/EntityLoadCollector.java",
                "changes": 94,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/entity/EntityLoadCollector.java?ref=c6bbfba989b806b106fe6b2e4f1744123c30c760",
                "deletions": 94,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/entity/EntityLoadCollector.java",
                "patch": "@@ -1,94 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.usergrid.corepersistence.pipeline.read.entity;\n-\n-\n-import java.util.List;\n-\n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractPipelineOperation;\n-import org.apache.usergrid.corepersistence.pipeline.read.Collector;\n-import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n-import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n-import org.apache.usergrid.persistence.collection.EntitySet;\n-import org.apache.usergrid.persistence.collection.MvccEntity;\n-import org.apache.usergrid.persistence.model.entity.Entity;\n-import org.apache.usergrid.persistence.model.entity.Id;\n-\n-import com.google.inject.Inject;\n-\n-import rx.Observable;\n-\n-\n-/**\n- * Loads entities from a set of Ids.\n- *\n- * TODO refactor this into a common command that both ES search and graphSearch can use for repair and verification\n- */\n-public class EntityLoadCollector extends AbstractPipelineOperation<Id, ResultsPage>\n-    implements Collector<Id, ResultsPage> {\n-\n-    private final EntityCollectionManagerFactory entityCollectionManagerFactory;\n-\n-\n-    @Inject\n-    public EntityLoadCollector( final EntityCollectionManagerFactory entityCollectionManagerFactory ) {\n-        this.entityCollectionManagerFactory = entityCollectionManagerFactory;\n-    }\n-\n-\n-    @Override\n-    public Observable<ResultsPage> call( final Observable<Id> observable ) {\n-\n-\n-        final EntityCollectionManager entityCollectionManager =\n-            entityCollectionManagerFactory.createCollectionManager( pipelineContext.getApplicationScope() );\n-\n-        final Observable<EntitySet> entitySetObservable = observable.buffer( pipelineContext.getLimit() ).flatMap(\n-            bufferedIds -> Observable.just( bufferedIds ).flatMap( ids -> entityCollectionManager.load( ids ) ) );\n-\n-\n-        final Observable<ResultsPage> resultsObservable = entitySetObservable\n-\n-            .flatMap( entitySet -> {\n-\n-                //get our entites and filter missing ones, then collect them into a results object\n-                final Observable<MvccEntity> mvccEntityObservable = Observable.from( entitySet.getEntities() );\n-\n-\n-                //convert them to our old entity model, then filter abscent, meaning they weren't found\n-                final Observable<List<Entity>> entitiesPageObservable =\n-                    mvccEntityObservable.filter( mvccEntity -> mvccEntity.getEntity().isPresent() )\n-                                        .map( mvccEntity -> mvccEntity.getEntity().get() ).toList();\n-\n-                //convert them to a list, then map them into results\n-                return entitiesPageObservable.map( entities -> new ResultsPage( entities ) );\n-            } );\n-\n-\n-        return resultsObservable;\n-    }\n-\n-    /**\n-     * Map a new cp entity to an old entity.  May be null if not present\n-     */\n-\n-\n-}",
                "raw_url": "https://github.com/apache/usergrid/raw/c6bbfba989b806b106fe6b2e4f1744123c30c760/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/entity/EntityLoadCollector.java",
                "sha": "dd6b9b87046bb0a303b67f0c5f4afdbba3588ddf",
                "status": "removed"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphEdgeByIdFilter.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphEdgeByIdFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 5,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphEdgeByIdFilter.java",
                "patch": "@@ -20,8 +20,9 @@\n package org.apache.usergrid.corepersistence.pipeline.read.graph;\n \n \n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractPipelineOperation;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.graph.GraphManager;\n import org.apache.usergrid.persistence.graph.GraphManagerFactory;\n import org.apache.usergrid.persistence.graph.SearchByEdge;\n@@ -39,7 +40,7 @@\n /**\n  * Filter should take and Id and a graph edge, and ensure the connection between the two exists\n  */\n-public abstract class AbstractReadGraphEdgeByIdFilter extends AbstractPipelineOperation<Id, Id> implements\n+public abstract class AbstractReadGraphEdgeByIdFilter extends AbstractFilter<Id, Id> implements\n     Filter<Id, Id> {\n \n     private final GraphManagerFactory graphManagerFactory;\n@@ -55,20 +56,21 @@ public AbstractReadGraphEdgeByIdFilter( final GraphManagerFactory graphManagerFa\n \n \n     @Override\n-    public Observable<Id> call( final Observable<Id> idObservable ) {\n+    public Observable<FilterResult<Id>> call( final Observable<FilterResult<Id>> filterValueObservable ) {\n \n         final GraphManager gm = graphManagerFactory.createEdgeManager( pipelineContext.getApplicationScope() );\n \n-        return idObservable.flatMap( id -> {\n+        return filterValueObservable.flatMap( filterValue -> {\n             final String edgeTypeName = getEdgeName();\n+            final Id id = filterValue.getValue();\n \n             //create our search\n             final SearchByEdge searchByEdge =\n                 new SimpleSearchByEdge( id, edgeTypeName, targetId, Long.MAX_VALUE, SearchByEdgeType.Order.DESCENDING,\n                     Optional.absent() );\n \n             //load the versions of the edge, take the first since that's all we need to validate existence, then emit the target node\n-            return gm.loadEdgeVersions( searchByEdge ).take( 1 ).map( edge -> edge.getTargetNode() );\n+            return gm.loadEdgeVersions( searchByEdge ).take( 1 ).map( edge -> edge.getTargetNode() ).map( targetId -> new FilterResult<>(targetId, filterValue.getPath()));\n         } );\n     }\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphEdgeByIdFilter.java",
                "sha": "42b352b9185664b4e6bae4140be56c7d33106ea1",
                "status": "modified"
            },
            {
                "additions": 57,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphFilter.java",
                "changes": 65,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 8,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphFilter.java",
                "patch": "@@ -21,8 +21,10 @@\n \n \n import org.apache.usergrid.corepersistence.pipeline.cursor.CursorSerializer;\n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractSeekingFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractPathFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.GraphManager;\n import org.apache.usergrid.persistence.graph.GraphManagerFactory;\n@@ -38,7 +40,7 @@\n /**\n  * Command for reading graph edges\n  */\n-public abstract class AbstractReadGraphFilter extends AbstractSeekingFilter<Id, Id, Edge> implements Filter<Id, Id> {\n+public abstract class AbstractReadGraphFilter extends AbstractPathFilter<Id, Id, Edge> implements Filter<Id, Id> {\n \n     private final GraphManagerFactory graphManagerFactory;\n \n@@ -52,21 +54,24 @@ public AbstractReadGraphFilter( final GraphManagerFactory graphManagerFactory )\n \n \n     @Override\n-    public Observable<Id> call( final Observable<Id> observable ) {\n+    public Observable<FilterResult<Id>> call( final Observable<FilterResult<Id>> previousIds ) {\n+\n \n         //get the graph manager\n         final GraphManager graphManager =\n             graphManagerFactory.createEdgeManager( pipelineContext.getApplicationScope() );\n \n \n         final String edgeName = getEdgeTypeName();\n+        final EdgeState edgeCursorState = new EdgeState();\n \n \n         //return all ids that are emitted from this edge\n-        return observable.flatMap( id -> {\n+        return previousIds.flatMap( previousFilterValue -> {\n \n             //set our our constant state\n             final Optional<Edge> startFromCursor = getSeekValue();\n+            final Id id = previousFilterValue.getValue();\n \n \n             final SimpleSearchByEdgeType search =\n@@ -77,14 +82,29 @@ public AbstractReadGraphFilter( final GraphManagerFactory graphManagerFactory )\n              * TODO, pass a message with pointers to our cursor values to be generated later\n              */\n             return graphManager.loadEdgesFromSource( search )\n-                //set our cursor every edge we traverse\n-                .doOnNext( edge -> setCursor( edge ) )\n-                    //map our id from the target edge\n-                .map( edge -> edge.getTargetNode() );\n+                //set the edge state for cursors\n+                .doOnNext( edge -> edgeCursorState.update( edge ) )\n+\n+                    //map our id from the target edge  and set our cursor every edge we traverse\n+                .map( edge -> createFilterResult( edge.getTargetNode(), edgeCursorState.getCursorEdge(),\n+                    previousFilterValue.getPath() ) );\n         } );\n     }\n \n \n+    @Override\n+    protected FilterResult<Id> createFilterResult( final Id emit, final Edge cursorValue,\n+                                                   final Optional<EdgePath> parent ) {\n+\n+        //if it's our first pass, there's no cursor to generate\n+        if(cursorValue == null){\n+            return new FilterResult<>( emit, parent );\n+        }\n+\n+        return super.createFilterResult( emit, cursorValue, parent );\n+    }\n+\n+\n     @Override\n     protected CursorSerializer<Edge> getCursorSerializer() {\n         return EdgeCursorSerializer.INSTANCE;\n@@ -95,4 +115,33 @@ public AbstractReadGraphFilter( final GraphManagerFactory graphManagerFactory )\n      * Get the edge type name we should use when traversing\n      */\n     protected abstract String getEdgeTypeName();\n+\n+\n+    /**\n+     * Wrapper class. Because edges seek > the last returned, we need to keep our n-1 value. This will be our cursor We\n+     * always try to seek to the same position as we ended.  Since we don't deal with a persistent read result, if we\n+     * seek to a value = to our last, we may skip data.\n+     */\n+    private final class EdgeState {\n+\n+        private Edge cursorEdge = null;\n+        private Edge currentEdge = null;\n+\n+\n+        /**\n+         * Update the pointers\n+         */\n+        private void update( final Edge newEdge ) {\n+            cursorEdge = currentEdge;\n+            currentEdge = newEdge;\n+        }\n+\n+\n+        /**\n+         * Get the edge to use in cursors for resume\n+         */\n+        private Edge getCursorEdge() {\n+            return cursorEdge;\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/AbstractReadGraphFilter.java",
                "sha": "303bc5bad2474dd046deeabe141d72f6844f5723",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityIdFilter.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityIdFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 7,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityIdFilter.java",
                "patch": "@@ -17,11 +17,12 @@\n  * under the License.\n  */\n \n-package org.apache.usergrid.corepersistence.pipeline.read.entity;\n+package org.apache.usergrid.corepersistence.pipeline.read.graph;\n \n \n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractPipelineOperation;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n import com.google.inject.Inject;\n@@ -34,7 +35,7 @@\n  * This command is a stopgap to make migrating 1.0 code easier.  Once full traversal has been implemented, this should\n  * be removed\n  */\n-public class EntityIdFilter extends AbstractPipelineOperation<Id, Id> implements Filter<Id, Id> {\n+public class EntityIdFilter extends AbstractFilter<Id, Id> implements Filter<Id, Id> {\n \n     private final Id entityId;\n \n@@ -44,10 +45,10 @@\n \n \n \n-\n     @Override\n-    public Observable<Id> call( final Observable<Id> idObservable ) {\n-        return Observable.just( entityId );\n-    }\n+    public Observable<FilterResult<Id>> call( final Observable<FilterResult<Id>> filterValueObservable ) {\n+        //ignore what our input was, and simply emit the id specified\n+       return filterValueObservable.map( idFilterResult ->  new FilterResult( entityId, idFilterResult.getPath() ));\n \n+    }\n }",
                "previous_filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/entity/EntityIdFilter.java",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityIdFilter.java",
                "sha": "5a0e0264f5641e8fa2cd5111fa086136d92fbc4c",
                "status": "renamed"
            },
            {
                "additions": 155,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityLoadFilter.java",
                "changes": 155,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityLoadFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityLoadFilter.java",
                "patch": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read.graph;\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n+import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n+import org.apache.usergrid.persistence.collection.EntityCollectionManager;\n+import org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\n+import org.apache.usergrid.persistence.collection.EntitySet;\n+import org.apache.usergrid.persistence.collection.MvccEntity;\n+import org.apache.usergrid.persistence.model.entity.Entity;\n+import org.apache.usergrid.persistence.model.entity.Id;\n+\n+import com.google.common.base.Optional;\n+import com.google.inject.Inject;\n+\n+import rx.Observable;\n+\n+\n+/**\n+ * Loads entities from a set of Ids.\n+ *\n+ * TODO refactor this into a common command that both ES search and graphSearch can use for repair and verification\n+ */\n+public class EntityLoadFilter extends AbstractFilter<Id, Entity> implements Filter<Id, Entity> {\n+\n+    private final EntityCollectionManagerFactory entityCollectionManagerFactory;\n+\n+\n+    @Inject\n+    public EntityLoadFilter( final EntityCollectionManagerFactory entityCollectionManagerFactory ) {\n+        this.entityCollectionManagerFactory = entityCollectionManagerFactory;\n+    }\n+\n+\n+    @Override\n+    public Observable<FilterResult<Entity>> call( final Observable<FilterResult<Id>> filterResultObservable ) {\n+\n+\n+        final EntityCollectionManager entityCollectionManager =\n+            entityCollectionManagerFactory.createCollectionManager( pipelineContext.getApplicationScope() );\n+\n+        //it's more efficient to make 1 network hop to get everything, then drop our results if required\n+        final Observable<FilterResult<Entity>> entityObservable =\n+            filterResultObservable.buffer( pipelineContext.getLimit() ).flatMap( bufferedIds -> {\n+\n+                    final Observable<EntitySet> entitySetObservable =\n+                        Observable.from( bufferedIds ).map( filterResultId -> filterResultId.getValue() ).toList()\n+                                  .flatMap( ids -> entityCollectionManager.load( ids ) );\n+\n+\n+                    //now we have a collection, validate our canidate set is correct.\n+\n+                    return entitySetObservable.map( entitySet -> new EntityVerifier( entitySet, bufferedIds ) )\n+                                              .doOnNext( entityCollector -> entityCollector.merge() ).flatMap(\n+                            entityCollector -> Observable.from( entityCollector.getResults() ) );\n+                } );\n+\n+        return entityObservable;\n+    }\n+\n+\n+    /**\n+     * Our collector to collect entities.  Not quite a true collector, but works within our operational flow as this\n+     * state is mutable and difficult to represent functionally\n+     */\n+    private static final class EntityVerifier {\n+\n+        private static final Logger logger = LoggerFactory.getLogger( EntityVerifier.class );\n+        private List<FilterResult<Entity>> results = new ArrayList<>();\n+\n+        private final List<FilterResult<Id>> candidateResults;\n+        private final EntitySet entitySet;\n+\n+\n+        public EntityVerifier( final EntitySet entitySet, final List<FilterResult<Id>> candidateResults ) {\n+            this.entitySet = entitySet;\n+            this.candidateResults = candidateResults;\n+            this.results = new ArrayList<>( entitySet.size() );\n+        }\n+\n+\n+        /**\n+         * Merge our candidates and our entity set into results\n+         */\n+        public void merge() {\n+\n+            for ( final FilterResult<Id> candidateResult : candidateResults ) {\n+                validate( candidateResult );\n+            }\n+        }\n+\n+\n+        public List<FilterResult<Entity>> getResults() {\n+            return results;\n+        }\n+\n+\n+        private void validate( final FilterResult<Id> filterResult ) {\n+\n+            final Id candidateId = filterResult.getValue();\n+\n+\n+            final MvccEntity entity = entitySet.getEntity( candidateId );\n+\n+\n+            //doesn't exist warn and drop\n+            if ( entity == null || !entity.getEntity().isPresent() ) {\n+                logger.warn( \"Read graph edge and received candidate with entityId {}, yet was not found in cassandra.\"\n+                        + \"  Ignoring since this could be a region sync issue\", candidateId );\n+\n+\n+                //TODO trigger an audit after a fail count where we explicitly try to repair from other regions\n+\n+                return;\n+            }\n+\n+            //it exists, add it\n+\n+            final Entity returnEntity = entity.getEntity().get();\n+\n+            final Optional<EdgePath> parent = filterResult.getPath();\n+\n+            final FilterResult<Entity> toReturn = new FilterResult<>( returnEntity, parent );\n+\n+            results.add( toReturn );\n+        }\n+    }\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/EntityLoadFilter.java",
                "sha": "d598a2e25b48464c3b3f4a69a1ef72e9aeb61552",
                "status": "added"
            },
            {
                "additions": 11,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/ReadGraphConnectionByTypeFilter.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/ReadGraphConnectionByTypeFilter.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 9,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/ReadGraphConnectionByTypeFilter.java",
                "patch": "@@ -21,8 +21,9 @@\n \n \n import org.apache.usergrid.corepersistence.pipeline.cursor.CursorSerializer;\n-import org.apache.usergrid.corepersistence.pipeline.read.AbstractSeekingFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractPathFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.Filter;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.GraphManager;\n import org.apache.usergrid.persistence.graph.GraphManagerFactory;\n@@ -42,7 +43,7 @@\n /**\n  * Command for reading graph edges on a connection\n  */\n-public class ReadGraphConnectionByTypeFilter extends AbstractSeekingFilter<Id, Id, Edge> implements Filter<Id, Id> {\n+public class ReadGraphConnectionByTypeFilter extends AbstractPathFilter<Id, Id, Edge> implements Filter<Id, Id> {\n \n     private final GraphManagerFactory graphManagerFactory;\n     private final String connectionName;\n@@ -61,8 +62,9 @@ public ReadGraphConnectionByTypeFilter( final GraphManagerFactory graphManagerFa\n     }\n \n \n+\n     @Override\n-    public Observable<Id> call( final Observable<Id> observable ) {\n+    public Observable<FilterResult<Id>> call( final Observable<FilterResult<Id>> filterResultObservable ) {\n \n         //get the graph manager\n         final GraphManager graphManager = graphManagerFactory.createEdgeManager( pipelineContext.getApplicationScope() );\n@@ -73,20 +75,18 @@ public ReadGraphConnectionByTypeFilter( final GraphManagerFactory graphManagerFa\n \n \n         //return all ids that are emitted from this edge\n-        return observable.flatMap( id -> {\n+        return filterResultObservable.flatMap( idFilterResult -> {\n \n               //set our our constant state\n             final Optional<Edge> startFromCursor = getSeekValue();\n+            final Id id = idFilterResult.getValue();\n \n             final SimpleSearchByIdType search =\n                 new SimpleSearchByIdType( id, edgeName, Long.MAX_VALUE, SearchByEdgeType.Order.DESCENDING,\n                     entityType, startFromCursor );\n \n-            /**\n-             * TODO, pass a message with pointers to our cursor values to be generated later\n-             */\n-            return graphManager.loadEdgesFromSourceByType( search ).doOnNext( edge -> setCursor( edge ) ).map(\n-                edge -> edge.getTargetNode() );\n+            return graphManager.loadEdgesFromSourceByType( search ).map(\n+                edge -> createFilterResult( edge.getTargetNode(), edge, idFilterResult.getPath() ));\n         } );\n     }\n \n@@ -95,4 +95,6 @@ public ReadGraphConnectionByTypeFilter( final GraphManagerFactory graphManagerFa\n     protected CursorSerializer<Edge> getCursorSerializer() {\n         return EdgeCursorSerializer.INSTANCE;\n     }\n+\n+\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/graph/ReadGraphConnectionByTypeFilter.java",
                "sha": "737157932236062e5284b492412b910f5e45755d",
                "status": "modified"
            },
            {
                "additions": 15,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/results/ObservableQueryExecutor.java",
                "changes": 24,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/results/ObservableQueryExecutor.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 9,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/results/ObservableQueryExecutor.java",
                "patch": "@@ -26,12 +26,10 @@\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-import org.apache.usergrid.corepersistence.pipeline.PipelineResult;\n import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n import org.apache.usergrid.corepersistence.util.CpEntityMapUtils;\n import org.apache.usergrid.persistence.EntityFactory;\n import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.collection.MvccEntity;\n import org.apache.usergrid.persistence.model.entity.Entity;\n import org.apache.usergrid.persistence.model.entity.Id;\n \n@@ -51,13 +49,17 @@\n     public Iterator<Results> iterator;\n \n \n-    public ObservableQueryExecutor( final Observable<PipelineResult<ResultsPage>> resultsObservable ) {\n+    public ObservableQueryExecutor( final Observable<ResultsPage> resultsObservable) {\n        //map to our old results objects, return a default empty if required\n         this.resultsObservable = resultsObservable.map( resultsPage -> createResults( resultsPage ) ).defaultIfEmpty( new Results() );\n     }\n \n \n-\n+    /**\n+     *\n+     * @param cpEntity\n+     * @return\n+     */\n     private org.apache.usergrid.persistence.Entity mapEntity( final Entity cpEntity ) {\n \n \n@@ -72,9 +74,8 @@ public ObservableQueryExecutor( final Observable<PipelineResult<ResultsPage>> re\n         return entity;\n     }\n \n-    private Results createResults( final PipelineResult<ResultsPage> pipelineResults ){\n+    private Results createResults( final ResultsPage resultsPage ){\n \n-        final ResultsPage resultsPage = pipelineResults.getResult();\n         final List<Entity> entityList = resultsPage.getEntityList();\n         final List<org.apache.usergrid.persistence.Entity> resultsEntities = new ArrayList<>( entityList.size() );\n \n@@ -85,10 +86,15 @@ private Results createResults( final PipelineResult<ResultsPage> pipelineResults\n \n         final Results results = Results.fromEntities( resultsEntities );\n \n-        if(pipelineResults.getCursor().isPresent()) {\n-            results.setCursor( pipelineResults.getCursor().get() );\n-        }\n \n+        //add the cursor if our limit is the same\n+        if(resultsPage.hasMoreResults()) {\n+            final Optional<String> cursor = resultsPage.getResponseCursor().encodeAsString();\n+\n+            if ( cursor.isPresent() ) {\n+                results.setCursor( cursor.get() );\n+            }\n+        }\n         return results;\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/corepersistence/results/ObservableQueryExecutor.java",
                "sha": "0260d1d44f2e8449fc13b87c6f7f0b3c3084f60c",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/persistence/Results.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/persistence/Results.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/apache/usergrid/persistence/Results.java",
                "patch": "@@ -1293,7 +1293,7 @@ public void setQueryExecutor(final QueryExecutor queryExecutor){\n     /** uses cursor to get next batch of Results (returns null if no cursor) */\n     public Results getNextPageResults() throws Exception {\n         if ( queryExecutor == null || !queryExecutor.hasNext() ) {\n-            return null;\n+            return new Results();\n         }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/main/java/org/apache/usergrid/persistence/Results.java",
                "sha": "fa221f5ed13645d6813696b03e75eb394566b970",
                "status": "modified"
            },
            {
                "additions": 14,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/test/java/org/apache/usergrid/corepersistence/pipeline/cursor/CursorTest.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/apache/usergrid/corepersistence/pipeline/cursor/CursorTest.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 6,
                "filename": "stack/core/src/test/java/org/apache/usergrid/corepersistence/pipeline/cursor/CursorTest.java",
                "patch": "@@ -24,11 +24,11 @@\n \n import org.junit.Test;\n \n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n import org.apache.usergrid.corepersistence.pipeline.read.elasticsearch.ElasticsearchCursorSerializer;\n import org.apache.usergrid.corepersistence.pipeline.read.graph.EdgeCursorSerializer;\n import org.apache.usergrid.persistence.graph.Edge;\n import org.apache.usergrid.persistence.graph.impl.SimpleEdge;\n-import org.apache.usergrid.persistence.graph.impl.SimpleMarkedEdge;\n \n import com.google.common.base.Optional;\n \n@@ -41,7 +41,10 @@\n     @Test\n     public void testCursors(){\n \n-        ResponseCursor responseCursor = new ResponseCursor();\n+\n+\n+\n+\n \n \n         //test encoding edge\n@@ -58,13 +61,18 @@ public void testCursors(){\n         final Integer query2 = 20;\n \n \n-        responseCursor.setCursor( 0, edge1, EdgeCursorSerializer.INSTANCE );\n \n-        responseCursor.setCursor( 1, query1, ElasticsearchCursorSerializer.INSTANCE );\n+        final EdgePath<Integer> filter3Path = new EdgePath<>( 3, query2, ElasticsearchCursorSerializer.INSTANCE, Optional.absent() );\n+\n+        final EdgePath<Edge> filter2Path = new EdgePath<Edge>(2, edge2, EdgeCursorSerializer.INSTANCE, Optional.of( filter3Path ));\n+\n+        final EdgePath<Integer> filter1Path = new EdgePath<>( 1, query1, ElasticsearchCursorSerializer.INSTANCE, Optional.of(filter2Path) );\n+\n+        final EdgePath<Edge> filter0Path = new EdgePath<>( 0, edge1, EdgeCursorSerializer.INSTANCE, Optional.of( filter1Path ) );\n+\n \n-        responseCursor.setCursor(2, edge2, EdgeCursorSerializer.INSTANCE);\n \n-        responseCursor.setCursor(3, query2, ElasticsearchCursorSerializer.INSTANCE);\n+        ResponseCursor responseCursor = new ResponseCursor( Optional.of(filter0Path) );\n \n         final Optional<String> cursor = responseCursor.encodeAsString();\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/core/src/test/java/org/apache/usergrid/corepersistence/pipeline/cursor/CursorTest.java",
                "sha": "fd65ebfc82f7f88900761c55448f88485cc2fdc3",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/CandidateResults.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/CandidateResults.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 10,
                "filename": "stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/CandidateResults.java",
                "patch": "@@ -42,14 +42,10 @@\n \n     private final List<CandidateResult> candidates;\n     private final Collection<SelectFieldMapping> getFieldMappings;\n-    private final SearchEdge searchEdge;\n \n-\n-    public CandidateResults( List<CandidateResult> candidates, final Collection<SelectFieldMapping> getFieldMappings,\n-                             final SearchEdge searchEdge ) {\n+    public CandidateResults( List<CandidateResult> candidates, final Collection<SelectFieldMapping> getFieldMappings) {\n         this.candidates = candidates;\n         this.getFieldMappings = getFieldMappings;\n-        this.searchEdge = searchEdge;\n         offset = Optional.absent();\n     }\n \n@@ -91,11 +87,6 @@ public boolean isEmpty() {\n     }\n \n \n-    public SearchEdge getSearchEdge() {\n-        return searchEdge;\n-    }\n-\n-\n     /**\n      * Get the candidates\n      * @return",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/CandidateResults.java",
                "sha": "a157e473c6c1f684bdf7bdf98fe31cf96ce79ea3",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsApplicationEntityIndexImpl.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsApplicationEntityIndexImpl.java?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 4,
                "filename": "stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsApplicationEntityIndexImpl.java",
                "patch": "@@ -169,7 +169,7 @@ public CandidateResults search( final SearchEdge searchEdge, final SearchTypes s\n         }\n         failureMonitor.success();\n \n-        return parseResults(searchResponse, parsedQuery, searchEdge, limit, offset);\n+        return parseResults(searchResponse, parsedQuery, limit, offset);\n     }\n \n \n@@ -227,7 +227,7 @@ private void checkDeleteByQueryResponse( final QueryBuilder query, final DeleteB\n     /**\n      * Parse the results and return the canddiate results\n      */\n-    private CandidateResults parseResults( final SearchResponse searchResponse, final ParsedQuery query, final SearchEdge searchEdge,\n+    private CandidateResults parseResults( final SearchResponse searchResponse, final ParsedQuery query,\n                                            final int limit, final int from ) {\n \n         final SearchHits searchHits = searchResponse.getHits();\n@@ -244,8 +244,7 @@ private CandidateResults parseResults( final SearchResponse searchResponse, fina\n             candidates.add( candidateResult );\n         }\n \n-        final CandidateResults candidateResults = new CandidateResults( candidates, query.getSelectFieldMappings(),\n-            searchEdge );\n+        final CandidateResults candidateResults = new CandidateResults( candidates, query.getSelectFieldMappings());\n \n         // >= seems odd.  However if we get an overflow, we need to account for it.\n         if (  hits.length >= limit ) {",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/corepersistence/queryindex/src/main/java/org/apache/usergrid/persistence/index/impl/EsApplicationEntityIndexImpl.java",
                "sha": "5b670602a3440dad83af350465adce0d739469c7",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/usergrid/blob/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/corepersistence/queryindex/src/main/resources/org/apache/usergrid/persistence/index/usergrid-mappings.json",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/queryindex/src/main/resources/org/apache/usergrid/persistence/index/usergrid-mappings.json?ref=7b215250afce3303af6a26ecf4ec8918840e37e0",
                "deletions": 0,
                "filename": "stack/corepersistence/queryindex/src/main/resources/org/apache/usergrid/persistence/index/usergrid-mappings.json",
                "patch": "@@ -73,6 +73,9 @@\n                     },\n                     \"string\": {\n                         \"type\": \"string\",\n+                        \"norms\": {\n+                            \"enabled\": false\n+                        },\n                         \"fields\": {\n                             \"exact\": {\n                                 \"type\": \"string\",",
                "raw_url": "https://github.com/apache/usergrid/raw/7b215250afce3303af6a26ecf4ec8918840e37e0/stack/corepersistence/queryindex/src/main/resources/org/apache/usergrid/persistence/index/usergrid-mappings.json",
                "sha": "c22a4ecd92a0ffbe9d7828eb28f9d7b979e4983f",
                "status": "modified"
            }
        ],
        "message": "Merge branch 'two-dot-o-dev' of https://git-wip-us.apache.org/repos/asf/incubator-usergrid into USERGRID-609\n\n# By Todd Nine\n# Via Todd Nine\n* 'two-dot-o-dev' of https://git-wip-us.apache.org/repos/asf/incubator-usergrid:\n  Updates observable short circuit and fixes NPE on empty results\n  Fixes graph cursor resume state.\n  Fixes resume logic by loading then filtering first id\n  Massive refactor.  Paths for cursor generation are now part of our I/O results. This allows the collector to take until satisfied, then generate a serializable path.\n  Updated mapping to fix missing doc_values and disable norms  since we use external sorting",
        "parent": "https://github.com/apache/usergrid/commit/c6bbfba989b806b106fe6b2e4f1744123c30c760",
        "patched_files": [
            "AbstractCollector.java",
            "FilterFactory.java",
            "CandidateIdFilter.java",
            "AbstractReadGraphFilter.java",
            "ResultsLoader.java",
            "ConnectionRefsVerifier.java",
            "EntityVerifier.java",
            "AbstractPathFilter.java",
            "CandidateResults.java",
            "CpRelationManager.java",
            "CollectionResultsLoaderFactoryImpl.java",
            "EntityLoadCollector.java",
            "Filter.java",
            "FilterResult.java",
            "Candidate.java",
            "EdgePath.java",
            "IdsVerifier.java",
            "ResultsPage.java",
            "Collector.java",
            "EsApplicationEntityIndexImpl.java",
            "ElasticSearchQueryExecutor.java",
            "CollectorFactory.java",
            "ReadPipelineBuilderImpl.java",
            "Pipeline.java",
            "VersionVerifier.java",
            "CollectionRefsVerifier.java",
            "ResultsVerifier.java",
            "IdCursorSerializer.java",
            "AbstractElasticSearchFilter.java",
            "ResponseCursor.java",
            "CandidateEntityFilter.java",
            "EntityIdFilter.java",
            "ConnectionResultsLoaderFactoryImpl.java",
            "EntityFilter.java",
            "AbstractReadGraphEdgeByIdFilter.java",
            "EntityLoadFilter.java",
            "Results.java",
            "PipelineContext.java",
            "ReadPipelineBuilder.java",
            "FilteringLoader.java",
            "AbstractFilter.java",
            "PipelineOperation.java",
            "ReadGraphConnectionByTypeFilter.java",
            "ResultsPageCollector.java",
            "ObservableQueryExecutor.java",
            "usergrid-mappings.json"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "CursorTest.java"
        ]
    },
    "usergrid_7ff36dd": {
        "bug_id": "usergrid_7ff36dd",
        "commit": "https://github.com/apache/usergrid/commit/7ff36ddcb8352fa00d60e66167bbab71b75bdbec",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/7ff36ddcb8352fa00d60e66167bbab71b75bdbec/stack/services/src/main/java/org/usergrid/services/applications/ApplicationsService.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/applications/ApplicationsService.java?ref=7ff36ddcb8352fa00d60e66167bbab71b75bdbec",
                "deletions": 2,
                "filename": "stack/services/src/main/java/org/usergrid/services/applications/ApplicationsService.java",
                "patch": "@@ -313,8 +313,10 @@ public ServiceResults getApplicationCounterNames() throws Exception {\n \n \tpublic ServiceResults getApplicationCounters(Query query) throws Exception {\n \t\tResults counters = em.getAggregateCounters(query);\n-\t\tServiceResults results = simpleServiceResults(Type.COUNTERS)\n-\t\t\t\t.withCounters(counters.getCounters());\n+\t\tServiceResults results = simpleServiceResults(Type.COUNTERS);\n+\t\tif (counters != null) {\n+\t\t\tresults.withCounters(counters.getCounters());\n+\t\t}\n \t\treturn results;\n \t}\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/7ff36ddcb8352fa00d60e66167bbab71b75bdbec/stack/services/src/main/java/org/usergrid/services/applications/ApplicationsService.java",
                "sha": "b9a1bdde85056c4983318e0d1c7d6c3ed4ef3084",
                "status": "modified"
            }
        ],
        "message": "fix npe",
        "parent": "https://github.com/apache/usergrid/commit/c05f927f3b2ef033fa6a6c55c97fa988d9f65189",
        "patched_files": [
            "ApplicationsService.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "ApplicationsServiceTest.java"
        ]
    },
    "usergrid_8042fab": {
        "bug_id": "usergrid_8042fab",
        "commit": "https://github.com/apache/usergrid/commit/8042fab526c637341715de3a063321b32060da80",
        "file": [
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/8042fab526c637341715de3a063321b32060da80/stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java?ref=8042fab526c637341715de3a063321b32060da80",
                "deletions": 1,
                "filename": "stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java",
                "patch": "@@ -364,7 +364,7 @@ public ServiceResults postItemById(ServiceContext context, UUID id)\n \n \t\tEntity entity = em.get(id);\n \t\tif (entity == null) {\n-\t\t\treturn null;\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tentity = importEntity(context, entity);\n \n@@ -402,6 +402,9 @@ public ServiceResults deleteItemById(ServiceContext context, UUID id)\n \t\t}\n \n \t\tEntity item = em.get(id);\n+\t\tif (item == null) {\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n+\t\t}\n \t\titem = importEntity(context, item);\n \n \t\tem.removeFromCollection(context.getOwner(),\n@@ -425,6 +428,9 @@ public ServiceResults deleteItemByName(ServiceContext context, String name)\n \t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tEntity entity = em.get(ref);\n+\t\tif (entity == null) {\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n+\t\t}\n \t\tentity = importEntity(context, entity);\n \n \t\tcheckPermissionsForEntity(context, entity);",
                "raw_url": "https://github.com/apache/usergrid/raw/8042fab526c637341715de3a063321b32060da80/stack/services/src/main/java/org/usergrid/services/AbstractCollectionService.java",
                "sha": "64701d7234cdf32073ca251444602fac17ea5441",
                "status": "modified"
            },
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/usergrid/blob/8042fab526c637341715de3a063321b32060da80/stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java",
                "changes": 12,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java?ref=8042fab526c637341715de3a063321b32060da80",
                "deletions": 6,
                "filename": "stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java",
                "patch": "@@ -295,7 +295,7 @@ public ServiceResults postItemById(ServiceContext context, UUID id)\n \n \t\tEntity entity = em.get(id);\n \t\tif (entity == null) {\n-\t\t\treturn null;\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tentity = importEntity(context, entity);\n \n@@ -331,11 +331,11 @@ public ServiceResults postItemsByQuery(ServiceContext context, Query query)\n \n \t\t\tEntityRef ref = em.getAlias(query.getEntityType(), name);\n \t\t\tif (ref == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tEntity entity = em.get(ref);\n \t\t\tif (entity == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tentity = importEntity(context, entity);\n \n@@ -362,7 +362,7 @@ public ServiceResults deleteItemById(ServiceContext context, UUID id)\n \n \t\tEntity entity = em.get(id);\n \t\tif (entity == null) {\n-\t\t\treturn null;\n+\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t}\n \t\tentity = importEntity(context, entity);\n \n@@ -392,11 +392,11 @@ public ServiceResults deleteItemsByQuery(ServiceContext context, Query query)\n \n \t\t\tEntityRef ref = em.getAlias(query.getEntityType(), name);\n \t\t\tif (ref == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tEntity entity = em.get(ref);\n \t\t\tif (entity == null) {\n-\t\t\t\treturn null;\n+\t\t\t\tthrow new ServiceResourceNotFoundException(context);\n \t\t\t}\n \t\t\tentity = importEntity(context, entity);\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/8042fab526c637341715de3a063321b32060da80/stack/services/src/main/java/org/usergrid/services/AbstractConnectionsService.java",
                "sha": "2542fc22fe0be2c58bdfd7f369923dfba7a39b65",
                "status": "modified"
            },
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/8042fab526c637341715de3a063321b32060da80/stack/services/src/main/java/org/usergrid/services/AbstractService.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/AbstractService.java?ref=8042fab526c637341715de3a063321b32060da80",
                "deletions": 0,
                "filename": "stack/services/src/main/java/org/usergrid/services/AbstractService.java",
                "patch": "@@ -294,6 +294,10 @@ public Entity importEntity(ServiceContext context, Entity entity)\n \t@Override\n \tpublic Entity importEntity(ServiceRequest request, Entity entity)\n \t\t\tthrows Exception {\n+\t\tif (entity == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tif (!isRootService()) {\n \t\t\treturn sm.importEntity(request, entity);\n \t\t}",
                "raw_url": "https://github.com/apache/usergrid/raw/8042fab526c637341715de3a063321b32060da80/stack/services/src/main/java/org/usergrid/services/AbstractService.java",
                "sha": "1879215e73885b45f41c1105adcabd99c34ec1ac",
                "status": "modified"
            }
        ],
        "message": "fix npe when entity not found, throw service_resource_not_found instead",
        "parent": "https://github.com/apache/usergrid/commit/ce78e78f334dd0da507f06ba4f49c42081b4af69",
        "patched_files": [
            "AbstractService.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "AbstractServiceTest.java"
        ]
    },
    "usergrid_832017b": {
        "bug_id": "usergrid_832017b",
        "commit": "https://github.com/apache/usergrid/commit/832017bf7b1c2e8b809b8254f2fd70eebab58d0f",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/832017bf7b1c2e8b809b8254f2fd70eebab58d0f/stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java?ref=832017bf7b1c2e8b809b8254f2fd70eebab58d0f",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java",
                "patch": "@@ -58,7 +58,14 @@ public UnionIterator( int pageSize, int id, ByteBuffer minUuid ) {\n         super( pageSize );\n \n         this.id = id;\n-        list = new SortedColumnList( pageSize, UUID_SERIALIZER.fromByteBuffer( minUuid ) );\n+\n+        UUID parseMinUuid = null;\n+\n+        if(minUuid != null)      {\n+            parseMinUuid = UUID_SERIALIZER.fromByteBuffer( minUuid );\n+        }\n+\n+        list = new SortedColumnList( pageSize, parseMinUuid );\n     }\n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/832017bf7b1c2e8b809b8254f2fd70eebab58d0f/stack/core/src/main/java/org/usergrid/persistence/query/ir/result/UnionIterator.java",
                "sha": "00e90b881a8b11eb13b2fb2cfe062676c170f49b",
                "status": "modified"
            },
            {
                "additions": 70,
                "blob_url": "https://github.com/apache/usergrid/blob/832017bf7b1c2e8b809b8254f2fd70eebab58d0f/stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java",
                "changes": 70,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java?ref=832017bf7b1c2e8b809b8254f2fd70eebab58d0f",
                "deletions": 0,
                "filename": "stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java",
                "patch": "@@ -16,13 +16,16 @@\n package org.usergrid.persistence.query.ir.result;\n \n \n+import java.nio.ByteBuffer;\n import java.util.HashSet;\n import java.util.Set;\n import java.util.UUID;\n \n import org.junit.Test;\n import org.usergrid.utils.UUIDUtils;\n \n+import me.prettyprint.cassandra.serializers.UUIDSerializer;\n+\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNull;\n@@ -295,6 +298,73 @@ public void iterationCompleted() {\n     }\n \n \n+    @Test\n+    public void nullCursorBytes() {\n+\n+        UUID id1 = UUIDUtils.minTimeUUID( 1 );\n+        UUID id2 = UUIDUtils.minTimeUUID( 2 );\n+        UUID id3 = UUIDUtils.minTimeUUID( 3 );\n+        UUID id4 = UUIDUtils.minTimeUUID( 4 );\n+        UUID id5 = UUIDUtils.minTimeUUID( 5 );\n+\n+\n+        InOrderIterator second = new InOrderIterator( 100 );\n+        second.add( id1 );\n+        second.add( id2 );\n+        second.add( id3 );\n+        second.add( id4 );\n+        second.add( id5 );\n+\n+        UnionIterator union = new UnionIterator( 100, 1, null );\n+\n+        union.addIterator( second );\n+\n+        Set<ScanColumn> ids = union.next();\n+\n+        // now make sure it's right, only 1, 3 and 8 intersect\n+        assertTrue( ids.contains( uuidColumn( id1 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id2 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id3 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id4 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id5 ) ) );\n+    }\n+\n+\n+    @Test\n+    public void validCursorBytes() {\n+\n+\n+        ByteBuffer cursor = UUIDSerializer.get().toByteBuffer( UUIDUtils.minTimeUUID( 4 ) );\n+\n+        UUID id1 = UUIDUtils.minTimeUUID( 1 );\n+        UUID id2 = UUIDUtils.minTimeUUID( 2 );\n+        UUID id3 = UUIDUtils.minTimeUUID( 3 );\n+        UUID id4 = UUIDUtils.minTimeUUID( 4 );\n+        UUID id5 = UUIDUtils.minTimeUUID( 5 );\n+\n+\n+        InOrderIterator second = new InOrderIterator( 100 );\n+        second.add( id1 );\n+        second.add( id2 );\n+        second.add( id3 );\n+        second.add( id4 );\n+        second.add( id5 );\n+\n+        UnionIterator union = new UnionIterator( 100, 1, cursor );\n+\n+        union.addIterator( second );\n+\n+        Set<ScanColumn> ids = union.next();\n+\n+        // now make sure it's right, only 1, 3 and 8 intersect\n+        assertFalse( ids.contains( uuidColumn( id1 ) ) );\n+        assertFalse( ids.contains( uuidColumn( id2 ) ) );\n+        assertFalse( ids.contains( uuidColumn( id3 ) ) );\n+        assertFalse( ids.contains( uuidColumn( id4 ) ) );\n+        assertTrue( ids.contains( uuidColumn( id5 ) ) );\n+    }\n+\n+\n     private void reverse( UUID[] array ) {\n \n         UUID temp = null;",
                "raw_url": "https://github.com/apache/usergrid/raw/832017bf7b1c2e8b809b8254f2fd70eebab58d0f/stack/core/src/test/java/org/usergrid/persistence/query/ir/result/UnionIteratorTest.java",
                "sha": "8fd9ea80099eb580bf87af0cd8fcbfa73eb41572",
                "status": "modified"
            }
        ],
        "message": "Merge pull request #32 from usergrid/USERGRID-2862-limitfix\n\nFixes NPE issue in the union iterator",
        "parent": "https://github.com/apache/usergrid/commit/b22115aec275b24019556edda509a109650ae385",
        "patched_files": [
            "UnionIterator.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "UnionIteratorTest.java"
        ]
    },
    "usergrid_ad4a337": {
        "bug_id": "usergrid_ad4a337",
        "commit": "https://github.com/apache/usergrid/commit/ad4a33713e8280a4d3637bf1395937bd32aa5fca",
        "file": [
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/ad4a33713e8280a4d3637bf1395937bd32aa5fca/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/datastax/TableDefinition.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/datastax/TableDefinition.java?ref=ad4a33713e8280a4d3637bf1395937bd32aa5fca",
                "deletions": 0,
                "filename": "stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/datastax/TableDefinition.java",
                "patch": "@@ -22,6 +22,8 @@\n package org.apache.usergrid.persistence.core.datastax;\n \n \n+import com.google.common.base.Preconditions;\n+\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n@@ -65,6 +67,12 @@ public TableDefinition( final String tableName, final Collection<String> primary\n                             final Map<String, String> columns, final CacheOption cacheOption,\n                             final Map<String, String> clusteringOrder){\n \n+        Preconditions.checkNotNull(tableName, \"Table name cannot be null\");\n+        Preconditions.checkNotNull(primaryKeys, \"Primary Key(s) cannot be null\");\n+        Preconditions.checkNotNull(columns, \"Columns cannot be null\");\n+        Preconditions.checkNotNull(cacheOption, \"CacheOption cannot be null\");\n+\n+\n         this.tableName = tableName;\n         this.primaryKeys = primaryKeys;\n         this.columns = columns;",
                "raw_url": "https://github.com/apache/usergrid/raw/ad4a33713e8280a4d3637bf1395937bd32aa5fca/stack/corepersistence/common/src/main/java/org/apache/usergrid/persistence/core/datastax/TableDefinition.java",
                "sha": "801eaa710b0234ebe57dd742a2ceb562b9e001ee",
                "status": "modified"
            },
            {
                "additions": 81,
                "blob_url": "https://github.com/apache/usergrid/blob/ad4a33713e8280a4d3637bf1395937bd32aa5fca/stack/corepersistence/common/src/test/java/org/apache/usergrid/persistence/core/datastax/TableDefinitionTest.java",
                "changes": 81,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/corepersistence/common/src/test/java/org/apache/usergrid/persistence/core/datastax/TableDefinitionTest.java?ref=ad4a33713e8280a4d3637bf1395937bd32aa5fca",
                "deletions": 0,
                "filename": "stack/corepersistence/common/src/test/java/org/apache/usergrid/persistence/core/datastax/TableDefinitionTest.java",
                "patch": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.usergrid.persistence.core.datastax;\n+\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class TableDefinitionTest {\n+\n+    @Test\n+    public void testNullTableName(){\n+\n+        try{\n+            TableDefinition table1 = new TableDefinition(null, null, null, null, null);\n+        } catch (NullPointerException npe){\n+            assertEquals(\"Table name cannot be null\", npe.getMessage());\n+        }\n+\n+\n+    }\n+\n+    @Test\n+    public void testNullPrimaryKeys(){\n+\n+        try{\n+            TableDefinition table1 = new TableDefinition(\"table1\", null, null, null, null);\n+        } catch (NullPointerException npe){\n+            assertEquals(\"Primary Key(s) cannot be null\", npe.getMessage());\n+        }\n+\n+\n+    }\n+\n+    @Test\n+    public void testNullColumns(){\n+\n+        try{\n+            TableDefinition table1 = new TableDefinition(\"table1\",\n+                new ArrayList<>(), null, null, null);\n+        } catch (NullPointerException npe){\n+            assertEquals(\"Columns cannot be null\", npe.getMessage());\n+        }\n+\n+\n+    }\n+\n+    @Test\n+    public void testNullCacheOption(){\n+\n+        try{\n+            TableDefinition table1 = new TableDefinition(\"table1\",\n+                new ArrayList<>(),\n+                new HashMap<>(), null, null);\n+        } catch (NullPointerException npe){\n+            assertEquals(\"CacheOption cannot be null\", npe.getMessage());\n+        }\n+\n+\n+    }\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/ad4a33713e8280a4d3637bf1395937bd32aa5fca/stack/corepersistence/common/src/test/java/org/apache/usergrid/persistence/core/datastax/TableDefinitionTest.java",
                "sha": "792864bdd01462e65f8b451b284cb58cb3d43a1e",
                "status": "added"
            }
        ],
        "message": "Add null checks and tests confirming NPEs are thrown.",
        "parent": "https://github.com/apache/usergrid/commit/a62fb0a0c95ece13c84a563e58802230bdcff1cb",
        "patched_files": [
            "TableDefinition.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "TableDefinitionTest.java"
        ]
    },
    "usergrid_b1157a8": {
        "bug_id": "usergrid_b1157a8",
        "commit": "https://github.com/apache/usergrid/commit/b1157a8924686557e5c26966c5a0b14fb87eb2d6",
        "file": [
            {
                "additions": 17,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "changes": 55,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 38,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "patch": "@@ -17,69 +17,48 @@\n package org.apache.usergrid.corepersistence;\n \n \n-import java.util.*;\n-\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.usergrid.corepersistence.asyncevents.AsyncEventService;\n import org.apache.usergrid.corepersistence.index.CollectionSettings;\n import org.apache.usergrid.corepersistence.index.CollectionSettingsFactory;\n import org.apache.usergrid.corepersistence.index.CollectionSettingsScopeImpl;\n-import org.apache.usergrid.corepersistence.results.IdQueryExecutor;\n-import org.apache.usergrid.persistence.map.MapManager;\n-import org.apache.usergrid.persistence.map.MapScope;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.util.Assert;\n-\n-import org.apache.usergrid.corepersistence.asyncevents.AsyncEventService;\n import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n import org.apache.usergrid.corepersistence.results.ConnectionRefQueryExecutor;\n import org.apache.usergrid.corepersistence.results.EntityQueryExecutor;\n+import org.apache.usergrid.corepersistence.results.IdQueryExecutor;\n import org.apache.usergrid.corepersistence.service.CollectionSearch;\n import org.apache.usergrid.corepersistence.service.CollectionService;\n import org.apache.usergrid.corepersistence.service.ConnectionSearch;\n import org.apache.usergrid.corepersistence.service.ConnectionService;\n import org.apache.usergrid.corepersistence.util.CpEntityMapUtils;\n import org.apache.usergrid.corepersistence.util.CpNamingUtils;\n-import org.apache.usergrid.persistence.ConnectedEntityRef;\n-import org.apache.usergrid.persistence.ConnectionRef;\n-import org.apache.usergrid.persistence.Entity;\n-import org.apache.usergrid.persistence.EntityManager;\n-import org.apache.usergrid.persistence.EntityRef;\n-import org.apache.usergrid.persistence.Query;\n+import org.apache.usergrid.persistence.*;\n import org.apache.usergrid.persistence.Query.Level;\n-import org.apache.usergrid.persistence.RelationManager;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.RoleRef;\n-import org.apache.usergrid.persistence.Schema;\n-import org.apache.usergrid.persistence.SimpleEntityRef;\n-import org.apache.usergrid.persistence.SimpleRoleRef;\n import org.apache.usergrid.persistence.cassandra.ConnectionRefImpl;\n import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n import org.apache.usergrid.persistence.entities.Group;\n import org.apache.usergrid.persistence.entities.User;\n-import org.apache.usergrid.persistence.graph.Edge;\n-import org.apache.usergrid.persistence.graph.GraphManager;\n-import org.apache.usergrid.persistence.graph.MarkedEdge;\n-import org.apache.usergrid.persistence.graph.SearchByEdge;\n-import org.apache.usergrid.persistence.graph.SearchByEdgeType;\n+import org.apache.usergrid.persistence.graph.*;\n import org.apache.usergrid.persistence.graph.impl.SimpleSearchByEdge;\n import org.apache.usergrid.persistence.graph.impl.SimpleSearchByEdgeType;\n import org.apache.usergrid.persistence.graph.impl.SimpleSearchEdgeType;\n import org.apache.usergrid.persistence.index.query.Identifier;\n+import org.apache.usergrid.persistence.map.MapManager;\n+import org.apache.usergrid.persistence.map.MapScope;\n import org.apache.usergrid.persistence.model.entity.Id;\n import org.apache.usergrid.persistence.model.entity.SimpleId;\n import org.apache.usergrid.persistence.schema.CollectionInfo;\n import org.apache.usergrid.utils.InflectionUtils;\n import org.apache.usergrid.utils.MapUtils;\n-\n-import com.google.common.base.Optional;\n-import com.google.common.base.Preconditions;\n-\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.util.Assert;\n import rx.Observable;\n \n-import static org.apache.usergrid.corepersistence.util.CpNamingUtils.createCollectionEdge;\n-import static org.apache.usergrid.corepersistence.util.CpNamingUtils.createConnectionEdge;\n-import static org.apache.usergrid.corepersistence.util.CpNamingUtils.createConnectionSearchByEdge;\n-import static org.apache.usergrid.corepersistence.util.CpNamingUtils.getNameFromEdgeType;\n+import java.util.*;\n+\n+import static org.apache.usergrid.corepersistence.util.CpNamingUtils.*;\n import static org.apache.usergrid.persistence.Schema.*;\n import static org.apache.usergrid.utils.ClassUtils.cast;\n import static org.apache.usergrid.utils.InflectionUtils.singularize;\n@@ -954,7 +933,7 @@ public Results searchTargetEntities( Query query ) throws Exception {\n         final Id sourceId = headEntity.asId();\n \n         final Optional<String> queryString = query.isGraphSearch()? Optional.<String>absent(): query.getQl();\n-\n+        final boolean isConnecting = query.isConnecting();\n \n         if ( query.getResultsLevel() == Level.REFS || query.getResultsLevel() == Level.IDS ) {\n \n@@ -968,7 +947,7 @@ public Results searchTargetEntities( Query query ) throws Exception {\n \n                     final ConnectionSearch search =\n                         new ConnectionSearch( applicationScope, sourceId, entityType, connection, toExecute.getLimit(),\n-                            queryString, cursor );\n+                            queryString, cursor, isConnecting );\n                     return connectionService.searchConnectionAsRefs( search );\n                 }\n             }.next();\n@@ -983,7 +962,7 @@ public Results searchTargetEntities( Query query ) throws Exception {\n                 //we need the callback so as we get a new cursor, we execute a new search and re-initialize our builders\n                 final ConnectionSearch search =\n                     new ConnectionSearch( applicationScope, sourceId, entityType, connection, toExecute.getLimit(),\n-                        queryString, cursor );\n+                        queryString, cursor, isConnecting );\n                 return connectionService.searchConnection( search );\n             }\n         }.next();",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/CpRelationManager.java",
                "sha": "57b1526e692f1b91f14bea8fa0e6ab8b0a4fe4c2",
                "status": "modified"
            },
            {
                "additions": 24,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/builder/IdBuilder.java",
                "changes": 29,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/builder/IdBuilder.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 5,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/builder/IdBuilder.java",
                "patch": "@@ -20,23 +20,20 @@\n package org.apache.usergrid.corepersistence.pipeline.builder;\n \n \n+import com.google.common.base.Optional;\n+import org.apache.usergrid.corepersistence.pipeline.Pipeline;\n import org.apache.usergrid.corepersistence.pipeline.PipelineOperation;\n import org.apache.usergrid.corepersistence.pipeline.read.FilterFactory;\n-import org.apache.usergrid.corepersistence.pipeline.Pipeline;\n import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n import org.apache.usergrid.corepersistence.pipeline.read.ResultsPage;\n import org.apache.usergrid.corepersistence.pipeline.read.collect.ConnectionRefFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.collect.ConnectionRefResumeFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.collect.IdResumeFilter;\n import org.apache.usergrid.corepersistence.pipeline.read.collect.ResultsPageCollector;\n import org.apache.usergrid.corepersistence.pipeline.read.search.Candidate;\n-import org.apache.usergrid.corepersistence.pipeline.read.traverse.IdFilter;\n import org.apache.usergrid.persistence.ConnectionRef;\n import org.apache.usergrid.persistence.model.entity.Entity;\n import org.apache.usergrid.persistence.model.entity.Id;\n-\n-import com.google.common.base.Optional;\n-\n import rx.Observable;\n \n \n@@ -68,6 +65,28 @@ public EntityBuilder loadEntities() {\n     }\n \n \n+    /**\n+     * Traverse all connection edges to our input Id\n+     * @param connectionName The name of the connection\n+     * @param entityType The optional type of the entity\n+     * @return\n+     */\n+    public IdBuilder traverseReverseConnection( final String connectionName, final Optional<String> entityType ) {\n+\n+        final PipelineOperation<FilterResult<Id>, FilterResult<Id>> filter;\n+\n+        if(entityType.isPresent()){\n+            //todo: change this too.\n+            filter = filterFactory.readGraphConnectionByTypeFilter( connectionName, entityType.get() );\n+        }else{\n+            filter = filterFactory.readGraphReverseConnectionFilter( connectionName );\n+        }\n+\n+\n+        return new IdBuilder( pipeline.withFilter(filter ), filterFactory );\n+    }\n+\n+\n     /**\n      * Traverse all the collection edges from our input Id\n      * @param collectionName",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/builder/IdBuilder.java",
                "sha": "b7d1f867c7363640787be87b6dd5b865139dc8bf",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java",
                "patch": "@@ -62,6 +62,14 @@\n      */\n     ReadGraphConnectionFilter readGraphConnectionFilter( final String connectionName );\n \n+\n+    /**\n+     * Generate a new instance of the command with the specified parameters\n+     *\n+     * @param connectionName The connection name to use when reverse traversing the graph\n+     */\n+    ReadGraphReverseConnectionFilter readGraphReverseConnectionFilter( final String connectionName );\n+\n     /**\n      * Generate a new instance of the command with the specified parameters\n      *",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/FilterFactory.java",
                "sha": "4b615d840c0022bc044e0b5d8db7da657acb5eb3",
                "status": "modified"
            },
            {
                "additions": 291,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/AbstractReadReverseGraphFilter.java",
                "changes": 291,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/AbstractReadReverseGraphFilter.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/AbstractReadReverseGraphFilter.java",
                "patch": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read.traverse;\n+\n+\n+import org.apache.usergrid.corepersistence.asyncevents.AsyncEventService;\n+import org.apache.usergrid.corepersistence.asyncevents.EventBuilder;\n+import org.apache.usergrid.corepersistence.asyncevents.EventBuilderImpl;\n+import org.apache.usergrid.persistence.core.rx.RxTaskScheduler;\n+import org.apache.usergrid.persistence.index.impl.IndexOperationMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.usergrid.corepersistence.pipeline.cursor.CursorSerializer;\n+import org.apache.usergrid.corepersistence.pipeline.read.AbstractPathFilter;\n+import org.apache.usergrid.corepersistence.pipeline.read.EdgePath;\n+import org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\n+import org.apache.usergrid.persistence.core.scope.ApplicationScope;\n+import org.apache.usergrid.persistence.graph.Edge;\n+import org.apache.usergrid.persistence.graph.GraphManager;\n+import org.apache.usergrid.persistence.graph.GraphManagerFactory;\n+import org.apache.usergrid.persistence.graph.MarkedEdge;\n+import org.apache.usergrid.persistence.graph.SearchByEdgeType;\n+import org.apache.usergrid.persistence.graph.impl.SimpleSearchByEdgeType;\n+import org.apache.usergrid.persistence.model.entity.Id;\n+\n+import com.google.common.base.Optional;\n+\n+import rx.Observable;\n+import rx.functions.Func1;\n+\n+\n+/**\n+ * Command for reading graph edges in reverse order.\n+ */\n+public abstract class AbstractReadReverseGraphFilter extends AbstractPathFilter<Id, Id, MarkedEdge> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger( AbstractReadGraphFilter.class );\n+\n+    private final GraphManagerFactory graphManagerFactory;\n+    private final RxTaskScheduler rxTaskScheduler;\n+    private final EventBuilder eventBuilder;\n+    private final AsyncEventService asyncEventService;\n+\n+\n+    /**\n+     * Create a new instance of our command\n+     */\n+    public AbstractReadReverseGraphFilter( final GraphManagerFactory graphManagerFactory,\n+                                    final RxTaskScheduler rxTaskScheduler,\n+                                    final EventBuilder eventBuilder,\n+                                    final AsyncEventService asyncEventService ) {\n+        this.graphManagerFactory = graphManagerFactory;\n+        this.rxTaskScheduler = rxTaskScheduler;\n+        this.eventBuilder = eventBuilder;\n+        this.asyncEventService = asyncEventService;\n+    }\n+\n+\n+    @Override\n+    public Observable<FilterResult<Id>> call( final Observable<FilterResult<Id>> previousIds ) {\n+\n+\n+        final ApplicationScope applicationScope = pipelineContext.getApplicationScope();\n+\n+        //get the graph manager\n+        final GraphManager graphManager =\n+            graphManagerFactory.createEdgeManager( applicationScope );\n+\n+\n+        final String edgeName = getEdgeTypeName();\n+        final EdgeState edgeCursorState = new EdgeState();\n+\n+\n+        //return all ids that are emitted from this edge\n+        return previousIds.flatMap( previousFilterValue -> {\n+\n+            //set our our constant state\n+            final Optional<MarkedEdge> startFromCursor = getSeekValue();\n+            final Id id = previousFilterValue.getValue();\n+\n+\n+            final Optional<Edge> typeWrapper = Optional.fromNullable(startFromCursor.orNull());\n+\n+            /**\n+             * We do not want to filter.  This is intentional DO NOT REMOVE!!!\n+             *\n+             * We want to fire events on these edges if they exist, the delete was missed.\n+             */\n+            final SimpleSearchByEdgeType search =\n+                new SimpleSearchByEdgeType( id, edgeName, Long.MAX_VALUE, SearchByEdgeType.Order.DESCENDING,\n+                    typeWrapper, false );\n+\n+            /**\n+             * TODO, pass a message with pointers to our cursor values to be generated later\n+             */\n+            return graphManager.loadEdgesToTarget( search ).filter(markedEdge -> {\n+\n+                final boolean isDeleted = markedEdge.isDeleted();\n+                final boolean isSourceNodeDeleted = markedEdge.isSourceNodeDelete();\n+                final boolean isTargetNodeDelete = markedEdge.isTargetNodeDeleted();\n+\n+\n+                if (isDeleted) {\n+\n+                    logger.info(\"Edge {} is deleted when seeking, deleting the edge\", markedEdge);\n+                    final Observable<IndexOperationMessage> indexMessageObservable = eventBuilder.buildDeleteEdge(applicationScope, markedEdge);\n+\n+                    indexMessageObservable\n+                        .compose(applyCollector())\n+                        .subscribeOn(rxTaskScheduler.getAsyncIOScheduler())\n+                        .subscribe();\n+\n+                }\n+\n+                if (isSourceNodeDeleted) {\n+\n+                    final Id sourceNodeId = markedEdge.getSourceNode();\n+                    logger.info(\"Edge {} has a deleted source node, deleting the entity for id {}\", markedEdge, sourceNodeId);\n+\n+                    final EventBuilderImpl.EntityDeleteResults\n+                        entityDeleteResults = eventBuilder.buildEntityDelete(applicationScope, sourceNodeId);\n+\n+                    entityDeleteResults.getIndexObservable()\n+                        .compose(applyCollector())\n+                        .subscribeOn(rxTaskScheduler.getAsyncIOScheduler())\n+                        .subscribe();\n+\n+                    Observable.merge(entityDeleteResults.getEntitiesDeleted(),\n+                        entityDeleteResults.getCompactedNode())\n+                        .subscribeOn(rxTaskScheduler.getAsyncIOScheduler()).\n+                        subscribe();\n+\n+                }\n+\n+                if (isTargetNodeDelete) {\n+\n+                    final Id targetNodeId = markedEdge.getTargetNode();\n+                    logger.info(\"Edge {} has a deleted target node, deleting the entity for id {}\", markedEdge, targetNodeId);\n+\n+                    final EventBuilderImpl.EntityDeleteResults\n+                        entityDeleteResults = eventBuilder.buildEntityDelete(applicationScope, targetNodeId);\n+\n+                    entityDeleteResults.getIndexObservable()\n+                        .compose(applyCollector())\n+                        .subscribeOn(rxTaskScheduler.getAsyncIOScheduler())\n+                        .subscribe();\n+\n+                    Observable.merge(entityDeleteResults.getEntitiesDeleted(),\n+                        entityDeleteResults.getCompactedNode())\n+                        .subscribeOn(rxTaskScheduler.getAsyncIOScheduler()).\n+                        subscribe();\n+\n+                }\n+\n+\n+                //filter if any of them are marked\n+                return !isDeleted && !isSourceNodeDeleted && !isTargetNodeDelete;\n+\n+\n+            })  // any non-deleted edges should be de-duped here so the results are unique\n+                .distinct( new EdgeDistinctKey() )\n+                //set the edge state for cursors\n+                .doOnNext( edge -> {\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"Seeking over edge {}\", edge);\n+                    }\n+                    edgeCursorState.update( edge );\n+                } )\n+\n+                //map our id from the target edge  and set our cursor every edge we traverse\n+                .map( edge -> createFilterResult( edge.getSourceNode(), edgeCursorState.getCursorEdge(),\n+                    previousFilterValue.getPath() ) );\n+        } );\n+    }\n+\n+\n+    @Override\n+    protected FilterResult<Id> createFilterResult( final Id emit, final MarkedEdge cursorValue,\n+                                                   final Optional<EdgePath> parent ) {\n+\n+        //if it's our first pass, there's no cursor to generate\n+        if(cursorValue == null){\n+            return new FilterResult<>( emit, parent );\n+        }\n+\n+        return super.createFilterResult( emit, cursorValue, parent );\n+    }\n+\n+\n+    @Override\n+    protected CursorSerializer<MarkedEdge> getCursorSerializer() {\n+        return EdgeCursorSerializer.INSTANCE;\n+    }\n+\n+\n+    /**\n+     * Get the edge type name we should use when traversing\n+     */\n+    protected abstract String getEdgeTypeName();\n+\n+\n+    /**\n+     * Wrapper class. Because edges seek > the last returned, we need to keep our n-1 value. This will be our cursor We\n+     * always try to seek to the same position as we ended.  Since we don't deal with a persistent read result, if we\n+     * seek to a value = to our last, we may skip data.\n+     */\n+    private final class EdgeState {\n+\n+        private MarkedEdge cursorEdge = null;\n+        private MarkedEdge currentEdge = null;\n+\n+\n+        /**\n+         * Update the pointers\n+         */\n+        private void update( final MarkedEdge newEdge ) {\n+            cursorEdge = currentEdge;\n+            currentEdge = newEdge;\n+        }\n+\n+\n+        /**\n+         * Get the edge to use in cursors for resume\n+         */\n+        private MarkedEdge getCursorEdge() {\n+            return cursorEdge;\n+        }\n+    }\n+\n+    private Observable.Transformer<IndexOperationMessage, IndexOperationMessage> applyCollector() {\n+\n+        return observable -> observable\n+            .collect(() -> new IndexOperationMessage(), (collector, single) -> collector.ingest(single))\n+            .filter(msg -> !msg.isEmpty())\n+            .doOnNext(indexOperation -> {\n+                asyncEventService.queueIndexOperationMessage(indexOperation);\n+            });\n+\n+    }\n+\n+    /**\n+     *  Return a key that Rx can use for determining a distinct edge.  Build a string containing the UUID\n+     *  of the source and target nodes, with the type to ensure uniqueness rather than the int sum of the hash codes.\n+     *  Edge timestamp is specifically left out as edges with the same source,target,type but different timestamps\n+     *  are considered duplicates.\n+     */\n+    private class EdgeDistinctKey implements Func1<Edge,String> {\n+\n+        @Override\n+        public String call(Edge edge) {\n+\n+            return buildDistinctKey(edge.getSourceNode().getUuid().toString(), edge.getTargetNode().getUuid().toString(),\n+                edge.getType().toLowerCase());\n+        }\n+    }\n+\n+    protected static String buildDistinctKey(final String sourceNode, final String targetNode, final String type){\n+\n+        final String DISTINCT_KEY_SEPARATOR = \":\";\n+        StringBuilder stringBuilder = new StringBuilder();\n+\n+        stringBuilder\n+            .append(sourceNode)\n+            .append(DISTINCT_KEY_SEPARATOR)\n+            .append(targetNode)\n+            .append(DISTINCT_KEY_SEPARATOR)\n+            .append(type);\n+\n+        return stringBuilder.toString();\n+\n+    }\n+\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/AbstractReadReverseGraphFilter.java",
                "sha": "dcda98f508be1bacd8d1b1a227e18b6288d45acf",
                "status": "added"
            },
            {
                "additions": 53,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/ReadGraphReverseConnectionFilter.java",
                "changes": 53,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/ReadGraphReverseConnectionFilter.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 0,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/ReadGraphReverseConnectionFilter.java",
                "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.usergrid.corepersistence.pipeline.read.traverse;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.assistedinject.Assisted;\n+import org.apache.usergrid.corepersistence.asyncevents.AsyncEventService;\n+import org.apache.usergrid.corepersistence.asyncevents.EventBuilder;\n+import org.apache.usergrid.corepersistence.rx.impl.AsyncRepair;\n+import org.apache.usergrid.persistence.core.rx.RxTaskScheduler;\n+import org.apache.usergrid.persistence.graph.GraphManagerFactory;\n+\n+import static org.apache.usergrid.corepersistence.util.CpNamingUtils.getEdgeTypeFromConnectionType;\n+\n+/**\n+ * Created by ayeshadastagiri on 8/9/16.\n+ */\n+public class ReadGraphReverseConnectionFilter extends AbstractReadReverseGraphFilter{\n+    private final String connectionName;\n+\n+    /**\n+     * Create a new instance of our command\n+     */\n+    @Inject\n+    public ReadGraphReverseConnectionFilter( final GraphManagerFactory graphManagerFactory,\n+                                      @AsyncRepair final RxTaskScheduler rxTaskScheduler,\n+                                      final EventBuilder eventBuilder,\n+                                      final AsyncEventService asyncEventService,\n+                                      @Assisted final String connectionName ) {\n+        super( graphManagerFactory, rxTaskScheduler, eventBuilder, asyncEventService );\n+        this.connectionName = connectionName;\n+    }\n+    @Override\n+    protected String getEdgeTypeName() {\n+        return getEdgeTypeFromConnectionType( connectionName );    }\n+}",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/pipeline/read/traverse/ReadGraphReverseConnectionFilter.java",
                "sha": "aa369c25258e2716e1744aadc7868696204cf843",
                "status": "added"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionSearch.java",
                "changes": 8,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionSearch.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 1,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionSearch.java",
                "patch": "@@ -36,18 +36,20 @@\n     private final int limit;\n     private final Optional<String> query;\n     private final Optional<String> cursor;\n+    private final boolean isConnecting;\n \n \n     public ConnectionSearch( final ApplicationScope applicationScope, final Id sourceNodeId, final Optional<String> entityType,\n                              final String connectionName, final int limit, final Optional<String> query, final\n-                             Optional<String> cursor ) {\n+                             Optional<String> cursor, boolean isConnecting ) {\n         this.applicationScope = applicationScope;\n         this.sourceNodeId = sourceNodeId;\n         this.entityType = entityType;\n         this.connectionName = connectionName;\n         this.limit = limit;\n         this.query = query;\n         this.cursor = cursor;\n+        this.isConnecting = isConnecting;\n     }\n \n \n@@ -84,4 +86,8 @@ public Id getSourceNodeId() {\n     public Optional<String> getEntityType() {\n         return entityType;\n     }\n+\n+    public boolean getIsConnecting(){\n+        return isConnecting;\n+    }\n }",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionSearch.java",
                "sha": "8ad57fbdcda7e603c54313fd5fe6367f5a1acf2b",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 2,
                "filename": "stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java",
                "patch": "@@ -94,8 +94,13 @@ public ConnectionServiceImpl( final PipelineBuilderFactory pipelineBuilderFactor\n \n \n         if ( !query.isPresent() ) {\n-            results =\n-                pipelineBuilder.traverseConnection( search.getConnectionName(), search.getEntityType() ).loadEntities();\n+            if(search.getIsConnecting()){\n+                results = pipelineBuilder.traverseReverseConnection(search.getConnectionName(), search.getEntityType()).loadEntities();\n+            }\n+            else {\n+                results =\n+                    pipelineBuilder.traverseConnection(search.getConnectionName(), search.getEntityType()).loadEntities();\n+            }\n         }\n \n         else {",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/corepersistence/service/ConnectionServiceImpl.java",
                "sha": "926c67627e2bc9687734ae1bb9863bda0727b398",
                "status": "modified"
            },
            {
                "additions": 19,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/persistence/Query.java",
                "changes": 39,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/main/java/org/apache/usergrid/persistence/Query.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 20,
                "filename": "stack/core/src/main/java/org/apache/usergrid/persistence/Query.java",
                "patch": "@@ -19,36 +19,25 @@\n package org.apache.usergrid.persistence;\n \n \n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.io.UnsupportedEncodingException;\n-import java.net.URLDecoder;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.UUID;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.commons.codec.binary.Base64;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.base.Optional;\n import org.apache.commons.lang.StringUtils;\n-\n import org.apache.usergrid.persistence.index.SelectFieldMapping;\n import org.apache.usergrid.persistence.index.exceptions.QueryParseException;\n import org.apache.usergrid.persistence.index.query.CounterResolution;\n import org.apache.usergrid.persistence.index.query.Identifier;\n import org.apache.usergrid.persistence.index.query.tree.Operand;\n import org.apache.usergrid.persistence.index.utils.ClassUtils;\n-import org.apache.usergrid.persistence.index.utils.ConversionUtils;\n import org.apache.usergrid.persistence.index.utils.ListUtils;\n import org.apache.usergrid.persistence.index.utils.MapUtils;\n \n-import com.fasterxml.jackson.annotation.JsonIgnore;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.google.common.base.Optional;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.*;\n+import java.util.Map.Entry;\n \n \n public class Query {\n@@ -82,6 +71,7 @@\n     private Long startTime;\n     private Long finishTime;\n     private boolean pad;\n+    private boolean connecting = false;\n     private CounterResolution resolution = CounterResolution.ALL;\n     private List<Identifier> identifiers;\n     private List<CounterFilterPredicate> counterFilters;\n@@ -611,6 +601,15 @@ public void setPad( boolean pad ) {\n         this.pad = pad;\n     }\n \n+    //set the flag to retrieve the edges in the reverse direction.\n+    public void setConnecting( boolean connecting ) {\n+        this.connecting = connecting;\n+    }\n+\n+    public boolean isConnecting() {\n+        return connecting;\n+    }\n+\n \n     public void setResolution( CounterResolution resolution ) {\n         this.resolution = resolution;",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/main/java/org/apache/usergrid/persistence/Query.java",
                "sha": "d68c08534524729c661819c779d64bb0cffb6cbc",
                "status": "modified"
            },
            {
                "additions": 54,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java",
                "changes": 67,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 13,
                "filename": "stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java",
                "patch": "@@ -17,24 +17,17 @@\n package org.apache.usergrid.persistence;\n \n \n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.UUID;\n-\n+import org.apache.usergrid.AbstractCoreIT;\n+import org.apache.usergrid.persistence.Query.Level;\n+import org.apache.usergrid.persistence.entities.User;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.usergrid.AbstractCoreIT;\n-import org.apache.usergrid.persistence.entities.User;\n-import org.apache.usergrid.persistence.Query.Level;\n+import java.util.*;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n \n public class EntityConnectionsIT extends AbstractCoreIT {\n     private static final Logger logger = LoggerFactory.getLogger( EntityConnectionsIT.class );\n@@ -335,6 +328,54 @@ public void testGetConnectingEntities() throws Exception {\n         assertEquals( \"user\", res.getEntity().getType() );\n     }\n \n+    //not required . addd tests at service layer.\n+    @Ignore\n+    @Test\n+    public void testGetConnectingEntitiesCursor() throws Exception {\n+\n+        UUID applicationId = app.getId( );\n+        assertNotNull( applicationId );\n+\n+        EntityManager em = app.getEntityManager();\n+        assertNotNull( em );\n+\n+        User fred = new User();\n+        fred.setUsername( \"fred\" );\n+        fred.setEmail( \"fred@flintstones.com\" );\n+        Entity fredEntity = em.create( fred );\n+        assertNotNull( fredEntity );\n+\n+        User wilma = new User();\n+        wilma.setUsername( \"wilma\" );\n+        wilma.setEmail( \"wilma@flintstones.com\" );\n+        Entity wilmaEntity = em.create( wilma );\n+        assertNotNull( wilmaEntity );\n+\n+        User John = new User();\n+        John.setUsername( \"John\" );\n+        John.setEmail( \"John@flintstones.com\" );\n+        Entity JohnEntity = em.create( John );\n+        assertNotNull( JohnEntity );\n+\n+        em.createConnection( fredEntity, \"likes\", wilmaEntity );\n+        em.createConnection( fredEntity, \"likes\", JohnEntity );\n+\n+\n+        app.refreshIndex();\n+\n+        // now query via the testConnection, this should work\n+\n+        Query query = Query.fromQLNullSafe(\"\" );\n+        query.setConnectionType( \"likes\" );\n+//        query.setConnecting(true);\n+        query.setEntityType( \"user\" );\n+\n+        // goes through \"traverseReverseConnection\"\n+        Results r = em.searchTargetEntities(fredEntity, query);\n+\n+        assertEquals( 2, r.size() );\n+    }\n+\n \n \n ",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/core/src/test/java/org/apache/usergrid/persistence/EntityConnectionsIT.java",
                "sha": "3d4e53c53592ea1908f1f726da119e041d7b7da0",
                "status": "modified"
            },
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/services/src/main/java/org/apache/usergrid/services/AbstractConnectionsService.java",
                "changes": 35,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/apache/usergrid/services/AbstractConnectionsService.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 22,
                "filename": "stack/services/src/main/java/org/apache/usergrid/services/AbstractConnectionsService.java",
                "patch": "@@ -17,32 +17,24 @@\n package org.apache.usergrid.services;\n \n \n-import java.util.List;\n-import java.util.Set;\n-import java.util.UUID;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.usergrid.persistence.ConnectionRef;\n-import org.apache.usergrid.persistence.Entity;\n-import org.apache.usergrid.persistence.EntityRef;\n-import org.apache.usergrid.persistence.Query;\n+import org.apache.usergrid.persistence.*;\n import org.apache.usergrid.persistence.Query.Level;\n-import org.apache.usergrid.persistence.Results;\n-import org.apache.usergrid.persistence.Schema;\n-import org.apache.usergrid.persistence.SimpleEntityRef;\n import org.apache.usergrid.persistence.index.query.Identifier;\n import org.apache.usergrid.services.ServiceParameter.IdParameter;\n import org.apache.usergrid.services.ServiceParameter.NameParameter;\n import org.apache.usergrid.services.ServiceParameter.QueryParameter;\n import org.apache.usergrid.services.ServiceResults.Type;\n import org.apache.usergrid.services.exceptions.ServiceResourceNotFoundException;\n import org.apache.usergrid.services.exceptions.UnsupportedServiceOperationException;\n-\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import rx.Observable;\n import rx.schedulers.Schedulers;\n \n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+\n import static org.apache.usergrid.services.ServiceParameter.filter;\n import static org.apache.usergrid.services.ServiceParameter.firstParameterIsName;\n import static org.apache.usergrid.utils.ClassUtils.cast;\n@@ -307,20 +299,15 @@ public ServiceResults getItemsByQuery( ServiceContext context, Query query ) thr\n         Results r = null;\n \n         if ( connecting() ) {\n+            query.setConnecting(true);\n             if ( query.hasQueryPredicates() ) {\n                 if (logger.isTraceEnabled()) {\n                     logger.trace(\"Attempted query of backwards connections\");\n                 }\n                 return null;\n             }\n             else {\n-//            \tr = em.getSourceEntities( context.getOwner().getUuid(), query.getConnectionType(),\n-//            \t\t\tquery.getEntityType(), level );\n-                // usergrid-2389: User defined limit in the query is ignored. Fixed it by adding\n-                // the limit to the method parameter downstream.\n-            \tr = em.getSourceEntities(\n-                    new SimpleEntityRef(context.getOwner().getType(), context.getOwner().getUuid()),\n-                    query.getConnectionType(), query.getEntityType(), level, query.getLimit());\n+                r = em.searchTargetEntities(context.getOwner(),query);\n             }\n         }\n         else {\n@@ -381,6 +368,10 @@ public ServiceResults postItemsByQuery( ServiceContext context, Query query ) th\n             }\n             else {\n                 entity = em.create( query.getEntityType(), context.getProperties() );\n+                //if entity is null here it throws NPE. Fixing it to throw 404.\n+                if ( entity == null ) {\n+                    throw new ServiceResourceNotFoundException( context );\n+                }\n             }\n             entity = importEntity( context, entity );\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/services/src/main/java/org/apache/usergrid/services/AbstractConnectionsService.java",
                "sha": "0a9f6a779b50499f6ac472536b9d7a843218c009",
                "status": "modified"
            },
            {
                "additions": 66,
                "blob_url": "https://github.com/apache/usergrid/blob/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/services/src/test/java/org/apache/usergrid/services/ConnectionsServiceIT.java",
                "changes": 74,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/test/java/org/apache/usergrid/services/ConnectionsServiceIT.java?ref=b1157a8924686557e5c26966c5a0b14fb87eb2d6",
                "deletions": 8,
                "filename": "stack/services/src/test/java/org/apache/usergrid/services/ConnectionsServiceIT.java",
                "patch": "@@ -17,19 +17,17 @@\n package org.apache.usergrid.services;\n \n \n-import java.util.Map;\n-\n+import org.apache.usergrid.persistence.Entity;\n+import org.apache.usergrid.persistence.Query;\n import org.junit.Assert;\n import org.junit.Test;\n-\n-import org.apache.usergrid.persistence.Entity;\n-\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.Map;\n+\n+import static org.junit.Assert.*;\n+\n \n \n public class ConnectionsServiceIT extends AbstractServiceIT {\n@@ -86,6 +84,66 @@ public void testUserConnections() throws Exception {\n         app.testRequest( ServiceAction.POST, 1, \"users\", \"conn-user1\", \"manages\", \"user\" );\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    @Test\n+    public void testUserConnectionsCursor() throws Exception {\n+        app.put(\"username\", \"conn-user1\");\n+        app.put(\"email\", \"conn-user1@apigee.com\");\n+\n+        Entity user1 = app.testRequest(ServiceAction.POST, 1, \"users\").getEntity();\n+        assertNotNull(user1);\n+\n+        app.testRequest(ServiceAction.GET, 1, \"users\", \"conn-user1\");\n+\n+        app.put(\"username\", \"conn-user2\");\n+        app.put(\"email\", \"conn-user2@apigee.com\");\n+\n+        Entity user2 = app.testRequest(ServiceAction.POST, 1, \"users\").getEntity();\n+        assertNotNull(user2);\n+\n+\n+        app.put(\"username\", \"conn-user3\");\n+        app.put(\"email\", \"conn-user3@apigee.com\");\n+\n+        Entity user3 = app.testRequest(ServiceAction.POST, 1, \"users\").getEntity();\n+        assertNotNull(user3);\n+\n+\n+        //POST users/conn-user2/manages/user2/conn-user1\n+        app.testRequest(ServiceAction.POST, 1, \"users\", \"conn-user2\", \"likes\", \"users\", \"conn-user1\");\n+        //POST users/conn-user3/reports/users/conn-user1\n+        app.testRequest(ServiceAction.POST, 1, \"users\", \"conn-user3\", \"likes\", \"users\", \"conn-user1\");\n+\n+        Query query = new Query().fromQLNullSafe(\"\");\n+        query.setLimit(1);\n+\n+        //the result should return a valid cursor.\n+        ServiceResults result = app.testRequest(ServiceAction.GET, 1, \"users\", \"conn-user1\", \"connecting\", \"likes\",query);\n+        assertNotNull(result.getCursor());\n+        String enityName1 = result.getEntity().getProperty(\"email\").toString();\n+\n+        Query newquery = new Query().fromQLNullSafe(\"\");\n+        query.setCursor(result.getCursor());\n+        result = app.testRequest(ServiceAction.GET,1,\"users\",\"conn-user1\",\"connecting\",\"likes\",query);\n+        String enityName2 = result.getEntity().getProperty(\"email\").toString();\n+\n+        //ensure the two entities returned in above requests are different.\n+        assertNotEquals(enityName1,enityName2);\n+\n+        newquery = new Query().fromQLNullSafe(\"\");\n+        query.setCursor(result.getCursor());\n+        result = app.testRequest(ServiceAction.GET,0,\"users\",\"conn-user1\",\"connecting\",\"likes\",query);\n+        //return empty cursor when no more entitites found.\n+        assertNull(result.getCursor());\n+\n+        //DELETE users/conn-user1/manages/user2/conn-user2 (qualified by collection type on second entity)\n+        app.testRequest(ServiceAction.DELETE, 1, \"users\", \"conn-user2\", \"likes\", \"users\", \"conn-user1\");\n+\n+        app.testRequest(ServiceAction.GET,1,\"users\",\"conn-user1\",\"connecting\",\"likes\");\n+\n+\n+    }\n+\n     @Test\n     public void testNonExistentEntity() throws Exception {\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/b1157a8924686557e5c26966c5a0b14fb87eb2d6/stack/services/src/test/java/org/apache/usergrid/services/ConnectionsServiceIT.java",
                "sha": "4e65f54d2079825b59e371d425f814653ac82bc5",
                "status": "modified"
            }
        ],
        "message": "Fixing https://issues.apache.org/jira/browse/USERGRID-1310.\nAlso fixed an NPE found during the fix. ( in abstract connection service when entity us null it throws NPE. Changed it to throw 404)",
        "parent": "https://github.com/apache/usergrid/commit/10e895767c9cc661ad6c6e728eb1b780e0efe7e9",
        "patched_files": [
            "ConnectionServiceImpl.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "ConnectionServiceImplTest.java"
        ]
    },
    "usergrid_c0eeefd": {
        "bug_id": "usergrid_c0eeefd",
        "commit": "https://github.com/apache/usergrid/commit/c0eeefd52f9e17e53d9f924f812624ca022d3040",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/usergrid/blob/c0eeefd52f9e17e53d9f924f812624ca022d3040/stack/services/src/main/java/org/usergrid/services/roles/RolesService.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/roles/RolesService.java?ref=c0eeefd52f9e17e53d9f924f812624ca022d3040",
                "deletions": 1,
                "filename": "stack/services/src/main/java/org/usergrid/services/roles/RolesService.java",
                "patch": "@@ -157,7 +157,11 @@ public ServiceResults deleteEntityDictionary(ServiceContext context, List<Entity\n                 throw new IllegalArgumentException(String.format(\"Could not load role with id '%s'\", ref.getUuid()));\n             }\n \n-            Query q = context.getParameters().get(0).getQuery();\n+            Query q = null;\n+\n+            if (context.getParameters().size() > 0) {\n+                q = context.getParameters().get(0).getQuery();\n+            }\n \n             if (q == null) {\n                 throw new IllegalArgumentException(\"You must supply a 'permission' query parameter\");",
                "raw_url": "https://github.com/apache/usergrid/raw/c0eeefd52f9e17e53d9f924f812624ca022d3040/stack/services/src/main/java/org/usergrid/services/roles/RolesService.java",
                "sha": "4a837a3119d8ca0080c0a7eb5f826238cce41b71",
                "status": "modified"
            }
        ],
        "message": "avoid NullPointerException",
        "parent": "https://github.com/apache/usergrid/commit/546051f47223b26c7fd75863c0a63b5763e3b145",
        "patched_files": [
            "RolesService.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "RolesServiceTest.java"
        ]
    },
    "usergrid_c8af2e5": {
        "bug_id": "usergrid_c8af2e5",
        "commit": "https://github.com/apache/usergrid/commit/c8af2e5fb445f1483327165e6ed93e6fb4d9b3fc",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/c8af2e5fb445f1483327165e6ed93e6fb4d9b3fc/stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java?ref=c8af2e5fb445f1483327165e6ed93e6fb4d9b3fc",
                "deletions": 2,
                "filename": "stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java",
                "patch": "@@ -349,7 +349,7 @@ public Viewable handlePasswordResetForm(@Context UriInfo ui,\n \n             if (!useReCaptcha()) {\n                 management.startAppUserPasswordResetFlow(getApplicationId(),\n-                        user);\n+                \t\tgetUser());\n                 return handleViewable(\"resetpw_email_success\", this);\n             }\n \n@@ -362,7 +362,7 @@ public Viewable handlePasswordResetForm(@Context UriInfo ui,\n \n             if (reCaptchaResponse.isValid()) {\n                 management.startAppUserPasswordResetFlow(getApplicationId(),\n-                        user);\n+                        getUser());\n                 return handleViewable(\"resetpw_email_success\", this);\n             } else {\n                 errorMsg = \"Incorrect Captcha\";",
                "raw_url": "https://github.com/apache/usergrid/raw/c8af2e5fb445f1483327165e6ed93e6fb4d9b3fc/stack/rest/src/main/java/org/usergrid/rest/applications/users/UserResource.java",
                "sha": "53c2578df9a27706f9d1f6e2e3951498567f93a8",
                "status": "modified"
            }
        ],
        "message": "Merge pull request #15 from realbeast/resetpw\n\nfixed application user password reset flow NPE",
        "parent": "https://github.com/apache/usergrid/commit/a72d805d279decd5024daf6e57bacedcd1544f99",
        "patched_files": [
            "UserResource.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "UserResourceTest.java"
        ]
    },
    "usergrid_cffc1cb": {
        "bug_id": "usergrid_cffc1cb",
        "commit": "https://github.com/apache/usergrid/commit/cffc1cb7c276508741a35276ae6233c3319c16a8",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/usergrid/blob/cffc1cb7c276508741a35276ae6233c3319c16a8/stack/services/src/main/java/org/usergrid/services/groups/GroupsService.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/groups/GroupsService.java?ref=cffc1cb7c276508741a35276ae6233c3319c16a8",
                "deletions": 0,
                "filename": "stack/services/src/main/java/org/usergrid/services/groups/GroupsService.java",
                "patch": "@@ -50,6 +50,10 @@ public ServiceResults postCollection(ServiceContext context)\n \t\t\tthrows Exception {\n \n     String path = (String)context.getProperty(\"path\");\n+    \n+    if(path == null){\n+        throw new IllegalArgumentException(\"You must provide a 'path' property when creating a group\");\n+    }\n \n     logger.info(\"Creating group with path {}\", path);\n ",
                "raw_url": "https://github.com/apache/usergrid/raw/cffc1cb7c276508741a35276ae6233c3319c16a8/stack/services/src/main/java/org/usergrid/services/groups/GroupsService.java",
                "sha": "77722b52472393dda402e6dc05b14da12e54c2c9",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/usergrid/blob/cffc1cb7c276508741a35276ae6233c3319c16a8/stack/services/src/main/java/org/usergrid/services/roles/RolesService.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/usergrid/contents/stack/services/src/main/java/org/usergrid/services/roles/RolesService.java?ref=cffc1cb7c276508741a35276ae6233c3319c16a8",
                "deletions": 1,
                "filename": "stack/services/src/main/java/org/usergrid/services/roles/RolesService.java",
                "patch": "@@ -73,8 +73,9 @@ public ServiceResults getEntityDictionary(ServiceContext context, List<EntityRef\n \n             String roleName = (String) em.getProperty(ref, \"name\");\n             \n+            //Should never happen\n             if (isBlank(roleName)) {\n-                return null;\n+                throw new IllegalArgumentException(\"You must provide a role name\");\n             }\n \n             return getApplicationRolePermissions(roleName);",
                "raw_url": "https://github.com/apache/usergrid/raw/cffc1cb7c276508741a35276ae6233c3319c16a8/stack/services/src/main/java/org/usergrid/services/roles/RolesService.java",
                "sha": "43e8077f81635dccc651f02504708f2ebfbbbe2d",
                "status": "modified"
            }
        ],
        "message": "Fixed invalid input errors for services that can cause NPEs",
        "parent": "https://github.com/apache/usergrid/commit/d97dd804b9eb1570fb2cd6b02e550670589c9e39",
        "patched_files": [
            "RolesService.java"
        ],
        "repo": "usergrid",
        "unit_tests": [
            "RolesServiceTest.java"
        ]
    }
}