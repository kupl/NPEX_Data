[
    {
        "repo": "sling-org-apache-sling-jcr-resource",
        "commit": "https://github.com/apache/sling-org-apache-sling-jcr-resource/commit/5eb44848b8f330447915ac9bac03f64d598e2cc5",
        "bug_id": "sling-org-apache-sling-jcr-resource_5eb4484",
        "message": "Revert \"SLING-7805 - NPE in Oak SessionImpl when starting up\"\n\nRestore the fix for SLING-3524",
        "parent": "https://github.com/apache/sling-org-apache-sling-jcr-resource/commit/4ed12eb799799404347f6a3550c712284a825741",
        "patched_files": [
            "pom.xml",
            "JcrResourceProvider.java",
            "JcrProviderStateFactory.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 2,
                "raw_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/raw/5eb44848b8f330447915ac9bac03f64d598e2cc5/pom.xml",
                "contents_url": "https://api.github.com/repos/apache/sling-org-apache-sling-jcr-resource/contents/pom.xml?ref=5eb44848b8f330447915ac9bac03f64d598e2cc5",
                "filename": "pom.xml",
                "deletions": 1,
                "sha": "fea14126697f07e32cbef706a3c6905341c5a12a",
                "blob_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/blob/5eb44848b8f330447915ac9bac03f64d598e2cc5/pom.xml",
                "patch": "@@ -54,6 +54,7 @@\n             <plugin>\n                 <groupId>org.apache.sling</groupId>\n                 <artifactId>maven-sling-plugin</artifactId>\n+                <version>2.3.2</version>\n                 <executions>\n                     <execution>\n                         <id>generate-adapter-metadata</id>\n@@ -176,7 +177,7 @@\n         <dependency>\n             <groupId>org.apache.sling</groupId>\n             <artifactId>org.apache.sling.api</artifactId>\n-            <version>2.16.4</version>\n+            <version>2.18.2</version>\n             <scope>provided</scope>\n         </dependency>\n         <dependency>",
                "changes": 3
            },
            {
                "status": "modified",
                "additions": 26,
                "raw_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/raw/5eb44848b8f330447915ac9bac03f64d598e2cc5/src/main/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrProviderStateFactory.java",
                "contents_url": "https://api.github.com/repos/apache/sling-org-apache-sling-jcr-resource/contents/src/main/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrProviderStateFactory.java?ref=5eb44848b8f330447915ac9bac03f64d598e2cc5",
                "filename": "src/main/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrProviderStateFactory.java",
                "deletions": 11,
                "sha": "064f095421138569fa094b9e44501defae4911ca",
                "blob_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/blob/5eb44848b8f330447915ac9bac03f64d598e2cc5/src/main/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrProviderStateFactory.java",
                "patch": "@@ -144,7 +144,12 @@ private JcrProviderState createJcrProviderState(\n             @NotNull final Map<String, Object> authenticationInfo,\n             @Nullable final BundleContext ctx\n     ) throws LoginException {\n-        final Session impersonatedSession = handleImpersonation(session, authenticationInfo, logoutSession);\n+        boolean explicitSessionUsed = (getSession(authenticationInfo) != null);\n+        final Session impersonatedSession = handleImpersonation(session, authenticationInfo, logoutSession, explicitSessionUsed);\n+        if (impersonatedSession != session && explicitSessionUsed) {\n+            // update the session in the auth info map in case the resolver gets cloned in the future\n+            authenticationInfo.put(JcrResourceConstants.AUTHENTICATION_INFO_SESSION, impersonatedSession);\n+        }\n         // if we're actually impersonating, we're responsible for closing the session we've created, regardless\n         // of what the original logoutSession value was.\n         boolean doLogoutSession = logoutSession || (impersonatedSession != session);\n@@ -166,25 +171,35 @@ private JcrProviderState createJcrProviderState(\n      * @param logoutSession\n      *            whether to logout the <code>session</code> after impersonation\n      *            or not.\n+     * @param explicitSessionUsed\n+     *            whether the JCR session was explicitly given in the auth info or not.\n      * @return The original session or impersonated session.\n      * @throws LoginException\n      *             If something goes wrong.\n      */\n     private static Session handleImpersonation(final Session session, final Map<String, Object> authenticationInfo,\n-            final boolean logoutSession) throws LoginException {\n+            final boolean logoutSession, boolean explicitSessionUsed) throws LoginException {\n         final String sudoUser = getSudoUser(authenticationInfo);\n-        if (sudoUser != null && !session.getUserID().equals(sudoUser)) {\n-            try {\n-                final SimpleCredentials creds = new SimpleCredentials(sudoUser, new char[0]);\n+        // Do we need session.impersonate() because we are asked to impersonate another user?\n+        boolean needsSudo = (sudoUser != null) && !session.getUserID().equals(sudoUser);\n+        // Do we need session.impersonate() to get an independent copy of the session we were given in the auth info?\n+        boolean needsCloning = !needsSudo && explicitSessionUsed && authenticationInfo.containsKey(ResourceProvider.AUTH_CLONE);\n+        try {\n+            if (needsSudo) {\n+                SimpleCredentials creds = new SimpleCredentials(sudoUser, new char[0]);\n                 copyAttributes(creds, authenticationInfo);\n                 creds.setAttribute(ResourceResolver.USER_IMPERSONATOR, session.getUserID());\n                 return session.impersonate(creds);\n-            } catch (final RepositoryException re) {\n-                throw getLoginException(re);\n-            } finally {\n-                if (logoutSession) {\n-                    session.logout();\n-                }\n+            } else if (needsCloning) {\n+                SimpleCredentials creds = new SimpleCredentials(session.getUserID(), new char[0]);\n+                copyAttributes(creds, authenticationInfo);\n+                return session.impersonate(creds);\n+            }\n+        } catch (final RepositoryException re) {\n+            throw getLoginException(re);\n+        } finally {\n+            if (logoutSession) {\n+                session.logout();\n             }\n         }\n         return session;",
                "changes": 37
            },
            {
                "status": "added",
                "additions": 199,
                "raw_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/raw/5eb44848b8f330447915ac9bac03f64d598e2cc5/src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderSessionHandlingTest.java",
                "contents_url": "https://api.github.com/repos/apache/sling-org-apache-sling-jcr-resource/contents/src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderSessionHandlingTest.java?ref=5eb44848b8f330447915ac9bac03f64d598e2cc5",
                "filename": "src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderSessionHandlingTest.java",
                "deletions": 0,
                "sha": "a471446bd2b1fcdb4f1daf6420d664e424096b3b",
                "blob_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/blob/5eb44848b8f330447915ac9bac03f64d598e2cc5/src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderSessionHandlingTest.java",
                "patch": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.sling.jcr.resource.internal.helper.jcr;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.sameInstance;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.jcr.Session;\n+\n+import org.apache.sling.api.resource.ResourceResolver;\n+import org.apache.sling.api.resource.ResourceResolverFactory;\n+import org.apache.sling.commons.testing.jcr.RepositoryProvider;\n+import org.apache.sling.jcr.api.SlingRepository;\n+import org.apache.sling.jcr.resource.api.JcrResourceConstants;\n+import org.apache.sling.spi.resource.provider.ResolveContext;\n+import org.apache.sling.spi.resource.provider.ResourceProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.mockito.Mockito;\n+import org.osgi.framework.ServiceReference;\n+import org.osgi.service.component.ComponentContext;\n+\n+@RunWith(Parameterized.class)\n+public class JcrResourceProviderSessionHandlingTest {\n+\n+    private enum LoginStyle {USER, SESSION};\n+\n+    private static final String AUTH_USER = \"admin\";\n+    private static final char[] AUTH_PASSWORD = \"admin\".toCharArray();\n+    private static final String SUDO_USER = \"anonymous\";\n+\n+    @Parameters(name = \"loginStyle= {0}, sudo = {1}, clone = {2}\")\n+    public static List<Object[]> data() {\n+\n+        LoginStyle[] loginStyles = LoginStyle.values();\n+        boolean[] sudoOptions = new boolean[] {false, true};\n+        boolean[] cloneOptions = new boolean[] {false, true};\n+\n+        // Generate all possible combinations into data.\n+        List<Object[]> data = new ArrayList<>();\n+        Object[] dataPoint = new Object[3];\n+        for (LoginStyle loginStyle : loginStyles) {\n+            dataPoint[0] = loginStyle;\n+            for (boolean sudo : sudoOptions) {\n+                dataPoint[1] = sudo;\n+                for (boolean clone : cloneOptions) {\n+                    dataPoint[2] = clone;\n+                    data.add(dataPoint.clone());\n+                }\n+            }\n+        }\n+        return data;\n+    }\n+\n+    @Parameter(0)\n+    public LoginStyle loginStyle;\n+\n+    @Parameter(1)\n+    public boolean useSudo;\n+\n+    @Parameter(2)\n+    public boolean doClone;\n+\n+    // Session we're using when loginStyle == SESSION, null otherwise.\n+    private Session explicitSession;\n+\n+    private JcrResourceProvider jcrResourceProvider;\n+    private JcrProviderState jcrProviderState;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        SlingRepository repo = RepositoryProvider.instance().getRepository();\n+        Map<String, Object> authInfo = new HashMap<>();\n+        switch (loginStyle) {\n+        case USER:\n+            authInfo.put(ResourceResolverFactory.USER, AUTH_USER);\n+            authInfo.put(ResourceResolverFactory.PASSWORD, AUTH_PASSWORD);\n+            break;\n+        case SESSION:\n+            explicitSession = repo.loginAdministrative(null);\n+            authInfo.put(JcrResourceConstants.AUTHENTICATION_INFO_SESSION, explicitSession);\n+            break;\n+        }\n+\n+        if (useSudo) {\n+            authInfo.put(ResourceResolverFactory.USER_IMPERSONATION, SUDO_USER);\n+        }\n+\n+        if (doClone) {\n+            authInfo.put(ResourceProvider.AUTH_CLONE, true);\n+        }\n+\n+        ComponentContext ctx = mock(ComponentContext.class);\n+        when(ctx.locateService(anyString(), Mockito.<ServiceReference<Object>>any())).thenReturn(repo);\n+\n+        jcrResourceProvider = new JcrResourceProvider();\n+        jcrResourceProvider.activate(ctx);\n+\n+        jcrProviderState = jcrResourceProvider.authenticate(authInfo);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+\n+        // Some tests do a logout, so check for liveness before trying to log out.\n+        if (jcrProviderState.getSession().isLive()) {\n+            jcrResourceProvider.logout(jcrProviderState);\n+        }\n+\n+        jcrResourceProvider.deactivate();\n+\n+        if (explicitSession != null) {\n+            explicitSession.logout();\n+        }\n+    }\n+\n+    @Test\n+    public void sessionUsesCorrectUser() {\n+        String expectedUser = useSudo ? SUDO_USER : AUTH_USER;\n+        assertEquals(expectedUser, jcrProviderState.getSession().getUserID());\n+    }\n+\n+    @Test\n+    public void explicitSessionNotClosedOnLogout() {\n+        assumeTrue(loginStyle == LoginStyle.SESSION);\n+\n+        jcrResourceProvider.logout(jcrProviderState);\n+\n+        assertTrue(explicitSession.isLive());\n+    }\n+\n+    @Test\n+    public void sessionsDoNotLeak() {\n+        // This test is only valid if we either didn't pass an explicit session,\n+        // or the provider had to clone it. Sessions created by the provider\n+        // must be closed by the provider, or we have a session leak.\n+        assumeThat(jcrProviderState.getSession(), is(not(sameInstance(explicitSession))));\n+\n+        jcrResourceProvider.logout(jcrProviderState);\n+\n+        assertFalse(jcrProviderState.getSession().isLive());\n+    }\n+\n+    @Test\n+    public void impersonatorIsReportedCorrectly() {\n+        assumeTrue(useSudo);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ResolveContext<JcrProviderState> mockContext = mock(ResolveContext.class);\n+        when(mockContext.getProviderState()).thenReturn(jcrProviderState);\n+        Object reportedImpersonator = jcrResourceProvider.getAttribute(mockContext, ResourceResolver.USER_IMPERSONATOR);\n+\n+        assertEquals(AUTH_USER, reportedImpersonator);\n+    }\n+\n+    @Test\n+    public void clonesAreIndependent() {\n+        assumeTrue(loginStyle == LoginStyle.SESSION && doClone);\n+\n+        assertNotSame(explicitSession, jcrProviderState.getSession());\n+    }\n+\n+}",
                "changes": 199
            },
            {
                "status": "modified",
                "additions": 6,
                "raw_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/raw/5eb44848b8f330447915ac9bac03f64d598e2cc5/src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderTest.java",
                "contents_url": "https://api.github.com/repos/apache/sling-org-apache-sling-jcr-resource/contents/src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderTest.java?ref=5eb44848b8f330447915ac9bac03f64d598e2cc5",
                "filename": "src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderTest.java",
                "deletions": 23,
                "sha": "32c6bfba17d77576b4d0e751523fb46e727efdc8",
                "blob_url": "https://github.com/apache/sling-org-apache-sling-jcr-resource/blob/5eb44848b8f330447915ac9bac03f64d598e2cc5/src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderTest.java",
                "patch": "@@ -19,18 +19,11 @@\n package org.apache.sling.jcr.resource.internal.helper.jcr;\n \n import java.security.Principal;\n-import java.util.HashMap;\n-import java.util.Map;\n \n import javax.jcr.Repository;\n-import javax.jcr.RepositoryException;\n import javax.jcr.Session;\n-import javax.naming.NamingException;\n \n-import org.apache.sling.api.resource.LoginException;\n-import org.apache.sling.api.resource.ResourceResolverFactory;\n import org.apache.sling.commons.testing.jcr.RepositoryTestBase;\n-import org.apache.sling.jcr.resource.api.JcrResourceConstants;\n import org.apache.sling.spi.resource.provider.ResolveContext;\n import org.junit.Assert;\n import org.mockito.Mockito;\n@@ -47,34 +40,24 @@ protected void setUp() throws Exception {\n         super.setUp();\n         // create the session\n         session = getSession();\n+        Repository repo = getRepository();\n+        ComponentContext ctx = Mockito.mock(ComponentContext.class);\n+        Mockito.when(ctx.locateService(Mockito.anyString(), Mockito.any(ServiceReference.class))).thenReturn(repo);\n+        jcrResourceProvider = new JcrResourceProvider();\n+        jcrResourceProvider.activate(ctx);\n     }\n \n     @Override\n     protected void tearDown() throws Exception {\n+        jcrResourceProvider.deactivate();\n         super.tearDown();\n     }\n \n     public void testAdaptTo_Principal() {\n-        jcrResourceProvider = new JcrResourceProvider();\n         ResolveContext ctx = Mockito.mock(ResolveContext.class);\n         Mockito.when(ctx.getProviderState()).thenReturn(new JcrProviderState(session, null, false));\n         Assert.assertNotNull(jcrResourceProvider.adaptTo(ctx, Principal.class));\n     }\n-    \n-    public void testLeakOnSudo() throws LoginException, RepositoryException, NamingException {\n-        Repository repo = getRepository();\n-        ComponentContext ctx = Mockito.mock(ComponentContext.class);\n-        Mockito.when(ctx.locateService(Mockito.anyString(), Mockito.any(ServiceReference.class))).thenReturn(repo);\n-        jcrResourceProvider = new JcrResourceProvider();\n-        jcrResourceProvider.activate(ctx);\n-        Map<String, Object> authInfo = new HashMap<String, Object>();\n-        authInfo.put(JcrResourceConstants.AUTHENTICATION_INFO_SESSION, session);\n-        authInfo.put(ResourceResolverFactory.USER_IMPERSONATION, \"anonymous\");\n-        JcrProviderState providerState = jcrResourceProvider.authenticate(authInfo);\n-        Assert.assertNotEquals(\"Impersonation didn't start new session\", session, providerState.getSession());\n-        jcrResourceProvider.logout(providerState);\n-        assertFalse(\"Impersonated session wasn't closed.\", providerState.getSession().isLive());\n-    }\n }\n \n ",
                "changes": 29
            }
        ],
        "unit_tests": [
            "JcrResourceProviderSessionHandlingTest.java",
            "JcrResourceProviderTest.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "src/test/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProviderSessionHandlingTest.java",
        "buggy_files": [
            "pom.xml",
            "src/main/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrResourceProvider.java",
            "src/main/java/org/apache/sling/jcr/resource/internal/helper/jcr/JcrProviderStateFactory.java"
        ],
        "fixed": true
    }
]