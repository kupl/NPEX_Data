{
    "samza_02153fa": {
        "bug_id": "samza_02153fa",
        "commit": "https://github.com/apache/samza/commit/02153fa506e38b2e7f01c0374089e200bfe1e363",
        "file": [
            {
                "additions": 111,
                "blob_url": "https://github.com/apache/samza/blob/02153fa506e38b2e7f01c0374089e200bfe1e363/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java",
                "changes": 216,
                "contents_url": "https://api.github.com/repos/apache/samza/contents/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java?ref=02153fa506e38b2e7f01c0374089e200bfe1e363",
                "deletions": 105,
                "filename": "samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java",
                "patch": "@@ -66,16 +66,16 @@\n   private final Config config;\n   private final long taskShutdownMs;\n   private final String processorId;\n+  private final ExecutorService executorService;\n+  private final Object lock = new Object();\n \n-  private ExecutorService executorService;\n-\n-  private volatile SamzaContainer container = null;\n-  private volatile Throwable containerException = null;\n+  private SamzaContainer container = null;\n+  private Throwable containerException = null;\n+  private boolean processorOnStartCalled = false;\n \n   // Latch used to synchronize between the JobCoordinator thread and the container thread, when the container is\n   // stopped due to re-balancing\n   volatile CountDownLatch jcContainerShutdownLatch;\n-  private volatile boolean processorOnStartCalled = false;\n \n   @VisibleForTesting\n   JobCoordinatorListener jobCoordinatorListener = null;\n@@ -97,7 +97,7 @@\n    */\n   public StreamProcessor(Config config, Map<String, MetricsReporter> customMetricsReporters,\n                          AsyncStreamTaskFactory asyncStreamTaskFactory, StreamProcessorLifecycleListener processorListener) {\n-    this(config, customMetricsReporters, (Object) asyncStreamTaskFactory, processorListener, null);\n+    this(config, customMetricsReporters, asyncStreamTaskFactory, processorListener, null);\n   }\n \n   /**\n@@ -110,7 +110,7 @@ public StreamProcessor(Config config, Map<String, MetricsReporter> customMetrics\n    */\n   public StreamProcessor(Config config, Map<String, MetricsReporter> customMetricsReporters,\n                          StreamTaskFactory streamTaskFactory, StreamProcessorLifecycleListener processorListener) {\n-    this(config, customMetricsReporters, (Object) streamTaskFactory, processorListener, null);\n+    this(config, customMetricsReporters, streamTaskFactory, processorListener, null);\n   }\n \n   /* package private */\n@@ -134,8 +134,9 @@ JobCoordinator getCurrentJobCoordinator() {\n     this.jobCoordinator = (jobCoordinator != null) ? jobCoordinator : getJobCoordinator();\n     this.jobCoordinatorListener = createJobCoordinatorListener();\n     this.jobCoordinator.setListener(jobCoordinatorListener);\n-\n-    processorId = this.jobCoordinator.getProcessorId();\n+    ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(CONTAINER_THREAD_NAME_FORMAT).setDaemon(true).build();\n+    this.executorService = Executors.newSingleThreadExecutor(threadFactory);\n+    this.processorId = this.jobCoordinator.getProcessorId();\n   }\n \n   /**\n@@ -175,124 +176,81 @@ public void start() {\n    * If container is not running, then this method will simply shutdown the {@link JobCoordinator}.\n    *\n    */\n-  public synchronized void stop() {\n-    boolean containerShutdownInvoked = false;\n-    if (container != null) {\n-      try {\n-        LOGGER.info(\"Shutting down the container: {} of stream processor: {}.\", container, processorId);\n-        container.shutdown();\n-        LOGGER.info(\"Waiting {} milliseconds for the container: {} to shutdown.\", taskShutdownMs, container);\n-        containerShutdownInvoked = true;\n-      } catch (Exception exception) {\n-        LOGGER.error(String.format(\"Ignoring the exception during the shutdown of container: %s.\", container), exception);\n+  public void stop() {\n+    synchronized (lock) {\n+      boolean containerShutdownInvoked = false;\n+      if (container != null) {\n+        try {\n+          LOGGER.info(\"Shutting down the container: {} of stream processor: {}.\", container, processorId);\n+          container.shutdown();\n+          containerShutdownInvoked = true;\n+        } catch (Exception exception) {\n+          LOGGER.error(String.format(\"Ignoring the exception during the shutdown of container: %s.\", container), exception);\n+        }\n       }\n-    }\n \n-    if (!containerShutdownInvoked) {\n-      LOGGER.info(\"Shutting down JobCoordinator from StreamProcessor\");\n-      jobCoordinator.stop();\n+      if (!containerShutdownInvoked) {\n+        LOGGER.info(\"Shutting down JobCoordinator from StreamProcessor\");\n+        jobCoordinator.stop();\n+      }\n     }\n   }\n \n   SamzaContainer createSamzaContainer(String processorId, JobModel jobModel) {\n-    return SamzaContainer.apply(\n-        processorId,\n-        jobModel,\n-        config,\n-        ScalaJavaUtil.toScalaMap(customMetricsReporter),\n-        taskFactory);\n+    return SamzaContainer.apply(processorId, jobModel, config, ScalaJavaUtil.toScalaMap(customMetricsReporter), taskFactory);\n   }\n \n   JobCoordinatorListener createJobCoordinatorListener() {\n     return new JobCoordinatorListener() {\n \n       @Override\n       public void onJobModelExpired() {\n-        if (container != null) {\n-          SamzaContainerStatus status = container.getStatus();\n-          if (SamzaContainerStatus.NOT_STARTED.equals(status) || SamzaContainerStatus.STARTED.equals(status)) {\n-            boolean shutdownComplete = false;\n-            try {\n-              LOGGER.info(\"Job model expired. Shutting down the container: {} of stream processor: {}.\", container, processorId);\n-              container.pause();\n-              shutdownComplete = jcContainerShutdownLatch.await(taskShutdownMs, TimeUnit.MILLISECONDS);\n-              LOGGER.info(String.format(\"Shutdown status of container: %s for stream processor: %s is: %s.\", container, processorId, shutdownComplete));\n-            } catch (IllegalContainerStateException icse) {\n-              // Ignored since container is not running\n-              LOGGER.info(String.format(\"Cannot shutdown container: %s for stream processor: %s. Container is not running.\", container, processorId), icse);\n-              shutdownComplete = true;\n-            } catch (InterruptedException e) {\n-              Thread.currentThread().interrupt();\n-              LOGGER.warn(String.format(\"Shutdown of container: %s for stream processor: %s was interrupted\", container, processorId), e);\n-            }\n-            if (!shutdownComplete) {\n-              LOGGER.warn(\"Container: {} shutdown was unsuccessful. Stopping the stream processor: {}.\", container, processorId);\n-              container = null;\n-              stop();\n+        synchronized (lock) {\n+          if (container != null) {\n+            SamzaContainerStatus status = container.getStatus();\n+            if (SamzaContainerStatus.NOT_STARTED.equals(status) || SamzaContainerStatus.STARTED.equals(status)) {\n+              boolean shutdownComplete = false;\n+              try {\n+                LOGGER.info(\"Job model expired. Shutting down the container: {} of stream processor: {}.\", container,\n+                    processorId);\n+                container.pause();\n+                shutdownComplete = jcContainerShutdownLatch.await(taskShutdownMs, TimeUnit.MILLISECONDS);\n+                LOGGER.info(String.format(\"Shutdown status of container: %s for stream processor: %s is: %s.\", container, processorId, shutdownComplete));\n+              } catch (IllegalContainerStateException icse) {\n+                // Ignored since container is not running\n+                LOGGER.info(String.format(\"Cannot shutdown container: %s for stream processor: %s. Container is not running.\", container, processorId), icse);\n+                shutdownComplete = true;\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                LOGGER.warn(String.format(\"Shutdown of container: %s for stream processor: %s was interrupted\", container, processorId), e);\n+              } catch (Exception e) {\n+                LOGGER.error(\"Exception occurred when shutting down the container: {}.\", container, e);\n+              }\n+              if (!shutdownComplete) {\n+                LOGGER.warn(\"Container: {} shutdown was unsuccessful. Stopping the stream processor: {}.\", container, processorId);\n+                container = null;\n+                stop();\n+              } else {\n+                LOGGER.info(\"Container: {} shutdown completed for stream processor: {}.\", container, processorId);\n+              }\n             } else {\n-              LOGGER.info(\"Container: {} shutdown completed for stream processor: {}.\", container, processorId);\n+              LOGGER.info(\"Container: {} of the stream processor: {} is not running.\", container, processorId);\n             }\n           } else {\n-            LOGGER.info(\"Container: {} of the stream processor: {} is not running.\", container, processorId);\n+            LOGGER.info(\"Container is not instantiated for stream processor: {}.\", processorId);\n           }\n-        } else {\n-          LOGGER.info(\"Container is not instantiated for stream processor: {}.\", processorId);\n         }\n       }\n \n       @Override\n       public void onNewJobModel(String processorId, JobModel jobModel) {\n-        jcContainerShutdownLatch = new CountDownLatch(1);\n-\n-        SamzaContainerListener containerListener = new SamzaContainerListener() {\n-          @Override\n-          public void onContainerStart() {\n-            if (!processorOnStartCalled) {\n-              // processorListener is called on start only the first time the container starts.\n-              // It is not called after every re-balance of partitions among the processors\n-              processorOnStartCalled = true;\n-              if (processorListener != null) {\n-                processorListener.onStart();\n-              }\n-            } else {\n-              LOGGER.warn(\"Received duplicate container start notification for container: {} in stream processor: {}.\", container, processorId);\n-            }\n-          }\n-\n-          @Override\n-          public void onContainerStop(boolean pauseByJm) {\n-            if (pauseByJm) {\n-              LOGGER.info(\"Container: {} of the stream processor: {} was stopped by the JobCoordinator.\", container, processorId);\n-              if (jcContainerShutdownLatch != null) {\n-                jcContainerShutdownLatch.countDown();\n-              }\n-            } else {  // sp.stop was called or container stopped by itself\n-              LOGGER.info(\"Container: {} stopped. Stopping the stream processor: {}.\", container, processorId);\n-              container = null; // this guarantees that stop() doesn't try to stop container again\n-              stop();\n-            }\n-          }\n-\n-          @Override\n-          public void onContainerFailed(Throwable t) {\n-            if (jcContainerShutdownLatch != null) {\n-              jcContainerShutdownLatch.countDown();\n-            } else {\n-              LOGGER.warn(\"JobCoordinatorLatch was null. It is possible for some component to be waiting.\");\n-            }\n-            containerException = t;\n-            LOGGER.error(String.format(\"Container: %s failed with an exception. Stopping the stream processor: %s. Original exception:\", container, processorId), containerException);\n-            container = null;\n-            stop();\n-          }\n-        };\n-\n-        container = createSamzaContainer(processorId, jobModel);\n-        container.setContainerListener(containerListener);\n-        LOGGER.info(\"Starting the container: {} for the stream processor: {}.\", container, processorId);\n-        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(CONTAINER_THREAD_NAME_FORMAT).build();\n-        executorService = Executors.newSingleThreadExecutor(threadFactory);\n-        executorService.submit(container::run);\n+        synchronized (lock) {\n+          jcContainerShutdownLatch = new CountDownLatch(1);\n+          container = createSamzaContainer(processorId, jobModel);\n+          container.setContainerListener(new ContainerListener());\n+          LOGGER.info(\"Starting the container: {} for the stream processor: {}.\", container, processorId);\n+          executorService.submit(container::run);\n+        }\n       }\n \n       @Override\n@@ -324,4 +282,52 @@ public void onCoordinatorFailure(Throwable throwable) {\n   SamzaContainer getContainer() {\n     return container;\n   }\n+\n+  class ContainerListener implements SamzaContainerListener {\n+\n+    @Override\n+    public void onContainerStart() {\n+      if (!processorOnStartCalled) {\n+        // processorListener is called on start only the first time the container starts.\n+        // It is not called after every re-balance of partitions among the processors\n+        processorOnStartCalled = true;\n+        if (processorListener != null) {\n+          processorListener.onStart();\n+        }\n+      } else {\n+        LOGGER.warn(\"Received duplicate container start notification for container: {} in stream processor: {}.\", container, processorId);\n+      }\n+    }\n+\n+    @Override\n+    public void onContainerStop(boolean pauseByJm) {\n+      if (pauseByJm) {\n+        LOGGER.info(\"Container: {} of the stream processor: {} was stopped by the JobCoordinator.\", container, processorId);\n+        if (jcContainerShutdownLatch != null) {\n+          jcContainerShutdownLatch.countDown();\n+        }\n+      } else {  // sp.stop was called or container stopped by itself\n+        LOGGER.info(\"Container: {} stopped. Stopping the stream processor: {}.\", container, processorId);\n+        synchronized (lock) {\n+          container = null; // this guarantees that stop() doesn't try to stop container again\n+          stop();\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void onContainerFailed(Throwable t) {\n+      if (jcContainerShutdownLatch != null) {\n+        jcContainerShutdownLatch.countDown();\n+      } else {\n+        LOGGER.warn(\"JobCoordinatorLatch was null. It is possible for some component to be waiting.\");\n+      }\n+      synchronized (lock) {\n+        containerException = t;\n+        LOGGER.error(String.format(\"Container: %s failed with an exception. Stopping the stream processor: %s. Original exception:\", container, processorId), containerException);\n+        container = null;\n+        stop();\n+      }\n+    }\n+  }\n }",
                "raw_url": "https://github.com/apache/samza/raw/02153fa506e38b2e7f01c0374089e200bfe1e363/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java",
                "sha": "73f32e77fcb08f661be12d050265b400cf2f2968",
                "status": "modified"
            },
            {
                "additions": 41,
                "blob_url": "https://github.com/apache/samza/blob/02153fa506e38b2e7f01c0374089e200bfe1e363/samza-core/src/main/java/org/apache/samza/zk/ZkJobCoordinator.java",
                "changes": 84,
                "contents_url": "https://api.github.com/repos/apache/samza/contents/samza-core/src/main/java/org/apache/samza/zk/ZkJobCoordinator.java?ref=02153fa506e38b2e7f01c0374089e200bfe1e363",
                "deletions": 43,
                "filename": "samza-core/src/main/java/org/apache/samza/zk/ZkJobCoordinator.java",
                "patch": "@@ -26,6 +26,7 @@\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import org.I0Itec.zkclient.IZkStateListener;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.samza.checkpoint.CheckpointManager;\n@@ -58,8 +59,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.zookeeper.Watcher.Event.KeeperState.*;\n-\n /**\n  * JobCoordinator for stand alone processor managed via Zookeeper.\n  */\n@@ -92,19 +91,19 @@\n   private final ZkJobCoordinatorMetrics metrics;\n   private final Map<String, MetricsReporter> reporters;\n   private final ZkLeaderElector leaderElector;\n+  private final AtomicBoolean initiatedShutdown = new AtomicBoolean(false);\n+  private final StreamMetadataCache streamMetadataCache;\n+  private final SystemAdmins systemAdmins;\n+  private final int debounceTimeMs;\n+  private final Map<TaskName, Integer> changeLogPartitionMap = new HashMap<>();\n \n-  private StreamMetadataCache streamMetadataCache = null;\n-  private SystemAdmins systemAdmins = null;\n-\n-  @VisibleForTesting\n-  ScheduleAfterDebounceTime debounceTimer = null;\n   private JobCoordinatorListener coordinatorListener = null;\n   private JobModel newJobModel;\n-  private int debounceTimeMs;\n   private boolean hasCreatedStreams = false;\n-  private boolean initiatedShutdown = false;\n   private String cachedJobModelVersion = null;\n-  private Map<TaskName, Integer> changeLogPartitionMap = new HashMap<>();\n+\n+  @VisibleForTesting\n+  ScheduleAfterDebounceTime debounceTimer;\n \n   ZkJobCoordinator(Config config, MetricsRegistry metricsRegistry, ZkUtils zkUtils) {\n     this.config = config;\n@@ -142,50 +141,49 @@ public void start() {\n   }\n \n   @Override\n-  public synchronized void stop() {\n+  public void stop() {\n     // Make the shutdown idempotent\n-    if (initiatedShutdown) {\n-      LOG.debug(\"Job Coordinator shutdown is already in progress!\");\n-      return;\n-    }\n+    if (initiatedShutdown.compareAndSet(false, true)) {\n \n-    LOG.info(\"Shutting down Job Coordinator...\");\n-    initiatedShutdown = true;\n-    boolean shutdownSuccessful = false;\n+      LOG.info(\"Shutting down JobCoordinator.\");\n+      boolean shutdownSuccessful = false;\n \n-    // Notify the metrics about abandoning the leadership. Moving it up the chain in the shutdown sequence so that\n-    // in case of unclean shutdown, we get notified about lack of leader and we can set up some alerts around the absence of leader.\n-    metrics.isLeader.set(false);\n+      // Notify the metrics about abandoning the leadership. Moving it up the chain in the shutdown sequence so that\n+      // in case of unclean shutdown, we get notified about lack of leader and we can set up some alerts around the absence of leader.\n+      metrics.isLeader.set(false);\n \n-    try {\n-      // todo: what does it mean for coordinator listener to be null? why not have it part of constructor?\n-      if (coordinatorListener != null) {\n-        coordinatorListener.onJobModelExpired();\n-      }\n+      try {\n+        // todo: what does it mean for coordinator listener to be null? why not have it part of constructor?\n+        if (coordinatorListener != null) {\n+          coordinatorListener.onJobModelExpired();\n+        }\n \n-      debounceTimer.stopScheduler();\n+        debounceTimer.stopScheduler();\n \n-      LOG.debug(\"Shutting down ZkController.\");\n-      zkController.stop();\n+        LOG.debug(\"Shutting down ZkController.\");\n+        zkController.stop();\n \n-      LOG.debug(\"Shutting down system admins.\");\n-      systemAdmins.stop();\n+        LOG.debug(\"Shutting down system admins.\");\n+        systemAdmins.stop();\n \n-      LOG.debug(\"Shutting down metrics.\");\n-      shutdownMetrics();\n+        LOG.debug(\"Shutting down metrics.\");\n+        shutdownMetrics();\n \n-      if (coordinatorListener != null) {\n-        coordinatorListener.onCoordinatorStop();\n-      }\n+        if (coordinatorListener != null) {\n+          coordinatorListener.onCoordinatorStop();\n+        }\n \n-      shutdownSuccessful = true;\n-    } catch (Throwable t) {\n-      LOG.error(\"Encountered errors during job coordinator stop.\", t);\n-      if (coordinatorListener != null) {\n-        coordinatorListener.onCoordinatorFailure(t);\n+        shutdownSuccessful = true;\n+      } catch (Throwable t) {\n+        LOG.error(\"Encountered errors during job coordinator stop.\", t);\n+        if (coordinatorListener != null) {\n+          coordinatorListener.onCoordinatorFailure(t);\n+        }\n+      } finally {\n+        LOG.info(\"Job Coordinator shutdown finished with ShutdownComplete=\" + shutdownSuccessful);\n       }\n-    } finally {\n-      LOG.info(\"Job Coordinator shutdown finished with ShutdownComplete=\" + shutdownSuccessful);\n+    } else {\n+      LOG.info(\"Job Coordinator shutdown is in progress!\");\n     }\n   }\n ",
                "raw_url": "https://github.com/apache/samza/raw/02153fa506e38b2e7f01c0374089e200bfe1e363/samza-core/src/main/java/org/apache/samza/zk/ZkJobCoordinator.java",
                "sha": "74abf556593fc14c152f732145c093c40bf9858e",
                "status": "modified"
            }
        ],
        "message": "SAMZA-1647: Fix NPE in onJobModelExpired handler in StreamProcessor.\n\n**Changes:**\n* Switching to using explicit lock in StreamProcessor to make things simpler on state updation.\n* Switch from using synchronized in ZkJobCoordinator to prevent any potential deadlocks\nbetween two threads (where one thread holds the StreamProcessor and other thread has ZkJobCoordinator lock).\n* Misc cleanups in StreamProcessor: Remove volatile qualifiers from state variables in StreamProcessor. Remove reinstantiating the\nexecutorService in onNewJobModel.\n* ZkJobCoordinator cleanups: Make some state variables as immutable.\n\n**NOTE**: The classes in which these changes were made were aynonymous inner classes,\nso to add proper unit tests we need to do big haul of refactor.\n\nAuthor: Shanthoosh Venkataraman <santhoshvenkat1988@gmail.com>\n\nReviewers: Jagadish <jagadish@apache.org>\n\nCloses #493 from shanthoosh/fix_npe_in_jobmodel_expired_handler",
        "parent": "https://github.com/apache/samza/commit/72ad7523fffdcafdc01a0c6922fc94ccd1e482a5",
        "repo": "samza",
        "unit_tests": [
            "TestZkJobCoordinator.java"
        ]
    },
    "samza_2e461a8": {
        "bug_id": "samza_2e461a8",
        "commit": "https://github.com/apache/samza/commit/2e461a8804ec568ff52de2d6e81a8edd4865ce12",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/samza/blob/2e461a8804ec568ff52de2d6e81a8edd4865ce12/samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/samza/contents/samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java?ref=2e461a8804ec568ff52de2d6e81a8edd4865ce12",
                "deletions": 1,
                "filename": "samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java",
                "patch": "@@ -712,7 +712,7 @@ private String getFormattedCommand(String logDirExpansionVar,\n   private String getPendingSamzaContainerId(ContainerId containerId) {\n     for (String samzaContainerId: state.pendingYarnContainers.keySet()) {\n       YarnContainer yarnContainer = state.pendingYarnContainers.get(samzaContainerId);\n-      if (yarnContainer.id().equals(containerId)) {\n+      if (yarnContainer != null && yarnContainer.id().equals(containerId)) {\n         return samzaContainerId;\n       }\n     }",
                "raw_url": "https://github.com/apache/samza/raw/2e461a8804ec568ff52de2d6e81a8edd4865ce12/samza-yarn/src/main/java/org/apache/samza/job/yarn/YarnClusterResourceManager.java",
                "sha": "79a9083987b6f3836d63f5f951369f1c94791801",
                "status": "modified"
            }
        ],
        "message": "SAMZA-1699: Fix NPE in ClusterResourceManager\n\nWhen the ClusterResourcedManager receives a notification that a container is started, it moves the container from the \"pending queue\" to its \"running queue\".\nIn the meanwhile, it's possible for another thread to remove the mapping for the key. Here's an example:\n\nNMCallbackThread-1:```\npendingYarnContainers.remove(key);```\n\nNMCallbackThread-2:\n```\nfor (String key : pendingYarnContainers.keySet()) {\n  yarnContainer = pendingYarnContainers.get(key); <-- could be null depending on whether the removal happened before it.\n}```\n\nAuthor: Jagadish <jvenkatraman@linkedin.com>\n\nReviewers: Prateek M<pmaheshw@linkedin.com>\n\nCloses #504 from vjagadish/npe-fix-async",
        "parent": "https://github.com/apache/samza/commit/51729ac6836f5baa522d7ba6a7308504ba027c5f",
        "repo": "samza",
        "unit_tests": [
            "TestYarnClusterResourceManager.java"
        ]
    }
}