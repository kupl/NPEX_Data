{
    "commons-jcs_6043126": {
        "bug_id": "commons-jcs_6043126",
        "commit": "https://github.com/apache/commons-jcs/commit/60431261912586b5fe0cc5c8b4206e711cb0639a",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/commons-jcs/blob/60431261912586b5fe0cc5c8b4206e711cb0639a/commons-jcs-core/src/test/java/org/apache/commons/jcs/auxiliary/remote/server/BasicRemoteCacheClientServerUnitTest.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/commons-jcs/contents/commons-jcs-core/src/test/java/org/apache/commons/jcs/auxiliary/remote/server/BasicRemoteCacheClientServerUnitTest.java?ref=60431261912586b5fe0cc5c8b4206e711cb0639a",
                "deletions": 1,
                "filename": "commons-jcs-core/src/test/java/org/apache/commons/jcs/auxiliary/remote/server/BasicRemoteCacheClientServerUnitTest.java",
                "patch": "@@ -100,7 +100,9 @@ public static void setup()\n     @AfterClass\n     public static void stop() throws IOException\n     {\n-        server.shutdown(\"localhost\", remotePort);\n+        if (server != null) { // in case setup failed, no point throwing NPE as well\n+            server.shutdown(\"localhost\", remotePort);\n+        }\n     }\n \n     /**",
                "raw_url": "https://github.com/apache/commons-jcs/raw/60431261912586b5fe0cc5c8b4206e711cb0639a/commons-jcs-core/src/test/java/org/apache/commons/jcs/auxiliary/remote/server/BasicRemoteCacheClientServerUnitTest.java",
                "sha": "fb32167c8845517fcbe65799927c798442b9af03",
                "status": "modified"
            }
        ],
        "message": " in case setup failed, no point throwing NPE as well\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/jcs/trunk@1606538 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/commons-jcs/commit/cf5e503db4274fd2c060571c982a0fba8b00c09c",
        "patched_files": [],
        "repo": "commons-jcs",
        "unit_tests": [
            "BasicRemoteCacheClientServerUnitTest.java"
        ]
    },
    "commons-jcs_d968b59": {
        "bug_id": "commons-jcs_d968b59",
        "commit": "https://github.com/apache/commons-jcs/commit/d968b59c22aeeadb4e5a12eb68b83acd2232ba2c",
        "file": [
            {
                "additions": 182,
                "blob_url": "https://github.com/apache/commons-jcs/blob/d968b59c22aeeadb4e5a12eb68b83acd2232ba2c/src/java/org/apache/jcs/engine/memory/lru/LRUMemoryCache.java",
                "changes": 196,
                "contents_url": "https://api.github.com/repos/apache/commons-jcs/contents/src/java/org/apache/jcs/engine/memory/lru/LRUMemoryCache.java?ref=d968b59c22aeeadb4e5a12eb68b83acd2232ba2c",
                "deletions": 14,
                "filename": "src/java/org/apache/jcs/engine/memory/lru/LRUMemoryCache.java",
                "patch": "@@ -72,7 +72,7 @@ public void update( ICacheElement ce )\n         ce.getElementAttributes().setLastAccessTimeNow();\n         addFirst( ce );\n         MemoryElementDescriptor old =\n-            ( MemoryElementDescriptor ) map.put( ce.getKey(), first );\n+            ( MemoryElementDescriptor ) map.put( first.ce.getKey(), first );\n \n         // If the node was the same as an existing node, remove it.\n \n@@ -107,27 +107,72 @@ public void update( ICacheElement ce )\n             // need to pre-queue the queuing.  This would be a bit wasteful\n             // and wouldn't save much time in this synchronous call.\n \n-            MemoryElementDescriptor node;\n-\n             for ( int i = 0; i < chunkSizeCorrected; i++ )\n             {\n                 synchronized ( this )\n                 {\n-                    cache.spoolToDisk( last.ce );\n-\n-                    map.remove( last.ce.getKey() );\n-\n-                    removeNode( last );\n+                    if ( last != null ) \n+                    {\n+                        if ( last.ce != null )\n+                        {\n+                            cache.spoolToDisk( last.ce );\n+                            if ( !map.containsKey(last.ce.getKey()) )\n+                            {\n+                                log.error(\"update: map does not contain key: \" + last.ce.getKey());\n+                                verifyCache();\n+                            }\n+                            if ( map.remove(last.ce.getKey()) == null )\n+                            {\n+                                log.warn(\"update: remove failed for key: \" + last.ce.getKey() );\n+                                verifyCache();\n+                            }\n+                        }\n+                        else\n+                        {\n+                            throw new Error(\"update: last.ce is null!\");\n+                        }\n+                        removeNode( last );\n+                    } \n+                    else \n+                    {\n+                        verifyCache();\n+                        throw new Error(\"update: last is null!\");\n+                    }\n                 }\n             }\n \n             if ( log.isDebugEnabled() )\n             {\n-                log.debug( \"After spool map size: \" + size );\n+                log.debug(\"update: After spool map size: \" + map.size());\n+            }\n+            if ( map.size() != dumpCacheSize() )\n+            {\n+                log.error(\"update: After spool, size mismatch: map.size() = \"\n+                          + map.size() + \", linked list size = \" +\n+                          dumpCacheSize());\n             }\n         }\n     }\n \n+    /**\n+     * Remove all of the elements from both the Map and the linked\n+     * list implementation. Overrides base class.\n+     */ \n+    public synchronized void removeAll()\n+        throws IOException\n+    {\n+        map.clear();\n+        for ( MemoryElementDescriptor me = first; me != null; ) \n+        {\n+            if ( me.prev != null )\n+            {\n+                me.prev = null;\n+            }\n+            MemoryElementDescriptor next = me.next;\n+            me = next;\n+        }\n+        first = last = null;\n+    }\n \n     /**\n      *  Get an item from the cache without affecting its last access time or\n@@ -168,14 +213,15 @@ else if ( log.isDebugEnabled() )\n      *@return                  ICacheElement if found, else null\n      *@exception  IOException\n      */\n-    public ICacheElement get( Serializable key )\n+    public synchronized ICacheElement get( Serializable key )\n         throws IOException\n     {\n         ICacheElement ce = null;\n \n         if ( log.isDebugEnabled() )\n         {\n-            log.debug( \"getting item for key: \" + key );\n+            log.debug( \"getting item from cache \" + cacheName + \" for key \" +\n+                       key );\n         }\n \n         MemoryElementDescriptor me = (MemoryElementDescriptor)map.get(key);\n@@ -197,6 +243,7 @@ public ICacheElement get( Serializable key )\n             log.debug( cacheName + \": LRUMemoryCache miss for \" + key );\n         }\n         \n+        verifyCache();\n         return ce;\n     }\n \n@@ -210,7 +257,7 @@ public ICacheElement get( Serializable key )\n      *@return\n      *@exception  IOException\n      */\n-    public boolean remove( Serializable key )\n+    public synchronized boolean remove( Serializable key )\n         throws IOException\n     {\n         if ( log.isDebugEnabled() )\n@@ -287,7 +334,9 @@ else if ( key instanceof GroupId )\n     public class IteratorWrapper\n         implements Iterator\n     {\n+        private final Log log = LogFactory.getLog( LRUMemoryCache.class );\n         private final Iterator i;\n+\n         private IteratorWrapper(Map m)\n         {\n             i = m.entrySet().iterator();\n@@ -382,7 +431,8 @@ private synchronized void removeNode( MemoryElementDescriptor me )\n     {\n         if ( log.isDebugEnabled() )\n         {\n-            log.debug( \"removing node \" + me.ce.getKey() );\n+            log.debug( \"removing node \" + me.ce.getKey() + \" from cache \" +\n+                       cacheName );\n         }\n \n         if ( me.next == null )\n@@ -443,7 +493,7 @@ private void addLast( CacheElement ce )\n             me.prev = last;\n         }\n         last = me;\n-        return;\n+        verifyCache(ce.getKey());\n     }\n \n     /**\n@@ -539,6 +589,124 @@ public void dumpCacheEntries()\n                  + me.ce.getKey() + \", val=\" + me.ce.getVal() );\n         }\n     }\n+\n+    private int dumpCacheSize() \n+    {\n+        int size = 0;\n+        for ( MemoryElementDescriptor me = first; me != null;  me = me.next )\n+        {\n+            size++;\n+        }\n+        return size; \n+    }\n+\n+    private void verifyCache() \n+    {\n+        if ( !log.isDebugEnabled() ) \n+            return;\n+\n+        boolean found = false;\n+        log.debug(\"verifycache[\" + cacheName + \"]: mapContains \" + map.size() + \" elements, linked list contains \" \n+                  + dumpCacheSize() + \" elements\" );\n+        log.debug(\"verifycache: checking linked list by key \");\n+        for ( MemoryElementDescriptor li = first; li != null; li = li.next ) \n+        {\n+            Object key = li.ce.getKey();\n+            if ( !map.containsKey(key) ) \n+            {\n+                log.error(\"verifycache[\" + cacheName + \"]: map does not contain key : \" + li.ce.getKey());\n+                log.error(\"li.hashcode=\" + li.ce.getKey().hashCode());\n+                log.error(\"key class=\" + key.getClass());\n+                log.error(\"key hashcode=\" + key.hashCode());\n+                log.error(\"key toString=\" + key.toString());\n+                if ( key instanceof GroupAttrName ) \n+                {\n+                    GroupAttrName name = (GroupAttrName) key;\n+                    log.error(\"GroupID hashcode=\" + name.groupId.hashCode());\n+                    log.error(\"GroupID.class=\" + name.groupId.getClass());\n+                    log.error(\"AttrName hashcode=\" + name.attrName.hashCode());\n+                    log.error(\"AttrName.class=\" + name.attrName.getClass());\n+                }\n+                dumpMap();\n+            }\n+            else if ( map.get(li.ce.getKey()) == null ) \n+            {\n+                log.error(\"verifycache[\" + cacheName +\n+                          \"]: linked list retrieval returned null for key: \" +\n+                          li.ce.getKey());\n+            }\n+        }\n+\n+        log.debug(\"verifycache: checking linked list by value \");\n+        for ( MemoryElementDescriptor li3 = first; li3 != null; li3 = li3.next ) \n+        {\n+            if ( map.containsValue(li3) == false ) \n+            {\n+                log.error(\"verifycache[\" + cacheName + \"]: map does not contain value : \" + li3);\n+                dumpMap();\n+            } \n+        }\n+\n+        log.debug(\"verifycache: checking via keysets!\");\n+        for ( Iterator itr2 = map.keySet().iterator(); itr2.hasNext(); )\n+        {\n+            found = false;\n+            Serializable val = null;\n+            try\n+            {\n+                val = (Serializable) itr2.next();\n+            }\n+            catch ( NoSuchElementException nse )\n+            {\n+                log.error(\"verifycache: no such element exception\");\n+            }                \n+\n+            for ( MemoryElementDescriptor li2 = first; li2 != null; li2 = li2.next ) \n+            {\n+                if ( val.equals(li2.ce.getKey()) )\n+                {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if ( !found ) \n+            {\n+                log.error(\"verifycache[\" + cacheName + \"]: key not found in list : \" + val );\n+                dumpCacheEntries();\n+                if ( map.containsKey(val) ) \n+                {\n+                    log.error(\"verifycache: map contains key\");\n+                }\n+                else \n+                {\n+                    log.error(\"verifycache: map does NOT contain key, what the HECK!\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private void verifyCache(Serializable key) \n+    {\n+        if ( !log.isDebugEnabled() ) \n+            return;\n+\n+        boolean found = false;\n+\n+        // go through the linked list looking for the key\n+        for ( MemoryElementDescriptor li = first; li != null; li = li.next ) \n+        {\n+            if ( li.ce.getKey() == key ) \n+            {\n+                found = true;\n+                log.debug(\"verifycache(key) key match: \" + key );\n+                break;\n+            }\n+        }\n+        if ( !found ) \n+        {\n+            log.error(\"verifycache(key)[\" + cacheName + \"], couldn't find key! : \" + key );\n+        }\n+    }\n }\n \n /**",
                "raw_url": "https://github.com/apache/commons-jcs/raw/d968b59c22aeeadb4e5a12eb68b83acd2232ba2c/src/java/org/apache/jcs/engine/memory/lru/LRUMemoryCache.java",
                "sha": "9c3432c9b60f56c026445e2984d5a62e0abafa5d",
                "status": "modified"
            }
        ],
        "message": "* src/java/org/apache/jcs/engine/memory/lru/LRUMemoryCache.java\n  update(): Clarified map.put() operation to be a bit clearer.\n            Removed reference to unused MemoryElementDescriptor object.\n            Added null checks to last and last.ce to avoid NPEs\n            when underlying objects have bugs in their .equals() and\n            .hashCode() implementations.\n            Added debugging messages when items from underlying map\n            cannot be found or removed when a full cache is being purged.\n            Adding more debugging messages after method is complete\n            to verify integrity of the cache.\n\n\n  removeAll(): Added implementation that overrides base class. This fixes\n               issue where underlying map was being reallocated but the\n               linked list still contained data.\n\n  get(): Synchronizing method to prevent possible issues.\n         Adding debug code to verify cache after method completion.\n\n\n  removeNode(): Adding debug code to display cache name in output.\n\n  addLast(): Removing unnecessary return statement.\n             Adding debug code to verify cache after method completion.\n\n  dumpCacheSize(): Adding method to compute number of elements in the\n                   linked list.\n\n  verifyCache(): Adding method to verify the integrity of the cache. This\n                 is done three ways; first by walking the linked list\n                 and verifying that they keys exist in the map, secondly\n                 by walking the list and verifying that the values exist\n                 in the map, and lastly by walking the map and verifying\n                 that the keys exist in the linked list. None of this\n                 verification is done if the Log level is not turned up\n                 to 'DEBUG' level.\n\n  verifyCache(key): Adding method to ensure that an individual key exists\n                    in both the linked list and the map.\n\nSubmitted by: Todd Enersen <tenersen@collab.net>\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/jcs/trunk@224036 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/commons-jcs/commit/88ca20dfa787810cfed8a32f811be7a42bbdd8bd",
        "patched_files": [
            "LRUMemoryCache.java"
        ],
        "repo": "commons-jcs",
        "unit_tests": [
            "TestLRUMemoryCache.java"
        ]
    }
}