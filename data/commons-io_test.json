{
    "commons-io_9afc296": {
        "repo": "commons-io",
        "message": "Silence impossible \"possible NPE\" warning\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1471788 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/commons-io/commit/9afc2969a3b491476525e100a8a542027576952e",
        "parent": "https://github.com/apache/commons-io/commit/586d223e8049873dfa350e5f575e3c03e714dbcf",
        "bug_id": "commons-io_9afc296",
        "file": [
            {
                "sha": "98f4f920e7b76f5eaf310644bc0e6404b1eb10c8",
                "filename": "src/main/java/org/apache/commons/io/input/XmlStreamReader.java",
                "blob_url": "https://github.com/apache/commons-io/blob/9afc2969a3b491476525e100a8a542027576952e/src/main/java/org/apache/commons/io/input/XmlStreamReader.java",
                "raw_url": "https://github.com/apache/commons-io/raw/9afc2969a3b491476525e100a8a542027576952e/src/main/java/org/apache/commons/io/input/XmlStreamReader.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/input/XmlStreamReader.java?ref=9afc2969a3b491476525e100a8a542027576952e",
                "patch": "@@ -711,7 +711,7 @@ private static String getXmlProlog(final InputStream is, final String guessedEnc\n             int max = BUFFER_SIZE;\n             int c = is.read(bytes, offset, max);\n             int firstGT = -1;\n-            String xmlProlog = null;\n+            String xmlProlog = \"\"; // avoid possible NPE warning (cannot happen; this just silences the warning)\n             while (c != -1 && firstGT == -1 && offset < BUFFER_SIZE) {\n                 offset += c;\n                 max -= c;",
                "deletions": 1
            },
            {
                "sha": "4e93effeb0fb74c4245dd00e56d080cda66b417a",
                "filename": "src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java",
                "blob_url": "https://github.com/apache/commons-io/blob/9afc2969a3b491476525e100a8a542027576952e/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java",
                "raw_url": "https://github.com/apache/commons-io/raw/9afc2969a3b491476525e100a8a542027576952e/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java?ref=9afc2969a3b491476525e100a8a542027576952e",
                "patch": "@@ -669,7 +669,7 @@ private static String getXmlProlog(final BufferedInputStream is, final String gu\n             int max = BUFFER_SIZE;\n             int c = is.read(bytes, offset, max);\n             int firstGT = -1;\n-            String xmlProlog = null;\n+            String xmlProlog = \"\"; // avoid possible NPE warning (cannot happen; this just silences the warning)\n             while (c != -1 && firstGT == -1 && offset < BUFFER_SIZE) {\n                 offset += c;\n                 max -= c;",
                "deletions": 1
            }
        ],
        "patched_files": [
            "XmlStreamReader.java"
        ],
        "unit_tests": [
            "XmlStreamReaderTest.java"
        ]
    },
    "commons-io_a32a395": {
        "repo": "commons-io",
        "message": "Add test for and fix NPE if thread stopped with no file found\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002918 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/commons-io/commit/a32a395a621098ce652ee8158e6320fa422f9fa3",
        "parent": "https://github.com/apache/commons-io/commit/a360f974003c5c60c16d019e873314c09d965107",
        "bug_id": "commons-io_a32a395",
        "file": [
            {
                "sha": "a8d36b3449514ae42da49c0f0838b112c6fddd37",
                "filename": "src/java/org/apache/commons/io/input/Tailer.java",
                "blob_url": "https://github.com/apache/commons-io/blob/a32a395a621098ce652ee8158e6320fa422f9fa3/src/java/org/apache/commons/io/input/Tailer.java",
                "raw_url": "https://github.com/apache/commons-io/raw/a32a395a621098ce652ee8158e6320fa422f9fa3/src/java/org/apache/commons/io/input/Tailer.java",
                "status": "modified",
                "changes": 9,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/java/org/apache/commons/io/input/Tailer.java?ref=a32a395a621098ce652ee8158e6320fa422f9fa3",
                "patch": "@@ -148,13 +148,14 @@ public void run() {\n \n                 if (reader == null) {\n                     Thread.sleep(delay);\n+                } else {\n+                    // The current position in the file\n+                    position = end ? file.length() : 0;\n+                    last = System.currentTimeMillis();\n+                    reader.seek(position);                    \n                 }\n             }\n \n-            // The current position in the file\n-            position = end ? file.length() : 0;\n-            last = System.currentTimeMillis();\n-            reader.seek(position);\n \n             while (run) {\n ",
                "deletions": 4
            },
            {
                "sha": "1d69a98794b4d18441c50bf611283510512df5d4",
                "filename": "src/test/org/apache/commons/io/input/TailerTest.java",
                "blob_url": "https://github.com/apache/commons-io/blob/a32a395a621098ce652ee8158e6320fa422f9fa3/src/test/org/apache/commons/io/input/TailerTest.java",
                "raw_url": "https://github.com/apache/commons-io/raw/a32a395a621098ce652ee8158e6320fa422f9fa3/src/test/org/apache/commons/io/input/TailerTest.java",
                "status": "modified",
                "changes": 20,
                "additions": 20,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/test/org/apache/commons/io/input/TailerTest.java?ref=a32a395a621098ce652ee8158e6320fa422f9fa3",
                "patch": "@@ -110,13 +110,29 @@ private void write(File file, String... lines) throws Exception {\n         }\n     }\n \n+    public void testStopWithNoFile() throws Exception {\n+        File file = new File(getTestDirectory(),\"nosuchfile\");\n+        assertFalse(\"nosuchfile should not exist\", file.exists());\n+        TestTailerListener listener = new TestTailerListener();\n+        int delay = 100;\n+        int idle = 50; // allow time for thread to work\n+        Tailer tailer = start(file, listener, delay, false);\n+        Thread.sleep(idle);\n+        tailer.stop();\n+        Thread.sleep(delay+idle);\n+        assertNull(listener.exception);\n+    }\n+\n     /**\n      * Test {@link TailerListener} implementation.\n      */\n     private static class TestTailerListener extends TailerListenerAdapter {\n \n         private final List<String> lines = new ArrayList<String>();\n \n+        volatile Exception exception = null;\n+        \n+        @Override\n         public void handle(String line) {\n             lines.add(line);\n         }\n@@ -126,5 +142,9 @@ public void handle(String line) {\n         public void clear() {\n             lines.clear();\n         }\n+        @Override\n+        public void handle(Exception e) {\n+            exception = e;\n+        }\n     }\n }",
                "deletions": 0
            }
        ],
        "patched_files": [
            "Tailer.java"
        ],
        "unit_tests": [
            "TailerTest.java"
        ]
    },
    "commons-io_3545c77": {
        "repo": "commons-io",
        "message": "Fix potential NPE if proxied stream supports write((byte[]) null) without complaining\nAdd test for same\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1003340 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/commons-io/commit/3545c7701ef563309c4cb6dc3a66f68ec61ed980",
        "parent": "https://github.com/apache/commons-io/commit/f9ae38abc1b8c957b7dfdf49b27992204c7b5ae0",
        "bug_id": "commons-io_3545c77",
        "file": [
            {
                "sha": "66c2dbac9130037aca8e700e8e5c5555ab1d1b0b",
                "filename": "src/java/org/apache/commons/io/output/ProxyOutputStream.java",
                "blob_url": "https://github.com/apache/commons-io/blob/3545c7701ef563309c4cb6dc3a66f68ec61ed980/src/java/org/apache/commons/io/output/ProxyOutputStream.java",
                "raw_url": "https://github.com/apache/commons-io/raw/3545c7701ef563309c4cb6dc3a66f68ec61ed980/src/java/org/apache/commons/io/output/ProxyOutputStream.java",
                "status": "modified",
                "changes": 5,
                "additions": 3,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/java/org/apache/commons/io/output/ProxyOutputStream.java?ref=3545c7701ef563309c4cb6dc3a66f68ec61ed980",
                "patch": "@@ -68,9 +68,10 @@ public void write(int idx) throws IOException {\n     @Override\n     public void write(byte[] bts) throws IOException {\n         try {\n-            beforeWrite(bts != null ? bts.length : 0);\n+            int len = bts != null ? bts.length : 0;\n+            beforeWrite(len);\n             out.write(bts);\n-            afterWrite(bts.length);\n+            afterWrite(len);\n         } catch (IOException e) {\n             handleIOException(e);\n         }",
                "deletions": 2
            },
            {
                "sha": "9833d9fd2ffb2f5adcf83fd4187ec2aba21ed7cd",
                "filename": "src/test/org/apache/commons/io/output/ProxyOutputStreamTest.java",
                "blob_url": "https://github.com/apache/commons-io/blob/3545c7701ef563309c4cb6dc3a66f68ec61ed980/src/test/org/apache/commons/io/output/ProxyOutputStreamTest.java",
                "raw_url": "https://github.com/apache/commons-io/raw/3545c7701ef563309c4cb6dc3a66f68ec61ed980/src/test/org/apache/commons/io/output/ProxyOutputStreamTest.java",
                "status": "added",
                "changes": 57,
                "additions": 57,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/test/org/apache/commons/io/output/ProxyOutputStreamTest.java?ref=3545c7701ef563309c4cb6dc3a66f68ec61ed980",
                "patch": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.output;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit Test Case for {@link CloseShieldOutputStream}.\n+ */\n+public class ProxyOutputStreamTest extends TestCase {\n+\n+    private ByteArrayOutputStream original;\n+\n+    private OutputStream proxied;\n+\n+    @Override\n+    protected void setUp() {\n+        original = new ByteArrayOutputStream(){\n+            @Override\n+            public void write(byte[] ba) throws IOException {\n+                if (ba != null){\n+                    super.write(ba);\n+                }\n+            }\n+        };\n+        proxied = new ProxyOutputStream(original);\n+    }\n+\n+    public void testWrite() throws Exception {\n+        proxied.write('y');\n+        assertEquals(1, original.size());\n+        assertEquals('y', original.toByteArray()[0]);\n+    }\n+\n+    public void testWriteNullBaSucceeds() throws Exception {\n+        byte[] ba = null;\n+        original.write(ba);\n+        proxied.write(ba);\n+    }\n+}",
                "deletions": 0
            }
        ],
        "patched_files": [
            "ProxyOutputStream.java"
        ],
        "unit_tests": [
            "ProxyOutputStreamTest.java"
        ]
    },
    "commons-io_f15433d": {
        "repo": "commons-io",
        "message": "Fix broken build (#73)\n\nSeveral things were broken with the build. This fixes build failures and\r\nmakes the build pass again on all Java versions tested on Travis CI.\r\n\r\n1. The test started to fail after the changes made in b5990be. This is\r\n   because after changing the type of writer from Appendable to NullWriter\r\n   the wrong overload of copy would be used:\r\n\r\n    copy(Reader, Writer) instead of copy(Reader, Appendable)\r\n\r\n  This change just forces the right overload at the call site.\r\n\r\n2. Replace tabs with spaces\r\n3. Add missing package-info file\r\n4. Fix NPE during javadoc generation\r\n\r\n  Commons parent 46 shipped with maven-javadoc-plugin 3.0.0 which was\r\n  affected by https://issues.apache.org/jira/browse/MJAVADOC-517.\r\n  This upgrades the build to commons parent 47, which includes\r\n  maven-javadoc-plugin 3.0.1.\r\n\r\n5. Fix invalid javadoc links\r\n6. Fix problem with Javadoc tool reporting import of unnamed modules",
        "commit": "https://github.com/apache/commons-io/commit/f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
        "parent": "https://github.com/apache/commons-io/commit/30f81c47f7ea0e9f743e08e73f48c0cfcfb746ff",
        "bug_id": "commons-io_f15433d",
        "file": [
            {
                "sha": "869112ea0de243f3d98c4107c84cdd8b5ac7ae82",
                "filename": "pom.xml",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/pom.xml",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/pom.xml",
                "status": "modified",
                "changes": 14,
                "additions": 13,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/pom.xml?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -19,7 +19,7 @@\n   <parent>\n     <groupId>org.apache.commons</groupId>\n     <artifactId>commons-parent</artifactId>\n-    <version>46</version>\n+    <version>47</version>\n   </parent>\n   <modelVersion>4.0.0</modelVersion>\n   <groupId>commons-io</groupId>\n@@ -350,6 +350,18 @@ file comparators, endian transformation classes, and much more.\n           </ignorePathsToDelete>\n         </configuration>\n       </plugin>\n+      <!--\n+       Fix for https://bugs.openjdk.java.net/browse/JDK-8212233\n+       which is addressed in maven-javadoc-plugin:3.1.0, see https://issues.apache.org/jira/browse/MJAVADOC-562\n+      -->\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-javadoc-plugin</artifactId>\n+        <version>${commons.javadoc.version}</version>\n+        <configuration>\n+          <source>7</source>\n+        </configuration>\n+      </plugin>\n     </plugins>\n   </build>\n ",
                "deletions": 1
            },
            {
                "sha": "a897c382a74634d4caf2ad302d3e0a32a32ae212",
                "filename": "src/main/java/org/apache/commons/io/DirectoryWalker.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/DirectoryWalker.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/DirectoryWalker.java",
                "status": "modified",
                "changes": 25,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/DirectoryWalker.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -36,16 +36,15 @@\n  * <p>\n  * The following sections describe:\n  *   <ul>\n- *      <li><a href=\"#DirectoryWalker_example\">1. Example Implementation</a> - example\n+ *      <li><a href=\"#example\">1. Example Implementation</a> - example\n  *          <code>FileCleaner</code> implementation.</li>\n- *      <li><a href=\"#DirectoryWalker_filter\">2. Filter Example</a> - using\n+ *      <li><a href=\"#filter\">2. Filter Example</a> - using\n  *          {@link FileFilter}(s) with <code>DirectoryWalker</code>.</li>\n- *      <li><a href=\"#DirectoryWalker_cancel\">3. Cancellation</a> - how to implement cancellation\n+ *      <li><a href=\"#cancel\">3. Cancellation</a> - how to implement cancellation\n  *          behaviour.</li>\n  *   </ul>\n  *\n- * <a id=\"DirectoryWalker_example\"></a>\n- * <h3>1. Example Implementation</h3>\n+ * <h3 id=\"example\">1. Example Implementation</h3>\n  *\n  * There are many possible extensions, for example, to delete all\n  * files and '.svn' directories, and return a list of deleted files:\n@@ -81,8 +80,7 @@\n  *  }\n  * </pre>\n  *\n- * <a id=\"DirectoryWalker_filter\"></a>\n- * <h3>2. Filter Example</h3>\n+ * <h3 id=\"filter\">2. Filter Example</h3>\n  *\n  * Choosing which directories and files to process can be a key aspect\n  * of using this class. This information can be setup in three ways,\n@@ -148,8 +146,7 @@\n  * This is much simpler than the previous example, and is why it is the preferred\n  * option for filtering.\n  *\n- * <a id=\"DirectoryWalker_cancel\"></a>\n- * <h3>3. Cancellation</h3>\n+ * <h3 id=\"cancel\">3. Cancellation</h3>\n  *\n  * The DirectoryWalker contains some of the logic required for cancel processing.\n  * Subclasses must complete the implementation.\n@@ -172,17 +169,16 @@\n  * <p>\n  * Two possible scenarios are envisaged for cancellation:\n  * <ul>\n- *    <li><a href=\"#DirectoryWalker_external\">3.1 External / Multi-threaded</a> - cancellation being\n+ *    <li><a href=\"#external\">3.1 External / Multi-threaded</a> - cancellation being\n  *        decided/initiated by an external process.</li>\n- *    <li><a href=\"#DirectoryWalker_internal\">3.2 Internal</a> - cancellation being decided/initiated\n+ *    <li><a href=\"#internal\">3.2 Internal</a> - cancellation being decided/initiated\n  *        from within a DirectoryWalker implementation.</li>\n  * </ul>\n  * <p>\n  * The following sections provide example implementations for these two different\n  * scenarios.\n  *\n- * <a id=\"DirectoryWalker_external\"></a>\n- * <h4>3.1 External / Multi-threaded</h4>\n+ * <h4 id=\"external\">3.1 External / Multi-threaded</h4>\n  *\n  * This example provides a public <code>cancel()</code> method that can be\n  * called by another thread to stop the processing. A typical example use-case\n@@ -213,8 +209,7 @@\n  *  }\n  * </pre>\n  *\n- * <a id=\"DirectoryWalker_internal\"></a>\n- * <h4>3.2 Internal</h4>\n+ * <h4 id=\"internal\">3.2 Internal</h4>\n  *\n  * This shows an example of how internal cancellation processing could be implemented.\n  * <b>Note</b> the decision logic and throwing a {@link CancelException} could be implemented",
                "deletions": 15
            },
            {
                "sha": "6d57dade2325426a0ae0dacecbe638b7e3f8d130",
                "filename": "src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java",
                "status": "modified",
                "changes": 6,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -46,14 +46,12 @@ public MessageDigestMaintainingObserver(final MessageDigest pMd) {\n         }\n \n         @Override\n-\t\tpublic\n-        void data(final int pByte) throws IOException {\n+        public void data(final int pByte) throws IOException {\n             md.update((byte) pByte);\n         }\n \n         @Override\n-\t\tpublic\n-        void data(final byte[] pBuffer, final int pOffset, final int pLength) throws IOException {\n+        public void data(final byte[] pBuffer, final int pOffset, final int pLength) throws IOException {\n             md.update(pBuffer, pOffset, pLength);\n         }\n     }",
                "deletions": 4
            },
            {
                "sha": "8d20de1324cec51effba96851c7fb5222724bf2b",
                "filename": "src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java",
                "status": "modified",
                "changes": 189,
                "additions": 102,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -16,109 +16,124 @@\n  */\n package org.apache.commons.io.input.buffer;\n \n-import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Objects;\n \n \n /**\n  * Implementation of a buffered input stream, which is internally based on the\n- * {@link CircularByteBuffer}. Unlike the {@link BufferedInputStream}, this one\n+ * {@link CircularByteBuffer}. Unlike the {@link java.io.BufferedInputStream}, this one\n  * doesn't need to reallocate byte arrays internally.\n  */\n public class CircularBufferInputStream extends InputStream {\n-\tprotected final InputStream in;\n-\tprotected final CircularByteBuffer buffer;\n-\tprotected final int bufferSize;\n-\tprivate boolean eofSeen;\n+    protected final InputStream in;\n+    protected final CircularByteBuffer buffer;\n+    protected final int bufferSize;\n+    private boolean eofSeen;\n \n-\t/** Creates a new instance, which filters the given input stream, and\n-\t * uses the given buffer size.\n-\t * @param pIn The input stream, which is being buffered.\n-\t * @param pBufferSize The size of the {@link CircularByteBuffer}, which is\n-\t * used internally.\n-\t */\n-\tpublic CircularBufferInputStream(InputStream pIn, int pBufferSize) {\n-\t\tObjects.requireNonNull(pIn, \"InputStream\");\n-\t\tif (pBufferSize <= 0) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid buffer size: \" + pBufferSize);\n-\t\t}\n-\t\tin = pIn;\n-\t\tbuffer = new CircularByteBuffer(pBufferSize);\n-\t\tbufferSize = pBufferSize;\n-\t\teofSeen = false;\n-\t}\n+    /**\n+     * Creates a new instance, which filters the given input stream, and\n+     * uses the given buffer size.\n+     *\n+     * @param pIn         The input stream, which is being buffered.\n+     * @param pBufferSize The size of the {@link CircularByteBuffer}, which is\n+     *                    used internally.\n+     */\n+    public CircularBufferInputStream(InputStream pIn, int pBufferSize) {\n+        Objects.requireNonNull(pIn, \"InputStream\");\n+        if (pBufferSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid buffer size: \" + pBufferSize);\n+        }\n+        in = pIn;\n+        buffer = new CircularByteBuffer(pBufferSize);\n+        bufferSize = pBufferSize;\n+        eofSeen = false;\n+    }\n \n-\t/** Creates a new instance, which filters the given input stream, and\n-\t * uses a reasonable default buffer size (8192).\n-\t * @param pIn The input stream, which is being buffered.\n-\t */\n-\tpublic CircularBufferInputStream(InputStream pIn) {\n-\t\tthis(pIn, 8192);\n-\t}\n+    /**\n+     * Creates a new instance, which filters the given input stream, and\n+     * uses a reasonable default buffer size (8192).\n+     *\n+     * @param pIn The input stream, which is being buffered.\n+     */\n+    public CircularBufferInputStream(InputStream pIn) {\n+        this(pIn, 8192);\n+    }\n \n-\tprotected void fillBuffer() throws IOException {\n-\t\tif (eofSeen) {\n-\t\t\treturn;\n-\t\t}\n-\t\tint space = buffer.getSpace();\n-\t\tfinal byte[] buf = new byte[space];\n-\t\twhile (space > 0) {\n-\t\t\tfinal int res = in.read(buf, 0, space);\n-\t\t\tif (res == -1) {\n-\t\t\t\teofSeen = true;\n-\t\t\t\treturn;\n-\t\t\t} else if (res > 0) {\n-\t\t\t\tbuffer.add(buf, 0, res);\n-\t\t\t\tspace -= res;\n-\t\t\t}\n-\t\t}\n-\t}\n+    /**\n+     * Fills the buffer with the contents of the input stream.\n+     *\n+     * @throws IOException in case of an error while reading from the input stream.\n+     */\n+    protected void fillBuffer() throws IOException {\n+        if (eofSeen) {\n+            return;\n+        }\n+        int space = buffer.getSpace();\n+        final byte[] buf = new byte[space];\n+        while (space > 0) {\n+            final int res = in.read(buf, 0, space);\n+            if (res == -1) {\n+                eofSeen = true;\n+                return;\n+            } else if (res > 0) {\n+                buffer.add(buf, 0, res);\n+                space -= res;\n+            }\n+        }\n+    }\n \n-\tprotected boolean haveBytes(int pNumber) throws IOException {\n-\t\tif (buffer.getCurrentNumberOfBytes() < pNumber) {\n-\t\t\tfillBuffer();\n-\t\t}\n-\t\treturn buffer.hasBytes();\n-\t}\n+    /**\n+     * Fills the buffer from the input stream until the given number of bytes have been added to the buffer.\n+     *\n+     * @param pNumber number of byte to fill into the buffer\n+     * @return true if the buffer has bytes\n+     * @throws IOException in case of an error while reading from the input stream.\n+     */\n+    protected boolean haveBytes(int pNumber) throws IOException {\n+        if (buffer.getCurrentNumberOfBytes() < pNumber) {\n+            fillBuffer();\n+        }\n+        return buffer.hasBytes();\n+    }\n \n-\t@Override\n-\tpublic int read() throws IOException {\n-\t\tif (!haveBytes(1)) {\n-\t\t\treturn -1;\n-\t\t}\n-\t\treturn buffer.read();\n-\t}\n+    @Override\n+    public int read() throws IOException {\n+        if (!haveBytes(1)) {\n+            return -1;\n+        }\n+        return buffer.read();\n+    }\n \n-\t@Override\n-\tpublic int read(byte[] pBuffer) throws IOException {\n-\t\treturn read(pBuffer, 0, pBuffer.length);\n-\t}\n+    @Override\n+    public int read(byte[] pBuffer) throws IOException {\n+        return read(pBuffer, 0, pBuffer.length);\n+    }\n \n-\t@Override\n-\tpublic int read(byte[] pBuffer, int pOffset, int pLength) throws IOException {\n-\t\tObjects.requireNonNull(pBuffer, \"Buffer\");\n-\t\tif (pOffset < 0) {\n-\t\t\tthrow new IllegalArgumentException(\"Offset must not be negative\");\n-\t\t}\n-\t\tif (pLength < 0) {\n-\t\t\tthrow new IllegalArgumentException(\"Length must not be negative\");\n-\t\t}\n-\t\tif (!haveBytes(pLength)) {\n-\t\t\treturn -1;\n-\t\t}\n-\t\tfinal int result = Math.min(pLength, buffer.getCurrentNumberOfBytes());\n-\t\tfor (int i = 0;  i < result;  i++) {\n-\t\t\tpBuffer[pOffset+i] = buffer.read();\n-\t\t}\n-\t\treturn result;\n-\t}\n+    @Override\n+    public int read(byte[] pBuffer, int pOffset, int pLength) throws IOException {\n+        Objects.requireNonNull(pBuffer, \"Buffer\");\n+        if (pOffset < 0) {\n+            throw new IllegalArgumentException(\"Offset must not be negative\");\n+        }\n+        if (pLength < 0) {\n+            throw new IllegalArgumentException(\"Length must not be negative\");\n+        }\n+        if (!haveBytes(pLength)) {\n+            return -1;\n+        }\n+        final int result = Math.min(pLength, buffer.getCurrentNumberOfBytes());\n+        for (int i = 0; i < result; i++) {\n+            pBuffer[pOffset + i] = buffer.read();\n+        }\n+        return result;\n+    }\n \n-\t@Override\n-\tpublic void close() throws IOException {\n-\t\tin.close();\n-\t\teofSeen = true;\n-\t\tbuffer.clear();\n-\t}\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+        eofSeen = true;\n+        buffer.clear();\n+    }\n }",
                "deletions": 87
            },
            {
                "sha": "95ca142c9308f5536c765953b56bbc56f3fb9b14",
                "filename": "src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java",
                "status": "modified",
                "changes": 421,
                "additions": 216,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -26,225 +26,236 @@\n  * like the {@link CircularBufferInputStream}.\n  */\n public class CircularByteBuffer {\n-\tprivate final byte[] buffer;\n-\tprivate int startOffset, endOffset, currentNumberOfBytes;\n+    private final byte[] buffer;\n+    private int startOffset, endOffset, currentNumberOfBytes;\n \n-\t/**\n-\t * Creates a new instance with the given buffer size.\n-\t * @param pSize the size of buffer to create\n-\t */\n-\tpublic CircularByteBuffer(int pSize) {\n-\t\tbuffer = new byte[pSize];\n-\t\tstartOffset = 0;\n-\t\tendOffset = 0;\n-\t\tcurrentNumberOfBytes = 0;\n-\t}\n+    /**\n+     * Creates a new instance with the given buffer size.\n+     *\n+     * @param pSize the size of buffer to create\n+     */\n+    public CircularByteBuffer(int pSize) {\n+        buffer = new byte[pSize];\n+        startOffset = 0;\n+        endOffset = 0;\n+        currentNumberOfBytes = 0;\n+    }\n \n-\t/**\n-\t * Creates a new instance with a reasonable default buffer size (8192).\n-\t */\n-\tpublic CircularByteBuffer() {\n-\t\tthis(8192);\n-\t}\n+    /**\n+     * Creates a new instance with a reasonable default buffer size (8192).\n+     */\n+    public CircularByteBuffer() {\n+        this(8192);\n+    }\n \n-\t/**\n-\t * Returns the next byte from the buffer, removing it at the same time, so\n-\t * that following invocations won't return it again.\n-\t * @return The byte, which is being returned.\n-\t * @throws IllegalStateException The buffer is empty. Use {@link #hasBytes()},\n-\t * or {@link #getCurrentNumberOfBytes()}, to prevent this exception.\n-\t */\n-\tpublic byte read() {\n-\t\tif (currentNumberOfBytes <= 0) {\n-\t\t\tthrow new IllegalStateException(\"No bytes available.\");\n-\t\t}\n-\t\tfinal byte b = buffer[startOffset];\n-\t\t--currentNumberOfBytes;\n-\t\tif (++startOffset == buffer.length) {\n-\t\t\tstartOffset = 0;\n-\t\t}\n-\t\treturn b;\n-\t}\n+    /**\n+     * Returns the next byte from the buffer, removing it at the same time, so\n+     * that following invocations won't return it again.\n+     *\n+     * @return The byte, which is being returned.\n+     * @throws IllegalStateException The buffer is empty. Use {@link #hasBytes()},\n+     *                               or {@link #getCurrentNumberOfBytes()}, to prevent this exception.\n+     */\n+    public byte read() {\n+        if (currentNumberOfBytes <= 0) {\n+            throw new IllegalStateException(\"No bytes available.\");\n+        }\n+        final byte b = buffer[startOffset];\n+        --currentNumberOfBytes;\n+        if (++startOffset == buffer.length) {\n+            startOffset = 0;\n+        }\n+        return b;\n+    }\n \n-\t/**\n-\t * Returns the given number of bytes from the buffer by storing them in\n-\t * the given byte array at the given offset.\n-\t * @param pBuffer The byte array, where to add bytes.\n-\t * @param pOffset The offset, where to store bytes in the byte array.\n-\t * @param pLength The number of bytes to return.\n-\t * @throws NullPointerException The byte array {@code pBuffer} is null.\n-\t * @throws IllegalArgumentException Either of {@code pOffset}, or {@code pLength} is negative,\n-\t * or the length of the byte array {@code pBuffer} is too small.\n-\t * @throws IllegalStateException The buffer doesn't hold the given number\n-\t * of bytes. Use {@link #getCurrentNumberOfBytes()} to prevent this\n-\t * exception.\n-\t */\n-\tpublic void read(byte[] pBuffer, int pOffset, int pLength) {\n-\t\tObjects.requireNonNull(pBuffer);\n-\t\tif (pOffset < 0  ||  pOffset >= pBuffer.length) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid offset: \" + pOffset);\n-\t\t}\n-\t\tif (pLength < 0  ||  pLength > buffer.length) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid length: \" + pLength);\n-\t\t}\n-\t\tif (pOffset+pLength > pBuffer.length) {\n-\t\t\tthrow new IllegalArgumentException(\"The supplied byte array contains only \"\n-\t\t\t\t\t+ pBuffer.length + \" bytes, but offset, and length would require \"\n-\t\t\t\t\t+ (pOffset+pLength-1));\n-\t\t}\n-\t\tif (currentNumberOfBytes < pLength) {\n-\t\t\tthrow new IllegalStateException(\"Currently, there are only \" + currentNumberOfBytes\n-\t\t\t\t\t+ \"in the buffer, not \" + pLength);\n-\t\t}\n-\t\tint offset = pOffset;\n-\t\tfor (int i = 0;  i < pLength;  i++) {\n-\t\t\tpBuffer[offset++] = buffer[startOffset];\n-\t\t\t--currentNumberOfBytes;\n-\t\t\tif (++startOffset == buffer.length) {\n-\t\t\t\tstartOffset = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n+    /**\n+     * Returns the given number of bytes from the buffer by storing them in\n+     * the given byte array at the given offset.\n+     *\n+     * @param pBuffer The byte array, where to add bytes.\n+     * @param pOffset The offset, where to store bytes in the byte array.\n+     * @param pLength The number of bytes to return.\n+     * @throws NullPointerException     The byte array {@code pBuffer} is null.\n+     * @throws IllegalArgumentException Either of {@code pOffset}, or {@code pLength} is negative,\n+     *                                  or the length of the byte array {@code pBuffer} is too small.\n+     * @throws IllegalStateException    The buffer doesn't hold the given number\n+     *                                  of bytes. Use {@link #getCurrentNumberOfBytes()} to prevent this\n+     *                                  exception.\n+     */\n+    public void read(byte[] pBuffer, int pOffset, int pLength) {\n+        Objects.requireNonNull(pBuffer);\n+        if (pOffset < 0 || pOffset >= pBuffer.length) {\n+            throw new IllegalArgumentException(\"Invalid offset: \" + pOffset);\n+        }\n+        if (pLength < 0 || pLength > buffer.length) {\n+            throw new IllegalArgumentException(\"Invalid length: \" + pLength);\n+        }\n+        if (pOffset + pLength > pBuffer.length) {\n+            throw new IllegalArgumentException(\"The supplied byte array contains only \"\n+                    + pBuffer.length + \" bytes, but offset, and length would require \"\n+                    + (pOffset + pLength - 1));\n+        }\n+        if (currentNumberOfBytes < pLength) {\n+            throw new IllegalStateException(\"Currently, there are only \" + currentNumberOfBytes\n+                    + \"in the buffer, not \" + pLength);\n+        }\n+        int offset = pOffset;\n+        for (int i = 0; i < pLength; i++) {\n+            pBuffer[offset++] = buffer[startOffset];\n+            --currentNumberOfBytes;\n+            if (++startOffset == buffer.length) {\n+                startOffset = 0;\n+            }\n+        }\n+    }\n \n-\t/**\n-\t * Adds a new byte to the buffer, which will eventually be returned by following\n-\t * invocations of {@link #read()}.\n-\t * @param pByte The byte, which is being added to the buffer.\n-\t * @throws IllegalStateException The buffer is full. Use {@link #hasSpace()},\n-\t * or {@link #getSpace()}, to prevent this exception.\n-\t */\n-\tpublic void add(byte pByte) {\n-\t\tif (currentNumberOfBytes >= buffer.length) {\n-\t\t\tthrow new IllegalStateException(\"No space available\");\n-\t\t}\n-\t\tbuffer[endOffset] = pByte;\n-\t\t++currentNumberOfBytes;\n-\t\tif (++endOffset == buffer.length) {\n-\t\t\tendOffset = 0;\n-\t\t}\n-\t}\n+    /**\n+     * Adds a new byte to the buffer, which will eventually be returned by following\n+     * invocations of {@link #read()}.\n+     *\n+     * @param pByte The byte, which is being added to the buffer.\n+     * @throws IllegalStateException The buffer is full. Use {@link #hasSpace()},\n+     *                               or {@link #getSpace()}, to prevent this exception.\n+     */\n+    public void add(byte pByte) {\n+        if (currentNumberOfBytes >= buffer.length) {\n+            throw new IllegalStateException(\"No space available\");\n+        }\n+        buffer[endOffset] = pByte;\n+        ++currentNumberOfBytes;\n+        if (++endOffset == buffer.length) {\n+            endOffset = 0;\n+        }\n+    }\n \n-\t/**\n-\t * Returns, whether the next bytes in the buffer are exactly those, given by\n-\t * {@code pBuffer}, {@code pOffset}, and {@code pLength}. No bytes are being\n-\t * removed from the buffer. If the result is true, then the following invocations\n-\t * of {@link #read()} are guaranteed to return exactly those bytes.\n-\t * @param pBuffer the buffer to compare against\n-\t * @param pOffset start offset\n-\t * @param pLength length to compare\n-\t * @return True, if the next invocations of {@link #read()} will return the\n-\t * bytes at offsets {@code pOffset}+0, {@code pOffset}+1, ...,\n-\t * {@code pOffset}+{@code pLength}-1 of byte array {@code pBuffer}.\n-\t * @throws IllegalArgumentException Either of {@code pOffset}, or {@code pLength} is negative.\n-\t * @throws NullPointerException The byte array {@code pBuffer} is null.\n-\t */\n-\tpublic boolean peek(byte[] pBuffer, int pOffset, int pLength) {\n-\t\tObjects.requireNonNull(pBuffer, \"Buffer\");\n-\t\tif (pOffset < 0  ||  pOffset >= pBuffer.length) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid offset: \" + pOffset);\n-\t\t}\n-\t\tif (pLength < 0  ||  pLength > buffer.length) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid length: \" + pLength);\n-\t\t}\n-\t\tif (pLength < currentNumberOfBytes) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tint offset = startOffset;\n-\t\tfor (int i = 0;  i < pLength;  i++) {\n-\t\t\tif (buffer[offset] != pBuffer[i+pOffset]) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tif (++offset == buffer.length) {\n-\t\t\t\toffset = 0;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n+    /**\n+     * Returns, whether the next bytes in the buffer are exactly those, given by\n+     * {@code pBuffer}, {@code pOffset}, and {@code pLength}. No bytes are being\n+     * removed from the buffer. If the result is true, then the following invocations\n+     * of {@link #read()} are guaranteed to return exactly those bytes.\n+     *\n+     * @param pBuffer the buffer to compare against\n+     * @param pOffset start offset\n+     * @param pLength length to compare\n+     * @return True, if the next invocations of {@link #read()} will return the\n+     * bytes at offsets {@code pOffset}+0, {@code pOffset}+1, ...,\n+     * {@code pOffset}+{@code pLength}-1 of byte array {@code pBuffer}.\n+     * @throws IllegalArgumentException Either of {@code pOffset}, or {@code pLength} is negative.\n+     * @throws NullPointerException     The byte array {@code pBuffer} is null.\n+     */\n+    public boolean peek(byte[] pBuffer, int pOffset, int pLength) {\n+        Objects.requireNonNull(pBuffer, \"Buffer\");\n+        if (pOffset < 0 || pOffset >= pBuffer.length) {\n+            throw new IllegalArgumentException(\"Invalid offset: \" + pOffset);\n+        }\n+        if (pLength < 0 || pLength > buffer.length) {\n+            throw new IllegalArgumentException(\"Invalid length: \" + pLength);\n+        }\n+        if (pLength < currentNumberOfBytes) {\n+            return false;\n+        }\n+        int offset = startOffset;\n+        for (int i = 0; i < pLength; i++) {\n+            if (buffer[offset] != pBuffer[i + pOffset]) {\n+                return false;\n+            }\n+            if (++offset == buffer.length) {\n+                offset = 0;\n+            }\n+        }\n+        return true;\n+    }\n \n-\t/**\n-\t * Adds the given bytes to the buffer. This is the same as invoking {@link #add(byte)}\n-\t * for the bytes at offsets {@code pOffset}+0, {@code pOffset}+1, ...,\n-\t * {@code pOffset}+{@code pLength}-1 of byte array {@code pBuffer}.\n+    /**\n+     * Adds the given bytes to the buffer. This is the same as invoking {@link #add(byte)}\n+     * for the bytes at offsets {@code pOffset}+0, {@code pOffset}+1, ...,\n+     * {@code pOffset}+{@code pLength}-1 of byte array {@code pBuffer}.\n+     *\n      * @param pBuffer the buffer to copy\n      * @param pOffset start offset\n      * @param pLength length to copy\n-\t * @throws IllegalStateException The buffer doesn't have sufficient space. Use\n-\t * {@link #getSpace()} to prevent this exception.\n-\t * @throws IllegalArgumentException Either of {@code pOffset}, or {@code pLength} is negative.\n-\t * @throws NullPointerException The byte array {@code pBuffer} is null.\n-\t */\n-\tpublic void add(byte[] pBuffer, int pOffset, int pLength) {\n-\t\tObjects.requireNonNull(pBuffer, \"Buffer\");\n-\t\tif (pOffset < 0  ||  pOffset >= pBuffer.length) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid offset: \" + pOffset);\n-\t\t}\n-\t\tif (pLength < 0) {\n-\t\t\tthrow new IllegalArgumentException(\"Invalid length: \" + pLength);\n-\t\t}\n-\t\tif (currentNumberOfBytes+pLength > buffer.length) {\n-\t\t\tthrow new IllegalStateException(\"No space available\");\n-\t\t}\n-\t\tfor (int i = 0;  i < pLength;  i++) {\n-\t\t\tbuffer[endOffset] = pBuffer[pOffset+i];\n-\t\t\tif (++endOffset == buffer.length) {\n-\t\t\t\tendOffset = 0;\n-\t\t\t}\n-\t\t}\n-\t\tcurrentNumberOfBytes += pLength;\n-\t}\n+     * @throws IllegalStateException    The buffer doesn't have sufficient space. Use\n+     *                                  {@link #getSpace()} to prevent this exception.\n+     * @throws IllegalArgumentException Either of {@code pOffset}, or {@code pLength} is negative.\n+     * @throws NullPointerException     The byte array {@code pBuffer} is null.\n+     */\n+    public void add(byte[] pBuffer, int pOffset, int pLength) {\n+        Objects.requireNonNull(pBuffer, \"Buffer\");\n+        if (pOffset < 0 || pOffset >= pBuffer.length) {\n+            throw new IllegalArgumentException(\"Invalid offset: \" + pOffset);\n+        }\n+        if (pLength < 0) {\n+            throw new IllegalArgumentException(\"Invalid length: \" + pLength);\n+        }\n+        if (currentNumberOfBytes + pLength > buffer.length) {\n+            throw new IllegalStateException(\"No space available\");\n+        }\n+        for (int i = 0; i < pLength; i++) {\n+            buffer[endOffset] = pBuffer[pOffset + i];\n+            if (++endOffset == buffer.length) {\n+                endOffset = 0;\n+            }\n+        }\n+        currentNumberOfBytes += pLength;\n+    }\n \n-\t/**\n-\t * Returns, whether there is currently room for a single byte in the buffer.\n-\t * Same as {@link #hasSpace(int) hasSpace(1)}.\n-\t * @see #hasSpace(int)\n-\t * @see #getSpace()\n-\t * @return true if there is space for a byte\n-\t */\n-\tpublic boolean hasSpace() {\n-\t\treturn currentNumberOfBytes < buffer.length;\n-\t}\n+    /**\n+     * Returns, whether there is currently room for a single byte in the buffer.\n+     * Same as {@link #hasSpace(int) hasSpace(1)}.\n+     *\n+     * @return true if there is space for a byte\n+     * @see #hasSpace(int)\n+     * @see #getSpace()\n+     */\n+    public boolean hasSpace() {\n+        return currentNumberOfBytes < buffer.length;\n+    }\n \n-\t/**\n-\t * Returns, whether there is currently room for the given number of bytes in the buffer.\n-\t * @see #hasSpace()\n-\t * @see #getSpace()\n-\t * @param pBytes the byte count\n-\t * @return true if there is space for the given number of bytes\n-\t */\n-\tpublic boolean hasSpace(int pBytes) {\n-\t\treturn currentNumberOfBytes+pBytes <= buffer.length;\n-\t}\n+    /**\n+     * Returns, whether there is currently room for the given number of bytes in the buffer.\n+     *\n+     * @param pBytes the byte count\n+     * @return true if there is space for the given number of bytes\n+     * @see #hasSpace()\n+     * @see #getSpace()\n+     */\n+    public boolean hasSpace(int pBytes) {\n+        return currentNumberOfBytes + pBytes <= buffer.length;\n+    }\n \n-\t/**\n-\t * Returns, whether the buffer is currently holding, at least, a single byte.\n-\t * @return true if the buffer is not empty\n-\t */\n-\tpublic boolean hasBytes() {\n-\t\treturn currentNumberOfBytes > 0;\n-\t}\n+    /**\n+     * Returns, whether the buffer is currently holding, at least, a single byte.\n+     *\n+     * @return true if the buffer is not empty\n+     */\n+    public boolean hasBytes() {\n+        return currentNumberOfBytes > 0;\n+    }\n \n-\t/**\n-\t * Returns the number of bytes, that can currently be added to the buffer.\n-\t * @return the number of bytes that can be added\n-\t */\n-\tpublic int getSpace() {\n-\t\treturn buffer.length - currentNumberOfBytes;\n-\t}\n+    /**\n+     * Returns the number of bytes, that can currently be added to the buffer.\n+     *\n+     * @return the number of bytes that can be added\n+     */\n+    public int getSpace() {\n+        return buffer.length - currentNumberOfBytes;\n+    }\n \n-\t/**\n-\t * Returns the number of bytes, that are currently present in the buffer.\n-\t * @return the number of bytes\n-\t */\n-\tpublic int getCurrentNumberOfBytes() {\n-\t\treturn currentNumberOfBytes;\n-\t}\n+    /**\n+     * Returns the number of bytes, that are currently present in the buffer.\n+     *\n+     * @return the number of bytes\n+     */\n+    public int getCurrentNumberOfBytes() {\n+        return currentNumberOfBytes;\n+    }\n \n-\t/**\n-\t * Removes all bytes from the buffer.\n-\t */\n-\tpublic void clear() {\n-\t\tstartOffset = 0;\n-\t\tendOffset = 0;\n-\t\tcurrentNumberOfBytes = 0;\n-\t}\n+    /**\n+     * Removes all bytes from the buffer.\n+     */\n+    public void clear() {\n+        startOffset = 0;\n+        endOffset = 0;\n+        currentNumberOfBytes = 0;\n+    }\n }",
                "deletions": 205
            },
            {
                "sha": "feed9c143283d163420f35cc39ab8533d5a9e4ed",
                "filename": "src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java",
                "status": "modified",
                "changes": 119,
                "additions": 63,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -21,67 +21,74 @@\n import java.util.Objects;\n \n \n-/** Implementation of a buffered input stream, which allows to peek into\n+/**\n+ * Implementation of a buffered input stream, which allows to peek into\n  * the buffers first bytes. This comes in handy when manually implementing\n  * scanners, lexers, parsers, or the like.\n  */\n public class PeekableInputStream extends CircularBufferInputStream {\n-\t/** Creates a new instance, which filters the given input stream, and\n-\t * uses the given buffer size.\n-\t * @param pIn The input stream, which is being buffered.\n-\t * @param pBufferSize The size of the {@link CircularByteBuffer}, which is\n-\t * used internally.\n-\t */\n-\tpublic PeekableInputStream(InputStream pIn, int pBufferSize) {\n-\t\tsuper(pIn, pBufferSize);\n-\t}\n+    /**\n+     * Creates a new instance, which filters the given input stream, and\n+     * uses the given buffer size.\n+     *\n+     * @param pIn         The input stream, which is being buffered.\n+     * @param pBufferSize The size of the {@link CircularByteBuffer}, which is\n+     *                    used internally.\n+     */\n+    public PeekableInputStream(InputStream pIn, int pBufferSize) {\n+        super(pIn, pBufferSize);\n+    }\n \n-\t/** Creates a new instance, which filters the given input stream, and\n-\t * uses a reasonable default buffer size (8192).\n-\t * @param pIn The input stream, which is being buffered.\n-\t */\n-\tpublic PeekableInputStream(InputStream pIn) {\n-\t\tsuper(pIn);\n-\t}\n+    /**\n+     * Creates a new instance, which filters the given input stream, and\n+     * uses a reasonable default buffer size (8192).\n+     *\n+     * @param pIn The input stream, which is being buffered.\n+     */\n+    public PeekableInputStream(InputStream pIn) {\n+        super(pIn);\n+    }\n \n-\t/**\n-\t * Returns, whether the next bytes in the buffer are as given by\n-\t * {@code pBuffer}. This is equivalent to {@link #peek(byte[],int,int)}\n-\t * with {@code pOffset} == 0, and {@code pLength} == {@code pBuffer.length}\n-\t * @param pBuffer the buffer to compare against\n-\t * @return true if the next bytes are as given\n-\t * @throws IOException Refilling the buffer failed.\n-\t */\n-\tpublic boolean peek(byte[] pBuffer) throws IOException {\n-\t\tObjects.requireNonNull(pBuffer, \"Buffer\");\n-\t\tif (pBuffer.length > bufferSize) {\n-\t\t\tthrow new IllegalArgumentException(\"Peek request size of \" + pBuffer.length\n-\t\t\t\t\t                           + \" bytes exceeds buffer size of \" + bufferSize + \" bytes\");\n-\t\t}\n-\t\tif (buffer.getCurrentNumberOfBytes() < pBuffer.length) {\n-\t\t\tfillBuffer();\n-\t\t}\n-\t\treturn buffer.peek(pBuffer, 0, pBuffer.length);\n-\t}\n+    /**\n+     * Returns, whether the next bytes in the buffer are as given by\n+     * {@code pBuffer}. This is equivalent to {@link #peek(byte[], int, int)}\n+     * with {@code pOffset} == 0, and {@code pLength} == {@code pBuffer.length}\n+     *\n+     * @param pBuffer the buffer to compare against\n+     * @return true if the next bytes are as given\n+     * @throws IOException Refilling the buffer failed.\n+     */\n+    public boolean peek(byte[] pBuffer) throws IOException {\n+        Objects.requireNonNull(pBuffer, \"Buffer\");\n+        if (pBuffer.length > bufferSize) {\n+            throw new IllegalArgumentException(\"Peek request size of \" + pBuffer.length\n+                    + \" bytes exceeds buffer size of \" + bufferSize + \" bytes\");\n+        }\n+        if (buffer.getCurrentNumberOfBytes() < pBuffer.length) {\n+            fillBuffer();\n+        }\n+        return buffer.peek(pBuffer, 0, pBuffer.length);\n+    }\n \n-\t/**\n-\t * Returns, whether the next bytes in the buffer are as given by\n-\t * {@code pBuffer}, {code pOffset}, and {@code pLength}.\n-\t * @param pBuffer the buffer to compare against\n-\t * @param pOffset the start offset\n-\t * @param pLength the length to compare\n-\t * @return true if the next bytes in the buffer are as given\n-\t * @throws IOException if there is a problem calling fillBuffer()\n-\t */\n-\tpublic boolean peek(byte[] pBuffer, int pOffset, int pLength) throws IOException {\n-\t\tObjects.requireNonNull(pBuffer, \"Buffer\");\n-\t\tif (pBuffer.length > bufferSize) {\n-\t\t\tthrow new IllegalArgumentException(\"Peek request size of \" + pBuffer.length\n-\t\t\t\t\t                           + \" bytes exceeds buffer size of \" + bufferSize + \" bytes\");\n-\t\t}\n-\t\tif (buffer.getCurrentNumberOfBytes() < pBuffer.length) {\n-\t\t\tfillBuffer();\n-\t\t}\n-\t\treturn buffer.peek(pBuffer, pOffset, pLength);\n-\t}\n+    /**\n+     * Returns, whether the next bytes in the buffer are as given by\n+     * {@code pBuffer}, {code pOffset}, and {@code pLength}.\n+     *\n+     * @param pBuffer the buffer to compare against\n+     * @param pOffset the start offset\n+     * @param pLength the length to compare\n+     * @return true if the next bytes in the buffer are as given\n+     * @throws IOException if there is a problem calling fillBuffer()\n+     */\n+    public boolean peek(byte[] pBuffer, int pOffset, int pLength) throws IOException {\n+        Objects.requireNonNull(pBuffer, \"Buffer\");\n+        if (pBuffer.length > bufferSize) {\n+            throw new IllegalArgumentException(\"Peek request size of \" + pBuffer.length\n+                    + \" bytes exceeds buffer size of \" + bufferSize + \" bytes\");\n+        }\n+        if (buffer.getCurrentNumberOfBytes() < pBuffer.length) {\n+            fillBuffer();\n+        }\n+        return buffer.peek(pBuffer, pOffset, pLength);\n+    }\n }",
                "deletions": 56
            },
            {
                "sha": "06dc5651039995c6c71ec24ee8e2ef8c179127b8",
                "filename": "src/main/java/org/apache/commons/io/input/buffer/package-info.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/package-info.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/main/java/org/apache/commons/io/input/buffer/package-info.java",
                "status": "added",
                "changes": 17,
                "additions": 17,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/main/java/org/apache/commons/io/input/buffer/package-info.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -0,0 +1,17 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.input.buffer;",
                "deletions": 0
            },
            {
                "sha": "a50b0543697fd7da516f8e020ce46909df8d847a",
                "filename": "src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java",
                "blob_url": "https://github.com/apache/commons-io/blob/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java",
                "raw_url": "https://github.com/apache/commons-io/raw/f15433d69c96aec08c9a0c3c15a69edd8250ae2b/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/commons-io/contents/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java?ref=f15433d69c96aec08c9a0c3c15a69edd8250ae2b",
                "patch": "@@ -257,7 +257,7 @@ public void testCopy_readerToAppendable_IO84() throws Exception {\n         final NullWriter writer = new NullWriter();\n \n         // Test copy() method\n-        assertEquals(size, IOUtils.copy(reader, writer));\n+        assertEquals(size, IOUtils.copy(reader, (Appendable) writer));\n \n         // reset the input\n         reader.close();",
                "deletions": 1
            }
        ],
        "patched_files": [
            "CircularBufferInputStream.java",
            "MessageDigestCalculatingInputStream.java"
        ],
        "unit_tests": [
            "CircularBufferInputStreamTest.java",
            "MessageDigestCalculatingInputStreamTest.java"
        ]
    }
}