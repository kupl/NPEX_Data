{
    "qpid-jms_020ae3a": {
        "bug_id": "qpid-jms_020ae3a",
        "commit": "https://github.com/apache/qpid-jms/commit/020ae3a7c9897478a88995b2b5ddb87034b333ff",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/qpid-jms/blob/020ae3a7c9897478a88995b2b5ddb87034b333ff/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java",
                "changes": 7,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java?ref=020ae3a7c9897478a88995b2b5ddb87034b333ff",
                "deletions": 2,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java",
                "patch": "@@ -110,8 +110,11 @@ public void send(JmsOutboundMessageDispatch envelope, AsyncResult request) throw\n     @Override\n     public void close(AsyncResult request) {\n         // Trigger an immediate close, the internal producers that are currently in the cache\n-        for (AmqpProducer producer : producerCache.values()) {\n-            producer.close(new CloseRequest(producer));\n+        // if the cache is enabled.\n+        if (connection.isAnonymousProducerCache()) {\n+            for (AmqpProducer producer : producerCache.values()) {\n+                producer.close(new CloseRequest(producer));\n+            }\n         }\n \n         request.onSuccess();",
                "raw_url": "https://github.com/apache/qpid-jms/raw/020ae3a7c9897478a88995b2b5ddb87034b333ff/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java",
                "sha": "447b4b229897c41fda8770bb5abcdf5655ecb078",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/qpid-jms/blob/020ae3a7c9897478a88995b2b5ddb87034b333ff/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/IntegrationTestFixture.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/IntegrationTestFixture.java?ref=020ae3a7c9897478a88995b2b5ddb87034b333ff",
                "deletions": 1,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/IntegrationTestFixture.java",
                "patch": "@@ -137,7 +137,11 @@ String buildURI(TestAmqpPeer testPeer, boolean ssl, String optionsString) {\n         final String baseURI = scheme + \"://localhost:\" + testPeer.getServerPort();\n         String remoteURI = baseURI;\n         if (optionsString != null) {\n-            remoteURI = baseURI + optionsString;\n+            if (optionsString.startsWith(\"?\")) {\n+                remoteURI = baseURI + optionsString;\n+            } else {\n+                remoteURI = baseURI + \"?\" + optionsString;\n+            }\n         }\n \n         return remoteURI;",
                "raw_url": "https://github.com/apache/qpid-jms/raw/020ae3a7c9897478a88995b2b5ddb87034b333ff/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/IntegrationTestFixture.java",
                "sha": "afcef7441b3d468aea584bb6e0e68f3661674854",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/qpid-jms/blob/020ae3a7c9897478a88995b2b5ddb87034b333ff/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java?ref=020ae3a7c9897478a88995b2b5ddb87034b333ff",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java",
                "patch": "@@ -1131,6 +1131,7 @@ private void doCreateAnonymousProducerTargetContainsCapabilityWhenAnonymousRelay\n \n             Message message = session.createMessage();\n             producer.send(dest, message);\n+            producer.close();\n \n             connection.close();\n ",
                "raw_url": "https://github.com/apache/qpid-jms/raw/020ae3a7c9897478a88995b2b5ddb87034b333ff/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java",
                "sha": "2b188c224a444e916b8678c8d30eac38c99bb023",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-227 Fix NPE on close of Anonymous producer\t\n\nWhen anonymous relay is not supported the producer close can NPE when\nthe producer cache is not enabled.",
        "parent": "https://github.com/apache/qpid-jms/commit/a21dec049baf0e0e38f131a8156c6a4d85edd890",
        "patched_files": [
            "IntegrationTestFixture.java",
            "AmqpAnonymousFallbackProducer.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "SessionIntegrationTest.java"
        ]
    },
    "qpid-jms_0fd981c": {
        "bug_id": "qpid-jms_0fd981c",
        "commit": "https://github.com/apache/qpid-jms/commit/0fd981ca1397607362c0c89920017fded813cec1",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/qpid-jms/blob/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsLocalTransactionContext.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsLocalTransactionContext.java?ref=0fd981ca1397607362c0c89920017fded813cec1",
                "deletions": 0,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsLocalTransactionContext.java",
                "patch": "@@ -183,6 +183,7 @@ public void onPendingSuccess() {\n \n                         @Override\n                         public void onPendingFailure(Throwable cause) {\n+                            reset();\n                         }\n                     });\n \n@@ -235,6 +236,7 @@ public void onPendingSuccess() {\n \n                     @Override\n                     public void onPendingFailure(Throwable cause) {\n+                        reset();\n                     }\n                 });\n ",
                "raw_url": "https://github.com/apache/qpid-jms/raw/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsLocalTransactionContext.java",
                "sha": "7d60fa74d392fed9c049950a92bac5c0767e1e8e",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/qpid-jms/blob/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java?ref=0fd981ca1397607362c0c89920017fded813cec1",
                "deletions": 2,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java",
                "patch": "@@ -98,8 +98,8 @@ public void processDeliveryUpdates(AmqpProvider provider) throws IOException {\n                     LOG.debug(\"Last TX request failed: {}\", current.getProviderHint());\n                     pendingDelivery.settle();\n                     Rejected rejected = (Rejected) state;\n-                    TransactionRolledBackException ex =\n-                        new TransactionRolledBackException(rejected.getError().getDescription());\n+                    Exception cause = AmqpSupport.convertToException(rejected.getError());\n+                    TransactionRolledBackException ex = new TransactionRolledBackException(cause.getMessage());\n                     AsyncResult request = this.pendingRequest;\n                     this.current = null;\n                     this.pendingRequest = null;",
                "raw_url": "https://github.com/apache/qpid-jms/raw/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java",
                "sha": "648b89672e434cb30854ab5b82f41359c2e314e9",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/qpid-jms/blob/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java",
                "changes": 412,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java?ref=0fd981ca1397607362c0c89920017fded813cec1",
                "deletions": 412,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java",
                "patch": "@@ -21,7 +21,6 @@\n import static org.apache.qpid.jms.provider.amqp.AmqpSupport.ANONYMOUS_RELAY;\n import static org.hamcrest.Matchers.arrayContaining;\n import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.greaterThan;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.junit.Assert.assertEquals;\n@@ -66,17 +65,12 @@\n import org.apache.qpid.jms.test.testpeer.describedtypes.Accepted;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Declare;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Declared;\n-import org.apache.qpid.jms.test.testpeer.describedtypes.Discharge;\n-import org.apache.qpid.jms.test.testpeer.describedtypes.Modified;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Rejected;\n-import org.apache.qpid.jms.test.testpeer.describedtypes.Released;\n-import org.apache.qpid.jms.test.testpeer.describedtypes.TransactionalState;\n import org.apache.qpid.jms.test.testpeer.describedtypes.sections.AmqpValueDescribedType;\n import org.apache.qpid.jms.test.testpeer.describedtypes.sections.HeaderDescribedType;\n import org.apache.qpid.jms.test.testpeer.matchers.AcceptedMatcher;\n import org.apache.qpid.jms.test.testpeer.matchers.CoordinatorMatcher;\n import org.apache.qpid.jms.test.testpeer.matchers.ModifiedMatcher;\n-import org.apache.qpid.jms.test.testpeer.matchers.ReleasedMatcher;\n import org.apache.qpid.jms.test.testpeer.matchers.SourceMatcher;\n import org.apache.qpid.jms.test.testpeer.matchers.TargetMatcher;\n import org.apache.qpid.jms.test.testpeer.matchers.TransactionalStateMatcher;\n@@ -951,78 +945,6 @@ public void testCreateAnonymousProducerWhenAnonymousRelayNodeIsNotSupported() th\n         }\n     }\n \n-    @Test(timeout=20000)\n-    public void testCommitTransactedSessionWithConsumerReceivingAllMessages() throws Exception {\n-        doCommitTransactedSessionWithConsumerTestImpl(1, 1);\n-    }\n-\n-    @Test(timeout=20000)\n-    public void testCommitTransactedSessionWithConsumerReceivingSomeMessages() throws Exception {\n-        doCommitTransactedSessionWithConsumerTestImpl(5, 2);\n-    }\n-\n-    private void doCommitTransactedSessionWithConsumerTestImpl(int transferCount, int consumeCount) throws Exception {\n-        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n-            Connection connection = testFixture.establishConnecton(testPeer);\n-            connection.start();\n-\n-            testPeer.expectBegin();\n-            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n-            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n-\n-            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            Binary txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n-            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            Queue queue = session.createQueue(\"myQueue\");\n-\n-            testPeer.expectReceiverAttach();\n-            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"), transferCount);\n-\n-            for (int i = 1; i <= consumeCount; i++) {\n-                // Then expect an *settled* TransactionalState disposition for each message once received by the consumer\n-                TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n-                stateMatcher.withTxnId(equalTo(txnId));\n-                stateMatcher.withOutcome(new AcceptedMatcher());\n-\n-                testPeer.expectDisposition(true, stateMatcher);\n-            }\n-\n-            MessageConsumer messageConsumer = session.createConsumer(queue);\n-\n-            for (int i = 1; i <= consumeCount; i++) {\n-                Message receivedMessage = messageConsumer.receive(3000);\n-\n-                assertNotNull(receivedMessage);\n-                assertTrue(receivedMessage instanceof TextMessage);\n-            }\n-\n-            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n-            // and reply with accepted and settled disposition to indicate the commit succeeded\n-            Discharge discharge = new Discharge();\n-            discharge.setFail(false);\n-            discharge.setTxnId(txnId);\n-            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n-            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n-            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n-\n-            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n-            declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            session.commit();\n-\n-            testPeer.waitForAllHandlersToComplete(1000);\n-        }\n-    }\n-\n     @Test(timeout=20000)\n     public void testIncomingMessageExceedsMaxRedeliveries() throws Exception {\n         try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n@@ -1070,340 +992,6 @@ public void testIncomingMessageExceedsMaxRedeliveries() throws Exception {\n         }\n     }\n \n-    @Test(timeout=20000)\n-    public void testProducedMessagesOnTransactedSessionCarryTxnId() throws Exception {\n-        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n-            Connection connection = testFixture.establishConnecton(testPeer);\n-            connection.start();\n-\n-            testPeer.expectBegin();\n-            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n-            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n-\n-            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a Declared disposition state containing the txnId.\n-            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            Queue queue = session.createQueue(\"myQueue\");\n-\n-            // Create a producer to use in provoking creation of the AMQP transaction\n-            testPeer.expectSenderAttach();\n-            MessageProducer producer  = session.createProducer(queue);\n-\n-            // Expect the message which provoked creating the transaction. Check it carries\n-            // TransactionalState with the above txnId but has no outcome. Respond with a\n-            // TransactionalState with Accepted outcome.\n-            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n-            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n-            messageMatcher.setMessageAnnotationsMatcher( new MessageAnnotationsSectionMatcher(true));\n-\n-            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n-            stateMatcher.withTxnId(equalTo(txnId));\n-            stateMatcher.withOutcome(nullValue());\n-\n-            TransactionalState txState = new TransactionalState();\n-            txState.setTxnId(txnId);\n-            txState.setOutcome(new Accepted());\n-\n-            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n-\n-            producer.send(session.createMessage());\n-\n-            testPeer.waitForAllHandlersToComplete(1000);\n-        }\n-    }\n-\n-    @Test(timeout=20000)\n-    public void testRollbackTransactedSessionWithConsumerReceivingAllMessages() throws Exception {\n-        doRollbackTransactedSessionWithConsumerTestImpl(1, 1);\n-    }\n-\n-    @Test(timeout=20000)\n-    public void testRollbackTransactedSessionWithConsumerReceivingSomeMessages() throws Exception {\n-        doRollbackTransactedSessionWithConsumerTestImpl(5, 2);\n-    }\n-\n-    private void doRollbackTransactedSessionWithConsumerTestImpl(int transferCount, int consumeCount) throws Exception {\n-        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n-            Connection connection = testFixture.establishConnecton(testPeer);\n-            connection.start();\n-\n-            testPeer.expectBegin();\n-            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n-            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n-\n-            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            Queue queue = session.createQueue(\"myQueue\");\n-\n-            testPeer.expectReceiverAttach();\n-            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"), transferCount);\n-\n-            for (int i = 1; i <= consumeCount; i++) {\n-                // Then expect a *settled* TransactionalState disposition for each message once received by the consumer\n-                TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n-                stateMatcher.withTxnId(equalTo(txnId));\n-                stateMatcher.withOutcome(new AcceptedMatcher());\n-\n-                testPeer.expectDisposition(true, stateMatcher);\n-            }\n-\n-            MessageConsumer messageConsumer = session.createConsumer(queue);\n-\n-            for (int i = 1; i <= consumeCount; i++) {\n-                Message receivedMessage = messageConsumer.receive(3000);\n-\n-                assertNotNull(receivedMessage);\n-                assertTrue(receivedMessage instanceof TextMessage);\n-            }\n-\n-            // Expect the consumer to be 'stopped' prior to rollback by issuing a 'drain'\n-            testPeer.expectLinkFlow(true, true, greaterThan(UnsignedInteger.ZERO));\n-\n-            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n-            // and reply with accepted and settled disposition to indicate the rollback succeeded\n-            Discharge discharge = new Discharge();\n-            discharge.setFail(true);\n-            discharge.setTxnId(txnId);\n-            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n-            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n-            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n-\n-            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            // Expect the messages that were not consumed to be released\n-            int unconsumed = transferCount - consumeCount;\n-            for (int i = 1; i <= unconsumed; i++) {\n-                testPeer.expectDisposition(true, new ReleasedMatcher());\n-            }\n-\n-            // Expect the consumer to be 'started' again as rollback completes\n-            testPeer.expectLinkFlow(false, false, greaterThan(UnsignedInteger.ZERO));\n-\n-            session.rollback();\n-\n-            testPeer.waitForAllHandlersToComplete(1000);\n-        }\n-    }\n-\n-    @Test(timeout=20000)\n-    public void testRollbackTransactedSessionWithPrefetchFullBeforeStoppingConsumer() throws Exception {\n-        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n-            Connection connection = testFixture.establishConnecton(testPeer);\n-            int messageCount = 5;\n-            ((JmsConnection) connection).getPrefetchPolicy().setAll(messageCount);\n-            connection.start();\n-\n-            testPeer.expectBegin();\n-            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n-            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n-\n-            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            Queue queue = session.createQueue(\"myQueue\");\n-\n-            // Create a consumer and fill the prefetch with messages, which we wont consume any of\n-            testPeer.expectReceiverAttach();\n-            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"), messageCount);\n-\n-            session.createConsumer(queue);\n-\n-            // Create a producer to use in provoking creation of the AMQP transaction\n-            testPeer.expectSenderAttach();\n-            MessageProducer producer  = session.createProducer(queue);\n-\n-            // Expect the message which provoked creating the transaction\n-            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n-            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n-            messageMatcher.setMessageAnnotationsMatcher( new MessageAnnotationsSectionMatcher(true));\n-            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n-            stateMatcher.withTxnId(equalTo(txnId));\n-            stateMatcher.withOutcome(nullValue());\n-\n-            TransactionalState txState = new TransactionalState();\n-            txState.setTxnId(txnId);\n-            txState.setOutcome(new Accepted());\n-\n-            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n-\n-            producer.send(session.createMessage());\n-\n-            // The consumer will be 'stopped' prior to rollback, however we will NOT send a 'drain' Flow\n-            // frame as we have manipulated that all the credit was already used, i.e. it already stopped.\n-\n-            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n-            // and reply with accepted and settled disposition to indicate the rollback succeeded\n-            Discharge discharge = new Discharge();\n-            discharge.setFail(true);\n-            discharge.setTxnId(txnId);\n-            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n-            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n-            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n-\n-            // Now expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            // Expect the messages that were not consumed to be released\n-            for (int i = 1; i <= messageCount; i++) {\n-                testPeer.expectDisposition(true, new ReleasedMatcher());\n-            }\n-\n-            // Expect the consumer to be 'started' again as rollback completes\n-            testPeer.expectLinkFlow(false, false, equalTo(UnsignedInteger.valueOf(messageCount)));\n-\n-            session.rollback();\n-\n-            testPeer.waitForAllHandlersToComplete(1000);\n-        }\n-    }\n-\n-    @Test(timeout=20000)\n-    public void testRollbackTransactedSessionWithPrefetchFullyUtilisedByDrainWhenStoppingConsumer() throws Exception {\n-        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n-            Connection connection = testFixture.establishConnecton(testPeer);\n-            int messageCount = 5;\n-            ((JmsConnection) connection).getPrefetchPolicy().setAll(messageCount);\n-            connection.start();\n-\n-            testPeer.expectBegin();\n-            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n-            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n-\n-            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            Queue queue = session.createQueue(\"myQueue\");\n-\n-            // Create a consumer, expect it to flow credit, but don't send it any messages\n-            testPeer.expectReceiverAttach();\n-            testPeer.expectLinkFlow(false, false, equalTo(UnsignedInteger.valueOf(messageCount)));\n-\n-            session.createConsumer(queue);\n-\n-            // Create a producer to use in provoking creation of the AMQP transaction\n-            testPeer.expectSenderAttach();\n-            MessageProducer producer  = session.createProducer(queue);\n-\n-            // Expect the message which provoked creating the transaction\n-            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n-            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n-            messageMatcher.setMessageAnnotationsMatcher( new MessageAnnotationsSectionMatcher(true));\n-\n-            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n-            stateMatcher.withTxnId(equalTo(txnId));\n-            stateMatcher.withOutcome(nullValue());\n-\n-            TransactionalState txState = new TransactionalState();\n-            txState.setTxnId(txnId);\n-            txState.setOutcome(new Accepted());\n-\n-            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n-\n-            producer.send(session.createMessage());\n-\n-            // Expect the consumer to be 'stopped' prior to rollback by issuing a 'drain' Flow.\n-            // Action the drain by filling the prefetch (which is equivalent to this having happened while\n-            // the Flow was in flight to the peer), and then DONT send a flow frame back to the client\n-            // as it can tell from the messages that all the credit has been used.\n-            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"),\n-                                                       messageCount, true, false, equalTo(UnsignedInteger.valueOf(messageCount)), 1, false);\n-\n-            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n-            // and reply with accepted and settled disposition to indicate the rollback succeeded\n-            Discharge discharge = new Discharge();\n-            discharge.setFail(true);\n-            discharge.setTxnId(txnId);\n-            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n-            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n-            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n-\n-            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            // Expect the messages that were not consumed to be released\n-            for (int i = 1; i <= messageCount; i++) {\n-                testPeer.expectDisposition(true, new ReleasedMatcher());\n-            }\n-\n-            // Expect the consumer to be 'started' again as rollback completes\n-            testPeer.expectLinkFlow(false, false, equalTo(UnsignedInteger.valueOf(messageCount)));\n-\n-            session.rollback();\n-\n-            testPeer.waitForAllHandlersToComplete(1000);\n-        }\n-    }\n-\n-    @Test(timeout=20000)\n-    public void testDefaultOutcomeIsModifiedForConsumerSourceOnTransactedSession() throws Exception {\n-        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n-            Connection connection = testFixture.establishConnecton(testPeer);\n-            connection.start();\n-\n-            testPeer.expectBegin();\n-            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n-            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n-\n-            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n-            // reply with a declared disposition state containing the txnId.\n-            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n-            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n-            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n-            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n-\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            String queueName = \"myQueue\";\n-            Queue queue = session.createQueue(queueName);\n-\n-            SourceMatcher sourceMatcher = new SourceMatcher();\n-            sourceMatcher.withAddress(equalTo(queueName));\n-            sourceMatcher.withDynamic(equalTo(false));\n-            sourceMatcher.withOutcomes(arrayContaining(Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL, Released.DESCRIPTOR_SYMBOL, Modified.DESCRIPTOR_SYMBOL));\n-            ModifiedMatcher outcomeMatcher = new ModifiedMatcher().withDeliveryFailed(equalTo(true)).withUndeliverableHere(nullValue());\n-            sourceMatcher.withDefaultOutcome(outcomeMatcher);\n-\n-            testPeer.expectReceiverAttach(notNullValue(), sourceMatcher);\n-            testPeer.expectLinkFlow();\n-\n-            session.createConsumer(queue);\n-\n-            testPeer.waitForAllHandlersToComplete(1000);\n-        }\n-    }\n \n     @Test(timeout=20000)\n     public void testPrefetchPolicyInfluencesCreditFlow() throws Exception {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java",
                "sha": "9fc563f0e56df9f5340e11e7f1b5ee2cd06f295c",
                "status": "modified"
            },
            {
                "additions": 720,
                "blob_url": "https://github.com/apache/qpid-jms/blob/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java",
                "changes": 720,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java?ref=0fd981ca1397607362c0c89920017fded813cec1",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java",
                "patch": "@@ -0,0 +1,720 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.qpid.jms.integration;\n+\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import javax.jms.Connection;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.TransactionRolledBackException;\n+\n+import org.apache.qpid.jms.JmsConnection;\n+import org.apache.qpid.jms.test.QpidJmsTestCase;\n+import org.apache.qpid.jms.test.testpeer.TestAmqpPeer;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Accepted;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Declare;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Declared;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Discharge;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Error;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Modified;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Rejected;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Released;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.TransactionalState;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.sections.AmqpValueDescribedType;\n+import org.apache.qpid.jms.test.testpeer.matchers.AcceptedMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.CoordinatorMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.ModifiedMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.ReleasedMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.SourceMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.TransactionalStateMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.sections.MessageAnnotationsSectionMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.sections.MessageHeaderSectionMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.sections.TransferPayloadCompositeMatcher;\n+import org.apache.qpid.jms.test.testpeer.matchers.types.EncodedAmqpValueMatcher;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.UnsignedInteger;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for behavior of Transacted Session operations.\n+ */\n+public class TransactionsIntegrationTest extends QpidJmsTestCase {\n+\n+    private final IntegrationTestFixture testFixture = new IntegrationTestFixture();\n+\n+    @Test(timeout=20000)\n+    public void testTransactionCommitFailWithEmptyRejectedDisposition() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a Declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            // Create a producer to use in provoking creation of the AMQP transaction\n+            testPeer.expectSenderAttach();\n+            MessageProducer producer  = session.createProducer(queue);\n+\n+            // Expect the message which was sent under the current transaction. Check it carries\n+            // TransactionalState with the above txnId but has no outcome. Respond with a\n+            // TransactionalState with Accepted outcome.\n+            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n+            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n+            messageMatcher.setMessageAnnotationsMatcher(new MessageAnnotationsSectionMatcher(true));\n+\n+            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            TransactionalState txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with rejected and settled disposition to indicate the commit failed\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(false);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Rejected(), true);\n+\n+            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            try {\n+                session.commit();\n+                fail(\"Commit operation should have failed.\");\n+            } catch (TransactionRolledBackException jmsTxRb) {\n+            }\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testProducedMessagesAfterCommitOfSentMessagesFails() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a Declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            // Create a producer to use in provoking creation of the AMQP transaction\n+            testPeer.expectSenderAttach();\n+            MessageProducer producer  = session.createProducer(queue);\n+\n+            // Expect the message which was sent under the current transaction. Check it carries\n+            // TransactionalState with the above txnId but has no outcome. Respond with a\n+            // TransactionalState with Accepted outcome.\n+            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n+            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n+            messageMatcher.setMessageAnnotationsMatcher(new MessageAnnotationsSectionMatcher(true));\n+\n+            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            TransactionalState txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with rejected and settled disposition to indicate the commit failed\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(false);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            Rejected commitFailure = new Rejected(new Error(Symbol.valueOf(\"failed\"), \"Unknown error\"));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, commitFailure, true);\n+\n+            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            try {\n+                session.commit();\n+                fail(\"Commit operation should have failed.\");\n+            } catch (TransactionRolledBackException jmsTxRb) {\n+            }\n+\n+            // Expect the message which was sent under the current transaction. Check it carries\n+            // TransactionalState with the above txnId but has no outcome. Respond with a\n+            // TransactionalState with Accepted outcome.\n+            stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testProducedMessagesAfterRollbackSentMessagesFails() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a Declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            // Create a producer to use in provoking creation of the AMQP transaction\n+            testPeer.expectSenderAttach();\n+            MessageProducer producer  = session.createProducer(queue);\n+\n+            // Expect the message which was sent under the current transaction. Check it carries\n+            // TransactionalState with the above txnId but has no outcome. Respond with a\n+            // TransactionalState with Accepted outcome.\n+            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n+            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n+            messageMatcher.setMessageAnnotationsMatcher(new MessageAnnotationsSectionMatcher(true));\n+\n+            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            TransactionalState txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with rejected and settled disposition to indicate the rollback failed\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(true);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            Rejected commitFailure = new Rejected(new Error(Symbol.valueOf(\"failed\"), \"Unknown error\"));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, commitFailure, true);\n+\n+            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            try {\n+                session.rollback();\n+                fail(\"Rollback operation should have failed.\");\n+            } catch (JMSException jmsex) {\n+            }\n+\n+            // Expect the message which was sent under the current transaction. Check it carries\n+            // TransactionalState with the above txnId but has no outcome. Respond with a\n+            // TransactionalState with Accepted outcome.\n+            stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testCommitTransactedSessionWithConsumerReceivingAllMessages() throws Exception {\n+        doCommitTransactedSessionWithConsumerTestImpl(1, 1);\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testCommitTransactedSessionWithConsumerReceivingSomeMessages() throws Exception {\n+        doCommitTransactedSessionWithConsumerTestImpl(5, 2);\n+    }\n+\n+    private void doCommitTransactedSessionWithConsumerTestImpl(int transferCount, int consumeCount) throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            testPeer.expectReceiverAttach();\n+            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"), transferCount);\n+\n+            for (int i = 1; i <= consumeCount; i++) {\n+                // Then expect an *settled* TransactionalState disposition for each message once received by the consumer\n+                TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+                stateMatcher.withTxnId(equalTo(txnId));\n+                stateMatcher.withOutcome(new AcceptedMatcher());\n+\n+                testPeer.expectDisposition(true, stateMatcher);\n+            }\n+\n+            MessageConsumer messageConsumer = session.createConsumer(queue);\n+\n+            for (int i = 1; i <= consumeCount; i++) {\n+                Message receivedMessage = messageConsumer.receive(3000);\n+\n+                assertNotNull(receivedMessage);\n+                assertTrue(receivedMessage instanceof TextMessage);\n+            }\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with accepted and settled disposition to indicate the commit succeeded\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(false);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n+\n+            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 1, (byte) 2, (byte) 3, (byte) 4});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            session.commit();\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testProducedMessagesOnTransactedSessionCarryTxnId() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a Declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            // Create a producer to use in provoking creation of the AMQP transaction\n+            testPeer.expectSenderAttach();\n+            MessageProducer producer  = session.createProducer(queue);\n+\n+            // Expect the message which was sent under the current transaction. Check it carries\n+            // TransactionalState with the above txnId but has no outcome. Respond with a\n+            // TransactionalState with Accepted outcome.\n+            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n+            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n+            messageMatcher.setMessageAnnotationsMatcher(new MessageAnnotationsSectionMatcher(true));\n+\n+            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            TransactionalState txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testRollbackTransactedSessionWithConsumerReceivingAllMessages() throws Exception {\n+        doRollbackTransactedSessionWithConsumerTestImpl(1, 1);\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testRollbackTransactedSessionWithConsumerReceivingSomeMessages() throws Exception {\n+        doRollbackTransactedSessionWithConsumerTestImpl(5, 2);\n+    }\n+\n+    private void doRollbackTransactedSessionWithConsumerTestImpl(int transferCount, int consumeCount) throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            testPeer.expectReceiverAttach();\n+            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"), transferCount);\n+\n+            for (int i = 1; i <= consumeCount; i++) {\n+                // Then expect a *settled* TransactionalState disposition for each message once received by the consumer\n+                TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+                stateMatcher.withTxnId(equalTo(txnId));\n+                stateMatcher.withOutcome(new AcceptedMatcher());\n+\n+                testPeer.expectDisposition(true, stateMatcher);\n+            }\n+\n+            MessageConsumer messageConsumer = session.createConsumer(queue);\n+\n+            for (int i = 1; i <= consumeCount; i++) {\n+                Message receivedMessage = messageConsumer.receive(3000);\n+\n+                assertNotNull(receivedMessage);\n+                assertTrue(receivedMessage instanceof TextMessage);\n+            }\n+\n+            // Expect the consumer to be 'stopped' prior to rollback by issuing a 'drain'\n+            testPeer.expectLinkFlow(true, true, greaterThan(UnsignedInteger.ZERO));\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with accepted and settled disposition to indicate the rollback succeeded\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(true);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n+\n+            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            // Expect the messages that were not consumed to be released\n+            int unconsumed = transferCount - consumeCount;\n+            for (int i = 1; i <= unconsumed; i++) {\n+                testPeer.expectDisposition(true, new ReleasedMatcher());\n+            }\n+\n+            // Expect the consumer to be 'started' again as rollback completes\n+            testPeer.expectLinkFlow(false, false, greaterThan(UnsignedInteger.ZERO));\n+\n+            session.rollback();\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testRollbackTransactedSessionWithPrefetchFullBeforeStoppingConsumer() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            int messageCount = 5;\n+            ((JmsConnection) connection).getPrefetchPolicy().setAll(messageCount);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            // Create a consumer and fill the prefetch with messages, which we wont consume any of\n+            testPeer.expectReceiverAttach();\n+            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"), messageCount);\n+\n+            session.createConsumer(queue);\n+\n+            // Create a producer to use in provoking creation of the AMQP transaction\n+            testPeer.expectSenderAttach();\n+            MessageProducer producer  = session.createProducer(queue);\n+\n+            // Expect the message which provoked creating the transaction\n+            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n+            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n+            messageMatcher.setMessageAnnotationsMatcher( new MessageAnnotationsSectionMatcher(true));\n+            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            TransactionalState txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            // The consumer will be 'stopped' prior to rollback, however we will NOT send a 'drain' Flow\n+            // frame as we have manipulated that all the credit was already used, i.e. it already stopped.\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with accepted and settled disposition to indicate the rollback succeeded\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(true);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n+\n+            // Now expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            // Expect the messages that were not consumed to be released\n+            for (int i = 1; i <= messageCount; i++) {\n+                testPeer.expectDisposition(true, new ReleasedMatcher());\n+            }\n+\n+            // Expect the consumer to be 'started' again as rollback completes\n+            testPeer.expectLinkFlow(false, false, equalTo(UnsignedInteger.valueOf(messageCount)));\n+\n+            session.rollback();\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testRollbackTransactedSessionWithPrefetchFullyUtilisedByDrainWhenStoppingConsumer() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            int messageCount = 5;\n+            ((JmsConnection) connection).getPrefetchPolicy().setAll(messageCount);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Queue queue = session.createQueue(\"myQueue\");\n+\n+            // Create a consumer, expect it to flow credit, but don't send it any messages\n+            testPeer.expectReceiverAttach();\n+            testPeer.expectLinkFlow(false, false, equalTo(UnsignedInteger.valueOf(messageCount)));\n+\n+            session.createConsumer(queue);\n+\n+            // Create a producer to use in provoking creation of the AMQP transaction\n+            testPeer.expectSenderAttach();\n+            MessageProducer producer  = session.createProducer(queue);\n+\n+            // Expect the message which provoked creating the transaction\n+            TransferPayloadCompositeMatcher messageMatcher = new TransferPayloadCompositeMatcher();\n+            messageMatcher.setHeadersMatcher(new MessageHeaderSectionMatcher(true));\n+            messageMatcher.setMessageAnnotationsMatcher( new MessageAnnotationsSectionMatcher(true));\n+\n+            TransactionalStateMatcher stateMatcher = new TransactionalStateMatcher();\n+            stateMatcher.withTxnId(equalTo(txnId));\n+            stateMatcher.withOutcome(nullValue());\n+\n+            TransactionalState txState = new TransactionalState();\n+            txState.setTxnId(txnId);\n+            txState.setOutcome(new Accepted());\n+\n+            testPeer.expectTransfer(messageMatcher, stateMatcher, false, txState, true);\n+\n+            producer.send(session.createMessage());\n+\n+            // Expect the consumer to be 'stopped' prior to rollback by issuing a 'drain' Flow.\n+            // Action the drain by filling the prefetch (which is equivalent to this having happened while\n+            // the Flow was in flight to the peer), and then DONT send a flow frame back to the client\n+            // as it can tell from the messages that all the credit has been used.\n+            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(\"content\"),\n+                                                       messageCount, true, false, equalTo(UnsignedInteger.valueOf(messageCount)), 1, false);\n+\n+            // Expect an unsettled 'discharge' transfer to the txn coordinator containing the txnId,\n+            // and reply with accepted and settled disposition to indicate the rollback succeeded\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(true);\n+            discharge.setTxnId(txnId);\n+            TransferPayloadCompositeMatcher dischargeMatcher = new TransferPayloadCompositeMatcher();\n+            dischargeMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(discharge));\n+            testPeer.expectTransfer(dischargeMatcher, nullValue(), false, new Accepted(), true);\n+\n+            // Then expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            // Expect the messages that were not consumed to be released\n+            for (int i = 1; i <= messageCount; i++) {\n+                testPeer.expectDisposition(true, new ReleasedMatcher());\n+            }\n+\n+            // Expect the consumer to be 'started' again as rollback completes\n+            testPeer.expectLinkFlow(false, false, equalTo(UnsignedInteger.valueOf(messageCount)));\n+\n+            session.rollback();\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testDefaultOutcomeIsModifiedForConsumerSourceOnTransactedSession() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            CoordinatorMatcher txCoordinatorMatcher = new CoordinatorMatcher();\n+            testPeer.expectSenderAttach(txCoordinatorMatcher, false, false);\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a declared disposition state containing the txnId.\n+            Binary txnId = new Binary(new byte[]{ (byte) 5, (byte) 6, (byte) 7, (byte) 8});\n+            TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+            declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+            testPeer.expectTransfer(declareMatcher, nullValue(), false, new Declared().setTxnId(txnId), true);\n+\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            String queueName = \"myQueue\";\n+            Queue queue = session.createQueue(queueName);\n+\n+            SourceMatcher sourceMatcher = new SourceMatcher();\n+            sourceMatcher.withAddress(equalTo(queueName));\n+            sourceMatcher.withDynamic(equalTo(false));\n+            sourceMatcher.withOutcomes(arrayContaining(Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL, Released.DESCRIPTOR_SYMBOL, Modified.DESCRIPTOR_SYMBOL));\n+            ModifiedMatcher outcomeMatcher = new ModifiedMatcher().withDeliveryFailed(equalTo(true)).withUndeliverableHere(nullValue());\n+            sourceMatcher.withDefaultOutcome(outcomeMatcher);\n+\n+            testPeer.expectReceiverAttach(notNullValue(), sourceMatcher);\n+            testPeer.expectLinkFlow();\n+\n+            session.createConsumer(queue);\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+}",
                "raw_url": "https://github.com/apache/qpid-jms/raw/0fd981ca1397607362c0c89920017fded813cec1/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java",
                "sha": "947700b58fba518ee87cb134be823c8dde7c9923",
                "status": "added"
            }
        ],
        "message": "QPIDJMS-125 Fix an potential NPE when a TX Discharge fails with rejected\nthat has a null error.  Fix issue with auto-starting new TX after commit\nor rollback fails.  Adds some tests to cover the above plus moves TX\ntests into their own JUnit test.",
        "parent": "https://github.com/apache/qpid-jms/commit/f5b8f9fc2ab5c4365aa12af4eaeff2451abe6f02",
        "patched_files": [
            "AmqpTransactionContext.java",
            "JmsLocalTransactionContext.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "SessionIntegrationTest.java",
            "TransactionsIntegrationTest.java"
        ]
    },
    "qpid-jms_125d72b": {
        "bug_id": "qpid-jms_125d72b",
        "commit": "https://github.com/apache/qpid-jms/commit/125d72b2a8b05ac7c8f9bbad599ed217107922f8",
        "file": [
            {
                "additions": 6,
                "blob_url": "https://github.com/apache/qpid-jms/blob/125d72b2a8b05ac7c8f9bbad599ed217107922f8/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java",
                "changes": 11,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java?ref=125d72b2a8b05ac7c8f9bbad599ed217107922f8",
                "deletions": 5,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java",
                "patch": "@@ -190,6 +190,12 @@ public void run() {\n                         }\n                     } catch (Exception e) {\n                         LOG.debug(\"Caught exception while closing proton connection: {}\", e.getMessage());\n+                    } finally {\n+                        if (nextIdleTimeoutCheck != null) {\n+                            LOG.trace(\"Cancelling scheduled IdleTimeoutCheck\");\n+                            nextIdleTimeoutCheck.cancel(false);\n+                            nextIdleTimeoutCheck = null;\n+                        }\n                     }\n                 }\n             });\n@@ -211,11 +217,6 @@ public void run() {\n                     }\n                 }\n \n-                if (nextIdleTimeoutCheck != null) {\n-                    LOG.trace(\"Cancelling IdleTimeoutCheck\");\n-                    nextIdleTimeoutCheck.cancel(false);\n-                    nextIdleTimeoutCheck = null;\n-                }\n                 serializer.shutdown();\n             }\n         }",
                "raw_url": "https://github.com/apache/qpid-jms/raw/125d72b2a8b05ac7c8f9bbad599ed217107922f8/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java",
                "sha": "6a1597d06b96d90505135fcbacbde6e0cb0d8195",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-45: move the cancellation into the executor so it occurs earlier, and additionally avoids a potential NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/d33ea1d542b6b363388f860a2e0f5996eefe4d97",
        "patched_files": [
            "AmqpProvider.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "AmqpProviderTest.java"
        ]
    },
    "qpid-jms_1bd30ca": {
        "bug_id": "qpid-jms_1bd30ca",
        "commit": "https://github.com/apache/qpid-jms/commit/1bd30cab4c53ad9da3c6d39a5e7081e7a127081e",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/qpid-jms/blob/1bd30cab4c53ad9da3c6d39a5e7081e7a127081e/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java?ref=1bd30cab4c53ad9da3c6d39a5e7081e7a127081e",
                "deletions": 1,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "patch": "@@ -933,7 +933,9 @@ public void onPendingFailure(Throwable cause) {\n             }\n         } catch (JMSException jmsEx) {\n             // Ensure that on failure case the message is returned to usable state for another send attempt.\n-            outbound.onSendComplete();\n+            if(outbound != null) {\n+                outbound.onSendComplete();\n+            }\n             throw jmsEx;\n         } finally {\n             sendLock.unlock();",
                "raw_url": "https://github.com/apache/qpid-jms/raw/1bd30cab4c53ad9da3c6d39a5e7081e7a127081e/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "sha": "b69ec352774290fcbe987de1df7bb67c911e11a7",
                "status": "modified"
            },
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/qpid-jms/blob/1bd30cab4c53ad9da3c6d39a5e7081e7a127081e/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ProducerIntegrationTest.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ProducerIntegrationTest.java?ref=1bd30cab4c53ad9da3c6d39a5e7081e7a127081e",
                "deletions": 2,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ProducerIntegrationTest.java",
                "patch": "@@ -3160,15 +3160,16 @@ public void onException(JMSException exception) {\n             }\n \n             // --- Post Reconnection Expectations of this test\n+\n+            // Reconnect to another peer and send the message object again which should work\n+            // without need to reset the message or otherwise account for past send failure.\n             connection = (JmsConnection) testFixture.establishConnecton(finalPeer);\n \n             finalPeer.expectBegin();\n             finalPeer.expectSenderAttach();\n             finalPeer.expectTransfer(new TransferPayloadCompositeMatcher(), nullValue(), new Accepted(), true);\n             finalPeer.expectClose();\n \n-            // Reconnect to another peer and send the failed message again which should work\n-            // without need to reset or otherwise account for past failure.\n             session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n             queue = session.createQueue(\"myQueue\");\n             producer = session.createProducer(queue);",
                "raw_url": "https://github.com/apache/qpid-jms/raw/1bd30cab4c53ad9da3c6d39a5e7081e7a127081e/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ProducerIntegrationTest.java",
                "sha": "30400224b54def8cf43e2482b4c0abc60dfab6b6",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-457: protect against potential NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/30f5132b2c28ff29023bdd00153c34385a3e2e31",
        "patched_files": [
            "JmsSession.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "ProducerIntegrationTest.java",
            "JmsSessionTest.java"
        ]
    },
    "qpid-jms_250d2ba": {
        "bug_id": "qpid-jms_250d2ba",
        "commit": "https://github.com/apache/qpid-jms/commit/250d2ba48c1d3bd9eacbe4b8036dc3cad49b0649",
        "file": [
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/qpid-jms/blob/250d2ba48c1d3bd9eacbe4b8036dc3cad49b0649/qpid-jms-interop-tests/qpid-jms-activemq-tests/src/test/java/org/apache/qpid/jms/failover/JmsTxConsumerFailoverTest.java",
                "changes": 20,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-interop-tests/qpid-jms-activemq-tests/src/test/java/org/apache/qpid/jms/failover/JmsTxConsumerFailoverTest.java?ref=250d2ba48c1d3bd9eacbe4b8036dc3cad49b0649",
                "deletions": 10,
                "filename": "qpid-jms-interop-tests/qpid-jms-activemq-tests/src/test/java/org/apache/qpid/jms/failover/JmsTxConsumerFailoverTest.java",
                "patch": "@@ -86,8 +86,8 @@ public boolean isSatisified() throws Exception {\n         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(50)));\n \n         for (int i = 0; i < MSG_COUNT; ++i) {\n-            Message received = consumer.receive(1000);\n-            assertNotNull(received);\n+            Message received = consumer.receive(3000);\n+            assertNotNull(\"Mesage was not expected but not received\", received);\n         }\n \n         try {\n@@ -117,8 +117,8 @@ public void testTxConsumerReceiveThenFailoverCommitFails() throws Exception {\n         assertEquals(MSG_COUNT, proxy.getQueueSize());\n \n         for (int i = 0; i < MSG_COUNT; ++i) {\n-            Message received = consumer.receive(1000);\n-            assertNotNull(received);\n+            Message received = consumer.receive(3000);\n+            assertNotNull(\"Mesage was not expected but not received\", received);\n         }\n \n         stopPrimaryBroker();\n@@ -154,8 +154,8 @@ public void testTxConsumerRollbackAfterFailoverGetsNoErrors() throws Exception {\n         assertEquals(MSG_COUNT, proxy.getQueueSize());\n \n         for (int i = 0; i < MSG_COUNT; ++i) {\n-            Message received = consumer.receive(1000);\n-            assertNotNull(received);\n+            Message received = consumer.receive(3000);\n+            assertNotNull(\"Mesage was not expected but not received\", received);\n         }\n \n         proxy = getProxyToQueue(name.getMethodName());\n@@ -198,9 +198,9 @@ public void testTxConsumerReceiveWorksAfterFailoverButCommitFails() throws Excep\n         assertEquals(MSG_COUNT, proxy.getQueueSize());\n \n         for (int i = 0; i < MSG_COUNT / 2; ++i) {\n-            Message received = consumer.receive(1000);\n+            Message received = consumer.receive(3000);\n+            assertNotNull(\"Mesage was not expected but not received\", received);\n             LOG.info(\"consumer received message #{} - {}\", i + 1, received.getJMSMessageID());\n-            assertNotNull(received);\n         }\n \n         assertEquals(MSG_COUNT, proxy.getQueueSize());\n@@ -212,9 +212,9 @@ public void testTxConsumerReceiveWorksAfterFailoverButCommitFails() throws Excep\n         assertEquals(MSG_COUNT, proxy.getQueueSize());\n \n         for (int i = 0; i < MSG_COUNT / 2; ++i) {\n-            Message received = consumer.receive(1000);\n+            Message received = consumer.receive(3000);\n+            assertNotNull(\"Mesage was not expected but not received\", received);\n             LOG.info(\"consumer received message #{} - {}\", i + 1, received.getJMSMessageID());\n-            assertNotNull(received);\n         }\n \n         try {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/250d2ba48c1d3bd9eacbe4b8036dc3cad49b0649/qpid-jms-interop-tests/qpid-jms-activemq-tests/src/test/java/org/apache/qpid/jms/failover/JmsTxConsumerFailoverTest.java",
                "sha": "81e894854295648edcfe55dbf3e977ee789645dd",
                "status": "modified"
            }
        ],
        "message": "NO-JIRA: increase receive timeouts to be more lenient of slower CI boxes, move assertions to prevent NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/776de4c25a177780c4a65a13b7992234ccd6c0a6",
        "patched_files": [],
        "repo": "qpid-jms",
        "unit_tests": [
            "JmsTxConsumerFailoverTest.java"
        ]
    },
    "qpid-jms_28b3810": {
        "bug_id": "qpid-jms_28b3810",
        "commit": "https://github.com/apache/qpid-jms/commit/28b3810a11bb0c1a5b3033b90bdc25344116b564",
        "file": [
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/qpid-jms/blob/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsProducer.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsProducer.java?ref=28b3810a11bb0c1a5b3033b90bdc25344116b564",
                "deletions": 0,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsProducer.java",
                "patch": "@@ -34,6 +34,7 @@\n import javax.jms.JMSProducer;\n import javax.jms.MapMessage;\n import javax.jms.Message;\n+import javax.jms.MessageFormatException;\n import javax.jms.ObjectMessage;\n import javax.jms.TextMessage;\n \n@@ -149,6 +150,10 @@ public JMSProducer send(Destination destination, String body) {\n \n     private void doSend(Destination destination, Message message) throws JMSException {\n \n+        if (message == null) {\n+            throw new MessageFormatException(\"Message must not be null\");\n+        }\n+\n         for (Map.Entry<String, Object> entry : messageProperties.entrySet()) {\n             message.setObjectProperty(entry.getKey(), entry.getValue());\n         }",
                "raw_url": "https://github.com/apache/qpid-jms/raw/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsProducer.java",
                "sha": "307100935e6d3a007431a90b4d26c521bd61c216",
                "status": "modified"
            },
            {
                "additions": 5,
                "blob_url": "https://github.com/apache/qpid-jms/blob/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "changes": 5,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java?ref=28b3810a11bb0c1a5b3033b90bdc25344116b564",
                "deletions": 0,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "patch": "@@ -44,6 +44,7 @@\n import javax.jms.MapMessage;\n import javax.jms.Message;\n import javax.jms.MessageConsumer;\n+import javax.jms.MessageFormatException;\n import javax.jms.MessageListener;\n import javax.jms.MessageProducer;\n import javax.jms.ObjectMessage;\n@@ -715,6 +716,10 @@ protected void send(JmsMessageProducer producer, Destination dest, Message msg,\n             throw new InvalidDestinationException(\"Destination must not be null\");\n         }\n \n+        if (msg == null) {\n+            throw new MessageFormatException(\"Message must not be null\");\n+        }\n+\n         JmsDestination destination = JmsMessageTransformation.transformDestination(connection, dest);\n \n         if (destination.isTemporary() && ((JmsTemporaryDestination) destination).isDeleted()) {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "sha": "e6c85cc892d0efbf2ee40e80ca0df8e48011fa2a",
                "status": "modified"
            },
            {
                "additions": 69,
                "blob_url": "https://github.com/apache/qpid-jms/blob/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsMessageProducerTest.java",
                "changes": 69,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsMessageProducerTest.java?ref=28b3810a11bb0c1a5b3033b90bdc25344116b564",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsMessageProducerTest.java",
                "patch": "@@ -36,6 +36,7 @@\n import javax.jms.InvalidDestinationException;\n import javax.jms.JMSException;\n import javax.jms.Message;\n+import javax.jms.MessageFormatException;\n import javax.jms.MessageProducer;\n import javax.jms.Session;\n \n@@ -327,6 +328,74 @@ public void testExplicitProducerThrowsIAEWhenNullCompletionListenerIsProvided()\n         }\n     }\n \n+    @Test(timeout = 10000)\n+    public void testAnonymousProducerThrowsMFEWhenNullMessageProvided() throws Exception {\n+        JmsDestination dest = new JmsQueue(\"explicitDestination\");\n+        JmsMessageProducer producer = (JmsMessageProducer) session.createProducer(null);\n+\n+        try {\n+            producer.send(dest, (Message) null);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+\n+        try {\n+            producer.send(dest, (Message) null, completionListener);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+\n+        try {\n+            producer.send(dest, (Message) null, Message.DEFAULT_DELIVERY_MODE, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+\n+        try {\n+            producer.send(dest, (Message) null, Message.DEFAULT_DELIVERY_MODE, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE, completionListener);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testExplicitProducerThrowsMFEWhenNullMessageProvided() throws Exception {\n+        JmsDestination dest = new JmsQueue(\"explicitDestination\");\n+        JmsMessageProducer producer = (JmsMessageProducer) session.createProducer(dest);\n+\n+        try {\n+            producer.send((Message) null);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+\n+        try {\n+            producer.send((Message) null, completionListener);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+\n+        try {\n+            producer.send((Message) null, Message.DEFAULT_DELIVERY_MODE, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+\n+        try {\n+            producer.send((Message) null, Message.DEFAULT_DELIVERY_MODE, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE, completionListener);\n+            fail(\"Expected exception not thrown\");\n+        } catch (MessageFormatException mfe) {\n+            // expected\n+        }\n+    }\n+\n     @Test(timeout = 10000)\n     public void testInOrderSendAcksCompletionsReturnInOrder() throws Exception {\n         final int MESSAGE_COUNT = 3;",
                "raw_url": "https://github.com/apache/qpid-jms/raw/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsMessageProducerTest.java",
                "sha": "c0c92c315ce21d222d4906944ff65e8b3095d765",
                "status": "modified"
            },
            {
                "additions": 16,
                "blob_url": "https://github.com/apache/qpid-jms/blob/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsProducerTest.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsProducerTest.java?ref=28b3810a11bb0c1a5b3033b90bdc25344116b564",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsProducerTest.java",
                "patch": "@@ -813,6 +813,22 @@ public void testTimeToLive() {\n \n     //----- Test Send Methods -----------------------------------------------//\n \n+    @Test\n+    public void testSendNullMessageThrowsMFRE() throws JMSException {\n+        JmsSession session = Mockito.mock(JmsSession.class);\n+        JmsMessageProducer messageProducer = Mockito.mock(JmsMessageProducer.class);\n+\n+        JmsProducer producer = new JmsProducer(session, messageProducer);\n+\n+        try {\n+            producer.send(JMS_DESTINATION, (Message) null);\n+            fail(\"Should throw a MessageFormatRuntimeException\");\n+        } catch (MessageFormatRuntimeException mfre) {\n+        } catch (Exception e) {\n+            fail(\"Should throw a MessageFormatRuntimeException\");\n+        }\n+    }\n+\n     @Test\n     public void testSendJMSMessage() throws JMSException {\n         JmsSession session = Mockito.mock(JmsSession.class);",
                "raw_url": "https://github.com/apache/qpid-jms/raw/28b3810a11bb0c1a5b3033b90bdc25344116b564/qpid-jms-client/src/test/java/org/apache/qpid/jms/producer/JmsProducerTest.java",
                "sha": "5cc381ed12c704e11f04c2a345ce9c9cb864546d",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-207 Handle null message passed to send calls\n\nThrow the correct exception when a null message gets passed to a send\nmethod (MessageFormatException) instead of waiting to hit an NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/fdedbd2469b73d5de87a084824419a631e0fbb18",
        "patched_files": [
            "JmsProducer.java",
            "JmsSession.java",
            "JmsMessageProducer.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "JmsProducerTest.java",
            "JmsMessageProducerTest.java",
            "JmsSessionTest.java"
        ]
    },
    "qpid-jms_75f3cf8": {
        "bug_id": "qpid-jms_75f3cf8",
        "commit": "https://github.com/apache/qpid-jms/commit/75f3cf8d2b94f495af6c130856ae8a9904ce670b",
        "file": [
            {
                "additions": 38,
                "blob_url": "https://github.com/apache/qpid-jms/blob/75f3cf8d2b94f495af6c130856ae8a9904ce670b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsQueueBrowser.java",
                "changes": 78,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsQueueBrowser.java?ref=75f3cf8d2b94f495af6c130856ae8a9904ce670b",
                "deletions": 40,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsQueueBrowser.java",
                "patch": "@@ -23,6 +23,7 @@\n import javax.jms.IllegalStateException;\n import javax.jms.JMSException;\n import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n import javax.jms.Queue;\n import javax.jms.QueueBrowser;\n \n@@ -61,7 +62,7 @@\n     private final JmsDestination destination;\n     private final String selector;\n \n-    private JmsMessageConsumer consumer;\n+    private volatile JmsMessageConsumer consumer;\n \n     private Message next;\n     private final AtomicBoolean closed = new AtomicBoolean();\n@@ -84,18 +85,6 @@ protected JmsQueueBrowser(JmsSession session, JmsDestination destination, String\n         this.selector = selector;\n     }\n \n-    private void destroyConsumer() {\n-        if (consumer == null) {\n-            return;\n-        }\n-        try {\n-            consumer.close();\n-            consumer = null;\n-        } catch (JMSException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n     /**\n      * Gets an enumeration for browsing the current queue messages in the order they would be\n      * received.\n@@ -108,16 +97,9 @@ private void destroyConsumer() {\n     @Override\n     public Enumeration<Message> getEnumeration() throws JMSException {\n         checkClosed();\n-        if (consumer == null) {\n-            consumer = createConsumer();\n-        }\n-        return this;\n-    }\n+        createConsumer();\n \n-    private void checkClosed() throws IllegalStateException {\n-        if (closed.get()) {\n-            throw new IllegalStateException(\"The Consumer is closed\");\n-        }\n+        return this;\n     }\n \n     /**\n@@ -126,10 +108,9 @@ private void checkClosed() throws IllegalStateException {\n     @Override\n     public boolean hasMoreElements() {\n         while (true) {\n-            synchronized (this) {\n-                if (consumer == null) {\n-                    return false;\n-                }\n+            MessageConsumer consumer = this.consumer;\n+            if (consumer == null) {\n+                return false;\n             }\n \n             if (next == null) {\n@@ -160,11 +141,6 @@ public boolean hasMoreElements() {\n      */\n     @Override\n     public Message nextElement() {\n-        synchronized (this) {\n-            if (consumer == null) {\n-                return null;\n-            }\n-        }\n \n         if (hasMoreElements()) {\n             Message message = next;\n@@ -195,7 +171,6 @@ public void close() throws JMSException {\n      *         if the JMS provider fails to get the queue associated with this browser due to\n      *         some internal error.\n      */\n-\n     @Override\n     public Queue getQueue() throws JMSException {\n         return (Queue) destination;\n@@ -212,15 +187,38 @@ public String toString() {\n         return \"JmsQueueBrowser { value=\" + (consumer != null ? consumer.getConsumerId() : \"null\") + \" }\";\n     }\n \n-    private JmsMessageConsumer createConsumer() throws JMSException {\n-        JmsMessageConsumer rc = new JmsMessageConsumer(session.getNextConsumerId(), session, destination, selector, false) {\n+    private void checkClosed() throws IllegalStateException {\n+        if (closed.get()) {\n+            throw new IllegalStateException(\"The Consumer is closed\");\n+        }\n+    }\n \n-            @Override\n-            public boolean isBrowser() {\n-                return true;\n+    private synchronized void destroyConsumer() {\n+        synchronized (this) {\n+            try {\n+                if (consumer != null) {\n+                    consumer.close();\n+                    consumer = null;\n+                }\n+            } catch (JMSException e) {\n+                LOG.warn(\"Error closing down internal consumer: \", e);\n             }\n-        };\n-        rc.init();\n-        return rc;\n+        }\n+    }\n+\n+    private synchronized void createConsumer() throws JMSException {\n+        if (consumer == null) {\n+            JmsMessageConsumer result = new JmsMessageConsumer(session.getNextConsumerId(), session, destination, selector, false) {\n+\n+                @Override\n+                public boolean isBrowser() {\n+                    return true;\n+                }\n+            };\n+            result.init();\n+\n+            // Assign only after fully created and initialized.\n+            consumer = result;\n+        }\n     }\n }",
                "raw_url": "https://github.com/apache/qpid-jms/raw/75f3cf8d2b94f495af6c130856ae8a9904ce670b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsQueueBrowser.java",
                "sha": "af1096b8668a94fbad8cae50a83acfa93176bff8",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-123 Add additional protections from possible NPE on concurrent\naccess.",
        "parent": "https://github.com/apache/qpid-jms/commit/fa7445ffb7de15b57975762233d67326e49d7344",
        "patched_files": [
            "JmsQueueBrowser.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "JmsQueueBrowserTest.java"
        ]
    },
    "qpid-jms_a02c533": {
        "bug_id": "qpid-jms_a02c533",
        "commit": "https://github.com/apache/qpid-jms/commit/a02c533a6a7184c0243025f8eebc67edb68643a4",
        "file": [
            {
                "additions": 3,
                "blob_url": "https://github.com/apache/qpid-jms/blob/a02c533a6a7184c0243025f8eebc67edb68643a4/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java?ref=a02c533a6a7184c0243025f8eebc67edb68643a4",
                "deletions": 1,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "patch": "@@ -696,7 +696,9 @@ public void run() {\n                         LOG.info(\"Connection attempt:[{}] to: {} failed\", reconnectAttempts, target);\n                         failure = e;\n                         try {\n-                            provider.close();\n+                            if (provider != null) {\n+                                provider.close();\n+                            }\n                         } catch (Throwable ex) {}\n                     }\n                 } else {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/a02c533a6a7184c0243025f8eebc67edb68643a4/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "sha": "fa20ee12a7252051b5e3ffec0249c3f506f2eb98",
                "status": "modified"
            }
        ],
        "message": "/QPIDJMS-168 fix potential NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/c99ea859d3d6a8015ead5fc99c19dd64c6f0a07c",
        "patched_files": [
            "FailoverProvider.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "FailoverProviderTest.java"
        ]
    },
    "qpid-jms_a7907e0": {
        "bug_id": "qpid-jms_a7907e0",
        "commit": "https://github.com/apache/qpid-jms/commit/a7907e0981bc8f0d332c88a1f19e937135bda5d4",
        "file": [
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/qpid-jms/blob/a7907e0981bc8f0d332c88a1f19e937135bda5d4/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/amqp/message/AmqpJmsMessageFacadeTest.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/amqp/message/AmqpJmsMessageFacadeTest.java?ref=a7907e0981bc8f0d332c88a1f19e937135bda5d4",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/amqp/message/AmqpJmsMessageFacadeTest.java",
                "patch": "@@ -141,6 +141,7 @@ public void testSetGetTtlOverrideOnNewMessage() throws Exception {\n         AmqpJmsMessageFacade amqpMessageFacade = createNewMessageFacade();\n \n         assertFalse(\"Should not have a ttl override\", amqpMessageFacade.hasAmqpTimeToLiveOverride());\n+        assertEquals(0, amqpMessageFacade.getAmqpTimeToLiveOverride());\n \n         amqpMessageFacade.setAmqpTimeToLiveOverride(ttl);\n ",
                "raw_url": "https://github.com/apache/qpid-jms/raw/a7907e0981bc8f0d332c88a1f19e937135bda5d4/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/amqp/message/AmqpJmsMessageFacadeTest.java",
                "sha": "7acc3d5568600bbab81818b7a64fa96d60b896b6",
                "status": "modified"
            }
        ],
        "message": "Add additional check to ensure that when the value is null we don't NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/4b04d693abcdd336021903bc8cd56ab5588e503d",
        "patched_files": [
            "AmqpJmsMessageFacade.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "AmqpJmsMessageFacadeTest.java"
        ]
    },
    "qpid-jms_cc00816": {
        "bug_id": "qpid-jms_cc00816",
        "commit": "https://github.com/apache/qpid-jms/commit/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d",
        "file": [
            {
                "additions": 13,
                "blob_url": "https://github.com/apache/qpid-jms/blob/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java?ref=cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d",
                "deletions": 2,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "patch": "@@ -142,8 +142,19 @@ protected JmsSession(JmsConnection connection, JmsSessionId sessionId, int ackno\n \n         connection.createResource(sessionInfo);\n \n-        // We always keep an open TX so start now.\n-        getTransactionContext().begin();\n+        // We always keep an open TX if transacted so start now.\n+        try {\n+            getTransactionContext().begin();\n+        } catch (Exception e) {\n+            // failed, close the AMQP session before we throw\n+            try {\n+                connection.destroyResource(sessionInfo);\n+            } catch (Exception ex) {\n+                // Ignore, throw original error\n+            }\n+\n+            throw e;\n+        }\n \n         // Start the completion executor now as it's needed throughout the\n         // lifetime of the Session.",
                "raw_url": "https://github.com/apache/qpid-jms/raw/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java",
                "sha": "a821c187487ae9cddfd56f85c23c1212e68c00d4",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/qpid-jms/blob/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionCoordinator.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionCoordinator.java?ref=cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d",
                "deletions": 2,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionCoordinator.java",
                "patch": "@@ -90,7 +90,7 @@ public void processDeliveryUpdates(AmqpProvider provider, Delivery delivery) thr\n                     Exception cause = AmqpSupport.convertToException(\n                         getParent().getProvider(), getEndpoint(), rejected.getError());\n                     JMSException failureCause = null;\n-                    if (txId.getProviderContext().equals(COMMIT_MARKER)) {\n+                    if (COMMIT_MARKER.equals(txId.getProviderContext())){\n                         failureCause = new TransactionRolledBackException(cause.getMessage());\n                     } else {\n                         failureCause = new JMSException(cause.getMessage());\n@@ -133,7 +133,7 @@ public void declare(JmsTransactionId txId, AsyncResult request) throws Exception\n         Declare declare = new Declare();\n         message.setBody(new AmqpValue(declare));\n \n-        ScheduledFuture<?> timeout = scheduleTimeoutIfNeeded(\"Timed out waiting for discharge of TX.\", request);\n+        ScheduledFuture<?> timeout = scheduleTimeoutIfNeeded(\"Timed out waiting for declare of TX.\", request);\n         OperationContext context = new OperationContext(txId, request, timeout);\n \n         Delivery delivery = getEndpoint().delivery(tagGenerator.getNextTag());",
                "raw_url": "https://github.com/apache/qpid-jms/raw/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionCoordinator.java",
                "sha": "caf6921ee10e7aeaac76cc72ce3ea525175897d4",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/qpid-jms/blob/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java?ref=cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java",
                "patch": "@@ -258,6 +258,8 @@ public void testCreateTransactedSessionFailsWhenNoDetachResponseSent() throws Ex\n             txCoordinatorMatcher.withCapabilities(arrayContaining(TxnCapability.LOCAL_TXN));\n             testPeer.expectSenderAttach(notNullValue(), txCoordinatorMatcher, true, true, false, 0, null, null);\n             testPeer.expectDetach(true, false, false);\n+            // Expect the AMQP session to be closed due to the JMS session creation failure.\n+            testPeer.expectEnd();\n \n             try {\n                 connection.createSession(true, Session.SESSION_TRANSACTED);",
                "raw_url": "https://github.com/apache/qpid-jms/raw/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java",
                "sha": "3e12fd9851dcfa035b8968eebc31daebe71d7b79",
                "status": "modified"
            },
            {
                "additions": 63,
                "blob_url": "https://github.com/apache/qpid-jms/blob/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java",
                "changes": 63,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java?ref=cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java",
                "patch": "@@ -52,6 +52,7 @@\n import org.apache.qpid.jms.policy.JmsDefaultPrefetchPolicy;\n import org.apache.qpid.jms.test.QpidJmsTestCase;\n import org.apache.qpid.jms.test.testpeer.TestAmqpPeer;\n+import org.apache.qpid.jms.test.testpeer.basictypes.AmqpError;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Accepted;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Declare;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Declared;\n@@ -1251,6 +1252,8 @@ public void testSessionCreateFailsOnDeclareTimeout() throws Exception {\n             testPeer.expectBegin();\n             testPeer.expectCoordinatorAttach();\n             testPeer.expectDeclareButDoNotRespond();\n+            // Expect the AMQP session to be closed due to the JMS session creation failure.\n+            testPeer.expectEnd();\n \n             try {\n                 connection.createSession(true, Session.SESSION_TRANSACTED);\n@@ -1268,6 +1271,66 @@ public void testSessionCreateFailsOnDeclareTimeout() throws Exception {\n         }\n     }\n \n+    @Test(timeout=20000)\n+    public void testSessionCreateFailsOnDeclareRejection() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+            testPeer.expectCoordinatorAttach();\n+\n+            // First expect an unsettled 'declare' transfer to the txn coordinator, and\n+            // reply with a Rejected disposition state to indicate failure.\n+            testPeer.expectDeclareAndReject();\n+            // Expect the AMQP session to be closed due to the JMS session creation failure.\n+            testPeer.expectEnd();\n+\n+            try {\n+                connection.createSession(true, Session.SESSION_TRANSACTED);\n+                fail(\"should have thrown\");\n+            } catch (JMSException jmse) {\n+                // Expected\n+            }\n+\n+            testPeer.expectClose();\n+            connection.close();\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testSessionCreateFailsOnCoordinatorLinkRefusal() throws Exception {\n+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {\n+            Connection connection = testFixture.establishConnecton(testPeer);\n+            connection.start();\n+\n+            testPeer.expectBegin();\n+\n+            // Expect coordinator link, refuse it, expect detach reply\n+            String errorMessage = \"CoordinatorLinkRefusal-breadcrumb\";\n+            testPeer.expectCoordinatorAttach(true, false, AmqpError.NOT_IMPLEMENTED, errorMessage);\n+            testPeer.expectDetach(true, false, false);\n+\n+            // Expect the AMQP session to be closed due to the JMS session creation failure.\n+            testPeer.expectEnd();\n+\n+            try {\n+                connection.createSession(true, Session.SESSION_TRANSACTED);\n+                fail(\"should have thrown\");\n+            } catch (JMSException jmse) {\n+                assertNotNull(jmse.getMessage());\n+                assertTrue(\"Expected exception message to contain breadcrumb\", jmse.getMessage().contains(errorMessage));\n+            }\n+\n+            testPeer.expectClose();\n+            connection.close();\n+\n+            testPeer.waitForAllHandlersToComplete(1000);\n+        }\n+    }\n+\n     @Test(timeout=20000)\n     public void testTransactionRolledBackOnSessionCloseTimesOut() throws Exception {\n         try (TestAmqpPeer testPeer = new TestAmqpPeer();) {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/TransactionsIntegrationTest.java",
                "sha": "d026b2cdca071374906a51ac3904dc4c1aaf8869",
                "status": "modified"
            },
            {
                "additions": 9,
                "blob_url": "https://github.com/apache/qpid-jms/blob/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java",
                "changes": 9,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java?ref=cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java",
                "patch": "@@ -78,6 +78,7 @@\n import org.apache.qpid.jms.test.testpeer.describedtypes.FlowFrame;\n import org.apache.qpid.jms.test.testpeer.describedtypes.FrameDescriptorMapping;\n import org.apache.qpid.jms.test.testpeer.describedtypes.OpenFrame;\n+import org.apache.qpid.jms.test.testpeer.describedtypes.Rejected;\n import org.apache.qpid.jms.test.testpeer.describedtypes.Released;\n import org.apache.qpid.jms.test.testpeer.describedtypes.SaslChallengeFrame;\n import org.apache.qpid.jms.test.testpeer.describedtypes.SaslMechanismsFrame;\n@@ -2082,6 +2083,14 @@ public void expectDeclareButDoNotRespond()\n         expectTransfer(declareMatcher, nullValue(), false, false, null, false);\n     }\n \n+    public void expectDeclareAndReject()\n+    {\n+        TransferPayloadCompositeMatcher declareMatcher = new TransferPayloadCompositeMatcher();\n+        declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));\n+\n+        expectTransfer(declareMatcher, nullValue(), false, new Rejected(), true);\n+    }\n+\n     public void expectDischarge(Binary txnId, boolean dischargeState) {\n         expectDischarge(txnId, dischargeState, new Accepted());\n     }",
                "raw_url": "https://github.com/apache/qpid-jms/raw/cc00816c4d4cfca2bcc4f3ac71b86a0e1d53a36d/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java",
                "sha": "2e2c9af3541b058f0303d7a289674b06795aeef6",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-307: avoid NPE during declare rejection, ensure the AMQP session is closed before JMS createSession throws, correct exception message.",
        "parent": "https://github.com/apache/qpid-jms/commit/53d96e8a5162257894aaaf3951b4ce1d77e641ed",
        "patched_files": [
            "AmqpTransactionCoordinator.java",
            "JmsSession.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "ConnectionIntegrationTest.java",
            "TestAmqpPeer.java",
            "TransactionsIntegrationTest.java",
            "JmsSessionTest.java"
        ]
    },
    "qpid-jms_d0ccd40": {
        "bug_id": "qpid-jms_d0ccd40",
        "commit": "https://github.com/apache/qpid-jms/commit/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
        "file": [
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "changes": 4,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 2,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "patch": "@@ -113,11 +113,11 @@ public FailoverProvider(Map<String, String> nestedOptions) {\n         this(null, nestedOptions);\n     }\n \n-    public FailoverProvider(URI[] uris) {\n+    public FailoverProvider(List<URI> uris) {\n         this(uris, null);\n     }\n \n-    public FailoverProvider(URI[] uris, Map<String, String> nestedOptions) {\n+    public FailoverProvider(List<URI> uris, Map<String, String> nestedOptions) {\n         this.uris = new FailoverUriPool(uris, nestedOptions);\n \n         this.serializer = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "sha": "a080fb1f8467edfc12cb9558472e05d6af82fca7",
                "status": "modified"
            },
            {
                "additions": 2,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverUriPool.java",
                "changes": 3,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverUriPool.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 1,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverUriPool.java",
                "patch": "@@ -22,6 +22,7 @@\n import java.net.URISyntaxException;\n import java.util.Collections;\n import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n \n import org.apache.qpid.jms.util.URISupport;\n@@ -47,7 +48,7 @@ public FailoverUriPool() {\n         this.nestedOptions = Collections.emptyMap();\n     }\n \n-    public FailoverUriPool(URI[] uris, Map<String, String> nestedOptions) {\n+    public FailoverUriPool(List<URI> uris, Map<String, String> nestedOptions) {\n         this.uris = new LinkedList<URI>();\n         if (nestedOptions != null) {\n             this.nestedOptions = nestedOptions;",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverUriPool.java",
                "sha": "624c05a717cf3dc4ab91264362cbdf21917fa86b",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/URISupport.java",
                "changes": 15,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/URISupport.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 7,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/util/URISupport.java",
                "patch": "@@ -34,14 +34,15 @@\n      * the individual URIs that comprise the composite one.\n      */\n     public static class CompositeData {\n+\n         private String host;\n         private String scheme;\n         private String path;\n-        private URI components[];\n-        private Map<String, String> parameters;\n+        private List<URI> components = Collections.emptyList();\n+        private Map<String, String> parameters = Collections.emptyMap();\n         private String fragment;\n \n-        public URI[] getComponents() {\n+        public List<URI> getComponents() {\n             return components;\n         }\n \n@@ -76,11 +77,11 @@ public URI toURI() throws URISyntaxException {\n                 sb.append(host);\n             } else {\n                 sb.append('(');\n-                for (int i = 0; i < components.length; i++) {\n+                for (int i = 0; i < components.size(); i++) {\n                     if (i != 0) {\n                         sb.append(',');\n                     }\n-                    sb.append(components[i].toString());\n+                    sb.append(components.get(i).toString());\n                 }\n                 sb.append(')');\n             }\n@@ -173,9 +174,9 @@ private static void parseComposite(URI uri, CompositeData rc, String ssp) throws\n         }\n \n         String components[] = splitComponents(componentString);\n-        rc.components = new URI[components.length];\n+        rc.components = new ArrayList<URI>(components.length);\n         for (int i = 0; i < components.length; i++) {\n-            rc.components[i] = new URI(components[i].trim());\n+            rc.components.add(new URI(components[i].trim()));\n         }\n \n         p = params.indexOf(\"?\");",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/URISupport.java",
                "sha": "e2aaaa01b695dfc01f357133db72be1e28b84a05",
                "status": "modified"
            },
            {
                "additions": 8,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverUriPoolTest.java",
                "changes": 16,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverUriPoolTest.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 8,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverUriPoolTest.java",
                "patch": "@@ -71,7 +71,7 @@ public void testCreateEmptyPoolFromNullUris() {\n \n     @Test\n     public void testCreateEmptyPoolWithURIs() throws URISyntaxException {\n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n         assertEquals(FailoverUriPool.DEFAULT_RANDOMIZE_ENABLED, pool.isRandomize());\n \n         assertNotNull(pool.getNestedOptions());\n@@ -88,7 +88,7 @@ public void testGetNextFromEmptyPool() {\n \n     @Test\n     public void testGetNextFromSingleValuePool() {\n-        FailoverUriPool pool = new FailoverUriPool(new URI[] {uris.get(0) }, null);\n+        FailoverUriPool pool = new FailoverUriPool(uris.subList(0, 1), null);\n \n         assertEquals(uris.get(0), pool.getNext());\n         assertEquals(uris.get(0), pool.getNext());\n@@ -106,7 +106,7 @@ public void testAddUriToEmptyPool() {\n \n     @Test\n     public void testDuplicatesNotAdded() {\n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n \n         assertEquals(uris.size(), pool.size());\n         pool.add(uris.get(0));\n@@ -195,7 +195,7 @@ public void testDuplicatesNotAddedWhenQueryPresentAndUnresolveable() throws URIS\n     public void testAddUriToPoolRandomized() throws URISyntaxException {\n         URI newUri = new URI(\"tcp://192.168.2.\" + (uris.size() + 1) + \":5672\");\n \n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n         pool.setRandomize(true);\n         pool.add(newUri);\n \n@@ -217,7 +217,7 @@ public void testAddUriToPoolRandomized() throws URISyntaxException {\n     public void testAddUriToPoolNotRandomized() throws URISyntaxException {\n         URI newUri = new URI(\"tcp://192.168.2.\" + (uris.size() + 1) + \":5672\");\n \n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n         pool.setRandomize(false);\n         pool.add(newUri);\n \n@@ -230,7 +230,7 @@ public void testAddUriToPoolNotRandomized() throws URISyntaxException {\n \n     @Test\n     public void testRemoveURIFromPool() throws URISyntaxException {\n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n         pool.setRandomize(false);\n \n         URI removed = uris.get(0);\n@@ -256,7 +256,7 @@ public void testConnectedDoesNotShufflesWhenNoRandomizing() {\n \n     private void assertConnectedEffectOnPool(boolean randomize, boolean shouldShuffle) {\n \n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n         pool.setRandomize(randomize);\n \n         List<URI> current = new ArrayList<URI>();\n@@ -291,7 +291,7 @@ private void assertConnectedEffectOnPool(boolean randomize, boolean shouldShuffl\n \n     @Test\n     public void testAddOrRemoveNullHasNoAffect() throws URISyntaxException {\n-        FailoverUriPool pool = new FailoverUriPool(uris.toArray(new URI[0]), null);\n+        FailoverUriPool pool = new FailoverUriPool(uris, null);\n         assertEquals(uris.size(), pool.size());\n \n         pool.add(null);",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverUriPoolTest.java",
                "sha": "2636830c5f8b7cc7470e2bfa9d6abcaca77e9d79",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FiloverProviderFactoryTest.java",
                "changes": 1,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FiloverProviderFactoryTest.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 0,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FiloverProviderFactoryTest.java",
                "patch": "@@ -44,6 +44,7 @@ public void setUp() throws URISyntaxException {\n \n     @Test(timeout = 60000)\n     public void testCreateProvider() throws Exception {\n+        assertNotNull(factory.getName());\n         Provider provider = factory.createProvider(baseURI);\n         assertNotNull(provider);\n         assertTrue(provider instanceof FailoverProvider);",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FiloverProviderFactoryTest.java",
                "sha": "d2db7c2ee72b9190606ab9aec300acfd6c1fc90e",
                "status": "modified"
            },
            {
                "additions": 10,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/URISupportTest.java",
                "changes": 22,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/URISupportTest.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 12,
                "filename": "qpid-jms-client/src/test/java/org/apache/qpid/jms/util/URISupportTest.java",
                "patch": "@@ -21,17 +21,15 @@\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.qpid.jms.util.PropertyUtil;\n-import org.apache.qpid.jms.util.URISupport;\n-import org.apache.qpid.jms.util.URISupport.CompositeData;\n-\n import junit.framework.TestCase;\n \n+import org.apache.qpid.jms.util.URISupport.CompositeData;\n+\n public class URISupportTest extends TestCase {\n \n     public void testEmptyCompositePath() throws Exception {\n         CompositeData data = URISupport.parseComposite(new URI(\"broker:()/localhost?persistent=false\"));\n-        assertEquals(0, data.getComponents().length);\n+        assertEquals(0, data.getComponents().size());\n     }\n \n     public void testCompositePath() throws Exception {\n@@ -43,19 +41,19 @@ public void testCompositePath() throws Exception {\n \n     public void testSimpleComposite() throws Exception {\n         CompositeData data = URISupport.parseComposite(new URI(\"test:part1\"));\n-        assertEquals(1, data.getComponents().length);\n+        assertEquals(1, data.getComponents().size());\n     }\n \n     public void testComposite() throws Exception {\n         URI uri = new URI(\"test:(part1://host,part2://(sub1://part,sube2:part))\");\n         CompositeData data = URISupport.parseComposite(uri);\n-        assertEquals(2, data.getComponents().length);\n+        assertEquals(2, data.getComponents().size());\n     }\n \n     public void testEmptyCompositeWithParenthesisInParam() throws Exception {\n         URI uri = new URI(\"failover://()?updateURIsURL=file:/C:/Dir(1)/a.csv\");\n         CompositeData data = URISupport.parseComposite(uri);\n-        assertEquals(0, data.getComponents().length);\n+        assertEquals(0, data.getComponents().size());\n         assertEquals(1, data.getParameters().size());\n         assertTrue(data.getParameters().containsKey(\"updateURIsURL\"));\n         assertEquals(\"file:/C:/Dir(1)/a.csv\", data.getParameters().get(\"updateURIsURL\"));\n@@ -64,17 +62,17 @@ public void testEmptyCompositeWithParenthesisInParam() throws Exception {\n     public void testCompositeWithParenthesisInParam() throws Exception {\n         URI uri = new URI(\"failover://(test)?updateURIsURL=file:/C:/Dir(1)/a.csv\");\n         CompositeData data = URISupport.parseComposite(uri);\n-        assertEquals(1, data.getComponents().length);\n+        assertEquals(1, data.getComponents().size());\n         assertEquals(1, data.getParameters().size());\n         assertTrue(data.getParameters().containsKey(\"updateURIsURL\"));\n         assertEquals(\"file:/C:/Dir(1)/a.csv\", data.getParameters().get(\"updateURIsURL\"));\n     }\n \n     public void testCompositeWithComponentParam() throws Exception {\n         CompositeData data = URISupport.parseComposite(new URI(\"test:(part1://host?part1=true)?outside=true\"));\n-        assertEquals(1, data.getComponents().length);\n+        assertEquals(1, data.getComponents().size());\n         assertEquals(1, data.getParameters().size());\n-        Map<String, String> part1Params = URISupport.parseParameters(data.getComponents()[0]);\n+        Map<String, String> part1Params = URISupport.parseParameters(data.getComponents().get(0));\n         assertEquals(1, part1Params.size());\n         assertTrue(part1Params.containsKey(\"part1\"));\n     }\n@@ -99,7 +97,7 @@ protected void assertMapKey(Map<String, String> map, String key, Object expected\n \n     public void testParsingCompositeURI() throws URISyntaxException {\n         CompositeData data = URISupport.parseComposite(new URI(\"broker://(tcp://localhost:61616)?name=foo\"));\n-        assertEquals(\"one component\", 1, data.getComponents().length);\n+        assertEquals(\"one component\", 1, data.getComponents().size());\n         assertEquals(\"Size: \" + data.getParameters(), 1, data.getParameters().size());\n     }\n ",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/URISupportTest.java",
                "sha": "a858758db0b7b1526d93990156acc402142be631",
                "status": "modified"
            },
            {
                "additions": 1,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-discovery/src/main/java/org/apache/qpid/jms/provider/discovery/DiscoveryProviderFactory.java",
                "changes": 2,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-discovery/src/main/java/org/apache/qpid/jms/provider/discovery/DiscoveryProviderFactory.java?ref=d0ccd408be0a3921bf2b0db77ccd1b310d2d9512",
                "deletions": 1,
                "filename": "qpid-jms-discovery/src/main/java/org/apache/qpid/jms/provider/discovery/DiscoveryProviderFactory.java",
                "patch": "@@ -52,7 +52,7 @@ public Provider createProvider(URI remoteURI) throws Exception {\n         DiscoveryProvider discovery = new DiscoveryProvider(remoteURI, failover);\n         PropertyUtil.setProperties(discovery, options);\n \n-        DiscoveryAgent agent = DiscoveryAgentFactory.createAgent(composite.getComponents()[0]);\n+        DiscoveryAgent agent = DiscoveryAgentFactory.createAgent(composite.getComponents().get(0));\n         discovery.setDiscoveryAgent(agent);\n \n         return discovery;",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d0ccd408be0a3921bf2b0db77ccd1b310d2d9512/qpid-jms-discovery/src/main/java/org/apache/qpid/jms/provider/discovery/DiscoveryProviderFactory.java",
                "sha": "1015e33ca0fdb37573c434a9fd421f618bae27a8",
                "status": "modified"
            }
        ],
        "message": "Just use collections and always return empty ones to avoid any NPE\nissues",
        "parent": "https://github.com/apache/qpid-jms/commit/47348747d7bb91cb6aafa94b5f7cb37b66b238d2",
        "patched_files": [
            "DiscoveryProviderFactory.java",
            "FailoverUriPool.java",
            "URISupport.java",
            "FailoverProvider.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "FiloverProviderFactoryTest.java",
            "FailoverProviderTest.java",
            "URISupportTest.java",
            "FailoverUriPoolTest.java"
        ]
    },
    "qpid-jms_d12430f": {
        "bug_id": "qpid-jms_d12430f",
        "commit": "https://github.com/apache/qpid-jms/commit/d12430f9b6b60abbbd8c7f1a24b08928dbfafab7",
        "file": [
            {
                "additions": 4,
                "blob_url": "https://github.com/apache/qpid-jms/blob/d12430f9b6b60abbbd8c7f1a24b08928dbfafab7/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "changes": 6,
                "contents_url": "https://api.github.com/repos/apache/qpid-jms/contents/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java?ref=d12430f9b6b60abbbd8c7f1a24b08928dbfafab7",
                "deletions": 2,
                "filename": "qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "patch": "@@ -20,6 +20,7 @@\n import java.net.URI;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.ConcurrentModificationException;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Locale;\n@@ -679,7 +680,8 @@ public void run() {\n                         for (int i = 0; i < uris.size(); ++i) {\n                             URI target = uris.getNext();\n                             if (target == null) {\n-                                LOG.warn(\"Failover URI collection unexpectedly modified during connection attempt.\");\n+                                LOG.trace(\"Failover URI collection unexpectedly modified during connection attempt.\");\n+                                failure = new ConcurrentModificationException(\"Failover URIs changed unexpectedly\");\n                                 continue;\n                             }\n \n@@ -708,7 +710,7 @@ public void run() {\n                             \"No remote URI available for reconnection during connection attempt: \" + reconnectAttempts);\n                     }\n                 } catch (Throwable unknownFailure) {\n-                    LOG.info(\"Connection attempt:[{}] failed abnormally.\", reconnectAttempts);\n+                    LOG.warn(\"Connection attempt:[{}] failed abnormally.\", reconnectAttempts);\n                     failure = failure == null ? unknownFailure : failure;\n                 } finally {\n                     if (provider == null) {",
                "raw_url": "https://github.com/apache/qpid-jms/raw/d12430f9b6b60abbbd8c7f1a24b08928dbfafab7/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java",
                "sha": "fe7ba539d68a2d69bf0726cb94787ec191c0e812",
                "status": "modified"
            }
        ],
        "message": "QPIDJMS-365 Polish the logging a bit and prevent edge case NPE",
        "parent": "https://github.com/apache/qpid-jms/commit/bb7b596bbed768b3e3cf03a02a8951b7fdd6d686",
        "patched_files": [
            "FailoverProvider.java"
        ],
        "repo": "qpid-jms",
        "unit_tests": [
            "FailoverProviderTest.java"
        ]
    }
}