[
    {
        "repo": "tinkerpop",
        "commit": "https://github.com/apache/tinkerpop/commit/c890cebad5231cdab8744878bebb4ea363689a3a",
        "bug_id": "tinkerpop_c890ceb",
        "message": "fixed the NPE that occurs in OLAP when you have a local/OLTP group() nested within an OLAP group(). The solution is elegant, but the problem, its not as efficient as the code when we had the NPE.... dar. Going to fiddle some more tomorrow to see if I can get it faster --- 600ms vs 400ms differences.",
        "parent": "https://github.com/apache/tinkerpop/commit/44d40f60664b8b758f02bc8e04300b931b2c6622",
        "patched_files": [
            "GroupStep.java",
            "GroupSideEffectStep.java",
            "GroovyGroupTest.groovy",
            "SparkStarBarrierInterceptor.java"
        ],
        "file": [
            {
                "status": "modified",
                "additions": 110,
                "raw_url": "https://github.com/apache/tinkerpop/raw/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java",
                "contents_url": "https://api.github.com/repos/apache/tinkerpop/contents/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java?ref=c890cebad5231cdab8744878bebb4ea363689a3a",
                "filename": "gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java",
                "deletions": 100,
                "sha": "b430d8f8fabfb465a4f8545a6194dfd08326c3ad",
                "blob_url": "https://github.com/apache/tinkerpop/blob/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java",
                "patch": "@@ -29,7 +29,6 @@\n import org.apache.tinkerpop.gremlin.process.traversal.lambda.TokenTraversal;\n import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;\n import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;\n-import org.apache.tinkerpop.gremlin.process.traversal.step.GraphComputing;\n import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;\n import org.apache.tinkerpop.gremlin.process.traversal.step.util.ReducingBarrierStep;\n import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;\n@@ -39,32 +38,32 @@\n import org.apache.tinkerpop.gremlin.structure.util.StringFactory;\n import org.apache.tinkerpop.gremlin.util.function.HashMapSupplier;\n import org.apache.tinkerpop.gremlin.util.iterator.IteratorUtils;\n+import org.javatuples.Pair;\n \n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n import java.util.Set;\n import java.util.function.BinaryOperator;\n \n /**\n  * @author Marko A. Rodriguez (http://markorodriguez.com)\n  */\n-public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>> implements ByModulating, TraversalParent, GraphComputing {\n+public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>> implements ByModulating, TraversalParent {\n \n     private char state = 'k';\n     private Traversal.Admin<S, K> keyTraversal = null;\n-    private Traversal.Admin<S, V> valueTraversal = this.integrateChild(__.fold().asAdmin());\n-    private Traversal.Admin<S, ?> preTraversal = null;      // used in OLAP\n-    private ReducingBarrierStep reducingBarrierStep = null; // used in OLAP\n-    private boolean onGraphComputer = false;\n+    private Traversal.Admin<S, ?> preTraversal;\n+    private Traversal.Admin<S, V> valueTraversal;\n \n     public GroupStep(final Traversal.Admin traversal) {\n         super(traversal);\n-        this.setReducingBiOperator(new GroupBiOperator<>(this.valueTraversal, this.onGraphComputer));\n+        this.valueTraversal = this.integrateChild(__.fold().asAdmin());\n+        this.preTraversal = this.integrateChild(splitOnBarrierStep(this.valueTraversal).get(0));\n+        this.setReducingBiOperator(new GroupBiOperator<>(this.valueTraversal));\n         this.setSeedSupplier(HashMapSupplier.instance());\n     }\n \n@@ -75,7 +74,8 @@ public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {\n             this.state = 'v';\n         } else if ('v' == this.state) {\n             this.valueTraversal = this.integrateChild(convertValueTraversal(kvTraversal));\n-            this.setReducingBiOperator(new GroupBiOperator<>(this.valueTraversal, this.onGraphComputer));\n+            this.preTraversal = this.integrateChild(splitOnBarrierStep(this.valueTraversal).get(0));\n+            this.setReducingBiOperator(new GroupBiOperator<>(this.valueTraversal));\n             this.state = 'x';\n         } else {\n             throw new IllegalStateException(\"The key and value traversals for group()-step have already been set: \" + this);\n@@ -85,21 +85,11 @@ public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {\n     @Override\n     public Map<K, V> projectTraverser(final Traverser.Admin<S> traverser) {\n         final Map<K, V> map = new HashMap<>(1);\n-        final K key = TraversalUtil.applyNullable(traverser, this.keyTraversal);\n-        if (this.onGraphComputer) {\n-            if (null == this.reducingBarrierStep) {\n-                final TraverserSet traverserSet = new TraverserSet();\n-                this.preTraversal.reset();\n-                this.preTraversal.addStart(traverser.split());\n-                this.preTraversal.getEndStep().forEachRemaining(traverserSet::add);\n-                map.put(key, (V) traverserSet);\n-            } else {\n-                this.valueTraversal.reset();\n-                this.valueTraversal.addStart(traverser.split());\n-                map.put(key, (V) this.reducingBarrierStep.nextBarrier());\n-            }\n-        } else\n-            map.put(key, (V) traverser);\n+        final TraverserSet traverserSet = new TraverserSet<>();\n+        this.preTraversal.reset();\n+        this.preTraversal.addStart(traverser.split());\n+        this.preTraversal.getEndStep().forEachRemaining(traverserSet::add);\n+        map.put(TraversalUtil.applyNullable(traverser, this.keyTraversal), (V) traverserSet);\n         return map;\n     }\n \n@@ -128,11 +118,7 @@ public String toString() {\n         if (null != this.keyTraversal)\n             clone.keyTraversal = this.keyTraversal.clone();\n         clone.valueTraversal = this.valueTraversal.clone();\n-        if (null != this.preTraversal)\n-            clone.preTraversal = this.preTraversal.clone();\n-        final Optional<Barrier> optional = TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, clone.valueTraversal);\n-        if (optional.isPresent() && optional.get() instanceof ReducingBarrierStep)\n-            clone.reducingBarrierStep = (ReducingBarrierStep) optional.get();\n+        clone.preTraversal = this.integrateChild(GroupStep.splitOnBarrierStep(clone.valueTraversal).get(0));\n         return clone;\n     }\n \n@@ -154,37 +140,19 @@ public int hashCode() {\n \n     @Override\n     public Map<K, V> generateFinalResult(final Map<K, V> object) {\n-        return GroupStep.doFinalReduction((Map<K, Object>) object, this.valueTraversal, this.onGraphComputer);\n-    }\n-\n-    @Override\n-    public void onGraphComputer() {\n-        this.preTraversal = this.integrateChild(splitOnBarrierStep(this.valueTraversal).get(0));\n-        final Optional<Barrier> optional = TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, this.valueTraversal);\n-        if (optional.isPresent() && optional.get() instanceof ReducingBarrierStep)\n-            this.reducingBarrierStep = (ReducingBarrierStep) optional.get();\n-        this.setReducingBiOperator(new GroupBiOperator<>(this.valueTraversal, this.onGraphComputer = true));\n+        return GroupStep.doFinalReduction((Map<K, Object>) object, this.valueTraversal);\n     }\n \n     ///////////////////////\n \n     public static final class GroupBiOperator<K, V> implements BinaryOperator<Map<K, V>>, Serializable {\n \n-        private boolean onGraphComputer;\n-        private BinaryOperator reducingBinaryOperator;          // OLAP (w/ reducer)\n-        private transient Traversal.Admin<?, V> valueTraversal; // OLTP\n-        private transient Map<K, Integer> counters;             // OLTP\n+        private Traversal.Admin<?, V> valueTraversal;\n+        private ReducingBarrierStep reducingBarrierStep = null;\n \n-        public GroupBiOperator(final Traversal.Admin<?, V> valueTraversal, final boolean onGraphComputer) {\n-            this.onGraphComputer = onGraphComputer;\n-            if (this.onGraphComputer) {\n-                final Optional<Barrier> optional = TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, valueTraversal);\n-                if (optional.isPresent() && optional.get() instanceof ReducingBarrierStep)\n-                    this.reducingBinaryOperator = ((ReducingBarrierStep) optional.get()).getBiOperator();\n-            } else {\n-                this.valueTraversal = valueTraversal;\n-                this.counters = new HashMap<>();\n-            }\n+        public GroupBiOperator(final Traversal.Admin<?, V> valueTraversal) {\n+            this.valueTraversal = valueTraversal.clone();\n+            this.reducingBarrierStep = TraversalHelper.getFirstStepOfAssignableClass(ReducingBarrierStep.class, this.valueTraversal).orElse(null);\n         }\n \n         public GroupBiOperator() {\n@@ -194,43 +162,84 @@ public GroupBiOperator() {\n         @Override\n         public Map<K, V> apply(final Map<K, V> mapA, final Map<K, V> mapB) {\n             for (final K key : mapB.keySet()) {\n-                if (this.onGraphComputer) {\n-                    final Object objectB = mapB.get(key);\n-                    if (null != this.reducingBinaryOperator) {\n-                        // OLAP -- if there is a mid-traversal, apply the binary reducer and propagate the mutating barrier\n-                        final Object objectA = mapA.get(key);\n-                        mapA.put(key, (V) (null == objectA ? objectB : this.reducingBinaryOperator.apply(objectA, objectB)));\n-                    } else {\n-                        // OLAP -- if there is no mid-traversal reducer, aggregate pre-barrier traversers into a traverser set (expensive, but that's that)\n-                        final Object objectA = mapA.get(key);\n-                        final TraverserSet traverserSet;\n-                        if (null == objectA) {\n-                            traverserSet = new TraverserSet();\n-                            mapA.put(key, (V) traverserSet);\n-                        } else\n-                            traverserSet = (TraverserSet) objectA;\n-                        traverserSet.addAll((TraverserSet) objectB);\n-                    }\n+                Object objectA = mapA.get(key);\n+                final Object objectB = mapB.get(key);\n+                assert null != objectB;\n+                if (null == objectA) {\n+                    objectA = objectB;\n                 } else {\n-                    // OLTP -- do mid-barrier reductions if they exist, else don't. Bulking is also available here because of addStart() prior to barrier.\n-                    final Traverser.Admin traverser = (Traverser.Admin) mapB.get(key);\n-                    Traversal.Admin valueTraversalClone = (Traversal.Admin) mapA.get(key);\n-                    if (null == valueTraversalClone) {\n-                        this.counters.put(key, 0);\n-                        valueTraversalClone = this.valueTraversal.clone();\n-                        mapA.put(key, (V) valueTraversalClone);\n-                    }\n-                    valueTraversalClone.addStart(traverser);\n-                    if (this.counters.compute(key, (k, i) -> ++i) > 1000) {\n-                        this.counters.put(key, 0);\n-                        TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, valueTraversalClone).ifPresent(Barrier::processAllStarts);\n+                    if (objectA instanceof TraverserSet) {\n+                        if (objectB instanceof TraverserSet) {\n+                            final TraverserSet set = (TraverserSet) objectA;\n+                            set.addAll((TraverserSet) objectB);\n+                            if (null != this.reducingBarrierStep && set.size() > 1000) {\n+                                this.valueTraversal.reset();\n+                                this.reducingBarrierStep.addStarts(set.iterator());\n+                                objectA = this.reducingBarrierStep.nextBarrier();\n+                            }\n+                        } else if (objectB instanceof Pair) {\n+                            final TraverserSet set = (TraverserSet) objectA;\n+                            set.addAll((TraverserSet) ((Pair) objectB).getValue0());\n+                            if (set.size() > 1000) {\n+                                this.valueTraversal.reset();\n+                                this.reducingBarrierStep.addStarts(set.iterator());\n+                                this.reducingBarrierStep.addBarrier(((Pair) objectB).getValue1());\n+                                objectA = this.reducingBarrierStep.nextBarrier();\n+                            } else {\n+                                objectA = Pair.with(set, ((Pair) objectB).getValue1());\n+                            }\n+                        } else {\n+                            objectA = Pair.with(objectA, objectB);\n+                        }\n+                    } else if (objectA instanceof Pair) {\n+                        if (objectB instanceof TraverserSet) {\n+                            final TraverserSet set = (TraverserSet) ((Pair) objectA).getValue0();\n+                            set.addAll((TraverserSet) objectB);\n+                            if (null != this.reducingBarrierStep &&set.size() > 1000) {\n+                                this.valueTraversal.reset();\n+                                this.reducingBarrierStep.addStarts(set.iterator());\n+                                this.reducingBarrierStep.addBarrier(((Pair) objectA).getValue1());\n+                                objectA = this.reducingBarrierStep.nextBarrier();\n+                            }\n+                        } else if (objectB instanceof Pair) {\n+                            this.valueTraversal.reset();\n+                            this.reducingBarrierStep.addBarrier(((Pair) objectA).getValue1());\n+                            this.reducingBarrierStep.addBarrier(((Pair) objectB).getValue1());\n+                            this.reducingBarrierStep.addStarts(((TraverserSet) ((Pair) objectA).getValue0()).iterator());\n+                            this.reducingBarrierStep.addStarts(((TraverserSet) ((Pair) objectB).getValue0()).iterator());\n+                            objectA = this.reducingBarrierStep.nextBarrier();\n+                        } else {\n+                            this.valueTraversal.reset();\n+                            this.reducingBarrierStep.addBarrier(((Pair) objectA).getValue1());\n+                            this.reducingBarrierStep.addBarrier(objectB);\n+                            this.reducingBarrierStep.addStarts(((TraverserSet) ((Pair) objectA).getValue0()).iterator());\n+                            objectA = this.reducingBarrierStep.nextBarrier();\n+                        }\n+                    } else {\n+                        if (objectB instanceof TraverserSet) {\n+                            objectA = Pair.with(objectB, objectA);\n+                        } else if (objectB instanceof Pair) {\n+                            this.valueTraversal.reset();\n+                            this.reducingBarrierStep.addBarrier(objectA);\n+                            this.reducingBarrierStep.addBarrier(((Pair) objectB).getValue1());\n+                            this.reducingBarrierStep.addStarts(((TraverserSet) ((Pair) objectB).getValue0()).iterator());\n+                            objectA = this.reducingBarrierStep.nextBarrier();\n+                        } else {\n+                            this.valueTraversal.reset();\n+                            this.reducingBarrierStep.addBarrier(objectA);\n+                            this.reducingBarrierStep.addBarrier(objectB);\n+                            objectA = this.reducingBarrierStep.nextBarrier();\n+                        }\n                     }\n                 }\n+                mapA.put(key, (V) objectA);\n             }\n             return mapA;\n+\n         }\n     }\n \n+\n     ///////////////////////\n \n     public static <S, E> Traversal.Admin<S, E> convertValueTraversal(final Traversal.Admin<S, E> valueTraversal) {\n@@ -263,30 +272,31 @@ public GroupBiOperator() {\n         }\n     }\n \n-    public static <K, V> Map<K, V> doFinalReduction(final Map<K, Object> map, final Traversal.Admin<?, V> valueTraversal, final boolean onGraphComputer) {\n+    public static <K, V> Map<K, V> doFinalReduction(final Map<K, Object> map, final Traversal.Admin<?, V> valueTraversal) {\n         final Map<K, V> reducedMap = new HashMap<>(map.size());\n-        // if not on OLAP, who cares --- don't waste time computing barriers\n-        final boolean hasReducingBarrier = onGraphComputer &&\n-                TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, valueTraversal).isPresent() &&\n-                TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, valueTraversal).get() instanceof ReducingBarrierStep;\n-        final Traversal.Admin<?, ?> postTraversal = (onGraphComputer & !hasReducingBarrier) ? splitOnBarrierStep(valueTraversal.clone()).get(1) : null;\n+        final ReducingBarrierStep reducingBarrierStep = TraversalHelper.getFirstStepOfAssignableClass(ReducingBarrierStep.class, valueTraversal).orElse(null);\n         IteratorUtils.removeOnNext(map.entrySet().iterator()).forEachRemaining(entry -> {\n-            if (onGraphComputer) {\n-                if (hasReducingBarrier) {   // OLAP with reduction (barrier)\n-                    valueTraversal.reset();\n-                    TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, valueTraversal).get().addBarrier(entry.getValue());\n-                    reducedMap.put(entry.getKey(), valueTraversal.next());\n-                } else {                    // OLAP without reduction (traverser set)\n-                    postTraversal.reset();\n-                    postTraversal.addStarts(((TraverserSet) entry.getValue()).iterator());\n-                    reducedMap.put(entry.getKey(), (V) postTraversal.next());\n-                }\n-            } else                          // OLTP is just a traversal\n-                reducedMap.put(entry.getKey(), ((Traversal.Admin<?, V>) entry.getValue()).next());\n+            valueTraversal.reset();\n+            if (null == reducingBarrierStep) {\n+                reducedMap.put(entry.getKey(), entry.getValue() instanceof TraverserSet ?\n+                        ((TraverserSet<V>) entry.getValue()).iterator().next().get() :\n+                        (V) entry.getValue());\n+            } else {\n+                if (entry.getValue() instanceof TraverserSet)\n+                    reducingBarrierStep.addStarts(((TraverserSet) entry.getValue()).iterator());\n+                else if (entry.getValue() instanceof Pair) {\n+                    reducingBarrierStep.addStarts(((TraverserSet) (((Pair) entry.getValue()).getValue0())).iterator());\n+                    reducingBarrierStep.addBarrier((((Pair) entry.getValue()).getValue1()));\n+                } else\n+                    reducingBarrierStep.addBarrier(entry.getValue());\n+                reducedMap.put(entry.getKey(), valueTraversal.next());\n+            }\n         });\n         assert map.isEmpty();\n         map.clear();\n         map.putAll(reducedMap);\n         return (Map<K, V>) map;\n     }\n }\n+\n+",
                "changes": 210
            },
            {
                "status": "modified",
                "additions": 17,
                "raw_url": "https://github.com/apache/tinkerpop/raw/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java",
                "contents_url": "https://api.github.com/repos/apache/tinkerpop/contents/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java?ref=c890cebad5231cdab8744878bebb4ea363689a3a",
                "filename": "gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java",
                "deletions": 42,
                "sha": "4fc4ffad2740fef5d29e30e14587043cd796ec56",
                "blob_url": "https://github.com/apache/tinkerpop/blob/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java",
                "patch": "@@ -21,16 +21,12 @@\n import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n import org.apache.tinkerpop.gremlin.process.traversal.Traverser;\n import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;\n-import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;\n import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;\n-import org.apache.tinkerpop.gremlin.process.traversal.step.GraphComputing;\n import org.apache.tinkerpop.gremlin.process.traversal.step.SideEffectCapable;\n import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;\n import org.apache.tinkerpop.gremlin.process.traversal.step.map.GroupStep;\n-import org.apache.tinkerpop.gremlin.process.traversal.step.util.ReducingBarrierStep;\n import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;\n import org.apache.tinkerpop.gremlin.process.traversal.traverser.util.TraverserSet;\n-import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;\n import org.apache.tinkerpop.gremlin.structure.util.StringFactory;\n import org.apache.tinkerpop.gremlin.util.function.HashMapSupplier;\n@@ -39,27 +35,26 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n import java.util.Set;\n \n /**\n  * @author Marko A. Rodriguez (http://markorodriguez.com)\n  */\n-public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S> implements SideEffectCapable<Map<K, ?>, Map<K, V>>, TraversalParent, ByModulating, GraphComputing {\n+public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S> implements SideEffectCapable<Map<K, ?>, Map<K, V>>, TraversalParent, ByModulating {\n \n     private char state = 'k';\n     private Traversal.Admin<S, K> keyTraversal = null;\n+    private Traversal.Admin<S, ?> preTraversal = null;\n     private Traversal.Admin<S, V> valueTraversal = this.integrateChild(__.fold().asAdmin());\n-    private Traversal.Admin<S, ?> preTraversal = null;      // used in OLAP\n-    private ReducingBarrierStep reducingBarrierStep = null; // used in OLAP\n-    private boolean onGraphComputer = false;\n     ///\n     private String sideEffectKey;\n \n     public GroupSideEffectStep(final Traversal.Admin traversal, final String sideEffectKey) {\n         super(traversal);\n         this.sideEffectKey = sideEffectKey;\n-        this.getTraversal().getSideEffects().registerIfAbsent(this.sideEffectKey, HashMapSupplier.instance(), new GroupStep.GroupBiOperator<>(this.valueTraversal, this.onGraphComputer));\n+        this.valueTraversal = this.integrateChild(__.fold().asAdmin());\n+        this.preTraversal = this.integrateChild(GroupStep.splitOnBarrierStep(this.valueTraversal).get(0));\n+        this.getTraversal().getSideEffects().registerIfAbsent(this.sideEffectKey, HashMapSupplier.instance(), new GroupStep.GroupBiOperator<>(this.valueTraversal));\n     }\n \n     @Override\n@@ -69,7 +64,8 @@ public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {\n             this.state = 'v';\n         } else if ('v' == this.state) {\n             this.valueTraversal = this.integrateChild(GroupStep.convertValueTraversal(kvTraversal));\n-            this.getTraversal().getSideEffects().register(this.sideEffectKey, null, new GroupStep.GroupBiOperator<>(this.valueTraversal, this.onGraphComputer));\n+            this.preTraversal = this.integrateChild(GroupStep.splitOnBarrierStep(this.valueTraversal).get(0));\n+            this.getTraversal().getSideEffects().register(this.sideEffectKey, null, new GroupStep.GroupBiOperator<>(this.valueTraversal));\n             this.state = 'x';\n         } else {\n             throw new IllegalStateException(\"The key and value traversals for group()-step have already been set: \" + this);\n@@ -78,22 +74,14 @@ public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {\n \n     @Override\n     protected void sideEffect(final Traverser.Admin<S> traverser) {\n-        final Map<K, Object> map = new HashMap<>(1);\n-        final K key = TraversalUtil.applyNullable(traverser, this.keyTraversal);\n-        if (this.onGraphComputer) {\n-            if (null == this.reducingBarrierStep) {\n-                final TraverserSet traverserSet = new TraverserSet<>();\n-                this.preTraversal.reset();\n-                this.preTraversal.addStart(traverser.split());\n-                this.preTraversal.getEndStep().forEachRemaining(traverserSet::add);\n-                map.put(key, traverserSet);\n-            } else {\n-                this.valueTraversal.reset();\n-                this.valueTraversal.addStart(traverser.split());\n-                map.put(key, (V) this.reducingBarrierStep.nextBarrier());\n-            }\n-        } else\n-            map.put(key, traverser.split());\n+        final Map<K, V> map = new HashMap<>(1);\n+        final TraverserSet midTraversers = new TraverserSet<>();\n+        this.preTraversal.reset();\n+        this.preTraversal.addStart(traverser.split());\n+        while (this.preTraversal.hasNext()) {\n+            midTraversers.add(this.preTraversal.getEndStep().next());\n+        }\n+        map.put(TraversalUtil.applyNullable(traverser, this.keyTraversal), (V) midTraversers);\n         this.getTraversal().getSideEffects().add(this.sideEffectKey, map);\n     }\n \n@@ -127,11 +115,7 @@ public String toString() {\n         if (null != this.keyTraversal)\n             clone.keyTraversal = this.keyTraversal.clone();\n         clone.valueTraversal = this.valueTraversal.clone();\n-        if (null != this.preTraversal)\n-            clone.preTraversal = this.preTraversal.clone();\n-        final Optional<Barrier> optional = TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, clone.valueTraversal);\n-        if (optional.isPresent() && optional.get() instanceof ReducingBarrierStep)\n-            clone.reducingBarrierStep = (ReducingBarrierStep) optional.get();\n+        clone.preTraversal = this.integrateChild(GroupStep.splitOnBarrierStep(clone.valueTraversal).get(0));\n         return clone;\n     }\n \n@@ -153,15 +137,6 @@ public int hashCode() {\n \n     @Override\n     public Map<K, V> generateFinalResult(final Map<K, ?> object) {\n-        return GroupStep.doFinalReduction((Map<K, Object>) object, this.valueTraversal, this.onGraphComputer);\n-    }\n-\n-    @Override\n-    public void onGraphComputer() {\n-        this.preTraversal = this.integrateChild(GroupStep.splitOnBarrierStep(this.valueTraversal).get(0));\n-        final Optional<Barrier> optional = TraversalHelper.getFirstStepOfAssignableClass(Barrier.class, this.valueTraversal);\n-        if (optional.isPresent() && optional.get() instanceof ReducingBarrierStep)\n-            this.reducingBarrierStep = (ReducingBarrierStep) optional.get();\n-        this.getTraversal().getSideEffects().register(this.sideEffectKey, null, new GroupStep.GroupBiOperator<>(this.valueTraversal, this.onGraphComputer = true));\n+        return GroupStep.doFinalReduction((Map<K, Object>) object, this.valueTraversal);\n     }\n }",
                "changes": 59
            },
            {
                "status": "modified",
                "additions": 5,
                "raw_url": "https://github.com/apache/tinkerpop/raw/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-groovy-test/src/main/groovy/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroovyGroupTest.groovy",
                "contents_url": "https://api.github.com/repos/apache/tinkerpop/contents/gremlin-groovy-test/src/main/groovy/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroovyGroupTest.groovy?ref=c890cebad5231cdab8744878bebb4ea363689a3a",
                "filename": "gremlin-groovy-test/src/main/groovy/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroovyGroupTest.groovy",
                "deletions": 0,
                "sha": "ddfb94a02c0b937d3617e2f23f07a45220e7605b",
                "blob_url": "https://github.com/apache/tinkerpop/blob/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-groovy-test/src/main/groovy/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroovyGroupTest.groovy",
                "patch": "@@ -108,5 +108,10 @@ public abstract class GroovyGroupTest {\n         public Traversal<Vertex, Map<String, Map<Object, Object>>> get_g_V_repeatXunionXoutXknowsX_groupXaX_byXageX__outXcreatedX_groupXbX_byXnameX_byXcountXX_groupXaX_byXnameXX_timesX2X_capXa_bX() {\n             new ScriptTraversal<>(g, \"gremlin-groovy\", \"g.V.repeat(union(out('knows').group('a').by('age'), out('created').group('b').by('name').by(count())).group('a').by('name')).times(2).cap('a', 'b')\")\n         }\n+\n+        @Override\n+        public Traversal<Vertex, Map<Long, Map<String, List<Vertex>>>> get_g_V_group_byXbothE_countX_byXgroup_byXlabelXX() {\n+            new ScriptTraversal<>(g, \"gremlin-groovy\", \"g.V.group().by(bothE().count).by(group.by(label))\")\n+        }\n     }\n }",
                "changes": 5
            },
            {
                "status": "modified",
                "additions": 42,
                "raw_url": "https://github.com/apache/tinkerpop/raw/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-test/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupTest.java",
                "contents_url": "https://api.github.com/repos/apache/tinkerpop/contents/gremlin-test/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupTest.java?ref=c890cebad5231cdab8744878bebb4ea363689a3a",
                "filename": "gremlin-test/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupTest.java",
                "deletions": 0,
                "sha": "d4c4d743cd5c1db62b75b787d54d2e14a2213688",
                "blob_url": "https://github.com/apache/tinkerpop/blob/c890cebad5231cdab8744878bebb4ea363689a3a/gremlin-test/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupTest.java",
                "patch": "@@ -84,6 +84,8 @@\n \n     public abstract Traversal<Vertex, Map<String, Map<Object, Object>>> get_g_V_repeatXunionXoutXknowsX_groupXaX_byXageX__outXcreatedX_groupXbX_byXnameX_byXcountXX_groupXaX_byXnameXX_timesX2X_capXa_bX();\n \n+    public abstract Traversal<Vertex, Map<Long, Map<String, List<Vertex>>>> get_g_V_group_byXbothE_countX_byXgroup_byXlabelXX();\n+\n     @Test\n     @LoadGraphWith(MODERN)\n     public void g_V_group_byXnameX() {\n@@ -356,6 +358,41 @@ public void g_V_repeatXunionXoutXknowsX_groupXaX_byXageX__outXcreatedX_groupXbX_\n         checkSideEffects(traversal.asAdmin().getSideEffects(), \"a\", HashMap.class, \"b\", HashMap.class);\n     }\n \n+    @Test\n+    @LoadGraphWith(MODERN)\n+    public void g_V_group_byXbothE_countX_byXgroup_byXlabelXX() {\n+        final Traversal<Vertex, Map<Long, Map<String, List<Vertex>>>> traversal = get_g_V_group_byXbothE_countX_byXgroup_byXlabelXX();\n+        final Map<Long, Map<String, List<Vertex>>> map = traversal.next();\n+        assertFalse(traversal.hasNext());\n+        assertEquals(2, map.size());\n+        assertTrue(map.containsKey(1l));\n+        assertTrue(map.containsKey(3l));\n+        //\n+        Map<String, List<Vertex>> submap = map.get(1l);\n+        assertEquals(2, submap.size());\n+        assertTrue(submap.containsKey(\"software\"));\n+        assertTrue(submap.containsKey(\"person\"));\n+        List<Vertex> list = submap.get(\"software\");\n+        assertEquals(1, list.size());\n+        assertEquals(convertToVertex(graph, \"ripple\"), list.get(0));\n+        list = submap.get(\"person\");\n+        assertEquals(2, list.size());\n+        assertTrue(list.contains(convertToVertex(graph, \"vadas\")));\n+        assertTrue(list.contains(convertToVertex(graph, \"peter\")));\n+        //\n+        submap = map.get(3l);\n+        assertEquals(2, submap.size());\n+        assertTrue(submap.containsKey(\"software\"));\n+        assertTrue(submap.containsKey(\"person\"));\n+        list = submap.get(\"software\");\n+        assertEquals(1, list.size());\n+        assertEquals(convertToVertex(graph, \"lop\"), list.get(0));\n+        list = submap.get(\"person\");\n+        assertEquals(2, list.size());\n+        assertTrue(list.contains(convertToVertex(graph, \"marko\")));\n+        assertTrue(list.contains(convertToVertex(graph, \"josh\")));\n+    }\n+\n     public static class Traversals extends GroupTest {\n \n         @Override\n@@ -437,5 +474,10 @@ public void g_V_repeatXunionXoutXknowsX_groupXaX_byXageX__outXcreatedX_groupXbX_\n         public Traversal<Vertex, Map<String, Map<Object, Object>>> get_g_V_repeatXunionXoutXknowsX_groupXaX_byXageX__outXcreatedX_groupXbX_byXnameX_byXcountXX_groupXaX_byXnameXX_timesX2X_capXa_bX() {\n             return g.V().repeat(__.union(__.out(\"knows\").group(\"a\").by(\"age\"), __.out(\"created\").group(\"b\").by(\"name\").by(count())).group(\"a\").by(\"name\")).times(2).cap(\"a\", \"b\");\n         }\n+\n+        @Override\n+        public Traversal<Vertex, Map<Long, Map<String, List<Vertex>>>> get_g_V_group_byXbothE_countX_byXgroup_byXlabelXX() {\n+            return g.V().<Long, Map<String, List<Vertex>>>group().by(__.bothE().count()).by(__.group().by(T.label));\n+        }\n     }\n }",
                "changes": 42
            },
            {
                "status": "modified",
                "additions": 0,
                "raw_url": "https://github.com/apache/tinkerpop/raw/c890cebad5231cdab8744878bebb4ea363689a3a/spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/process/computer/traversal/strategy/optimization/interceptor/SparkStarBarrierInterceptor.java",
                "contents_url": "https://api.github.com/repos/apache/tinkerpop/contents/spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/process/computer/traversal/strategy/optimization/interceptor/SparkStarBarrierInterceptor.java?ref=c890cebad5231cdab8744878bebb4ea363689a3a",
                "filename": "spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/process/computer/traversal/strategy/optimization/interceptor/SparkStarBarrierInterceptor.java",
                "deletions": 1,
                "sha": "5c6d7299dc79bdf895d6ff167c0cd494c0d2a16e",
                "blob_url": "https://github.com/apache/tinkerpop/blob/c890cebad5231cdab8744878bebb4ea363689a3a/spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/process/computer/traversal/strategy/optimization/interceptor/SparkStarBarrierInterceptor.java",
                "patch": "@@ -126,7 +126,6 @@ else if (endStep instanceof FoldStep) {\n                 }\n             }).fold(endStep.getSeedSupplier().get(), biOperator::apply);\n         } else if (endStep instanceof GroupStep) {\n-            ((GroupStep) endStep).onGraphComputer();\n             final GroupStep.GroupBiOperator<Object, Object> biOperator = (GroupStep.GroupBiOperator) endStep.getBiOperator();\n             result = ((GroupStep) endStep).generateFinalResult(nextRDD.\n                     mapPartitions(partitions -> {",
                "changes": 1
            },
            {
                "status": "modified",
                "additions": 2,
                "raw_url": "https://github.com/apache/tinkerpop/raw/c890cebad5231cdab8744878bebb4ea363689a3a/tinkergraph-gremlin/src/test/java/org/apache/tinkerpop/gremlin/tinkergraph/structure/TinkerGraphPlayTest.java",
                "contents_url": "https://api.github.com/repos/apache/tinkerpop/contents/tinkergraph-gremlin/src/test/java/org/apache/tinkerpop/gremlin/tinkergraph/structure/TinkerGraphPlayTest.java?ref=c890cebad5231cdab8744878bebb4ea363689a3a",
                "filename": "tinkergraph-gremlin/src/test/java/org/apache/tinkerpop/gremlin/tinkergraph/structure/TinkerGraphPlayTest.java",
                "deletions": 2,
                "sha": "555771645ea1cc7bdcc6fd3d4f950e0f0cd26022",
                "blob_url": "https://github.com/apache/tinkerpop/blob/c890cebad5231cdab8744878bebb4ea363689a3a/tinkergraph-gremlin/src/test/java/org/apache/tinkerpop/gremlin/tinkergraph/structure/TinkerGraphPlayTest.java",
                "patch": "@@ -86,11 +86,11 @@ public void testPlay8() throws Exception {\n     @Ignore\n     public void benchmarkGroup() throws Exception {\n         Graph graph = TinkerGraph.open();\n-        GraphTraversalSource g = graph.traversal().withComputer();\n+        GraphTraversalSource g = graph.traversal();\n         graph.io(GraphMLIo.build()).readGraph(\"../data/grateful-dead.xml\");\n         /////////\n \n-        g.V().group().by(T.label).by(values(\"name\")).forEachRemaining(x -> logger.info(x.toString()));\n+        //g.V().group().by(T.label).by(values(\"name\")).forEachRemaining(x -> logger.info(x.toString()));\n \n         System.out.println(\"group: \" + g.V().both(\"followedBy\").both(\"followedBy\").group().by(\"songType\").by(count()).next());\n         System.out.println(\"groupV3d0: \" + g.V().both(\"followedBy\").both(\"followedBy\").groupV3d0().by(\"songType\").by().by(__.count(Scope.local)).next());",
                "changes": 4
            }
        ],
        "unit_tests": [
            "GroupSideEffectStepTest.java",
            "TinkerGraphPlayTest.java",
            "GroupStepTest.java",
            "GroupTest.java"
        ]
    },
    {
        "buggy": false,
        "test_file": "gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStepTest.java",
        "buggy_files": [
            "gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java",
            "gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java",
            "gremlin-groovy-test/src/main/groovy/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroovyGroupTest.groovy",
            "spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/process/computer/traversal/strategy/optimization/interceptor/SparkStarBarrierInterceptor.java"
        ],
        "fixed": true
    }
]