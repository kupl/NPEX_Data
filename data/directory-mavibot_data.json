[{"commit": "https://github.com/apache/directory-mavibot/commit/aab254c01df122ae251b2980c7f36aa684a588c2", "parent": "https://github.com/apache/directory-mavibot/commit/fb391da15f0d2415ae477dedb26496a18a72884f", "message": "Fixed some potential NPE when browsing an empty BTree", "bug_id": "directory-mavibot_1", "file": [{"additions": 48, "raw_url": "https://github.com/apache/directory-mavibot/raw/aab254c01df122ae251b2980c7f36aa684a588c2/mavibot/src/main/java/org/apache/directory/mavibot/btree/managed/TupleCursorImpl.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/aab254c01df122ae251b2980c7f36aa684a588c2/mavibot/src/main/java/org/apache/directory/mavibot/btree/managed/TupleCursorImpl.java", "sha": "602366cebf316aee3ed10644c1377de2b0d76c6e", "changes": 48, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/managed/TupleCursorImpl.java?ref=aab254c01df122ae251b2980c7f36aa684a588c2", "patch": "@@ -88,6 +88,12 @@\n      */\n     public Tuple<K, V> next() throws EndOfFileExceededException, IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            throw new NoSuchElementException( \"No tuple present\" );\n+        }\n+\n         ParentPos<K, V> parentPos = stack[depth];\n \n         if ( parentPos.page == null )\n@@ -287,6 +293,12 @@\n      */\n     public Tuple<K, V> prev() throws EndOfFileExceededException, IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            throw new NoSuchElementException( \"No more tuple present\" );\n+        }\n+\n         ParentPos<K, V> parentPos = stack[depth];\n \n         if ( parentPos.page == null )\n@@ -366,6 +378,12 @@\n      */\n     public boolean hasNext() throws EndOfFileExceededException, IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            return false;\n+        }\n+        \n         // Take the leaf and check if we have no mare values\n         ParentPos<K, V> parentPos = stack[depth];\n \n@@ -421,6 +439,12 @@ public boolean hasNext() throws EndOfFileExceededException, IOException\n      */\n     public boolean hasPrev() throws EndOfFileExceededException, IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            return false;\n+        }\n+\n         // Take the leaf and check if we have no mare values\n         ParentPos<K, V> parentPos = stack[depth];\n \n@@ -513,6 +537,12 @@ public long getCreationDate()\n      */\n     public void moveToNextNonDuplicateKey() throws EndOfFileExceededException, IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            return;\n+        }\n+\n         ParentPos<K, V> parentPos = stack[depth];\n \n         if ( parentPos.page == null )\n@@ -566,6 +596,12 @@ public void moveToNextNonDuplicateKey() throws EndOfFileExceededException, IOExc\n      */\n     public void moveToPrevNonDuplicateKey() throws EndOfFileExceededException, IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            return;\n+        }\n+\n         ParentPos<K, V> parentPos = stack[depth];\n \n         if ( parentPos.page == null )\n@@ -606,6 +642,12 @@ public void moveToPrevNonDuplicateKey() throws EndOfFileExceededException, IOExc\n      */\n     public void beforeFirst() throws IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            return;\n+        }\n+\n         Page<K, V> child = null;\n         \n         for ( int i = 0; i < depth; i++ )\n@@ -646,6 +688,12 @@ public void beforeFirst() throws IOException\n      */\n     public void afterLast() throws IOException\n     {\n+        // First check that we have elements in the BTree\n+        if ( ( stack == null ) || ( stack.length == 0 ) )\n+        {\n+            return;\n+        }\n+\n         Page<K, V> child = null;\n \n         for ( int i = 0; i < depth; i++ )", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/managed/TupleCursorImpl.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/25b9a8e968d1a53deb5ec15b346674f6cab1c970", "parent": "https://github.com/apache/directory-mavibot/commit/a86c49c63e5a95c68652953ca6e3e405615c6168", "message": "o fixed an NPE\no added test class", "bug_id": "directory-mavibot_2", "file": [{"additions": 2, "raw_url": "https://github.com/apache/directory-mavibot/raw/25b9a8e968d1a53deb5ec15b346674f6cab1c970/mavibot/src/main/java/org/apache/mavibot/btree/BTreeBuilder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/25b9a8e968d1a53deb5ec15b346674f6cab1c970/mavibot/src/main/java/org/apache/mavibot/btree/BTreeBuilder.java", "sha": "b490f11e6b2a283683500c5cacc4163451e63ed1", "changes": 29, "status": "modified", "deletions": 27, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/BTreeBuilder.java?ref=25b9a8e968d1a53deb5ec15b346674f6cab1c970", "patch": "@@ -33,7 +33,6 @@\n import java.util.List;\n \n import org.apache.mavibot.btree.serializer.ElementSerializer;\n-import org.apache.mavibot.btree.serializer.IntSerializer;\n \n \n /**\n@@ -105,7 +104,7 @@ public BTreeBuilder( String name, int numKeysInNode, ElementSerializer<K> keySer\n         {\n             if ( lastLeaf.keys[i] == null )\n             {\n-                int n = i + 1;\n+                int n = i;\n                 lastLeaf.nbElems = n;\n                 K[] keys = lastLeaf.keys;\n \n@@ -170,7 +169,7 @@ public BTreeBuilder( String name, int numKeysInNode, ElementSerializer<K> keySer\n         {\n             if ( lastNode.keys[j] == null )\n             {\n-                int n = j + 1;\n+                int n = j;\n                 lastNode.nbElems = n;\n                 K[] keys = lastNode.keys;\n \n@@ -184,28 +183,4 @@ public BTreeBuilder( String name, int numKeysInNode, ElementSerializer<K> keySer\n \n         return attachNodes( lstNodes, btree );\n     }\n-\n-\n-    public static void main( String[] args ) throws IOException\n-    {\n-        List<Tuple<Integer, Integer>> sortedTuple = new ArrayList<Tuple<Integer, Integer>>();\n-        for ( int i = 0; i < 8; i++ )\n-        {\n-            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( i, i );\n-            sortedTuple.add( t );\n-        }\n-\n-        IntSerializer ser = new IntSerializer();\n-        BTreeBuilder<Integer, Integer> bb = new BTreeBuilder<Integer, Integer>( \"master\", 4, ser, ser );\n-\n-        BTree btree = bb.build( sortedTuple.iterator() );\n-\n-        Cursor<Integer, Integer> cursor = btree.browse();\n-        while ( cursor.hasNext() )\n-        {\n-            Tuple<Integer, Integer> t = cursor.next();\n-            System.out.println( t );\n-        }\n-        cursor.close();\n-    }\n }", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/BTreeBuilder.java"}, {"additions": 76, "raw_url": "https://github.com/apache/directory-mavibot/raw/25b9a8e968d1a53deb5ec15b346674f6cab1c970/mavibot/src/test/java/org/apache/mavibot/btree/BTreeBuilderTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/25b9a8e968d1a53deb5ec15b346674f6cab1c970/mavibot/src/test/java/org/apache/mavibot/btree/BTreeBuilderTest.java", "sha": "f5c05ee1510243624d668393f7dadcac0c54303e", "changes": 76, "status": "added", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/mavibot/btree/BTreeBuilderTest.java?ref=25b9a8e968d1a53deb5ec15b346674f6cab1c970", "patch": "@@ -0,0 +1,76 @@\n+/*\n+ *   Licensed to the Apache Software Foundation (ASF) under one\n+ *   or more contributor license agreements.  See the NOTICE file\n+ *   distributed with this work for additional information\n+ *   regarding copyright ownership.  The ASF licenses this file\n+ *   to you under the Apache License, Version 2.0 (the\n+ *   \"License\"); you may not use this file except in compliance\n+ *   with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing,\n+ *   software distributed under the License is distributed on an\n+ *   \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *   KIND, either express or implied.  See the License for the\n+ *   specific language governing permissions and limitations\n+ *   under the License.\n+ *\n+ */\n+\n+package org.apache.mavibot.btree;\n+\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.mavibot.btree.serializer.IntSerializer;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * Test cases for BTreeBuilder.\n+ *\n+ * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n+ */\n+public class BTreeBuilderTest\n+{\n+    @Test\n+    public void testIntegerTree() throws IOException\n+    {\n+        List<Tuple<Integer, Integer>> sortedTuple = new ArrayList<Tuple<Integer, Integer>>();\n+        for ( int i = 1; i < 8; i++ )\n+        {\n+            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( i, i );\n+            sortedTuple.add( t );\n+        }\n+\n+        IntSerializer ser = new IntSerializer();\n+        BTreeBuilder<Integer, Integer> bb = new BTreeBuilder<Integer, Integer>( \"master\", 4, ser, ser );\n+\n+        // contains 1, 2, 3, 4, 5, 6, 7\n+        BTree btree = bb.build( sortedTuple.iterator() );\n+\n+        assertEquals( 1, btree.rootPage.getNbElems() );\n+        \n+        assertEquals( 7, btree.rootPage.findRightMost().getKey() );\n+        \n+        assertEquals( 1, btree.rootPage.findLeftMost().getKey() );\n+        \n+        Cursor<Integer, Integer> cursor = btree.browse();\n+        int i = 0;\n+        while ( cursor.hasNext() )\n+        {\n+            Tuple<Integer, Integer> expected = sortedTuple.get( i++ );\n+            Tuple<Integer, Integer> actual = cursor.next();\n+            assertEquals( expected.getKey(), actual.getKey() );\n+            assertEquals( expected.getValue(), actual.getValue() );\n+        }\n+        \n+        cursor.close();\n+        btree.close();\n+    }\n+\n+}", "filename": "mavibot/src/test/java/org/apache/mavibot/btree/BTreeBuilderTest.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/488e5cc26fc2d6a0ea98510d24d28f618791a1fb", "parent": "https://github.com/apache/directory-mavibot/commit/d76674563546547ef0ec4820f5572faee18d4f55", "message": "o Added more than one value in a page, stored the btree, and read it back\no Fixed a NPE when writing data in a page : when the data was filling the last page completely, that was generating a NPE.", "bug_id": "directory-mavibot_3", "file": [{"additions": 8, "raw_url": "https://github.com/apache/directory-mavibot/raw/488e5cc26fc2d6a0ea98510d24d28f618791a1fb/mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/488e5cc26fc2d6a0ea98510d24d28f618791a1fb/mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java", "sha": "ac95187244af2f69a95b848ffd846db1ffee06ab", "changes": 9, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java?ref=488e5cc26fc2d6a0ea98510d24d28f618791a1fb", "patch": "@@ -34,12 +34,12 @@\n \n import org.apache.mavibot.btree.BTree;\n import org.apache.mavibot.btree.BTreeFactory;\n+import org.apache.mavibot.btree.ElementHolder;\n import org.apache.mavibot.btree.Leaf;\n import org.apache.mavibot.btree.MemoryHolder;\n import org.apache.mavibot.btree.Node;\n import org.apache.mavibot.btree.Page;\n import org.apache.mavibot.btree.ReferenceHolder;\n-import org.apache.mavibot.btree.ElementHolder;\n import org.apache.mavibot.btree.exception.BTreeAlreadyManagedException;\n import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n import org.apache.mavibot.btree.serializer.IntSerializer;\n@@ -1256,6 +1256,13 @@ private long storeRaw( long position, byte[] bytes, PageIO... pageIos )\n                     pageData.put( bytes, bytes.length - nbStored, remaining );\n                     pageData.reset();\n                     pageNb++;\n+\n+                    if ( pageNb == pageIos.length )\n+                    {\n+                        // We can stop here : we have reach the end of the page\n+                        break;\n+                    }\n+\n                     pageData = pageIos[pageNb].getData();\n                     pagePos = LINK_SIZE;\n                     nbStored -= remaining;", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java"}, {"additions": 15, "raw_url": "https://github.com/apache/directory-mavibot/raw/488e5cc26fc2d6a0ea98510d24d28f618791a1fb/mavibot/src/test/java/org/apache/mavibot/btree/store/RecordManagerTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/488e5cc26fc2d6a0ea98510d24d28f618791a1fb/mavibot/src/test/java/org/apache/mavibot/btree/store/RecordManagerTest.java", "sha": "61be56eb254eaa02b9692bcaf9088089bcdbe7b1", "changes": 18, "status": "modified", "deletions": 3, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/mavibot/btree/store/RecordManagerTest.java?ref=488e5cc26fc2d6a0ea98510d24d28f618791a1fb", "patch": "@@ -30,6 +30,7 @@\n \n import org.apache.mavibot.btree.BTree;\n import org.apache.mavibot.btree.exception.BTreeAlreadyManagedException;\n+import org.apache.mavibot.btree.exception.KeyNotFoundException;\n import org.apache.mavibot.btree.serializer.LongSerializer;\n import org.apache.mavibot.btree.serializer.StringSerializer;\n import org.junit.Test;\n@@ -92,9 +93,10 @@ public void testRecordManager() throws IOException, BTreeAlreadyManagedException\n \n     /**\n      * Test the creation of a RecordManager with a BTree containing data.\n+     * @throws KeyNotFoundException \n      */\n     @Test\n-    public void testRecordManagerWithBTree() throws IOException, BTreeAlreadyManagedException\n+    public void testRecordManagerWithBTree() throws IOException, BTreeAlreadyManagedException, KeyNotFoundException\n     {\n         File tempFile = File.createTempFile( \"mavibot\", \".db\" );\n         String tempFileName = tempFile.getAbsolutePath();\n@@ -110,8 +112,10 @@ public void testRecordManagerWithBTree() throws IOException, BTreeAlreadyManaged\n         // And make it managed by the RM\n         recordManager.manage( btree );\n \n-        // Now, add some elemnts in the BTree\n+        // Now, add some elements in the BTree\n+        btree.insert( 3L, \"V3\" );\n         btree.insert( 1L, \"V1\" );\n+        btree.insert( 5L, \"V5\" );\n \n         // Close the recordManager\n         recordManager.close();\n@@ -126,7 +130,7 @@ public void testRecordManagerWithBTree() throws IOException, BTreeAlreadyManaged\n         assertEquals( 1, managedBTrees.size() );\n         assertTrue( managedBTrees.contains( \"test\" ) );\n \n-        BTree btree1 = recordManager1.getManagedTree( \"test\" );\n+        BTree<Long, String> btree1 = recordManager1.getManagedTree( \"test\" );\n \n         assertNotNull( btree1 );\n         assertEquals( btree.getComparator().getClass().getName(), btree1.getComparator().getClass().getName() );\n@@ -137,5 +141,13 @@ public void testRecordManagerWithBTree() throws IOException, BTreeAlreadyManaged\n         assertEquals( btree.getPageSize(), btree1.getPageSize() );\n         assertEquals( btree.getRevision(), btree1.getRevision() );\n         assertEquals( btree.getValueSerializer().getClass().getName(), btree1.getValueSerializer().getClass().getName() );\n+\n+        // Check the stord element\n+        assertTrue( btree1.exist( 1L ) );\n+        assertTrue( btree1.exist( 3L ) );\n+        assertTrue( btree1.exist( 5L ) );\n+        assertEquals( \"V1\", btree1.get( 1L ) );\n+        assertEquals( \"V3\", btree1.get( 3L ) );\n+        assertEquals( \"V5\", btree1.get( 5L ) );\n     }\n }", "filename": "mavibot/src/test/java/org/apache/mavibot/btree/store/RecordManagerTest.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/381b986ff2d1a3dc58bafc9fff9aa47237eb44de", "parent": "https://github.com/apache/directory-mavibot/commit/9e83907abe9e77008a8589ff2366670a296b4dcb", "message": "o A few optimization in the browse(K) method\no Fixed a NPE (DIRSERVER-20147) applying Lin's suggested patch\no Removed some spurious Sysout.println", "bug_id": "directory-mavibot_4", "file": [{"additions": 1, "raw_url": "https://github.com/apache/directory-mavibot/raw/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java", "sha": "73059983af0d1e0971f8115bbe884840ae0e5ad2", "changes": 3, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java?ref=381b986ff2d1a3dc58bafc9fff9aa47237eb44de", "patch": "@@ -191,10 +191,9 @@\n \n         ParentPos<K, V>[] stack = ( ParentPos<K, V>[] ) Array.newInstance( ParentPos.class, 32 );\n \n-        TupleCursor<K, V> cursor;\n         try\n         {\n-            cursor = getRootPage( transaction.getRevision() ).browse( key, transaction, stack, 0 );\n+            TupleCursor<K, V> cursor = getRootPage( transaction.getRevision() ).browse( key, transaction, stack, 0 );\n \n             return cursor;\n         }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java"}, {"additions": 3, "raw_url": "https://github.com/apache/directory-mavibot/raw/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java", "sha": "18a7910cc68635e9b6f6e34d60c1f9d5dfad9e7b", "changes": 14, "status": "modified", "deletions": 11, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java?ref=381b986ff2d1a3dc58bafc9fff9aa47237eb44de", "patch": "@@ -782,7 +782,7 @@ public boolean contains( K key, V value ) throws IOException\n \n                 stack[depth] = parentPos;\n             }\n-            else if ( nbElems >= 0 )\n+            else\n             {\n                 // We are at the end of a leaf. We have to check if we are at the end \n                 // of the tree or not\n@@ -795,10 +795,9 @@ else if ( nbElems >= 0 )\n                     {\n                         cursor.afterLast();\n                     }\n-                    catch ( IOException e )\n+                    catch ( IOException ioe )\n                     {\n-                        // TODO Auto-generated catch block\n-                        e.printStackTrace();\n+                        // Not likely to happen\n                     }\n                 }\n                 else\n@@ -830,13 +829,6 @@ else if ( nbElems >= 0 )\n                     }\n                 }\n             }\n-            else\n-            {\n-                // Not found, because there are no elements : return a null cursor\n-                stack[depth] = null;\n-\n-                cursor = new TupleCursor<K, V>( transaction, null, 0 );\n-            }\n         }\n \n         return cursor;", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java"}, {"additions": 2, "raw_url": "https://github.com/apache/directory-mavibot/raw/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/main/java/org/apache/directory/mavibot/btree/TupleCursor.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/main/java/org/apache/directory/mavibot/btree/TupleCursor.java", "sha": "d19397e511a14db1b97d56978e61d898d3f32941", "changes": 3, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/TupleCursor.java?ref=381b986ff2d1a3dc58bafc9fff9aa47237eb44de", "patch": "@@ -226,8 +226,9 @@ public boolean hasNext() throws EndOfFileExceededException, IOException\n         else\n         {\n             // Check if we have some more value\n-            if ( parentPos.valueCursor.hasNext() )\n+            if ( ( parentPos.valueCursor != null ) && parentPos.valueCursor.hasNext() )\n             {\n+                // No problem, we still have some values to read\n                 return true;\n             }\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/TupleCursor.java"}, {"additions": 2, "raw_url": "https://github.com/apache/directory-mavibot/raw/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java", "sha": "937016a37dbd8ae22797dac830f48033602f20f1", "changes": 13, "status": "modified", "deletions": 11, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java?ref=381b986ff2d1a3dc58bafc9fff9aa47237eb44de", "patch": "@@ -365,7 +365,7 @@ public void testInMemoryBulkLoadN() throws IOException, KeyNotFoundException\n \n             //System.out.println( \"Delta initial load = \" + ( t3 - t2 ) );\n \n-            System.out.println( \"Checking for N = \" + n );\n+            //System.out.println( \"Checking for N = \" + n );\n             checkBtree( btree, newBtree );\n         }\n     }\n@@ -400,7 +400,7 @@ public void testInMemoryBulkLoad21() throws IOException, KeyNotFoundException\n \n         //System.out.println( \"Delta initial load = \" + ( t3 - t2 ) );\n \n-        System.out.println( \"Checking for N = \" + 21 );\n+        //System.out.println( \"Checking for N = \" + 21 );\n         checkBtree( btree, newBtree );\n     }\n \n@@ -559,11 +559,6 @@ public void testPersistedBulkLoadComputeLevels() throws IOException, KeyNotFound\n             for ( int i = 2599; i <= 2599; i++ )\n             {\n                 List<LevelInfo<Long, String>> levels = BulkLoader.computeLevels( btree, i );\n-\n-                for ( LevelInfo<Long, String> level : levels )\n-                {\n-                    System.out.println( level );\n-                }\n             }\n         }\n         finally\n@@ -769,9 +764,6 @@ public void remove()\n             result = BulkLoader.load( btree, tupleIterator, 128 );\n             long t1 = System.currentTimeMillis();\n \n-            System.out.println( \"== Btree #\" + 4 + \", Time to bulkoad the \" + nbElems + \" elements \"\n-                + ( t1 - t0 ) + \"ms\" );\n-\n             TupleCursor<Long, String> cursor = result.browse();\n             int nbFetched = 0;\n \n@@ -1179,7 +1171,6 @@ public void remove()\n                     prev = elem;\n                     elem = cursor.next();\n                     nbFetched++;\n-                    System.out.println( elem );\n                 }\n             }\n             catch ( Exception e )", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java"}, {"additions": 0, "raw_url": "https://github.com/apache/directory-mavibot/raw/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/381b986ff2d1a3dc58bafc9fff9aa47237eb44de/mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java", "sha": "318ced1080daa115672a345fbd602e857d7e2f4e", "changes": 2, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java?ref=381b986ff2d1a3dc58bafc9fff9aa47237eb44de", "patch": "@@ -69,8 +69,6 @@ public void createBTree() throws IOException\n     {\n         dataDir = tempFolder.newFolder( UUID.randomUUID().toString() );\n \n-        System.out.println( dataDir + \"/mavibot.db\" );\n-\n         openRecordManagerAndBtree();\n \n         try", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/518c3c729168dd4c37a6e6adbed53250108f61fa", "parent": "https://github.com/apache/directory-mavibot/commit/5403983080952568c58a1ea5cf3b5c4bee9c436c", "message": "o Fixed a failing tests when we are reopening a BTree, as we should not see the old revisions\no Added the EmptyCursor used when we have no element to return\no Fixed a NPE", "bug_id": "directory-mavibot_5", "file": [{"additions": 23, "raw_url": "https://github.com/apache/directory-mavibot/raw/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java", "sha": "4378f0d74f1abf03061d0060c106564d2c358d95", "changes": 30, "status": "modified", "deletions": 7, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java?ref=518c3c729168dd4c37a6e6adbed53250108f61fa", "patch": "@@ -118,11 +118,20 @@\n      */\n     protected ReadTransaction<K, V> beginReadTransaction( long revision )\n     {\n-        ReadTransaction<K, V> readTransaction = new ReadTransaction<K, V>( getBtreeHeader( revision ) );\n+        BTreeHeader<K, V> btreeHeader = getBtreeHeader( revision );\n \n-        readTransactions.add( readTransaction );\n+        if ( btreeHeader != null )\n+        {\n+            ReadTransaction<K, V> readTransaction = new ReadTransaction<K, V>( btreeHeader );\n \n-        return readTransaction;\n+            readTransactions.add( readTransaction );\n+\n+            return readTransaction;\n+        }\n+        else\n+        {\n+            return null;\n+        }\n     }\n \n \n@@ -151,12 +160,19 @@\n     {\n         ReadTransaction<K, V> transaction = beginReadTransaction( revision );\n \n-        ParentPos<K, V>[] stack = (ParentPos<K, V>[]) Array.newInstance( ParentPos.class, 32 );\n+        if ( transaction == null )\n+        {\n+            return new EmptyTupleCursor<K, V>( revision );\n+        }\n+        else\n+        {\n+            ParentPos<K, V>[] stack = (ParentPos<K, V>[]) Array.newInstance( ParentPos.class, 32 );\n \n-        // And get the cursor\n-        TupleCursor<K, V> cursor = transaction.getRootPage().browse( transaction, stack, 0 );\n+            // And get the cursor\n+            TupleCursor<K, V> cursor = transaction.getRootPage().browse( transaction, stack, 0 );\n \n-        return cursor;\n+            return cursor;\n+        }\n     }\n \n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java"}, {"additions": 234, "raw_url": "https://github.com/apache/directory-mavibot/raw/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/main/java/org/apache/directory/mavibot/btree/EmptyTupleCursor.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/main/java/org/apache/directory/mavibot/btree/EmptyTupleCursor.java", "sha": "4afefb2cb881224e4b4c4edc2786c979ad734479", "changes": 234, "status": "added", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/EmptyTupleCursor.java?ref=518c3c729168dd4c37a6e6adbed53250108f61fa", "patch": "@@ -0,0 +1,234 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one\n+ *  or more contributor license agreements.  See the NOTICE file\n+ *  distributed with this work for additional information\n+ *  regarding copyright ownership.  The ASF licenses this file\n+ *  to you under the Apache License, Version 2.0 (the\n+ *  \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ *\n+ */\n+package org.apache.directory.mavibot.btree;\n+\n+\n+import java.io.IOException;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n+\n+\n+/**\n+ * A Cursor which is used when we have no element to return\n+ * <p>\n+ *\n+ * @param <K> The type for the Key\n+ * @param <V> The type for the stored value\n+ *\n+ * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n+ */\n+public class EmptyTupleCursor<K, V> extends TupleCursor<K, V>\n+{\n+    private long revision;\n+    private long creationDate;\n+\n+    /**\n+     * Creates a new instance of Cursor, starting on a page at a given position.\n+     *\n+     * @param transaction The transaction this operation is protected by\n+     * @param stack The stack of parent's from root to this page\n+     */\n+    public EmptyTupleCursor( long revision )\n+    {\n+        super();\n+\n+        this.revision = revision;\n+        creationDate = System.currentTimeMillis();\n+    }\n+\n+\n+    /**\n+     * Change the position in the current cursor to set it after the last key\n+     */\n+    public void afterLast() throws IOException\n+    {\n+    }\n+\n+\n+    /**\n+     * Change the position in the current cursor before the first key\n+     */\n+    public void beforeFirst() throws IOException\n+    {\n+    }\n+\n+\n+    /**\n+     * Tells if the cursor can return a next element\n+     *\n+     * @return true if there are some more elements\n+     * @throws IOException\n+     * @throws EndOfFileExceededException\n+     */\n+    public boolean hasNext() throws EndOfFileExceededException, IOException\n+    {\n+        return false;\n+    }\n+\n+\n+    /**\n+     * Find the next key/value\n+     *\n+     * @return A Tuple containing the found key and value\n+     * @throws IOException\n+     * @throws EndOfFileExceededException\n+     */\n+    public Tuple<K, V> next() throws EndOfFileExceededException, IOException\n+    {\n+        throw new NoSuchElementException( \"No tuple present\" );\n+    }\n+\n+\n+    /**\n+     * Get the next non-duplicate key.\n+     * If the BTree contains :\n+     *\n+     *  <ul>\n+     *    <li><1,0></li>\n+     *    <li><1,1></li>\n+     *    <li><1,2></li>\n+     *    <li><2,0></li>\n+     *    <li><2,1></li>\n+     *  </ul>\n+     *\n+     *  and cursor is present at <1,1> then the returned tuple will be <2,0> (not <1,2>)\n+     *\n+     * @return A Tuple containing the found key and value\n+     * @throws EndOfFileExceededException\n+     * @throws IOException\n+     */\n+    public Tuple<K, V> nextKey() throws EndOfFileExceededException, IOException\n+    {\n+        // This is the end : no more value\n+        throw new NoSuchElementException( \"No more tuples present\" );\n+    }\n+\n+\n+    /**\n+     * Tells if the cursor can return a next key\n+     *\n+     * @return true if there are some more keys\n+     * @throws IOException\n+     * @throws EndOfFileExceededException\n+     */\n+    public boolean hasNextKey() throws EndOfFileExceededException, IOException\n+    {\n+        return false;\n+    }\n+\n+\n+    /**\n+     * Tells if the cursor can return a previous element\n+     *\n+     * @return true if there are some more elements\n+     * @throws IOException\n+     * @throws EndOfFileExceededException\n+     */\n+    public boolean hasPrev() throws EndOfFileExceededException, IOException\n+    {\n+        return false;\n+    }\n+\n+\n+    /**\n+     * Find the previous key/value\n+     *\n+     * @return A Tuple containing the found key and value\n+     * @throws IOException\n+     * @throws EndOfFileExceededException\n+     */\n+    public Tuple<K, V> prev() throws EndOfFileExceededException, IOException\n+    {\n+        throw new NoSuchElementException( \"No more tuple present\" );\n+    }\n+\n+\n+    /**\n+     * Get the previous non-duplicate key.\n+     * If the BTree contains :\n+     *\n+     *  <ul>\n+     *    <li><1,0></li>\n+     *    <li><1,1></li>\n+     *    <li><1,2></li>\n+     *    <li><2,0></li>\n+     *    <li><2,1></li>\n+     *  </ul>\n+     *\n+     *  and cursor is present at <2,1> then the returned tuple will be <1,0> (not <2,0>)\n+     *\n+     * @return A Tuple containing the found key and value\n+     * @throws EndOfFileExceededException\n+     * @throws IOException\n+     */\n+    public Tuple<K, V> prevKey() throws EndOfFileExceededException, IOException\n+    {\n+        throw new NoSuchElementException( \"No more tuples present\" );\n+    }\n+\n+\n+    /**\n+     * Tells if the cursor can return a previous key\n+     *\n+     * @return true if there are some more keys\n+     * @throws IOException\n+     * @throws EndOfFileExceededException\n+     */\n+    public boolean hasPrevKey() throws EndOfFileExceededException, IOException\n+    {\n+        return false;\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void close()\n+    {\n+    }\n+\n+\n+    /**\n+     * Get the creation date\n+     * @return The creation date for this cursor\n+     */\n+    public long getCreationDate()\n+    {\n+        return creationDate;\n+    }\n+\n+\n+    /**\n+     * Get the current revision\n+     *\n+     * @return The revision this cursor is based on\n+     */\n+    public long getRevision()\n+    {\n+        return revision;\n+    }\n+\n+\n+    public String toString()\n+    {\n+        return \"EmptyTupleCursor\";\n+    }\n+}", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/EmptyTupleCursor.java"}, {"additions": 8, "raw_url": "https://github.com/apache/directory-mavibot/raw/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/main/java/org/apache/directory/mavibot/btree/ReadTransaction.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/main/java/org/apache/directory/mavibot/btree/ReadTransaction.java", "sha": "2e765ce45802a5d645f272f39031221897ff9177", "changes": 13, "status": "modified", "deletions": 5, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/ReadTransaction.java?ref=518c3c729168dd4c37a6e6adbed53250108f61fa", "patch": "@@ -66,11 +66,14 @@\n      */\n     public ReadTransaction( BTreeHeader<K, V> btreeHeader )\n     {\n-        this.revision = btreeHeader.getRevision();\n-        this.creationDate = System.currentTimeMillis();\n-        this.rootPage = btreeHeader.getRootPage();\n-        this.btreeHeader = btreeHeader;\n-        closed = false;\n+        if ( btreeHeader != null )\n+        {\n+            this.revision = btreeHeader.getRevision();\n+            this.creationDate = System.currentTimeMillis();\n+            this.rootPage = btreeHeader.getRootPage();\n+            this.btreeHeader = btreeHeader;\n+            closed = false;\n+        }\n     }\n \n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/ReadTransaction.java"}, {"additions": 2, "raw_url": "https://github.com/apache/directory-mavibot/raw/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/518c3c729168dd4c37a6e6adbed53250108f61fa/mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java", "sha": "74ae66d16711cc2b4631632c6c8600e39f3889a4", "changes": 4, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java?ref=518c3c729168dd4c37a6e6adbed53250108f61fa", "patch": "@@ -454,10 +454,10 @@ public void testRecordManagerBrowseWithKeepRevisions() throws IOException, BTree\n \n         // Check that we can read the revision again\n         // revision 1\n-        checkBTreeRevisionBrowse( btree, rev1, 3L );\n+        checkBTreeRevisionBrowse( btree, rev1 );\n \n         // Revision 2\n-        checkBTreeRevisionBrowse( btree, rev2, 1L, 3L );\n+        checkBTreeRevisionBrowse( btree, rev2 );\n \n         // Revision 3\n         checkBTreeRevisionBrowse( btree, rev3, 1L, 3L, 5L );", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/RecordManagerTest.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/bb9e17fe79199d876762b7d24c05c6b430a73408", "parent": "https://github.com/apache/directory-mavibot/commit/8b46c8264bcd0c117929c93492ec2e407f6c4908", "message": "o Fixed the getPage and getReference methods so that they don't throw NPE\no Huge refactoring of the InMemoryBtreeBuilder, which now takes a configuration instance\no Added a toString method to the KeyHolder class\no Added the BulkLoader class which can bulkload a complete BTree (persistent btree only atm)", "bug_id": "directory-mavibot_6", "file": [{"additions": 16, "raw_url": "https://github.com/apache/directory-mavibot/raw/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java", "sha": "774cefa4668a82b10e3c17473d4dc5d265d27c17", "changes": 18, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java?ref=bb9e17fe79199d876762b7d24c05c6b430a73408", "patch": "@@ -155,7 +155,14 @@ public boolean hasKey( K key ) throws IOException\n     {\n         if ( pos < nbElems + 1 )\n         {\n-            return children[pos].getValue();\n+            if ( children[pos] != null )\n+            {\n+                return children[pos].getValue();\n+            }\n+            else\n+            {\n+                return null;\n+            }\n         }\n         else\n         {\n@@ -259,7 +266,14 @@ public V get( K key ) throws IOException, KeyNotFoundException\n     {\n         if ( ( pos >= 0 ) && ( pos < children.length ) )\n         {\n-            return children[pos].getValue();\n+            if ( children[pos] != null )\n+            {\n+                return children[pos].getValue();\n+            }\n+            else\n+            {\n+                return null;\n+            }\n         }\n         else\n         {", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java"}, {"additions": 1329, "raw_url": "https://github.com/apache/directory-mavibot/raw/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java", "sha": "49ce27e5cb59ebff2733b951564e4136f03d18c6", "changes": 1329, "status": "added", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java?ref=bb9e17fe79199d876762b7d24c05c6b430a73408", "patch": "@@ -0,0 +1,1329 @@\n+/*\n+ *   Licensed to the Apache Software Foundation (ASF) under one\n+ *   or more contributor license agreements.  See the NOTICE file\n+ *   distributed with this work for additional information\n+ *   regarding copyright ownership.  The ASF licenses this file\n+ *   to you under the Apache License, Version 2.0 (the\n+ *   \"License\"); you may not use this file except in compliance\n+ *   with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing,\n+ *   software distributed under the License is distributed on an\n+ *   \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *   KIND, either express or implied.  See the License for the\n+ *   specific language governing permissions and limitations\n+ *   under the License.\n+ *\n+ */\n+\n+package org.apache.directory.mavibot.btree;\n+\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import org.apache.directory.mavibot.btree.comparator.IntComparator;\n+import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n+import org.apache.directory.mavibot.btree.exception.KeyNotFoundException;\n+import org.apache.directory.mavibot.btree.serializer.IntSerializer;\n+\n+\n+/**\n+ * A class used to bulk load a BTree. It will allow the load of N elements in \n+ * a given BTree without to have to inject one by one, saving a lot of time.\n+ * The second advantage is that the btree will be dense (the leaves will be\n+ * complete, except the last one).\n+ * This class can also be used to compact a BTree.\n+ *\n+ * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n+ */\n+public class BulkLoader<K, V>\n+{\n+    static enum LevelEnum\n+    {\n+        LEAF,\n+        NODE\n+    }\n+\n+    /**\n+     * A private class to store informations on a level. We have to keep :\n+     * <ul>\n+     * <li>The number of elements to store in this level</li>\n+     * <li>A flag that tells if it's a leaf or a node level</li>\n+     * <li>The number of pages necessary to store all the elements in a level</li>\n+     * <li>The number of elements we can store in a complete page (we may have one or two \n+     * incomplete pages at the end)</li>\n+     * <li>A flag that tells if we have some incomplete page at the end</li>\n+     * </ul>\n+     * TODO LevelInfo.\n+     *\n+     * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n+     */\n+    /*private*/class LevelInfo\n+    {\n+        /** The level number */\n+        private int levelNumber;\n+\n+        /** Nb of elements for this level */\n+        /*private*/int nbElems;\n+\n+        /** The number of pages in this level */\n+        /*private*/int nbPages;\n+\n+        /** Nb of elements before we reach an incomplete page */\n+        /*private*/int nbElemsLimit;\n+\n+        /** A flag that tells if the level contains nodes or leaves */\n+        private boolean isNode;\n+\n+        /** The current page which contains the data until we move it to the resulting BTree */\n+        /*private*/Page<K, V> currentPage;\n+\n+        /** The current position in the currentPage */\n+        private int currentPos;\n+\n+        /** The number of already added elements for this level */\n+        private int nbAddedElems;\n+\n+\n+        /** @see Object#toString() */\n+        public String toString()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+\n+            if ( isNode )\n+            {\n+                sb.append( \"NodeLevel[\" );\n+                sb.append( levelNumber );\n+                sb.append( \"] :\" );\n+            }\n+            else\n+            {\n+                sb.append( \"LeafLevel:\" );\n+            }\n+\n+            sb.append( \"\\n    nbElems           = \" ).append( nbElems );\n+            sb.append( \"\\n    nbPages           = \" ).append( nbPages );\n+            sb.append( \"\\n    nbElemsLimit      = \" ).append( nbElemsLimit );\n+            sb.append( \"\\n    nbAddedElems      = \" ).append( nbAddedElems );\n+            sb.append( \"\\n    currentPos        = \" ).append( currentPos );\n+            sb.append( \"\\n    currentPage\" );\n+            sb.append( \"\\n        nbKeys : \" ).append( currentPage.getNbElems() );\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+\n+    /**\n+     * Bulk Load data into a persisted BTree\n+     *\n+     * @param btree The persisted BTree in which we want to load the data\n+     * @param iterator The iterator over the data to bulkload\n+     * @param chunkSize The number of elements we may store in memory at each iteration\n+     * @throws IOException If there is a problem while processing the data\n+     */\n+    public BTree<K, V> load( PersistedBTree<K, V> btree, Iterator<Tuple<K, V>> iterator, int chunkSize )\n+        throws IOException\n+    {\n+        if ( btree == null )\n+        {\n+            throw new RuntimeException( \"Invalid BTree : it's null\" );\n+        }\n+\n+        if ( iterator == null )\n+        {\n+            // Nothing to do...\n+            return null;\n+        }\n+\n+        // Iterate through the elements by chunk\n+        int nbRead = 0;\n+        int nbIteration = 0;\n+        boolean inMemory = true;\n+        int nbElems = 0;\n+\n+        // An array of chukSize tuple max\n+        List<Tuple<K, V>> tuples = new ArrayList<Tuple<K, V>>( chunkSize );\n+\n+        // The list of files we will use to store the sorted chunks\n+        List<File> sortedFiles = new ArrayList<File>();\n+\n+        // Now, start to read all the tuples to sort them. We may use intermediate files\n+        // for that purpose if we hit the threshold.\n+        while ( true )\n+        {\n+            nbIteration++;\n+            tuples.clear();\n+\n+            // Read up to chukSize elements\n+            while ( iterator.hasNext() && ( nbRead < chunkSize ) )\n+            {\n+                Tuple<K, V> tuple = iterator.next();\n+                tuples.add( tuple );\n+                nbRead++;\n+            }\n+\n+            if ( nbRead < chunkSize )\n+            {\n+                if ( nbIteration == 1 )\n+                {\n+                    // We have read all the data in one round trip, let's get out, no need\n+                    // to store the data on disk\n+                    sortedFiles.add( flushToDisk( nbIteration, tuples, btree ) );\n+                }\n+                else\n+                {\n+                    // Flush the sorted data on disk and exit\n+                    inMemory = false;\n+\n+                    sortedFiles.add( flushToDisk( nbIteration, tuples, btree ) );\n+                }\n+\n+                // Update the number of read elements\n+                nbElems += nbRead;\n+\n+                break;\n+            }\n+            else\n+            {\n+                if ( !iterator.hasNext() )\n+                {\n+                    // special case : we have exactly chunkSize elements in the incoming data\n+                    if ( nbIteration > 1 )\n+                    {\n+                        // Flush the sorted data on disk and exit\n+                        inMemory = false;\n+                        sortedFiles.add( flushToDisk( nbIteration, tuples, btree ) );\n+                    }\n+\n+                    // We have read all the data in one round trip, let's get out, no need\n+                    // to store the data on disk\n+\n+                    // Update the number of read elements\n+                    nbElems += nbRead;\n+\n+                    break;\n+                }\n+\n+                // We have read chunkSize elements, we have to sort them on disk\n+                nbElems += nbRead;\n+                nbRead = 0;\n+                sortedFiles.add( flushToDisk( nbIteration, tuples, btree ) );\n+            }\n+        }\n+\n+        // Now that we have processed all the data, we can start storing them in the btree\n+        Iterator<Tuple<K, Set<V>>> dataIterator = null;\n+        FileInputStream[] streams = null;\n+\n+        if ( inMemory )\n+        {\n+            // Here, we have all the data in memory, no need to merge files\n+            // We will build a simple iterator over the data\n+            dataIterator = createTupleIterator( btree, tuples );\n+\n+        }\n+        else\n+        {\n+            // We first have to build an iterator over the files\n+            int nbFiles = sortedFiles.size();\n+            streams = new FileInputStream[nbFiles];\n+\n+            for ( int i = 0; i < nbFiles; i++ )\n+            {\n+                streams[i] = new FileInputStream( sortedFiles.get( i ) );\n+            }\n+\n+            dataIterator = createIterator( btree, streams );\n+        }\n+\n+        // Ok, we have an iterator over sorted elements, we can now load them in the \n+        // target btree.\n+        BTree<K, V> resultBTree = bulkLoad( btree, dataIterator, nbElems );\n+\n+        // Now, close the FileInputStream if we have some\n+        if ( !inMemory )\n+        {\n+            int nbFiles = sortedFiles.size();\n+\n+            for ( int i = 0; i < nbFiles; i++ )\n+            {\n+                streams[i].close();\n+            }\n+        }\n+\n+        return resultBTree;\n+    }\n+\n+\n+    /**\n+     * Creates a node leaf LevelInfo based on the number of elements in the lower level. We can store\n+     * up to PageSize + 1 references to pages in a node.\n+     */\n+    /* no qualifier*/LevelInfo computeLevel( BTree<K, V> btree, int nbElems, LevelEnum levelType )\n+    {\n+        int pageSize = btree.getPageSize();\n+        int incrementNode = 0;\n+\n+        if ( levelType == LevelEnum.NODE )\n+        {\n+            incrementNode = 1;\n+        }\n+\n+        LevelInfo level = new LevelInfo();\n+        level.isNode = ( levelType == LevelEnum.NODE );\n+        level.nbElems = nbElems;\n+        level.nbPages = nbElems / ( pageSize + incrementNode );\n+        level.levelNumber = 0;\n+        level.nbAddedElems = 0;\n+        level.currentPos = 0;\n+\n+        // Create the first level page\n+        if ( nbElems <= pageSize + incrementNode )\n+        {\n+            if ( nbElems % ( pageSize + incrementNode ) != 0 )\n+            {\n+                level.nbPages = 1;\n+            }\n+\n+            level.nbElemsLimit = nbElems;\n+\n+            if ( level.isNode )\n+            {\n+                level.currentPage = BTreeFactory.createNode( btree, 0L, nbElems - 1 );\n+            }\n+            else\n+            {\n+                level.currentPage = BTreeFactory.createLeaf( btree, 0L, nbElems );\n+            }\n+        }\n+        else\n+        {\n+            int remaining = nbElems % ( pageSize + incrementNode );\n+\n+            if ( remaining == 0 )\n+            {\n+                level.nbElemsLimit = nbElems;\n+\n+                if ( level.isNode )\n+                {\n+                    level.currentPage = BTreeFactory.createNode( btree, 0L, pageSize );\n+                }\n+                else\n+                {\n+                    level.currentPage = BTreeFactory.createLeaf( btree, 0L, pageSize );\n+                }\n+            }\n+            else\n+            {\n+                level.nbPages++;\n+\n+                if ( remaining < ( pageSize / 2 ) + incrementNode )\n+                {\n+                    level.nbElemsLimit = nbElems - remaining - ( pageSize + incrementNode );\n+\n+                    if ( level.nbElemsLimit > 0 )\n+                    {\n+                        if ( level.isNode )\n+                        {\n+                            level.currentPage = BTreeFactory.createNode( btree, 0L, pageSize );\n+                        }\n+                        else\n+                        {\n+                            level.currentPage = BTreeFactory.createLeaf( btree, 0L, pageSize );\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if ( level.isNode )\n+                        {\n+                            level.currentPage = BTreeFactory.createNode( btree, 0L, ( pageSize / 2 ) + remaining - 1 );\n+                        }\n+                        else\n+                        {\n+                            level.currentPage = BTreeFactory.createLeaf( btree, 0L, ( pageSize / 2 ) + remaining );\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    level.nbElemsLimit = nbElems - remaining;\n+\n+                    if ( level.isNode )\n+                    {\n+                        level.currentPage = BTreeFactory.createNode( btree, 0L, pageSize );\n+                    }\n+                    else\n+                    {\n+                        level.currentPage = BTreeFactory.createLeaf( btree, 0L, pageSize );\n+                    }\n+                }\n+            }\n+        }\n+\n+        return level;\n+    }\n+\n+\n+    /**\n+     * Compute the number of pages necessary to store all the elements per level. The resulting list is\n+     * reversed ( ie the leaves are on the left, the root page on the right.\n+     */\n+    /* No Qualifier */List<LevelInfo> computeLevels( BTree<K, V> btree, int nbElems )\n+    {\n+        List<LevelInfo> levelList = new ArrayList<LevelInfo>();\n+\n+        // Compute the leaves info\n+        LevelInfo leafLevel = computeLevel( btree, nbElems, LevelEnum.LEAF );\n+\n+        levelList.add( leafLevel );\n+        int nbPages = leafLevel.nbPages;\n+        int levelNumber = 1;\n+\n+        while ( nbPages > 1 )\n+        {\n+            // Compute the Nodes info\n+            LevelInfo nodeLevel = computeLevel( btree, nbPages, LevelEnum.NODE );\n+            nodeLevel.levelNumber = levelNumber++;\n+            levelList.add( nodeLevel );\n+            nbPages = nodeLevel.nbPages;\n+        }\n+\n+        return levelList;\n+    }\n+\n+\n+    /**\n+     * Inject a tuple into a leaf\n+     */\n+    private void injectInLeaf( BTree<K, V> btree, Tuple<K, Set<V>> tuple, LevelInfo leafLevel )\n+    {\n+        PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) leafLevel.currentPage;\n+\n+        KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), tuple.getKey() );\n+        ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, ( V[] ) tuple.getValue().toArray() );\n+        leaf.setKey( leafLevel.currentPos, keyHolder );\n+        leaf.setValue( leafLevel.currentPos, valueHolder );\n+\n+        leafLevel.currentPos++;\n+    }\n+\n+\n+    private int computeNbElemsLeaf( BTree<K, V> btree, LevelInfo levelInfo )\n+    {\n+        int pageSize = btree.getPageSize();\n+        int remaining = levelInfo.nbElems - levelInfo.nbAddedElems;\n+\n+        if ( remaining < pageSize )\n+        {\n+            return remaining;\n+        }\n+        else if ( remaining == pageSize )\n+        {\n+            return pageSize;\n+        }\n+        else if ( remaining > levelInfo.nbElems - levelInfo.nbElemsLimit )\n+        {\n+            return pageSize;\n+        }\n+        else\n+        {\n+            return remaining - pageSize / 2;\n+        }\n+    }\n+\n+\n+    /**\n+     * Compute the number of nodes necessary to store all the elements.\n+     */\n+    /* No qualifier */int computeNbElemsNode( BTree<K, V> btree, LevelInfo levelInfo )\n+    {\n+        int pageSize = btree.getPageSize();\n+        int remaining = levelInfo.nbElems - levelInfo.nbAddedElems;\n+\n+        if ( remaining < pageSize + 1 )\n+        {\n+            return remaining;\n+        }\n+        else if ( remaining == pageSize + 1 )\n+        {\n+            return pageSize + 1;\n+        }\n+        else if ( remaining > levelInfo.nbElems - levelInfo.nbElemsLimit )\n+        {\n+            return pageSize + 1;\n+        }\n+        else\n+        {\n+            return remaining - pageSize / 2;\n+        }\n+    }\n+\n+\n+    /**\n+     * Inject a page reference into the root page.\n+     */\n+    private void injectInRoot( BTree<K, V> btree, Page<K, V> page, PageHolder<K, V> pageHolder, LevelInfo level )\n+        throws IOException\n+    {\n+        PersistedNode<K, V> node = ( PersistedNode<K, V> ) level.currentPage;\n+        if ( ( level.currentPos == 0 ) && ( node.getPage( 0 ) == null ) )\n+\n+        {\n+            node.setPageHolder( 0, pageHolder );\n+            level.nbAddedElems++;\n+        }\n+        else\n+        {\n+            // Inject the pageHolder and the page leftmost key\n+            node.setPageHolder( level.currentPos + 1, pageHolder );\n+            KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), page.getLeftMostKey() );\n+            node.setKey( level.currentPos, keyHolder );\n+            level.currentPos++;\n+            level.nbAddedElems++;\n+\n+            // Check that we haven't added the last element. If so,\n+            // we have to write the page on disk and update the btree\n+            if ( level.nbAddedElems == level.nbElems )\n+            {\n+                PageHolder<K, V> rootHolder = ( ( PersistedBTree<K, V> ) btree ).getRecordManager().writePage(\n+                    btree, node, 0L );\n+                ( ( PersistedBTree<K, V> ) btree ).setRootPage( rootHolder.getValue() );\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+\n+    /**\n+     * Inject a page reference into a Node. This method will recurse if needed.\n+     */\n+    private void injectInNode( BTree<K, V> btree, Page<K, V> page, List<LevelInfo> levels, int levelIndex )\n+        throws IOException\n+    {\n+        int pageSize = btree.getPageSize();\n+        LevelInfo level = levels.get( levelIndex );\n+        PersistedNode<K, V> node = ( PersistedNode<K, V> ) level.currentPage;\n+\n+        // We first have to write the page on disk\n+        PageHolder<K, V> pageHolder = ( ( PersistedBTree<K, V> ) btree ).getRecordManager().writePage( btree, page, 0L );\n+\n+        // First deal with a node that has less than PageSize elements at this level.\n+        // It will become the root node.\n+        if ( level.nbElems <= pageSize + 1 )\n+        {\n+            injectInRoot( btree, page, pageHolder, level );\n+\n+            return;\n+        }\n+\n+        // Now, we have some parent node. We process the 3 different use case :\n+        // o Full node before the limit\n+        // o Node over the limit but with at least N/2 elements\n+        // o Node over the limit but with elements spread into 2 nodes\n+        if ( level.nbAddedElems < level.nbElemsLimit )\n+        {\n+            // Ok, we haven't yet reached the incomplete pages (if any).\n+            // Let's add the page reference into the node\n+            // There is one special case : when we are adding the very first page \n+            // reference into a node. In this case, we don't store the key\n+            if ( ( level.currentPos == 0 ) && ( node.getKey( 0 ) == null ) )\n+            {\n+                node.setPageHolder( 0, pageHolder );\n+            }\n+            else\n+            {\n+                // Inject the pageHolder and the page leftmost key\n+                node.setPageHolder( level.currentPos, pageHolder );\n+                KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), page.getLeftMostKey() );\n+                node.setKey( level.currentPos - 1, keyHolder );\n+            }\n+\n+            // Now, increment this level nb of added elements\n+            level.currentPos++;\n+            level.nbAddedElems++;\n+\n+            // Check that we haven't added the last element. If so,\n+            // we have to write the page on disk and update the parent's node\n+            if ( level.nbAddedElems == level.nbElems )\n+            {\n+                //PageHolder<K, V> rootHolder = ( ( PersistedBTree<K, V> ) btree ).getRecordManager().writePage(\n+                //    btree, node, 0L );\n+                //( ( PersistedBTree<K, V> ) btree ).setRootPage( rootHolder.getValue() );\n+                injectInNode( btree, node, levels, levelIndex + 1 );\n+\n+                return;\n+            }\n+            else\n+            {\n+                // Check that we haven't completed the current node, and that this is not the root node.\n+                if ( ( level.currentPos == pageSize + 1 ) && ( level.levelNumber < levels.size() - 1 ) )\n+                {\n+                    // yes. We have to write the node on disk, update its parent\n+                    // and create a new current node\n+                    injectInNode( btree, node, levels, levelIndex + 1 );\n+\n+                    // The page is full, we have to create a new one, with a size depending on the remaining elements\n+                    if ( level.nbAddedElems < level.nbElemsLimit )\n+                    {\n+                        // We haven't reached the limit, create a new full node\n+                        level.currentPage = BTreeFactory.createNode( btree, 0L, pageSize );\n+                    }\n+                    else if ( level.nbElems - level.nbAddedElems <= pageSize )\n+                    {\n+                        level.currentPage = BTreeFactory.createNode( btree, 0L, level.nbElems - level.nbAddedElems - 1 );\n+                    }\n+                    else\n+                    {\n+                        level.currentPage = BTreeFactory.createNode( btree, 0L, ( level.nbElems - 1 )\n+                            - ( level.nbAddedElems + 1 ) - pageSize / 2 );\n+                    }\n+\n+                    level.currentPos = 0;\n+                }\n+            }\n+\n+            return;\n+        }\n+        else\n+        {\n+            // We are dealing with the last page or the last two pages \n+            // We can have either one single pages which can contain up to pageSize-1 elements\n+            // or with two pages, the first one containing ( nbElems - limit ) - pageSize/2 elements\n+            // and the second one will contain pageSize/2 elements. \n+            if ( level.nbElems - level.nbElemsLimit > pageSize )\n+            {\n+                // As the remaining elements are above a page size, they will be spread across\n+                // two pages. We have two cases here, depending on the page we are filling\n+                if ( level.nbElems - level.nbAddedElems <= pageSize / 2 + 1 )\n+                {\n+                    // As we have less than PageSize/2 elements to write, we are on the second page\n+                    if ( ( level.currentPos == 0 ) && ( node.getKey( 0 ) == null ) )\n+                    {\n+                        node.setPageHolder( 0, pageHolder );\n+                    }\n+                    else\n+                    {\n+                        // Inject the pageHolder and the page leftmost key\n+                        node.setPageHolder( level.currentPos, pageHolder );\n+                        KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(),\n+                            page.getLeftMostKey() );\n+                        node.setKey( level.currentPos - 1, keyHolder );\n+                    }\n+\n+                    // Now, increment this level nb of added elements\n+                    level.currentPos++;\n+                    level.nbAddedElems++;\n+\n+                    // Check if we are done with the page\n+                    if ( level.nbAddedElems == level.nbElems )\n+                    {\n+                        // Yes, we have to update the parent\n+                        injectInNode( btree, node, levels, levelIndex + 1 );\n+                    }\n+                }\n+                else\n+                {\n+                    // This is the first page \n+                    if ( ( level.currentPos == 0 ) && ( node.getKey( 0 ) == null ) )\n+                    {\n+                        // First element of the page\n+                        node.setPageHolder( 0, pageHolder );\n+                    }\n+                    else\n+                    {\n+                        // Any other following elements\n+                        // Inject the pageHolder and the page leftmost key\n+                        node.setPageHolder( level.currentPos, pageHolder );\n+                        KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(),\n+                            page.getLeftMostKey() );\n+                        node.setKey( level.currentPos - 1, keyHolder );\n+                    }\n+\n+                    // Now, increment this level nb of added elements\n+                    level.currentPos++;\n+                    level.nbAddedElems++;\n+\n+                    // Check if we are done with the page\n+                    if ( level.currentPos == node.getNbElems() + 1 )\n+                    {\n+                        // Yes, we have to update the parent\n+                        injectInNode( btree, node, levels, levelIndex + 1 );\n+\n+                        // An create a new one\n+                        level.currentPage = BTreeFactory.createNode( btree, 0L, pageSize / 2 );\n+                        level.currentPos = 0;\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                // Two cases : we don't have anything else to write, or this is a single page\n+                if ( level.nbAddedElems == level.nbElems )\n+                {\n+                    // We are done with the page\n+                    injectInNode( btree, node, levels, levelIndex + 1 );\n+                }\n+                else\n+                {\n+                    // We have some more elements to add in  the page\n+                    // This is the first page \n+                    if ( ( level.currentPos == 0 ) && ( node.getKey( 0 ) == null ) )\n+                    {\n+                        // First element of the page\n+                        node.setPageHolder( 0, pageHolder );\n+                    }\n+                    else\n+                    {\n+                        // Any other following elements\n+                        // Inject the pageHolder and the page leftmost key\n+                        node.setPageHolder( level.currentPos, pageHolder );\n+                        KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(),\n+                            page.getLeftMostKey() );\n+                        node.setKey( level.currentPos - 1, keyHolder );\n+                    }\n+\n+                    // Now, increment this level nb of added elements\n+                    level.currentPos++;\n+                    level.nbAddedElems++;\n+\n+                    // Check if we are done with the page\n+                    if ( level.currentPos == node.getNbElems() + 1 )\n+                    {\n+                        // Yes, we have to update the parent\n+                        injectInNode( btree, node, levels, levelIndex + 1 );\n+\n+                        // An create a new one\n+                        level.currentPage = BTreeFactory.createNode( btree, 0L, pageSize / 2 );\n+                        level.currentPos = 0;\n+                    }\n+                }\n+\n+                return;\n+            }\n+        }\n+    }\n+\n+\n+    private BTree<K, V> bulkLoadSinglePage( BTree<K, V> btree, Iterator<Tuple<K, Set<V>>> dataIterator, int nbElems )\n+        throws IOException\n+    {\n+        // Create a new page\n+        PersistedLeaf<K, V> rootPage = ( PersistedLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0L, nbElems );\n+\n+        // We first have to inject data into the page\n+        int pos = 0;\n+\n+        while ( dataIterator.hasNext() )\n+        {\n+            Tuple<K, Set<V>> tuple = dataIterator.next();\n+\n+            // Store the current element in the rootPage\n+            KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), tuple.getKey() );\n+            ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, ( V[] ) tuple.getValue().toArray() );\n+            rootPage.setKey( pos, keyHolder );\n+            rootPage.setValue( pos, valueHolder );\n+            pos++;\n+        }\n+\n+        // Now write the page on disk\n+        ( ( PersistedBTree<K, V> ) btree ).getRecordManager().writePage( btree, rootPage, 0L );\n+\n+        // Update the btree with the rootPage and the nb of added elements\n+        ( ( PersistedBTree<K, V> ) btree ).getBtreeHeader().setRootPage( rootPage );\n+        ( ( PersistedBTree<K, V> ) btree ).getBtreeHeader().setNbElems( nbElems );\n+\n+        return btree;\n+    }\n+\n+\n+    /**\n+     * Construct the target BTree from the sorted data. We will use the nb of elements\n+     * to determinate the structure of the BTree, as it must be balanced\n+     */\n+    private BTree<K, V> bulkLoad( BTree<K, V> btree, Iterator<Tuple<K, Set<V>>> dataIterator, int nbElems )\n+        throws IOException\n+    {\n+        int pageSize = btree.getPageSize();\n+\n+        // Special case : we can store all the element sin a single page\n+        if ( nbElems <= pageSize )\n+        {\n+            return bulkLoadSinglePage( btree, dataIterator, nbElems );\n+        }\n+\n+        // Ok, we will need more than one page to store the elements, which\n+        // means we also will need more than one level.\n+        // First, compute the needed number of levels.\n+        List<LevelInfo> levels = computeLevels( btree, nbElems );\n+\n+        // Now, let's fill the levels\n+        LevelInfo leafLevel = levels.get( 0 );\n+        int nbRead = 0;\n+\n+        while ( dataIterator.hasNext() )\n+        {\n+            nbRead++;\n+            //System.out.println( \"Adding #\" + nbRead );\n+            //System.out.println( \"--------------------------------------------------------\" );\n+\n+            //for ( int i = 0; i < leafLevel.currentPage.getNbElems(); i++ )\n+            //{\n+            //    System.out.println( \"Key[\" + i + \"] = \" + leafLevel.currentPage.getKey( i ) );\n+            //}\n+\n+            // let's fill page up to the point all the complete pages have been filled\n+            if ( leafLevel.nbAddedElems < leafLevel.nbElemsLimit )\n+            {\n+                // grab a tuple\n+                Tuple<K, Set<V>> tuple = dataIterator.next();\n+\n+                injectInLeaf( btree, tuple, leafLevel );\n+                leafLevel.nbAddedElems++;\n+\n+                // The page is completed, update the parent's node and create a new current page\n+                if ( leafLevel.currentPos == pageSize )\n+                {\n+                    //System.out.println( leafLevel.currentPage );\n+                    injectInNode( btree, leafLevel.currentPage, levels, 1 );\n+\n+                    // The page is full, we have to create a new one\n+                    leafLevel.currentPage = BTreeFactory.createLeaf( btree, 0L, computeNbElemsLeaf( btree, leafLevel ) );\n+                    leafLevel.currentPos = 0;\n+                }\n+            }\n+            else\n+            {\n+                // We have to deal with uncompleted pages now (if we have any)\n+                if ( leafLevel.nbAddedElems == nbElems )\n+                {\n+                    // First use case : we have injected all the elements in the btree : get out\n+                    break;\n+                }\n+\n+                if ( nbElems - leafLevel.nbElemsLimit > pageSize )\n+                {\n+                    // Second use case : the number of elements after the limit does not\n+                    // fit in a page, that means we have to split it into\n+                    // two pages\n+\n+                    // First page will contain nbElems - leafLevel.nbElemsLimit - PageSize/2 elements\n+                    int nbToAdd = nbElems - leafLevel.nbElemsLimit - pageSize / 2;\n+\n+                    while ( nbToAdd > 0 )\n+                    {\n+                        // grab a tuple\n+                        Tuple<K, Set<V>> tuple = dataIterator.next();\n+\n+                        injectInLeaf( btree, tuple, leafLevel );\n+                        leafLevel.nbAddedElems++;\n+                        nbToAdd--;\n+                    }\n+\n+                    // Now inject the page into the node\n+                    injectInNode( btree, leafLevel.currentPage, levels, 1 );\n+                    //System.out.println( leafLevel.currentPage );\n+\n+                    // Create a new page for the remaining elements\n+                    nbToAdd = pageSize / 2;\n+                    leafLevel.currentPage = BTreeFactory.createLeaf( btree, 0L, nbToAdd );\n+                    leafLevel.currentPos = 0;\n+\n+                    while ( nbToAdd > 0 )\n+                    {\n+                        // grab a tuple\n+                        Tuple<K, Set<V>> tuple = dataIterator.next();\n+\n+                        injectInLeaf( btree, tuple, leafLevel );\n+                        leafLevel.nbAddedElems++;\n+                        nbToAdd--;\n+                    }\n+\n+                    // And update the parent node\n+                    injectInNode( btree, leafLevel.currentPage, levels, 1 );\n+\n+                    // We are done\n+                    //System.out.println( leafLevel.currentPage );\n+                    break;\n+                }\n+                else\n+                {\n+                    // Third use case : we can push all the elements in the last page.\n+                    // Let's do it\n+                    int nbToAdd = nbElems - leafLevel.nbElemsLimit;\n+\n+                    while ( nbToAdd > 0 )\n+                    {\n+                        // grab a tuple\n+                        Tuple<K, Set<V>> tuple = dataIterator.next();\n+\n+                        injectInLeaf( btree, tuple, leafLevel );\n+                        leafLevel.nbAddedElems++;\n+                        nbToAdd--;\n+                    }\n+\n+                    // Now inject the page into the node\n+                    injectInNode( btree, leafLevel.currentPage, levels, 1 );\n+\n+                    // and we are done\n+                    //System.out.println( leafLevel.currentPage );\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return btree;\n+    }\n+\n+\n+    /**\n+     * Flush a list of tuples to disk after having sorted them. In the process, we may have to gather the values\n+     * for the tuples having the same keys.\n+     * @throws IOException \n+     */\n+    private File flushToDisk( int fileNb, List<Tuple<K, V>> tuples, BTree<K, V> btree ) throws IOException\n+    {\n+        //System.out.println( \"Sorted values for file nb[\" + fileNb + \"] : \" );\n+\n+        // Sort the tuples. \n+        Tuple<K, Set<V>>[] sortedTuples = sort( btree, tuples );\n+\n+        boolean isFirst = true;\n+        for ( Tuple<K, Set<V>> tuple : sortedTuples )\n+        {\n+            if ( isFirst )\n+            {\n+                isFirst = false;\n+            }\n+            else\n+            {\n+                //System.out.print( \", \" );\n+            }\n+\n+            //System.out.print( tuple.getKey() );\n+        }\n+\n+        //System.out.println();\n+\n+        File file = File.createTempFile( \"sorted\", Integer.toString( fileNb ) );\n+        file.deleteOnExit();\n+        FileOutputStream fos = new FileOutputStream( file );\n+\n+        // Flush the tuples on disk\n+        for ( Tuple<K, Set<V>> tuple : sortedTuples )\n+        {\n+            // Serialize the key\n+            byte[] bytesKey = btree.getKeySerializer().serialize( tuple.key );\n+            fos.write( IntSerializer.serialize( bytesKey.length ) );\n+            fos.write( bytesKey );\n+\n+            // Serialize the number of values\n+            int nbValues = tuple.getValue().size();\n+            fos.write( IntSerializer.serialize( nbValues ) );\n+\n+            // Serialize the values\n+            for ( V value : tuple.getValue() )\n+            {\n+                byte[] bytesValue = btree.getValueSerializer().serialize( value );\n+\n+                // Serialize the value\n+                fos.write( IntSerializer.serialize( bytesValue.length ) );\n+                fos.write( bytesValue );\n+            }\n+        }\n+\n+        fos.flush();\n+        fos.close();\n+\n+        return file;\n+    }\n+\n+\n+    /**\n+     * Sort a list of tuples, eliminating the duplicate keys and storing the values in a set when we \n+     * have a duplicate key\n+     */\n+    private Tuple<K, Set<V>>[] sort( BTree<K, V> btree, List<Tuple<K, V>> tuples )\n+    {\n+        Comparator<Tuple<K, Set<V>>> tupleComparator = new TupleComparator( btree.getKeyComparator(), btree\n+            .getValueComparator() );\n+\n+        // Sort the list\n+        Tuple<K, V>[] tuplesArray = ( Tuple<K, V>[] ) tuples.toArray( new Tuple[]\n+            {} );\n+\n+        // First, eliminate the equals keys. We use a map for that\n+        Map<K, Set<V>> mapTuples = new HashMap<K, Set<V>>();\n+\n+        for ( Tuple<K, V> tuple : tuplesArray )\n+        {\n+            // Is the key present in the map ?\n+            Set<V> foundSet = mapTuples.get( tuple.key );\n+\n+            if ( foundSet != null )\n+            {\n+                // We already have had such a key, add the value to the existing key\n+                foundSet.add( tuple.value );\n+            }\n+            else\n+            {\n+                // No such key present in the map : create a new set to store the values,\n+                // and add it in the map associated with the new key\n+                Set<V> set = new TreeSet<V>();\n+                set.add( tuple.value );\n+                mapTuples.put( tuple.key, set );\n+            }\n+        }\n+\n+        // Now, sort the map, by extracting all the key/values from the map\n+        int size = mapTuples.size();\n+        Tuple<K, Set<V>>[] sortedTuples = new Tuple[size];\n+        int pos = 0;\n+\n+        // We create an array containing all the elements\n+        for ( Map.Entry<K, Set<V>> entry : mapTuples.entrySet() )\n+        {\n+            sortedTuples[pos] = new Tuple<K, Set<V>>();\n+            sortedTuples[pos].key = entry.getKey();\n+            sortedTuples[pos].value = entry.getValue();\n+            pos++;\n+        }\n+\n+        // And we sort the array\n+        Arrays.sort( sortedTuples, tupleComparator );\n+\n+        return sortedTuples;\n+    }\n+\n+\n+    /**\n+     * Build an iterator over an array of sorted tuples, in memory\n+     */\n+    private Iterator<Tuple<K, Set<V>>> createTupleIterator( BTree<K, V> btree, List<Tuple<K, V>> tuples )\n+    {\n+        final Tuple<K, Set<V>>[] sortedTuples = sort( btree, tuples );\n+\n+        Iterator<Tuple<K, Set<V>>> tupleIterator = new Iterator<Tuple<K, Set<V>>>()\n+        {\n+            private int pos = 0;\n+\n+\n+            @Override\n+            public Tuple<K, Set<V>> next()\n+            {\n+                // Return the current tuple, if any\n+                if ( pos < sortedTuples.length )\n+                {\n+                    Tuple<K, Set<V>> tuple = sortedTuples[pos];\n+                    pos++;\n+\n+                    return tuple;\n+                }\n+\n+                return null;\n+            }\n+\n+\n+            @Override\n+            public boolean hasNext()\n+            {\n+                return pos < sortedTuples.length;\n+            }\n+\n+\n+            @Override\n+            public void remove()\n+            {\n+            }\n+        };\n+\n+        return tupleIterator;\n+    }\n+\n+\n+    private Tuple<K, Set<V>> fetchTuple( BTree<K, V> btree, FileInputStream fis )\n+    {\n+        try\n+        {\n+            if ( fis.available() == 0 )\n+            {\n+                return null;\n+            }\n+\n+            Tuple<K, Set<V>> tuple = new Tuple<K, Set<V>>();\n+            tuple.value = new TreeSet<V>();\n+\n+            byte[] intBytes = new byte[4];\n+\n+            // Read the key length\n+            fis.read( intBytes );\n+            int keyLength = IntSerializer.deserialize( intBytes );\n+\n+            // Read the key\n+            byte[] keyBytes = new byte[keyLength];\n+            fis.read( keyBytes );\n+            K key = btree.getKeySerializer().fromBytes( keyBytes );\n+            tuple.key = key;\n+\n+            // get the number of values\n+            fis.read( intBytes );\n+            int nbValues = IntSerializer.deserialize( intBytes );\n+\n+            // Serialize the values\n+            for ( int i = 0; i < nbValues; i++ )\n+            {\n+                // Read the value length\n+                fis.read( intBytes );\n+                int valueLength = IntSerializer.deserialize( intBytes );\n+\n+                // Read the value\n+                byte[] valueBytes = new byte[valueLength];\n+                fis.read( valueBytes );\n+                V value = btree.getValueSerializer().fromBytes( valueBytes );\n+                tuple.value.add( value );\n+            }\n+\n+            return tuple;\n+        }\n+        catch ( IOException ioe )\n+        {\n+            return null;\n+        }\n+    }\n+\n+\n+    /**\n+     * Build an iterator over an array of sorted tuples, from files on the disk\n+     * @throws FileNotFoundException \n+     */\n+    private Iterator<Tuple<K, Set<V>>> createIterator( final BTree<K, V> btree, final FileInputStream[] streams )\n+        throws FileNotFoundException\n+    {\n+        // The number of files we have to read from\n+        final int nbFiles = streams.length;\n+\n+        // We will read only one element at a time from each file\n+        final Tuple<K, Set<V>>[] readTuples = new Tuple[nbFiles];\n+        final TreeSet<Tuple<K, Integer>> candidateSet =\n+            new TreeSet<Tuple<K, Integer>>(\n+                new TupleComparator<K, Integer>( btree.getKeyComparator(), IntComparator.INSTANCE ) );\n+\n+        // Read the tuple from each files\n+        for ( int i = 0; i < nbFiles; i++ )\n+        {\n+            while ( true )\n+            {\n+                readTuples[i] = fetchTuple( btree, streams[i] );\n+                //System.out.println( \"Fetched tuple \" + readTuples[i] + \" from file \" + i );\n+\n+                if ( readTuples[i] != null )\n+                {\n+                    Tuple<K, Integer> candidate = new Tuple<K, Integer>( readTuples[i].key, i, btree.getKeySerializer()\n+                        .getComparator() );\n+\n+                    if ( !candidateSet.contains( candidate ) )\n+                    {\n+                        //System.out.println( \"Added candidate \" + candidate + \" to the set of candidates\" );\n+                        candidateSet.add( candidate );\n+                        break;\n+                    }\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        int pos = 0;\n+        Iterator<Tuple<K, Integer>> iterator = candidateSet.iterator();\n+\n+        while ( iterator.hasNext() )\n+        {\n+            Tuple<K, Integer> candidate = iterator.next();\n+            //System.out.println( \"candidate[\" + pos + \"] = \" + candidate.getKey() );\n+            pos++;\n+        }\n+\n+        Iterator<Tuple<K, Set<V>>> tupleIterator = new Iterator<Tuple<K, Set<V>>>()\n+        {\n+            private int pos = 0;\n+\n+\n+            @Override\n+            public Tuple<K, Set<V>> next()\n+            {\n+                // Get the first candidate\n+                Tuple<K, Integer> tupleCandidate = candidateSet.first();\n+\n+                // Remove it from the set\n+                candidateSet.remove( tupleCandidate );\n+\n+                // Get the the next tuple from the stream we just got the tuple from\n+                Tuple<K, Set<V>> tuple = readTuples[tupleCandidate.value];\n+\n+                // fetch it from the disk and store it into its reader\n+                readTuples[tupleCandidate.value] = fetchTuple( btree, streams[tupleCandidate.value] );\n+                //System.out.println( \"Next : fetched new tuple from file nb \" + tupleCandidate.value + \" : \"\n+                //    + readTuples[tupleCandidate.value] );\n+\n+                if ( readTuples[tupleCandidate.value] != null )\n+                {\n+                    // And store it into the candidate set\n+                    Tuple<K, Integer> newTuple = new Tuple<K, Integer>( readTuples[tupleCandidate.value].key,\n+                        tupleCandidate.value );\n+                    candidateSet.add( newTuple );\n+                }\n+\n+                int pos = 0;\n+                Iterator<Tuple<K, Integer>> iterator = candidateSet.iterator();\n+\n+                while ( iterator.hasNext() )\n+                {\n+                    Tuple<K, Integer> candidate = iterator.next();\n+                    //System.out.println( \"candidate[\" + pos + \"] = \" + candidate.getKey() );\n+                    pos++;\n+                }\n+\n+                // We can now return the found value\n+                //System.out.println( \"Returning selected tuple : \" + tuple );\n+                return tuple;\n+            }\n+\n+\n+            @Override\n+            public boolean hasNext()\n+            {\n+                // Check that we have at least one element to read\n+                return !candidateSet.isEmpty();\n+            }\n+\n+\n+            @Override\n+            public void remove()\n+            {\n+            }\n+\n+        };\n+\n+        return tupleIterator;\n+    }\n+\n+\n+    /**\n+     * Compact a given persisted BTree, making it dense. All the values will be stored \n+     * in newly created pages, each one of them containing as much elements\n+     * as it's size.\n+     * </br>\n+     * The RecordManager will be stopped and restarted, do not use this method\n+     * on a running BTree.\n+     *\n+     * @param recordManager The associated recordManager\n+     * @param btree The BTree to compact\n+     */\n+    public static void compact( RecordManager recordManager, BTree<?, ?> btree )\n+    {\n+\n+    }\n+\n+\n+    /**\n+     * Compact a given in-memory BTree, making it dense. All the values will be stored \n+     * in newly created pages, each one of them containing as much elements\n+     * as it's size.\n+     * </br>\n+     *\n+     * @param btree The BTree to compact\n+     * @throws KeyNotFoundException \n+     * @throws IOException \n+     */\n+    public static BTree<?, ?> compact( BTree<?, ?> btree ) throws IOException, KeyNotFoundException\n+    {\n+        // First, create a new BTree which will contain all the elements\n+        InMemoryBTreeConfiguration configuration = new InMemoryBTreeConfiguration();\n+        configuration.setName( btree.getName() );\n+        configuration.setPageSize( btree.getPageSize() );\n+        configuration.setKeySerializer( btree.getKeySerializer() );\n+        configuration.setValueSerializer( btree.getValueSerializer() );\n+        configuration.setAllowDuplicates( btree.isAllowDuplicates() );\n+        configuration.setReadTimeOut( btree.getReadTimeOut() );\n+        configuration.setWriteBufferSize( btree.getWriteBufferSize() );\n+\n+        File file = ( ( InMemoryBTree ) btree ).getFile();\n+\n+        if ( file != null )\n+        {\n+            configuration.setFilePath( file.getPath() );\n+        }\n+\n+        // Create a new Btree Builder\n+        InMemoryBTreeBuilder btreeBuilder = new InMemoryBTreeBuilder( configuration );\n+\n+        // Create a cursor over the existing btree\n+        final TupleCursor cursor = btree.browse();\n+\n+        // Create an iterator that will iterate the existing btree\n+        Iterator<Tuple> tupleItr = new Iterator<Tuple>()\n+        {\n+            @Override\n+            public Tuple next()\n+            {\n+                try\n+                {\n+                    return cursor.next();\n+                }\n+                catch ( EndOfFileExceededException e )\n+                {\n+                    return null;\n+                }\n+                catch ( IOException e )\n+                {\n+                    return null;\n+                }\n+            }\n+\n+\n+            @Override\n+            public boolean hasNext()\n+            {\n+                try\n+                {\n+                    return cursor.hasNext();\n+                }\n+                catch ( EndOfFileExceededException e )\n+                {\n+                    return false;\n+                }\n+                catch ( IOException e )\n+                {\n+                    return false;\n+                }\n+            }\n+\n+\n+            @Override\n+            public void remove()\n+            {\n+            }\n+        };\n+\n+        // And finally, compact the btree\n+        return btreeBuilder.build( tupleItr );\n+    }\n+}", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java"}, {"additions": 372, "raw_url": "https://github.com/apache/directory-mavibot/raw/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTreeBuilder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTreeBuilder.java", "sha": "a8aadd264db629cb2e870181b2ebb6722f4c3250", "changes": 422, "status": "modified", "deletions": 50, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTreeBuilder.java?ref=bb9e17fe79199d876762b7d24c05c6b430a73408", "patch": "@@ -37,94 +37,415 @@\n  */\n public class InMemoryBTreeBuilder<K, V>\n {\n-    private String name;\n-\n-    private int numKeysInNode;\n-\n-    private ElementSerializer<K> keySerializer;\n-\n-    private ElementSerializer<V> valueSerializer;\n-\n-\n+    /** The Btree configuration */\n+    private InMemoryBTreeConfiguration<K, V> btreeConfiguration;\n+\n+\n+    /**\n+     * Creates a new instance of InMemoryBTreeBuilder.\n+     *\n+     * @param name The BTree name\n+     * @param numKeysInNode The number of keys per node\n+     * @param keySerializer The key serializer\n+     * @param valueSerializer The value  serializer\n+     */\n     public InMemoryBTreeBuilder( String name, int numKeysInNode, ElementSerializer<K> keySerializer,\n         ElementSerializer<V> valueSerializer )\n     {\n-        this.name = name;\n-        this.numKeysInNode = numKeysInNode;\n-        this.keySerializer = keySerializer;\n-        this.valueSerializer = valueSerializer;\n+        btreeConfiguration = new InMemoryBTreeConfiguration<K, V>();\n+        btreeConfiguration.setName( name );\n+        btreeConfiguration.setPageSize( numKeysInNode );\n+        btreeConfiguration.setKeySerializer( keySerializer );\n+        btreeConfiguration.setValueSerializer( valueSerializer );\n+    }\n+\n+\n+    /**\n+     * Creates a new instance of InMemoryBTreeBuilder.\n+     *\n+     * @param btreeConfiguration The Btree configuration\n+     */\n+    public InMemoryBTreeBuilder( InMemoryBTreeConfiguration<K, V> btreeConfiguration )\n+    {\n+        this.btreeConfiguration = btreeConfiguration;\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public BTree<K, V> build( Iterator<Tuple<K, V>> sortedTupleItr ) throws IOException\n     {\n-        BTree<K, V> btree = BTreeFactory.createInMemoryBTree( name, keySerializer, valueSerializer );\n+        BTree<K, V> btree = BTreeFactory.createInMemoryBTree( btreeConfiguration );\n+        int pageSize = btree.getPageSize();\n+        int maxElements = ( pageSize + 1 ) * pageSize;\n+\n+        // The stack used to store all the levels. No need to have more than 16 levels, \n+        // it will allow the storage of 2^64 elements with pages containing 4 elements each.\n+        List<InMemoryNode<K, V>>[] pageStack = new ArrayList[15];\n+\n+        for ( int i = 0; i < 15; i++ )\n+        {\n+            pageStack[i] = new ArrayList<InMemoryNode<K, V>>( maxElements );\n+        }\n \n-        List<Page<K, V>> lstLeaves = new ArrayList<Page<K, V>>();\n+        // The number of added elements\n+        int nbAdded = 0;\n \n-        int totalTupleCount = 0;\n+        // The btree height\n+        int btreeHeight = 0;\n \n-        InMemoryLeaf<K, V> leaf1 = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0, numKeysInNode );\n-        lstLeaves.add( leaf1 );\n+        // An array containing the number of elements necessary to fulfill a layer :\n+        // pageSize * (pageSize + 1)\n+        List<Tuple<K, V>> tuples = new ArrayList<Tuple<K, V>>( maxElements );\n \n-        int leafIndex = 0;\n+        // A list of nodes that are going to be created\n+        List<InMemoryNode<K, V>> nodes = new ArrayList<InMemoryNode<K, V>>();\n \n+        // Now, loop on all the elements\n         while ( sortedTupleItr.hasNext() )\n         {\n+            nbAdded++;\n+\n+            // Get the tuple to inject\n             Tuple<K, V> tuple = sortedTupleItr.next();\n+            tuples.add( tuple );\n \n-            BTreeFactory.setKey( btree, leaf1, leafIndex, tuple.getKey() );\n+            if ( tuples.size() == maxElements )\n+            {\n+                // We have enough elements to create pageSize leaves, and the upper node\n+                InMemoryNode<K, V> node = ( InMemoryNode<K, V> ) addLeaves( btree, tuples, maxElements );\n+                int level = 0;\n+\n+                if ( node != null )\n+                {\n+                    while ( true )\n+                    {\n+                        pageStack[level].add( node );\n+\n+                        // If the node list has enough elements to fulfill a parent node,\n+                        // then process \n+                        if ( pageStack[level].size() > btree.getPageSize() )\n+                        {\n+                            node = createParentNode( btree, pageStack[level], btree.getPageSize() );\n+                            pageStack[level].clear();\n+                            level++;\n+                        }\n+                        else\n+                        {\n+                            break;\n+                        }\n+                    }\n+\n+                    ( ( AbstractBTree<K, V> ) btree ).setRootPage( pageStack[level].get( 0 ) );\n+\n+                    // Update the btree height\n+                    if ( btreeHeight < level )\n+                    {\n+                        btreeHeight = level;\n+                    }\n+                }\n+\n+                tuples.clear();\n+            }\n+        }\n \n-            InMemoryValueHolder<V> eh = new InMemoryValueHolder<V>( btree, tuple.getValue() );\n+        if ( tuples.size() > 0 )\n+        {\n+            // Let's deal with the remaining elements\n+            Page<K, V> page = addLeaves( btree, tuples, maxElements );\n \n-            BTreeFactory.setValue( btree, leaf1, leafIndex, eh );\n+            if ( page instanceof InMemoryNode )\n+            {\n+                nodes.add( ( InMemoryNode<K, V> ) page );\n \n-            leafIndex++;\n-            totalTupleCount++;\n+                // If the node list has enough elements to fulfill a parent node,\n+                // then process \n+                if ( nodes.size() == maxElements )\n+                {\n+                    Page<K, V> rootPage = createParentNode( btree, nodes, maxElements );\n \n-            if ( ( totalTupleCount % numKeysInNode ) == 0 )\n+                    ( ( AbstractBTree<K, V> ) btree ).setRootPage( rootPage );\n+                }\n+            }\n+            else\n             {\n-                leafIndex = 0;\n-                leaf1 = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0, numKeysInNode );\n-                lstLeaves.add( leaf1 );\n+                InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) page;\n+\n+                // Its a leaf. That means we may have to balance the btree\n+                if ( pageStack[0].size() != 0 )\n+                {\n+                    // We have some leaves in level 0, which means we just have to add the new leaf\n+                    // there, after having check we don't have to borrow some elements from the last leaf\n+                    if ( leaf.getNbElems() < btree.getPageSize() / 2 )\n+                    {\n+                        // Not enough elements in the added leaf. Borrow some from the left.\n+                    }\n+                    else\n+                    {\n+                        // Enough elements in the added leaf (at least N/2). We just have to update\n+                        // the parent's node.\n+                    }\n+                }\n             }\n         }\n \n-        if ( lstLeaves.isEmpty() )\n+        // Update the number of elements\n+        ( ( AbstractBTree<K, V> ) btree ).getBtreeHeader().setNbElems( nbAdded );\n+\n+        return btree;\n+    }\n+\n+\n+    /**\n+     * Creates all the nodes using the provided node pages, and update the upper laye\n+     */\n+    private InMemoryNode<K, V> createParentNode( BTree<K, V> btree, List<InMemoryNode<K, V>> nodes, int maxElements )\n+    {\n+        // We have enough tuples to fulfill the upper node.\n+        // First, create the new node\n+        InMemoryNode<K, V> parentNode = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0,\n+            btreeConfiguration.getPageSize() );\n+\n+        int nodePos = 0;\n+\n+        // Then iterate on the tuples, creating the needed pages\n+        for ( InMemoryNode<K, V> node : nodes )\n         {\n-            return btree;\n+            if ( nodePos == 0 )\n+            {\n+                PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, node );\n+                parentNode.setPageHolder( nodePos, pageHolder );\n+            }\n+            else if ( nodePos == btree.getPageSize() )\n+            {\n+                K key = node.getLeftMostKey();\n+                BTreeFactory.setKey( btree, parentNode, nodePos - 1, key );\n+                PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, node );\n+                parentNode.setPageHolder( nodePos, pageHolder );\n+            }\n+            else\n+            {\n+                K key = node.getLeftMostKey();\n+                BTreeFactory.setKey( btree, parentNode, nodePos - 1, key );\n+                PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, node );\n+                parentNode.setPageHolder( nodePos, pageHolder );\n+            }\n+\n+            nodePos++;\n+        }\n+\n+        // And return the node\n+        return parentNode;\n+    }\n+\n+\n+    /**\n+     * Creates all the leaves using the provided tuples, and update the upper layer if needed\n+     */\n+    private Page<K, V> addLeaves( BTree<K, V> btree, List<Tuple<K, V>> tuples, int maxElements )\n+    {\n+        if ( tuples.size() == 0 )\n+        {\n+            // No element to inject in the BTree\n+            return null;\n         }\n \n-        // remove null keys and values from the last leaf and resize\n-        InMemoryLeaf<K, V> lastLeaf = ( InMemoryLeaf<K, V> ) lstLeaves.get( lstLeaves.size() - 1 );\n+        // The insertion position in the leaf\n+        int leafPos = 0;\n \n-        for ( int i = 0; i < lastLeaf.getNbElems(); i++ )\n+        // Deal with special cases : \n+        // First, everything will fit in a single page\n+        if ( tuples.size() < btree.getPageSize() )\n         {\n-            if ( lastLeaf.getKeys()[i] == null )\n+            // The leaf will be the rootPage\n+            // creates a first leaf\n+            InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0,\n+                btreeConfiguration.getPageSize() );\n+\n+            // Iterate on the tuples\n+            for ( Tuple<K, V> tuple : tuples )\n             {\n-                int n = i;\n-                lastLeaf.setNbElems( n );\n-                KeyHolder<K>[] keys = lastLeaf.getKeys();\n+                injectTuple( btree, leaf, leafPos, tuple );\n+                leafPos++;\n+            }\n+\n+            return leaf;\n+        }\n \n-                lastLeaf.setKeys( ( KeyHolder[] ) Array.newInstance( KeyHolder.class, n ) );\n-                System.arraycopy( keys, 0, lastLeaf.getKeys(), 0, n );\n+        // Second, the data will fit into a 2 level tree\n+        if ( tuples.size() < maxElements )\n+        {\n+            // We will just create the necessary leaves and the upper node if needed\n+            // We have enough tuples to fulfill the uper node.\n+            // First, create the new node\n+            InMemoryNode<K, V> node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0,\n+                btreeConfiguration.getPageSize() );\n \n-                ValueHolder<V>[] values = lastLeaf.values;\n-                lastLeaf.values = ( InMemoryValueHolder<V>[] ) Array.newInstance( InMemoryValueHolder.class, n );\n-                System.arraycopy( values, 0, lastLeaf.values, 0, n );\n+            // creates a first leaf\n+            InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0,\n+                btreeConfiguration.getPageSize() );\n \n-                break;\n+            int nodePos = 0;\n+\n+            // Then iterate on the tuples, creating the needed pages\n+            for ( Tuple<K, V> tuple : tuples )\n+            {\n+                if ( leafPos == btree.getPageSize() )\n+                {\n+                    // The leaf is full, we need to attach it to its parent's node\n+                    // and to create a new leaf\n+                    BTreeFactory.setKey( btree, node, nodePos, tuple.getKey() );\n+                    PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, leaf );\n+                    node.setPageHolder( nodePos, pageHolder );\n+                    nodePos++;\n+\n+                    // When done, we need to create a new leaf\n+                    leaf = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0,\n+                        btree.getPageSize() );\n+\n+                    // and inject the tuple in the leaf\n+                    injectTuple( btree, leaf, 0, tuple );\n+                    leafPos = 1;\n+                }\n+                else\n+                {\n+                    // Inject the tuple in the leaf\n+                    injectTuple( btree, leaf, leafPos, tuple );\n+                    leafPos++;\n+                }\n             }\n+\n+            // Last, not least, deal with the last created leaf, which has to be injected in its parent's node\n+            if ( leafPos > 0 )\n+            {\n+                PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, leaf );\n+                node.setPageHolder( nodePos, pageHolder );\n+            }\n+\n+            return node;\n         }\n+        else\n+        {\n+            // We have enough tuples to fulfill the upper node.\n+            // First, create the new node\n+            InMemoryNode<K, V> node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0,\n+                btreeConfiguration.getPageSize() );\n \n-        Page<K, V> rootPage = attachNodes( lstLeaves, btree );\n+            // creates a first leaf\n+            InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0,\n+                btreeConfiguration.getPageSize() );\n \n-        System.out.println( \"built rootpage : \" + rootPage );\n+            int nodePos = 0;\n \n-        ( ( AbstractBTree<K, V> ) btree ).setRootPage( rootPage );\n+            // Then iterate on the tuples, creating the needed pages\n+            for ( Tuple<K, V> tuple : tuples )\n+            {\n+                if ( leafPos == btree.getPageSize() )\n+                {\n+                    // The leaf is full, we need to attach it to its parent's node\n+                    // and to create a new node\n+                    BTreeFactory.setKey( btree, node, nodePos, tuple.getKey() );\n+                    PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, leaf );\n+                    node.setPageHolder( nodePos, pageHolder );\n+                    nodePos++;\n+\n+                    // When done, we need to create a new leaf\n+                    leaf = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0,\n+                        btree.getPageSize() );\n+\n+                    // and inject the tuple in the leaf\n+                    injectTuple( btree, leaf, 0, tuple );\n+                    leafPos = 1;\n+                }\n+                else\n+                {\n+                    // Inject the tuple in the leaf\n+                    injectTuple( btree, leaf, leafPos, tuple );\n+                    leafPos++;\n+                }\n+            }\n \n-        return btree;\n+            // Last, not least, deal with the last created leaf, which has to be injected in its parent's node\n+            if ( leafPos > 0 )\n+            {\n+                PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, leaf );\n+                node.setPageHolder( nodePos, pageHolder );\n+            }\n+\n+            // And return the node\n+            return node;\n+        }\n+    }\n+\n+\n+    private void injectTuple( BTree<K, V> btree, InMemoryLeaf<K, V> leaf, int leafPos, Tuple<K, V> tuple )\n+    {\n+        BTreeFactory.setKey( btree, leaf, leafPos, tuple.getKey() );\n+        ValueHolder<V> valueHolder = new InMemoryValueHolder<V>( btree, tuple.getValue() );\n+        BTreeFactory.setValue( btree, leaf, leafPos, valueHolder );\n+    }\n+\n+\n+    private int add( BTree<K, V> btree, Page<K, V>[] pageStack, int level, Page<K, V> page, Tuple<K, V> tuple )\n+    {\n+        if ( page == null )\n+        {\n+            // No existing page at this level, create a new one\n+            if ( level == 0 )\n+            {\n+                // creates a leaf\n+                InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0,\n+                    btreeConfiguration.getPageSize() );\n+\n+                // Store the new leaf in the stack\n+                pageStack[level] = leaf;\n+\n+                // Inject the tuple in the leaf\n+                BTreeFactory.setKey( btree, leaf, 0, tuple.getKey() );\n+                ValueHolder<V> valueHolder = new InMemoryValueHolder<V>( btree, tuple.getValue() );\n+                BTreeFactory.setValue( btree, leaf, 0, valueHolder );\n+            }\n+            else\n+            {\n+                // Create a node\n+                InMemoryNode<K, V> node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0,\n+                    btreeConfiguration.getPageSize() );\n+\n+                // Inject the tuple key in the node\n+                BTreeFactory.setKey( btree, node, 0, tuple.getKey() );\n+                PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, pageStack[level - 1] );\n+                node.setPageHolder( 0, pageHolder );\n+            }\n+        }\n+        else\n+        {\n+            // Check first if the current page is full\n+            if ( page.getNbElems() == btree.getPageSize() )\n+            {\n+                // Ok, it's full. We need to create a new page and to propagate the\n+                // added element to the upper level\n+            }\n+            else\n+            {\n+                // We just have to inject the tuple in the current page\n+                // be it a leaf or a node\n+                if ( page.isLeaf() )\n+                {\n+                    // It's a leaf\n+                    BTreeFactory.setKey( btree, page, page.getNbElems(), tuple.getKey() );\n+                    ValueHolder<V> valueHolder = new InMemoryValueHolder<V>( btree, tuple.getValue() );\n+                    BTreeFactory.setValue( btree, page, page.getNbElems(), valueHolder );\n+                }\n+                else\n+                {\n+                    // It's a node\n+                    BTreeFactory.setKey( btree, page, page.getNbElems(), tuple.getKey() );\n+                    PageHolder<K, V> pageHolder = new PageHolder<K, V>( btree, pageStack[level - 1] );\n+                    ( ( InMemoryNode<K, V> ) page ).setPageHolder( page.getNbElems(), pageHolder );\n+                }\n+            }\n+        }\n+\n+        return level;\n     }\n \n \n@@ -138,9 +459,10 @@ public InMemoryBTreeBuilder( String name, int numKeysInNode, ElementSerializer<K\n \n         List<Page<K, V>> lstNodes = new ArrayList<Page<K, V>>();\n \n-        int numChildren = numKeysInNode + 1;\n+        int numChildren = btreeConfiguration.getPageSize() + 1;\n \n-        InMemoryNode<K, V> node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0, numKeysInNode );\n+        InMemoryNode<K, V> node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0,\n+            btreeConfiguration.getPageSize() );\n         lstNodes.add( node );\n         int i = 0;\n         int totalNodes = 0;\n@@ -160,7 +482,7 @@ public InMemoryBTreeBuilder( String name, int numKeysInNode, ElementSerializer<K\n             if ( ( totalNodes % numChildren ) == 0 )\n             {\n                 i = 0;\n-                node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0, numKeysInNode );\n+                node = ( InMemoryNode<K, V> ) BTreeFactory.createNode( btree, 0, btreeConfiguration.getPageSize() );\n                 lstNodes.add( node );\n             }\n         }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTreeBuilder.java"}, {"additions": 9, "raw_url": "https://github.com/apache/directory-mavibot/raw/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/KeyHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/KeyHolder.java", "sha": "6a8a31e074b06c93fded9a32d5c1d1f30091de1e", "changes": 9, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/KeyHolder.java?ref=bb9e17fe79199d876762b7d24c05c6b430a73408", "patch": "@@ -60,4 +60,13 @@\n     {\n         return key;\n     }\n+\n+\n+    /**\n+     * @see Object#toString()\n+     */\n+    public String toString()\n+    {\n+        return key.toString();\n+    }\n }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/KeyHolder.java"}, {"additions": 41, "raw_url": "https://github.com/apache/directory-mavibot/raw/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/bb9e17fe79199d876762b7d24c05c6b430a73408/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java", "sha": "9f1d9aa80446af8b48bb15095ceffe0cb6f7921b", "changes": 80, "status": "modified", "deletions": 39, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java?ref=bb9e17fe79199d876762b7d24c05c6b430a73408", "patch": "@@ -68,10 +68,11 @@\n \n     /** The BtreeInfo offset */\n     private long btreeInfoOffset;\n-    \n+\n     /** The internal recordManager */\n     private RecordManager recordManager;\n \n+\n     /**\n      * Creates a new BTree, with no initialization.\n      */\n@@ -124,20 +125,20 @@\n \n         switch ( btreeType )\n         {\n-            case BTREE_OF_BTREES :\n-            case COPIED_PAGES_BTREE :\n+            case BTREE_OF_BTREES:\n+            case COPIED_PAGES_BTREE:\n                 // We will create a new cache and a new readTransactions map \n                 init( null );\n                 currentBtreeHeader = btreeHeader;\n                 break;\n \n-            case PERSISTED_SUB :\n+            case PERSISTED_SUB:\n                 init( ( PersistedBTree<K, V> ) configuration.getParentBTree() );\n                 btreeRevisions.put( 0L, btreeHeader );\n                 currentBtreeHeader = btreeHeader;\n                 break;\n-                \n-            default :\n+\n+            default:\n                 // We will create a new cache and a new readTransactions map \n                 init( null );\n                 btreeRevisions.put( 0L, btreeHeader );\n@@ -165,13 +166,13 @@ public void init( BTree<K, V> parentBTree )\n             {\n                 cacheSize = 1;\n             }\n-            \n+\n             cache = new LRUMap( cacheSize );\n         }\n         else\n         {\n-            this.cache = ((PersistedBTree<K, V>)parentBTree).getCache();\n-            this.readTransactions = ((PersistedBTree<K, V>)parentBTree).getReadTransactions();\n+            this.cache = ( ( PersistedBTree<K, V> ) parentBTree ).getCache();\n+            this.readTransactions = ( ( PersistedBTree<K, V> ) parentBTree ).getReadTransactions();\n         }\n \n         // Initialize the txnManager thread\n@@ -275,7 +276,7 @@ public void close() throws IOException\n      * @return\n      * @throws IOException\n      */\n-    /* no qualifier */ Tuple<K, V> delete( K key, V value, long revision ) throws IOException\n+    /* no qualifier */Tuple<K, V> delete( K key, V value, long revision ) throws IOException\n     {\n         // We have to start a new transaction, which will be committed or rollbacked\n         // locally. This will duplicate the current BtreeHeader during this phase.\n@@ -328,7 +329,7 @@ public void close() throws IOException\n \n         // Try to delete the entry starting from the root page. Here, the root\n         // page may be either a Node or a Leaf\n-        DeleteResult<K, V> result = btreeHeader.getRootPage().delete( key, value, revision);\n+        DeleteResult<K, V> result = btreeHeader.getRootPage().delete( key, value, revision );\n \n         if ( result instanceof NotPresentResult )\n         {\n@@ -370,11 +371,10 @@ public void close() throws IOException\n         // Write down the data on disk\n         long newBtreeHeaderOffset = recordManager.writeBtreeHeader( this, newBtreeHeader );\n \n-\n         // Update the B-tree of B-trees with this new offset, if we are not already doing so\n         switch ( btreeType )\n         {\n-            case PERSISTED :\n+            case PERSISTED:\n                 // We have a new B-tree header to inject into the B-tree of btrees\n                 recordManager.addInBtreeOfBtrees( getName(), revision, newBtreeHeaderOffset );\n \n@@ -384,19 +384,18 @@ public void close() throws IOException\n                 storeRevision( newBtreeHeader, recordManager.isKeepRevisions() );\n \n                 break;\n-                \n-            case PERSISTED_SUB :\n+\n+            case PERSISTED_SUB:\n                 // Sub-B-trees are only updating the CopiedPage B-tree\n                 recordManager.addInCopiedPagesBtree( getName(), revision, result.getCopiedPages() );\n-                \n+\n                 //btreeRevisions.put( revision, newBtreeHeader );\n \n                 currentRevision.set( revision );\n \n-\n                 break;\n \n-            case BTREE_OF_BTREES :\n+            case BTREE_OF_BTREES:\n                 // The B-tree of B-trees or the copiedPages B-tree has been updated, update the RMheader parameters\n                 recordManager.updateRecordManagerHeader( newBtreeHeaderOffset, -1L );\n \n@@ -408,7 +407,7 @@ public void close() throws IOException\n \n                 break;\n \n-            case COPIED_PAGES_BTREE :\n+            case COPIED_PAGES_BTREE:\n                 // The B-tree of B-trees or the copiedPages B-tree has been updated, update the RMheader parameters\n                 recordManager.updateRecordManagerHeader( -1L, newBtreeHeaderOffset );\n \n@@ -468,39 +467,39 @@ public void close() throws IOException\n         }\n     }\n \n-    \n+\n     private BTreeHeader<K, V> getBTreeHeader( String name )\n     {\n         switch ( btreeType )\n         {\n-            case PERSISTED_SUB : \n+            case PERSISTED_SUB:\n                 return getBtreeHeader();\n-                \n-            case BTREE_OF_BTREES : \n+\n+            case BTREE_OF_BTREES:\n                 return recordManager.getNewBTreeHeader( RecordManager.BTREE_OF_BTREES_NAME );\n-                    \n-            case COPIED_PAGES_BTREE : \n+\n+            case COPIED_PAGES_BTREE:\n                 return recordManager.getNewBTreeHeader( RecordManager.COPIED_PAGE_BTREE_NAME );\n-                \n-            default : \n+\n+            default:\n                 return recordManager.getBTreeHeader( getName() );\n         }\n     }\n \n-    \n+\n     private BTreeHeader<K, V> getNewBTreeHeader( String name )\n     {\n         if ( btreeType == BTreeTypeEnum.PERSISTED_SUB )\n         {\n             return getBtreeHeader();\n         }\n-        \n+\n         BTreeHeader<K, V> btreeHeader = recordManager.getNewBTreeHeader( getName() );\n \n         return btreeHeader;\n     }\n \n-    \n+\n     /**\n      * Insert the tuple into the B-tree rootPage, get back the new rootPage\n      */\n@@ -581,7 +580,7 @@ public void close() throws IOException\n         // Update the B-tree of B-trees with this new offset, if we are not already doing so\n         switch ( btreeType )\n         {\n-            case PERSISTED :\n+            case PERSISTED:\n                 // We have a new B-tree header to inject into the B-tree of btrees\n                 recordManager.addInBtreeOfBtrees( getName(), revision, newBtreeHeaderOffset );\n \n@@ -592,18 +591,18 @@ public void close() throws IOException\n \n                 break;\n \n-            case PERSISTED_SUB :\n+            case PERSISTED_SUB:\n                 // Sub-B-trees are only updating the CopiedPage B-tree\n                 recordManager.addInCopiedPagesBtree( getName(), revision, result.getCopiedPages() );\n-                \n+\n                 // Store the new revision\n                 storeRevision( newBtreeHeader, recordManager.isKeepRevisions() );\n \n                 currentRevision.set( revision );\n \n                 break;\n \n-            case BTREE_OF_BTREES :\n+            case BTREE_OF_BTREES:\n                 // The B-tree of B-trees or the copiedPages B-tree has been updated, update the RMheader parameters\n                 recordManager.updateRecordManagerHeader( newBtreeHeaderOffset, -1L );\n \n@@ -615,7 +614,7 @@ public void close() throws IOException\n \n                 break;\n \n-            case COPIED_PAGES_BTREE :\n+            case COPIED_PAGES_BTREE:\n                 // The B-tree of B-trees or the copiedPages B-tree has been updated, update the RMheader parameters\n                 recordManager.updateRecordManagerHeader( -1L, newBtreeHeaderOffset );\n \n@@ -636,6 +635,7 @@ public void close() throws IOException\n         return result;\n     }\n \n+\n     /**\n      * Write the data in the ByteBuffer, and eventually on disk if needed.\n      *\n@@ -688,6 +688,7 @@ private void writeBuffer( FileChannel channel, ByteBuffer bb, byte[] buffer ) th\n         return pageHolder;\n     }\n \n+\n     /**\n      * Get the rootPzge associated to a give revision.\n      *\n@@ -750,8 +751,8 @@ public void setBtreeInfoOffset( long btreeInfoOffset )\n \n         return readTransaction;\n     }\n-    \n-    \n+\n+\n     /**\n      * {@inheritDoc}\n      */\n@@ -761,7 +762,8 @@ public void setBtreeInfoOffset( long btreeInfoOffset )\n \n         if ( btreeHeader != null )\n         {\n-            ReadTransaction<K, V> readTransaction = new ReadTransaction<K, V>(  recordManager, btreeHeader, readTransactions );\n+            ReadTransaction<K, V> readTransaction = new ReadTransaction<K, V>( recordManager, btreeHeader,\n+                readTransactions );\n \n             readTransactions.add( readTransaction );\n \n@@ -772,7 +774,7 @@ public void setBtreeInfoOffset( long btreeInfoOffset )\n             return null;\n         }\n     }\n-    \n+\n \n     /**\n      * @see Object#toString()", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/32b7b4b2e880590ed33ca76dbda8983761ea3179", "parent": "https://github.com/apache/directory-mavibot/commit/b6102dad2a6809eb4c927007bad0b8147d69271f", "message": "o added support for replacing value of an existing key\no fixed an issue in InMemoryBTree when a key already exists\no fixed an NPE in findLeftMost() findRightMost() of PersistedLeaf of a persisted sub-BTree\no made RevisionName serializable\no added and updated tests", "bug_id": "directory-mavibot_7", "file": [{"additions": 21, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java", "sha": "3038fbc1e9125c0bb007b1373d2f8d1e0809454c", "changes": 21, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -375,4 +375,25 @@ public void add( V value )\n             addInBtree( value );\n         }\n     }\n+    \n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V replaceValueArray( V newValue )\n+    {\n+        if( isSubBtree() )\n+        {\n+            throw new IllegalStateException( \"method is not applicable for the duplicate B-Trees\" );\n+        }\n+        \n+        V tmp = valueArray[0];\n+        \n+        nbArrayElems = 1;\n+        valueArray[0] = newValue;\n+        \n+        return tmp;\n+    }\n+\n }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java"}, {"additions": 5, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTree.java", "sha": "920afccbd953caecd7d2d45ef087cbc294326981", "changes": 5, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTree.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -389,6 +389,11 @@ public void close() throws IOException\n         // a Node or a Leaf\n         InsertResult<K, V> result = newBtreeHeader.getRootPage().insert( key, value, revision );\n \n+        if ( result instanceof ExistsResult )\n+        {\n+            return result;\n+        }\n+\n         if ( result instanceof ModifyResult )\n         {\n             ModifyResult<K, V> modifyResult = ( ( ModifyResult<K, V> ) result );", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryBTree.java"}, {"additions": 6, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryLeaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryLeaf.java", "sha": "83c18ab2c27f7036da174fc7fb7b199e84d55f7c", "changes": 14, "status": "modified", "deletions": 8, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryLeaf.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -748,12 +748,6 @@ else if ( nbElems > 0 )\n \n         boolean valueExists = valueHolder.contains( value );\n \n-        // Check we can add a new value\n-        if ( !valueExists && !btree.isAllowDuplicates() )\n-        {\n-            throw new DuplicateValueNotAllowedException( \"Duplicate values are not allowed\" );\n-        }\n-\n         if ( this.revision != revision )\n         {\n             // The page hasn't been modified yet, we need to copy it first\n@@ -764,19 +758,23 @@ else if ( nbElems > 0 )\n         valueHolder = newLeaf.values[pos];\n         V replacedValue = null;\n \n-        if ( !valueExists )\n+        if ( !valueExists && btree.isAllowDuplicates() )\n         {\n             valueHolder.add( value );\n             newLeaf.values[pos] = valueHolder;\n         }\n-        else\n+        else if ( valueExists && btree.isAllowDuplicates() )\n         {\n             // As strange as it sounds, we need to remove the value to reinject it.\n             // There are cases where the value retrieval just use one part of the\n             // value only (typically for LDAP Entries, where we use the DN)\n             replacedValue = valueHolder.remove( value );\n             valueHolder.add( value );\n         }\n+        else if ( !btree.isAllowDuplicates() )\n+        {\n+            replacedValue = valueHolder.replaceValueArray( value );\n+        }\n \n         // Create the result\n         InsertResult<K, V> result = new ModifyResult<K, V>( newLeaf, replacedValue );", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryLeaf.java"}, {"additions": 53, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java", "sha": "97f5bb385cf1d3f237ef5e8412a8f97ffeb450ee", "changes": 92, "status": "modified", "deletions": 39, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -844,26 +844,29 @@ else if ( nbElems > 0 )\n         // Copy the keys and the values\n         System.arraycopy( keys, 0, newLeaf.keys, 0, nbElems );\n \n-        // It' not enough to copy the ValueHolder, we have to clone them\n-        // as ValueHolders are mutable\n-        int pos = 0;\n-\n-        for ( ValueHolder<V> valueHolder : values )\n+        if ( values != null )\n         {\n-            try\n-            {\n-                newLeaf.values[pos++] = valueHolder.clone();\n-            }\n-            catch ( CloneNotSupportedException e )\n-            {\n-                // TODO Auto-generated catch block\n-                e.printStackTrace();\n-            }\n-\n-            // Stop when we have copied nbElems values\n-            if ( pos == nbElems )\n+            // It' not enough to copy the ValueHolder, we have to clone them\n+            // as ValueHolders are mutable\n+            int pos = 0;\n+            \n+            for ( ValueHolder<V> valueHolder : values )\n             {\n-                break;\n+                try\n+                {\n+                    newLeaf.values[pos++] = valueHolder.clone();\n+                }\n+                catch ( CloneNotSupportedException e )\n+                {\n+                    // TODO Auto-generated catch block\n+                    e.printStackTrace();\n+                }\n+                \n+                // Stop when we have copied nbElems values\n+                if ( pos == nbElems )\n+                {\n+                    break;\n+                }\n             }\n         }\n \n@@ -891,17 +894,6 @@ else if ( nbElems > 0 )\n \n         boolean valueExists = valueHolder.contains( value );\n \n-        // Check we can add a new value\n-        if ( !valueExists && !btree.isAllowDuplicates() )\n-        {\n-            throw new DuplicateValueNotAllowedException( \"Duplicate values are not allowed\" );\n-        }\n-\n-        if ( valueExists )\n-        {\n-            return ExistsResult.EXISTS;\n-        }\n-        \n         if ( this.revision != revision )\n         {\n             // The page hasn't been modified yet, we need to copy it first\n@@ -912,21 +904,24 @@ else if ( nbElems > 0 )\n         valueHolder = newLeaf.values[pos];\n         V replacedValue = null;\n \n-        if ( !valueExists )\n+        if ( !valueExists && btree.isAllowDuplicates() )\n         {\n             valueHolder.add( value );\n             newLeaf.values[pos] = valueHolder;\n         }\n-        else\n+        else if ( valueExists && btree.isAllowDuplicates() )\n         {\n-            // this block should be deleted after fixing MAVIBOT-39\n             // As strange as it sounds, we need to remove the value to reinject it.\n             // There are cases where the value retrieval just use one part of the\n             // value only (typically for LDAP Entries, where we use the DN)\n-            //replacedValue = valueHolder.remove( value );\n-            //valueHolder.add( value );\n+            replacedValue = valueHolder.remove( value );\n+            valueHolder.add( value );\n         }\n-\n+        else if ( !btree.isAllowDuplicates() )\n+        {\n+            replacedValue = valueHolder.replaceValueArray( value );\n+        }\n+        \n         // Create the result\n         InsertResult<K, V> result = new ModifyResult<K, V>( newLeaf, replacedValue );\n         result.addCopiedPage( this );\n@@ -1096,19 +1091,28 @@ public K getRightMostKey()\n      */\n     public Tuple<K, V> findLeftMost() throws IOException\n     {\n+        K key = keys[0].getKey();\n+        \n+        boolean isSubTree = ( btree.getType() == PERSISTED_SUB );\n+        \n+        if ( isSubTree )\n+        {\n+            return new Tuple<K, V>( key, null );\n+        }\n+        \n         ValueCursor<V> cursor = values[0].getCursor();\n \n         try\n         {\n             cursor.beforeFirst();\n             if ( cursor.hasNext() )\n             {\n-                return new Tuple<K, V>( keys[0].getKey(), cursor.next() );\n+                return new Tuple<K, V>( key, cursor.next() );\n             }\n             else\n             {\n                 // Null value\n-                return new Tuple<K, V>( keys[0].getKey(), null );\n+                return new Tuple<K, V>( key, null );\n             }\n         }\n         finally\n@@ -1123,6 +1127,16 @@ public K getRightMostKey()\n      */\n     public Tuple<K, V> findRightMost() throws EndOfFileExceededException, IOException\n     {\n+        \n+        K key = keys[nbElems - 1].getKey();\n+        \n+        boolean isSubTree = ( btree.getType() == PERSISTED_SUB );\n+        \n+        if ( isSubTree )\n+        {\n+            return new Tuple<K, V>( key, null );\n+        }\n+\n         ValueCursor<V> cursor = values[nbElems - 1].getCursor();\n \n         try\n@@ -1131,12 +1145,12 @@ public K getRightMostKey()\n \n             if ( cursor.hasPrev() )\n             {\n-                return new Tuple<K, V>( keys[nbElems - 1].getKey(), cursor.prev() );\n+                return new Tuple<K, V>( key, cursor.prev() );\n             }\n             else\n             {\n                 // Null value\n-                return new Tuple<K, V>( keys[nbElems - 1].getKey(), null );\n+                return new Tuple<K, V>( key, null );\n             }\n         }\n         finally", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java"}, {"additions": 13, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java", "sha": "3e9dea51c65fd845f787b3aaccf1d83a18515b14", "changes": 13, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -410,6 +410,8 @@ private V removeFromBtree( V removedValue )\n                         }\n                     }\n \n+                    cursor.close();\n+                    \n                     return returnedValue;\n                 }\n                 else\n@@ -636,6 +638,17 @@ private int findPos( V value )\n     }\n \n \n+    @Override\n+    public V replaceValueArray( V newValue )\n+    {\n+        V val = super.replaceValueArray( newValue );\n+        // The raw value is not anymore up to date with the content\n+        isRawUpToDate = false;\n+        \n+        return val;\n+    }\n+\n+\n     /**\n      * Deserialize the values stored in an array\n      */", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java"}, {"additions": 3, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/RevisionName.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/RevisionName.java", "sha": "ae7a24f144e8ae0ca468d964abaa956778d54c45", "changes": 4, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/RevisionName.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -19,14 +19,16 @@\n  */\n package org.apache.directory.mavibot.btree;\n \n+import java.io.Serializable;\n+\n \n /**\n  * A data structure that stores a revision associated to a BTree name. We use\n  * it to allow the access to old revisions.\n  *\n  * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n  */\n-/* no qualifier*/class RevisionName extends Tuple<Long, String>\n+/* no qualifier*/class RevisionName extends Tuple<Long, String> implements Serializable\n {\n     /**\n      * A constructor for the RevisionName class", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/RevisionName.java"}, {"additions": 1, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/SpaceReclaimer.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/SpaceReclaimer.java", "sha": "33747cb23e3edb6ed0aabbe7e005b96cdc3e253f", "changes": 2, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/SpaceReclaimer.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -83,7 +83,7 @@ public SpaceReclaimer( RecordManager rm )\n \n         try\n         {\n-            LOG.debug( \"Storing {} RevisionName of Copied page map\", rm.copiedPageMap.size() );\n+            LOG.debug( \"Storing {} RevisionNames of Copied page map\", rm.copiedPageMap.size() );\n             \n             OutputStream fileOut = new FileOutputStream( file );\n             ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/SpaceReclaimer.java"}, {"additions": 12, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/ValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/main/java/org/apache/directory/mavibot/btree/ValueHolder.java", "sha": "6215d99032f1a49717ebb27ef04cef71057c8d33", "changes": 12, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/ValueHolder.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -69,6 +69,18 @@\n      */\n     V remove( V removedValue );\n \n+    \n+    /**\n+     * Replaces the single value present in the array.\n+     * \n+     * This is only applicable for B-Trees that don't\n+     * support duplicate values.\n+     *\n+     * @param newValue the new value\n+     * @return the value that was replaced\n+     */\n+    V replaceValueArray( V newValue );\n+    \n \n     /**\n      * Create a clone of this instance", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/ValueHolder.java"}, {"additions": 2, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeDuplicateKeyTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeDuplicateKeyTest.java", "sha": "17219927afa7e8754a490341b8fb9d58864a0ee5", "changes": 2, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeDuplicateKeyTest.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -37,6 +37,7 @@\n import org.apache.directory.mavibot.btree.serializer.IntSerializer;\n import org.apache.directory.mavibot.btree.serializer.LongSerializer;\n import org.apache.directory.mavibot.btree.serializer.StringSerializer;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n \n@@ -743,6 +744,7 @@ public void testMoveToPrevAndTraverseForward() throws Exception\n      * Test that a BTree which forbid duplicate values does not accept them\n      */\n     @Test(expected = DuplicateValueNotAllowedException.class)\n+    @Ignore(\"this condition is removed\")\n     public void testBTreeForbidDups() throws IOException, BTreeAlreadyManagedException\n     {\n         BTree<Long, String> singleValueBtree = BTreeFactory.createInMemoryBTree( \"test2\", LongSerializer.INSTANCE,", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeDuplicateKeyTest.java"}, {"additions": 25, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java", "sha": "751a2579d027423ae3ec93f4668f0d0ede0727e6", "changes": 25, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -1982,4 +1982,29 @@ public void testCheckRootPageContents() throws Exception\n \n         btree.close();\n     }\n+\n+    \n+    /**\n+     * Test the overwriting of elements\n+     */\n+    @Test\n+    public void testOverwrite() throws Exception\n+    {\n+        BTree<Integer, Integer> btree = BTreeFactory.createInMemoryBTree( \"test\", IntSerializer.INSTANCE,\n+            IntSerializer.INSTANCE );\n+\n+        // Adding an element with a null value\n+        btree.insert( 1, 1 );\n+\n+        assertTrue( btree.hasKey( 1 ) );\n+\n+        assertEquals( Integer.valueOf( 1 ), btree.get( 1 ) );\n+        \n+        btree.insert( 1, 10 );\n+\n+        assertTrue( btree.hasKey( 1 ) );\n+        assertEquals( Integer.valueOf( 10 ), btree.get( 1 ) );\n+\n+        btree.close();\n+    }\n }", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java"}, {"additions": 25, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeBrowseTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeBrowseTest.java", "sha": "8346bde644fd796100f4bdfda33de7304afac5ce", "changes": 25, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeBrowseTest.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -36,6 +36,7 @@\n import org.apache.directory.mavibot.btree.exception.BTreeAlreadyManagedException;\n import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n import org.apache.directory.mavibot.btree.exception.KeyNotFoundException;\n+import org.apache.directory.mavibot.btree.serializer.IntSerializer;\n import org.apache.directory.mavibot.btree.serializer.LongSerializer;\n import org.apache.directory.mavibot.btree.serializer.StringSerializer;\n import org.junit.After;\n@@ -1107,6 +1108,30 @@ public void testPrevKey() throws IOException, BTreeAlreadyManagedException, KeyN\n     }\n     \n     \n+    /**\n+     * Test the overwriting of elements\n+     */\n+    @Test\n+    public void testOverwrite() throws Exception\n+    {\n+        btree.setAllowDuplicates( false );\n+        \n+        // Adding an element with a null value\n+        btree.insert( 1L, \"1\" );\n+\n+        assertTrue( btree.hasKey( 1L ) );\n+\n+        assertEquals( \"1\", btree.get( 1L ) );\n+        \n+        btree.insert( 1L, \"10\" );\n+\n+        assertTrue( btree.hasKey( 1L ) );\n+        assertEquals( \"10\", btree.get( 1L ) );\n+\n+        btree.close();\n+    }\n+\n+    \n     @Ignore(\"test used for debugging\")\n     @Test\n     public void testAdd20Random() throws IOException, BTreeAlreadyManagedException, KeyNotFoundException", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeBrowseTest.java"}, {"additions": 30, "raw_url": "https://github.com/apache/directory-mavibot/raw/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeDuplicateKeyTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/32b7b4b2e880590ed33ca76dbda8983761ea3179/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeDuplicateKeyTest.java", "sha": "8dfd94cbdce6907e1608c2077ea453c896d9444b", "changes": 30, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeDuplicateKeyTest.java?ref=32b7b4b2e880590ed33ca76dbda8983761ea3179", "patch": "@@ -41,6 +41,7 @@\n import org.apache.directory.mavibot.btree.serializer.StringSerializer;\n import org.junit.After;\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n@@ -792,11 +793,40 @@ public void testMoveToPrevAndTraverseForward() throws Exception\n         cursor.close();\n     }\n \n+    \n+    @Test\n+    public void testFindLeftAndRightMosetInSubBTree() throws Exception\n+    {\n+        PersistedBTreeConfiguration<Integer, Integer> config = new PersistedBTreeConfiguration<Integer, Integer>();\n+\n+        config.setName( \"test\" );\n+        config.setKeySerializer( IntSerializer.INSTANCE );\n+        config.setValueSerializer( IntSerializer.INSTANCE );\n+        config.setAllowDuplicates( false );\n+        config.setBtreeType( BTreeTypeEnum.PERSISTED_SUB );\n+\n+        PersistedBTree<Integer, Integer> subBtree = new PersistedBTree<Integer, Integer>( config );\n+        \n+        subBtree.setRecordManager( recordManager1 );\n+        \n+        subBtree.insert( 1, 1 ); // the values will be discarded in this BTree type\n+        subBtree.insert( 2, 2 );\n+        subBtree.insert( 3, 3 );\n+        subBtree.insert( 4, 4 );\n+        subBtree.insert( 5, 5 );\n+        \n+        Tuple<Integer, Integer> t = subBtree.getRootPage().findLeftMost();\n+        assertEquals( Integer.valueOf( 1 ), t.getKey() );\n+        \n+        t = subBtree.getRootPage().findRightMost();\n+        assertEquals( Integer.valueOf( 5 ), t.getKey() );\n+    }\n \n     /**\n      * Test that a BTree which forbid duplicate values does not accept them\n      */\n     @Test(expected = DuplicateValueNotAllowedException.class)\n+    @Ignore(\"this condition is removed\")\n     public void testBTreeForbidDups() throws IOException, BTreeAlreadyManagedException\n     {\n         BTree<Long, String> singleValueBtree = recordManager1.addBTree( \"test2\", LongSerializer.INSTANCE,", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedBTreeDuplicateKeyTest.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/75f90efdb2873811b83bdf741f6458f0a06f5671", "parent": "https://github.com/apache/directory-mavibot/commit/316afb2f211cf3a04cf884a4532ef4650fd4247c", "message": "o Fixed a NPE in the Array holding for values\no Added a PageHolder common class for in-memory and persisted btrees\no The abstract in-memory and persisted page class have been removed\no The in-memory/persisted Leaf classes have been removed to InMemoryLeaf/PersistedLeaf", "bug_id": "directory-mavibot_8", "file": [{"additions": 110, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java", "sha": "25faaed4e7caa45b6be4952fd01e52a98cb727f6", "changes": 110, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -20,6 +20,9 @@\n package org.apache.directory.mavibot.btree;\n \n \n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+\n import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n import org.apache.directory.mavibot.btree.exception.KeyNotFoundException;\n@@ -42,6 +45,9 @@\n     /** Keys of children nodes */\n     protected KeyHolder<K>[] keys;\n \n+    /** Children pages associated with keys. */\n+    protected PageHolder<K, V>[] children;\n+\n     /** The number of current values in the Page */\n     protected int nbElems;\n \n@@ -68,6 +74,19 @@ protected AbstractPage( BTree<K, V> btree )\n         this.btree = btree;\n     }\n \n+    /**\n+     * Internal constructor used to create Page instance used when a page is being copied or overflow\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    // Cannot create an array of generic objects\n+    protected AbstractPage( BTree<K, V> btree, long revision, int nbElems )\n+    {\n+        this.btree = btree;\n+        this.revision = revision;\n+        this.nbElems = nbElems;\n+        this.keys = ( KeyHolder[] ) Array.newInstance( KeyHolder.class, nbElems );\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n@@ -99,6 +118,76 @@ public K getKey( int pos )\n     }\n \n     \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Page<K, V> getPage( int pos )\n+    {\n+        if ( ( pos >= 0 ) && ( pos < children.length ) )\n+        {\n+            return children[pos].getValue();\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void setPageHolder( int pos, PageHolder<K, V> pageHolder )\n+    {\n+        if ( ( pos >= 0 ) && ( pos < children.length ) )\n+        {\n+            children[pos] = pageHolder;\n+        }\n+    }\n+\n+\n+    /**\n+     * Selects the sibling (the previous or next page with the same parent) which has\n+     * the more element assuming it's above N/2\n+     * \n+     * @param parent The parent of the current page\n+     * @param The position of the current page reference in its parent\n+     * @return The position of the sibling, or -1 if we have'nt found any sibling\n+     * @throws IOException If we have an error while trying to access the page\n+     */\n+    protected int selectSibling( Page<K, V> parent, int parentPos ) throws IOException\n+    {\n+        if ( parentPos == 0 )\n+        {\n+            // The current page is referenced on the left of its parent's page :\n+            // we will not have a previous page with the same parent\n+            return 1;\n+        }\n+\n+        if ( parentPos == parent.getNbElems() )\n+        {\n+            // The current page is referenced on the right of its parent's page :\n+            // we will not have a next page with the same parent\n+            return parentPos - 1;\n+        }\n+\n+        Page<K, V> prevPage = ((AbstractPage<K, V>)parent).getPage( parentPos - 1 );\n+        Page<K, V> nextPage = ((AbstractPage<K, V>)parent).getPage( parentPos + 1 );\n+\n+        int prevPageSize = prevPage.getNbElems();\n+        int nextPageSize = nextPage.getNbElems();\n+\n+        if ( prevPageSize >= nextPageSize )\n+        {\n+            return parentPos - 1;\n+        }\n+        else\n+        {\n+            return parentPos + 1;\n+        }\n+    }\n+\n+\n     /**\n      * {@inheritDoc}\n      */\n@@ -162,6 +251,18 @@ public void setLastOffset( long lastOffset )\n     }\n \n \n+    /**\n+     * Sets the key at a give position\n+     * \n+     * @param pos The position in the keys array\n+     * @param key the key to inject\n+     */\n+    public void setKey( int pos, KeyHolder<K> key )\n+    {\n+        keys[pos] = key;\n+    }\n+\n+\n     /**\n      * @param revision the keys to set\n      */\n@@ -310,6 +411,15 @@ else if ( comp > 0 )\n     }\n \n \n+    /**\n+     * @return the btree\n+     */\n+    public BTree<K, V> getBtree()\n+    {\n+        return btree;\n+    }\n+\n+\n     /**\n      * {@inheritDoc}\n      */", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java"}, {"additions": 0, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractTupleCursor.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractTupleCursor.java", "sha": "9329c029e5c9bc4e2a5ce3b873b853dc6d545688", "changes": 50, "status": "modified", "deletions": 50, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractTupleCursor.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -58,56 +58,6 @@ protected AbstractTupleCursor( Transaction<K, V> transaction, ParentPos<K, V>[]\n     }\n     \n     \n-    /**\n-     * {@inheritDoc}\n-     *\n-    public void afterLast() throws IOException\n-    {\n-        // First check that we have elements in the BTree\n-        if ( ( stack == null ) || ( stack.length == 0 ) )\n-        {\n-            return;\n-        }\n-\n-        Page<K, V> child = null;\n-\n-        for ( int i = 0; i < depth; i++ )\n-        {\n-            ParentPos<K, V> parentPos = stack[i];\n-            \n-            if ( child != null )\n-            {\n-                parentPos.page = child;\n-                parentPos.pos = child.getNbElems();\n-            }\n-            else\n-            {\n-                // We have N+1 children if the page is a Node, so we don't decrement the nbElems field\n-                parentPos.pos = parentPos.page.getNbElems();\n-            }\n-\n-            child = ((Node<K, V>)parentPos.page).children[parentPos.pos];\n-        }\n-        \n-        // and leaf\n-        ParentPos<K, V> parentPos = stack[depth];\n-\n-        if ( child == null )\n-        {\n-            parentPos.pos = parentPos.page.getNbElems() - 1;\n-        }\n-        else\n-        {\n-            parentPos.page = child;\n-            parentPos.pos = child.getNbElems() - 1;\n-        }\n-\n-        parentPos.valueCursor = ((Leaf<K, V>)parentPos.page).values[parentPos.pos].getCursor();\n-        parentPos.valueCursor.afterLast();\n-        parentPos.pos = AFTER_LAST;\n-    }\n-\n-\n     /**\n      * {@inheritDoc}\n      */", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractTupleCursor.java"}, {"additions": 35, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java", "sha": "aaf7f5a58e24e2deecda16cd14fc8d26bc3d4f12", "changes": 56, "status": "modified", "deletions": 21, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -48,6 +48,9 @@\n     protected int valueThresholdUp = 1;\n     protected int valueThresholdLow = 1;\n \n+    protected int nbArrayElems;\n+    \n+\n     /**\n      * {@inheritDoc}\n      */\n@@ -272,7 +275,7 @@ public boolean contains( V checkedValue )\n     private void addInArray( V value )\n     {\n         // We have to check that we have reached the threshold or not\n-        if ( valueArray.length >= valueThresholdUp )\n+        if ( size() >= valueThresholdUp )\n         {\n             // Ok, transform the array into a btree\n             createSubTree();\n@@ -287,6 +290,7 @@ private void addInArray( V value )\n                 }\n \n                 // We can delete the array now\n+                nbArrayElems = 0;\n                 valueArray = null;\n \n                 // And inject the new value\n@@ -300,27 +304,37 @@ private void addInArray( V value )\n         }\n         else\n         {\n-            // First check that the value is not already present in the ValueHolder\n-            int pos = findPos( value );\n-\n-            if ( pos >= 0 )\n+            // Create the array if it's null\n+            if ( valueArray == null )\n             {\n-                // The value exists : nothing to do\n-                return;\n+                valueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), 1 );\n+                nbArrayElems = 1;\n+                valueArray[0] = value;\n+            }\n+            else\n+            {\n+                // check that the value is not already present in the ValueHolder\n+                int pos = findPos( value );\n+    \n+                if ( pos >= 0 )\n+                {\n+                    // The value exists : nothing to do\n+                    return;\n+                }\n+    \n+                // Ok, we just have to insert the new element at the right position\n+                // We transform the position to a positive value \n+                pos = -( pos + 1 );\n+                // First, copy the array\n+                V[] newValueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), valueArray.length + 1 );\n+    \n+                System.arraycopy( valueArray, 0, newValueArray, 0, pos );\n+                newValueArray[pos] = value;\n+                System.arraycopy( valueArray, pos, newValueArray, pos + 1, valueArray.length - pos );\n+    \n+                // And switch the arrays\n+                valueArray = newValueArray;\n             }\n-\n-            // Ok, we just have to insert the new element at the right position\n-            // We transform the position to a positive value \n-            pos = -( pos + 1 );\n-            // First, copy the array\n-            V[] newValueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), valueArray.length + 1 );\n-\n-            System.arraycopy( valueArray, 0, newValueArray, 0, pos );\n-            newValueArray[pos] = value;\n-            System.arraycopy( valueArray, pos, newValueArray, pos + 1, valueArray.length - pos );\n-\n-            // And switch the arrays\n-            valueArray = newValueArray;\n         }\n     }\n     \n@@ -347,7 +361,7 @@ private void addInBtree( V value )\n      */\n     public void add( V value )\n     {\n-        if ( valueArray != null )\n+        if ( valueBtree == null )\n         {\n             addInArray( value );\n         }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java"}, {"additions": 55, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/PageHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/PageHolder.java", "sha": "7328b02302bbe33c3a5a61d0a0601066cbe91145", "changes": 55, "status": "added", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PageHolder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -0,0 +1,55 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one\n+ *  or more contributor license agreements.  See the NOTICE file\n+ *  distributed with this work for additional information\n+ *  regarding copyright ownership.  The ASF licenses this file\n+ *  to you under the Apache License, Version 2.0 (the\n+ *  \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ *\n+ */\n+package org.apache.directory.mavibot.btree;\n+\n+import java.io.IOException;\n+\n+import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n+\n+public class PageHolder<K, V>\n+{\n+    /** The BTree */\n+    protected BTree<K, V> btree;\n+    \n+    /** The stored page */\n+    private Page<K, V> page;\n+\n+    /**\n+     * Create a new holder storing an offset and a SoftReference containing the element.\n+     * \n+     * @param page The element to store into a SoftReference\n+     **/\n+    public PageHolder( BTree<K, V> btree, Page<K, V> page )\n+    {\n+        this.btree = btree;\n+        this.page = page;\n+    }\n+\n+    \n+    /**\n+     * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n+     */\n+    public Page<K, V> getValue()\n+    {\n+        return page;\n+    }\n+}", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PageHolder.java"}, {"additions": 0, "raw_url": "https://github.com/apache/directory-mavibot/raw/316afb2f211cf3a04cf884a4532ef4650fd4247c/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/AbstractInMemoryPage.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/316afb2f211cf3a04cf884a4532ef4650fd4247c/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/AbstractInMemoryPage.java", "sha": "8f59efe741f576e2f972b969c7ae5114142dd211", "changes": 122, "status": "removed", "deletions": 122, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/AbstractInMemoryPage.java?ref=316afb2f211cf3a04cf884a4532ef4650fd4247c", "patch": "@@ -1,122 +0,0 @@\n-/*\n- *  Licensed to the Apache Software Foundation (ASF) under one\n- *  or more contributor license agreements.  See the NOTICE file\n- *  distributed with this work for additional information\n- *  regarding copyright ownership.  The ASF licenses this file\n- *  to you under the Apache License, Version 2.0 (the\n- *  \"License\"); you may not use this file except in compliance\n- *  with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- *\n- */\n-package org.apache.directory.mavibot.btree.memory;\n-\n-\n-import java.io.IOException;\n-import java.lang.reflect.Array;\n-\n-import org.apache.directory.mavibot.btree.AbstractPage;\n-import org.apache.directory.mavibot.btree.BTree;\n-import org.apache.directory.mavibot.btree.KeyHolder;\n-import org.apache.directory.mavibot.btree.Page;\n-import org.apache.directory.mavibot.btree.exception.KeyNotFoundException;\n-\n-\n-/**\n- * A MVCC abstract Page. It stores the field and the methods shared by the Node and Leaf\n- * classes.\n- * \n- * @param <K> The type for the Key\n- * @param <V> The type for the stored value\n- *\n- * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n- */\n-/* No qualifier */abstract class AbstractInMemoryPage<K, V> extends AbstractPage<K, V>\n-{\n-    /**\n-     * Internal constructor used to create Page instance used when a page is being copied or overflow\n-     */\n-    protected AbstractInMemoryPage( BTree<K, V> btree )\n-    {\n-        super( btree );\n-    }\n-    \n-    \n-    /**\n-     * Internal constructor used to create Page instance used when a page is being copied or overflow\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    // Cannot create an array of generic objects\n-    protected AbstractInMemoryPage( BTree<K, V> btree, long revision, int nbElems )\n-    {\n-        super( btree );\n-        this.revision = revision;\n-        this.nbElems = nbElems;\n-\n-        // We get the type of array to create from the btree\n-        // Yes, this is an hack...\n-        this.setKeys( ( KeyHolder[] ) Array.newInstance( KeyHolder.class, nbElems ) );\n-    }\n-\n-\n-    /**\n-     * Selects the sibling (the previous or next page with the same parent) which has\n-     * the more element assuming it's above N/2\n-     * \n-     * @param parent The parent of the current page\n-     * @param The position of the current page reference in its parent\n-     * @return The position of the sibling, or -1 if we have'nt found any sibling\n-     * @throws IOException If we have an error while trying to access the page\n-     */\n-    protected int selectSibling( Node<K, V> parent, int parentPos ) throws IOException\n-    {\n-        if ( parentPos == 0 )\n-        {\n-            // The current page is referenced on the left of its parent's page :\n-            // we will not have a previous page with the same parent\n-            return 1;\n-        }\n-\n-        if ( parentPos == parent.getNbElems() )\n-        {\n-            // The current page is referenced on the right of its parent's page :\n-            // we will not have a next page with the same parent\n-            return parentPos - 1;\n-        }\n-\n-        Page<K, V> prevPage = parent.children[parentPos - 1];\n-        Page<K, V> nextPage = parent.children[parentPos + 1];\n-\n-        int prevPageSize = prevPage.getNbElems();\n-        int nextPageSize = nextPage.getNbElems();\n-\n-        if ( prevPageSize >= nextPageSize )\n-        {\n-            return parentPos - 1;\n-        }\n-        else\n-        {\n-            return parentPos + 1;\n-        }\n-    }\n-\n-\n-    /**\n-     * Sets the key at a give position\n-     * \n-     * @param pos The position in the keys array\n-     * @param key the key to inject\n-     */\n-    /* No qualifier*/void setKey( int pos, K key )\n-    {\n-        keys[pos] = new KeyHolder<K>( key );\n-    }\n-}", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/AbstractInMemoryPage.java"}, {"additions": 15, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/BTreeFactory.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/BTreeFactory.java", "sha": "5f34c4b4e06c7a8aa5aea3770be4464f81a7b1cd", "changes": 26, "status": "modified", "deletions": 11, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/BTreeFactory.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -23,8 +23,11 @@\n import java.io.IOException;\n import java.util.LinkedList;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n+import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n+import org.apache.directory.mavibot.btree.PageHolder;\n import org.apache.directory.mavibot.btree.ParentPos;\n import org.apache.directory.mavibot.btree.ValueHolder;\n import org.apache.directory.mavibot.btree.serializer.ElementSerializer;\n@@ -77,9 +80,9 @@\n      * @param nbElems The number or elements in this leaf\n      * @return A Leaf instance\n      */\n-    public static <K, V> Leaf<K, V> createLeaf( BTree<K, V> btree, long revision, int nbElems )\n+    public static <K, V> InMemoryLeaf<K, V> createLeaf( BTree<K, V> btree, long revision, int nbElems )\n     {\n-        Leaf<K, V> leaf = new Leaf<K, V>( btree, revision, nbElems );\n+        InMemoryLeaf<K, V> leaf = new InMemoryLeaf<K, V>( btree, revision, nbElems );\n \n         return leaf;\n     }\n@@ -192,7 +195,8 @@\n      */\n     public static <K, V> void setKey( Page<K, V> page, int pos, K key )\n     {\n-        ( ( AbstractInMemoryPage<K, V> ) page ).setKey( pos, key );\n+        KeyHolder<K> keyHolder = new KeyHolder<K>( key );\n+        ( ( AbstractPage<K, V> ) page ).setKey( pos, keyHolder );\n     }\n \n \n@@ -201,7 +205,7 @@\n      * @param pos The position in the values array\n      * @param value the value to inject\n      */\n-    public static <K, V> void setValue( Leaf<K, V> page, int pos, InMemoryValueHolder<V> value )\n+    public static <K, V> void setValue( InMemoryLeaf<K, V> page, int pos, InMemoryValueHolder<V> value )\n     {\n         page.setValue( pos, value );\n     }\n@@ -212,9 +216,9 @@\n      * @param pos The position in the values array\n      * @param value the value to inject\n      */\n-    public static <K, V> void setValue( Node<K, V> page, int pos, Page<K, V> value )\n+    public static <K, V> void setValue( BTree<K, V> btree, Node<K, V> page, int pos, Page<K, V> value )\n     {\n-        page.children[pos] = value;\n+        page.setPageHolder( pos, new PageHolder<K, V>( btree, value ) );\n     }\n \n \n@@ -232,9 +236,9 @@\n         ParentPos<K, V> last = new ParentPos<K, V>( btree.getRootPage(), btree.getRootPage().getNbElems() );\n         stack.push( last );\n \n-        if ( btree.getRootPage() instanceof Leaf )\n+        if ( btree.getRootPage() instanceof InMemoryLeaf )\n         {\n-            Leaf<K, V> leaf = ( Leaf<K, V> ) ( btree.getRootPage() );\n+            InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( btree.getRootPage() );\n             ValueHolder<V> valueHolder = leaf.values[last.pos];\n             last.valueCursor = valueHolder.getCursor();\n         }\n@@ -244,14 +248,14 @@\n \n             while ( true )\n             {\n-                Page<K, V> p = node.children[node.getNbElems()];\n+                Page<K, V> p = node.getPage( node.getNbElems() );\n \n                 last = new ParentPos<K, V>( p, p.getNbElems() );\n                 stack.push( last );\n \n-                if ( p instanceof Leaf )\n+                if ( p instanceof InMemoryLeaf )\n                 {\n-                    Leaf<K, V> leaf = ( Leaf<K, V> ) ( last.page );\n+                    InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( last.page );\n                     ValueHolder<V> valueHolder = leaf.values[last.pos];\n                     last.valueCursor = valueHolder.getCursor();\n                     break;", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/BTreeFactory.java"}, {"additions": 2, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTree.java", "sha": "1d5a2d229a3cb4973547d9eeb5dff85316fb645e", "changes": 4, "status": "modified", "deletions": 2, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTree.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -154,7 +154,7 @@ public InMemoryBTree( BTreeConfiguration<K, V> configuration ) throws IOExceptio\n \n         // Create the first root page, with revision 0L. It will be empty\n         // and increment the revision at the same time\n-        rootPage = new Leaf<K, V>( this );\n+        rootPage = new InMemoryLeaf<K, V>( this );\n \n         // Now, initialize the BTree\n         init();\n@@ -265,7 +265,7 @@ public InMemoryBTree( String name, String dataDir, ElementSerializer<K> keySeria\n \n         // Create the first root page, with revision 0L. It will be empty\n         // and increment the revision at the same time\n-        rootPage = new Leaf<K, V>( this );\n+        rootPage = new InMemoryLeaf<K, V>( this );\n \n         // Now, call the init() method\n         init();", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTree.java"}, {"additions": 4, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeBuilder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeBuilder.java", "sha": "99ac177116747e9639b5bc4e23437e76363c679b", "changes": 7, "status": "modified", "deletions": 3, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeBuilder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -36,6 +36,7 @@\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n+import org.apache.directory.mavibot.btree.PageHolder;\n import org.apache.directory.mavibot.btree.Tuple;\n import org.apache.directory.mavibot.btree.ValueHolder;\n import org.apache.directory.mavibot.btree.serializer.ElementSerializer;\n@@ -77,7 +78,7 @@ public InMemoryBTreeBuilder( String name, int numKeysInNode, ElementSerializer<K\n \n         int totalTupleCount = 0;\n \n-        Leaf<K, V> leaf1 = createLeaf( btree, 0, numKeysInNode );\n+        InMemoryLeaf<K, V> leaf1 = createLeaf( btree, 0, numKeysInNode );\n         lstLeaves.add( leaf1 );\n \n         int leafIndex = 0;\n@@ -107,7 +108,7 @@ public InMemoryBTreeBuilder( String name, int numKeysInNode, ElementSerializer<K\n         }\n \n         // remove null keys and values from the last leaf and resize\n-        Leaf<K, V> lastLeaf = ( Leaf<K, V> ) lstLeaves.get( lstLeaves.size() - 1 );\n+        InMemoryLeaf<K, V> lastLeaf = ( InMemoryLeaf<K, V> ) lstLeaves.get( lstLeaves.size() - 1 );\n         for ( int i = 0; i < lastLeaf.getNbElems(); i++ )\n         {\n             if ( lastLeaf.getKeys()[i] == null )\n@@ -161,7 +162,7 @@ public InMemoryBTreeBuilder( String name, int numKeysInNode, ElementSerializer<K\n                 setKey( node, i - 1, p.getLeftMostKey() );\n             }\n \n-            node.children[i] = p;\n+            node.setPageHolder( i, new PageHolder<K, V>( btree, p ) );\n \n             i++;\n             totalNodes++;", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeBuilder.java"}, {"additions": 34, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryLeaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryLeaf.java", "previous_filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/Leaf.java", "sha": "4108b2a60ddc07c2e1113d69d290b7f0e785c0bd", "changes": 67, "status": "renamed", "deletions": 33, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryLeaf.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -23,11 +23,13 @@\n import java.io.IOException;\n import java.lang.reflect.Array;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.BorrowedFromLeftResult;\n import org.apache.directory.mavibot.btree.BorrowedFromRightResult;\n import org.apache.directory.mavibot.btree.DeleteResult;\n import org.apache.directory.mavibot.btree.InsertResult;\n+import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.ModifyResult;\n import org.apache.directory.mavibot.btree.NotPresentResult;\n import org.apache.directory.mavibot.btree.Page;\n@@ -51,7 +53,7 @@\n  *\n  * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n  */\n-/* No qualifier */class Leaf<K, V> extends AbstractInMemoryPage<K, V>\n+/* No qualifier */class InMemoryLeaf<K, V> extends AbstractPage<K, V>\n {\n     /** Values associated with keys */\n     protected ValueHolder<V>[] values;\n@@ -62,7 +64,7 @@\n      * \n      * @param btree The BTree this page belongs to.\n      */\n-    /* No qualifier */Leaf( BTree<K, V> btree )\n+    InMemoryLeaf( BTree<K, V> btree )\n     {\n         super( btree );\n     }\n@@ -76,8 +78,7 @@\n      * @param nbElems The number of elements this page will contain\n      */\n     @SuppressWarnings(\"unchecked\")\n-    // Cannot create an array of generic objects\n-    /* No qualifier */Leaf( BTree<K, V> btree, long revision, int nbElems )\n+    InMemoryLeaf( BTree<K, V> btree, long revision, int nbElems )\n     {\n         super( btree, revision, nbElems );\n \n@@ -193,15 +194,15 @@\n             }\n         }\n \n-        Leaf<K, V> newLeaf = null;\n+        InMemoryLeaf<K, V> newLeaf = null;\n \n         if ( keyRemoved )\n         {\n-            newLeaf = new Leaf<K, V>( btree, revision, nbElems - 1 );\n+            newLeaf = new InMemoryLeaf<K, V>( btree, revision, nbElems - 1 );\n         }\n         else\n         {\n-            newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+            newLeaf = new InMemoryLeaf<K, V>( btree, revision, nbElems );\n         }\n \n         // Create the result\n@@ -231,7 +232,7 @@ else if ( keyRemoved )\n                 // Check in both next and previous page, if they have the same parent\n                 // and select the biggest page with the same parent to borrow an element.\n                 int siblingPos = selectSibling( ( Node<K, V> ) parent, parentPos );\n-                Leaf<K, V> sibling = ( Leaf<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos] );\n+                InMemoryLeaf<K, V> sibling = ( InMemoryLeaf<K, V> ) ( ( ( Node<K, V> ) parent ).getPage( siblingPos ) );\n \n                 if ( sibling.getNbElems() == halfSize )\n                 {\n@@ -298,13 +299,13 @@ else if ( keyRemoved )\n      * @return The new created leaf containing the sibling and the old page.\n      * @throws IOException If we have an error while trying to access the page\n      */\n-    private DeleteResult<K, V> mergeWithSibling( Tuple<K, V> removedElement, long revision, Leaf<K, V> sibling,\n+    private DeleteResult<K, V> mergeWithSibling( Tuple<K, V> removedElement, long revision, InMemoryLeaf<K, V> sibling,\n         boolean isLeft, int pos )\n         throws EndOfFileExceededException, IOException\n     {\n         // Create the new page. It will contain N - 1 elements (the maximum number)\n         // as we merge two pages that contain N/2 elements minus the one we remove\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, btree.getPageSize() - 1 );\n+        InMemoryLeaf<K, V> newLeaf = new InMemoryLeaf<K, V>( btree, revision, btree.getPageSize() - 1 );\n \n         if ( isLeft )\n         {\n@@ -359,22 +360,22 @@ else if ( keyRemoved )\n      * @return The resulting pages\n      * @throws IOException If we have an error while trying to access the page \n      */\n-    private DeleteResult<K, V> borrowFromLeft( Tuple<K, V> removedElement, long revision, Leaf<K, V> sibling, int pos )\n+    private DeleteResult<K, V> borrowFromLeft( Tuple<K, V> removedElement, long revision, InMemoryLeaf<K, V> sibling, int pos )\n         throws IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n         K siblingKey = sibling.getKey( sibling.getNbElems() - 1 );\n         ValueHolder<V> siblingValue = sibling.values[sibling.getNbElems() - 1];\n \n         // Create the new sibling, with one less element at the end\n-        Leaf<K, V> newSibling = ( Leaf<K, V> ) sibling.copy( revision, sibling.getNbElems() - 1 );\n+        InMemoryLeaf<K, V> newSibling = ( InMemoryLeaf<K, V> ) sibling.copy( revision, sibling.getNbElems() - 1 );\n \n         // Create the new page and add the new element at the beginning\n         // First copy the current page, with the same size\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+        InMemoryLeaf<K, V> newLeaf = new InMemoryLeaf<K, V>( btree, revision, nbElems );\n \n         // Insert the borrowed element\n-        newLeaf.setKey( 0, siblingKey );\n+        newLeaf.setKey( 0, new KeyHolder<K>( siblingKey ) );\n         newLeaf.values[0] = siblingValue;\n \n         // Copy the keys and the values up to the insertion position,\n@@ -406,26 +407,26 @@ else if ( keyRemoved )\n      * @return The resulting pages\n      * @throws IOException If we have an error while trying to access the page \n      */\n-    private DeleteResult<K, V> borrowFromRight( Tuple<K, V> removedElement, long revision, Leaf<K, V> sibling, int pos )\n+    private DeleteResult<K, V> borrowFromRight( Tuple<K, V> removedElement, long revision, InMemoryLeaf<K, V> sibling, int pos )\n         throws IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n         K siblingKey = sibling.getKey( 0 );\n         ValueHolder<V> siblingHolder = sibling.values[0];\n \n         // Create the new sibling\n-        Leaf<K, V> newSibling = new Leaf<K, V>( btree, revision, sibling.getNbElems() - 1 );\n+        InMemoryLeaf<K, V> newSibling = new InMemoryLeaf<K, V>( btree, revision, sibling.getNbElems() - 1 );\n \n         // Copy the keys and the values from 1 to N in the new sibling\n         System.arraycopy( sibling.getKeys(), 1, newSibling.getKeys(), 0, sibling.nbElems - 1 );\n         System.arraycopy( sibling.values, 1, newSibling.values, 0, sibling.nbElems - 1 );\n \n         // Create the new page and add the new element at the end\n         // First copy the current page, with the same size\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+        InMemoryLeaf<K, V> newLeaf = new InMemoryLeaf<K, V>( btree, revision, nbElems );\n \n         // Insert the borrowed element at the end\n-        newLeaf.setKey( nbElems - 1, siblingKey );\n+        newLeaf.setKey( nbElems - 1, new KeyHolder<K>( siblingKey ) );\n         newLeaf.values[nbElems - 1] = siblingHolder;\n \n         // Copy the keys and the values up to the deletion position,\n@@ -454,7 +455,7 @@ else if ( keyRemoved )\n      * @param pos The position into the page of the element to remove\n      * @throws IOException If we have an error while trying to access the page\n      */\n-    private void copyAfterRemovingElement( boolean keyRemoved, Leaf<K, V> newLeaf, int pos ) throws IOException\n+    private void copyAfterRemovingElement( boolean keyRemoved, InMemoryLeaf<K, V> newLeaf, int pos ) throws IOException\n     {\n         if ( keyRemoved )\n         {\n@@ -703,7 +704,7 @@ else if ( nbElems > 0 )\n      */\n     private Page<K, V> copy( long revision, int nbElems )\n     {\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+        InMemoryLeaf<K, V> newLeaf = new InMemoryLeaf<K, V>( btree, revision, nbElems );\n \n         // Copy the keys and the values\n         System.arraycopy( getKeys(), 0, newLeaf.getKeys(), 0, nbElems );\n@@ -726,12 +727,12 @@ else if ( nbElems > 0 )\n     private InsertResult<K, V> replaceElement( long revision, K key, V value, int pos )\n         throws IOException\n     {\n-        Leaf<K, V> newLeaf = this;\n+        InMemoryLeaf<K, V> newLeaf = this;\n \n         if ( this.revision != revision )\n         {\n             // The page hasn't been modified yet, we need to copy it first\n-            newLeaf = ( Leaf<K, V> ) copy( revision, nbElems );\n+            newLeaf = ( InMemoryLeaf<K, V> ) copy( revision, nbElems );\n         }\n \n         // Get the previous value from the leaf (it's a copy)\n@@ -773,15 +774,15 @@ else if ( nbElems > 0 )\n     private Page<K, V> addElement( long revision, K key, V value, int pos )\n     {\n         // First copy the current page, but add one element in the copied page\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems + 1 );\n+        InMemoryLeaf<K, V> newLeaf = new InMemoryLeaf<K, V>( btree, revision, nbElems + 1 );\n \n         // Atm, store the value in memory\n         InMemoryValueHolder<V> valueHolder = new InMemoryValueHolder<V>( btree, value );\n \n         // Deal with the special case of an empty page\n         if ( nbElems == 0 )\n         {\n-            newLeaf.setKey( 0, key );\n+            newLeaf.setKey( 0, new KeyHolder<K>( key ) );\n             newLeaf.values[0] = valueHolder;\n         }\n         else\n@@ -791,7 +792,7 @@ else if ( nbElems > 0 )\n             System.arraycopy( values, 0, newLeaf.values, 0, pos );\n \n             // Add the new element\n-            newLeaf.setKey( pos, key );\n+            newLeaf.setKey( pos, new KeyHolder<K>( key ) );\n             newLeaf.values[pos] = valueHolder;\n \n             // And copy the remaining elements\n@@ -821,30 +822,30 @@ else if ( nbElems > 0 )\n     private InsertResult<K, V> addAndSplit( long revision, K key, V value, int pos )\n     {\n         int middle = btree.getPageSize() >> 1;\n-        Leaf<K, V> leftLeaf = null;\n-        Leaf<K, V> rightLeaf = null;\n+        InMemoryLeaf<K, V> leftLeaf = null;\n+        InMemoryLeaf<K, V> rightLeaf = null;\n         InMemoryValueHolder<V> valueHolder = new InMemoryValueHolder<V>( btree, value );\n \n         // Determinate where to store the new value\n         if ( pos <= middle )\n         {\n             // The left page will contain the new value\n-            leftLeaf = new Leaf<K, V>( btree, revision, middle + 1 );\n+            leftLeaf = new InMemoryLeaf<K, V>( btree, revision, middle + 1 );\n \n             // Copy the keys and the values up to the insertion position\n             System.arraycopy( getKeys(), 0, leftLeaf.getKeys(), 0, pos );\n             System.arraycopy( values, 0, leftLeaf.values, 0, pos );\n \n             // Add the new element\n-            leftLeaf.setKey( pos, key );\n+            leftLeaf.setKey( pos, new KeyHolder<K>( key ) );\n             leftLeaf.values[pos] = valueHolder;\n \n             // And copy the remaining elements\n             System.arraycopy( getKeys(), pos, leftLeaf.getKeys(), pos + 1, middle - pos );\n             System.arraycopy( values, pos, leftLeaf.values, pos + 1, middle - pos );\n \n             // Now, create the right page\n-            rightLeaf = new Leaf<K, V>( btree, revision, middle );\n+            rightLeaf = new InMemoryLeaf<K, V>( btree, revision, middle );\n \n             // Copy the keys and the values in the right page\n             System.arraycopy( getKeys(), middle, rightLeaf.getKeys(), 0, middle );\n@@ -853,14 +854,14 @@ else if ( nbElems > 0 )\n         else\n         {\n             // Create the left page\n-            leftLeaf = new Leaf<K, V>( btree, revision, middle );\n+            leftLeaf = new InMemoryLeaf<K, V>( btree, revision, middle );\n \n             // Copy all the element into the left page\n             System.arraycopy( getKeys(), 0, leftLeaf.getKeys(), 0, middle );\n             System.arraycopy( values, 0, leftLeaf.values, 0, middle );\n \n             // Now, create the right page\n-            rightLeaf = new Leaf<K, V>( btree, revision, middle + 1 );\n+            rightLeaf = new InMemoryLeaf<K, V>( btree, revision, middle + 1 );\n \n             int rightPos = pos - middle;\n \n@@ -869,7 +870,7 @@ else if ( nbElems > 0 )\n             System.arraycopy( values, middle, rightLeaf.values, 0, rightPos );\n \n             // Add the new element\n-            rightLeaf.setKey( rightPos, key );\n+            rightLeaf.setKey( rightPos, new KeyHolder<K>( key ) );\n             rightLeaf.values[rightPos] = valueHolder;\n \n             // And copy the remaining elements", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryLeaf.java"}, {"additions": 20, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryValueHolder.java", "sha": "efc1cd43cbf8f294ab89b0d9cc4c1b6b587b3f6c", "changes": 26, "status": "modified", "deletions": 6, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryValueHolder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -29,6 +29,7 @@\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.Tuple;\n import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n+import org.apache.directory.mavibot.btree.persisted.PersistedBTree;\n \n \n /**\n@@ -51,12 +52,17 @@\n     InMemoryValueHolder( BTree<?, V> parentBtree, int nbValues )\n     {\n         valueSerializer = parentBtree.getValueSerializer();\n+\n+        if ( nbValues <= 1 )\n+        {\n+            valueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), nbValues );\n+        }\n     }\n \n \n     /**\n      * Creates a new instance of a ValueHolder, containing Values. This constructor is called\n-     * whe we need to create a new ValueHolder with deserialized values.\n+     * when we need to create a new ValueHolder with deserialized values.\n      * \n      * @param parentBtree The parent BTree\n      * @param values The Values stored in the ValueHolder\n@@ -69,10 +75,12 @@\n         {\n             int nbValues = values.length;\n \n-            if ( nbValues < 2 )\n+            if ( nbValues == 1 )\n             {\n                 // Store the value\n-                valueArray = values;\n+                valueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), nbValues );\n+                valueArray[0] = values[0];\n+                nbArrayElems = nbValues;\n             }\n             else\n             {\n@@ -107,7 +115,7 @@ public int size()\n         }\n         else\n         {\n-            return 1;\n+            return nbArrayElems;\n         }\n     }\n \n@@ -191,6 +199,7 @@ private V removeFromBtree( V removedValue )\n             {\n                 valueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), 1 );\n                 valueArray[0] = valueBtree.browse().next().getKey();\n+                nbArrayElems = 1;\n                 valueBtree.close();\n                 valueBtree = null;\n             }\n@@ -226,7 +235,7 @@ private V removeFromArray( V value )\n         else\n         {\n             V returnedValue = valueArray[0];\n-            valueArray[0] = null;\n+            nbArrayElems = 0;\n           \n             return returnedValue;\n         }\n@@ -278,7 +287,12 @@ public String toString()\n         else\n         {\n             sb.append( \", {\" );\n-            sb.append( valueArray[0] );\n+            \n+            if ( size() != 0 )\n+            {\n+                sb.append( valueArray[0] );\n+            }\n+            \n             sb.append( \"}\" );\n         }\n         ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/InMemoryValueHolder.java"}, {"additions": 85, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/Node.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/Node.java", "sha": "3156ee25348eb18fe8959a2ce9774dc2deac4829", "changes": 173, "status": "modified", "deletions": 88, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/Node.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -24,6 +24,7 @@\n import java.lang.reflect.Array;\n import java.util.List;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.BorrowedFromLeftResult;\n import org.apache.directory.mavibot.btree.BorrowedFromRightResult;\n@@ -34,6 +35,7 @@\n import org.apache.directory.mavibot.btree.ModifyResult;\n import org.apache.directory.mavibot.btree.NotPresentResult;\n import org.apache.directory.mavibot.btree.Page;\n+import org.apache.directory.mavibot.btree.PageHolder;\n import org.apache.directory.mavibot.btree.ParentPos;\n import org.apache.directory.mavibot.btree.RemoveResult;\n import org.apache.directory.mavibot.btree.SplitResult;\n@@ -54,12 +56,8 @@\n  *\n  * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n  */\n-/* No qualifier */class Node<K, V> extends AbstractInMemoryPage<K, V>\n+/* No qualifier */class Node<K, V> extends AbstractPage<K, V>\n {\n-    /** Children pages associated with keys. */\n-    protected Page<K, V>[] children;\n-\n-\n     /**\n      * Creates a new Node which will contain only one key, with references to\n      * a left and right page. This is a specific constructor used by the btree\n@@ -75,7 +73,7 @@\n         super( btree, revision, nbElems );\n \n         // Create the children array\n-        children = ( Page<K, V>[] ) Array.newInstance( Page.class, nbElems + 1 );\n+        children = ( PageHolder<K, V>[] ) Array.newInstance( PageHolder.class, nbElems + 1 );\n     }\n \n \n@@ -96,18 +94,17 @@\n         super( btree, revision, 1 );\n \n         // Create the children array, and store the left and right children\n-        children = ( Page[] ) Array.newInstance( Page.class,\n-            btree.getPageSize() + 1 );\n+        children = ( PageHolder[] ) Array.newInstance( PageHolder.class, btree.getPageSize() + 1 );\n \n-        children[0] = leftPage;\n-        children[1] = rightPage;\n+        children[0] = new PageHolder<K, V>( btree, leftPage );\n+        children[1] = new PageHolder<K, V>( btree, rightPage );\n \n         // Create the keys array and store the pivot into it\n         // We get the type of array to create from the btree\n         // Yes, this is an hack...\n         setKeys( ( KeyHolder<K>[] ) Array.newInstance( KeyHolder.class, btree.getPageSize() ) );\n \n-        setKey( 0, key );\n+        setKey( 0, new KeyHolder<K>( key ) );\n     }\n \n \n@@ -127,7 +124,7 @@\n         }\n \n         // Get the child page into which we will insert the <K, V> tuple\n-        Page<K, V> child = children[pos];\n+        Page<K, V> child = children[pos].getValue();\n \n         // and insert the <K, V> into this child\n         InsertResult<K, V> result = child.insert( revision, key, value );\n@@ -190,16 +187,16 @@\n \n         if ( found )\n         {\n-            newPage.children[index + 1] = modifiedPage;\n+            newPage.children[index + 1] = new PageHolder<K, V>( btree, modifiedPage );\n         }\n         else\n         {\n-            newPage.children[index] = modifiedPage;\n+            newPage.children[index] = new PageHolder<K, V>( btree, modifiedPage );\n         }\n \n         if ( pos < 0 )\n         {\n-            newPage.setKey( index, removeResult.getModifiedPage().getLeftMostKey() );\n+            newPage.setKey( index, new KeyHolder<K>( removeResult.getModifiedPage().getLeftMostKey() ) );\n         }\n \n         // Modify the result and return\n@@ -261,7 +258,7 @@\n         // Create the new sibling, with one less element at the beginning\n         Node<K, V> newSibling = new Node<K, V>( btree, revision, sibling.getNbElems() - 1 );\n \n-        K siblingKey = sibling.children[0].getLeftMostKey();\n+        K siblingKey = sibling.children[0].getValue().getLeftMostKey();\n \n         // Copy the keys and children of the old sibling in the new sibling\n         System.arraycopy( sibling.getKeys(), 1, newSibling.getKeys(), 0, newSibling.getNbElems() );\n@@ -275,7 +272,7 @@\n         int index = Math.abs( pos );\n \n         // Copy the key and children from sibling\n-        newNode.setKey( nbElems - 1, siblingKey ); // 1\n+        newNode.setKey( nbElems - 1, new KeyHolder<K>( siblingKey ) ); // 1\n         newNode.children[nbElems] = sibling.children[0]; // 8\n \n         if ( index < 2 )\n@@ -285,7 +282,7 @@\n \n             // Inject the modified page\n             Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-            newNode.children[0] = modifiedPage;\n+            newNode.children[0] = new PageHolder<K, V>( btree, modifiedPage );\n \n             // Copy the children\n             System.arraycopy( children, 2, newNode.children, 1, nbElems - 1 );\n@@ -299,7 +296,7 @@\n             }\n \n             // Inject the new modified page key\n-            newNode.setKey( index - 2, mergedResult.getModifiedPage().getLeftMostKey() ); // 2\n+            newNode.setKey( index - 2, new KeyHolder<K>( mergedResult.getModifiedPage().getLeftMostKey() ) ); // 2\n \n             if ( index < nbElems )\n             {\n@@ -315,7 +312,7 @@\n \n             // Inject the modified page\n             Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-            newNode.children[index - 1] = modifiedPage; // 6\n+            newNode.children[index - 1] = new PageHolder<K, V>( btree, modifiedPage ); // 6\n         }\n \n         // Create the result\n@@ -344,7 +341,7 @@\n         Node<K, V> sibling, int pos ) throws IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n-        Page<K, V> siblingChild = sibling.children[sibling.nbElems];\n+        Page<K, V> siblingChild = sibling.children[sibling.nbElems].getValue();\n \n         // Create the new sibling, with one less element at the end\n         Node<K, V> newSibling = new Node<K, V>( btree, revision, sibling.getNbElems() - 1 );\n@@ -358,23 +355,23 @@\n         Node<K, V> newNode = new Node<K, V>( btree, revision, nbElems );\n \n         // Sets the first children\n-        newNode.children[0] = siblingChild; //1\n+        newNode.children[0] = new PageHolder<K, V>( btree, siblingChild ); //1\n \n         int index = Math.abs( pos );\n \n         if ( index < 2 )\n         {\n-            newNode.setKey( 0, mergedResult.getModifiedPage().getLeftMostKey() );\n+            newNode.setKey( 0, new KeyHolder<K>( mergedResult.getModifiedPage().getLeftMostKey() ) );\n             System.arraycopy( getKeys(), 1, newNode.getKeys(), 1, nbElems - 1 );\n \n             Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-            newNode.children[1] = modifiedPage;\n+            newNode.children[1] = new PageHolder<K, V>( btree, modifiedPage );\n             System.arraycopy( children, 2, newNode.children, 2, nbElems - 1 );\n         }\n         else\n         {\n             // Set the first key\n-            newNode.setKey( 0, children[0].getLeftMostKey() ); //2\n+            newNode.setKey( 0, new KeyHolder<K>( children[0].getValue().getLeftMostKey() ) ); //2\n \n             if ( index > 2 )\n             {\n@@ -383,7 +380,7 @@\n             }\n \n             // Inject the modified key\n-            newNode.setKey( index - 1, mergedResult.getModifiedPage().getLeftMostKey() ); // 3\n+            newNode.setKey( index - 1, new KeyHolder<K>( mergedResult.getModifiedPage().getLeftMostKey() ) ); // 3\n \n             if ( index < nbElems )\n             {\n@@ -399,7 +396,7 @@\n \n             // Insert the modified page\n             Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-            newNode.children[index] = modifiedPage; // 7\n+            newNode.children[index] = new PageHolder<K, V>( btree, modifiedPage ); // 7\n         }\n \n         // Create the result\n@@ -445,26 +442,26 @@\n             // Then copy all the elements up to the deletion point\n             if ( index < 2 )\n             {\n-                newNode.setKey( half, mergedResult.getModifiedPage().getLeftMostKey() );\n+                newNode.setKey( half, new KeyHolder<K>( mergedResult.getModifiedPage().getLeftMostKey() ) );\n                 System.arraycopy( getKeys(), 1, newNode.getKeys(), half + 1, half - 1 );\n \n                 Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-                newNode.children[half + 1] = modifiedPage;\n+                newNode.children[half + 1] = new PageHolder<K, V>( btree, modifiedPage );\n                 System.arraycopy( children, 2, newNode.children, half + 2, half - 1 );\n             }\n             else\n             {\n                 // Copy the left part of the node keys up to the deletion point\n                 // Insert the new key\n-                newNode.setKey( half, children[0].getLeftMostKey() ); // 3\n+                newNode.setKey( half, new KeyHolder<K>( children[0].getValue().getLeftMostKey() ) ); // 3\n \n                 if ( index > 2 )\n                 {\n                     System.arraycopy( getKeys(), 0, newNode.getKeys(), half + 1, index - 2 ); //4\n                 }\n \n                 // Inject the new merged key\n-                newNode.setKey( half + index - 1, mergedResult.getModifiedPage().getLeftMostKey() ); //5\n+                newNode.setKey( half + index - 1, new KeyHolder<K>( mergedResult.getModifiedPage().getLeftMostKey() ) ); //5\n \n                 if ( index < half )\n                 {\n@@ -477,7 +474,7 @@\n \n                 // Inject the new merged child\n                 Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-                newNode.children[half + index] = modifiedPage; //8\n+                newNode.children[half + index] = new PageHolder<K, V>( btree, modifiedPage ); //8\n             }\n         }\n         else\n@@ -490,7 +487,7 @@\n \n                 // Insert the first child\n                 Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-                newNode.children[0] = modifiedPage;\n+                newNode.children[0] = new PageHolder<K, V>( btree, modifiedPage );\n \n                 // Copy the node children\n                 System.arraycopy( children, 2, newNode.children, 1, half - 1 );\n@@ -508,11 +505,11 @@\n                 System.arraycopy( children, 0, newNode.children, 0, index - 1 ); //6\n \n                 // Inject the modified key\n-                newNode.setKey( index - 2, mergedResult.getModifiedPage().getLeftMostKey() ); //2\n+                newNode.setKey( index - 2, new KeyHolder<K>( mergedResult.getModifiedPage().getLeftMostKey() ) ); //2\n \n                 // Inject the modified children\n                 Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-                newNode.children[index - 1] = modifiedPage; // 7\n+                newNode.children[index - 1] = new PageHolder<K, V>( btree, modifiedPage ); // 7\n \n                 // Add the remaining node's key if needed\n                 if ( index < half )\n@@ -525,7 +522,7 @@\n             }\n \n             // Inject the new key from sibling\n-            newNode.setKey( half - 1, sibling.findLeftMost().getKey() ); //3\n+            newNode.setKey( half - 1, new KeyHolder<K>( sibling.findLeftMost().getKey() ) ); //3\n \n             // Copy the sibling keys\n             System.arraycopy( sibling.getKeys(), 0, newNode.getKeys(), half, half );\n@@ -562,12 +559,12 @@\n         if ( found )\n         {\n             index = -( pos + 1 );\n-            child = children[-pos];\n+            child = children[-pos].getValue();\n             deleteResult = child.delete( revision, key, value, this, -pos );\n         }\n         else\n         {\n-            child = children[pos];\n+            child = children[pos].getValue();\n             deleteResult = child.delete( revision, key, value, this, pos );\n         }\n \n@@ -631,7 +628,7 @@\n                 // a sibling, or we will have to merge two pages\n                 int siblingPos = selectSibling( ( Node<K, V> ) parent, parentPos );\n \n-                Node<K, V> sibling = ( Node<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos] );\n+                Node<K, V> sibling = ( Node<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos].getValue() );\n \n                 if ( sibling.getNbElems() > halfSize )\n                 {\n@@ -690,42 +687,42 @@\n             if ( borrowedResult.isFromRight() )\n             {\n                 // Update the keys\n-                newPage.setKey( pos, modifiedPage.findLeftMost().getKey() );\n-                newPage.setKey( pos + 1, modifiedSibling.findLeftMost().getKey() );\n+                newPage.setKey( pos, new KeyHolder<K>( modifiedPage.findLeftMost().getKey() ) );\n+                newPage.setKey( pos + 1, new KeyHolder<K>( modifiedSibling.findLeftMost().getKey() ) );\n \n                 // Update the children\n-                newPage.children[pos + 1] = modifiedPage;\n-                newPage.children[pos + 2] = modifiedSibling;\n+                newPage.children[pos + 1] = new PageHolder<K, V>( btree, modifiedPage );\n+                newPage.children[pos + 2] = new PageHolder<K, V>( btree, modifiedSibling );\n             }\n             else\n             {\n                 // Update the keys\n-                newPage.setKey( pos, modifiedPage.findLeftMost().getKey() );\n+                newPage.setKey( pos, new KeyHolder<K>( modifiedPage.findLeftMost().getKey() ) );\n \n                 // Update the children\n-                newPage.children[pos] = modifiedSibling;\n-                newPage.children[pos + 1] = modifiedPage;\n+                newPage.children[pos] = new PageHolder<K, V>( btree, modifiedSibling );\n+                newPage.children[pos + 1] = new PageHolder<K, V>( btree, modifiedPage );\n             }\n         }\n         else\n         {\n             if ( borrowedResult.isFromRight() )\n             {\n                 // Update the keys\n-                newPage.setKey( pos, modifiedSibling.findLeftMost().getKey() );\n+                newPage.setKey( pos, new KeyHolder<K>( modifiedSibling.findLeftMost().getKey() ) );\n \n                 // Update the children\n-                newPage.children[pos] = modifiedPage;\n-                newPage.children[pos + 1] = modifiedSibling;\n+                newPage.children[pos] = new PageHolder<K, V>( btree, modifiedPage );\n+                newPage.children[pos + 1] = new PageHolder<K, V>( btree, modifiedSibling );\n             }\n             else\n             {\n                 // Update the keys\n-                newPage.setKey( pos - 1, modifiedPage.findLeftMost().getKey() );\n+                newPage.setKey( pos - 1, new KeyHolder<K>( modifiedPage.findLeftMost().getKey() ) );\n \n                 // Update the children\n-                newPage.children[pos - 1] = modifiedSibling;\n-                newPage.children[pos] = modifiedPage;\n+                newPage.children[pos - 1] = new PageHolder<K, V>( btree, modifiedSibling );\n+                newPage.children[pos] = new PageHolder<K, V>( btree, modifiedPage );\n             }\n         }\n \n@@ -762,7 +759,7 @@\n             // Copy the keys and the children\n             System.arraycopy( getKeys(), 1, newNode.getKeys(), 0, newNode.nbElems );\n             Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-            newNode.children[0] = modifiedPage;\n+            newNode.children[0] = new PageHolder<K, V>( btree, modifiedPage );\n             System.arraycopy( children, 2, newNode.children, 1, nbElems - 1 );\n         }\n         else\n@@ -773,7 +770,7 @@\n                 System.arraycopy( getKeys(), 0, newNode.getKeys(), 0, index );\n             }\n \n-            newNode.setKey( index, mergedResult.getModifiedPage().findLeftMost().getKey() );\n+            newNode.setKey( index, new KeyHolder<K>( mergedResult.getModifiedPage().findLeftMost().getKey() ) );\n \n             if ( index < nbElems - 2 )\n             {\n@@ -784,7 +781,7 @@\n             System.arraycopy( children, 0, newNode.children, 0, index + 1 );\n \n             Page<K, V> modifiedPage = mergedResult.getModifiedPage();\n-            newNode.children[index + 1] = modifiedPage;\n+            newNode.children[index + 1] = new PageHolder<K, V>( btree, modifiedPage );\n \n             if ( index < nbElems - 2 )\n             {\n@@ -813,11 +810,11 @@ public V get( K key ) throws IOException, KeyNotFoundException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].get( key );\n+            return children[-pos].getValue().get( key );\n         }\n         else\n         {\n-            return children[pos].get( key );\n+            return children[pos].getValue().get( key );\n         }\n     }\n \n@@ -834,11 +831,11 @@ public V get( K key ) throws IOException, KeyNotFoundException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].getValues( key );\n+            return children[-pos].getValue().getValues( key );\n         }\n         else\n         {\n-            return children[pos].getValues( key );\n+            return children[pos].getValue().getValues( key );\n         }\n     }\n \n@@ -855,11 +852,11 @@ public boolean hasKey( K key ) throws IOException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].hasKey( key );\n+            return children[-pos].getValue().hasKey( key );\n         }\n         else\n         {\n-            Page<K, V> page = children[pos];\n+            Page<K, V> page = children[pos].getValue();\n \n             if ( page == null )\n             {\n@@ -883,11 +880,11 @@ public boolean contains( K key, V value ) throws IOException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].contains( key, value );\n+            return children[-pos].getValue().contains( key, value );\n         }\n         else\n         {\n-            return children[pos].contains( key, value );\n+            return children[pos].getValue().contains( key, value );\n         }\n     }\n \n@@ -900,7 +897,7 @@ public boolean contains( K key, V value ) throws IOException\n      */\n     public void setValue( int pos, Page<K, V> value )\n     {\n-        children[pos] = value;\n+        children[pos] = new PageHolder<K, V>( btree, value );\n     }\n \n \n@@ -911,7 +908,7 @@ public void setValue( int pos, Page<K, V> value )\n     {\n         if ( pos < nbElems + 1 )\n         {\n-            return children[pos];\n+            return children[pos].getValue();\n         }\n         else\n         {\n@@ -936,7 +933,7 @@ public void setValue( int pos, Page<K, V> value )\n         // We first stack the current page\n         stack[depth++] = new ParentPos<K, V>( this, pos );\n         \n-        Page<K, V> page = children[pos];\n+        Page<K, V> page = children[pos].getValue();\n \n         return page.browse( key, transaction, stack, depth );\n     }\n@@ -950,7 +947,7 @@ public void setValue( int pos, Page<K, V> value )\n     {\n         stack[depth++] = new ParentPos<K, V>( this, 0 );\n         \n-        Page<K, V> page = children[0];\n+        Page<K, V> page = children[0].getValue();\n \n         return page.browse( transaction, stack, depth );\n     }\n@@ -976,7 +973,7 @@ public void setValue( int pos, Page<K, V> value )\n         // to point on the modified child\n         Page<K, V> modifiedPage = result.getModifiedPage();\n \n-        ( ( Node<K, V> ) newPage ).children[pos] = modifiedPage;\n+        ( ( Node<K, V> ) newPage ).children[pos] = new PageHolder<K, V>( btree, modifiedPage );\n \n         // We can return the result, where we update the modifiedPage,\n         // to avoid the creation of a new object\n@@ -1016,12 +1013,12 @@ public void setValue( int pos, Page<K, V> value )\n         }\n \n         // Add the new key and children\n-        newNode.setKey( pos, key );\n+        newNode.setKey( pos, new KeyHolder<K>( key ) );\n \n         // If the BTree is managed, we now have to write the modified page on disk\n         // and to add this page to the list of modified pages\n-        newNode.children[pos] = leftPage;\n-        newNode.children[pos + 1] = rightPage;\n+        newNode.children[pos] = new PageHolder<K, V>( btree, leftPage );\n+        newNode.children[pos + 1] = new PageHolder<K, V>( btree, rightPage );\n \n         // And copy the remaining keys and children\n         if ( nbElems > 0 )\n@@ -1075,9 +1072,9 @@ public void setValue( int pos, Page<K, V> value )\n             System.arraycopy( children, 0, newLeftPage.children, 0, pos );\n \n             // Add the new element\n-            newLeftPage.setKey( pos, pivot );\n-            newLeftPage.children[pos] = leftPage;\n-            newLeftPage.children[pos + 1] = rightPage;\n+            newLeftPage.setKey( pos, new KeyHolder<K>( pivot ) );\n+            newLeftPage.children[pos] = new PageHolder<K, V>( btree, leftPage );\n+            newLeftPage.children[pos + 1] = new PageHolder<K, V>( btree, rightPage );\n \n             // And copy the remaining elements minus the new pivot\n             System.arraycopy( getKeys(), pos, newLeftPage.getKeys(), pos + 1, middle - pos - 1 );\n@@ -1100,12 +1097,12 @@ else if ( pos == middle )\n             // Copy the keys and the children up to the insertion position (here, middle)\n             System.arraycopy( getKeys(), 0, newLeftPage.getKeys(), 0, middle );\n             System.arraycopy( children, 0, newLeftPage.children, 0, middle );\n-            newLeftPage.children[middle] = leftPage;\n+            newLeftPage.children[middle] = new PageHolder<K, V>( btree, leftPage );\n \n             // And process the right page now\n             System.arraycopy( getKeys(), middle, newRightPage.getKeys(), 0, middle );\n             System.arraycopy( children, middle + 1, newRightPage.children, 1, middle );\n-            newRightPage.children[0] = rightPage;\n+            newRightPage.children[0] = new PageHolder<K, V>( btree, rightPage );\n \n             // Create the result\n             InsertResult<K, V> result = new SplitResult<K, V>( copiedPages, pivot, newLeftPage, newRightPage );\n@@ -1124,9 +1121,9 @@ else if ( pos == middle )\n             System.arraycopy( children, middle + 1, newRightPage.children, 0, pos - middle - 1 );\n \n             // Add the new element\n-            newRightPage.setKey( pos - middle - 1, pivot );\n-            newRightPage.children[pos - middle - 1] = leftPage;\n-            newRightPage.children[pos - middle] = rightPage;\n+            newRightPage.setKey( pos - middle - 1, new KeyHolder<K>( pivot ) );\n+            newRightPage.children[pos - middle - 1] = new PageHolder<K, V>( btree, leftPage );\n+            newRightPage.children[pos - middle] = new PageHolder<K, V>( btree, rightPage );\n \n             // And copy the remaining elements minus the new pivot\n             System.arraycopy( getKeys(), pos, newRightPage.getKeys(), pos - middle, nbElems - pos );\n@@ -1166,7 +1163,7 @@ else if ( pos == middle )\n      */\n     public K getLeftMostKey()\n     {\n-        return children[0].getLeftMostKey();\n+        return children[0].getValue().getLeftMostKey();\n     }\n \n \n@@ -1179,10 +1176,10 @@ public K getRightMostKey()\n \n         if ( children[index] != null )\n         {\n-            return children[index].getRightMostKey();\n+            return children[index].getValue().getRightMostKey();\n         }\n \n-        return children[nbElems - 1].getRightMostKey();\n+        return children[nbElems - 1].getValue().getRightMostKey();\n     }\n \n \n@@ -1191,7 +1188,7 @@ public K getRightMostKey()\n      */\n     public Tuple<K, V> findLeftMost() throws EndOfFileExceededException, IOException\n     {\n-        return children[0].findLeftMost();\n+        return children[0].getValue().findLeftMost();\n     }\n \n \n@@ -1200,7 +1197,7 @@ public K getRightMostKey()\n      */\n     public Tuple<K, V> findRightMost() throws EndOfFileExceededException, IOException\n     {\n-        return children[nbElems].findRightMost();\n+        return children[nbElems].getValue().findRightMost();\n     }\n \n \n@@ -1224,7 +1221,7 @@ public String toString()\n             }\n             else\n             {\n-                sb.append( 'r' ).append( children[0].getRevision() );\n+                sb.append( 'r' ).append( children[0].getValue().getRevision() );\n             }\n \n             for ( int i = 0; i < nbElems; i++ )\n@@ -1237,7 +1234,7 @@ public String toString()\n                 }\n                 else\n                 {\n-                    sb.append( 'r' ).append( children[i + 1].getRevision() );\n+                    sb.append( 'r' ).append( children[i + 1].getValue().getRevision() );\n                 }\n             }\n         }\n@@ -1258,14 +1255,14 @@ public String dumpPage( String tabs )\n         if ( nbElems > 0 )\n         {\n             // Start with the first child\n-            sb.append( children[0].dumpPage( tabs + \"    \" ) );\n+            sb.append( children[0].getValue().dumpPage( tabs + \"    \" ) );\n \n             for ( int i = 0; i < nbElems; i++ )\n             {\n                 sb.append( tabs );\n                 sb.append( \"<\" );\n                 sb.append( getKey( i ) ).append( \">\\n\" );\n-                sb.append( children[i + 1].dumpPage( tabs + \"    \" ) );\n+                sb.append( children[i + 1].getValue().dumpPage( tabs + \"    \" ) );\n             }\n         }\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/Node.java"}, {"additions": 21, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/TupleCursorImpl.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/TupleCursorImpl.java", "sha": "7f9c60a29f8d9c77f255c8b9b62968ea9da8b642", "changes": 42, "status": "modified", "deletions": 21, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/TupleCursorImpl.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -86,7 +86,7 @@ public void afterLast() throws IOException\n                 parentPos.pos = parentPos.page.getNbElems();\n             }\n \n-            child = ((Node<K, V>)parentPos.page).children[parentPos.pos];\n+            child = ((Node<K, V>)parentPos.page).getPage( parentPos.pos );\n         }\n         \n         // and leaf\n@@ -102,7 +102,7 @@ public void afterLast() throws IOException\n             parentPos.pos = child.getNbElems() - 1;\n         }\n \n-        parentPos.valueCursor = ((Leaf<K, V>)parentPos.page).values[parentPos.pos].getCursor();\n+        parentPos.valueCursor = ((InMemoryLeaf<K, V>)parentPos.page).values[parentPos.pos].getCursor();\n         parentPos.valueCursor.afterLast();\n         parentPos.pos = AFTER_LAST;\n     }\n@@ -131,7 +131,7 @@ public void beforeFirst() throws IOException\n                 parentPos.page = child;\n             }\n \n-            child = ((Node<K, V>)parentPos.page).children[0];\n+            child = ((Node<K, V>)parentPos.page).getPage( 0 );\n         }\n \n         // and leaf\n@@ -145,7 +145,7 @@ public void beforeFirst() throws IOException\n         \n         if ( parentPos.valueCursor != null )\n         {\n-            parentPos.valueCursor = ((Leaf<K, V>)parentPos.page).values[0].getCursor();\n+            parentPos.valueCursor = ((InMemoryLeaf<K, V>)parentPos.page).values[0].getCursor();\n             parentPos.valueCursor.beforeFirst();\n         }\n     }\n@@ -185,7 +185,7 @@ public void beforeFirst() throws IOException\n             {\n                 // We can pick the next element at this level\n                 parentPos.pos++;\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos];\n+                child = ((Node<K, V>)parentPos.page).getPage( parentPos.pos );\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n@@ -194,14 +194,14 @@ public void beforeFirst() throws IOException\n                     parentPos = stack[currentDepth];\n                     parentPos.pos = 0;\n                     parentPos.page = child;\n-                    child = ((Node<K, V>)child).children[0];\n+                    child = ((Node<K, V>)child).getPage( 0 );\n                 }\n \n                 // and the leaf\n                 parentPos = stack[depth];\n                 parentPos.page = child;\n                 parentPos.pos = 0;\n-                parentPos.valueCursor = ((Leaf<K, V>)child).values[0].getCursor();\n+                parentPos.valueCursor = ((InMemoryLeaf<K, V>)child).values[0].getCursor();\n \n                 return parentPos;\n             }\n@@ -245,7 +245,7 @@ public void beforeFirst() throws IOException\n             {\n                 // We can pick the next element at this level\n                 parentPos.pos--;\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos];\n+                child = ((Node<K, V>)parentPos.page).getPage( parentPos.pos );\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n@@ -254,14 +254,14 @@ public void beforeFirst() throws IOException\n                     parentPos = stack[currentDepth];\n                     parentPos.pos = child.getNbElems();\n                     parentPos.page = child;\n-                    child = ((Node<K, V>)parentPos.page).children[parentPos.page.getNbElems()];\n+                    child = ((Node<K, V>)parentPos.page).getPage( parentPos.page.getNbElems() );\n                 }\n \n                 // and the leaf\n                 parentPos = stack[depth];\n                 parentPos.pos = child.getNbElems() - 1;\n                 parentPos.page = child;\n-                ValueHolder<V> valueHolder = ((Leaf<K, V>)parentPos.page).values[parentPos.pos];\n+                ValueHolder<V> valueHolder = ((InMemoryLeaf<K, V>)parentPos.page).values[parentPos.pos];\n                 parentPos.valueCursor = valueHolder.getCursor();\n                 parentPos.valueCursor.afterLast();\n \n@@ -402,13 +402,13 @@ private boolean hasNextParentPos() throws EndOfFileExceededException, IOExceptio\n             else\n             {\n                 // We can pick the next element at this level\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos + 1];\n+                child = ((Node<K, V>)parentPos.page).getPage( parentPos.pos + 1 );\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n                 {\n                     currentDepth++;\n-                    child = ((Node<K, V>)child).children[0];\n+                    child = ((Node<K, V>)child).getPage( 0 );\n                 }\n \n                 return true;\n@@ -548,13 +548,13 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n             else\n             {\n                 // We can pick the previous element at this level\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos - 1];\n+                child = ((Node<K, V>)parentPos.page).getPage( parentPos.pos - 1 );\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n                 {\n                     currentDepth++;\n-                    child = ((Node<K, V>)child).children[child.getNbElems()];\n+                    child = ((Node<K, V>)child).getPage( child.getNbElems() );\n                 }\n \n                 return true;\n@@ -630,7 +630,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n \n             try\n             {\n-                ValueHolder<V> valueHolder = ( ( Leaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n+                ValueHolder<V> valueHolder = ( ( InMemoryLeaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n                 \n                 parentPos.valueCursor = valueHolder.getCursor();\n                 \n@@ -642,7 +642,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n             }\n         }\n         \n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( parentPos.page );\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n         tuple.setValue( value );\n \n@@ -681,7 +681,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n             if ( ( newParentPos == null ) || ( newParentPos.page == null ) )\n             {\n                 // This is the end : no more value\n-                Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+                InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( parentPos.page );\n                 ValueHolder<V> valueHolder = leaf.values[parentPos.pos];\n                 parentPos.pos = AFTER_LAST;\n                 parentPos.valueCursor = valueHolder.getCursor();\n@@ -701,7 +701,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n         }\n \n         // The key\n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( parentPos.page );\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n         \n         // The value\n@@ -778,7 +778,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n                 \n                 try\n                 {\n-                    ValueHolder<V> valueHolder = ( ( Leaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n+                    ValueHolder<V> valueHolder = ( ( InMemoryLeaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n                     \n                     parentPos.valueCursor = valueHolder.getCursor();\n                     parentPos.valueCursor.afterLast();\n@@ -793,7 +793,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n         }\n \n \n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( parentPos.page );\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n         tuple.setValue( value );\n \n@@ -846,7 +846,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n         }\n         \n         // Update the Tuple \n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        InMemoryLeaf<K, V> leaf = ( InMemoryLeaf<K, V> ) ( parentPos.page );\n \n         // The key\n         tuple.setKey( leaf.getKey( parentPos.pos ) );", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/memory/TupleCursorImpl.java"}, {"additions": 0, "raw_url": "https://github.com/apache/directory-mavibot/raw/316afb2f211cf3a04cf884a4532ef4650fd4247c/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/AbstractPersistedPage.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/316afb2f211cf3a04cf884a4532ef4650fd4247c/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/AbstractPersistedPage.java", "sha": "9700927e49314e8a9324f1a9f4dc944da29bfdb8", "changes": 132, "status": "removed", "deletions": 132, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/AbstractPersistedPage.java?ref=316afb2f211cf3a04cf884a4532ef4650fd4247c", "patch": "@@ -1,132 +0,0 @@\n-/*\n- *  Licensed to the Apache Software Foundation (ASF) under one\n- *  or more contributor license agreements.  See the NOTICE file\n- *  distributed with this work for additional information\n- *  regarding copyright ownership.  The ASF licenses this file\n- *  to you under the Apache License, Version 2.0 (the\n- *  \"License\"); you may not use this file except in compliance\n- *  with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- *\n- */\n-package org.apache.directory.mavibot.btree.persisted;\n-\n-\n-import java.io.IOException;\n-import java.lang.reflect.Array;\n-\n-import org.apache.directory.mavibot.btree.AbstractPage;\n-import org.apache.directory.mavibot.btree.BTree;\n-import org.apache.directory.mavibot.btree.KeyHolder;\n-import org.apache.directory.mavibot.btree.Page;\n-\n-\n-/**\n- * A MVCC abstract Page. It stores the field and the methods shared by the Node and Leaf\n- * classes.\n- * \n- * @param <K> The type for the Key\n- * @param <V> The type for the stored value\n- *\n- * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n- */\n-/* No qualifier */abstract class AbstractPersistedPage<K, V> extends AbstractPage<K, V>\n-{\n-    /**\n-     * Creates a default empty AbstractPage\n-     * \n-     * @param btree The associated BTree\n-     */\n-    protected AbstractPersistedPage( BTree<K, V> btree )\n-    {\n-        super( btree );\n-    }\n-\n-\n-    /**\n-     * Internal constructor used to create Page instance used when a page is being copied or overflow\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    // Cannot create an array of generic objects\n-    protected AbstractPersistedPage( BTree<K, V> btree, long revision, int nbElems )\n-    {\n-        super( btree );\n-        this.revision = revision;\n-        this.nbElems = nbElems;\n-        this.keys = ( KeyHolder[] ) Array.newInstance( KeyHolder.class, nbElems );\n-    }\n-\n-\n-    /**\n-     * Selects the sibling (the previous or next page with the same parent) which has\n-     * the more element assuming it's above N/2\n-     * \n-     * @param parent The parent of the current page\n-     * @param The position of the current page reference in its parent\n-     * @return The position of the sibling, or -1 if we have'nt found any sibling\n-     * @throws IOException If we have an error while trying to access the page\n-     */\n-    protected int selectSibling( Node<K, V> parent, int parentPos ) throws IOException\n-    {\n-        if ( parentPos == 0 )\n-        {\n-            // The current page is referenced on the left of its parent's page :\n-            // we will not have a previous page with the same parent\n-            return 1;\n-        }\n-\n-        if ( parentPos == parent.getNbElems() )\n-        {\n-            // The current page is referenced on the right of its parent's page :\n-            // we will not have a next page with the same parent\n-            return parentPos - 1;\n-        }\n-\n-        Page<K, V> prevPage = parent.children[parentPos - 1].getValue( btree );\n-        Page<K, V> nextPage = parent.children[parentPos + 1].getValue( btree );\n-\n-        int prevPageSize = prevPage.getNbElems();\n-        int nextPageSize = nextPage.getNbElems();\n-\n-        if ( prevPageSize >= nextPageSize )\n-        {\n-            return parentPos - 1;\n-        }\n-        else\n-        {\n-            return parentPos + 1;\n-        }\n-    }\n-\n-\n-    /**\n-     * Sets the key at a give position\n-     * \n-     * @param pos The position in the keys array\n-     * @param key the key to inject\n-     */\n-    /* No qualifier*/void setKey( int pos, K key )\n-    {\n-        keys[pos] = new PersistedKeyHolder<K>( btree.getKeySerializer(), key );\n-    }\n-\n-\n-    /**\n-     * Sets the key at a give position\n-     * \n-     * @param pos The position in the keys array\n-     * @param buffer the serialized key to inject\n-     */\n-    /* No qualifier*/void setKey( int pos, byte[] buffer )\n-    {\n-        keys[pos] = new PersistedKeyHolder<K>( btree.getKeySerializer(), buffer );\n-    }\n-}", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/AbstractPersistedPage.java"}, {"additions": 22, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/BTreeFactory.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/BTreeFactory.java", "sha": "7270652f7c0570691413bf126dee3edea2fdd60c", "changes": 40, "status": "modified", "deletions": 18, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/BTreeFactory.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -23,7 +23,9 @@\n import java.io.IOException;\n import java.util.LinkedList;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n+import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n import org.apache.directory.mavibot.btree.ParentPos;\n import org.apache.directory.mavibot.btree.ValueHolder;\n@@ -90,9 +92,9 @@\n      * @param nbElems The number or elements in this leaf\n      * @return A Leaf instance\n      */\n-    public static <K, V> Leaf<K, V> createLeaf( BTree<K, V> btree, long revision, int nbElems )\n+    public static <K, V> PersistedLeaf<K, V> createLeaf( BTree<K, V> btree, long revision, int nbElems )\n     {\n-        Leaf<K, V> leaf = new Leaf<K, V>( btree, revision, nbElems );\n+        PersistedLeaf<K, V> leaf = new PersistedLeaf<K, V>( btree, revision, nbElems );\n \n         return leaf;\n     }\n@@ -232,9 +234,10 @@\n      * @param pos The position in the keys array\n      * @param key the key to inject\n      */\n-    public static <K, V> void setKey( Page<K, V> page, int pos, K key )\n+    public static <K, V> void setKey( BTree<K, V> btree, Page<K, V> page, int pos, K key )\n     {\n-        ( ( AbstractPersistedPage<K, V> ) page ).setKey( pos, key );\n+        KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), key );\n+        ( ( AbstractPage<K, V> ) page ).setKey( pos, keyHolder );\n     }\n \n \n@@ -244,9 +247,10 @@\n      * @param pos the position of this key in the page\n      * @param buffer the byte[] containing the serialized key\n      */\n-    public static <K, V> void setKey( Page<K, V> page, int pos, byte[] buffer )\n+    public static <K, V> void setKey( BTree<K, V> btree, Page<K, V> page, int pos, byte[] buffer )\n     {\n-        ( ( AbstractPersistedPage<K, V> ) page ).setKey( pos, buffer );\n+        KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), buffer );\n+        ( ( AbstractPage<K, V> ) page ).setKey( pos, keyHolder );\n     }\n \n \n@@ -255,7 +259,7 @@\n      * @param pos The position in the values array\n      * @param value the value to inject\n      */\n-    public static <K, V> void setValue( Leaf<K, V> page, int pos, PersistedValueHolder<V> value )\n+    public static <K, V> void setValue( PersistedLeaf<K, V> page, int pos, PersistedValueHolder<V> value )\n     {\n         page.setValue( pos, value );\n     }\n@@ -266,7 +270,7 @@\n      * @param pos The position in the values array\n      * @param value the value to inject\n      */\n-    public static <K, V> void setValue( Node<K, V> page, int pos, PageHolder<K, V> value )\n+    public static <K, V> void setValue( Node<K, V> page, int pos, PersistedPageHolder<K, V> value )\n     {\n         page.setValue( pos, value );\n     }\n@@ -286,9 +290,9 @@\n         ParentPos<K, V> last = new ParentPos<K, V>( btree.getRootPage(), btree.getRootPage().getNbElems() );\n         stack.push( last );\n \n-        if ( btree.getRootPage() instanceof Leaf )\n+        if ( btree.getRootPage() instanceof PersistedLeaf )\n         {\n-            Leaf<K, V> leaf = ( Leaf<K, V> ) ( btree.getRootPage() );\n+            PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( btree.getRootPage() );\n             ValueHolder<V> valueHolder = leaf.values[last.pos];\n             last.valueCursor = valueHolder.getCursor();\n         }\n@@ -298,14 +302,14 @@\n \n             while ( true )\n             {\n-                Page<K, V> p = node.children[node.getNbElems()].getValue( btree );\n+                Page<K, V> p = node.children[node.getNbElems()].getValue();\n \n                 last = new ParentPos<K, V>( p, p.getNbElems() );\n                 stack.push( last );\n \n-                if ( p instanceof Leaf )\n+                if ( p instanceof PersistedLeaf )\n                 {\n-                    Leaf<K, V> leaf = ( Leaf<K, V> ) ( last.page );\n+                    PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( last.page );\n                     ValueHolder<V> valueHolder = leaf.values[last.pos];\n                     last.valueCursor = valueHolder.getCursor();\n                     break;\n@@ -331,9 +335,9 @@\n         ParentPos<K, V> first = new ParentPos<K, V>( btree.getRootPage(), 0 );\n         stack.push( first );\n \n-        if ( btree.getRootPage() instanceof Leaf )\n+        if ( btree.getRootPage() instanceof PersistedLeaf )\n         {\n-            Leaf<K, V> leaf = ( Leaf<K, V> ) ( btree.getRootPage() );\n+            PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( btree.getRootPage() );\n             ValueHolder<V> valueHolder = leaf.values[first.pos];\n             first.valueCursor = valueHolder.getCursor();\n         }\n@@ -343,14 +347,14 @@\n \n             while ( true )\n             {\n-                Page<K, V> page = node.children[0].getValue( btree );\n+                Page<K, V> page = node.children[0].getValue();\n \n                 first = new ParentPos<K, V>( page, 0 );\n                 stack.push( first );\n \n-                if ( page instanceof Leaf )\n+                if ( page instanceof PersistedLeaf )\n                 {\n-                    Leaf<K, V> leaf = ( Leaf<K, V> ) ( page );\n+                    PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( page );\n                     ValueHolder<V> valueHolder = leaf.values[first.pos];\n                     first.valueCursor = valueHolder.getCursor();\n                     break;", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/BTreeFactory.java"}, {"additions": 62, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/Node.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/Node.java", "sha": "6c3137aa0d647d5052f52fec00143952b2861338", "changes": 163, "status": "modified", "deletions": 101, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/Node.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -24,6 +24,7 @@\n import java.lang.reflect.Array;\n import java.util.List;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.BorrowedFromSiblingResult;\n import org.apache.directory.mavibot.btree.BorrowedFromLeftResult;\n@@ -54,10 +55,10 @@\n  *\n  * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n  */\n-/* No qualifier */class Node<K, V> extends AbstractPersistedPage<K, V>\n+/* No qualifier */class Node<K, V> extends AbstractPage<K, V>\n {\n     /** Children pages associated with keys. */\n-    protected PageHolder<K, V>[] children;\n+    protected PersistedPageHolder<K, V>[] children;\n \n \n     /**\n@@ -75,7 +76,7 @@\n         super( btree, revision, nbElems );\n \n         // Create the children array\n-        children = ( PageHolder<K, V>[] ) Array.newInstance( PageHolder.class, nbElems + 1 );\n+        children = ( PersistedPageHolder<K, V>[] ) Array.newInstance( PersistedPageHolder.class, nbElems + 1 );\n     }\n \n \n@@ -96,11 +97,11 @@\n         super( btree, revision, 1 );\n \n         // Create the children array, and store the left and right children\n-        children = ( PageHolder<K, V>[] ) Array.newInstance( PageHolder.class,\n+        children = ( PersistedPageHolder<K, V>[] ) Array.newInstance( PersistedPageHolder.class,\n             btree.getPageSize() + 1 );\n \n-        children[0] = new PageHolder<K, V>( btree, leftPage );\n-        children[1] = new PageHolder<K, V>( btree, rightPage );\n+        children[0] = new PersistedPageHolder<K, V>( btree, leftPage );\n+        children[1] = new PersistedPageHolder<K, V>( btree, rightPage );\n \n         // Create the keys array and store the pivot into it\n         // We get the type of array to create from the btree\n@@ -123,13 +124,13 @@\n      * @param rightPage The right page\n      */\n     @SuppressWarnings(\"unchecked\")\n-    /* No qualifier */Node( BTree<K, V> btree, long revision, K key, PageHolder<K, V> leftPage,\n-        PageHolder<K, V> rightPage )\n+    /* No qualifier */Node( BTree<K, V> btree, long revision, K key, PersistedPageHolder<K, V> leftPage,\n+        PersistedPageHolder<K, V> rightPage )\n     {\n         super( btree, revision, 1 );\n \n         // Create the children array, and store the left and right children\n-        children = ( PageHolder<K, V>[] ) Array.newInstance( PageHolder.class,\n+        children = ( PersistedPageHolder<K, V>[] ) Array.newInstance( PersistedPageHolder.class,\n             btree.getPageSize() + 1 );\n \n         children[0] = leftPage;\n@@ -158,7 +159,7 @@\n         }\n \n         // Get the child page into which we will insert the <K, V> tuple\n-        Page<K, V> child = children[pos].getValue( btree );\n+        Page<K, V> child = children[pos].getValue();\n \n         // and insert the <K, V> into this child\n         InsertResult<K, V> result = child.insert( revision, key, value );\n@@ -292,7 +293,7 @@\n         // Create the new sibling, with one less element at the beginning\n         Node<K, V> newSibling = new Node<K, V>( btree, revision, sibling.getNbElems() - 1 );\n \n-        K siblingKey = sibling.children[0].getValue( btree ).getLeftMostKey();\n+        K siblingKey = sibling.children[0].getValue().getLeftMostKey();\n \n         // Copy the keys and children of the old sibling in the new sibling\n         System.arraycopy( sibling.keys, 1, newSibling.keys, 0, newSibling.getNbElems() );\n@@ -376,7 +377,7 @@\n         Node<K, V> sibling, int pos ) throws IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n-        Page<K, V> siblingChild = sibling.children[sibling.nbElems].getValue( btree );\n+        Page<K, V> siblingChild = sibling.children[sibling.nbElems].getValue();\n \n         // Create the new sibling, with one less element at the end\n         Node<K, V> newSibling = new Node<K, V>( btree, revision, sibling.getNbElems() - 1 );\n@@ -407,7 +408,7 @@\n         else\n         {\n             // Set the first key\n-            newNode.keys[0] = new PersistedKeyHolder<K>( btree.getKeySerializer(), children[0].getValue( btree )\n+            newNode.keys[0] = new PersistedKeyHolder<K>( btree.getKeySerializer(), children[0].getValue()\n                 .getLeftMostKey() ); //2\n \n             if ( index > 2 )\n@@ -492,7 +493,7 @@\n             {\n                 // Copy the left part of the node keys up to the deletion point\n                 // Insert the new key\n-                newNode.keys[half] = new PersistedKeyHolder<K>( btree.getKeySerializer(), children[0].getValue( btree )\n+                newNode.keys[half] = new PersistedKeyHolder<K>( btree.getKeySerializer(), children[0].getValue()\n                     .getLeftMostKey() ); // 3\n \n                 if ( index > 2 )\n@@ -601,12 +602,12 @@\n         if ( found )\n         {\n             index = -( pos + 1 );\n-            child = children[-pos].getValue( btree );\n+            child = children[-pos].getValue();\n             deleteResult = child.delete( revision, key, value, this, -pos );\n         }\n         else\n         {\n-            child = children[pos].getValue( btree );\n+            child = children[pos].getValue();\n             deleteResult = child.delete( revision, key, value, this, pos );\n         }\n \n@@ -670,7 +671,7 @@\n                 // a sibling, or we will have to merge two pages\n                 int siblingPos = selectSibling( ( Node<K, V> ) parent, parentPos );\n \n-                Node<K, V> sibling = ( Node<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos].getValue( btree ) );\n+                Node<K, V> sibling = ( Node<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos].getValue() );\n \n                 if ( sibling.getNbElems() > halfSize )\n                 {\n@@ -871,11 +872,11 @@ public V get( K key ) throws IOException, KeyNotFoundException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].getValue( btree ).get( key );\n+            return children[-pos].getValue().get( key );\n         }\n         else\n         {\n-            return children[pos].getValue( btree ).get( key );\n+            return children[pos].getValue().get( key );\n         }\n     }\n \n@@ -892,11 +893,11 @@ public V get( K key ) throws IOException, KeyNotFoundException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].getValue( btree ).getValues( key );\n+            return children[-pos].getValue().getValues( key );\n         }\n         else\n         {\n-            return children[pos].getValue( btree ).getValues( key );\n+            return children[pos].getValue().getValues( key );\n         }\n     }\n \n@@ -913,11 +914,11 @@ public boolean hasKey( K key ) throws IOException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].getValue( btree ).hasKey( key );\n+            return children[-pos].getValue().hasKey( key );\n         }\n         else\n         {\n-            Page<K, V> page = children[pos].getValue( btree );\n+            Page<K, V> page = children[pos].getValue();\n \n             if ( page == null )\n             {\n@@ -941,11 +942,11 @@ public boolean contains( K key, V value ) throws IOException\n         {\n             // Here, if we have found the key in the node, then we must go down into\n             // the right child, not the left one\n-            return children[-pos].getValue( btree ).contains( key, value );\n+            return children[-pos].getValue().contains( key, value );\n         }\n         else\n         {\n-            return children[pos].getValue( btree ).contains( key, value );\n+            return children[pos].getValue().contains( key, value );\n         }\n     }\n \n@@ -956,7 +957,7 @@ public boolean contains( K key, V value ) throws IOException\n      * @param pos The position in the values array\n      * @param value the value to inject\n      */\n-    public void setValue( int pos, PageHolder<K, V> value )\n+    public void setValue( int pos, PersistedPageHolder<K, V> value )\n     {\n         children[pos] = value;\n     }\n@@ -969,7 +970,7 @@ public void setValue( int pos, PageHolder<K, V> value )\n     {\n         if ( pos < nbElems + 1 )\n         {\n-            return children[pos].getValue( btree );\n+            return children[pos].getValue();\n         }\n         else\n         {\n@@ -994,7 +995,7 @@ public void setValue( int pos, PageHolder<K, V> value )\n         // We first stack the current page\n         stack[depth++] = new ParentPos<K, V>( this, pos );\n         \n-        Page<K, V> page = children[pos].getValue( btree );\n+        Page<K, V> page = children[pos].getValue();\n \n         return page.browse( key, transaction, stack, depth );\n     }\n@@ -1008,7 +1009,7 @@ public void setValue( int pos, PageHolder<K, V> value )\n     {\n         stack[depth++] = new ParentPos<K, V>( this, 0 );\n         \n-        Page<K, V> page = children[0].getValue( btree );\n+        Page<K, V> page = children[0].getValue();\n \n         return page.browse( transaction, stack, depth );\n     }\n@@ -1053,9 +1054,9 @@ public void setValue( int pos, PageHolder<K, V> value )\n      * @return A holder contaning a reference to the child page\n      * @throws IOException If we have an error while trying to access the page\n      */\n-    private PageHolder<K, V> createHolder( Page<K, V> page ) throws IOException\n+    private PersistedPageHolder<K, V> createHolder( Page<K, V> page ) throws IOException\n     {\n-        PageHolder<K, V> holder = ((PersistedBTree<K, V>)btree).getRecordManager().writePage( btree,\n+        PersistedPageHolder<K, V> holder = ((PersistedBTree<K, V>)btree).getRecordManager().writePage( btree,\n             page,\n             revision );\n \n@@ -1257,20 +1258,7 @@ else if ( pos == middle )\n      */\n     public K getLeftMostKey()\n     {\n-        try\n-        {\n-            return children[0].getValue( btree ).getLeftMostKey();\n-        }\n-        catch ( EndOfFileExceededException eofe )\n-        {\n-            eofe.printStackTrace();\n-            return null;\n-        }\n-        catch ( IOException ioe )\n-        {\n-            ioe.printStackTrace();\n-            return null;\n-        }\n+        return children[0].getValue().getLeftMostKey();\n     }\n \n \n@@ -1281,25 +1269,12 @@ public K getRightMostKey()\n     {\n         int index = ( nbElems + 1 ) - 1;\n \n-        try\n-        {\n-            if ( children[index] != null )\n-            {\n-                return children[index].getValue( btree ).getRightMostKey();\n-            }\n-    \n-            return children[nbElems - 1].getValue( btree ).getRightMostKey();\n-        }\n-        catch ( EndOfFileExceededException eofe )\n-        {\n-            eofe.printStackTrace();\n-            return null;\n-        }\n-        catch ( IOException ioe )\n+        if ( children[index] != null )\n         {\n-            ioe.printStackTrace();\n-            return null;\n+            return children[index].getValue().getRightMostKey();\n         }\n+\n+        return children[nbElems - 1].getValue().getRightMostKey();\n     }\n \n \n@@ -1308,7 +1283,7 @@ public K getRightMostKey()\n      */\n     public Tuple<K, V> findLeftMost() throws EndOfFileExceededException, IOException\n     {\n-        return children[0].getValue( btree ).findLeftMost();\n+        return children[0].getValue().findLeftMost();\n     }\n \n \n@@ -1317,7 +1292,7 @@ public K getRightMostKey()\n      */\n     public Tuple<K, V> findRightMost() throws EndOfFileExceededException, IOException\n     {\n-        return children[nbElems].getValue( btree ).findRightMost();\n+        return children[nbElems].getValue().findRightMost();\n     }\n \n \n@@ -1332,39 +1307,32 @@ public String toString()\n         sb.append( super.toString() );\n         sb.append( \"] -> {\" );\n \n-        try\n+        if ( nbElems > 0 )\n         {\n-            if ( nbElems > 0 )\n+            // Start with the first child\n+            if ( children[0] == null )\n+            {\n+                sb.append( \"null\" );\n+            }\n+            else\n             {\n-                // Start with the first child\n-                if ( children[0] == null )\n+                sb.append( 'r' ).append( children[0].getValue().getRevision() );\n+            }\n+\n+            for ( int i = 0; i < nbElems; i++ )\n+            {\n+                sb.append( \"|<\" ).append( keys[i] ).append( \">|\" );\n+\n+                if ( children[i + 1] == null )\n                 {\n                     sb.append( \"null\" );\n                 }\n                 else\n                 {\n-                    sb.append( 'r' ).append( children[0].getValue( btree ).getRevision() );\n-                }\n-\n-                for ( int i = 0; i < nbElems; i++ )\n-                {\n-                    sb.append( \"|<\" ).append( keys[i] ).append( \">|\" );\n-\n-                    if ( children[i + 1] == null )\n-                    {\n-                        sb.append( \"null\" );\n-                    }\n-                    else\n-                    {\n-                        sb.append( 'r' ).append( children[i + 1].getValue( btree ).getRevision() );\n-                    }\n+                    sb.append( 'r' ).append( children[i + 1].getValue().getRevision() );\n                 }\n             }\n         }\n-        catch ( IOException ioe )\n-        {\n-            // Do nothing\n-        }\n \n         sb.append( \"}\" );\n \n@@ -1381,22 +1349,15 @@ public String dumpPage( String tabs )\n \n         if ( nbElems > 0 )\n         {\n-            try\n-            {\n-                // Start with the first child\n-                sb.append( children[0].getValue( btree ).dumpPage( tabs + \"    \" ) );\n+            // Start with the first child\n+            sb.append( children[0].getValue().dumpPage( tabs + \"    \" ) );\n \n-                for ( int i = 0; i < nbElems; i++ )\n-                {\n-                    sb.append( tabs );\n-                    sb.append( \"<\" );\n-                    sb.append( keys[i] ).append( \">\\n\" );\n-                    sb.append( children[i + 1].getValue( btree ).dumpPage( tabs + \"    \" ) );\n-                }\n-            }\n-            catch ( IOException ioe )\n+            for ( int i = 0; i < nbElems; i++ )\n             {\n-                // Do nothing\n+                sb.append( tabs );\n+                sb.append( \"<\" );\n+                sb.append( keys[i] ).append( \">\\n\" );\n+                sb.append( children[i + 1].getValue().dumpPage( tabs + \"    \" ) );\n             }\n         }\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/Node.java"}, {"additions": 13, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTree.java", "sha": "17d9460f3bd86d62ca7794d6fb6eabf66b5a229b", "changes": 25, "status": "modified", "deletions": 12, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTree.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -31,6 +31,7 @@\n import net.sf.ehcache.config.CacheConfiguration;\n \n import org.apache.directory.mavibot.btree.AbstractBTree;\n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTreeHeader;\n import org.apache.directory.mavibot.btree.DeleteResult;\n import org.apache.directory.mavibot.btree.InsertResult;\n@@ -125,7 +126,7 @@ public PersistedBTree( BTreeConfiguration<K, V> configuration )\n \n         // Create the first root page, with revision 0L. It will be empty\n         // and increment the revision at the same time\n-        rootPage = new Leaf<K, V>( this );\n+        rootPage = new PersistedLeaf<K, V>( this );\n         \n         if ( isSubBtree )\n         {\n@@ -237,7 +238,7 @@ public PersistedBTree( String name, String dataDir, ElementSerializer<K> keySeri\n \n         // Create the first root page, with revision 0L. It will be empty\n         // and increment the revision at the same time\n-        rootPage = new Leaf<K, V>( this );\n+        rootPage = new PersistedLeaf<K, V>( this );\n \n         // Now, call the init() method\n         init();\n@@ -440,16 +441,16 @@ public void close() throws IOException\n                 // Write the modified page on disk\n                 // Note that we don't use the holder, the new root page will\n                 // remain in memory.\n-                PageHolder<K, V> holder = recordManager.writePage( this, modifiedPage,\n+                PersistedPageHolder<K, V> holder = recordManager.writePage( this, modifiedPage,\n                     revision );\n \n                 // Store the offset on disk in the page in memory\n-                ( ( AbstractPersistedPage<K, V> ) modifiedPage ).setOffset( ( ( PageHolder<K, V> ) holder )\n+                ( ( AbstractPage<K, V> ) modifiedPage ).setOffset( ( ( PersistedPageHolder<K, V> ) holder )\n                     .getOffset() );\n \n                 // Store the last offset on disk in the page in memory\n-                ( ( AbstractPersistedPage<K, V> ) modifiedPage )\n-                    .setLastOffset( ( ( PageHolder<K, V> ) holder )\n+                ( ( AbstractPage<K, V> ) modifiedPage )\n+                    .setLastOffset( ( ( PersistedPageHolder<K, V> ) holder )\n                         .getLastOffset() );\n \n                 // This is a new root\n@@ -464,7 +465,7 @@ public void close() throws IOException\n \n                 // We have to update the rootPage on disk\n                 // Update the BTree header now\n-                recordManager.updateBtreeHeader( this, ( ( AbstractPersistedPage<K, V> ) rootPage ).getOffset() );\n+                recordManager.updateBtreeHeader( this, ( ( AbstractPage<K, V> ) rootPage ).getOffset() );\n             }\n \n             recordManager.addFreePages( this, result.getCopiedPages() );\n@@ -524,7 +525,7 @@ public void close() throws IOException\n             // Write the modified page on disk\n             // Note that we don't use the holder, the new root page will\n             // remain in memory.\n-            PageHolder<K, V> holder = recordManager.writePage( this, modifiedPage,\n+            PersistedPageHolder<K, V> holder = recordManager.writePage( this, modifiedPage,\n                 revision );\n             \n             // The root has just been modified, we haven't split it\n@@ -546,18 +547,18 @@ public void close() throws IOException\n \n             // If the BTree is managed, we have to write the two pages that were created\n             // and to keep a track of the two offsets for the upper node\n-            PageHolder<K, V> holderLeft = recordManager.writePage( this,\n+            PersistedPageHolder<K, V> holderLeft = recordManager.writePage( this,\n                 leftPage, revision );\n \n-            PageHolder<K, V> holderRight = recordManager.writePage( this,\n+            PersistedPageHolder<K, V> holderRight = recordManager.writePage( this,\n                 rightPage, revision );\n \n             // Create the new rootPage\n             newRootPage = new Node<K, V>( this, revision, pivot, holderLeft, holderRight );\n \n             // If the BTree is managed, we now have to write the page on disk\n             // and to add this page to the list of modified pages\n-            PageHolder<K, V> holder = recordManager\n+            PersistedPageHolder<K, V> holder = recordManager\n                 .writePage( this, newRootPage, revision );\n \n             rootPage = newRootPage;\n@@ -575,7 +576,7 @@ public void close() throws IOException\n         recordManager.updateRecordManagerHeader();\n \n         // Update the BTree header now\n-        recordManager.updateBtreeHeader( this, ( ( AbstractPersistedPage<K, V> ) rootPage ).getOffset() );\n+        recordManager.updateBtreeHeader( this, ( ( AbstractPage<K, V> ) rootPage ).getOffset() );\n \n         // Moved the free pages into the list of free pages\n         recordManager.addFreePages( this, result.getCopiedPages() );", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTree.java"}, {"additions": 12, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTreeBuilder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTreeBuilder.java", "sha": "8293bc2c4ba050f203894d8bcf56f70c44e05135", "changes": 23, "status": "modified", "deletions": 11, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTreeBuilder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -33,6 +33,7 @@\n import java.util.Iterator;\n import java.util.List;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n@@ -81,7 +82,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n \n         int totalTupleCount = 0;\n \n-        Leaf<K, V> leaf1 = createLeaf( btree, 0, numKeysInNode );\n+        PersistedLeaf<K, V> leaf1 = createLeaf( btree, 0, numKeysInNode );\n         lstLeaves.add( leaf1 );\n \n         int leafIndex = 0;\n@@ -90,7 +91,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n         {\n             Tuple<K, V> tuple = sortedTupleItr.next();\n             \n-            setKey( leaf1, leafIndex, tuple.getKey() );\n+            setKey( btree, leaf1, leafIndex, tuple.getKey() );\n \n             PersistedValueHolder<V> eh = new PersistedValueHolder<V>( btree, tuple.getValue() );\n \n@@ -102,7 +103,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n             {\n                 leafIndex = 0;\n                 \n-                PageHolder<K, V> pageHolder = ( PageHolder<K, V> ) rm.writePage( btree, leaf1, 1 );\n+                PersistedPageHolder<K, V> pageHolder = ( PersistedPageHolder<K, V> ) rm.writePage( btree, leaf1, 1 );\n                 \n                 leaf1 = createLeaf( btree, 0, numKeysInNode );\n                 lstLeaves.add( leaf1 );\n@@ -117,7 +118,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n         }\n \n         // remove null keys and values from the last leaf and resize\n-        Leaf<K, V> lastLeaf = ( Leaf<K, V> ) lstLeaves.get( lstLeaves.size() - 1 );\n+        PersistedLeaf<K, V> lastLeaf = ( PersistedLeaf<K, V> ) lstLeaves.get( lstLeaves.size() - 1 );\n         for ( int i = 0; i < lastLeaf.getNbElems(); i++ )\n         {\n             if ( lastLeaf.getKey( i ) == null )\n@@ -133,7 +134,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n                 lastLeaf.values = ( PersistedValueHolder<V>[] ) Array.newInstance( PersistedValueHolder.class, n );\n                 System.arraycopy( values, 0, lastLeaf.values, 0, n );\n \n-                PageHolder<K, V> pageHolder = ( PageHolder<K, V> ) rm.writePage( btree, lastLeaf, 1 );\n+                PersistedPageHolder<K, V> pageHolder = ( PersistedPageHolder<K, V> ) rm.writePage( btree, lastLeaf, 1 );\n \n                 break;\n             }\n@@ -146,7 +147,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n         //System.out.println(\"built rootpage : \" + rootPage);\n         ((PersistedBTree<K, V>)btree).setNbElems( totalTupleCount );\n         \n-        rm.updateBtreeHeader( btree, ( ( AbstractPersistedPage<K, V> ) rootPage ).getOffset() );\n+        rm.updateBtreeHeader( btree, ( ( AbstractPage<K, V> ) rootPage ).getOffset() );\n         \n         rm.addFreePages( btree, Arrays.asList( btree.getRootPage() ) );\n         \n@@ -177,10 +178,10 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n         {\n             if ( i != 0 )\n             {\n-                setKey( node, i - 1, page.getLeftMostKey() );\n+                setKey( btree, node, i - 1, page.getLeftMostKey() );\n             }\n \n-            node.children[i] = new PageHolder<K, V>( btree, page );\n+            node.children[i] = new PersistedPageHolder<K, V>( btree, page );\n \n             i++;\n             totalNodes++;\n@@ -189,15 +190,15 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n             {\n                 i = 0;\n                 \n-                PageHolder<K, V> pageHolder = ( PageHolder<K, V> ) rm.writePage( btree, node, 1 );\n+                PersistedPageHolder<K, V> pageHolder = ( PersistedPageHolder<K, V> ) rm.writePage( btree, node, 1 );\n \n                 node = createNode( btree, 0, numKeysInNode );\n                 lstNodes.add( node );\n             }\n         }\n \n         // remove null keys and values from the last node and resize\n-        AbstractPersistedPage<K, V> lastNode = ( AbstractPersistedPage<K, V> ) lstNodes.get( lstNodes.size() - 1 );\n+        AbstractPage<K, V> lastNode = ( AbstractPage<K, V> ) lstNodes.get( lstNodes.size() - 1 );\n \n         for ( int j = 0; j < lastNode.getNbElems(); j++ )\n         {\n@@ -210,7 +211,7 @@ public PersistedBTreeBuilder( RecordManager rm, String name, int numKeysInNode,\n                 lastNode.setKeys( ( KeyHolder[] ) Array.newInstance( KeyHolder.class, n ) );\n                 System.arraycopy( keys, 0, lastNode.getKeys(), 0, n );\n \n-                PageHolder<K, V> pageHolder = ( PageHolder<K, V> ) rm.writePage( btree, lastNode, 1 );\n+                PersistedPageHolder<K, V> pageHolder = ( PersistedPageHolder<K, V> ) rm.writePage( btree, lastNode, 1 );\n \n                 break;\n             }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedBTreeBuilder.java"}, {"additions": 27, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedLeaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedLeaf.java", "previous_filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/Leaf.java", "sha": "6f03c512d9cdf607de3daf40104d995ac9046129", "changes": 54, "status": "renamed", "deletions": 27, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedLeaf.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -23,6 +23,7 @@\n import java.io.IOException;\n import java.lang.reflect.Array;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.BorrowedFromLeftResult;\n import org.apache.directory.mavibot.btree.BorrowedFromRightResult;\n@@ -52,7 +53,7 @@\n  *\n  * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n  */\n-/* No qualifier */class Leaf<K, V> extends AbstractPersistedPage<K, V>\n+/* No qualifier */class PersistedLeaf<K, V> extends AbstractPage<K, V>\n {\n     /** Values associated with keys */\n     protected ValueHolder<V>[] values;\n@@ -63,7 +64,7 @@\n      * \n      * @param btree The BTree this page belongs to.\n      */\n-    /* No qualifier */Leaf( BTree<K, V> btree )\n+    PersistedLeaf( BTree<K, V> btree )\n     {\n         super( btree );\n     }\n@@ -77,8 +78,7 @@\n      * @param nbElems The number of elements this page will contain\n      */\n     @SuppressWarnings(\"unchecked\")\n-    // Cannot create an array of generic objects\n-    /* No qualifier */Leaf( BTree<K, V> btree, long revision, int nbElems )\n+    PersistedLeaf( BTree<K, V> btree, long revision, int nbElems )\n     {\n         super( btree, revision, nbElems );\n         values = ( ValueHolder<V>[] ) Array.newInstance( PersistedValueHolder.class, nbElems );\n@@ -182,17 +182,17 @@\n             }\n         }\n \n-        Leaf<K, V> newLeaf = null;\n+        PersistedLeaf<K, V> newLeaf = null;\n \n         if ( keyRemoved )\n         {\n             // No value, we can remove the key\n-            newLeaf = new Leaf<K, V>( btree, revision, nbElems - 1 );\n+            newLeaf = new PersistedLeaf<K, V>( btree, revision, nbElems - 1 );\n         }\n         else\n         {\n             // Copy the page as we will delete a value from a ValueHolder\n-            newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+            newLeaf = new PersistedLeaf<K, V>( btree, revision, nbElems );\n         }\n \n         // Create the result\n@@ -222,7 +222,7 @@ else if ( keyRemoved )\n                 // Check in both next and previous page, if they have the same parent\n                 // and select the biggest page with the same parent to borrow an element.\n                 int siblingPos = selectSibling( ( Node<K, V> ) parent, parentPos );\n-                Leaf<K, V> sibling = ( Leaf<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos].getValue( btree ) );\n+                PersistedLeaf<K, V> sibling = ( PersistedLeaf<K, V> ) ( ( ( Node<K, V> ) parent ).children[siblingPos].getValue() );\n \n                 if ( sibling.getNbElems() == halfSize )\n                 {\n@@ -303,13 +303,13 @@ else if ( keyRemoved )\n      * @return The new created leaf containing the sibling and the old page.\n      * @throws IOException If we have an error while trying to access the page\n      */\n-    private DeleteResult<K, V> mergeWithSibling( Tuple<K, V> removedElement, long revision, Leaf<K, V> sibling,\n+    private DeleteResult<K, V> mergeWithSibling( Tuple<K, V> removedElement, long revision, PersistedLeaf<K, V> sibling,\n         boolean isLeft, int pos )\n         throws EndOfFileExceededException, IOException\n     {\n         // Create the new page. It will contain N - 1 elements (the maximum number)\n         // as we merge two pages that contain N/2 elements minus the one we remove\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, btree.getPageSize() - 1 );\n+        PersistedLeaf<K, V> newLeaf = new PersistedLeaf<K, V>( btree, revision, btree.getPageSize() - 1 );\n \n         if ( isLeft )\n         {\n@@ -364,19 +364,19 @@ else if ( keyRemoved )\n      * @return The resulting pages\n      * @throws IOException If we have an error while trying to access the page \n      */\n-    private DeleteResult<K, V> borrowFromLeft( Tuple<K, V> removedElement, long revision, Leaf<K, V> sibling, int pos )\n+    private DeleteResult<K, V> borrowFromLeft( Tuple<K, V> removedElement, long revision, PersistedLeaf<K, V> sibling, int pos )\n         throws IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n         K siblingKey = sibling.keys[sibling.getNbElems() - 1].getKey();\n         ValueHolder<V> siblingValue = sibling.values[sibling.getNbElems() - 1];\n \n         // Create the new sibling, with one less element at the end\n-        Leaf<K, V> newSibling = ( Leaf<K, V> ) sibling.copy( revision, sibling.getNbElems() - 1 );\n+        PersistedLeaf<K, V> newSibling = ( PersistedLeaf<K, V> ) sibling.copy( revision, sibling.getNbElems() - 1 );\n \n         // Create the new page and add the new element at the beginning\n         // First copy the current page, with the same size\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+        PersistedLeaf<K, V> newLeaf = new PersistedLeaf<K, V>( btree, revision, nbElems );\n \n         // Insert the borrowed element\n         newLeaf.keys[0] = new PersistedKeyHolder<K>( btree.getKeySerializer(), siblingKey );\n@@ -411,23 +411,23 @@ else if ( keyRemoved )\n      * @return The resulting pages\n      * @throws IOException If we have an error while trying to access the page \n      */\n-    private DeleteResult<K, V> borrowFromRight( Tuple<K, V> removedElement, long revision, Leaf<K, V> sibling, int pos )\n+    private DeleteResult<K, V> borrowFromRight( Tuple<K, V> removedElement, long revision, PersistedLeaf<K, V> sibling, int pos )\n         throws IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n         K siblingKey = sibling.keys[0].getKey();\n         ValueHolder<V> siblingHolder = sibling.values[0];\n \n         // Create the new sibling\n-        Leaf<K, V> newSibling = new Leaf<K, V>( btree, revision, sibling.getNbElems() - 1 );\n+        PersistedLeaf<K, V> newSibling = new PersistedLeaf<K, V>( btree, revision, sibling.getNbElems() - 1 );\n \n         // Copy the keys and the values from 1 to N in the new sibling\n         System.arraycopy( sibling.keys, 1, newSibling.keys, 0, sibling.nbElems - 1 );\n         System.arraycopy( sibling.values, 1, newSibling.values, 0, sibling.nbElems - 1 );\n \n         // Create the new page and add the new element at the end\n         // First copy the current page, with the same size\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+        PersistedLeaf<K, V> newLeaf = new PersistedLeaf<K, V>( btree, revision, nbElems );\n \n         // Insert the borrowed element at the end\n         newLeaf.keys[nbElems - 1] = new PersistedKeyHolder<K>( btree.getKeySerializer(), siblingKey );\n@@ -459,7 +459,7 @@ else if ( keyRemoved )\n      * @param pos The position into the page of the element to remove\n      * @throws IOException If we have an error while trying to access the page\n      */\n-    private void copyAfterRemovingElement( boolean keyRemoved, V removedValue, Leaf<K, V> newLeaf, int pos ) throws IOException\n+    private void copyAfterRemovingElement( boolean keyRemoved, V removedValue, PersistedLeaf<K, V> newLeaf, int pos ) throws IOException\n     {\n         if ( keyRemoved )\n         {\n@@ -752,7 +752,7 @@ else if ( nbElems > 0 )\n      */\n     private Page<K, V> copy( long revision, int nbElems )\n     {\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems );\n+        PersistedLeaf<K, V> newLeaf = new PersistedLeaf<K, V>( btree, revision, nbElems );\n \n         // Copy the keys and the values\n         System.arraycopy( keys, 0, newLeaf.keys, 0, nbElems );\n@@ -797,12 +797,12 @@ else if ( nbElems > 0 )\n     private InsertResult<K, V> replaceElement( long revision, K key, V value, int pos )\n         throws IOException\n     {\n-        Leaf<K, V> newLeaf = this;\n+        PersistedLeaf<K, V> newLeaf = this;\n \n         if ( this.revision != revision )\n         {\n             // The page hasn't been modified yet, we need to copy it first\n-            newLeaf = ( Leaf<K, V> ) copy( revision, nbElems );\n+            newLeaf = ( PersistedLeaf<K, V> ) copy( revision, nbElems );\n         }\n \n         // Get the previous value from the leaf (it's a copy)\n@@ -844,7 +844,7 @@ else if ( nbElems > 0 )\n     private Page<K, V> addElement( long revision, K key, V value, int pos )\n     {\n         // First copy the current page, but add one element in the copied page\n-        Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems + 1 );\n+        PersistedLeaf<K, V> newLeaf = new PersistedLeaf<K, V>( btree, revision, nbElems + 1 );\n \n         // Create the value holder\n         ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, value );\n@@ -893,15 +893,15 @@ else if ( nbElems > 0 )\n     private InsertResult<K, V> addAndSplit( long revision, K key, V value, int pos )\n     {\n         int middle = btree.getPageSize() >> 1;\n-        Leaf<K, V> leftLeaf = null;\n-        Leaf<K, V> rightLeaf = null;\n+        PersistedLeaf<K, V> leftLeaf = null;\n+        PersistedLeaf<K, V> rightLeaf = null;\n         ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, value );\n \n         // Determinate where to store the new value\n         if ( pos <= middle )\n         {\n             // The left page will contain the new value\n-            leftLeaf = new Leaf<K, V>( btree, revision, middle + 1 );\n+            leftLeaf = new PersistedLeaf<K, V>( btree, revision, middle + 1 );\n \n             // Copy the keys and the values up to the insertion position\n             System.arraycopy( keys, 0, leftLeaf.keys, 0, pos );\n@@ -916,7 +916,7 @@ else if ( nbElems > 0 )\n             System.arraycopy( values, pos, leftLeaf.values, pos + 1, middle - pos );\n \n             // Now, create the right page\n-            rightLeaf = new Leaf<K, V>( btree, revision, middle );\n+            rightLeaf = new PersistedLeaf<K, V>( btree, revision, middle );\n \n             // Copy the keys and the values in the right page\n             System.arraycopy( keys, middle, rightLeaf.keys, 0, middle );\n@@ -925,14 +925,14 @@ else if ( nbElems > 0 )\n         else\n         {\n             // Create the left page\n-            leftLeaf = new Leaf<K, V>( btree, revision, middle );\n+            leftLeaf = new PersistedLeaf<K, V>( btree, revision, middle );\n \n             // Copy all the element into the left page\n             System.arraycopy( keys, 0, leftLeaf.keys, 0, middle );\n             System.arraycopy( values, 0, leftLeaf.values, 0, middle );\n \n             // Now, create the right page\n-            rightLeaf = new Leaf<K, V>( btree, revision, middle + 1 );\n+            rightLeaf = new PersistedLeaf<K, V>( btree, revision, middle + 1 );\n \n             int rightPos = pos - middle;\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedLeaf.java"}, {"additions": 56, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedPageHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedPageHolder.java", "previous_filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PageHolder.java", "sha": "bd378547730787e31595d4d5a313304ab8a12604", "changes": 100, "status": "renamed", "deletions": 44, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedPageHolder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -22,10 +22,13 @@\n \n import java.io.IOException;\n \n+import net.sf.ehcache.Cache;\n import net.sf.ehcache.Element;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.Page;\n+import org.apache.directory.mavibot.btree.PageHolder;\n import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n \n \n@@ -40,10 +43,13 @@\n  *\n  * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n  */\n-public class PageHolder<K, V>\n+public class PersistedPageHolder<K, V> extends PageHolder<K, V>\n {\n-    /** The BTree */\n-    private BTree<K, V> btree;\n+    /** The RecordManager */\n+    private RecordManager recordManager;\n+    \n+    /** The cache */\n+    private  Cache cache;\n \n     /** The offset of the first {@link PageIO} storing the page on disk */\n     private long offset;\n@@ -57,19 +63,21 @@\n      * \n      * @param page The element to store into a SoftReference\n      */\n-    public PageHolder( BTree<K, V> btree, Page<K, V> page )\n+    public PersistedPageHolder( BTree<K, V> btree, Page<K, V> page )\n     {\n-        this.btree = btree;\n-        this.offset = page.getOffset();\n-        this.lastOffset = page.getLastOffset();\n+        super( btree, page );\n+        cache = ((PersistedBTree<K, V>)btree).getCache();\n+        recordManager = ((PersistedBTree<K, V>)btree).getRecordManager();\n+        offset = page.getOffset();\n+        lastOffset = page.getLastOffset();\n \n         if ( page instanceof Page<?, ?> )\n         {\n-            ( ( AbstractPersistedPage<K, V> ) page ).setOffset( offset );\n-            ( ( AbstractPersistedPage<K, V> ) page ).setLastOffset( lastOffset );\n+            ( ( AbstractPage<K, V> ) page ).setOffset( offset );\n+            ( ( AbstractPage<K, V> ) page ).setLastOffset( lastOffset );\n         }\n \n-        ((PersistedBTree<K, V>)btree).getCache().put( new Element( offset, page ) );\n+        cache.put( new Element( offset, page ) );\n     }\n \n \n@@ -78,19 +86,21 @@ public PageHolder( BTree<K, V> btree, Page<K, V> page )\n      * \n      * @param page The element to store into a SoftReference\n      */\n-    public PageHolder( BTree<K, V> btree, Page<K, V> page, long offset, long lastOffset )\n+    public PersistedPageHolder( BTree<K, V> btree, Page<K, V> page, long offset, long lastOffset )\n     {\n-        this.btree = btree;\n+        super( btree, page );\n+        cache = ((PersistedBTree<K, V>)btree).getCache();\n+        recordManager = ((PersistedBTree<K, V>)btree).getRecordManager();\n         this.offset = offset;\n         this.lastOffset = lastOffset;\n \n         if ( page instanceof Page<?, ?> )\n         {\n-            ( ( AbstractPersistedPage<K, V> ) page ).setOffset( offset );\n-            ( ( AbstractPersistedPage<K, V> ) page ).setLastOffset( lastOffset );\n+            ( ( AbstractPage<K, V> ) page ).setOffset( offset );\n+            ( ( AbstractPage<K, V> ) page ).setLastOffset( lastOffset );\n         }\n \n-        ((PersistedBTree<K, V>)btree).getCache().put( new Element( offset, page ) );\n+        cache.put( new Element( offset, page ) );\n     }\n \n \n@@ -99,17 +109,17 @@ public PageHolder( BTree<K, V> btree, Page<K, V> page, long offset, long lastOff\n      * @throws IOException \n      * @throws EndOfFileExceededException \n      */\n-    public Page<K, V> getValue( BTree<K, V> btree ) throws EndOfFileExceededException, IOException\n+    public Page<K, V> getValue()\n     {\n-        Element element = ((PersistedBTree<K, V>)btree).getCache().get( offset );\n+        Element element = cache.get( offset );\n \n         if ( element == null )\n         {\n             // We haven't found the element in the cache, reload it\n             // We have to fetch the element from disk, using the offset now\n-            Page<K, V> page = fetchElement( btree );\n+            Page<K, V> page = fetchElement();\n \n-            ((PersistedBTree<K, V>)btree).getCache().put( new Element( offset, page ) );\n+            cache.put( new Element( offset, page ) );\n \n             return page;\n         }\n@@ -119,15 +129,15 @@ public PageHolder( BTree<K, V> btree, Page<K, V> page, long offset, long lastOff\n         if ( page == null )\n         {\n             // We have to fetch the element from disk, using the offset now\n-            page = fetchElement( btree );\n+            page = fetchElement();\n \n             if ( page instanceof Page<?, ?> )\n             {\n-                ( ( AbstractPersistedPage<K, V> ) page ).setOffset( offset );\n-                ( ( AbstractPersistedPage<K, V> ) page ).setLastOffset( lastOffset );\n+                ( ( AbstractPage<K, V> ) page ).setOffset( offset );\n+                ( ( AbstractPage<K, V> ) page ).setLastOffset( lastOffset );\n             }\n \n-            ((PersistedBTree<K, V>)btree).getCache().put( new Element( offset, page ) );\n+            cache.put( new Element( offset, page ) );\n         }\n \n         return page;\n@@ -137,14 +147,23 @@ public PageHolder( BTree<K, V> btree, Page<K, V> page, long offset, long lastOff\n     /**\n      * Retrieve the value from the disk, using the BTree and offset\n      * @return The deserialized element (\n-     * @throws IOException \n-     * @throws EndOfFileExceededException \n      */\n-    private Page<K, V> fetchElement( BTree<K, V> btree ) throws EndOfFileExceededException, IOException\n+    private Page<K, V> fetchElement()\n     {\n-        Page<K, V> element = ((PersistedBTree<K, V>)btree).getRecordManager().deserialize( btree, offset );\n-\n-        return element;\n+        try\n+        {\n+            Page<K, V> element = recordManager.deserialize( btree, offset );\n+    \n+            return element;\n+        }\n+        catch ( EndOfFileExceededException eofee )\n+        {\n+            throw new RuntimeException( eofee.getMessage() );\n+        }\n+        catch ( IOException ioe )\n+        {\n+            throw new RuntimeException( ioe.getMessage() );\n+        }\n     }\n \n \n@@ -173,24 +192,17 @@ public String toString()\n     {\n         StringBuilder sb = new StringBuilder();\n \n-        try\n-        {\n-            Page<K, V> page = getValue( btree );\n+        Page<K, V> page = getValue();\n \n-            if ( page != null )\n-            {\n-                sb.append( btree.getName() ).append( \"[\" ).append( offset ).append( \", \" ).append( lastOffset )\n-                    .append( \"]:\" ).append( page );\n-            }\n-            else\n-            {\n-                sb.append( btree.getName() ).append( \"[\" ).append( offset ).append( \", \" ).append( lastOffset )\n-                    .append( \"]\" );\n-            }\n+        if ( page != null )\n+        {\n+            sb.append( btree.getName() ).append( \"[\" ).append( offset ).append( \", \" ).append( lastOffset )\n+                .append( \"]:\" ).append( page );\n         }\n-        catch ( IOException ioe )\n+        else\n         {\n-            // Nothing we can do...\n+            sb.append( btree.getName() ).append( \"[\" ).append( offset ).append( \", \" ).append( lastOffset )\n+                .append( \"]\" );\n         }\n \n         return sb.toString();", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedPageHolder.java"}, {"additions": 1, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedValueHolder.java", "sha": "72be00a247818b2fbef86f8515999619d2009f8b", "changes": 2, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedValueHolder.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -76,7 +76,7 @@\n \n         // We create the array of values if they fit in an array. If they are stored in a \n         // BTree, we do nothing atm.\n-        if ( nbValues <= PersistedBTree.valueThresholdUp )\n+        if ( nbValues <= valueThresholdUp )\n         {\n             // The values are contained into an array\n             valueArray = ( V[] ) Array.newInstance( valueSerializer.getType(), nbValues );", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/PersistedValueHolder.java"}, {"additions": 19, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/RecordManager.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/RecordManager.java", "sha": "68852112421a90891138a2c42d33a67282653604", "changes": 34, "status": "modified", "deletions": 15, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/RecordManager.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -33,6 +33,7 @@\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import org.apache.directory.mavibot.btree.AbstractPage;\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n@@ -389,6 +390,7 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n             {\n                 // Create the BTree\n                 BTree<Object, Object> btree = BTreeFactory.createBTree();\n+                ((PersistedBTree<Object, Object>)btree).setRecordManager( this );\n                 ((PersistedBTree<Object, Object>)btree).setBtreeOffset( nextBtreeOffset );\n                 lastAddedBTreeOffset = nextBtreeOffset;\n \n@@ -537,6 +539,8 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n \n         // Now, init the BTree\n         btree.init();\n+        \n+        ((PersistedBTree<K, V>)btree).setRecordManager( this );\n \n         // Now, load the rootPage, which can be a Leaf or a Node, depending \n         // on the number of elements in the tree : if it's above the pageSize,\n@@ -570,8 +574,8 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n \n         Page<K, V> page = readPage( btree, rootPageIos );\n \n-        ( ( AbstractPersistedPage<K, V> ) page ).setOffset( rootPageIos[0].getOffset() );\n-        ( ( AbstractPersistedPage<K, V> ) page ).setLastOffset( rootPageIos[rootPageIos.length - 1].getOffset() );\n+        ( ( AbstractPage<K, V> ) page ).setOffset( rootPageIos[0].getOffset() );\n+        ( ( AbstractPage<K, V> ) page ).setLastOffset( rootPageIos[rootPageIos.length - 1].getOffset() );\n \n         return page;\n     }\n@@ -619,11 +623,11 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n     /**\n      * Deserialize a Leaf from some PageIOs\n      */\n-    private <K, V> Leaf<K, V> readLeafKeysAndValues( BTree<K, V> btree, int nbElems, long revision, ByteBuffer byteBuffer,\n+    private <K, V> PersistedLeaf<K, V> readLeafKeysAndValues( BTree<K, V> btree, int nbElems, long revision, ByteBuffer byteBuffer,\n         PageIO[] pageIos )\n     {\n         // Its a leaf, create it\n-        Leaf<K, V> leaf = BTreeFactory.createLeaf( btree, revision, nbElems );\n+        PersistedLeaf<K, V> leaf = BTreeFactory.createLeaf( btree, revision, nbElems );\n \n         // Store the page offset on disk\n         leaf.setOffset( pageIos[0].getOffset() );\n@@ -666,7 +670,7 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n             keyLengths[i] = byteBuffer.getInt();\n             byte[] data = new byte[keyLengths[i]];\n             byteBuffer.get( data );\n-            BTreeFactory.setKey( leaf, i, data );\n+            BTreeFactory.setKey( btree, leaf, i, data );\n         }\n \n         return leaf;\n@@ -688,7 +692,7 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n             long offset = OFFSET_SERIALIZER.deserialize( byteBuffer );\n             long lastOffset = OFFSET_SERIALIZER.deserialize( byteBuffer );\n \n-            PageHolder<K, V> valueHolder = new PageHolder<K, V>( btree, null, offset, lastOffset );\n+            PersistedPageHolder<K, V> valueHolder = new PersistedPageHolder<K, V>( btree, null, offset, lastOffset );\n             node.setValue( i, valueHolder );\n \n             // Read the key length\n@@ -702,14 +706,14 @@ private void loadRecordManager() throws IOException, ClassNotFoundException, Ill\n             // Set the new position now\n             byteBuffer.position( currentPosition + keyLength );\n             \n-            BTreeFactory.setKey( node, i, key );\n+            BTreeFactory.setKey( btree, node, i, key );\n         }\n \n         // and read the last value, as it's a node\n         long offset = OFFSET_SERIALIZER.deserialize( byteBuffer );\n         long lastOffset = OFFSET_SERIALIZER.deserialize( byteBuffer );\n \n-        PageHolder<K, V> valueHolder = new PageHolder<K, V>( btree, null, offset, lastOffset );\n+        PersistedPageHolder<K, V> valueHolder = new PersistedPageHolder<K, V>( btree, null, offset, lastOffset );\n         node.setValue( nbElems, valueHolder );\n \n         return node;\n@@ -1073,7 +1077,7 @@ private long readLong( PageIO[] pageIos, long position )\n         // Now, we can inject the BTree rootPage offset into the BTree header\n         position = store( position, rootPageIo.getOffset(), pageIos );\n         ((PersistedBTree<K, V>)btree).setRootPageOffset( rootPageIo.getOffset() );\n-        ( ( Leaf<K, V> ) rootPage ).setOffset( rootPageIo.getOffset() );\n+        ( ( PersistedLeaf<K, V> ) rootPage ).setOffset( rootPageIo.getOffset() );\n \n         // The next BTree Header offset (-1L, as it's a new BTree)\n         position = store( position, NO_PAGE, pageIos );\n@@ -1202,8 +1206,8 @@ private long readLong( PageIO[] pageIos, long position )\n                 }\n                 else\n                 {\n-                    dataSize += serializeLeafValue( ( Leaf<K, V> ) page, pos, serializedData );\n-                    dataSize += serializeLeafKey( ( Leaf<K, V> ) page, pos, serializedData );\n+                    dataSize += serializeLeafValue( ( PersistedLeaf<K, V> ) page, pos, serializedData );\n+                    dataSize += serializeLeafKey( ( PersistedLeaf<K, V> ) page, pos, serializedData );\n                 }\n             }\n \n@@ -1281,7 +1285,7 @@ private long readLong( PageIO[] pageIos, long position )\n     /**\n      * Serialize a Leaf's key\n      */\n-    private <K, V> int serializeLeafKey( Leaf<K, V> leaf, int pos, List<byte[]> serializedData )\n+    private <K, V> int serializeLeafKey( PersistedLeaf<K, V> leaf, int pos, List<byte[]> serializedData )\n     {\n         int dataSize = 0;\n         KeyHolder<K> keyHolder = leaf.getKeyHolder( pos );\n@@ -1310,7 +1314,7 @@ private long readLong( PageIO[] pageIos, long position )\n     /**\n      * Serialize a Leaf's Value. We store \n      */\n-    private <K, V> int serializeLeafValue( Leaf<K, V> leaf, int pos, List<byte[]> serializedData )\n+    private <K, V> int serializeLeafValue( PersistedLeaf<K, V> leaf, int pos, List<byte[]> serializedData )\n         throws IOException\n     {\n         // The value can be an Array or a sub-btree, but we don't care\n@@ -1916,7 +1920,7 @@ private long store( long position, long value, PageIO... pageIos )\n      * @return The offset of the new page\n      * @throws IOException \n      */\n-    /* No qualifier*/<K, V> PageHolder<K, V> writePage( BTree<K, V> btree, Page<K, V> newPage,\n+    /* No qualifier*/<K, V> PersistedPageHolder<K, V> writePage( BTree<K, V> btree, Page<K, V> newPage,\n         long newRevision )\n         throws IOException\n     {\n@@ -1931,7 +1935,7 @@ private long store( long position, long value, PageIO... pageIos )\n         // Build the resulting reference\n         long offset = pageIos[0].getOffset();\n         long lastOffset = pageIos[pageIos.length - 1].getOffset();\n-        PageHolder<K, V> valueHolder = new PageHolder<K, V>( btree, newPage, offset,\n+        PersistedPageHolder<K, V> valueHolder = new PersistedPageHolder<K, V>( btree, newPage, offset,\n             lastOffset );\n \n         if ( LOG_CHECK.isDebugEnabled() )", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/RecordManager.java"}, {"additions": 21, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/TupleCursorImpl.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/TupleCursorImpl.java", "sha": "7ec42e1516d144dd081c88c52f1d4c1fe2260f5e", "changes": 43, "status": "modified", "deletions": 22, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/TupleCursorImpl.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -29,7 +29,6 @@\n import org.apache.directory.mavibot.btree.ParentPos;\n import org.apache.directory.mavibot.btree.Transaction;\n import org.apache.directory.mavibot.btree.Tuple;\n-import org.apache.directory.mavibot.btree.TupleCursor;\n import org.apache.directory.mavibot.btree.ValueHolder;\n import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n \n@@ -130,7 +129,7 @@\n \n             try\n             {\n-                ValueHolder<V> valueHolder = ( ( Leaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n+                ValueHolder<V> valueHolder = ( ( PersistedLeaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n                 \n                 parentPos.valueCursor = valueHolder.getCursor();\n                 \n@@ -142,7 +141,7 @@\n             }\n         }\n         \n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( parentPos.page );\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n         tuple.setValue( value );\n \n@@ -184,7 +183,7 @@\n             {\n                 // We can pick the next element at this level\n                 parentPos.pos++;\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos].getValue( btree );\n+                child = ((Node<K, V>)parentPos.page).children[parentPos.pos].getValue();\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n@@ -193,14 +192,14 @@\n                     parentPos = stack[currentDepth];\n                     parentPos.pos = 0;\n                     parentPos.page = child;\n-                    child = ((Node<K, V>)child).children[0].getValue( btree );\n+                    child = ((Node<K, V>)child).children[0].getValue();\n                 }\n \n                 // and the leaf\n                 parentPos = stack[depth];\n                 parentPos.page = child;\n                 parentPos.pos = 0;\n-                parentPos.valueCursor = ((Leaf<K, V>)child).values[0].getCursor();\n+                parentPos.valueCursor = ((PersistedLeaf<K, V>)child).values[0].getCursor();\n \n                 return parentPos;\n             }\n@@ -243,13 +242,13 @@ private boolean hasNextParentPos() throws EndOfFileExceededException, IOExceptio\n             else\n             {\n                 // We can pick the next element at this level\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos + 1].getValue( btree );\n+                child = ((Node<K, V>)parentPos.page).children[parentPos.pos + 1].getValue();\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n                 {\n                     currentDepth++;\n-                    child = ((Node<K, V>)child).children[0].getValue( btree );\n+                    child = ((Node<K, V>)child).children[0].getValue();\n                 }\n \n                 return true;\n@@ -293,13 +292,13 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n             else\n             {\n                 // We can pick the previous element at this level\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos - 1].getValue( btree );\n+                child = ((Node<K, V>)parentPos.page).children[parentPos.pos - 1].getValue();\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n                 {\n                     currentDepth++;\n-                    child = ((Node<K, V>)child).children[child.getNbElems()].getValue( btree );\n+                    child = ((Node<K, V>)child).children[child.getNbElems()].getValue();\n                 }\n \n                 return true;\n@@ -344,7 +343,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n             {\n                 // We can pick the next element at this level\n                 parentPos.pos--;\n-                child = ((Node<K, V>)parentPos.page).children[parentPos.pos].getValue( btree );\n+                child = ((Node<K, V>)parentPos.page).children[parentPos.pos].getValue();\n                 \n                 // and go down the tree through the nodes\n                 while ( currentDepth < depth - 1 )\n@@ -353,14 +352,14 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n                     parentPos = stack[currentDepth];\n                     parentPos.pos = child.getNbElems();\n                     parentPos.page = child;\n-                    child = ((Node<K, V>)parentPos.page).children[parentPos.page.getNbElems()].getValue( btree );\n+                    child = ((Node<K, V>)parentPos.page).children[parentPos.page.getNbElems()].getValue();\n                 }\n \n                 // and the leaf\n                 parentPos = stack[depth];\n                 parentPos.pos = child.getNbElems() - 1;\n                 parentPos.page = child;\n-                ValueHolder<V> valueHolder = ((Leaf<K, V>)parentPos.page).values[parentPos.pos];\n+                ValueHolder<V> valueHolder = ((PersistedLeaf<K, V>)parentPos.page).values[parentPos.pos];\n                 parentPos.valueCursor = valueHolder.getCursor();\n                 parentPos.valueCursor.afterLast();\n \n@@ -436,7 +435,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n                 \n                 try\n                 {\n-                    ValueHolder<V> valueHolder = ( ( Leaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n+                    ValueHolder<V> valueHolder = ( ( PersistedLeaf<K, V> ) parentPos.page ).getValue( parentPos.pos );\n                     \n                     parentPos.valueCursor = valueHolder.getCursor();\n                     parentPos.valueCursor.afterLast();\n@@ -451,7 +450,7 @@ private boolean hasPrevParentPos() throws EndOfFileExceededException, IOExceptio\n         }\n \n \n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( parentPos.page );\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n         tuple.setValue( value );\n \n@@ -649,7 +648,7 @@ public boolean hasNextKey() throws EndOfFileExceededException, IOException\n             if ( ( newParentPos == null ) || ( newParentPos.page == null ) )\n             {\n                 // This is the end : no more value\n-                Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+                PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( parentPos.page );\n                 ValueHolder<V> valueHolder = leaf.values[parentPos.pos];\n                 parentPos.pos = AFTER_LAST;\n                 parentPos.valueCursor = valueHolder.getCursor();\n@@ -669,7 +668,7 @@ public boolean hasNextKey() throws EndOfFileExceededException, IOException\n         }\n \n         // The key\n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( parentPos.page );\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n         \n         // The value\n@@ -760,7 +759,7 @@ public boolean hasPrevKey() throws EndOfFileExceededException, IOException\n         }\n         \n         // Update the Tuple \n-        Leaf<K, V> leaf = ( Leaf<K, V> ) ( parentPos.page );\n+        PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) ( parentPos.page );\n \n         // The key\n         tuple.setKey( leaf.getKey( parentPos.pos ) );\n@@ -798,7 +797,7 @@ public void beforeFirst() throws IOException\n                 parentPos.page = child;\n             }\n \n-            child = ((Node<K, V>)parentPos.page).children[0].getValue( btree );\n+            child = ((Node<K, V>)parentPos.page).children[0].getValue();\n         }\n \n         // and leaf\n@@ -812,7 +811,7 @@ public void beforeFirst() throws IOException\n         \n         if ( parentPos.valueCursor != null )\n         {\n-            parentPos.valueCursor = ((Leaf<K, V>)parentPos.page).values[0].getCursor();\n+            parentPos.valueCursor = ((PersistedLeaf<K, V>)parentPos.page).values[0].getCursor();\n             parentPos.valueCursor.beforeFirst();\n         }\n     }\n@@ -846,7 +845,7 @@ public void afterLast() throws IOException\n                 parentPos.pos = parentPos.page.getNbElems();\n             }\n \n-            child = ((Node<K, V>)parentPos.page).children[parentPos.pos].getValue( btree );\n+            child = ((Node<K, V>)parentPos.page).children[parentPos.pos].getValue();\n         }\n         \n         // and leaf\n@@ -862,7 +861,7 @@ public void afterLast() throws IOException\n             parentPos.pos = child.getNbElems() - 1;\n         }\n \n-        parentPos.valueCursor = ((Leaf<K, V>)parentPos.page).values[parentPos.pos].getCursor();\n+        parentPos.valueCursor = ((PersistedLeaf<K, V>)parentPos.page).values[parentPos.pos].getCursor();\n         parentPos.valueCursor.afterLast();\n         parentPos.pos = AFTER_LAST;\n     }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/persisted/TupleCursorImpl.java"}, {"additions": 5, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeTest.java", "sha": "5e164eb89e60009f7f7bdc454a07aed64bc9cd8e", "changes": 9, "status": "modified", "deletions": 4, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeTest.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -38,6 +38,7 @@\n import org.apache.directory.mavibot.btree.BTree;\n import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.Page;\n+import org.apache.directory.mavibot.btree.PageHolder;\n import org.apache.directory.mavibot.btree.Tuple;\n import org.apache.directory.mavibot.btree.TupleCursor;\n import org.apache.directory.mavibot.btree.exception.EndOfFileExceededException;\n@@ -1044,7 +1045,7 @@ public void testBrowseNonExistingKey() throws Exception\n     private Page<Integer, String> createLeaf( BTree<Integer, String> btree, long revision,\n         Tuple<Integer, String>... tuples )\n     {\n-        Leaf<Integer, String> leaf = new Leaf<Integer, String>( btree );\n+        InMemoryLeaf<Integer, String> leaf = new InMemoryLeaf<Integer, String>( btree );\n         int pos = 0;\n         leaf.setRevision( revision );\n         leaf.setNbElems( tuples.length );\n@@ -1054,7 +1055,7 @@ public void testBrowseNonExistingKey() throws Exception\n \n         for ( Tuple<Integer, String> tuple : tuples )\n         {\n-            leaf.setKey( pos, tuple.getKey() );\n+            leaf.setKey( pos, new KeyHolder<Integer>( tuple.getKey() ) );\n             leaf.values[pos] = new InMemoryValueHolder<String>( btree, tuple.getValue() );\n             pos++;\n         }\n@@ -1070,10 +1071,10 @@ private void addPage( BTree<Integer, String> btree, Node<Integer, String> node,\n \n         if ( pos > 0 )\n         {\n-            node.setKey( pos - 1, leftmost.getKey() );\n+            node.setKey( pos - 1, new KeyHolder<Integer>( leftmost.getKey() ) );\n         }\n \n-        node.children[pos] = page;\n+        node.setPageHolder( pos, new PageHolder<Integer, String>( btree, page ) );\n     }\n \n ", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/InMemoryBTreeTest.java"}, {"additions": 39, "raw_url": "https://github.com/apache/directory-mavibot/raw/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/LeafTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/75f90efdb2873811b83bdf741f6458f0a06f5671/mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/LeafTest.java", "sha": "8f4f1d8c8e5c93f306c03eba3b3d97f03acda2c8", "changes": 76, "status": "modified", "deletions": 37, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/LeafTest.java?ref=75f90efdb2873811b83bdf741f6458f0a06f5671", "patch": "@@ -31,8 +31,10 @@\n import org.apache.directory.mavibot.btree.BorrowedFromRightResult;\n import org.apache.directory.mavibot.btree.DeleteResult;\n import org.apache.directory.mavibot.btree.InsertResult;\n+import org.apache.directory.mavibot.btree.KeyHolder;\n import org.apache.directory.mavibot.btree.NotPresentResult;\n import org.apache.directory.mavibot.btree.Page;\n+import org.apache.directory.mavibot.btree.PageHolder;\n import org.apache.directory.mavibot.btree.RemoveResult;\n import org.apache.directory.mavibot.btree.Tuple;\n import org.apache.directory.mavibot.btree.exception.KeyNotFoundException;\n@@ -75,11 +77,11 @@ public void shutdown() throws IOException\n      * A helper method to insert elements in a Leaf\n      * @throws IOException \n      */\n-    private Leaf<Long, String> insert( Leaf<Long, String> leaf, long key, String value ) throws IOException\n+    private InMemoryLeaf<Long, String> insert( InMemoryLeaf<Long, String> leaf, long key, String value ) throws IOException\n     {\n         InsertResult<Long, String> result = leaf.insert( 1L, key, value );\n \n-        return ( Leaf<Long, String> ) ( (org.apache.directory.mavibot.btree.ModifyResult<Long, String> ) result ).getModifiedPage();\n+        return ( InMemoryLeaf<Long, String> ) ( (org.apache.directory.mavibot.btree.ModifyResult<Long, String> ) result ).getModifiedPage();\n     }\n \n \n@@ -90,7 +92,7 @@ public void shutdown() throws IOException\n     @Test\n     public void testDeleteFromEmptyLeaf() throws IOException\n     {\n-        Leaf<Long, String> leaf = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> leaf = new InMemoryLeaf<Long, String>( btree );\n \n         DeleteResult<Long, String> result = leaf.delete( 1L, 1L, null, null, -1 );\n \n@@ -105,7 +107,7 @@ public void testDeleteFromEmptyLeaf() throws IOException\n     @Test\n     public void testDeleteNotPresentElementFromRootLeaf() throws IOException\n     {\n-        Leaf<Long, String> leaf = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> leaf = new InMemoryLeaf<Long, String>( btree );\n         leaf = insert( leaf, 1L, \"v1\" );\n         leaf = insert( leaf, 2L, \"v2\" );\n         leaf = insert( leaf, 3L, \"v3\" );\n@@ -124,7 +126,7 @@ public void testDeleteNotPresentElementFromRootLeaf() throws IOException\n     @Test\n     public void testDeletePresentElementFromRootLeaf() throws IOException\n     {\n-        Leaf<Long, String> leaf = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> leaf = new InMemoryLeaf<Long, String>( btree );\n         leaf = insert( leaf, 1L, \"v1\" );\n         leaf = insert( leaf, 2L, \"v2\" );\n         leaf = insert( leaf, 3L, \"v3\" );\n@@ -171,7 +173,7 @@ public void testDeletePresentElementFromRootLeaf() throws IOException\n     @Test\n     public void testDeleteFirstElementFromRootLeaf() throws IOException\n     {\n-        Leaf<Long, String> leaf = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> leaf = new InMemoryLeaf<Long, String>( btree );\n         leaf = insert( leaf, 1L, \"v1\" );\n         leaf = insert( leaf, 2L, \"v2\" );\n         leaf = insert( leaf, 3L, \"v3\" );\n@@ -226,9 +228,9 @@ public void testDeleteFirstElementFromRootLeaf() throws IOException\n     public void testDeleteBorrowingFromLeftSibling() throws IOException\n     {\n         Node<Long, String> parent = new Node<Long, String>( btree, 1L, 2 );\n-        Leaf<Long, String> left = new Leaf<Long, String>( btree );\n-        Leaf<Long, String> target = new Leaf<Long, String>( btree );\n-        Leaf<Long, String> right = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> left = new InMemoryLeaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> target = new InMemoryLeaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> right = new InMemoryLeaf<Long, String>( btree );\n \n         // Fill the left page\n         left = insert( left, 1L, \"v1\" );\n@@ -249,13 +251,13 @@ public void testDeleteBorrowingFromLeftSibling() throws IOException\n         right = insert( right, 12L, \"v12\" );\n         right = insert( right, 13L, \"v13\" );\n \n-        parent.children[0] = left;\n-        parent.children[1] = target;\n-        parent.children[2] = right;\n+        parent.setPageHolder( 0, new PageHolder<Long, String>( btree, left ) );\n+        parent.setPageHolder( 1, new PageHolder<Long, String>( btree, target ) );\n+        parent.setPageHolder( 2, new PageHolder<Long, String>( btree, right ) );\n \n         // Update the parent\n-        parent.setKey( 0, 6L );\n-        parent.setKey( 1, 10L );\n+        parent.setKey( 0, new KeyHolder<Long>( 6L ) );\n+        parent.setKey( 1, new KeyHolder<Long>( 10L ) );\n \n         // Now, delete the element from the target page\n         DeleteResult<Long, String> result = target.delete( 2L, 7L, null, parent, 1 );\n@@ -268,7 +270,7 @@ public void testDeleteBorrowingFromLeftSibling() throws IOException\n         assertEquals( Long.valueOf( 7L ), removedKey.getKey() );\n \n         // Check the modified leaf\n-        Leaf<Long, String> newLeaf = ( Leaf<Long, String> ) borrowed.getModifiedPage();\n+        InMemoryLeaf<Long, String> newLeaf = ( InMemoryLeaf<Long, String> ) borrowed.getModifiedPage();\n \n         assertEquals( 4, newLeaf.getNbElems() );\n         assertEquals( Long.valueOf( 5L ), newLeaf.getKey( 0 ) );\n@@ -277,7 +279,7 @@ public void testDeleteBorrowingFromLeftSibling() throws IOException\n         assertEquals( Long.valueOf( 9L ), newLeaf.getKey( 3 ) );\n \n         // Check the sibling\n-        Leaf<Long, String> leftSibling = ( Leaf<Long, String> ) borrowed.getModifiedSibling();\n+        InMemoryLeaf<Long, String> leftSibling = ( InMemoryLeaf<Long, String> ) borrowed.getModifiedSibling();\n \n         assertEquals( 4, leftSibling.getNbElems() );\n         assertEquals( Long.valueOf( 1L ), leftSibling.getKey( 0 ) );\n@@ -296,9 +298,9 @@ public void testDeleteBorrowingFromLeftSibling() throws IOException\n     public void testDeleteBorrowingFromRightSibling() throws IOException\n     {\n         Node<Long, String> parent = new Node<Long, String>( btree, 1L, 2 );\n-        Leaf<Long, String> left = new Leaf<Long, String>( btree );\n-        Leaf<Long, String> target = new Leaf<Long, String>( btree );\n-        Leaf<Long, String> right = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> left = new InMemoryLeaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> target = new InMemoryLeaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> right = new InMemoryLeaf<Long, String>( btree );\n \n         // Fill the left page\n         left = insert( left, 1L, \"v1\" );\n@@ -319,13 +321,13 @@ public void testDeleteBorrowingFromRightSibling() throws IOException\n         right = insert( right, 13L, \"v13\" );\n         right = insert( right, 14L, \"v14\" );\n \n-        parent.children[0] = left;\n-        parent.children[1] = target;\n-        parent.children[2] = right;\n+        parent.setPageHolder( 0, new PageHolder<Long, String>( btree, left ) );\n+        parent.setPageHolder( 1, new PageHolder<Long, String>( btree, target ) );\n+        parent.setPageHolder( 2, new PageHolder<Long, String>( btree, right ) );\n \n         // Update the parent\n-        parent.setKey( 0, 6L );\n-        parent.setKey( 1, 10L );\n+        parent.setKey( 0, new KeyHolder<Long>( 6L ) );\n+        parent.setKey( 1, new KeyHolder<Long>( 10L ) );\n \n         // Now, delete the element from the target page\n         DeleteResult<Long, String> result = target.delete( 2L, 7L, null, parent, 1 );\n@@ -339,7 +341,7 @@ public void testDeleteBorrowingFromRightSibling() throws IOException\n         assertEquals( Long.valueOf( 7L ), removedKey.getKey() );\n \n         // Check the modified leaf\n-        Leaf<Long, String> newLeaf = ( Leaf<Long, String> ) borrowed.getModifiedPage();\n+        InMemoryLeaf<Long, String> newLeaf = ( InMemoryLeaf<Long, String> ) borrowed.getModifiedPage();\n \n         assertEquals( 4, newLeaf.getNbElems() );\n         assertEquals( Long.valueOf( 6L ), newLeaf.getKey( 0 ) );\n@@ -348,7 +350,7 @@ public void testDeleteBorrowingFromRightSibling() throws IOException\n         assertEquals( Long.valueOf( 10L ), newLeaf.getKey( 3 ) );\n \n         // Check the sibling\n-        Leaf<Long, String> rightSibling = ( Leaf<Long, String> ) borrowed.getModifiedSibling();\n+        InMemoryLeaf<Long, String> rightSibling = ( InMemoryLeaf<Long, String> ) borrowed.getModifiedSibling();\n \n         assertEquals( 4, rightSibling.getNbElems() );\n         assertEquals( Long.valueOf( 11L ), rightSibling.getKey( 0 ) );\n@@ -367,9 +369,9 @@ public void testDeleteBorrowingFromRightSibling() throws IOException\n     public void testDeleteMergeWithSibling() throws IOException\n     {\n         Node<Long, String> parent = new Node<Long, String>( btree, 1L, 2 );\n-        Leaf<Long, String> left = new Leaf<Long, String>( btree );\n-        Leaf<Long, String> target = new Leaf<Long, String>( btree );\n-        Leaf<Long, String> right = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> left = new InMemoryLeaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> target = new InMemoryLeaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> right = new InMemoryLeaf<Long, String>( btree );\n \n         // Fill the left page\n         left = insert( left, 1L, \"v1\" );\n@@ -389,13 +391,13 @@ public void testDeleteMergeWithSibling() throws IOException\n         right = insert( right, 11L, \"v11\" );\n         right = insert( right, 12L, \"v12\" );\n \n-        parent.children[0] = left;\n-        parent.children[1] = target;\n-        parent.children[2] = right;\n+        parent.setPageHolder( 0, new PageHolder<Long, String>( btree, left ) );\n+        parent.setPageHolder( 1, new PageHolder<Long, String>( btree, target ) );\n+        parent.setPageHolder( 2, new PageHolder<Long, String>( btree, right ) );\n \n         // Update the parent\n-        parent.setKey( 0, 5L );\n-        parent.setKey( 1, 9L );\n+        parent.setKey( 0, new KeyHolder<Long>( 5L ) );\n+        parent.setKey( 1, new KeyHolder<Long>( 9L ) );\n \n         // Now, delete the element from the target page\n         DeleteResult<Long, String> result = target.delete( 2L, 7L, null, parent, 1 );\n@@ -408,7 +410,7 @@ public void testDeleteMergeWithSibling() throws IOException\n         assertEquals( Long.valueOf( 7L ), removedKey.getKey() );\n \n         // Check the modified leaf\n-        Leaf<Long, String> newLeaf = ( Leaf<Long, String> ) merged.getModifiedPage();\n+        InMemoryLeaf<Long, String> newLeaf = ( InMemoryLeaf<Long, String> ) merged.getModifiedPage();\n \n         assertEquals( 7, newLeaf.getNbElems() );\n         assertEquals( Long.valueOf( 1L ), newLeaf.getKey( 0 ) );\n@@ -428,13 +430,13 @@ public void testDeleteMergeWithSibling() throws IOException\n     @Test\n     public void testFindPos() throws Exception\n     {\n-        Leaf<Long, String> leaf = new Leaf<Long, String>( btree );\n+        InMemoryLeaf<Long, String> leaf = new InMemoryLeaf<Long, String>( btree );\n \n         // Inject the values\n         for ( long i = 0; i < 8; i++ )\n         {\n             long value = i + i + 1;\n-            leaf = ( Leaf<Long, String> ) ( (org.apache.directory.mavibot.btree.ModifyResult<Long, String> ) leaf.insert( 0L, value, \"V\" + value ) )\n+            leaf = ( InMemoryLeaf<Long, String> ) ( (org.apache.directory.mavibot.btree.ModifyResult<Long, String> ) leaf.insert( 0L, value, \"V\" + value ) )\n                 .getModifiedPage();\n         }\n ", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/memory/LeafTest.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/fffad21ac942f822ea809e9d60a59d9d3babb60e", "parent": "https://github.com/apache/directory-mavibot/commit/25e67e20d4eff4decceb2e84c46a6dbdb1ace91e", "message": "o Added the code that fetch an element from the disk, when it's not present in memory\no Propagated various exceptions up to the top\no The RecordManager was not stored into a BTree we read from disk, leading to NPEs", "bug_id": "directory-mavibot_9", "file": [{"additions": 6, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/AbstractPage.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/AbstractPage.java", "sha": "55b4a5583046e4988af50eeb0415e79f10bc4617", "changes": 7, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/AbstractPage.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -20,8 +20,11 @@\n package org.apache.mavibot.btree;\n \n \n+import java.io.IOException;\n import java.lang.reflect.Array;\n \n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n+\n \n /**\n  * A MVCC abstract Page. It stores the field and the methods shared by the Node and Leaf\n@@ -86,8 +89,10 @@ protected AbstractPage( BTree<K, V> btree, long revision, int nbElems )\n      * @param parent The parent of the current page\n      * @param The position of the current page reference in its parent\n      * @return The position of the sibling, or -1 if we have'nt found any sibling\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    protected int selectSibling( Node<K, V> parent, int parentPos )\n+    protected int selectSibling( Node<K, V> parent, int parentPos ) throws EndOfFileExceededException, IOException\n     {\n         if ( parentPos == 0 )\n         {", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/AbstractPage.java"}, {"additions": 21, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Cursor.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Cursor.java", "sha": "45c85b6b45c7e475fc80dbdf2e1f858bd82c9586", "changes": 27, "status": "modified", "deletions": 6, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/Cursor.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -20,8 +20,11 @@\n package org.apache.mavibot.btree;\n \n \n+import java.io.IOException;\n import java.util.LinkedList;\n \n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n+\n \n /**\n  * A Cursor is used to fetch elements in a BTree and is returned by the\n@@ -67,8 +70,10 @@\n      * Find the next key/value\n      * \n      * @return A Tuple containing the found key and value\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    /* No qualifier */Tuple<K, V> next()\n+    /* No qualifier */Tuple<K, V> next() throws EndOfFileExceededException, IOException\n     {\n         ParentPos<K, V> parentPos = stack.getFirst();\n \n@@ -104,8 +109,10 @@\n      * Find the leaf containing the following elements.\n      * \n      * @return the new ParentPos instance, or null if we have no following leaf\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    private ParentPos<K, V> findNextParentPos()\n+    private ParentPos<K, V> findNextParentPos() throws EndOfFileExceededException, IOException\n     {\n         while ( true )\n         {\n@@ -150,8 +157,10 @@\n      * Find the leaf containing the previous elements.\n      * \n      * @return the new ParentPos instance, or null if we have no previous leaf\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    private ParentPos<K, V> findPreviousParentPos()\n+    private ParentPos<K, V> findPreviousParentPos() throws EndOfFileExceededException, IOException\n     {\n         while ( true )\n         {\n@@ -197,8 +206,10 @@\n      * Find the previous key/value\n      * \n      * @return A Tuple containing the found key and value\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    /* No qualifier */Tuple<K, V> prev()\n+    /* No qualifier */Tuple<K, V> prev() throws EndOfFileExceededException, IOException\n     {\n         ParentPos<K, V> parentPos = stack.peek();\n \n@@ -234,8 +245,10 @@\n     /**\n      * Tells if the cursor can return a next element\n      * @return true if there are some more elements\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    /* No qualifier */boolean hasNext()\n+    /* No qualifier */boolean hasNext() throws EndOfFileExceededException, IOException\n     {\n         ParentPos<K, V> parentPos = stack.peek();\n \n@@ -265,8 +278,10 @@\n     /**\n      * Tells if the cursor can return a previous element\n      * @return true if there are some more elements\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    /* No qualifier */boolean hasPrev()\n+    /* No qualifier */boolean hasPrev() throws EndOfFileExceededException, IOException\n     {\n         ParentPos<K, V> parentPos = stack.peek();\n ", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/Cursor.java"}, {"additions": 6, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/ElementHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/ElementHolder.java", "sha": "fe7fbdb498a333ac1145bc5282fb6c13ca7f5ed9", "changes": 7, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/ElementHolder.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -20,6 +20,11 @@\n package org.apache.mavibot.btree;\n \n \n+import java.io.IOException;\n+\n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n+\n+\n /**\n  * A Value holder. As we may not store all the values in memory (except for an in-memory\n  * BTree), we will use a SoftReference to keep a reference to a Value, and if it's null,\n@@ -40,5 +45,5 @@\n      * \n      * @return The stored element\n      */\n-    E getValue( BTree<K, V> btree );\n+    E getValue( BTree<K, V> btree ) throws EndOfFileExceededException, IOException;\n }", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/ElementHolder.java"}, {"additions": 28, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Leaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Leaf.java", "sha": "a5f01044437ef83fd6b54c59195b57197dd4622a", "changes": 32, "status": "modified", "deletions": 4, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/Leaf.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -24,6 +24,7 @@\n import java.lang.reflect.Array;\n import java.util.LinkedList;\n \n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n import org.apache.mavibot.btree.exception.KeyNotFoundException;\n \n \n@@ -108,9 +109,12 @@\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     @SuppressWarnings(\"unchecked\")\n     public DeleteResult<K, V> delete( long revision, K key, Page<K, V> parent, int parentPos )\n+        throws EndOfFileExceededException, IOException\n     {\n         // Check that the leaf is not empty\n         if ( nbElems == 0 )\n@@ -200,8 +204,11 @@\n      * @param isLeft Tells if the sibling is on the left or on the right\n      * @param pos The position of the removed element\n      * @return The new created leaf containing the sibling and the old page.\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     private DeleteResult<K, V> mergeWithSibling( long revision, Leaf<K, V> sibling, boolean isLeft, int pos )\n+        throws EndOfFileExceededException, IOException\n     {\n         // Create the new page. It will contain N - 1 elements (the maximum number)\n         // as we merge two pages that contain N/2 elements minus the one we remove\n@@ -256,8 +263,11 @@\n      * @param sibling The left sibling\n      * @param pos The position of the element to remove\n      * @return The resulting pages\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     private DeleteResult<K, V> borrowFromLeft( long revision, Leaf<K, V> sibling, int pos )\n+        throws EndOfFileExceededException, IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n         K siblingKey = sibling.keys[sibling.getNbElems() - 1];\n@@ -300,8 +310,11 @@\n      * @param sibling The right sibling\n      * @param pos The position of the element to remove\n      * @return The resulting pages\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     private DeleteResult<K, V> borrowFromRight( long revision, Leaf<K, V> sibling, int pos )\n+        throws EndOfFileExceededException, IOException\n     {\n         // The sibling is on the left, borrow the rightmost element\n         K siblingKey = sibling.keys[0];\n@@ -345,8 +358,10 @@\n      * @param revision The revision of the modified page\n      * @param pos The position into the page of the element to remove\n      * @return The modified page with the <K,V> element added\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    private DeleteResult<K, V> removeElement( long revision, int pos )\n+    private DeleteResult<K, V> removeElement( long revision, int pos ) throws EndOfFileExceededException, IOException\n     {\n         // First copy the current page, but remove one element in the copied page\n         Leaf<K, V> newLeaf = new Leaf<K, V>( btree, revision, nbElems - 1 );\n@@ -394,8 +409,10 @@ public boolean exist( K key )\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public V get( K key ) throws KeyNotFoundException\n+    public V get( K key ) throws KeyNotFoundException, EndOfFileExceededException, IOException\n     {\n         int pos = findPos( key );\n \n@@ -530,8 +547,11 @@ public void setValue( int pos, ElementHolder<V, K, V> value )\n      * @param value the new value\n      * @param pos The position of the key in the page\n      * @return The copied page\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     private InsertResult<K, V> replaceElement( long revision, K key, V value, int pos )\n+        throws EndOfFileExceededException, IOException\n     {\n         Leaf<K, V> newLeaf = this;\n \n@@ -693,17 +713,21 @@ public K getLeftMostKey()\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public Tuple<K, V> findLeftMost()\n+    public Tuple<K, V> findLeftMost() throws EndOfFileExceededException, IOException\n     {\n         return new Tuple<K, V>( keys[0], values[0].getValue( btree ) );\n     }\n \n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public Tuple<K, V> findRightMost()\n+    public Tuple<K, V> findRightMost() throws EndOfFileExceededException, IOException\n     {\n         return new Tuple<K, V>( keys[nbElems - 1], values[nbElems - 1].getValue( btree ) );\n     }", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/Leaf.java"}, {"additions": 62, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Node.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Node.java", "sha": "70b364cfac5318f474814c6114ff3ed4fbcd85b0", "changes": 90, "status": "modified", "deletions": 28, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/Node.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -24,6 +24,7 @@\n import java.lang.reflect.Array;\n import java.util.LinkedList;\n \n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n import org.apache.mavibot.btree.exception.KeyNotFoundException;\n \n \n@@ -821,8 +822,11 @@ public boolean exist( K key ) throws IOException\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws KeyNotFoundException \n+     * @throws EndOfFileExceededException \n      */\n-    public V get( K key ) throws KeyNotFoundException\n+    public V get( K key ) throws IOException, KeyNotFoundException\n     {\n         int pos = findPos( key );\n \n@@ -852,8 +856,10 @@ public void setValue( int pos, ElementHolder<Page<K, V>, K, V> value )\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public Page<K, V> getReference( int pos )\n+    public Page<K, V> getReference( int pos ) throws EndOfFileExceededException, IOException\n     {\n         if ( pos < nbElems + 1 )\n         {\n@@ -868,8 +874,11 @@ public void setValue( int pos, ElementHolder<Page<K, V>, K, V> value )\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     public Cursor<K, V> browse( K key, Transaction<K, V> transaction, LinkedList<ParentPos<K, V>> stack )\n+        throws EndOfFileExceededException, IOException\n     {\n         int pos = findPos( key );\n \n@@ -887,8 +896,11 @@ public void setValue( int pos, ElementHolder<Page<K, V>, K, V> value )\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     public Cursor<K, V> browse( Transaction<K, V> transaction, LinkedList<ParentPos<K, V>> stack )\n+        throws EndOfFileExceededException, IOException\n     {\n         stack.push( new ParentPos<K, V>( this, 0 ) );\n \n@@ -1115,32 +1127,40 @@ else if ( pos == middle )\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public K getLeftMostKey()\n+    public K getLeftMostKey() throws EndOfFileExceededException, IOException\n     {\n         return children[0].getValue( btree ).getLeftMostKey();\n     }\n \n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public Tuple<K, V> findLeftMost()\n+    public Tuple<K, V> findLeftMost() throws EndOfFileExceededException, IOException\n     {\n         return children[0].getValue( btree ).findLeftMost();\n     }\n \n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    public Tuple<K, V> findRightMost()\n+    public Tuple<K, V> findRightMost() throws EndOfFileExceededException, IOException\n     {\n         return children[nbElems].getValue( btree ).findRightMost();\n     }\n \n \n     /**\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      * @see Object#toString()\n      */\n     public String toString()\n@@ -1151,32 +1171,39 @@ public String toString()\n         sb.append( super.toString() );\n         sb.append( \"] -> {\" );\n \n-        if ( nbElems > 0 )\n+        try\n         {\n-            // Start with the first child\n-            if ( children[0] == null )\n-            {\n-                sb.append( \"null\" );\n-            }\n-            else\n+            if ( nbElems > 0 )\n             {\n-                sb.append( 'r' ).append( children[0].getValue( btree ).getRevision() );\n-            }\n-\n-            for ( int i = 0; i < nbElems; i++ )\n-            {\n-                sb.append( \"|<\" ).append( keys[i] ).append( \">|\" );\n-\n-                if ( children[i + 1] == null )\n+                // Start with the first child\n+                if ( children[0] == null )\n                 {\n                     sb.append( \"null\" );\n                 }\n                 else\n                 {\n-                    sb.append( 'r' ).append( children[i + 1].getValue( btree ).getRevision() );\n+                    sb.append( 'r' ).append( children[0].getValue( btree ).getRevision() );\n+                }\n+\n+                for ( int i = 0; i < nbElems; i++ )\n+                {\n+                    sb.append( \"|<\" ).append( keys[i] ).append( \">|\" );\n+\n+                    if ( children[i + 1] == null )\n+                    {\n+                        sb.append( \"null\" );\n+                    }\n+                    else\n+                    {\n+                        sb.append( 'r' ).append( children[i + 1].getValue( btree ).getRevision() );\n+                    }\n                 }\n             }\n         }\n+        catch ( IOException ioe )\n+        {\n+            // Do nothing\n+        }\n \n         sb.append( \"}\" );\n \n@@ -1193,15 +1220,22 @@ public String dumpPage( String tabs )\n \n         if ( nbElems > 0 )\n         {\n-            // Start with the first child\n-            sb.append( children[0].getValue( btree ).dumpPage( tabs + \"    \" ) );\n+            try\n+            {\n+                // Start with the first child\n+                sb.append( children[0].getValue( btree ).dumpPage( tabs + \"    \" ) );\n \n-            for ( int i = 0; i < nbElems; i++ )\n+                for ( int i = 0; i < nbElems; i++ )\n+                {\n+                    sb.append( tabs );\n+                    sb.append( \"<\" );\n+                    sb.append( keys[i] ).append( \">\\n\" );\n+                    sb.append( children[i + 1].getValue( btree ).dumpPage( tabs + \"    \" ) );\n+                }\n+            }\n+            catch ( IOException ioe )\n             {\n-                sb.append( tabs );\n-                sb.append( \"<\" );\n-                sb.append( keys[i] ).append( \">\\n\" );\n-                sb.append( children[i + 1].getValue( btree ).dumpPage( tabs + \"    \" ) );\n+                // Do nothing\n             }\n         }\n ", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/Node.java"}, {"additions": 17, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Page.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/Page.java", "sha": "9ba9b9efc4e131771147791cb1cd09fb72633c07", "changes": 23, "status": "modified", "deletions": 6, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/Page.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -23,6 +23,7 @@\n import java.io.IOException;\n import java.util.LinkedList;\n \n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n import org.apache.mavibot.btree.exception.KeyNotFoundException;\n \n \n@@ -96,7 +97,7 @@\n      * @throws KeyNotFoundException If no entry with the given key can be found\n      * @return The associated value, or null if there is none\n      */\n-    V get( K key ) throws KeyNotFoundException;\n+    V get( K key ) throws KeyNotFoundException, IOException;\n \n \n     /**\n@@ -108,7 +109,8 @@\n      * @param stack The stack of parents we go through to get to this page\n      * @return A Cursor to browse the next elements\n      */\n-    Cursor<K, V> browse( K key, Transaction<K, V> transaction, LinkedList<ParentPos<K, V>> stack );\n+    Cursor<K, V> browse( K key, Transaction<K, V> transaction, LinkedList<ParentPos<K, V>> stack )\n+        throws EndOfFileExceededException, IOException;\n \n \n     /**\n@@ -117,8 +119,11 @@\n      * @param transaction The started transaction for this operation\n      * @param stack The stack of parents we go through to get to this page\n      * @return A Cursor to browse the next elements\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    Cursor<K, V> browse( Transaction<K, V> transaction, LinkedList<ParentPos<K, V>> stack );\n+    Cursor<K, V> browse( Transaction<K, V> transaction, LinkedList<ParentPos<K, V>> stack )\n+        throws EndOfFileExceededException, IOException;\n \n \n     /**\n@@ -140,26 +145,32 @@\n      * down in the leftmost children to recursively find the leftmost key.\n      * \n      * @return The leftmost key in the tree\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    K getLeftMostKey();\n+    K getLeftMostKey() throws EndOfFileExceededException, IOException;\n \n \n     /**\n      * Find the leftmost element in this page. If the page is a node, it will go\n      * down in the leftmost children to recursively find the leftmost element.\n      * \n      * @return The leftmost element in the tree\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    Tuple<K, V> findLeftMost();\n+    Tuple<K, V> findLeftMost() throws EndOfFileExceededException, IOException;\n \n \n     /**\n      * Find the rightmost element in this page. If the page is a node, it will go\n      * down in the rightmost children to recursively find the rightmost element.\n      * \n      * @return The rightmost element in the tree\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    Tuple<K, V> findRightMost();\n+    Tuple<K, V> findRightMost() throws EndOfFileExceededException, IOException;\n \n \n     /**", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/Page.java"}, {"additions": 17, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/ReferenceHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/ReferenceHolder.java", "sha": "ac4ffc234bc9027a386a8d0cfddf366e17fae2a5", "changes": 25, "status": "modified", "deletions": 8, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/ReferenceHolder.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -20,8 +20,11 @@\n package org.apache.mavibot.btree;\n \n \n+import java.io.IOException;\n import java.lang.ref.SoftReference;\n \n+import org.apache.mavibot.btree.exception.EndOfFileExceededException;\n+\n \n /**\n  * A Value holder. As we may not store all the values in memory (except for an in-memory\n@@ -62,29 +65,35 @@ public ReferenceHolder( BTree<K, V> btree, E element, long offset )\n \n     /**\n      * {@inheritDoc}\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n     @Override\n-    public E getValue( BTree<K, V> btree )\n+    public E getValue( BTree<K, V> btree ) throws EndOfFileExceededException, IOException\n     {\n         E element = reference.get();\n \n-        if ( element != null )\n+        if ( element == null )\n         {\n-            return element;\n+            // We have to fetch the element from disk, using the offset now\n+            element = fetchElement( btree );\n         }\n \n-        // We have to fetch the element from disk, using the offset now\n-        return fetchElement( btree );\n+        return element;\n     }\n \n \n     /**\n      * Retrieve the value from the disk, using the BTree and offset\n-     * @return\n+     * @return The deserialized element (\n+     * @throws IOException \n+     * @throws EndOfFileExceededException \n      */\n-    private E fetchElement( BTree<K, V> btree )\n+    private E fetchElement( BTree<K, V> btree ) throws EndOfFileExceededException, IOException\n     {\n-        return null;\n+        E element = ( E ) btree.getRecordManager().deserialize( btree, offset );\n+\n+        return element;\n     }\n \n ", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/ReferenceHolder.java"}, {"additions": 11, "raw_url": "https://github.com/apache/directory-mavibot/raw/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/fffad21ac942f822ea809e9d60a59d9d3babb60e/mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java", "sha": "c0af07cff615e1bf7da9ee5af15141fdc8b94e71", "changes": 11, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java?ref=fffad21ac942f822ea809e9d60a59d9d3babb60e", "patch": "@@ -492,6 +492,7 @@ private void loadBTree( PageIO[] pageIos, BTree<?, ?> btree ) throws EndOfFileEx\n         PageIO[] rootPageIos = readPages( rootPageOffset, Long.MAX_VALUE );\n \n         Page btreeRoot = readPage( btree, rootPageIos );\n+        BTreeFactory.setRecordManager( btree, this );\n \n         BTreeFactory.setRoot( btree, btreeRoot );\n     }\n@@ -508,6 +509,16 @@ private Page readNode( BTree btree, long offset, long revision, int nbElems ) th\n     }\n \n \n+    public Page deserialize( BTree btree, long offset ) throws EndOfFileExceededException, IOException\n+    {\n+        PageIO[] rootPageIos = readPages( offset, Long.MAX_VALUE );\n+\n+        Page page = readPage( btree, rootPageIos );\n+\n+        return page;\n+    }\n+\n+\n     private Page readPage( BTree btree, PageIO[] pageIos ) throws IOException\n     {\n         // Deserialize the rootPage now", "filename": "mavibot/src/main/java/org/apache/mavibot/btree/store/RecordManager.java"}], "repo": "directory-mavibot"}, {"commit": "https://github.com/apache/directory-mavibot/commit/9e83907abe9e77008a8589ff2366670a296b4dcb", "parent": "https://github.com/apache/directory-mavibot/commit/1aa6bf278582bbd7258e95b08d382ce0e7f3a2e7", "message": "o Huge refactoring of the BulkLoad feature. We now are capable to bulk load elements with multiple values\no Removed useless sysout\no Added a setValues() method in Page\no The BtreHeaderOffset and BTreeInfoOffset default value is now NO_PAGE\no The subtrees are now created in one step, then written in a second step, to avoid creating pages that will be immediately reused\no raw keys are marked with the deserialied value as :<K> in the KeyHolder.toString() method\no Fixed a NPE in PersistedLeaf.toString() method", "bug_id": "directory-mavibot_10", "file": [{"additions": 1120, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/img/datastructure.graphml", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/img/datastructure.graphml", "sha": "643b780f3805f4016569748bc01027ca1ae2febd", "changes": 1780, "status": "modified", "deletions": 660, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/img/datastructure.graphml?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "filename": "mavibot/img/datastructure.graphml"}, {"additions": 0, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java", "sha": "5f95eda78e37cc916c86c101b9e541ce987ca8d9", "changes": 5, "status": "modified", "deletions": 5, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -1095,11 +1095,6 @@ public void run()\n \n                         long t1 = System.currentTimeMillis();\n \n-                        if ( nbTxns > 0 )\n-                        {\n-                            System.out.println( \"Processing old txn : \" + nbTxns + \", \" + ( t1 - t0 ) + \"ms\" );\n-                        }\n-\n                         // Wait until we reach the timeout\n                         Thread.sleep( readTimeOut );\n                     }", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractBTree.java"}, {"additions": 11, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java", "sha": "3163ff1e26c8aab51e863597e580c8e6226baf91", "changes": 16, "status": "modified", "deletions": 5, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -138,11 +138,6 @@ public boolean hasKey( K key ) throws IOException\n         {\n             Page<K, V> page = children[pos].getValue();\n \n-            if ( page == null )\n-            {\n-                System.out.println( \"Page is null for pos = \" + pos + \", children = \" + children[pos] );\n-            }\n-\n             return page.hasKey( key );\n         }\n     }\n@@ -318,6 +313,17 @@ public V get( K key ) throws IOException, KeyNotFoundException\n     }\n \n \n+    /**\n+     * Sets the value at a give position\n+     * @param pos The position in the values array\n+     * @param value the value to inject\n+     */\n+    /* no qualifier */void setValue( int pos, ValueHolder<V> value )\n+    {\n+        // Implementation in the leaves\n+    }\n+\n+\n     /**\n      * {@inheritDoc}\n      */", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractPage.java"}, {"additions": 60, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java", "sha": "a22b7ba185721d30238a7067f543fd8365ef3210", "changes": 78, "status": "modified", "deletions": 18, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -23,6 +23,7 @@\n import java.io.IOException;\n import java.lang.reflect.Array;\n import java.util.Comparator;\n+import java.util.Iterator;\n \n import org.apache.directory.mavibot.btree.exception.KeyNotFoundException;\n import org.apache.directory.mavibot.btree.serializer.ElementSerializer;\n@@ -247,7 +248,8 @@ protected boolean btreeContains( V value )\n         }\n         catch ( KeyNotFoundException knfe )\n         {\n-            knfe.printStackTrace();return false;\n+            knfe.printStackTrace();\n+            return false;\n         }\n     }\n \n@@ -274,38 +276,78 @@ public boolean contains( V checkedValue )\n     protected abstract void createSubTree();\n \n \n+    /**\n+     * Manage a new Sub-BTree .\n+     */\n+    protected abstract void manageSubTree();\n+\n+\n     /**\n      * Add the value in an array\n      */\n-    private void addInArray( V value )\n+    private void addInArray( final V value )\n     {\n         // We have to check that we have reached the threshold or not\n         if ( size() >= valueThresholdUp )\n         {\n             // Ok, transform the array into a btree\n             createSubTree();\n \n-            try\n+            Iterator<Tuple<V, V>> valueIterator = new Iterator<Tuple<V, V>>()\n             {\n-                for ( V val : valueArray )\n+                int pos = 0;\n+\n+\n+                @Override\n+                public Tuple<V, V> next()\n+                {\n+                    // We can now return the found value\n+                    if ( pos == valueArray.length )\n+                    {\n+                        // Special case : deal with the added value\n+                        pos++;\n+\n+                        return new Tuple<V, V>( value, value );\n+                    }\n+                    else\n+                    {\n+                        V oldValue = valueArray[pos];\n+                        pos++;\n+\n+                        return new Tuple<V, V>( oldValue, oldValue );\n+                    }\n+                }\n+\n+\n+                @Override\n+                public boolean hasNext()\n+                {\n+                    // Check that we have at least one element to read\n+                    return pos < valueArray.length + 1;\n+                }\n+\n+\n+                @Override\n+                public void remove()\n                 {\n-                    // Here, we should insert all the values in one shot then \n-                    // write the btree on disk only once.\n-                    valueBtree.insert( val, null );\n                 }\n \n-                // We can delete the array now\n-                nbArrayElems = 0;\n-                valueArray = null;\n+            };\n \n-                // And inject the new value\n-                valueBtree.insert( value, null );\n+            try\n+            {\n+                BulkLoader.load( valueBtree, valueIterator, valueArray.length );\n             }\n             catch ( IOException e )\n             {\n                 // TODO Auto-generated catch block\n                 e.printStackTrace();\n             }\n+\n+            manageSubTree();\n+\n+            // And make the valueArray to be null now\n+            valueArray = null;\n         }\n         else\n         {\n@@ -375,24 +417,24 @@ public void add( V value )\n             addInBtree( value );\n         }\n     }\n-    \n-    \n+\n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public V replaceValueArray( V newValue )\n     {\n-        if( isSubBtree() )\n+        if ( isSubBtree() )\n         {\n             throw new IllegalStateException( \"method is not applicable for the duplicate B-Trees\" );\n         }\n-        \n+\n         V tmp = valueArray[0];\n-        \n+\n         nbArrayElems = 1;\n         valueArray[0] = newValue;\n-        \n+\n         return tmp;\n     }\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/AbstractValueHolder.java"}, {"additions": 1, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/BTreeHeader.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/BTreeHeader.java", "sha": "9a2206c5b130ad9747909d8d6c6e859af9417b62", "changes": 2, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/BTreeHeader.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -59,7 +59,7 @@\n     private long rootPageOffset;\n \n     /** The position of the B-tree header in the file */\n-    private long btreeHeaderOffset;\n+    private long btreeHeaderOffset = RecordManager.NO_PAGE;\n \n     // Those are data which aren't serialized : they are in memory only */\n     /** A Map containing the rootPage for this tree */", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/BTreeHeader.java"}, {"additions": 83, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java", "sha": "5782a56a9c5069420115139db9120949bcb4de27", "changes": 105, "status": "modified", "deletions": 22, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -65,6 +65,27 @@ private BulkLoader()\n         NODE\n     }\n \n+    /**\n+     * A private class used to store the temporary sorted file. It's used by\n+     * the bulkLoader\n+     */\n+    private static class SortedFile\n+    {\n+        /** the file that contains the values */\n+        private File file;\n+\n+        /** The number of stored values */\n+        private int nbValues;\n+\n+\n+        /** A constructor for this class */\n+        /*No Qualifier*/SortedFile( File file, int nbValues )\n+        {\n+            this.file = file;\n+            this.nbValues = nbValues;\n+        }\n+    }\n+\n \n     /**\n      * Process the data, and creates files to store them sorted if necessary, or store them\n@@ -163,7 +184,7 @@ private BulkLoader()\n      * sorted and merged elements.\n      * @throws IOException \n      */\n-    private static <K, V> Tuple<Iterator<Tuple<K, Set<V>>>, Integer> processFiles( BTree<K, V> btree,\n+    private static <K, V> Tuple<Iterator<Tuple<K, Set<V>>>, SortedFile> processFiles( BTree<K, V> btree,\n         Iterator<Tuple<K, Set<V>>> dataIterator ) throws IOException\n     {\n         File file = File.createTempFile( \"sortedUnique\", \"data\" );\n@@ -206,9 +227,10 @@ private BulkLoader()\n \n         FileInputStream fis = new FileInputStream( file );\n         Iterator<Tuple<K, Set<V>>> uniqueIterator = createUniqueFileIterator( btree, fis );\n+        SortedFile sortedFile = new SortedFile( file, nbReads );\n \n-        Tuple<Iterator<Tuple<K, Set<V>>>, Integer> result = new Tuple<Iterator<Tuple<K, Set<V>>>, Integer>(\n-            uniqueIterator, nbReads );\n+        Tuple<Iterator<Tuple<K, Set<V>>>, SortedFile> result = new Tuple<Iterator<Tuple<K, Set<V>>>, SortedFile>(\n+            uniqueIterator, sortedFile );\n \n         return result;\n     }\n@@ -222,7 +244,7 @@ private BulkLoader()\n      * @param chunkSize The number of elements we may store in memory at each iteration\n      * @throws IOException If there is a problem while processing the data\n      */\n-    public static <K, V> BTree<K, V> load( PersistedBTree<K, V> btree, Iterator<Tuple<K, V>> iterator, int chunkSize )\n+    public static <K, V> BTree<K, V> load( BTree<K, V> btree, Iterator<Tuple<K, V>> iterator, int chunkSize )\n         throws IOException\n     {\n         if ( btree == null )\n@@ -281,8 +303,9 @@ private BulkLoader()\n             dataIterator = createIterator( btree, streams );\n \n             // Process the files, and construct one single file with an iterator\n-            Tuple<Iterator<Tuple<K, Set<V>>>, Integer> result = processFiles( btree, dataIterator );\n-            resultBTree = bulkLoad( btree, result.key, result.value );\n+            Tuple<Iterator<Tuple<K, Set<V>>>, SortedFile> result = processFiles( btree, dataIterator );\n+            resultBTree = bulkLoad( btree, result.key, result.value.nbValues );\n+            result.value.file.delete();\n         }\n \n         // Ok, we have an iterator over sorted elements, we can now load them in the \n@@ -444,14 +467,18 @@ private BulkLoader()\n     /**\n      * Inject a tuple into a leaf\n      */\n-    private static <K, V> void injectInLeaf( BTree<K, V> btree, Tuple<K, Set<V>> tuple, LevelInfo leafLevel )\n+    private static <K, V> void injectInLeaf( BTree<K, V> btree, Tuple<K, Set<V>> tuple, LevelInfo<K, V> leafLevel )\n     {\n         PersistedLeaf<K, V> leaf = ( PersistedLeaf<K, V> ) leafLevel.getCurrentPage();\n \n         KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), tuple.getKey() );\n-        ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, ( V[] ) tuple.getValue().toArray() );\n         leaf.setKey( leafLevel.getCurrentPos(), keyHolder );\n-        leaf.setValue( leafLevel.getCurrentPos(), valueHolder );\n+\n+        if ( btree.getType() != BTreeTypeEnum.PERSISTED_SUB )\n+        {\n+            ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, ( V[] ) tuple.getValue().toArray() );\n+            leaf.setValue( leafLevel.getCurrentPos(), valueHolder );\n+        }\n \n         leafLevel.incCurrentPos();\n     }\n@@ -515,8 +542,8 @@ else if ( remaining > levelInfo.getNbElems() - levelInfo.getNbElemsLimit() )\n         LevelInfo<K, V> level ) throws IOException\n     {\n         PersistedNode<K, V> node = ( PersistedNode<K, V> ) level.getCurrentPage();\n-        if ( ( level.getCurrentPos() == 0 ) && ( node.getPage( 0 ) == null ) )\n \n+        if ( ( level.getCurrentPos() == 0 ) && ( node.getPage( 0 ) == null ) )\n         {\n             node.setPageHolder( 0, pageHolder );\n             level.incNbAddedElems();\n@@ -759,8 +786,23 @@ else if ( level.getNbElems() - level.getNbAddedElems() <= pageSize )\n     private static <K, V> BTree<K, V> bulkLoadSinglePage( BTree<K, V> btree, Iterator<Tuple<K, Set<V>>> dataIterator,\n         int nbElems ) throws IOException\n     {\n-        // Create a new page\n-        PersistedLeaf<K, V> rootPage = ( PersistedLeaf<K, V> ) BTreeFactory.createLeaf( btree, 0L, nbElems );\n+        // Use the root page\n+        Page<K, V> rootPage = btree.getRootPage();\n+\n+        // Initialize the root page\n+        ( ( AbstractPage<K, V> ) rootPage ).setNbElems( nbElems );\n+        KeyHolder<K>[] keys = new KeyHolder[nbElems];\n+        ValueHolder<V>[] values = new ValueHolder[nbElems];\n+\n+        switch ( btree.getType() )\n+        {\n+            case IN_MEMORY:\n+                ( ( InMemoryLeaf<K, V> ) rootPage ).values = values;\n+                break;\n+\n+            default:\n+                ( ( PersistedLeaf<K, V> ) rootPage ).values = values;\n+        }\n \n         // We first have to inject data into the page\n         int pos = 0;\n@@ -771,18 +813,31 @@ else if ( level.getNbElems() - level.getNbAddedElems() <= pageSize )\n \n             // Store the current element in the rootPage\n             KeyHolder<K> keyHolder = new PersistedKeyHolder<K>( btree.getKeySerializer(), tuple.getKey() );\n-            ValueHolder<V> valueHolder = new PersistedValueHolder<V>( btree, ( V[] ) tuple.getValue().toArray() );\n-            rootPage.setKey( pos, keyHolder );\n-            rootPage.setValue( pos, valueHolder );\n+            keys[pos] = keyHolder;\n+\n+            switch ( btree.getType() )\n+            {\n+                case IN_MEMORY:\n+                    ValueHolder<V> valueHolder = new InMemoryValueHolder<V>( btree, ( V[] ) tuple.getValue()\n+                        .toArray() );\n+                    ( ( InMemoryLeaf<K, V> ) rootPage ).values[pos] = valueHolder;\n+                    break;\n+\n+                default:\n+                    valueHolder = new PersistedValueHolder<V>( btree, ( V[] ) tuple.getValue()\n+                        .toArray() );\n+                    ( ( PersistedLeaf<K, V> ) rootPage ).values[pos] = valueHolder;\n+            }\n+\n             pos++;\n         }\n \n-        // Now write the page on disk\n-        ( ( PersistedBTree<K, V> ) btree ).getRecordManager().writePage( btree, rootPage, 0L );\n+        // Update the rootPage\n+        ( ( AbstractPage<K, V> ) rootPage ).setKeys( keys );\n \n-        // Update the btree with the rootPage and the nb of added elements\n-        ( ( PersistedBTree<K, V> ) btree ).getBtreeHeader().setRootPage( rootPage );\n-        ( ( PersistedBTree<K, V> ) btree ).getBtreeHeader().setNbElems( nbElems );\n+        // Update the btree with the nb of added elements, and write it$\n+        BTreeHeader<K, V> btreeHeader = ( ( AbstractBTree<K, V> ) btree ).getBtreeHeader();\n+        btreeHeader.setNbElems( nbElems );\n \n         return btree;\n     }\n@@ -862,7 +917,8 @@ else if ( level.getNbElems() - level.getNbAddedElems() <= pageSize )\n                     }\n \n                     // Now inject the page into the node\n-                    injectInNode( btree, leafLevel.getCurrentPage(), levels, 1 );\n+                    Page<K, V> currentPage = leafLevel.getCurrentPage();\n+                    injectInNode( btree, currentPage, levels, 1 );\n \n                     // Create a new page for the remaining elements\n                     nbToAdd = pageSize / 2;\n@@ -880,7 +936,8 @@ else if ( level.getNbElems() - level.getNbAddedElems() <= pageSize )\n                     }\n \n                     // And update the parent node\n-                    injectInNode( btree, leafLevel.getCurrentPage(), levels, 1 );\n+                    Page<K, V> levelCurrentPage = leafLevel.getCurrentPage();\n+                    injectInNode( btree, levelCurrentPage, levels, 1 );\n \n                     // We are done\n                     break;\n@@ -910,6 +967,10 @@ else if ( level.getNbElems() - level.getNbAddedElems() <= pageSize )\n             }\n         }\n \n+        // Update the btree with the nb of added elements, and write it$\n+        BTreeHeader<K, V> btreeHeader = ( ( AbstractBTree<K, V> ) btree ).getBtreeHeader();\n+        btreeHeader.setNbElems( nbElems );\n+\n         return btree;\n     }\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/BulkLoader.java"}, {"additions": 9, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryValueHolder.java", "sha": "bfae29cec58c245debc146a61bf7843d541dab1b", "changes": 9, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryValueHolder.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -133,6 +133,15 @@ protected void createSubTree()\n     }\n \n \n+    /**\n+     * Manage a new Sub-BTree\n+     */\n+    protected void manageSubTree()\n+    {\n+        // Nothing to do\n+    }\n+\n+\n     /**\n      * Set the subBtree in the ValueHolder\n      */", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/InMemoryValueHolder.java"}, {"additions": 1, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java", "sha": "7e264327a1bd76d22c623a9ec76cf6abcb2a0117", "changes": 2, "status": "modified", "deletions": 1, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -67,7 +67,7 @@\n     /*No qualifier*/static int valueThresholdLow = DEFAULT_VALUE_THRESHOLD_LOW;\n \n     /** The BtreeInfo offset */\n-    private long btreeInfoOffset;\n+    private long btreeInfoOffset = RecordManager.NO_PAGE;\n \n     /** The internal recordManager */\n     private RecordManager recordManager;", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedBTree.java"}, {"additions": 5, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedKeyHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedKeyHolder.java", "sha": "1c6b9415a32c22f402f77fc21d5b8b04e4a6e678", "changes": 5, "status": "modified", "deletions": 0, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedKeyHolder.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -121,6 +121,11 @@ public String toString()\n             sb.append( key );\n             sb.append( \", \" );\n         }\n+        else if ( raw != null )\n+        {\n+            K key = getKey();\n+            sb.append( \":\" ).append( key ).append( \":,\" );\n+        }\n         else\n         {\n             sb.append( \"null,\" );", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedKeyHolder.java"}, {"additions": 24, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java", "sha": "7e0a53f9ddc4d471080c64312a62766aca8ce29b", "changes": 31, "status": "modified", "deletions": 7, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -1113,11 +1113,6 @@ else if ( !btree.isAllowDuplicates() )\n      */\n     public K getLeftMostKey()\n     {\n-        if ( keys.length == 0 )\n-        {\n-            System.out.println( \"\" );\n-        }\n-\n         return keys[0].getKey();\n     }\n \n@@ -1250,7 +1245,18 @@ public String toString()\n                     sb.append( \", \" );\n                 }\n \n-                sb.append( \"<\" ).append( keys[i] ).append( \",\" ).append( values[i] ).append( \">\" );\n+                sb.append( \"<\" ).append( keys[i] ).append( \",\" );\n+\n+                if ( values != null )\n+                {\n+                    sb.append( values[i] );\n+                }\n+                else\n+                {\n+                    sb.append( \"null\" );\n+                }\n+\n+                sb.append( \">\" );\n             }\n         }\n \n@@ -1422,7 +1428,18 @@ public String dumpPage( String tabs )\n                     sb.append( \", \" );\n                 }\n \n-                sb.append( \"<\" ).append( keys[i] ).append( \",\" ).append( values[i] ).append( \">\" );\n+                sb.append( \"<\" ).append( keys[i] ).append( \",\" );\n+\n+                if ( values != null )\n+                {\n+                    sb.append( values[i] );\n+                }\n+                else\n+                {\n+                    sb.append( \"null\" );\n+                }\n+\n+                sb.append( \">\" );\n             }\n         }\n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedLeaf.java"}, {"additions": 46, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java", "sha": "43c210703f54b0df7893faba8a296c02a8bc24f5", "changes": 209, "status": "modified", "deletions": 163, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -20,16 +20,10 @@\n package org.apache.directory.mavibot.btree;\n \n \n-import static org.apache.directory.mavibot.btree.BTreeFactory.createLeaf;\n-import static org.apache.directory.mavibot.btree.BTreeFactory.createNode;\n-import static org.apache.directory.mavibot.btree.BTreeFactory.setKey;\n-\n import java.io.IOException;\n import java.lang.reflect.Array;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Comparator;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.UUID;\n \n import org.apache.directory.mavibot.btree.exception.BTreeAlreadyCreatedException;\n@@ -139,6 +133,8 @@\n                 {\n                     throw new RuntimeException( e );\n                 }\n+\n+                manageSubTree();\n             }\n         }\n         else\n@@ -249,29 +245,33 @@ public int size()\n      */\n     protected void createSubTree()\n     {\n-        try\n-        {\n-            PersistedBTreeConfiguration<V, V> configuration = new PersistedBTreeConfiguration<V, V>();\n-            configuration.setAllowDuplicates( false );\n-            configuration.setKeySerializer( valueSerializer );\n-            configuration.setName( UUID.randomUUID().toString() );\n-            configuration.setValueSerializer( valueSerializer );\n-            configuration.setParentBTree( parentBtree );\n-            configuration.setBtreeType( BTreeTypeEnum.PERSISTED_SUB );\n+        PersistedBTreeConfiguration<V, V> configuration = new PersistedBTreeConfiguration<V, V>();\n+        configuration.setAllowDuplicates( false );\n+        configuration.setKeySerializer( valueSerializer );\n+        configuration.setName( UUID.randomUUID().toString() );\n+        configuration.setValueSerializer( valueSerializer );\n+        configuration.setParentBTree( parentBtree );\n+        configuration.setBtreeType( BTreeTypeEnum.PERSISTED_SUB );\n+\n+        valueBtree = BTreeFactory.createPersistedBTree( configuration );\n+        ( ( PersistedBTree<V, V> ) valueBtree ).setRecordManager( parentBtree.getRecordManager() );\n+    }\n \n-            valueBtree = BTreeFactory.createPersistedBTree( configuration );\n \n-            try\n-            {\n-                // The sub-btree will not be added into the BOB.\n-                parentBtree.getRecordManager().manage( valueBtree, RecordManager.INTERNAL_BTREE );\n-                raw = null;\n-            }\n-            catch ( BTreeAlreadyManagedException e )\n-            {\n-                // should never happen\n-                throw new BTreeAlreadyCreatedException( e );\n-            }\n+    /**\n+     * Push the sub-BTree into the RecordManager\n+     */\n+    protected void manageSubTree()\n+    {\n+        try\n+        {\n+            parentBtree.getRecordManager().manageSubBtree( valueBtree );\n+            raw = null;\n+        }\n+        catch ( BTreeAlreadyManagedException e )\n+        {\n+            // should never happen\n+            throw new BTreeAlreadyCreatedException( e );\n         }\n         catch ( IOException e )\n         {\n@@ -712,159 +712,42 @@ private void deserializeSubBtree()\n      * @return The created BTree\n      * @throws Exception\n      */\n-    private BTree<V, V> build( PersistedBTree<V, V> btree, V[] dupKeyValues ) throws Exception\n+    private BTree<V, V> build( PersistedBTree<V, V> btree, final V[] dupKeyValues ) throws Exception\n     {\n-        long newRevision = btree.getRevision() + 1;\n-        int numKeysInNode = btree.getPageSize();\n-        RecordManager rm = btree.getRecordManager();\n-        List<Page<V, V>> lstLeaves = new ArrayList<Page<V, V>>();\n-        int totalTupleCount = 0;\n-        int nbKeyPage = Math.min( dupKeyValues.length, numKeysInNode );\n-\n-        Page<V, V> newLeaf = BTreeFactory.createLeaf( btree, newRevision, nbKeyPage );\n-        lstLeaves.add( newLeaf );\n-\n-        int leafIndex = 0;\n-\n-        // Iterate on all the values\n-        for ( V v : dupKeyValues )\n+        Iterator<Tuple<V, V>> valueIterator = new Iterator<Tuple<V, V>>()\n         {\n-            // Inject the key in the leaf\n-            setKey( btree, newLeaf, leafIndex, v );\n+            int pos = 0;\n \n-            leafIndex++;\n-            totalTupleCount++;\n \n-            if ( ( totalTupleCount % numKeysInNode ) == 0 )\n+            @Override\n+            public Tuple<V, V> next()\n             {\n-                // The page has been completed, create a new one or \n-                // if it was the last value, we are done\n-                if ( totalTupleCount == dupKeyValues.length )\n-                {\n-                    // We are done with the values, exit\n-                    break;\n-                }\n-                else\n-                {\n-                    // Create a new leaf\n-                    leafIndex = 0;\n-                    nbKeyPage = Math.min( dupKeyValues.length - totalTupleCount, numKeysInNode );\n+                // We can now return the found value\n+                V value = dupKeyValues[pos];\n+                pos++;\n \n-                    newLeaf = createLeaf( btree, newRevision, nbKeyPage );\n-                    lstLeaves.add( newLeaf );\n-                }\n+                return new Tuple<V, V>( value, value );\n             }\n \n-            //TODO build the whole tree in chunks rather than processing *all* leaves at first\n-        }\n-\n-        if ( lstLeaves.isEmpty() )\n-        {\n-            return btree;\n-        }\n-\n-        // make sure either one of the root pages is reclaimed, cause when we call rm.manage()\n-        // there is already a root page created\n-        Page<V, V> rootPage = attachNodes( lstLeaves, btree, numKeysInNode, rm );\n-        rm.writePage( btree, rootPage, rootPage.getRevision() );\n-\n-        Page<V, V> oldRoot = btree.getRootPage();\n-\n-        long newRootPageOffset = ( ( AbstractPage<?, V> ) rootPage ).getOffset();\n-        LOG.debug( \"replacing old offset {} of the BTree {} with {}\",\n-            btree.getRootPageOffset(), btree.getName(), newRootPageOffset );\n-\n-        BTreeHeader<V, V> header = btree.getBtreeHeader();\n \n-        header.setRootPage( rootPage );\n-        header.setRevision( newRevision );\n-        header.setNbElems( totalTupleCount );\n-\n-        long newBtreeHeaderOffset = rm.writeBtreeHeader( btree, header );\n-\n-        header.setBTreeHeaderOffset( newBtreeHeaderOffset );\n-        rm.writeBtreeHeader( btree, header );\n-\n-        rm.freePages( ( BTree ) btree, btree.getRevision(), ( List ) Arrays.asList( oldRoot ) );\n-\n-        return btree;\n-    }\n-\n-\n-    /**\n-     * Attaches the Nodes together\n-     * \n-     * @param children the leaves\n-     * @param btree the sub-BTree\n-     * @param numKeysInNode number of keys per each node\n-     * @param rm the RecordManager\n-     * @return the new root page of the sub-BTree after attaching all the nodes\n-     * @throws IOException\n-     */\n-    private Page<V, V> attachNodes( List<Page<V, V>> children, BTree btree, int numKeysInNode, RecordManager rm )\n-        throws IOException\n-    {\n-        if ( children.size() == 1 )\n-        {\n-            return children.get( 0 );\n-        }\n-\n-        List<Page<V, V>> lstNodes = new ArrayList<Page<V, V>>();\n-\n-        int numChildren = numKeysInNode + 1;\n-\n-        PersistedNode node = ( PersistedNode ) createNode( btree, btree.getRevision(), numKeysInNode );\n-        lstNodes.add( node );\n-        int i = 0;\n-        int totalNodes = 0;\n-\n-        for ( Page<?, V> p : children )\n-        {\n-            if ( i != 0 )\n+            @Override\n+            public boolean hasNext()\n             {\n-                setKey( btree, node, i - 1, p.getLeftMostKey() );\n+                // Check that we have at least one element to read\n+                return pos < dupKeyValues.length;\n             }\n \n-            node.children[i] = new PersistedPageHolder( btree, p );\n \n-            i++;\n-            totalNodes++;\n-\n-            if ( ( totalNodes % numChildren ) == 0 )\n+            @Override\n+            public void remove()\n             {\n-                i = 0;\n-\n-                PageHolder pageHolder = ( PageHolder ) rm.writePage( btree, node, 1 );\n-\n-                node = ( PersistedNode ) createNode( btree, btree.getRevision(), numKeysInNode );\n-                lstNodes.add( node );\n             }\n-        }\n-\n-        // remove null keys and values from the last node and resize\n-        AbstractPage<?, V> lastNode = ( AbstractPage<?, V> ) lstNodes.get( lstNodes.size() - 1 );\n-\n-        for ( int j = 0; j < lastNode.nbElems; j++ )\n-        {\n-            if ( lastNode.keys[j] == null )\n-            {\n-                int n = j;\n-                lastNode.nbElems = n;\n-                KeyHolder<?>[] keys = lastNode.keys;\n \n-                lastNode.keys = ( KeyHolder[] ) Array.newInstance( KeyHolder.class, n );\n-                System.arraycopy( keys, 0, lastNode.keys, 0, n );\n-\n-                break;\n-            }\n-        }\n+        };\n \n-        if ( lastNode.keys.length == 0 )\n-        {\n-            lstNodes.remove( lastNode );\n-        }\n+        BulkLoader.load( btree, valueIterator, dupKeyValues.length );\n \n-        return attachNodes( lstNodes, btree, numKeysInNode, rm );\n+        return btree;\n     }\n \n ", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/PersistedValueHolder.java"}, {"additions": 107, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/RecordManager.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/main/java/org/apache/directory/mavibot/btree/RecordManager.java", "sha": "98eccede00a1267964f4cda07e34ba2ddc5bc3e8", "changes": 169, "status": "modified", "deletions": 62, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/main/java/org/apache/directory/mavibot/btree/RecordManager.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -23,6 +23,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.io.RandomAccessFile;\n+import java.nio.BufferUnderflowException;\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.util.ArrayList;\n@@ -376,7 +377,7 @@ private void initRecordManager() throws IOException\n         // Create a new Header\n         nbBtree = 0;\n         firstFreePage = NO_PAGE;\n-        currentBtreeOfBtreesOffset = 0L;\n+        currentBtreeOfBtreesOffset = NO_PAGE;\n \n         updateRecordManagerHeader();\n \n@@ -389,7 +390,7 @@ private void initRecordManager() throws IOException\n         // Inject these B-trees into the RecordManager. They are internal B-trees.\n         try\n         {\n-            manage( btreeOfBtrees, INTERNAL_BTREE );\n+            manageSubBtree( btreeOfBtrees );\n \n             currentBtreeOfBtreesOffset = ( ( PersistedBTree<NameRevision, Long> ) btreeOfBtrees ).getBtreeHeader()\n                 .getBTreeHeaderOffset();\n@@ -1407,18 +1408,81 @@ private byte readByte( PageIO[] pageIos, long position )\n      * Manage a B-tree. The btree will be added and managed by this RecordManager. We will create a\n      * new RootPage for this added B-tree, which will contain no data.<br/>\n      * This method is threadsafe.\n+     * Managing a btree is a matter of storing an reference to the managed B-tree in the B-tree Of B-trees.\n+     * We store a tuple of NameRevision (where revision is 0L) and a offset to the B-tree header.\n+     * At the same time, we keep a track of the managed B-trees in a Map.\n      *\n      * @param btree The new B-tree to manage.\n-     * @throws BTreeAlreadyManagedException if the B-tree is already managed\n+     * @param treeType flag indicating if this is an internal tree\n+     *\n+     * @throws BTreeAlreadyManagedException If the B-tree is already managed\n      * @throws IOException if there was a problem while accessing the file\n      */\n     public synchronized <K, V> void manage( BTree<K, V> btree ) throws BTreeAlreadyManagedException, IOException\n     {\n         beginTransaction();\n \n-        manage( ( BTree<Object, Object> ) btree, NORMAL_BTREE );\n+        try\n+        {\n+            LOG.debug( \"Managing the btree {}\", btree.getName() );\n+            BTreeFactory.setRecordManager( btree, this );\n \n-        commit();\n+            String name = btree.getName();\n+\n+            if ( managedBtrees.containsKey( name ) )\n+            {\n+                // There is already a B-tree with this name in the recordManager...\n+                LOG.error( \"There is already a B-tree named '{}' managed by this recordManager\", name );\n+                rollback();\n+                throw new BTreeAlreadyManagedException( name );\n+            }\n+\n+            // Now, write the B-tree informations\n+            long btreeInfoOffset = writeBtreeInfo( btree );\n+            BTreeHeader<K, V> btreeHeader = ( ( AbstractBTree<K, V> ) btree ).getBtreeHeader();\n+            ( ( PersistedBTree<K, V> ) btree ).setBtreeInfoOffset( btreeInfoOffset );\n+\n+            // Serialize the B-tree root page\n+            Page<K, V> rootPage = btreeHeader.getRootPage();\n+\n+            PageIO[] rootPageIos = serializePage( btree, btreeHeader.getRevision(), rootPage );\n+\n+            // Get the reference on the first page\n+            long rootPageOffset = rootPageIos[0].getOffset();\n+\n+            // Store the rootPageOffset into the Btree header and into the rootPage\n+            btreeHeader.setRootPageOffset( rootPageOffset );\n+            ( ( PersistedLeaf<K, V> ) rootPage ).setOffset( rootPageOffset );\n+\n+            LOG.debug( \"Flushing the newly managed '{}' btree rootpage\", btree.getName() );\n+            flushPages( rootPageIos );\n+\n+            // And the B-tree header\n+            long btreeHeaderOffset = writeBtreeHeader( btree, btreeHeader );\n+\n+            // Now, if this is a new B-tree, add it to the B-tree of B-trees\n+            // Add the btree into the map of managed B-trees\n+            managedBtrees.put( name, ( BTree<Object, Object> ) btree );\n+\n+            // And in the Map of currentBtreeHeaders and newBtreeHeaders\n+            currentBTreeHeaders.put( name, btreeHeader );\n+            newBTreeHeaders.put( name, btreeHeader );\n+\n+            // We can safely increment the number of managed B-trees\n+            nbBtree++;\n+\n+            // Create the new NameRevision\n+            NameRevision nameRevision = new NameRevision( name, 0L );\n+\n+            // Inject it into the B-tree of B-tree\n+            btreeOfBtrees.insert( nameRevision, btreeHeaderOffset );\n+            commit();\n+        }\n+        catch ( IOException ioe )\n+        {\n+            rollback();\n+            throw ioe;\n+        }\n     }\n \n \n@@ -1433,22 +1497,22 @@ private byte readByte( PageIO[] pageIos, long position )\n      * @throws BTreeAlreadyManagedException If the B-tree is already managed\n      * @throws IOException\n      */\n-    public synchronized <K, V> void manage( BTree<K, V> btree, boolean treeType )\n+    public synchronized <K, V> void manageSubBtree( BTree<K, V> btree )\n         throws BTreeAlreadyManagedException, IOException\n     {\n-        LOG.debug( \"Managing the btree {} which is an internam tree : {}\", btree.getName(), treeType );\n+        LOG.debug( \"Managing the sub-btree {}\", btree.getName() );\n         BTreeFactory.setRecordManager( btree, this );\n \n         String name = btree.getName();\n \n         if ( managedBtrees.containsKey( name ) )\n         {\n-            // There is already a B-tree with this name in the recordManager...\n-            LOG.error( \"There is already a B-tree named '{}' managed by this recordManager\", name );\n+            // There is already a subB-tree with this name in the recordManager...\n+            LOG.error( \"There is already a sub-B-tree named '{}' managed by this recordManager\", name );\n             throw new BTreeAlreadyManagedException( name );\n         }\n \n-        // Now, write the B-tree informations\n+        // Now, write the subB-tree informations\n         long btreeInfoOffset = writeBtreeInfo( btree );\n         BTreeHeader<K, V> btreeHeader = ( ( AbstractBTree<K, V> ) btree ).getBtreeHeader();\n         ( ( PersistedBTree<K, V> ) btree ).setBtreeInfoOffset( btreeInfoOffset );\n@@ -1463,7 +1527,8 @@ private byte readByte( PageIO[] pageIos, long position )\n \n         // Store the rootPageOffset into the Btree header and into the rootPage\n         btreeHeader.setRootPageOffset( rootPageOffset );\n-        ( ( PersistedLeaf<K, V> ) rootPage ).setOffset( rootPageOffset );\n+\n+        ( ( AbstractPage<K, V> ) rootPage ).setOffset( rootPageOffset );\n \n         LOG.debug( \"Flushing the newly managed '{}' btree rootpage\", btree.getName() );\n         flushPages( rootPageIos );\n@@ -1472,24 +1537,29 @@ private byte readByte( PageIO[] pageIos, long position )\n         long btreeHeaderOffset = writeBtreeHeader( btree, btreeHeader );\n \n         // Now, if this is a new B-tree, add it to the B-tree of B-trees\n-        if ( treeType != INTERNAL_BTREE )\n+        // Add the btree into the map of managed B-trees\n+        if ( ( btree.getType() != BTreeTypeEnum.BTREE_OF_BTREES ) && ( btree.getType() != BTreeTypeEnum.PERSISTED_SUB ) )\n         {\n-            // Add the btree into the map of managed B-trees\n             managedBtrees.put( name, ( BTree<Object, Object> ) btree );\n+        }\n \n-            // And in the Map of currentBtreeHeaders and newBtreeHeaders\n-            currentBTreeHeaders.put( name, btreeHeader );\n-            newBTreeHeaders.put( name, btreeHeader );\n+        // And in the Map of currentBtreeHeaders and newBtreeHeaders\n+        currentBTreeHeaders.put( name, btreeHeader );\n+        newBTreeHeaders.put( name, btreeHeader );\n+\n+        // Create the new NameRevision\n+        NameRevision nameRevision = new NameRevision( name, 0L );\n \n+        // Inject it into the B-tree of B-tree\n+        if ( ( btree.getType() != BTreeTypeEnum.BTREE_OF_BTREES ) && ( btree.getType() != BTreeTypeEnum.PERSISTED_SUB ) )\n+        {\n             // We can safely increment the number of managed B-trees\n             nbBtree++;\n \n-            // Create the new NameRevision\n-            NameRevision nameRevision = new NameRevision( name, 0L );\n-\n-            // Inject it into the B-tree of B-tree\n             btreeOfBtrees.insert( nameRevision, btreeHeaderOffset );\n         }\n+\n+        updateRecordManagerHeader();\n     }\n \n \n@@ -1692,6 +1762,15 @@ private byte readByte( PageIO[] pageIos, long position )\n         int dataSize = 0;\n         int nbValues = valueHolder.size();\n \n+        if ( nbValues == 0 )\n+        {\n+            // No value.\n+            byte[] buffer = IntSerializer.serialize( nbValues );\n+            serializedData.add( buffer );\n+\n+            return buffer.length;\n+        }\n+\n         if ( !valueHolder.isSubBtree() )\n         {\n             // Write the nb elements first\n@@ -1716,47 +1795,15 @@ private byte readByte( PageIO[] pageIos, long position )\n         }\n         else\n         {\n-            if ( nbValues == 0 )\n-            {\n-                // No value.\n-                byte[] buffer = IntSerializer.serialize( nbValues );\n-                serializedData.add( buffer );\n-\n-                return buffer.length;\n-            }\n-\n-            if ( valueHolder.isSubBtree() )\n-            {\n-                // Store the nbVlues as a negative number. We add 1 so that 0 is not confused with an Array value\n-                byte[] buffer = IntSerializer.serialize( -( nbValues + 1 ) );\n-                serializedData.add( buffer );\n-                dataSize += buffer.length;\n-\n-                // the B-tree offset\n-                buffer = LongSerializer.serialize( ( ( PersistedValueHolder<V> ) valueHolder ).getOffset() );\n-                serializedData.add( buffer );\n-                dataSize += buffer.length;\n-            }\n-            else\n-            {\n-                // This is an array, store the nb of values as a positive number\n-                byte[] buffer = IntSerializer.serialize( nbValues );\n-                serializedData.add( buffer );\n-                dataSize += buffer.length;\n-\n-                // Now store each value\n-                byte[] data = ( ( PersistedValueHolder<V> ) valueHolder ).getRaw();\n-                buffer = IntSerializer.serialize( data.length );\n-                serializedData.add( buffer );\n-                dataSize += buffer.length;\n-\n-                if ( data.length > 0 )\n-                {\n-                    serializedData.add( data );\n-                }\n+            // Store the nbVlues as a negative number. We add 1 so that 0 is not confused with an Array value\n+            byte[] buffer = IntSerializer.serialize( -( nbValues + 1 ) );\n+            serializedData.add( buffer );\n+            dataSize += buffer.length;\n \n-                dataSize += data.length;\n-            }\n+            // the B-tree offset\n+            buffer = LongSerializer.serialize( ( ( PersistedValueHolder<V> ) valueHolder ).getOffset() );\n+            serializedData.add( buffer );\n+            dataSize += buffer.length;\n         }\n \n         return dataSize;\n@@ -2926,8 +2973,6 @@ private int computeNbPages( int dataSize )\n      */\n     private PageIO fetchNewPage() throws IOException\n     {\n-        //dumpFreePages( firstFreePage );\n-\n         if ( firstFreePage == NO_PAGE )\n         {\n             nbCreatedPages.incrementAndGet();", "filename": "mavibot/src/main/java/org/apache/directory/mavibot/btree/RecordManager.java"}, {"additions": 14, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java", "sha": "841f5a11718a3b0262d57783d39f65b23190b577", "changes": 70, "status": "modified", "deletions": 56, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -150,7 +150,7 @@ public void testInMemoryBulkLoad8Elements() throws IOException, KeyNotFoundExcep\n     public void testPersistedBulkLoad1000Elements() throws IOException, KeyNotFoundException,\n         BTreeAlreadyManagedException\n     {\n-        for ( int i = 0; i < 1001; i++ )\n+        for ( int i = 1000000; i < 1000001; i++ )\n         {\n             Random random = new Random( System.currentTimeMillis() );\n             File file = File.createTempFile( \"managedbtreebuilder\", \".data\" );\n@@ -161,6 +161,7 @@ public void testPersistedBulkLoad1000Elements() throws IOException, KeyNotFoundE\n                 RecordManager rm = new RecordManager( file.getAbsolutePath() );\n                 PersistedBTree<Long, String> btree = ( PersistedBTree<Long, String> ) rm.addBTree( \"test\",\n                     LongSerializer.INSTANCE, StringSerializer.INSTANCE, false );\n+                btree.setPageSize( 64 );\n \n                 int nbElems = i;\n                 int addedElems = 0;\n@@ -193,12 +194,8 @@ public void testPersistedBulkLoad1000Elements() throws IOException, KeyNotFoundE\n                     expectedTuple.value.add( value );\n                     expected.put( key, expectedTuple );\n                     addedElems++;\n-\n-                    if ( addedElems % 100 == 0 )\n-                    {\n-                        //System.out.println( \"Nb added elements = \" + addedElems );\n-                    }\n                 }\n+\n                 long t01 = System.currentTimeMillis();\n \n                 // System.out.println( \"Time to create the \" + nbElems + \" elements \" + ( ( t01 - t00 ) / 1 ) );\n@@ -229,10 +226,10 @@ public void remove()\n                 };\n \n                 long t0 = System.currentTimeMillis();\n-                BTree<Long, String> result = BulkLoader.load( btree, tupleIterator, 128 );\n+                BTree<Long, String> result = BulkLoader.load( btree, tupleIterator, 1024000 );\n                 long t1 = System.currentTimeMillis();\n \n-                if ( i % 100 == 0 )\n+                if ( ( i % 100 ) == 0 )\n                 {\n                     System.out.println( \"== Btree #\" + i + \", Time to bulkoad the \" + nbElems + \" elements \"\n                         + ( t1 - t0 ) + \"ms\" );\n@@ -451,10 +448,6 @@ public void testPersistedBulkLoadComputeLeafLevel() throws IOException, KeyNotFo\n \n             for ( int i = 0; i < 49; i++ )\n             {\n-                System.out.println( \"=======================================\" );\n-                System.out.println( \"== Iteration n#\" + i );\n-                System.out.println( \"=======================================\" );\n-\n                 LevelInfo<Long, String> leafInfo = BulkLoader.computeLevel( btree, i, LevelEnum.LEAF );\n \n                 assertEquals( expectedNbPages[i], leafInfo.getNbPages() );\n@@ -510,10 +503,6 @@ public void testPersistedBulkLoadComputeNodeLevel() throws IOException, KeyNotFo\n \n             for ( int i = 2; i < 52; i++ )\n             {\n-                System.out.println( \"=======================================\" );\n-                System.out.println( \"== Iteration n#\" + i );\n-                System.out.println( \"=======================================\" );\n-\n                 LevelInfo<Long, String> nodeInfo = BulkLoader.computeLevel( btree, i, LevelEnum.NODE );\n \n                 assertEquals( expectedNbPages[i], nodeInfo.getNbPages() );\n@@ -569,10 +558,6 @@ public void testPersistedBulkLoadComputeLevels() throws IOException, KeyNotFound\n \n             for ( int i = 2599; i <= 2599; i++ )\n             {\n-                System.out.println( \"=======================================\" );\n-                System.out.println( \"== Iteration #\" + i );\n-                System.out.println( \"=======================================\" );\n-\n                 List<LevelInfo<Long, String>> levels = BulkLoader.computeLevels( btree, i );\n \n                 for ( LevelInfo<Long, String> level : levels )\n@@ -592,7 +577,7 @@ public void testPersistedBulkLoadComputeLevels() throws IOException, KeyNotFound\n      * Test that we can load 100 BTrees with 0 to 1000 elements, each one of them having multiple values\n      * @throws BTreeAlreadyManagedException \n      */\n-    @Ignore(\"The test is failing atm due to the sub-btree construction which is not working correctly when we have too many elements\")\n+    //@Ignore(\"The test is failing atm due to the sub-btree construction which is not working correctly when we have too many elements\")\n     @Test\n     public void testPersistedBulkLoad1000ElementsMultipleValues() throws IOException, KeyNotFoundException,\n         BTreeAlreadyManagedException\n@@ -672,24 +657,11 @@ public void remove()\n                 };\n \n                 long t0 = System.currentTimeMillis();\n-                BTree<Long, String> result = null;\n-\n-                try\n-                {\n-                    result = BulkLoader.load( btree, tupleIterator, 128 );\n-                }\n-                catch ( NullPointerException npe )\n-                {\n-                    System.out.println( \"Error with : \" );\n-                    for ( int j = 0; j < i; j++ )\n-                    {\n-                        System.out.println( elems[j] );\n-                    }\n-                }\n+                BTree<Long, String> result = BulkLoader.load( btree, tupleIterator, 128 );\n                 long t1 = System.currentTimeMillis();\n \n-                System.out.println( \"== Btree #\" + i + \", Time to bulkoad the \" + nbElems + \" elements \"\n-                    + ( t1 - t0 ) + \"ms\" );\n+                //System.out.println( \"== Btree #\" + i + \", Time to bulkoad the \" + nbElems + \" elements \"\n+                //    + ( t1 - t0 ) + \"ms\" );\n \n                 TupleCursor<Long, String> cursor = result.browse();\n                 int nbFetched = 0;\n@@ -793,19 +765,8 @@ public void remove()\n \n             long t0 = System.currentTimeMillis();\n             BTree<Long, String> result = null;\n-            try\n-            {\n-                result = BulkLoader.load( btree, tupleIterator, 128 );\n-            }\n-            catch ( NullPointerException npe )\n-            {\n-                npe.printStackTrace();\n-                System.out.println( \"Error with : \" );\n-                for ( int j = 0; j < 4; j++ )\n-                {\n-                    System.out.println( elems[j] );\n-                }\n-            }\n+\n+            result = BulkLoader.load( btree, tupleIterator, 128 );\n             long t1 = System.currentTimeMillis();\n \n             System.out.println( \"== Btree #\" + 4 + \", Time to bulkoad the \" + nbElems + \" elements \"\n@@ -819,10 +780,6 @@ public void remove()\n             while ( cursor.hasNext() )\n             {\n                 Tuple<Long, String> elem = cursor.next();\n-\n-                assertTrue( expected.containsKey( elem.key ) );\n-                Tuple<Long, Set<String>> tuple = expected.get( elem.key );\n-                assertNotNull( tuple );\n                 nbFetched++;\n             }\n \n@@ -856,7 +813,7 @@ public void testDebug() throws IOException\n         listTuples.add( new Tuple<Long, String>( 32L, \"V8\" ) );\n         listTuples.add( new Tuple<Long, String>( -21L, \"V9\" ) );\n         listTuples.add( new Tuple<Long, String>( 9L, \"V10\" ) );\n-        //listTuples.add( new Tuple<Long, String>( 0L, \"V11\" ) );\n+        listTuples.add( new Tuple<Long, String>( 0L, \"V11\" ) );\n         listTuples.add( new Tuple<Long, String>( -7L, \"V12\" ) );\n         listTuples.add( new Tuple<Long, String>( -13L, \"V13\" ) );\n         listTuples.add( new Tuple<Long, String>( 23L, \"V14\" ) );\n@@ -1222,6 +1179,7 @@ public void remove()\n                     prev = elem;\n                     elem = cursor.next();\n                     nbFetched++;\n+                    System.out.println( elem );\n                 }\n             }\n             catch ( Exception e )\n@@ -1234,7 +1192,7 @@ public void remove()\n         }\n         catch ( Exception e )\n         {\n-\n+            e.printStackTrace();\n         }\n     }\n }", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/BulkLoaderTest.java"}, {"additions": 4, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java", "sha": "49bb731d194dab727afabc06c06ccea25bff90b5", "changes": 7, "status": "modified", "deletions": 3, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -1193,7 +1193,8 @@ private void addPage( BTree<Integer, String> btree, InMemoryNode<Integer, String\n      * @param element The removed element\n      * @param expected The expected set of elements\n      */\n-    private void checkRemoval( BTree<Integer, String> btree, int element, Set<Integer> expected ) throws IOException, KeyNotFoundException\n+    private void checkRemoval( BTree<Integer, String> btree, int element, Set<Integer> expected ) throws IOException,\n+        KeyNotFoundException\n     {\n         Tuple<Integer, String> removed = btree.delete( element );\n         assertEquals( element, removed.getKey().intValue() );\n@@ -1983,7 +1984,7 @@ public void testCheckRootPageContents() throws Exception\n         btree.close();\n     }\n \n-    \n+\n     /**\n      * Test the overwriting of elements\n      */\n@@ -1999,7 +2000,7 @@ public void testOverwrite() throws Exception\n         assertTrue( btree.hasKey( 1 ) );\n \n         assertEquals( Integer.valueOf( 1 ), btree.get( 1 ) );\n-        \n+\n         btree.insert( 1, 10 );\n \n         assertTrue( btree.hasKey( 1 ) );", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBTreeTest.java"}, {"additions": 12, "raw_url": "https://github.com/apache/directory-mavibot/raw/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedSubBtreeKeyCursorTest.java", "blob_url": "https://github.com/apache/directory-mavibot/blob/9e83907abe9e77008a8589ff2366670a296b4dcb/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedSubBtreeKeyCursorTest.java", "sha": "0d5d81ff1157a9caaaa757cf931b5120492101a1", "changes": 21, "status": "modified", "deletions": 9, "contents_url": "https://api.github.com/repos/apache/directory-mavibot/contents/mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedSubBtreeKeyCursorTest.java?ref=9e83907abe9e77008a8589ff2366670a296b4dcb", "patch": "@@ -19,6 +19,7 @@\n  */\n package org.apache.directory.mavibot.btree;\n \n+\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n@@ -35,6 +36,7 @@\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n \n+\n /**\n  * Tests for KeyCursor of a persisted sub-Btree.\n  *\n@@ -71,7 +73,7 @@ public void createBTree() throws IOException\n \n             btree = BTreeFactory.createPersistedBTree( configuration );\n \n-            recordManager.manage( btree, RecordManager.INTERNAL_BTREE );\n+            recordManager.manage( btree );\n         }\n         catch ( Exception e )\n         {\n@@ -91,33 +93,34 @@ public void cleanup() throws IOException\n         {\n             FileUtils.deleteDirectory( dataDir );\n         }\n-        \n+\n         recordManager.close();\n         assertTrue( recordManager.isContextOk() );\n     }\n \n+\n     @Test\n     public void testBrowseKeys() throws Exception\n     {\n-        for( int i=0; i< 10; i++ )\n+        for ( int i = 0; i < 10; i++ )\n         {\n             // only the keys are stored, values are ignored\n             btree.insert( i, i );\n         }\n-        \n+\n         KeyCursor<Integer> cursor = btree.browseKeys();\n-        \n-        for( int i=0; i< 10; i++ )\n+\n+        for ( int i = 0; i < 10; i++ )\n         {\n             assertTrue( cursor.hasNext() );\n             assertEquals( String.valueOf( i ), String.valueOf( cursor.next() ) );\n         }\n-        \n+\n         assertFalse( cursor.hasNext() );\n \n         cursor.afterLast();\n-        \n-        for( int i=9; i>= 0; i-- )\n+\n+        for ( int i = 9; i >= 0; i-- )\n         {\n             assertTrue( cursor.hasPrev() );\n             assertEquals( String.valueOf( i ), String.valueOf( cursor.prev() ) );", "filename": "mavibot/src/test/java/org/apache/directory/mavibot/btree/PersistedSubBtreeKeyCursorTest.java"}], "repo": "directory-mavibot"}]
