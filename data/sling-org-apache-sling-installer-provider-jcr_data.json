[
    {
        "repo": "sling-org-apache-sling-installer-provider-jcr",
        "message": "SLING-4486 : Potential NPE when service is deactivate immediately\n\ngit-svn-id: https://svn.apache.org/repos/asf/sling/trunk@1665447 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/commit/991cbdc3ad41e6a539c5b65f85cc283511220632",
        "parent": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/commit/5f449be9791ba5828b36bc9261558dfb97b9fa3b",
        "bug_id": "sling-org-apache-sling-installer-provider-jcr_1",
        "file": [
            {
                "sha": "6b62d0ebfb7bd9607cfa964f90a2af89491bd091",
                "filename": "src/main/java/org/apache/sling/installer/provider/jcr/impl/JcrInstaller.java",
                "blob_url": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/blob/991cbdc3ad41e6a539c5b65f85cc283511220632/src/main/java/org/apache/sling/installer/provider/jcr/impl/JcrInstaller.java",
                "raw_url": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/raw/991cbdc3ad41e6a539c5b65f85cc283511220632/src/main/java/org/apache/sling/installer/provider/jcr/impl/JcrInstaller.java",
                "status": "modified",
                "changes": 184,
                "additions": 101,
                "contents_url": "https://api.github.com/repos/apache/sling-org-apache-sling-installer-provider-jcr/contents/src/main/java/org/apache/sling/installer/provider/jcr/impl/JcrInstaller.java?ref=991cbdc3ad41e6a539c5b65f85cc283511220632",
                "patch": "@@ -148,42 +148,42 @@\n     public static final String PROP_SEARCH_PATH = \"sling.jcrinstall.search.path\";\n     public static final String [] DEFAULT_SEARCH_PATH = { \"/libs:100\", \"/apps:200\" };\n \n-    private int maxWatchedFolderDepth;\n+    private volatile int maxWatchedFolderDepth;\n \n     /** Filter for folder names */\n-    private FolderNameFilter folderNameFilter;\n+    private volatile FolderNameFilter folderNameFilter;\n \n     /** List of watched folders */\n-    private List<WatchedFolder> watchedFolders;\n+    private volatile List<WatchedFolder> watchedFolders;\n \n     /** Session shared by all WatchedFolder */\n-    private Session session;\n+    private volatile Session session;\n \n     /** The root folders that we watch */\n-    private String [] roots;\n+    private volatile String [] roots;\n \n     /** The component context. */\n-    private ComponentContext componentContext;\n+    private volatile ComponentContext componentContext;\n \n     /** Service reg for managed service. */\n-    private ServiceRegistration managedServiceRef;\n+    private volatile ServiceRegistration managedServiceRef;\n \n     /** Configuration from managed service (old pid) */\n-    private Dictionary<?, ?> oldConfiguration;\n+    private volatile Dictionary<?, ?> oldConfiguration;\n \n     private static final String DEFAULT_NEW_CONFIG_PATH = \"sling/install\";\n     @Property(value=DEFAULT_NEW_CONFIG_PATH)\n     private static final String PROP_NEW_CONFIG_PATH = \"sling.jcrinstall.new.config.path\";\n \n     /** The path for new configurations. */\n-    private String newConfigPath;\n+    private volatile String newConfigPath;\n \n     public static final String PAUSE_SCAN_NODE_PATH = \"/system/sling/installer/jcr/pauseInstallation\";\n     @Property(value= PAUSE_SCAN_NODE_PATH)\n     private static final String PROP_SCAN_PROP_PATH = \"sling.jcrinstall.signal.path\";\n \n     /** The path for pauseInstallation property */\n-    private String pauseScanNodePath;\n+    private volatile String pauseScanNodePath;\n \n     private volatile boolean pauseMessageLogged = false;\n \n@@ -192,9 +192,9 @@\n     private static final String PROP_ENABLE_WRITEBACK = \"sling.jcrinstall.enable.writeback\";\n \n     /** Write back enabled? */\n-    private boolean writeBack;\n+    private volatile boolean writeBack;\n \n-    private EventListener moveEventListener;\n+    private volatile EventListener moveEventListener;\n \n     /** Convert Nodes to InstallableResources */\n     static interface NodeConverter {\n@@ -212,7 +212,7 @@ InstallableResource convertNode(Node n, int priority)\n     private final RescanTimer updateFoldersListTimer = new RescanTimer();\n \n     /** Thread that can be cleanly stopped with a flag */\n-    static int bgThreadCounter;\n+    static volatile int bgThreadCounter;\n     class StoppableThread extends Thread {\n \n         /** Used for synchronizing. */\n@@ -229,96 +229,113 @@ InstallableResource convertNode(Node n, int priority)\n         @Override\n         public final void run() {\n             logger.info(\"Background thread {} starting\", Thread.currentThread().getName());\n-            try {\n-                // open session\n-                session = repository.loginAdministrative(repository.getDefaultWorkspace());\n-\n-                for (String path : roots) {\n-                    listeners.add(new RootFolderListener(session, folderNameFilter, path, updateFoldersListTimer));\n-                    logger.debug(\"Configured root folder: {}\", path);\n-                }\n+            synchronized ( this.lock ) {\n+                if ( this.active ) {\n+                    try {\n+                        // open session\n+                        session = repository.loginAdministrative(repository.getDefaultWorkspace());\n+\n+                        for (String path : roots) {\n+                            listeners.add(new RootFolderListener(session, folderNameFilter, path, updateFoldersListTimer));\n+                            logger.debug(\"Configured root folder: {}\", path);\n+                        }\n \n-                // Watch for events on the root - that might be one of our root folders\n-                session.getWorkspace().getObservationManager().addEventListener(JcrInstaller.this,\n-                        Event.NODE_ADDED | Event.NODE_REMOVED,\n-                        \"/\",\n-                        false, // isDeep\n-                        null,\n-                        null,\n-                        true); // noLocal\n-                // add special observation listener for move events\n-                JcrInstaller.this.moveEventListener = new EventListener() {\n-\n-                    /**\n-                     * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)\n-                     */\n-                    public void onEvent(final EventIterator events) {\n-                        try {\n-                            while (events.hasNext()) {\n-                                final Event e = events.nextEvent();\n-                                JcrInstaller.this.checkChanges(e.getIdentifier());\n-                                JcrInstaller.this.checkChanges(e.getPath());\n+                        // Watch for events on the root - that might be one of our root folders\n+                        session.getWorkspace().getObservationManager().addEventListener(JcrInstaller.this,\n+                                Event.NODE_ADDED | Event.NODE_REMOVED,\n+                                \"/\",\n+                                false, // isDeep\n+                                null,\n+                                null,\n+                                true); // noLocal\n+                        // add special observation listener for move events\n+                        JcrInstaller.this.moveEventListener = new EventListener() {\n+\n+                            /**\n+                             * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)\n+                             */\n+                            public void onEvent(final EventIterator events) {\n+                                try {\n+                                    while (events.hasNext()) {\n+                                        final Event e = events.nextEvent();\n+                                        JcrInstaller.this.checkChanges(e.getIdentifier());\n+                                        JcrInstaller.this.checkChanges(e.getPath());\n+                                    }\n+                                } catch (final RepositoryException re) {\n+                                    logger.warn(\"RepositoryException in onEvent\", re);\n+                                }\n                             }\n-                        } catch (final RepositoryException re) {\n-                            logger.warn(\"RepositoryException in onEvent\", re);\n+                        };\n+                        session.getWorkspace().getObservationManager().addEventListener(\n+                                moveEventListener,\n+                                Event.NODE_MOVED,\n+                                \"/\",\n+                                true, // isDeep\n+                                null,\n+                                null,\n+                                true); // noLocal\n+\n+                        logger.debug(\"Watching for node events on / to detect removal/add of our root folders\");\n+\n+\n+                        // Find paths to watch and create WatchedFolders to manage them\n+                        watchedFolders = new LinkedList<WatchedFolder>();\n+                        for(String root : roots) {\n+                            findPathsToWatch(root, watchedFolders);\n+                        }\n+\n+                        // Scan watchedFolders and register resources with installer\n+                        for(final WatchedFolder f : watchedFolders) {\n+                            f.start();\n+                        }\n+                    } catch (final RepositoryException re) {\n+                        logger.error(\"Repository exception during startup - deactivating installer!\", re);\n+                        active = false;\n+                        final ComponentContext ctx = componentContext;\n+                        if ( ctx  != null ) {\n+                            final String name = (String) componentContext.getProperties().get(\n+                                    ComponentConstants.COMPONENT_NAME);\n+                            ctx.disableComponent(name);\n                         }\n                     }\n-                };\n-                session.getWorkspace().getObservationManager().addEventListener(\n-                        moveEventListener,\n-                        Event.NODE_MOVED,\n-                        \"/\",\n-                        true, // isDeep\n-                        null,\n-                        null,\n-                        true); // noLocal\n-\n-                logger.debug(\"Watching for node events on / to detect removal/add of our root folders\");\n-\n-\n-                // Find paths to watch and create WatchedFolders to manage them\n-                watchedFolders = new LinkedList<WatchedFolder>();\n-                for(String root : roots) {\n-                    findPathsToWatch(root, watchedFolders);\n                 }\n+            }\n \n-                // Scan watchedFolders and register resources with installer\n+            if ( this.active ) {\n                 final List<InstallableResource> resources = new LinkedList<InstallableResource>();\n-                for(WatchedFolder f : watchedFolders) {\n-                    f.start();\n-                    final WatchedFolder.ScanResult r = f.scan();\n-                    logger.debug(\"Startup: {} provides resources {}\", f, r.toAdd);\n-                    resources.addAll(r.toAdd);\n+                for(final WatchedFolder f : watchedFolders) {\n+                    if ( this.active ) {\n+                        try {\n+                            final WatchedFolder.ScanResult r = f.scan();\n+                            logger.debug(\"Startup: {} provides resources {}\", f, r.toAdd);\n+                            resources.addAll(r.toAdd);\n+                        } catch (final RepositoryException re) {\n+                            if ( this.active ) {\n+                                logger.error(\"Repository exception during scanning.\", re);\n+                            }\n+                        }\n+                    }\n                 }\n \n-                logger.debug(\"Registering {} resources with OSGi installer: {}\", resources.size(), resources);\n-                installer.registerResources(URL_SCHEME, resources.toArray(new InstallableResource[resources.size()]));\n-            } catch (final RepositoryException re) {\n-                logger.error(\"Repository exception during startup - deactivating installer!\", re);\n-                active = false;\n-                final ComponentContext ctx = componentContext;\n-                if ( ctx  != null ) {\n-                    final String name = (String) componentContext.getProperties().get(\n-                            ComponentConstants.COMPONENT_NAME);\n-                    ctx.disableComponent(name);\n+                if ( this.active ) {\n+                    logger.debug(\"Registering {} resources with OSGi installer: {}\", resources.size(), resources);\n+                    installer.registerResources(URL_SCHEME, resources.toArray(new InstallableResource[resources.size()]));\n                 }\n             }\n+\n             while (active) {\n                 runOneCycle();\n             }\n             logger.info(\"Background thread {} done\", Thread.currentThread().getName());\n             counters[RUN_LOOP_COUNTER] = -1;\n         }\n     };\n-    private StoppableThread backgroundThread;\n+    private volatile StoppableThread backgroundThread;\n \n     /**\n      * Activate this component.\n      */\n     protected void activate(final ComponentContext context) {\n-        if (backgroundThread != null) {\n-            throw new IllegalStateException(\"Expected backgroundThread to be null in activate()\");\n-        }\n         this.componentContext = context;\n         this.start();\n         final Dictionary<String, Object> props = new Hashtable<String, Object>();\n@@ -403,9 +420,6 @@ private void stop() {\n             backgroundThread = null;\n     \t}\n \n-        folderNameFilter = null;\n-        watchedFolders = null;\n-        converters.clear();\n         try {\n             if (session != null) {\n                 for(RootFolderListener wfc : listeners) {\n@@ -425,6 +439,10 @@ private void stop() {\n             session = null;\n         }\n         listeners.clear();\n+\n+        folderNameFilter = null;\n+        watchedFolders = null;\n+        converters.clear();\n     }\n \n ",
                "deletions": 83
            }
        ]
    },
    {
        "repo": "sling-org-apache-sling-installer-provider-jcr",
        "message": "SLING-1956 : ConfigNodeConverter throws NPE on config with empty multi-valued property\n\ngit-svn-id: https://svn.apache.org/repos/asf/sling/trunk@1063645 13f79535-47bb-0310-9956-ffa450edef68",
        "commit": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/commit/d3aa61dbfd901e62d0d7f4455cdbab69a60124f9",
        "parent": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/commit/a142a8152205b61d9455192e760eb732318e3b7b",
        "bug_id": "sling-org-apache-sling-installer-provider-jcr_2",
        "file": [
            {
                "sha": "48209165ddec983baa0a13483cc55134e2cc4062",
                "filename": "src/main/java/org/apache/sling/installer/provider/jcr/impl/ConfigNodeConverter.java",
                "blob_url": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/blob/d3aa61dbfd901e62d0d7f4455cdbab69a60124f9/src/main/java/org/apache/sling/installer/provider/jcr/impl/ConfigNodeConverter.java",
                "raw_url": "https://github.com/apache/sling-org-apache-sling-installer-provider-jcr/raw/d3aa61dbfd901e62d0d7f4455cdbab69a60124f9/src/main/java/org/apache/sling/installer/provider/jcr/impl/ConfigNodeConverter.java",
                "status": "modified",
                "changes": 36,
                "additions": 21,
                "contents_url": "https://api.github.com/repos/apache/sling-org-apache-sling-installer-provider-jcr/contents/src/main/java/org/apache/sling/installer/provider/jcr/impl/ConfigNodeConverter.java?ref=d3aa61dbfd901e62d0d7f4455cdbab69a60124f9",
                "patch": "@@ -89,41 +89,47 @@ protected void loadProperties(Dictionary<String, Object> d, Node n) throws Repos\n             if(name.contains(\":\")) {\n                 continue;\n             }\n-            if(p.getDefinition().isMultiple()) {\n+            if (p.getDefinition().isMultiple()) {\n                 Object [] data = null;\n                 final Value [] values = p.getValues();\n                 int i = 0;\n-                for(Value v : values) {\n+                for (Value v : values) {\n                     Object o = convertValue(v);\n-                    if(i == 0) {\n+                    if (i == 0) {\n                         data = (Object[])Array.newInstance(o.getClass(), values.length);\n                     }\n                     data[i++] = o;\n                 }\n+                // create empty array in case no value is specified\n+                if ( data == null ) {\n+                    data = new String[0];\n+                }\n                 d.put(name, data);\n \n             } else {\n                 final Object o = convertValue(p.getValue());\n-                if(o != null) {\n+                if (o != null) {\n                     d.put(name, o);\n                 }\n             }\n         }\n     }\n \n-    /** Convert v according to its type */\n+    /**\n+     * Convert v according to its type.\n+     */\n     protected Object convertValue(Value v) throws RepositoryException {\n         switch(v.getType()) {\n-        case PropertyType.STRING:\n-            return v.getString();\n-        case PropertyType.DATE:\n-            return v.getDate();\n-        case PropertyType.DOUBLE:\n-            return v.getDouble();\n-        case PropertyType.LONG:\n-            return v.getLong();\n-        case PropertyType.BOOLEAN:\n-            return v.getBoolean();\n+            case PropertyType.STRING:\n+                return v.getString();\n+            case PropertyType.DATE:\n+                return v.getDate();\n+            case PropertyType.DOUBLE:\n+                return v.getDouble();\n+            case PropertyType.LONG:\n+                return v.getLong();\n+            case PropertyType.BOOLEAN:\n+                return v.getBoolean();\n         }\n         log.debug(\"Value of type {} ignored\", v.getType());\n         return null;",
                "deletions": 15
            }
        ]
    }
]