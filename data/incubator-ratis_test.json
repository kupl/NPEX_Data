{
    "incubator-ratis_008c009": {
        "repo": "incubator-ratis",
        "message": "RATIS-577. NPE in LogAppender while creating a new request.",
        "commit": "https://github.com/apache/incubator-ratis/commit/008c0093fed0cfd7e53b7d455621e1ec794d6f38",
        "parent": "https://github.com/apache/incubator-ratis/commit/300d9c53c4b77e16ddd5d68dcf6c792d52a94a02",
        "bug_id": "incubator-ratis_008c009",
        "file": [
            {
                "sha": "1586ecb79ed219959d9a87f1cb38d8a793676103",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/008c0093fed0cfd7e53b7d455621e1ec794d6f38/ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/008c0093fed0cfd7e53b7d455621e1ec794d6f38/ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java",
                "status": "modified",
                "changes": 7,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/raftlog/segmented/SegmentedRaftLog.java?ref=008c0093fed0cfd7e53b7d455621e1ec794d6f38",
                "patch": "@@ -178,8 +178,8 @@ private void loadLogSegments(long lastIndexInSnapshot,\n   @Override\n   public LogEntryProto get(long index) throws RaftLogIOException {\n     checkLogState();\n-    LogSegment segment;\n-    LogRecordWithEntry recordAndEntry;\n+    final LogSegment segment;\n+    final LogRecordWithEntry recordAndEntry;\n     try (AutoCloseableLock readLock = readLock()) {\n       segment = cache.getSegment(index);\n       if (segment == null) {\n@@ -203,6 +203,9 @@ public LogEntryProto get(long index) throws RaftLogIOException {\n   @Override\n   public EntryWithData getEntryWithData(long index) throws RaftLogIOException {\n     final LogEntryProto entry = get(index);\n+    if (entry == null) {\n+      throw new RaftLogIOException(\"Log entry not found: index = \" + index);\n+    }\n     if (!ServerProtoUtils.shouldReadStateMachineData(entry)) {\n       return new EntryWithData(entry, null);\n     }",
                "deletions": 2
            }
        ],
        "patched_files": [
            "SegmentedRaftLog.java"
        ],
        "unit_tests": [
            "TestSegmentedRaftLog.java"
        ]
    },
    "incubator-ratis_8ef7b48": {
        "repo": "incubator-ratis",
        "message": "RATIS-361. Fix the NPE bug in MemoryRaftLog.",
        "commit": "https://github.com/apache/incubator-ratis/commit/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0",
        "parent": "https://github.com/apache/incubator-ratis/commit/ce783995f6612fa76f24a59c23e5964a4bf434a1",
        "bug_id": "incubator-ratis_8ef7b48",
        "file": [
            {
                "sha": "2661ba8c6eb0a7e911e85e0e90db0beb42e3bb84",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java",
                "status": "modified",
                "changes": 68,
                "additions": 43,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/storage/MemoryRaftLog.java?ref=8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0",
                "patch": "@@ -30,12 +30,40 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n \n /**\n  * A simple RaftLog implementation in memory. Used only for testing.\n  */\n public class MemoryRaftLog extends RaftLog {\n-  private final List<LogEntryProto> entries = new ArrayList<>();\n+  static class EntryList {\n+    private final List<LogEntryProto> entries = new ArrayList<>();\n+\n+    LogEntryProto get(int i) {\n+      return i >= 0 && i < entries.size() ? entries.get(i) : null;\n+    }\n+\n+    TermIndex getTermIndex(int i) {\n+      return ServerProtoUtils.toTermIndex(get(i));\n+    }\n+\n+    int size() {\n+      return entries.size();\n+    }\n+\n+    void truncate(int index) {\n+      if (entries.size() > index) {\n+        entries.subList(index, entries.size()).clear();\n+      }\n+    }\n+\n+    void add(LogEntryProto entry) {\n+      entries.add(entry);\n+    }\n+  }\n+\n+  private final EntryList entries = new EntryList();\n+  private final AtomicReference<Metadata> metadata = new AtomicReference<>(new Metadata(null, 0));\n \n   public MemoryRaftLog(RaftPeerId selfId, int maxBufferSize) {\n     super(selfId, maxBufferSize);\n@@ -45,8 +73,7 @@ public MemoryRaftLog(RaftPeerId selfId, int maxBufferSize) {\n   public LogEntryProto get(long index) {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int i = (int) index;\n-      return i >= 0 && i < entries.size() ? entries.get(i) : null;\n+      return entries.get(Math.toIntExact(index));\n     }\n   }\n \n@@ -59,25 +86,22 @@ public EntryWithData getEntryWithData(long index) {\n   public TermIndex getTermIndex(long index) {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int i = (int) index;\n-      return i >= 0 && i < entries.size() ?\n-          ServerProtoUtils.toTermIndex(entries.get(i)) : null;\n+      return entries.getTermIndex(Math.toIntExact(index));\n     }\n   }\n \n   @Override\n   public TermIndex[] getEntries(long startIndex, long endIndex) {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int from = (int) startIndex;\n       if (startIndex >= entries.size()) {\n         return null;\n       }\n-      final int to = (int) Math.min(entries.size(), endIndex);\n+      final int from = Math.toIntExact(startIndex);\n+      final int to = Math.toIntExact(Math.min(entries.size(), endIndex));\n       TermIndex[] ti = new TermIndex[to - from];\n       for (int i = 0; i < ti.length; i++) {\n-        ti[i] = TermIndex.newTermIndex(entries.get(i).getTerm(),\n-            entries.get(i).getIndex());\n+        ti[i] = entries.getTermIndex(i);\n       }\n       return ti;\n     }\n@@ -88,10 +112,7 @@ public TermIndex getTermIndex(long index) {\n     checkLogState();\n     try(AutoCloseableLock writeLock = writeLock()) {\n       Preconditions.assertTrue(index >= 0);\n-      final int truncateIndex = (int) index;\n-      for (int i = entries.size() - 1; i >= truncateIndex; i--) {\n-        entries.remove(i);\n-      }\n+      entries.truncate(Math.toIntExact(index));\n     }\n     return CompletableFuture.completedFuture(index);\n   }\n@@ -100,8 +121,7 @@ public TermIndex getTermIndex(long index) {\n   public TermIndex getLastEntryTermIndex() {\n     checkLogState();\n     try(AutoCloseableLock readLock = readLock()) {\n-      final int size = entries.size();\n-      return size == 0 ? null : ServerProtoUtils.toTermIndex(entries.get(size - 1));\n+      return entries.getTermIndex(entries.size() - 1);\n     }\n   }\n \n@@ -120,26 +140,24 @@ public long append(long term, RaftConfiguration newConf) {\n     checkLogState();\n     try(AutoCloseableLock writeLock = writeLock()) {\n       final long nextIndex = getNextIndex();\n-      final LogEntryProto e = ServerProtoUtils.toLogEntryProto(newConf, term,\n-          nextIndex);\n+      final LogEntryProto e = ServerProtoUtils.toLogEntryProto(newConf, term, nextIndex);\n       entries.add(e);\n       return nextIndex;\n     }\n   }\n \n   @Override\n   public long getStartIndex() {\n-    return entries.isEmpty() ? RaftServerConstants.INVALID_LOG_INDEX :\n-        entries.get(0).getIndex();\n+    return entries.size() == 0? RaftServerConstants.INVALID_LOG_INDEX: entries.getTermIndex(0).getIndex();\n   }\n \n   @Override\n   public List<CompletableFuture<Long>> append(LogEntryProto... entries) {\n     checkLogState();\n+    if (entries == null || entries.length == 0) {\n+      return Collections.emptyList();\n+    }\n     try(AutoCloseableLock writeLock = writeLock()) {\n-      if (entries == null || entries.length == 0) {\n-        return Collections.emptyList();\n-      }\n       // Before truncating the entries, we first need to check if some\n       // entries are duplicated. If the leader sends entry 6, entry 7, then\n       // entry 6 again, without this check the follower may truncate entry 7\n@@ -191,12 +209,12 @@ public long getLatestFlushedIndex() {\n \n   @Override\n   public void writeMetadata(long term, RaftPeerId votedFor) {\n-    // do nothing\n+    metadata.set(new Metadata(votedFor, term));\n   }\n \n   @Override\n   public Metadata loadMetadata() {\n-    return new Metadata(null, 0);\n+    return metadata.get();\n   }\n \n   @Override",
                "deletions": 25
            },
            {
                "sha": "329b02bfe0913c83215cafcb59392679e56b8218",
                "filename": "ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0/ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java",
                "status": "modified",
                "changes": 14,
                "additions": 10,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/statemachine/TestStateMachine.java?ref=8ef7b4852163456eb5db6c5bbb8440d9c3cb36b0",
                "patch": "@@ -116,12 +116,18 @@ void rethrowIfException() throws Throwable {\n \n   @Test\n   public void testTransactionContextIsPassedBack() throws Throwable {\n+    runTestTransactionContextIsPassedBack(false);\n+  }\n+\n+  @Test\n+  public void testTransactionContextIsPassedBackUseMemory() throws Throwable {\n+    runTestTransactionContextIsPassedBack(true);\n+  }\n+\n+  void runTestTransactionContextIsPassedBack(boolean useMemory) throws Throwable {\n     final RaftProperties properties = new RaftProperties();\n     properties.setClass(MiniRaftCluster.STATEMACHINE_CLASS_KEY, SMTransactionContext.class, StateMachine.class);\n-\n-    // TODO: fix and run with in-memory log. It fails with NPE\n-    // TODO: if change setUseMemory to true\n-    RaftServerConfigKeys.Log.setUseMemory(properties, false);\n+    RaftServerConfigKeys.Log.setUseMemory(properties, useMemory);\n \n     try(MiniRaftClusterWithSimulatedRpc cluster = getFactory().newCluster(NUM_SERVERS, properties)) {\n       cluster.start();",
                "deletions": 4
            }
        ],
        "patched_files": [
            "MemoryRaftLog.java",
            "StateMachine.java"
        ],
        "unit_tests": [
            "TestStateMachine.java"
        ]
    },
    "incubator-ratis_8fed368": {
        "repo": "incubator-ratis",
        "message": "RATIS-512. testLeaderStepDown may fail with NullPointerException. Contributed by Tsz Wo Nicholas Sze.",
        "commit": "https://github.com/apache/incubator-ratis/commit/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f",
        "parent": "https://github.com/apache/incubator-ratis/commit/9984f3129834ed4daaca0274a96525bee5773440",
        "bug_id": "incubator-ratis_8fed368",
        "file": [
            {
                "sha": "74c19a15e8e79c8a8c7242b2425b740759412c33",
                "filename": "ratis-server/src/test/java/org/apache/ratis/MiniRaftCluster.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f/ratis-server/src/test/java/org/apache/ratis/MiniRaftCluster.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f/ratis-server/src/test/java/org/apache/ratis/MiniRaftCluster.java",
                "status": "modified",
                "changes": 11,
                "additions": 5,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/MiniRaftCluster.java?ref=8fed3689c7b6b6d94fd1b808dd018855f2b21f1f",
                "patch": "@@ -424,12 +424,12 @@ static void startServers(Iterable<? extends RaftServer> servers) throws IOExcept\n    * prepare the peer list when removing some peers from the conf\n    */\n   public PeerChanges removePeers(int number, boolean removeLeader,\n-      Collection<RaftPeer> excluded) {\n+      Collection<RaftPeer> excluded) throws InterruptedException {\n     Collection<RaftPeer> peers = new ArrayList<>(group.getPeers());\n     List<RaftPeer> removedPeers = new ArrayList<>(number);\n     if (removeLeader) {\n-      final RaftPeer leader = toRaftPeer(getLeader());\n-      assert !excluded.contains(leader);\n+      final RaftPeer leader = toRaftPeer(RaftTestUtil.waitForLeader(this));\n+      Preconditions.assertTrue(!excluded.contains(leader));\n       peers.remove(leader);\n       removedPeers.add(leader);\n     }\n@@ -443,10 +443,9 @@ public PeerChanges removePeers(int number, boolean removeLeader,\n         removed++;\n       }\n     }\n-    RaftPeer[] p = peers.toArray(new RaftPeer[peers.size()]);\n+    final RaftPeer[] p = peers.toArray(RaftPeer.emptyArray());\n     group = RaftGroup.valueOf(group.getGroupId(), p);\n-    return new PeerChanges(p, new RaftPeer[0],\n-        removedPeers.toArray(new RaftPeer[removedPeers.size()]));\n+    return new PeerChanges(p, RaftPeer.emptyArray(), removedPeers.toArray(RaftPeer.emptyArray()));\n   }\n \n   public void killServer(RaftPeerId id) {",
                "deletions": 6
            },
            {
                "sha": "9cf0d9b35c2ff2ad8edf762535aacce1679676fc",
                "filename": "ratis-server/src/test/java/org/apache/ratis/RaftExceptionBaseTest.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f/ratis-server/src/test/java/org/apache/ratis/RaftExceptionBaseTest.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f/ratis-server/src/test/java/org/apache/ratis/RaftExceptionBaseTest.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/RaftExceptionBaseTest.java?ref=8fed3689c7b6b6d94fd1b808dd018855f2b21f1f",
                "patch": "@@ -30,6 +30,7 @@\n import org.apache.ratis.util.LogUtils;\n import org.apache.ratis.util.SizeInBytes;\n import org.junit.Assert;\n+import org.junit.Assume;\n import org.junit.Test;\n \n import java.io.IOException;\n@@ -91,7 +92,7 @@ RaftClientReply assertNotLeaderException(RaftPeerId expectedSuggestedLeader,\n     final SimpleMessage message = new SimpleMessage(messageId);\n     final RaftClientReply reply = rpc.sendRequest(cluster.newRaftClientRequest(ClientId.randomId(), server, message));\n     Assert.assertNotNull(reply);\n-    Assert.assertFalse(reply.isSuccess());\n+    Assume.assumeFalse(reply.isSuccess());\n     final NotLeaderException nle = reply.getNotLeaderException();\n     Objects.requireNonNull(nle);\n     Assert.assertEquals(expectedSuggestedLeader, nle.getSuggestedLeader().getId());",
                "deletions": 1
            },
            {
                "sha": "f96ceff70f2cf5216d42d188566fde9a7b946dee",
                "filename": "ratis-server/src/test/java/org/apache/ratis/server/impl/RaftReconfigurationBaseTest.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f/ratis-server/src/test/java/org/apache/ratis/server/impl/RaftReconfigurationBaseTest.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/8fed3689c7b6b6d94fd1b808dd018855f2b21f1f/ratis-server/src/test/java/org/apache/ratis/server/impl/RaftReconfigurationBaseTest.java",
                "status": "modified",
                "changes": 3,
                "additions": 2,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/server/impl/RaftReconfigurationBaseTest.java?ref=8fed3689c7b6b6d94fd1b808dd018855f2b21f1f",
                "patch": "@@ -175,7 +175,8 @@ void runTestReconfTwice(CLUSTER cluster) throws Exception {\n \n           latch.countDown();\n           client.close();\n-        } catch (IOException ignored) {\n+        } catch(Exception ignored) {\n+          LOG.warn(ignored.getClass().getSimpleName() + \" is ignored\", ignored);\n         }\n       });\n       clientThread.start();",
                "deletions": 1
            }
        ],
        "patched_files": [
            "MiniRaftCluster.java"
        ],
        "unit_tests": [
            "RaftExceptionBaseTest.java",
            "RaftReconfigurationBaseTest.java"
        ]
    },
    "incubator-ratis_bbfb875": {
        "repo": "incubator-ratis",
        "message": "RATIS-336. LeaderState.isBootStrappingPeer may have NPE.",
        "commit": "https://github.com/apache/incubator-ratis/commit/bbfb8754d136a5404e8c2a813a7468d94165d80c",
        "parent": "https://github.com/apache/incubator-ratis/commit/f6814c6b46a54a787983a4245121ee35a9cad0b8",
        "bug_id": "incubator-ratis_bbfb875",
        "file": [
            {
                "sha": "d62b1a7b28609f407884d4f89276527c697ea7a3",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderElection.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c",
                "patch": "@@ -170,7 +170,7 @@ private void askForVotes() throws InterruptedException, IOException {\n           case DISCOVERED_A_NEW_TERM:\n             final long term = r.term > server.getState().getCurrentTerm() ?\n                 r.term : server.getState().getCurrentTerm();\n-            server.changeToFollower(term, true);\n+            server.changeToFollowerAndPersistMetadata(term);\n             return;\n           case TIMEOUT:\n             // should start another election",
                "deletions": 1
            },
            {
                "sha": "b4b613e745c5a43e6e35fac6669be4d484e3719f",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java",
                "status": "modified",
                "changes": 173,
                "additions": 106,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/LeaderState.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c",
                "patch": "@@ -40,8 +40,6 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n-import static org.apache.ratis.server.impl.LeaderState.StateUpdateEventType.*;\n-\n /**\n  * States for leader only. It contains three different types of processors:\n  * 1. RPC senders: each thread is appending log to a follower\n@@ -54,21 +52,76 @@\n   private static final Logger LOG = RaftServerImpl.LOG;\n   public static final String APPEND_PLACEHOLDER = LeaderState.class.getSimpleName() + \".placeholder\";\n \n-  enum StateUpdateEventType {\n-    STEPDOWN, UPDATECOMMIT, STAGINGPROGRESS\n-  }\n-\n-  enum BootStrapProgress {\n+  private enum BootStrapProgress {\n     NOPROGRESS, PROGRESSING, CAUGHTUP\n   }\n \n   static class StateUpdateEvent {\n-    final StateUpdateEventType type;\n+    private enum Type {\n+      STEP_DOWN, UPDATE_COMMIT, CHECK_STAGING\n+    }\n+\n+    final Type type;\n     final long newTerm;\n+    final Runnable handler;\n \n-    StateUpdateEvent(StateUpdateEventType type, long newTerm) {\n+    StateUpdateEvent(Type type, long newTerm, Runnable handler) {\n       this.type = type;\n       this.newTerm = newTerm;\n+      this.handler = handler;\n+    }\n+\n+    void execute() {\n+      handler.run();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (obj == this) {\n+        return true;\n+      } else if (!(obj instanceof StateUpdateEvent)) {\n+        return false;\n+      }\n+      final StateUpdateEvent that = (StateUpdateEvent)obj;\n+      return this.type == that.type && this.newTerm == that.newTerm;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return type + (newTerm >= 0? \":\" + newTerm: \"\");\n+    }\n+  }\n+\n+  private class EventQueue {\n+    private final BlockingQueue<StateUpdateEvent> queue = new ArrayBlockingQueue<>(4096);\n+\n+    void submit(StateUpdateEvent event) {\n+      try {\n+        queue.put(event);\n+      } catch (InterruptedException e) {\n+        LOG.info(\"{}: Interrupted when submitting {} \", server.getId(), event);\n+      }\n+    }\n+\n+    StateUpdateEvent poll() {\n+      final StateUpdateEvent e;\n+      try {\n+        e = queue.poll(server.getMaxTimeoutMs(), TimeUnit.MILLISECONDS);\n+      } catch(InterruptedException ie) {\n+        String s = server.getId() + \": \" + getClass().getSimpleName() + \" thread is interrupted\";\n+        if (!running) {\n+          LOG.info(s + \" gracefully\");\n+          return null;\n+        } else {\n+          throw new IllegalStateException(s + \" UNEXPECTEDLY\", ie);\n+        }\n+      }\n+\n+      if (e != null) {\n+        // remove duplicated events from the head.\n+        for(; e.equals(queue.peek()); queue.poll());\n+      }\n+      return e;\n     }\n   }\n \n@@ -101,10 +154,10 @@ boolean removeAll(Collection<LogAppender> c) {\n     }\n   }\n \n-  static final StateUpdateEvent UPDATE_COMMIT_EVENT =\n-      new StateUpdateEvent(StateUpdateEventType.UPDATECOMMIT, -1);\n-  static final StateUpdateEvent STAGING_PROGRESS_EVENT =\n-      new StateUpdateEvent(StateUpdateEventType.STAGINGPROGRESS, -1);\n+  private final StateUpdateEvent UPDATE_COMMIT_EVENT =\n+      new StateUpdateEvent(StateUpdateEvent.Type.UPDATE_COMMIT, -1, this::updateCommit);\n+  private final StateUpdateEvent CHECK_STAGING_EVENT =\n+      new StateUpdateEvent(StateUpdateEvent.Type.CHECK_STAGING, -1, this::checkStaging);\n \n   private final RaftServerImpl server;\n   private final RaftLog raftLog;\n@@ -117,7 +170,7 @@ boolean removeAll(Collection<LogAppender> c) {\n    * The list is protected by the RaftServer's lock.\n    */\n   private final SenderList senders;\n-  private final BlockingQueue<StateUpdateEvent> eventQ;\n+  private final EventQueue eventQueue = new EventQueue();\n   private final EventProcessor processor;\n   private final PendingRequests pendingRequests;\n   private volatile boolean running = true;\n@@ -135,7 +188,6 @@ boolean removeAll(Collection<LogAppender> c) {\n     final ServerState state = server.getState();\n     this.raftLog = state.getLog();\n     this.currentTerm = state.getCurrentTerm();\n-    eventQ = new ArrayBlockingQueue<>(4096);\n     processor = new EventProcessor();\n     pendingRequests = new PendingRequests(server);\n \n@@ -192,10 +244,6 @@ boolean inStagingState() {\n     return stagingState != null;\n   }\n \n-  ConfigurationStagingState getStagingState() {\n-    return stagingState;\n-  }\n-\n   long getCurrentTerm() {\n     return currentTerm;\n   }\n@@ -299,11 +347,25 @@ private void updateSenders(RaftConfiguration conf) {\n     stopAndRemoveSenders(s -> !conf.containsInConf(s.getFollower().getPeer().getId()));\n   }\n \n-  void submitUpdateStateEvent(StateUpdateEvent event) {\n+  void submitStepDownEvent() {\n+    submitStepDownEvent(getCurrentTerm());\n+  }\n+\n+  void submitStepDownEvent(long term) {\n+    eventQueue.submit(new StateUpdateEvent(StateUpdateEvent.Type.STEP_DOWN, term, () -> stepDown(term)));\n+  }\n+\n+  private void stepDown(long term) {\n     try {\n-      eventQ.put(event);\n-    } catch (InterruptedException e) {\n-      LOG.info(\"Interrupted when adding event {} into the queue\", event);\n+      server.changeToFollowerAndPersistMetadata(term);\n+    } catch(IOException e) {\n+      final String s = server.getId() + \": Failed to persist metadata for term \" + term;\n+      LOG.warn(s, e);\n+      // the failure should happen while changing the state to follower\n+      // thus the in-memory state should have been updated\n+      if (running) {\n+        throw new IllegalStateException(s + \" and running == true\", e);\n+      }\n     }\n   }\n \n@@ -331,50 +393,20 @@ public void run() {\n       prepare();\n \n       while (running) {\n-        try {\n-          StateUpdateEvent event = eventQ.poll(server.getMaxTimeoutMs(),\n-              TimeUnit.MILLISECONDS);\n-          synchronized (server) {\n-            if (running) {\n-              handleEvent(event);\n+        final StateUpdateEvent event = eventQueue.poll();\n+        synchronized(server) {\n+          if (running) {\n+            if (event != null) {\n+              event.execute();\n+            } else if (inStagingState()) {\n+              checkStaging();\n             }\n           }\n-          // the updated configuration does not need to be sync'ed here\n-        } catch (InterruptedException e) {\n-          final String s = server.getId() + \" \" + getClass().getSimpleName()\n-              + \" thread is interrupted \";\n-          if (!running) {\n-            LOG.info(s + \" gracefully; server=\" + server);\n-          } else {\n-            LOG.warn(s + \" UNEXPECTEDLY; server=\" + server, e);\n-            throw new RuntimeException(e);\n-          }\n-        } catch (IOException e) {\n-          LOG.warn(\"Failed to persist new votedFor/term.\", e);\n-          // the failure should happen while changing the state to follower\n-          // thus the in-memory state should have been updated\n-          Preconditions.assertTrue(!running);\n         }\n       }\n     }\n   }\n \n-  private void handleEvent(StateUpdateEvent e) throws IOException {\n-    if (e == null) {\n-      if (inStagingState()) {\n-        checkNewPeers();\n-      }\n-    } else {\n-      if (e.type == STEPDOWN) {\n-        server.changeToFollower(e.newTerm, true);\n-      } else if (e.type == UPDATECOMMIT) {\n-        updateLastCommitted();\n-      } else if (e.type == STAGINGPROGRESS) {\n-        checkNewPeers();\n-      }\n-    }\n-  }\n-\n   /**\n    * So far we use a simple implementation for catchup checking:\n    * 1. If the latest rpc time of the remote peer is before 3 * max_timeout,\n@@ -410,11 +442,14 @@ private BootStrapProgress checkProgress(FollowerInfo follower,\n         .collect(Collectors.toCollection(ArrayList::new));\n   }\n \n-  private void checkNewPeers() {\n+  void submitCheckStagingEvent() {\n+    eventQueue.submit(CHECK_STAGING_EVENT);\n+  }\n+\n+  private void checkStaging() {\n     if (!inStagingState()) {\n-      // it is possible that the bootstrapping is done and we still have\n-      // remaining STAGINGPROGRESS event to handle.\n-      updateLastCommitted();\n+      // it is possible that the bootstrapping is done. Then, fallback to UPDATE_COMMIT\n+      UPDATE_COMMIT_EVENT.execute();\n     } else {\n       final long committedIndex = server.getState().getLog()\n           .getLastCommittedIndex();\n@@ -431,10 +466,14 @@ private void checkNewPeers() {\n   }\n \n   boolean isBootStrappingPeer(RaftPeerId peerId) {\n-    return inStagingState() && getStagingState().contains(peerId);\n+    return Optional.ofNullable(stagingState).map(s -> s.contains(peerId)).orElse(false);\n+  }\n+\n+  void submitUpdateCommitEvent() {\n+    eventQueue.submit(UPDATE_COMMIT_EVENT);\n   }\n \n-  private void updateLastCommitted() {\n+  private void updateCommit() {\n     final RaftPeerId selfId = server.getId();\n     final RaftConfiguration conf = server.getRaftConf();\n \n@@ -575,7 +614,7 @@ static long getMajority(long[] indices) {\n   /** @return true if the request is replied; otherwise, the reply is delayed, return false. */\n   boolean replyPendingRequest(long logIndex, RaftClientReply reply, RetryCache.CacheEntry cacheEntry) {\n     if (!pendingRequests.replyPendingRequest(logIndex, reply, cacheEntry)) {\n-      submitUpdateStateEvent(UPDATE_COMMIT_EVENT);\n+      submitUpdateCommitEvent();\n       return false;\n     }\n     return true;",
                "deletions": 67
            },
            {
                "sha": "3c9b2d4dbf61476ac48abb3282027af6952f3f9c",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java",
                "status": "modified",
                "changes": 15,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/LogAppender.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c",
                "patch": "@@ -20,7 +20,6 @@\n import org.apache.ratis.conf.RaftProperties;\n import org.apache.ratis.protocol.RaftPeerId;\n import org.apache.ratis.server.RaftServerConfigKeys;\n-import org.apache.ratis.server.impl.LeaderState.StateUpdateEventType;\n import org.apache.ratis.server.protocol.TermIndex;\n import org.apache.ratis.server.storage.RaftLog.EntryWithData;\n import org.apache.ratis.server.storage.FileInfo;\n@@ -45,7 +44,6 @@\n import static org.apache.ratis.util.LifeCycle.State.CLOSED;\n import static org.apache.ratis.util.LifeCycle.State.CLOSING;\n import static org.apache.ratis.util.LifeCycle.State.EXCEPTION;\n-import static org.apache.ratis.util.LifeCycle.State.NEW;\n import static org.apache.ratis.util.LifeCycle.State.RUNNING;\n import static org.apache.ratis.util.LifeCycle.State.STARTING;\n \n@@ -491,10 +489,11 @@ private void handleException(Exception e) {\n   }\n \n   protected void submitEventOnSuccessAppend() {\n-    LeaderState.StateUpdateEvent e = follower.isAttendingVote() ?\n-        LeaderState.UPDATE_COMMIT_EVENT :\n-        LeaderState.STAGING_PROGRESS_EVENT;\n-    leaderState.submitUpdateStateEvent(e);\n+    if (follower.isAttendingVote()) {\n+      leaderState.submitUpdateCommitEvent();\n+    } else {\n+      leaderState.submitCheckStagingEvent();\n+    }\n   }\n \n   protected void checkSlowness() {\n@@ -531,9 +530,7 @@ protected void checkResponseTerm(long responseTerm) {\n     synchronized (server) {\n       if (isAppenderRunning() && follower.isAttendingVote()\n           && responseTerm > leaderState.getCurrentTerm()) {\n-        leaderState.submitUpdateStateEvent(\n-            new LeaderState.StateUpdateEvent(StateUpdateEventType.STEPDOWN,\n-                responseTerm));\n+        leaderState.submitStepDownEvent(responseTerm);\n       }\n     }\n   }",
                "deletions": 9
            },
            {
                "sha": "d4b32a10362f407c1aa97ef7234b46a9ffb6a4b5",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java",
                "status": "modified",
                "changes": 27,
                "additions": 11,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/impl/RaftServerImpl.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c",
                "patch": "@@ -295,13 +295,10 @@ public boolean isLeader() {\n   /**\n    * Change the server state to Follower if necessary\n    * @param newTerm The new term.\n-   * @param sync We will call {@link ServerState#persistMetadata()} if this is\n-   *             set to true and term/votedFor get updated.\n    * @return if the term/votedFor should be updated to the new term\n    * @throws IOException if term/votedFor persistence failed.\n    */\n-  synchronized boolean changeToFollower(long newTerm, boolean sync)\n-      throws IOException {\n+  private synchronized boolean changeToFollower(long newTerm) {\n     final RaftPeerRole old = role.getCurrentRole();\n     final boolean metadataUpdated = state.updateCurrentTerm(newTerm);\n \n@@ -314,11 +311,13 @@ synchronized boolean changeToFollower(long newTerm, boolean sync)\n       }\n       startHeartbeatMonitor();\n     }\n+    return metadataUpdated;\n+  }\n \n-    if (metadataUpdated && sync) {\n+  synchronized void changeToFollowerAndPersistMetadata(long newTerm) throws IOException {\n+    if (changeToFollower(newTerm)) {\n       state.persistMetadata();\n     }\n-    return metadataUpdated;\n   }\n \n   private synchronized void shutdownLeaderState(boolean allowNull) {\n@@ -546,9 +545,7 @@ void assertGroup(Object requestorId, RaftGroupId requestorGroupId) throws GroupM\n         cacheEntry.failWithReply(exceptionReply);\n         // leader will step down here\n         if (isLeader() && leaderState != null) {\n-          leaderState.submitUpdateStateEvent(new LeaderState.StateUpdateEvent(\n-              LeaderState.StateUpdateEventType.STEPDOWN,\n-              leaderState.getCurrentTerm()));\n+          leaderState.submitStepDownEvent();\n         }\n         return CompletableFuture.completedFuture(exceptionReply);\n       }\n@@ -777,7 +774,7 @@ private RequestVoteReplyProto requestVote(\n             getId(), role, candidateId, candidateTerm, state.getLeaderId(), state.getCurrentTerm(),\n             isFollower()? heartbeatMonitor.getLastRpcTime().elapsedTimeMs() + \"ms\": null);\n       } else if (state.recognizeCandidate(candidateId, candidateTerm)) {\n-        boolean termUpdated = changeToFollower(candidateTerm, false);\n+        final boolean termUpdated = changeToFollower(candidateTerm);\n         // see Section 5.4.1 Election restriction\n         if (state.isLogUpToDate(candidateLastEntry)) {\n           heartbeatMonitor.updateLastRpcTime(false);\n@@ -910,7 +907,7 @@ static void logAppendEntries(boolean isHeartbeat, Supplier<String> message) {\n         }\n         return CompletableFuture.completedFuture(reply);\n       }\n-      changeToFollower(leaderTerm, true);\n+      changeToFollowerAndPersistMetadata(leaderTerm);\n       state.setLeader(leaderId, \"appendEntries\");\n \n       if (!initializing && lifeCycle.compareAndTransition(STARTING, RUNNING)) {\n@@ -1010,7 +1007,7 @@ public InstallSnapshotReplyProto installSnapshot(\n             \" Reply: {}\", getId(), reply);\n         return reply;\n       }\n-      changeToFollower(leaderTerm, true);\n+      changeToFollowerAndPersistMetadata(leaderTerm);\n       state.setLeader(leaderId, \"installSnapshot\");\n \n       if (lifeCycle.getCurrentState() == RUNNING) {\n@@ -1062,10 +1059,8 @@ synchronized RequestVoteRequestProto createRequestVoteRequest(\n         groupId, term, lastEntry);\n   }\n \n-  public synchronized void submitLocalSyncEvent() {\n-    if (isLeader() && leaderState != null) {\n-      leaderState.submitUpdateStateEvent(LeaderState.UPDATE_COMMIT_EVENT);\n-    }\n+  public void submitUpdateCommitEvent() {\n+    Optional.ofNullable(leaderState).ifPresent(LeaderState::submitUpdateCommitEvent);\n   }\n \n   /**",
                "deletions": 16
            },
            {
                "sha": "715370b554b114af25aded930b7629f0a6dc8352",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java",
                "status": "modified",
                "changes": 18,
                "additions": 6,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/storage/RaftLogWorker.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c",
                "patch": "@@ -61,7 +61,7 @@\n \n   private final RaftStorage storage;\n   private volatile LogOutputStream out;\n-  private final RaftServerImpl raftServer;\n+  private final Runnable submitUpdateCommitEvent;\n   private final StateMachine stateMachine;\n   private final Supplier<Timer> logFlushTimer;\n \n@@ -86,7 +86,7 @@\n     this.name = selfId + \"-\" + getClass().getSimpleName();\n     LOG.info(\"new {} for {}\", name, storage);\n \n-    this.raftServer = raftServer;\n+    this.submitUpdateCommitEvent = raftServer != null? raftServer::submitUpdateCommitEvent: () -> {};\n     this.stateMachine = raftServer != null? raftServer.getStateMachine(): null;\n \n     this.storage = storage;\n@@ -100,11 +100,8 @@\n     this.workerThread = new Thread(this, name);\n \n     // Server Id can be null in unit tests\n-    Supplier<String> serverId = () -> raftServer == null || raftServer.getId() == null\n-        ? \"null\" : raftServer.getId().toString();\n     this.logFlushTimer = JavaUtils.memoize(() -> RatisMetricsRegistry.getRegistry()\n-        .timer(MetricRegistry.name(RaftLogWorker.class, serverId.get(),\n-            \"flush-time\")));\n+        .timer(MetricRegistry.name(RaftLogWorker.class, selfId.toString(), \"flush-time\")));\n   }\n \n   void start(long latestIndex, File openSegmentFile) throws IOException {\n@@ -243,9 +240,7 @@ private void flushWrites() throws IOException {\n   private void updateFlushedIndex() {\n     flushedIndex = lastWrittenIndex;\n     pendingFlushNum = 0;\n-    if (raftServer != null) {\n-      raftServer.submitLocalSyncEvent();\n-    }\n+    submitUpdateCommitEvent.run();\n   }\n \n   /**\n@@ -288,9 +283,8 @@ Task truncate(TruncationSegments ts) {\n           // this.entry != entry iff the entry has state machine data\n           this.stateMachineFuture = stateMachine.writeStateMachineData(entry);\n         } catch (Throwable e) {\n-          LOG.error(\"{}: writeStateMachineData failed for index:{} proto:{}\",\n-              raftServer.getId() ,entry.getIndex(),\n-              ServerProtoUtils.toString(entry), e.getMessage());\n+          LOG.error(name + \": writeStateMachineData failed for index \" + entry.getIndex()\n+              + \", entry=\" + ServerProtoUtils.toLogEntryString(entry), e);\n           throw e;\n         }\n       }",
                "deletions": 12
            },
            {
                "sha": "862e21f87f20ee9db3ed1709651be62ec170486b",
                "filename": "ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/bbfb8754d136a5404e8c2a813a7468d94165d80c/ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java",
                "status": "modified",
                "changes": 3,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/main/java/org/apache/ratis/server/storage/SegmentedRaftLog.java?ref=bbfb8754d136a5404e8c2a813a7468d94165d80c",
                "patch": "@@ -105,8 +105,7 @@ public String toString() {\n   private final long segmentMaxSize;\n \n   public SegmentedRaftLog(RaftPeerId selfId, RaftServerImpl server,\n-      RaftStorage storage, long lastIndexInSnapshot, RaftProperties properties)\n-      throws IOException {\n+      RaftStorage storage, long lastIndexInSnapshot, RaftProperties properties) {\n     super(selfId, RaftServerConfigKeys.Log.Appender.bufferCapacity(properties)\n         .getSizeInt());\n     this.server = server;",
                "deletions": 2
            }
        ],
        "patched_files": [
            "SegmentedRaftLog.java",
            "LeaderElection.java"
        ],
        "unit_tests": [
            "TestSegmentedRaftLog.java",
            "LeaderElectionTests.java"
        ]
    },
    "incubator-ratis_89b1a1c": {
        "repo": "incubator-ratis",
        "message": "RATIS-303. TestRaftStateMachineException is failing with NullPointerException.  Contributed by Shashikant Banerjee",
        "commit": "https://github.com/apache/incubator-ratis/commit/89b1a1cd9b12623f031845881e3df069dcafe249",
        "parent": "https://github.com/apache/incubator-ratis/commit/ef48512da368f7d52ffddd3a8f02890bbdff2b39",
        "bug_id": "incubator-ratis_89b1a1c",
        "file": [
            {
                "sha": "ca367387481fd231bdd65ebd4f26f9e887568135",
                "filename": "ratis-grpc/src/test/java/org/apache/ratis/grpc/TestRaftStateMachineExceptionWithGrpc.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-grpc/src/test/java/org/apache/ratis/grpc/TestRaftStateMachineExceptionWithGrpc.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-grpc/src/test/java/org/apache/ratis/grpc/TestRaftStateMachineExceptionWithGrpc.java",
                "status": "added",
                "changes": 26,
                "additions": 26,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-grpc/src/test/java/org/apache/ratis/grpc/TestRaftStateMachineExceptionWithGrpc.java?ref=89b1a1cd9b12623f031845881e3df069dcafe249",
                "patch": "@@ -0,0 +1,26 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ratis.grpc;\n+\n+import org.apache.ratis.server.impl.RaftStateMachineExceptionTests;\n+\n+public class TestRaftStateMachineExceptionWithGrpc\n+    extends RaftStateMachineExceptionTests<MiniRaftClusterWithGRpc>\n+    implements MiniRaftClusterWithGRpc.FactoryGet {\n+\n+}",
                "deletions": 0
            },
            {
                "sha": "6a8fd9d1946a88e4233675dc257ff40540a0aa28",
                "filename": "ratis-hadoop/src/test/java/org/apache/ratis/hadooprpc/TestRaftStateMachineExceptionWithHadoopRpc.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-hadoop/src/test/java/org/apache/ratis/hadooprpc/TestRaftStateMachineExceptionWithHadoopRpc.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-hadoop/src/test/java/org/apache/ratis/hadooprpc/TestRaftStateMachineExceptionWithHadoopRpc.java",
                "status": "added",
                "changes": 25,
                "additions": 25,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-hadoop/src/test/java/org/apache/ratis/hadooprpc/TestRaftStateMachineExceptionWithHadoopRpc.java?ref=89b1a1cd9b12623f031845881e3df069dcafe249",
                "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ratis.hadooprpc;\n+\n+import org.apache.ratis.server.impl.RaftStateMachineExceptionTests;\n+\n+public class TestRaftStateMachineExceptionWithHadoopRpc extends\n+    RaftStateMachineExceptionTests<MiniRaftClusterWithHadoopRpc>\n+    implements MiniRaftClusterWithHadoopRpc.Factory.Get {\n+}",
                "deletions": 0
            },
            {
                "sha": "34fddc975f66244c591064abc169b6636439af90",
                "filename": "ratis-netty/src/test/java/org/apache/ratis/netty/TestRaftStateMachineExceptionWithNetty.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-netty/src/test/java/org/apache/ratis/netty/TestRaftStateMachineExceptionWithNetty.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-netty/src/test/java/org/apache/ratis/netty/TestRaftStateMachineExceptionWithNetty.java",
                "status": "added",
                "changes": 25,
                "additions": 25,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-netty/src/test/java/org/apache/ratis/netty/TestRaftStateMachineExceptionWithNetty.java?ref=89b1a1cd9b12623f031845881e3df069dcafe249",
                "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ratis.netty;\n+\n+import org.apache.ratis.server.impl.RaftStateMachineExceptionTests;\n+\n+public class TestRaftStateMachineExceptionWithNetty\n+    extends RaftStateMachineExceptionTests<MiniRaftClusterWithNetty>\n+    implements MiniRaftClusterWithNetty.FactoryGet {\n+}",
                "deletions": 0
            },
            {
                "sha": "ec635d0bcc5e78d96469c946279d6defc065c779",
                "filename": "ratis-server/src/test/java/org/apache/ratis/server/impl/RaftStateMachineExceptionTests.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-server/src/test/java/org/apache/ratis/server/impl/RaftStateMachineExceptionTests.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-server/src/test/java/org/apache/ratis/server/impl/RaftStateMachineExceptionTests.java",
                "status": "renamed",
                "changes": 82,
                "additions": 50,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/server/impl/RaftStateMachineExceptionTests.java?ref=89b1a1cd9b12623f031845881e3df069dcafe249",
                "patch": "@@ -15,41 +15,43 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.ratis.statemachine;\n+package org.apache.ratis.server.impl;\n \n import org.apache.log4j.Level;\n+import org.apache.ratis.BaseTest;\n import org.apache.ratis.MiniRaftCluster;\n-import org.apache.ratis.RaftTestUtil.SimpleMessage;\n+import org.apache.ratis.RaftTestUtil;\n import org.apache.ratis.client.RaftClient;\n import org.apache.ratis.client.RaftClientRpc;\n-import org.apache.ratis.examples.ParameterizedBaseTest;\n+import org.apache.ratis.conf.RaftProperties;\n import org.apache.ratis.protocol.*;\n-import org.apache.ratis.server.impl.RaftServerImpl;\n-import org.apache.ratis.server.impl.RaftServerTestUtil;\n-import org.apache.ratis.server.impl.RetryCache;\n import org.apache.ratis.server.storage.RaftLog;\n+import org.apache.ratis.statemachine.SimpleStateMachine4Testing;\n+import org.apache.ratis.statemachine.StateMachine;\n+import org.apache.ratis.statemachine.TransactionContext;\n import org.apache.ratis.util.LogUtils;\n import org.junit.Assert;\n import org.junit.Test;\n-import org.junit.runners.Parameterized;\n \n import java.io.IOException;\n-import java.util.Collection;\n import java.util.Objects;\n import java.util.concurrent.CompletableFuture;\n \n import static org.junit.Assert.fail;\n \n-public class TestRaftStateMachineException extends ParameterizedBaseTest {\n-  static {\n+public abstract class RaftStateMachineExceptionTests<CLUSTER extends MiniRaftCluster>\n+    extends BaseTest implements MiniRaftCluster.Factory.Get<CLUSTER> {\n+  {\n     LogUtils.setLogLevel(RaftServerImpl.LOG, Level.DEBUG);\n     LogUtils.setLogLevel(RaftLog.LOG, Level.DEBUG);\n     LogUtils.setLogLevel(RaftClient.LOG, Level.DEBUG);\n   }\n \n   protected static boolean failPreAppend = false;\n \n-  protected static class StateMachineWithException extends SimpleStateMachine4Testing {\n+  protected static class StateMachineWithException extends\n+      SimpleStateMachine4Testing {\n+\n     @Override\n     public CompletableFuture<Message> applyTransaction(TransactionContext trx) {\n       CompletableFuture<Message> future = new CompletableFuture<>();\n@@ -68,42 +70,45 @@ public TransactionContext preAppendTransaction(TransactionContext trx)\n     }\n   }\n \n-  @Parameterized.Parameters\n-  public static Collection<Object[]> data() throws IOException {\n-    return getMiniRaftClusters(StateMachineWithException.class, 3);\n-  }\n-\n-  @Parameterized.Parameter\n-  public MiniRaftCluster cluster;\n-\n   @Test\n   public void testHandleStateMachineException() throws Exception {\n-    setAndStart(cluster);\n+    final RaftProperties prop = getProperties();\n+    prop.setClass(MiniRaftCluster.STATEMACHINE_CLASS_KEY,\n+        StateMachineWithException.class, StateMachine.class);\n+    final MiniRaftCluster cluster = newCluster(3);\n+    cluster.start();\n \n-    final RaftPeerId leaderId = cluster.getLeader().getId();\n+    RaftPeerId leaderId = RaftTestUtil.waitForLeader(cluster).getId();\n \n     try(final RaftClient client = cluster.createClient(leaderId)) {\n-      client.send(new SimpleMessage(\"m\"));\n+      client.send(new RaftTestUtil.SimpleMessage(\"m\"));\n       fail(\"Exception expected\");\n     } catch (StateMachineException e) {\n       e.printStackTrace();\n       Assert.assertTrue(e.getCause().getMessage().contains(\"Fake Exception\"));\n     }\n+    cluster.shutdown();\n   }\n \n   @Test\n   public void testRetryOnStateMachineException() throws Exception {\n-    setAndStart(cluster);\n+    final RaftProperties prop = getProperties();\n+    prop.setClass(MiniRaftCluster.STATEMACHINE_CLASS_KEY,\n+        StateMachineWithException.class, StateMachine.class);\n+    final MiniRaftCluster cluster = newCluster(3);\n+    cluster.start();\n \n-    final RaftPeerId leaderId = cluster.getLeaderAndSendFirstMessage(true).getId();\n+    RaftPeerId leaderId = RaftTestUtil.waitForLeader(cluster).getId();\n+\n+    cluster.getLeaderAndSendFirstMessage(true);\n     long oldLastApplied = cluster.getLeader().getState().getLastAppliedIndex();\n \n     final RaftClient client = cluster.createClient(leaderId);\n     final RaftClientRpc rpc = client.getClientRpc();\n     final long callId = 999;\n     final long seqNum = 111;\n     RaftClientRequest r = cluster.newRaftClientRequest(client.getId(), leaderId,\n-        callId, seqNum, new SimpleMessage(\"message\"));\n+        callId, seqNum, new RaftTestUtil.SimpleMessage(\"message\"));\n     RaftClientReply reply = rpc.sendRequest(r);\n     Assert.assertFalse(reply.isSuccess());\n     Assert.assertNotNull(reply.getStateMachineException());\n@@ -131,39 +136,52 @@ public void testRetryOnStateMachineException() throws Exception {\n     }\n \n     client.close();\n+    cluster.shutdown();\n   }\n \n   @Test\n   public void testRetryOnExceptionDuringReplication() throws Exception {\n-    setAndStart(cluster);\n-    final RaftPeerId leaderId = cluster.getLeaderAndSendFirstMessage(true).getId();\n-\n+    final RaftProperties prop = getProperties();\n+    prop.setClass(MiniRaftCluster.STATEMACHINE_CLASS_KEY,\n+        StateMachineWithException.class, StateMachine.class);\n+    final MiniRaftCluster cluster = newCluster(3);\n+    cluster.start();\n+    RaftTestUtil.waitForLeader(cluster);\n+    RaftServerImpl leader = cluster.getLeader();\n+    RaftPeerId leaderId = leader.getId();\n+    cluster.getLeaderAndSendFirstMessage(true);\n     // turn on the preAppend failure switch\n     failPreAppend = true;\n     final RaftClient client = cluster.createClient(leaderId);\n     final RaftClientRpc rpc = client.getClientRpc();\n     final long callId = 999;\n     final long seqNum = 111;\n     RaftClientRequest r = cluster.newRaftClientRequest(client.getId(), leaderId,\n-        callId, seqNum, new SimpleMessage(\"message\"));\n+        callId, seqNum, new RaftTestUtil.SimpleMessage(\"message\"));\n     RaftClientReply reply = rpc.sendRequest(r);\n     Objects.requireNonNull(reply.getStateMachineException());\n \n     RetryCache.CacheEntry oldEntry = RaftServerTestUtil.getRetryEntry(\n-        cluster.getLeader(), client.getId(), callId);\n+        leader, client.getId(), callId);\n     Assert.assertNotNull(oldEntry);\n     Assert.assertTrue(RaftServerTestUtil.isRetryCacheEntryFailed(oldEntry));\n \n+    // At this point of time the old leader would have stepped down. wait for\n+    // leader election to complete\n+    RaftTestUtil.waitForLeader(cluster);\n+    leader = cluster.getLeader();\n+    leaderId = leader.getId();\n     // retry\n+    r = cluster.newRaftClientRequest(client.getId(), leaderId,\n+        callId, seqNum, new RaftTestUtil.SimpleMessage(\"message\"));\n     reply = rpc.sendRequest(r);\n     Objects.requireNonNull(reply.getStateMachineException());\n \n     RetryCache.CacheEntry currentEntry = RaftServerTestUtil.getRetryEntry(\n-        cluster.getLeader(), client.getId(), callId);\n+        leader, client.getId(), callId);\n     Assert.assertNotNull(currentEntry);\n     Assert.assertTrue(RaftServerTestUtil.isRetryCacheEntryFailed(currentEntry));\n     Assert.assertNotEquals(oldEntry, currentEntry);\n-\n     failPreAppend = false;\n     client.close();\n   }",
                "deletions": 32,
                "previous_filename": "ratis-examples/src/test/java/org/apache/ratis/statemachine/TestRaftStateMachineException.java"
            },
            {
                "sha": "d8ca86f4a17467ff6e6fd3527edae01b4f7ae562",
                "filename": "ratis-server/src/test/java/org/apache/ratis/server/simulation/TestRaftStateMachineExceptionWithSimulatedRpc.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-server/src/test/java/org/apache/ratis/server/simulation/TestRaftStateMachineExceptionWithSimulatedRpc.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-server/src/test/java/org/apache/ratis/server/simulation/TestRaftStateMachineExceptionWithSimulatedRpc.java",
                "status": "added",
                "changes": 25,
                "additions": 25,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/server/simulation/TestRaftStateMachineExceptionWithSimulatedRpc.java?ref=89b1a1cd9b12623f031845881e3df069dcafe249",
                "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ratis.server.simulation;\n+\n+import org.apache.ratis.server.impl.RaftStateMachineExceptionTests;\n+\n+public class TestRaftStateMachineExceptionWithSimulatedRpc extends\n+    RaftStateMachineExceptionTests<MiniRaftClusterWithSimulatedRpc>\n+    implements MiniRaftClusterWithSimulatedRpc.FactoryGet {\n+}",
                "deletions": 0
            },
            {
                "sha": "b6d6d3f687ae7ec9e1cc7a6b8f58cc331cad9221",
                "filename": "ratis-server/src/test/java/org/apache/ratis/statemachine/SimpleStateMachine4Testing.java",
                "blob_url": "https://github.com/apache/incubator-ratis/blob/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-server/src/test/java/org/apache/ratis/statemachine/SimpleStateMachine4Testing.java",
                "raw_url": "https://github.com/apache/incubator-ratis/raw/89b1a1cd9b12623f031845881e3df069dcafe249/ratis-server/src/test/java/org/apache/ratis/statemachine/SimpleStateMachine4Testing.java",
                "status": "modified",
                "changes": 2,
                "additions": 1,
                "contents_url": "https://api.github.com/repos/apache/incubator-ratis/contents/ratis-server/src/test/java/org/apache/ratis/statemachine/SimpleStateMachine4Testing.java?ref=89b1a1cd9b12623f031845881e3df069dcafe249",
                "patch": "@@ -88,7 +88,7 @@ public static SimpleStateMachine4Testing get(RaftServerImpl s) {\n   private RoleInfoProto slownessInfo = null;\n   private RoleInfoProto leaderElectionTimeoutInfo = null;\n \n-  SimpleStateMachine4Testing() {\n+  public SimpleStateMachine4Testing() {\n     checkpointer = new Daemon(() -> {\n       while (running) {\n           if (list.get(list.size() - 1).getIndex() - endIndexLastCkpt >=",
                "deletions": 1
            }
        ],
        "patched_files": [
            "SimpleStateMachine4Testing.java",
            "RaftStateMachineExceptionTests.java"
        ],
        "unit_tests": [
            "TestRaftStateMachineExceptionWithNetty.java",
            "TestRaftStateMachineExceptionWithHadoopRpc.java",
            "TestRaftStateMachineExceptionWithSimulatedRpc.java",
            "TestRaftStateMachineExceptionWithGrpc.java"
        ]
    }
}