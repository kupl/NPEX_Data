<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ResourceManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.query.scheduler.resources</a> &gt; <span class="el_source">ResourceManager.java</span></div><h1>ResourceManager.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.query.scheduler.resources;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.linkedin.pinot.common.query.ServerQueryRequest;
import com.linkedin.pinot.core.query.scheduler.SchedulerGroupAccountant;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import org.apache.commons.configuration.Configuration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Abstract class to manage all the server resources for query execution.
 * Currently this manages the threadpool for query execution.
 *
 * This class supports soft and hard limits on the number of threads. A
 * scheduler group will not get more than the hard_limit number of threads.
 */
// TODO: This class supports hard and soft thread limits. Potentially, we can make
// these limits dynamic - SchedulerGroups with low latency can have higher hard limit
// than the groups with high latency. That requires more experimentation and tuning
public abstract class ResourceManager {
<span class="fc" id="L43">  private static final Logger LOGGER = LoggerFactory.getLogger(ResourceManager.class);</span>

  public static final String QUERY_RUNNER_CONFIG_KEY = &quot;query_runner_threads&quot;;
  public static final String QUERY_WORKER_CONFIG_KEY = &quot;query_worker_threads&quot;;
  public static final int DEFAULT_QUERY_RUNNER_THREADS;
  public static final int DEFAULT_QUERY_WORKER_THREADS;

  static {
<span class="fc" id="L51">    int numCores = Runtime.getRuntime().availableProcessors();</span>
    // arbitrary...but not completely arbitrary
<span class="fc" id="L53">    DEFAULT_QUERY_RUNNER_THREADS = numCores;</span>
<span class="fc" id="L54">    DEFAULT_QUERY_WORKER_THREADS = 2 * numCores;</span>
<span class="fc" id="L55">  }</span>

  // set the main query runner priority higher than NORM but lower than MAX
  // because if a query is complete we want to deserialize and return response as soon
  // as possible
  protected static final int QUERY_RUNNER_THREAD_PRIORITY = 7;
  // This executor service will run the &quot;main&quot; operation of query processing
  // including planning, distributing operators across threads, waiting and
  // reducing the results from the parallel set of operators (MCombineOperator)
  //
  protected final ListeningExecutorService queryRunners;
  protected final ListeningExecutorService queryWorkers;
  protected final int numQueryRunnerThreads;
  protected final int numQueryWorkerThreads;

  /**
   * @param config configuration for initializing resource manager
   */
<span class="fc" id="L73">  public ResourceManager(Configuration config) {</span>
<span class="fc" id="L74">    numQueryRunnerThreads = config.getInt(QUERY_RUNNER_CONFIG_KEY, DEFAULT_QUERY_RUNNER_THREADS);</span>
<span class="fc" id="L75">    numQueryWorkerThreads = config.getInt(QUERY_WORKER_CONFIG_KEY, DEFAULT_QUERY_WORKER_THREADS);</span>

<span class="fc" id="L77">    LOGGER.info(&quot;Initializing with {} query runner threads and {} worker threads&quot;, numQueryRunnerThreads,</span>
        numQueryWorkerThreads);
    // pqr -&gt; pinot query runner (to give short names)
<span class="fc" id="L80">    ThreadFactory queryRunnerFactory = new ThreadFactoryBuilder().setDaemon(false)</span>
        .setPriority(QUERY_RUNNER_THREAD_PRIORITY)
        .setNameFormat(&quot;pqr-%d&quot;)
        .build();
<span class="fc" id="L84">    queryRunners = MoreExecutors.listeningDecorator(</span>
        Executors.newFixedThreadPool(numQueryRunnerThreads, queryRunnerFactory));

    // pqw -&gt; pinot query workers
<span class="fc" id="L88">    ThreadFactory queryWorkersFactory = new ThreadFactoryBuilder().setDaemon(false)</span>
        .setPriority(Thread.NORM_PRIORITY)
        .setNameFormat(&quot;pqw-%d&quot;)
        .build();
<span class="fc" id="L92">    queryWorkers = MoreExecutors.listeningDecorator(</span>
        Executors.newFixedThreadPool(numQueryWorkerThreads, queryWorkersFactory));
<span class="fc" id="L94">  }</span>

  public void stop() {
<span class="fc" id="L97">    queryWorkers.shutdownNow();</span>
<span class="fc" id="L98">    queryRunners.shutdownNow();</span>
<span class="fc" id="L99">  }</span>

  /**
   * Total number of query runner threads. Query runner threads are 'main'
   * threads executing the query.
   * @return
   */
  final public int getNumQueryRunnerThreads() {
<span class="fc" id="L107">    return numQueryRunnerThreads;</span>
  }

  /**
   * Total number of query worker threads. Query worker threads are a pool of threads
   * for parallel processing of a query.
   * @return
   */
  final public int getNumQueryWorkerThreads() {
<span class="fc" id="L116">    return numQueryWorkerThreads;</span>
  }

  /**
   * Returns executor service for running queries.
   * @return
   */
  final public ListeningExecutorService getQueryRunners() {
<span class="fc" id="L124">    return queryRunners;</span>
  }

  @VisibleForTesting
  final public ExecutorService getQueryWorkers() {
<span class="nc" id="L129">    return queryWorkers;</span>
  }

  /**
   * Get the executor service for running the query. The provided executor
   * service limits the number of resources available for executing query
   * as per the configured policy
   * @param query
   * @param accountant Accountant for a scheduler group
   * @return
   */
  public abstract QueryExecutorService getExecutorService(ServerQueryRequest query, SchedulerGroupAccountant accountant);

  /**
   * Hard limit on number of threads for a scheduler group.
   * A group may not be allotted threads more than this for query execution.
   * @return number of threads
   */
  public abstract int getTableThreadsHardLimit();

  /**
   * Soft limit on the number of threads for a scheduler group.
   * Queries from a scheduler group will be de-prioritized if the group
   * is using more than the soft limit.
   * @return number of threads
   */
  public abstract int getTableThreadsSoftLimit();

  /**
   * Check if the query for a scheduler group can get required resources for scheduling
   * @param accountant resource accounting information for a group
   * @return
   */
  public boolean canSchedule(SchedulerGroupAccountant accountant) {
<span class="fc bfc" id="L163" title="All 2 branches covered.">    return accountant.totalReservedThreads() &lt; getTableThreadsHardLimit();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>