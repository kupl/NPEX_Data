<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RealtimeSegmentStatsHistory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.realtime.impl</a> &gt; <span class="el_source">RealtimeSegmentStatsHistory.java</span></div><h1>RealtimeSegmentStatsHistory.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.linkedin.pinot.core.realtime.impl;

import com.google.common.annotations.VisibleForTesting;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/*
 * Keeps history of statistics for segments consumed from kafka for a single table.
 */
public class RealtimeSegmentStatsHistory implements Serializable {
<span class="fc" id="L40">  public static Logger LOGGER = LoggerFactory.getLogger(RealtimeSegmentStatsHistory.class);</span>
  private static final long serialVersionUID = 1L;  // Change this if a new field is added to this class
  // XXX MAX_NUM_ENTRIES should be a final variable, but we need to modify it for testing.
<span class="fc" id="L43">  private static int MAX_NUM_ENTRIES = 16;  // Max number of past segments for which stats are kept</span>
  // Fields to be serialzied.
<span class="fc" id="L45">  private int _cursor = 0;</span>
  private SegmentStats[] _entries;
<span class="fc" id="L47">  private boolean _isFull = false;</span>
  private String _historyFilePath;

  // We return these values when we don't have any prior statistics.
  private final static int DEFAULT_EST_AVG_COL_SIZE = 32;
  private final static int DEFAULT_EST_CARDINALITY = 5000;

  // Not to be serialized
  transient int _arraySize;
  transient File _historyFile;

  @VisibleForTesting
  public static int getMaxNumEntries() {
<span class="fc" id="L60">    return MAX_NUM_ENTRIES;</span>
  }

  @VisibleForTesting
  public static int getDefaultEstAvgColSize() {
<span class="fc" id="L65">    return DEFAULT_EST_AVG_COL_SIZE;</span>
  }

  @VisibleForTesting
  public static int getDefaultEstCardinality() {
<span class="fc" id="L70">    return DEFAULT_EST_CARDINALITY;</span>
  }

  @VisibleForTesting
  public static void setMaxNumEntries(int maxNumEntries) {
<span class="fc" id="L75">    MAX_NUM_ENTRIES = maxNumEntries;</span>
<span class="fc" id="L76">  }</span>

<span class="fc" id="L78">  public static class SegmentStats implements Serializable {</span>
    private static final long serialVersionUID = 1L;
    private int _numRowsConsumed;   // Number of rows consumed
    private int _numSeconds;        // Number of seconds taken to consume them
    private long _memUsedBytes;          // Memory used for consumption (bytes)
<span class="fc" id="L83">    private Map&lt;String, ColumnStats&gt; _colNameToStats = new HashMap();</span>

    public int getNumRowsConsumed() {
<span class="fc" id="L86">      return _numRowsConsumed;</span>
    }

    public void setNumRowsConsumed(int numRowsConsumed) {
<span class="fc" id="L90">      _numRowsConsumed = numRowsConsumed;</span>
<span class="fc" id="L91">    }</span>

    public int getNumSeconds() {
<span class="fc" id="L94">      return _numSeconds;</span>
    }

    public void setNumSeconds(int numSeconds) {
<span class="fc" id="L98">      _numSeconds = numSeconds;</span>
<span class="fc" id="L99">    }</span>

    public long getMemUsedBytes() {
<span class="fc" id="L102">      return _memUsedBytes;</span>
    }

    public void setMemUsedBytes(long memUsedBytes) {
<span class="fc" id="L106">      _memUsedBytes = memUsedBytes;</span>
<span class="fc" id="L107">    }</span>

    public void setColumnStats(@Nonnull String columnName, @Nonnull ColumnStats columnStats) {
<span class="fc" id="L110">      _colNameToStats.put(columnName, columnStats);</span>
<span class="fc" id="L111">    }</span>

    public @Nullable ColumnStats getColumnStats(String columnName) {
<span class="fc" id="L114">      return _colNameToStats.get(columnName);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L119">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L120">      sb.append(&quot;nRows=&quot; + getNumRowsConsumed())</span>
          .append(&quot;,nMinutes=&quot; + getNumSeconds())
          .append(&quot;,memUsed=&quot; + getMemUsedBytes());

<span class="nc bnc" id="L124" title="All 2 branches missed.">      for (Map.Entry&lt;String, ColumnStats&gt; entry : _colNameToStats.entrySet()) {</span>
<span class="nc" id="L125">        sb.append(&quot;,&quot;)</span>
            .append(entry.getKey())
            .append(&quot;:&quot;)
            .append(entry.getValue().toString());
<span class="nc" id="L129">      }</span>
<span class="nc" id="L130">      return sb.toString();</span>
    }
  }

<span class="fc" id="L134">  public static class ColumnStats implements Serializable {</span>
    private static final long serialVersionUID = 1L;  // Change this if a new field is added to this class

    private int _avgColumnSize;     // Used only for string columns when building dictionary
    private int _cardinality;       // Used for all dictionary columns

    public int getCardinality() {
<span class="fc" id="L141">      return _cardinality;</span>
    }

    public void setCardinality(int cardinality) {
<span class="fc" id="L145">      _cardinality = cardinality;</span>
<span class="fc" id="L146">    }</span>

    public int getAvgColumnSize() {
<span class="fc" id="L149">      return _avgColumnSize;</span>
    }

    public void setAvgColumnSize(int avgColumnSize) {
<span class="fc" id="L153">      _avgColumnSize = avgColumnSize;</span>
<span class="fc" id="L154">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L158">      return &quot;cardinality=&quot; + getCardinality() + &quot;,avgSize=&quot; + getAvgColumnSize();</span>
    }
  }

  /**
   * Constructor called when there is no file present.
   *
   * @param historyFilePath
   */
<span class="fc" id="L167">  private RealtimeSegmentStatsHistory(String historyFilePath) {</span>
<span class="fc" id="L168">    _entries = new SegmentStats[MAX_NUM_ENTRIES];</span>
<span class="fc" id="L169">    _historyFilePath = historyFilePath;</span>
<span class="fc" id="L170">    _historyFile = new File(_historyFilePath);</span>
<span class="fc" id="L171">    normalize();</span>
<span class="fc" id="L172">  }</span>

  // We may choose to change the number of segments we keep in history. So, if MAX_NUM_ENTRIES is changed,
  // then after deserialization we need to copy old array entries to an array of new size. Depending on
  // whether the new size is higher or lower, the values of _cursor and _isFull will change.
  private void normalize() {
<span class="fc bfc" id="L178" title="All 2 branches covered.">    if (_entries.length == MAX_NUM_ENTRIES) {</span>
<span class="fc" id="L179">      _arraySize = MAX_NUM_ENTRIES;</span>
<span class="fc" id="L180">      return;</span>
    }
    int toCopy;
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (isFull()) {</span>
<span class="fc" id="L184">      toCopy = Math.min(_entries.length, MAX_NUM_ENTRIES);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">      if (_entries.length &gt; MAX_NUM_ENTRIES) {</span>
<span class="fc" id="L186">        _cursor = 0;</span>
      } else {
<span class="fc" id="L188">        _isFull = false;</span>
<span class="fc" id="L189">        _cursor = _entries.length;</span>
      }
    } else {
<span class="fc" id="L192">      toCopy = Math.min(_cursor, MAX_NUM_ENTRIES);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">      if (_cursor &gt; MAX_NUM_ENTRIES) {</span>
<span class="nc" id="L194">        _cursor = 0;</span>
<span class="nc" id="L195">        _isFull = true;</span>
      }
    }

<span class="fc" id="L199">    SegmentStats[] tmp = _entries;</span>
<span class="fc" id="L200">    _entries = new SegmentStats[MAX_NUM_ENTRIES];</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">    for (int i = 0; i &lt; toCopy; i++) {</span>
<span class="fc" id="L203">      _entries[i] = tmp[i];</span>
    }
<span class="fc" id="L205">    _arraySize = _entries.length;</span>
<span class="fc" id="L206">  }</span>

  public int getCursor() {
<span class="fc" id="L209">    return _cursor;</span>
  }

  public int getArraySize() {
<span class="fc" id="L213">    return _arraySize;</span>
  }

  public boolean isFull() {
<span class="fc" id="L217">    return _isFull;</span>
  }

  public synchronized void addSegmentStats(SegmentStats segmentStats) {
<span class="fc" id="L221">    _entries[_cursor] = segmentStats;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">    if (_cursor &gt;= _arraySize -1) {</span>
<span class="fc" id="L223">      _isFull = true;</span>
    }
<span class="fc" id="L225">    _cursor = (_cursor + 1) % _arraySize;</span>
<span class="fc" id="L226">  }</span>

  /**
   * Estimate the cardinality of a column based on past segments of a table
   * For now, we return the average value.
   *
   * @param columnName
   * @return estimated
   */
  public synchronized int getEstimatedCardinality(@Nonnull String columnName) {
<span class="fc" id="L236">    int numEntriesToScan = getNumntriesToScan();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">    if (numEntriesToScan == 0) {</span>
<span class="fc" id="L238">      return DEFAULT_EST_CARDINALITY;</span>
    }
<span class="fc" id="L240">    int totalCardinality = 0;</span>
<span class="fc" id="L241">    int numValidValues = 0;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    for (int i = 0; i &lt; numEntriesToScan; i++) {</span>
<span class="fc" id="L243">      SegmentStats segmentStats = getSegmentStatsAt(i);</span>
<span class="fc" id="L244">      ColumnStats columnStats = segmentStats.getColumnStats(columnName);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">      if (columnStats != null) {</span>
<span class="fc" id="L246">        totalCardinality += columnStats.getCardinality();</span>
<span class="fc" id="L247">        numValidValues++;</span>
      }
    }
<span class="fc bfc" id="L250" title="All 2 branches covered.">    if (numValidValues &gt; 0) {</span>
<span class="fc" id="L251">      int avgEstimatedCardinality = totalCardinality /numValidValues;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">      if (avgEstimatedCardinality &gt; 0) {</span>
<span class="fc" id="L253">        return avgEstimatedCardinality;</span>
      }
    }
<span class="fc" id="L256">    return DEFAULT_EST_CARDINALITY;</span>
  }

  /**
   * Estimate the average size of a string column based on the past segments of the table.
   * For now, we return the average value.
   *
   * @param columnName
   * @return estimated average string size
   */
  public synchronized int getEstimatedAvgColSize(@Nonnull String columnName) {
<span class="fc" id="L267">    int numEntriesToScan = getNumntriesToScan();</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">    if (numEntriesToScan == 0) {</span>
<span class="fc" id="L269">      return DEFAULT_EST_AVG_COL_SIZE;</span>
    }
<span class="fc" id="L271">    int totalColSize = 0;</span>
<span class="fc" id="L272">    int numValidValues = 0;</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (int i = 0; i &lt; numEntriesToScan; i++) {</span>
<span class="fc" id="L274">      SegmentStats segmentStats = getSegmentStatsAt(i);</span>
<span class="fc" id="L275">      ColumnStats columnStats = segmentStats.getColumnStats(columnName);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      if (columnStats != null) {</span>
<span class="fc" id="L277">        totalColSize += columnStats.getAvgColumnSize();</span>
<span class="fc" id="L278">        numValidValues++;</span>
      }
    }
<span class="fc bfc" id="L281" title="All 2 branches covered.">    if (numValidValues &gt; 0) {</span>
<span class="fc" id="L282">      int avgColSize = totalColSize / numValidValues;</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">      if (avgColSize &gt; 0) {</span>
<span class="fc" id="L284">        return avgColSize;</span>
      }
    }
<span class="fc" id="L287">    return DEFAULT_EST_AVG_COL_SIZE;</span>
  }

  public SegmentStats getSegmentStatsAt(int index) {
<span class="fc" id="L291">    return _entries[index];</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L296">    return &quot;cursor=&quot; + getCursor() + &quot;,numEntries=&quot; + getArraySize() + &quot;,isFull=&quot; + isFull();</span>
  }

  public synchronized void save() {
<span class="pc" id="L300">    try (OutputStream os = new FileOutputStream(new File(_historyFilePath));</span>
<span class="fc" id="L301">        ObjectOutputStream obos = new ObjectOutputStream(os)</span>
    ) {
<span class="fc" id="L303">      obos.writeObject(this);</span>
<span class="fc" id="L304">      obos.flush();</span>
<span class="fc" id="L305">      os.flush();</span>
<span class="pc bpc" id="L306" title="12 of 16 branches missed.">    } catch (IOException e) {</span>
<span class="nc" id="L307">      LOGGER.warn(&quot;Could not update stats file {}&quot;, _historyFile, e);</span>
<span class="fc" id="L308">    }</span>
<span class="fc" id="L309">  }</span>

  public static synchronized RealtimeSegmentStatsHistory deserialzeFrom(File inFile) throws IOException, ClassNotFoundException {
<span class="fc bfc" id="L312" title="All 2 branches covered.">    if (inFile.exists()) {</span>
<span class="pc" id="L313">      try (FileInputStream is = new FileInputStream(inFile); ObjectInputStream obis = new ObjectInputStream(is)) {</span>
<span class="fc" id="L314">        RealtimeSegmentStatsHistory history = (RealtimeSegmentStatsHistory) (obis.readObject());</span>
<span class="fc" id="L315">        history.normalize();</span>
<span class="fc" id="L316">        return history;</span>
<span class="pc bpc" id="L317" title="12 of 16 branches missed.">      }</span>
    } else {
<span class="fc" id="L319">      return new RealtimeSegmentStatsHistory(inFile.getAbsolutePath());</span>
    }
  }

  private int getNumntriesToScan() {
<span class="fc bfc" id="L324" title="All 2 branches covered.">    if (isFull()) {</span>
<span class="fc" id="L325">      return getArraySize();</span>
    }
<span class="fc" id="L327">    return getCursor();</span>
  }

  public static void main(String[] args) throws Exception {
<span class="nc" id="L331">    RealtimeSegmentStatsHistory history = RealtimeSegmentStatsHistory.deserialzeFrom(new File(&quot;/tmp/stats.ser&quot;));</span>
<span class="nc" id="L332">    System.out.println(history.toString());</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">    for (int i = 0; i &lt;history.getNumntriesToScan(); i++) {</span>
<span class="nc" id="L334">      SegmentStats segmentStats = history.getSegmentStatsAt(i);</span>
<span class="nc" id="L335">      System.out.println(segmentStats.toString());</span>

    }
<span class="nc" id="L338">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>