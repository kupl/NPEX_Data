<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PinotDataBitSet.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.io.util</a> &gt; <span class="el_source">PinotDataBitSet.java</span></div><h1>PinotDataBitSet.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.io.util;

import com.linkedin.pinot.core.segment.memory.PinotDataBuffer;
import java.io.Closeable;


public final class PinotDataBitSet implements Closeable {
<span class="fc" id="L23">  private static final int[] NUM_BITS_SET = new int[1 &lt;&lt; Byte.SIZE];</span>
<span class="fc" id="L24">  private static final int[][] NTH_BIT_SET = new int[Byte.SIZE][1 &lt;&lt; Byte.SIZE];</span>
<span class="fc" id="L25">  private static final int[] FIRST_BIT_SET = NTH_BIT_SET[0];</span>
  private static final int BYTE_MASK = 0xFF;

  static {
<span class="fc bfc" id="L29" title="All 2 branches covered.">    for (int i = 0; i &lt; (1 &lt;&lt; Byte.SIZE); i++) {</span>
<span class="fc" id="L30">      int numBitsSet = 0;</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">      for (int j = 0; j &lt; Byte.SIZE; j++) {</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">        if ((i &amp; (0x80 &gt;&gt;&gt; j)) != 0) {</span>
<span class="fc" id="L33">          NUM_BITS_SET[i]++;</span>
<span class="fc" id="L34">          NTH_BIT_SET[numBitsSet][i] = j;</span>
<span class="fc" id="L35">          numBitsSet++;</span>
        }
      }
    }
<span class="fc" id="L39">  }</span>

  private final PinotDataBuffer _dataBuffer;

<span class="fc" id="L43">  public PinotDataBitSet(PinotDataBuffer dataBuffer) {</span>
<span class="fc" id="L44">    _dataBuffer = dataBuffer;</span>
<span class="fc" id="L45">  }</span>

  public int readInt(int index, int numBitsPerValue) {
<span class="fc" id="L48">    long bitOffset = (long) index * numBitsPerValue;</span>
<span class="fc" id="L49">    int byteOffset = (int) (bitOffset / Byte.SIZE);</span>
<span class="fc" id="L50">    int bitOffsetInFirstByte = (int) (bitOffset % Byte.SIZE);</span>

    // Initiated with the value in first byte
<span class="fc" id="L53">    int currentValue = _dataBuffer.getByte(byteOffset) &amp; (BYTE_MASK &gt;&gt;&gt; bitOffsetInFirstByte);</span>

<span class="fc" id="L55">    int numBitsLeft = numBitsPerValue - (Byte.SIZE - bitOffsetInFirstByte);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">    if (numBitsLeft &lt;= 0) {</span>
      // The value is inside the first byte
<span class="fc" id="L58">      return currentValue &gt;&gt;&gt; -numBitsLeft;</span>
    } else {
      // The value is in multiple bytes
<span class="fc bfc" id="L61" title="All 2 branches covered.">      while (numBitsLeft &gt; Byte.SIZE) {</span>
<span class="fc" id="L62">        currentValue = (currentValue &lt;&lt; Byte.SIZE) | (_dataBuffer.getByte(++byteOffset) &amp; BYTE_MASK);</span>
<span class="fc" id="L63">        numBitsLeft -= Byte.SIZE;</span>
      }
<span class="fc" id="L65">      return (currentValue &lt;&lt; numBitsLeft) | ((_dataBuffer.getByte(byteOffset + 1) &amp; BYTE_MASK) &gt;&gt;&gt; (Byte.SIZE</span>
          - numBitsLeft));
    }
  }

  public void readInt(int startIndex, int numBitsPerValue, int length, int[] buffer) {
<span class="fc" id="L71">    long startBitOffset = (long) startIndex * numBitsPerValue;</span>
<span class="fc" id="L72">    int byteOffset = (int) (startBitOffset / Byte.SIZE);</span>
<span class="fc" id="L73">    int bitOffsetInFirstByte = (int) (startBitOffset % Byte.SIZE);</span>

    // Initiated with the value in first byte
<span class="fc" id="L76">    int currentValue = _dataBuffer.getByte(byteOffset) &amp; (BYTE_MASK &gt;&gt;&gt; bitOffsetInFirstByte);</span>

<span class="fc bfc" id="L78" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">      if (bitOffsetInFirstByte == Byte.SIZE) {</span>
<span class="fc" id="L80">        bitOffsetInFirstByte = 0;</span>
<span class="fc" id="L81">        currentValue = _dataBuffer.getByte(++byteOffset) &amp; BYTE_MASK;</span>
      }
<span class="fc" id="L83">      int numBitsLeft = numBitsPerValue - (Byte.SIZE - bitOffsetInFirstByte);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">      if (numBitsLeft &lt;= 0) {</span>
        // The value is inside the first byte
<span class="fc" id="L86">        buffer[i] = currentValue &gt;&gt;&gt; -numBitsLeft;</span>
<span class="fc" id="L87">        bitOffsetInFirstByte = Byte.SIZE + numBitsLeft;</span>
<span class="fc" id="L88">        currentValue = currentValue &amp; (BYTE_MASK &gt;&gt;&gt; bitOffsetInFirstByte);</span>
      } else {
        // The value is in multiple bytes
<span class="fc bfc" id="L91" title="All 2 branches covered.">        while (numBitsLeft &gt; Byte.SIZE) {</span>
<span class="fc" id="L92">          currentValue = (currentValue &lt;&lt; Byte.SIZE) | (_dataBuffer.getByte(++byteOffset) &amp; BYTE_MASK);</span>
<span class="fc" id="L93">          numBitsLeft -= Byte.SIZE;</span>
        }
<span class="fc" id="L95">        int nextByte = _dataBuffer.getByte(++byteOffset) &amp; BYTE_MASK;</span>
<span class="fc" id="L96">        buffer[i] = (currentValue &lt;&lt; numBitsLeft) | (nextByte &gt;&gt;&gt; (Byte.SIZE - numBitsLeft));</span>
<span class="fc" id="L97">        bitOffsetInFirstByte = numBitsLeft;</span>
<span class="fc" id="L98">        currentValue = nextByte &amp; (BYTE_MASK &gt;&gt;&gt; bitOffsetInFirstByte);</span>
      }
    }
<span class="fc" id="L101">  }</span>

  public void writeInt(int index, int numBitsPerValue, int value) {
<span class="fc" id="L104">    long bitOffset = (long) index * numBitsPerValue;</span>
<span class="fc" id="L105">    int byteOffset = (int) (bitOffset / Byte.SIZE);</span>
<span class="fc" id="L106">    int bitOffsetInFirstByte = (int) (bitOffset % Byte.SIZE);</span>

<span class="fc" id="L108">    int firstByte = _dataBuffer.getByte(byteOffset);</span>

<span class="fc" id="L110">    int firstByteMask = BYTE_MASK &gt;&gt;&gt; bitOffsetInFirstByte;</span>
<span class="fc" id="L111">    int numBitsLeft = numBitsPerValue - (Byte.SIZE - bitOffsetInFirstByte);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (numBitsLeft &lt;= 0) {</span>
      // The value is inside the first byte
<span class="fc" id="L114">      firstByteMask &amp;= BYTE_MASK &lt;&lt; -numBitsLeft;</span>
<span class="fc" id="L115">      _dataBuffer.putByte(byteOffset, (byte) ((firstByte &amp; ~firstByteMask) | (value &lt;&lt; -numBitsLeft)));</span>
    } else {
      // The value is in multiple bytes
<span class="fc" id="L118">      _dataBuffer.putByte(byteOffset,</span>
          (byte) ((firstByte &amp; ~firstByteMask) | ((value &gt;&gt;&gt; numBitsLeft) &amp; firstByteMask)));
<span class="fc bfc" id="L120" title="All 2 branches covered.">      while (numBitsLeft &gt; Byte.SIZE) {</span>
<span class="fc" id="L121">        numBitsLeft -= Byte.SIZE;</span>
<span class="fc" id="L122">        _dataBuffer.putByte(++byteOffset, (byte) (value &gt;&gt; numBitsLeft));</span>
      }
<span class="fc" id="L124">      int lastByte = _dataBuffer.getByte(++byteOffset);</span>
<span class="fc" id="L125">      _dataBuffer.putByte(byteOffset,</span>
          (byte) ((lastByte &amp; (BYTE_MASK &gt;&gt;&gt; numBitsLeft)) | (value &lt;&lt; (Byte.SIZE - numBitsLeft))));
    }
<span class="fc" id="L128">  }</span>

  public void writeInt(int startIndex, int numBitsPerValue, int length, int[] values) {
<span class="fc" id="L131">    long startBitOffset = (long) startIndex * numBitsPerValue;</span>
<span class="fc" id="L132">    int byteOffset = (int) (startBitOffset / Byte.SIZE);</span>
<span class="fc" id="L133">    int bitOffsetInFirstByte = (int) (startBitOffset % Byte.SIZE);</span>

<span class="fc" id="L135">    int firstByte = _dataBuffer.getByte(byteOffset);</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L138">      int value = values[i];</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">      if (bitOffsetInFirstByte == Byte.SIZE) {</span>
<span class="fc" id="L140">        bitOffsetInFirstByte = 0;</span>
<span class="fc" id="L141">        firstByte = _dataBuffer.getByte(++byteOffset);</span>
      }
<span class="fc" id="L143">      int firstByteMask = BYTE_MASK &gt;&gt;&gt; bitOffsetInFirstByte;</span>
<span class="fc" id="L144">      int numBitsLeft = numBitsPerValue - (Byte.SIZE - bitOffsetInFirstByte);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">      if (numBitsLeft &lt;= 0) {</span>
        // The value is inside the first byte
<span class="fc" id="L147">        firstByteMask &amp;= BYTE_MASK &lt;&lt; -numBitsLeft;</span>
<span class="fc" id="L148">        firstByte = ((firstByte &amp; ~firstByteMask) | (value &lt;&lt; -numBitsLeft));</span>
<span class="fc" id="L149">        _dataBuffer.putByte(byteOffset, (byte) firstByte);</span>
<span class="fc" id="L150">        bitOffsetInFirstByte = Byte.SIZE + numBitsLeft;</span>
      } else {
        // The value is in multiple bytes
<span class="fc" id="L153">        _dataBuffer.putByte(byteOffset,</span>
            (byte) ((firstByte &amp; ~firstByteMask) | ((value &gt;&gt;&gt; numBitsLeft) &amp; firstByteMask)));
<span class="fc bfc" id="L155" title="All 2 branches covered.">        while (numBitsLeft &gt; Byte.SIZE) {</span>
<span class="fc" id="L156">          numBitsLeft -= Byte.SIZE;</span>
<span class="fc" id="L157">          _dataBuffer.putByte(++byteOffset, (byte) (value &gt;&gt; numBitsLeft));</span>
        }
<span class="fc" id="L159">        int lastByte = _dataBuffer.getByte(++byteOffset);</span>
<span class="fc" id="L160">        firstByte = (lastByte &amp; (0xFF &gt;&gt;&gt; numBitsLeft)) | (value &lt;&lt; (Byte.SIZE - numBitsLeft));</span>
<span class="fc" id="L161">        _dataBuffer.putByte(byteOffset, (byte) firstByte);</span>
<span class="fc" id="L162">        bitOffsetInFirstByte = numBitsLeft;</span>
      }
    }
<span class="fc" id="L165">  }</span>

  public void setBit(int bitOffset) {
<span class="fc" id="L168">    int byteOffset = bitOffset / Byte.SIZE;</span>
<span class="fc" id="L169">    int bitOffsetInByte = bitOffset % Byte.SIZE;</span>
<span class="fc" id="L170">    _dataBuffer.putByte(byteOffset, (byte) (_dataBuffer.getByte(byteOffset) | (0x80 &gt;&gt;&gt; bitOffsetInByte)));</span>
<span class="fc" id="L171">  }</span>

  public void unsetBit(int bitOffset) {
<span class="fc" id="L174">    int byteOffset = bitOffset / Byte.SIZE;</span>
<span class="fc" id="L175">    int bitOffsetInByte = bitOffset % Byte.SIZE;</span>
<span class="fc" id="L176">    _dataBuffer.putByte(byteOffset, (byte) (_dataBuffer.getByte(byteOffset) &amp; (0xFF7F &gt;&gt;&gt; bitOffsetInByte)));</span>
<span class="fc" id="L177">  }</span>

  public int getNextSetBitOffset(int bitOffset) {
<span class="fc" id="L180">    int byteOffset = bitOffset / Byte.SIZE;</span>
<span class="fc" id="L181">    int bitOffsetInFirstByte = bitOffset % Byte.SIZE;</span>
<span class="fc" id="L182">    int firstByte = (_dataBuffer.getByte(byteOffset) &lt;&lt; bitOffsetInFirstByte) &amp; BYTE_MASK;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (firstByte != 0) {</span>
<span class="fc" id="L184">      return bitOffset + FIRST_BIT_SET[firstByte];</span>
    }
    while (true) {
<span class="fc" id="L187">      int currentByte = _dataBuffer.getByte(++byteOffset) &amp; BYTE_MASK;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      if (currentByte != 0) {</span>
<span class="fc" id="L189">        return (byteOffset * Byte.SIZE) | FIRST_BIT_SET[currentByte];</span>
      }
<span class="fc" id="L191">    }</span>
  }

  public int getNextNthSetBitOffset(int bitOffset, int n) {
<span class="fc" id="L195">    int byteOffset = bitOffset / Byte.SIZE;</span>
<span class="fc" id="L196">    int bitOffsetInFirstByte = bitOffset % Byte.SIZE;</span>
<span class="fc" id="L197">    int firstByte = (_dataBuffer.getByte(byteOffset) &lt;&lt; bitOffsetInFirstByte) &amp; BYTE_MASK;</span>
<span class="fc" id="L198">    int numBitsSet = NUM_BITS_SET[firstByte];</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (numBitsSet &gt;= n) {</span>
<span class="fc" id="L200">      return bitOffset + NTH_BIT_SET[n - 1][firstByte];</span>
    }
    while (true) {
<span class="fc" id="L203">      n -= numBitsSet;</span>
<span class="fc" id="L204">      int currentByte = _dataBuffer.getByte(++byteOffset) &amp; BYTE_MASK;</span>
<span class="fc" id="L205">      numBitsSet = NUM_BITS_SET[currentByte];</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">      if (numBitsSet &gt;= n) {</span>
<span class="fc" id="L207">        return (byteOffset * Byte.SIZE) | NTH_BIT_SET[n - 1][currentByte];</span>
      }
<span class="fc" id="L209">    }</span>
  }

  @Override
  public void close() {
<span class="fc" id="L214">    _dataBuffer.close();</span>
<span class="fc" id="L215">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>