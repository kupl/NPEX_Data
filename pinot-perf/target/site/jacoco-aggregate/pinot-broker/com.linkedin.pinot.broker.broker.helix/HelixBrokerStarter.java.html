<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HelixBrokerStarter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-broker</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.broker.broker.helix</a> &gt; <span class="el_source">HelixBrokerStarter.java</span></div><h1>HelixBrokerStarter.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.broker.broker.helix;

import com.google.common.collect.ImmutableList;
import com.linkedin.pinot.broker.broker.AccessControlFactory;
import com.linkedin.pinot.broker.broker.BrokerServerBuilder;
import com.linkedin.pinot.broker.routing.HelixExternalViewBasedRouting;
import com.linkedin.pinot.common.metadata.ZKMetadataProvider;
import com.linkedin.pinot.common.metrics.BrokerMeter;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.common.utils.ControllerTenantNameBuilder;
import com.linkedin.pinot.common.utils.NetUtil;
import com.linkedin.pinot.common.utils.ServiceStatus;
import com.linkedin.pinot.common.utils.StringUtil;
import com.yammer.metrics.core.MetricsRegistry;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.commons.lang.StringUtils;
import org.apache.helix.HelixAdmin;
import org.apache.helix.HelixManager;
import org.apache.helix.HelixManagerFactory;
import org.apache.helix.InstanceType;
import org.apache.helix.PreConnectCallback;
import org.apache.helix.ZNRecord;
import org.apache.helix.model.InstanceConfig;
import org.apache.helix.participant.StateMachineEngine;
import org.apache.helix.participant.statemachine.StateModelFactory;
import org.apache.helix.store.zk.ZkHelixPropertyStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Helix Broker Startable
 *
 *
 */
public class HelixBrokerStarter {

  private static final String PROPERTY_STORE = &quot;PROPERTYSTORE&quot;;

  private final HelixManager _spectatorHelixManager;
  private final HelixManager _helixManager;
  private final HelixAdmin _helixAdmin;
  private final Configuration _pinotHelixProperties;
  private final HelixExternalViewBasedRouting _helixExternalViewBasedRouting;
  private final BrokerServerBuilder _brokerServerBuilder;
  private final ZkHelixPropertyStore&lt;ZNRecord&gt; _propertyStore;
  private final LiveInstancesChangeListenerImpl _liveInstancesListener;
  private final MetricsRegistry _metricsRegistry;

  // Set after broker is started, which is actually in the constructor.
  private AccessControlFactory _accessControlFactory;

<span class="fc" id="L72">  private static final Logger LOGGER = LoggerFactory.getLogger(HelixBrokerStarter.class);</span>

  private static final String ROUTING_TABLE_PARAMS_SUBSET_KEY =
      &quot;pinot.broker.routing.table&quot;;

  public HelixBrokerStarter(String helixClusterName, String zkServer, Configuration pinotHelixProperties)
      throws Exception {
<span class="fc" id="L79">    this(null, helixClusterName, zkServer, pinotHelixProperties);</span>
<span class="fc" id="L80">  }</span>

  public HelixBrokerStarter(String brokerHost, String helixClusterName, String zkServer, Configuration pinotHelixProperties)
<span class="fc" id="L83">      throws Exception {</span>
<span class="fc" id="L84">    LOGGER.info(&quot;Starting Pinot broker&quot;);</span>

<span class="fc" id="L86">    _liveInstancesListener = new LiveInstancesChangeListenerImpl(helixClusterName);</span>

<span class="fc" id="L88">    _pinotHelixProperties = DefaultHelixBrokerConfig.getDefaultBrokerConf(pinotHelixProperties);</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">    if (brokerHost == null) {</span>
<span class="fc" id="L91">      brokerHost = NetUtil.getHostAddress();</span>
    }

<span class="fc" id="L94">    final String brokerId =</span>
        _pinotHelixProperties.getString(
                CommonConstants.Helix.Instance.INSTANCE_ID_KEY,
                CommonConstants.Helix.PREFIX_OF_BROKER_INSTANCE
                        + brokerHost
                        + &quot;_&quot;
                        + _pinotHelixProperties.getInt(CommonConstants.Helix.KEY_OF_BROKER_QUERY_PORT,
                    CommonConstants.Helix.DEFAULT_BROKER_QUERY_PORT));

<span class="fc" id="L103">    _pinotHelixProperties.addProperty(CommonConstants.Broker.CONFIG_OF_BROKER_ID, brokerId);</span>
<span class="fc" id="L104">    setupHelixSystemProperties();</span>

    // Remove all white-spaces from the list of zkServers (if any).
<span class="fc" id="L107">    String zkServers = zkServer.replaceAll(&quot;\\s+&quot;, &quot;&quot;);</span>

<span class="fc" id="L109">    LOGGER.info(&quot;Connecting Helix components&quot;);</span>
    // Connect spectator Helix manager.
<span class="fc" id="L111">    _spectatorHelixManager =</span>
        HelixManagerFactory.getZKHelixManager(helixClusterName, brokerId, InstanceType.SPECTATOR, zkServers);
<span class="fc" id="L113">    _spectatorHelixManager.connect();</span>
<span class="fc" id="L114">    _helixAdmin = _spectatorHelixManager.getClusterManagmentTool();</span>
<span class="fc" id="L115">    _propertyStore = _spectatorHelixManager.getHelixPropertyStore();</span>
<span class="fc" id="L116">    _helixExternalViewBasedRouting = new HelixExternalViewBasedRouting(_propertyStore, _spectatorHelixManager,</span>
        pinotHelixProperties.subset(ROUTING_TABLE_PARAMS_SUBSET_KEY));
<span class="fc" id="L118">    _brokerServerBuilder = startBroker(_pinotHelixProperties);</span>
<span class="fc" id="L119">    _metricsRegistry = _brokerServerBuilder.getMetricsRegistry();</span>
<span class="fc" id="L120">    ClusterChangeMediator clusterChangeMediator =</span>
        new ClusterChangeMediator(_helixExternalViewBasedRouting, _brokerServerBuilder.getBrokerMetrics());
<span class="fc" id="L122">    _spectatorHelixManager.addExternalViewChangeListener(clusterChangeMediator);</span>
<span class="fc" id="L123">    _spectatorHelixManager.addInstanceConfigChangeListener(clusterChangeMediator);</span>
<span class="fc" id="L124">    _spectatorHelixManager.addLiveInstanceChangeListener(_liveInstancesListener);</span>

    // Connect participant Helix manager.
<span class="fc" id="L127">    _helixManager =</span>
        HelixManagerFactory.getZKHelixManager(helixClusterName, brokerId, InstanceType.PARTICIPANT, zkServers);
<span class="fc" id="L129">    StateMachineEngine stateMachineEngine = _helixManager.getStateMachineEngine();</span>
<span class="fc" id="L130">    StateModelFactory&lt;?&gt; stateModelFactory =</span>
        new BrokerResourceOnlineOfflineStateModelFactory(_spectatorHelixManager, _propertyStore, _helixExternalViewBasedRouting);
<span class="fc" id="L132">    stateMachineEngine.registerStateModelFactory(BrokerResourceOnlineOfflineStateModelFactory.getStateModelDef(),</span>
        stateModelFactory);
<span class="fc" id="L134">    _helixManager.connect();</span>
<span class="fc" id="L135">    addInstanceTagIfNeeded(helixClusterName, brokerId);</span>

    // Register the service status handler
<span class="fc" id="L138">    ServiceStatus.setServiceStatusCallback(</span>
        new ServiceStatus.MultipleCallbackServiceStatusCallback(ImmutableList.of(
            new ServiceStatus.IdealStateAndCurrentStateMatchServiceStatusCallback(_helixManager, helixClusterName, brokerId),
            new ServiceStatus.IdealStateAndExternalViewMatchServiceStatusCallback(_helixManager, helixClusterName, brokerId)
        )));

<span class="fc" id="L144">    _brokerServerBuilder.getBrokerMetrics().addCallbackGauge(</span>
<span class="fc" id="L145">        &quot;helix.connected&quot;, new Callable&lt;Long&gt;() {</span>
          @Override
          public Long call() throws Exception {
<span class="nc bnc" id="L148" title="All 2 branches missed.">            return _helixManager.isConnected() ? 1L : 0L;</span>
          }
        });

<span class="fc" id="L152">    _helixManager.addPreConnectCallback(</span>
<span class="fc" id="L153">        new PreConnectCallback() {</span>
          @Override
          public void onPreConnect() {
<span class="nc" id="L156">            _brokerServerBuilder.getBrokerMetrics()</span>
            .addMeteredGlobalValue(BrokerMeter.HELIX_ZOOKEEPER_RECONNECTS, 1L);
<span class="nc" id="L158">          }</span>
        });
<span class="fc" id="L160">  }</span>

  private void setupHelixSystemProperties() {
<span class="fc" id="L163">    final String helixFlappingTimeWindowPropName = &quot;helixmanager.flappingTimeWindow&quot;;</span>
<span class="fc" id="L164">    System.setProperty(helixFlappingTimeWindowPropName,</span>
        _pinotHelixProperties.getString(DefaultHelixBrokerConfig.HELIX_FLAPPING_TIME_WINDOW_NAME,
            DefaultHelixBrokerConfig.DEFAULT_HELIX_FLAPPING_TIMEIWINDWOW_MS));
<span class="fc" id="L167">  }</span>

  private void addInstanceTagIfNeeded(String clusterName, String instanceName) {
<span class="fc" id="L170">    InstanceConfig instanceConfig = _helixAdmin.getInstanceConfig(clusterName, instanceName);</span>
<span class="fc" id="L171">    List&lt;String&gt; instanceTags = instanceConfig.getTags();</span>
<span class="pc bpc" id="L172" title="2 of 4 branches missed.">    if (instanceTags == null || instanceTags.isEmpty()) {</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">      if (ZKMetadataProvider.getClusterTenantIsolationEnabled(_propertyStore)) {</span>
<span class="fc" id="L174">        _helixAdmin.addInstanceTag(clusterName, instanceName,</span>
            ControllerTenantNameBuilder.getBrokerTenantNameForTenant(ControllerTenantNameBuilder.DEFAULT_TENANT_NAME));
      } else {
<span class="fc" id="L177">        _helixAdmin.addInstanceTag(clusterName, instanceName, CommonConstants.Helix.UNTAGGED_BROKER_INSTANCE);</span>
      }
    }
<span class="fc" id="L180">  }</span>

  private BrokerServerBuilder startBroker(Configuration config) throws Exception {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">    if (config == null) {</span>
<span class="nc" id="L184">      config = DefaultHelixBrokerConfig.getDefaultBrokerConf();</span>
    }
<span class="fc" id="L186">    final BrokerServerBuilder brokerServerBuilder =</span>
        new BrokerServerBuilder(config, _helixExternalViewBasedRouting,
            _helixExternalViewBasedRouting.getTimeBoundaryService(), _liveInstancesListener);
<span class="fc" id="L189">    brokerServerBuilder.buildNetwork();</span>
<span class="fc" id="L190">    brokerServerBuilder.buildHTTP();</span>
<span class="fc" id="L191">    _accessControlFactory = brokerServerBuilder.getAccessControlFactory();</span>
<span class="fc" id="L192">    _helixExternalViewBasedRouting.setBrokerMetrics(brokerServerBuilder.getBrokerMetrics());</span>
<span class="fc" id="L193">    brokerServerBuilder.start();</span>

<span class="fc" id="L195">    LOGGER.info(&quot;Pinot broker ready and listening on port {} for API requests&quot;,</span>
        config.getProperty(&quot;pinot.broker.client.queryPort&quot;));

<span class="fc" id="L198">    Runtime.getRuntime().addShutdownHook(new Thread() {</span>
      @Override
      public void run() {
        try {
<span class="fc" id="L202">          brokerServerBuilder.stop();</span>
<span class="nc" id="L203">        } catch (final Exception e) {</span>
<span class="nc" id="L204">          LOGGER.error(&quot;Caught exception while running shutdown hook&quot;, e);</span>
<span class="fc" id="L205">        }</span>
<span class="fc" id="L206">      }</span>
    });
<span class="fc" id="L208">    return brokerServerBuilder;</span>
  }

  public AccessControlFactory getAccessControlFactory() {
<span class="nc" id="L212">    return _accessControlFactory;</span>
  }

  /**
   * The zk string format should be 127.0.0.1:3000,127.0.0.1:3001/app/a which applies
   * the /helixClusterName/PROPERTY_STORE after chroot to all servers.
   * Expected output for this method is:
   * 127.0.0.1:3000/app/a/helixClusterName/PROPERTY_STORE,127.0.0.1:3001/app/a/helixClusterName/PROPERTY_STORE
   *
   * @param zkServers
   * @param helixClusterName
   * @return the full property store path
   *
   * @see org.apache.zookeeper.ZooKeeper#ZooKeeper(String, int, org.apache.zookeeper.Watcher)
   */
  public static String getZkAddressForBroker(String zkServers, String helixClusterName) {
<span class="fc" id="L228">    List tokens = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L229">    String[] zkSplit = zkServers.split(&quot;/&quot;, 2);</span>
<span class="fc" id="L230">    String zkHosts = zkSplit[0];</span>
<span class="fc" id="L231">    String zkPathSuffix = StringUtil.join(&quot;/&quot;, helixClusterName, PROPERTY_STORE);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    if (zkSplit.length &gt; 1) {</span>
<span class="fc" id="L233">      zkPathSuffix = zkSplit[1] + &quot;/&quot; + zkPathSuffix;</span>
    }
<span class="fc bfc" id="L235" title="All 2 branches covered.">    for (String token : zkHosts.split(&quot;,&quot;)) {</span>
<span class="fc" id="L236">      tokens.add(StringUtil.join(&quot;/&quot;, StringUtils.chomp(token, &quot;/&quot;), zkPathSuffix));</span>
    }
<span class="fc" id="L238">    return StringUtils.join(tokens, &quot;,&quot;);</span>
  }

  public HelixManager getSpectatorHelixManager() {
<span class="nc" id="L242">    return _spectatorHelixManager;</span>
  }

  public HelixExternalViewBasedRouting getHelixExternalViewBasedRouting() {
<span class="fc" id="L246">    return _helixExternalViewBasedRouting;</span>
  }

  public BrokerServerBuilder getBrokerServerBuilder() {
<span class="fc" id="L250">    return _brokerServerBuilder;</span>
  }

  public static HelixBrokerStarter startDefault() throws Exception {
<span class="nc" id="L254">    Configuration configuration = new PropertiesConfiguration();</span>
<span class="nc" id="L255">    int port = 5001;</span>
<span class="nc" id="L256">    configuration.addProperty(CommonConstants.Helix.KEY_OF_BROKER_QUERY_PORT, port);</span>
<span class="nc" id="L257">    configuration.addProperty(&quot;pinot.broker.timeoutMs&quot;, 500 * 1000L);</span>

<span class="nc" id="L259">    final HelixBrokerStarter pinotHelixBrokerStarter =</span>
        new HelixBrokerStarter(null, &quot;quickstart&quot;, &quot;localhost:2122&quot;, configuration);
<span class="nc" id="L261">    return pinotHelixBrokerStarter;</span>
  }

  public void shutdown() {
<span class="nc" id="L265">    LOGGER.info(&quot;Shutting down&quot;);</span>

<span class="nc bnc" id="L267" title="All 2 branches missed.">    if (_helixManager != null) {</span>
<span class="nc" id="L268">      LOGGER.info(&quot;Disconnecting Helix manager&quot;);</span>
<span class="nc" id="L269">      _helixManager.disconnect();</span>
    }

<span class="nc bnc" id="L272" title="All 2 branches missed.">    if (_spectatorHelixManager != null) {</span>
<span class="nc" id="L273">      LOGGER.info(&quot;Disconnecting spectator Helix manager&quot;);</span>
<span class="nc" id="L274">      _spectatorHelixManager.disconnect();</span>
    }
<span class="nc" id="L276">  }</span>

  public MetricsRegistry getMetricsRegistry() {
<span class="nc" id="L279">    return _metricsRegistry;</span>
  }

  public static void main(String[] args) throws Exception {
<span class="nc" id="L283">    startDefault();</span>
<span class="nc" id="L284">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>