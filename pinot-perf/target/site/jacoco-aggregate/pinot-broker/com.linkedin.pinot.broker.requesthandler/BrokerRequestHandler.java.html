<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BrokerRequestHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-broker</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.broker.requesthandler</a> &gt; <span class="el_source">BrokerRequestHandler.java</span></div><h1>BrokerRequestHandler.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.broker.requesthandler;

import com.google.common.base.Splitter;
import com.linkedin.pinot.broker.api.RequesterIdentity;
import com.linkedin.pinot.broker.broker.AccessControlFactory;
import com.linkedin.pinot.broker.pruner.SegmentZKMetadataPrunerService;
import com.linkedin.pinot.broker.routing.RoutingTable;
import com.linkedin.pinot.broker.routing.RoutingTableLookupRequest;
import com.linkedin.pinot.broker.routing.TimeBoundaryService;
import com.linkedin.pinot.broker.routing.TimeBoundaryService.TimeBoundaryInfo;
import com.linkedin.pinot.common.config.TableNameBuilder;
import com.linkedin.pinot.common.exception.QueryException;
import com.linkedin.pinot.common.metrics.BrokerMeter;
import com.linkedin.pinot.common.metrics.BrokerMetrics;
import com.linkedin.pinot.common.metrics.BrokerQueryPhase;
import com.linkedin.pinot.common.query.ReduceService;
import com.linkedin.pinot.common.query.ReduceServiceRegistry;
import com.linkedin.pinot.common.request.BrokerRequest;
import com.linkedin.pinot.common.request.FilterOperator;
import com.linkedin.pinot.common.request.FilterQuery;
import com.linkedin.pinot.common.request.FilterQueryMap;
import com.linkedin.pinot.common.request.InstanceRequest;
import com.linkedin.pinot.common.response.BrokerResponse;
import com.linkedin.pinot.common.response.BrokerResponseFactory;
import com.linkedin.pinot.common.response.BrokerResponseFactory.ResponseType;
import com.linkedin.pinot.common.response.ProcessingException;
import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.common.utils.DataTable;
import com.linkedin.pinot.core.common.datatable.DataTableFactory;
import com.linkedin.pinot.pql.parsers.Pql2Compiler;
import com.linkedin.pinot.serde.SerDe;
import com.linkedin.pinot.transport.common.CompositeFuture;
import com.linkedin.pinot.transport.scattergather.ScatterGather;
import com.linkedin.pinot.transport.scattergather.ScatterGatherRequest;
import com.linkedin.pinot.transport.scattergather.ScatterGatherStats;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.concurrent.ThreadSafe;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.lang3.StringUtils;
import org.apache.thrift.protocol.TCompactProtocol;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The &lt;code&gt;BrokerRequestHandler&lt;/code&gt; class is a thread-safe broker request handler. Clients can submit multiple
 * requests to be processed parallel.
 */
@ThreadSafe
public class BrokerRequestHandler {
<span class="fc" id="L79">  private static final Logger LOGGER = LoggerFactory.getLogger(BrokerRequestHandler.class);</span>
<span class="fc" id="L80">  private static final Pql2Compiler REQUEST_COMPILER = new Pql2Compiler();</span>

  private static final String BROKER_QUERY_SPLIT_IN_CLAUSE = &quot;pinot.broker.query.split.in.clause&quot;;
  private static final String BROKER_QUERY_LOG_LENGTH = &quot;pinot.broker.query.log.length&quot;;
<span class="fc" id="L84">  private static final ResponseType DEFAULT_BROKER_RESPONSE_TYPE = ResponseType.BROKER_RESPONSE_TYPE_NATIVE;</span>
  private static final boolean DEFAULT_BROKER_QUERY_SPLIT_IN_CLAUSE = false;
  private static final int DEFAULT_QUERY_LOG_LENGTH = Integer.MAX_VALUE;

  private final SegmentZKMetadataPrunerService _segmentPrunerService;
  private final boolean _splitInClause;
  private final int _queryLogLength;
  private final AccessControlFactory _accessControlFactory;
  private final RoutingTable _routingTable;
  private final ScatterGather _scatterGatherer;
  private final ReduceServiceRegistry _reduceServiceRegistry;
  private final BrokerMetrics _brokerMetrics;
  private final TimeBoundaryService _timeBoundaryService;
  private final long _brokerTimeOutMs;
  private final BrokerRequestOptimizer _optimizer;
  private final int _queryResponseLimit;
  private final AtomicLong _requestIdGenerator;
  private final String _brokerId;

  public BrokerRequestHandler(RoutingTable table, TimeBoundaryService timeBoundaryService,
      ScatterGather scatterGatherer, ReduceServiceRegistry reduceServiceRegistry,
      SegmentZKMetadataPrunerService segmentPrunerService, BrokerMetrics brokerMetrics, Configuration config,
<span class="fc" id="L106">      AccessControlFactory accessControlFactory) {</span>
<span class="fc" id="L107">    _routingTable = table;</span>
<span class="fc" id="L108">    _timeBoundaryService = timeBoundaryService;</span>
<span class="fc" id="L109">    _reduceServiceRegistry = reduceServiceRegistry;</span>
<span class="fc" id="L110">    _scatterGatherer = scatterGatherer;</span>
<span class="fc" id="L111">    _brokerMetrics = brokerMetrics;</span>
<span class="fc" id="L112">    _optimizer = new BrokerRequestOptimizer();</span>
<span class="fc" id="L113">    _requestIdGenerator = new AtomicLong(0);</span>
<span class="fc" id="L114">    _queryResponseLimit = config.getInt(CommonConstants.Broker.CONFIG_OF_BROKER_QUERY_RESPONSE_LIMIT,</span>
        CommonConstants.Broker.DEFAULT_BROKER_QUERY_RESPONSE_LIMIT);
<span class="fc" id="L116">    _splitInClause = config.getBoolean(BROKER_QUERY_SPLIT_IN_CLAUSE, DEFAULT_BROKER_QUERY_SPLIT_IN_CLAUSE);</span>
<span class="fc" id="L117">    _queryLogLength = config.getInt(BROKER_QUERY_LOG_LENGTH, DEFAULT_QUERY_LOG_LENGTH);</span>
<span class="fc" id="L118">    _brokerTimeOutMs = config.getLong(CommonConstants.Broker.CONFIG_OF_BROKER_TIMEOUT_MS,</span>
        CommonConstants.Broker.DEFAULT_BROKER_TIMEOUT_MS);
<span class="fc" id="L120">    _brokerId = config.getString(CommonConstants.Broker.CONFIG_OF_BROKER_ID, getDefaultBrokerId());</span>
<span class="fc" id="L121">    _segmentPrunerService = segmentPrunerService;</span>
<span class="fc" id="L122">    _accessControlFactory = accessControlFactory;</span>

<span class="fc" id="L124">    LOGGER.info(&quot;Broker response limit is: &quot; + _queryResponseLimit);</span>
<span class="fc" id="L125">    LOGGER.info(&quot;Broker timeout is - &quot; + _brokerTimeOutMs + &quot; ms&quot;);</span>
<span class="fc" id="L126">    LOGGER.info(&quot;Broker id: &quot; + _brokerId);</span>
<span class="fc" id="L127">  }</span>

  private String getDefaultBrokerId() {
<span class="fc" id="L130">    String defaultBrokerId = &quot;&quot;;</span>
    try {
<span class="fc" id="L132">      defaultBrokerId = InetAddress.getLocalHost().getHostName();</span>
<span class="nc" id="L133">    } catch (UnknownHostException e) {</span>
<span class="nc" id="L134">      LOGGER.error(&quot;Caught exception while getting default broker id&quot;, e);</span>
<span class="fc" id="L135">    }</span>
<span class="fc" id="L136">    return defaultBrokerId;</span>
  }

  /**
   * Process a JSON format request.
   *
   * @param request JSON format request to be processed.
   * @param requesterIdentity
   * @return broker response.
   * @throws Exception
   */
  @Nonnull
  public BrokerResponse handleRequest(@Nonnull JSONObject request, RequesterIdentity requesterIdentity) throws Exception {
<span class="fc" id="L149">    long requestId = _requestIdGenerator.incrementAndGet();</span>
<span class="fc" id="L150">    String pql = request.getString(&quot;pql&quot;);</span>
<span class="fc" id="L151">    LOGGER.debug(&quot;Query string for requestId {}: {}&quot;, requestId, pql);</span>

<span class="fc" id="L153">    boolean isTraceEnabled = false;</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">    if (request.has(&quot;trace&quot;)) {</span>
<span class="fc" id="L155">      isTraceEnabled = Boolean.parseBoolean(request.getString(&quot;trace&quot;));</span>
<span class="fc" id="L156">      LOGGER.debug(&quot;Trace is set to: {} for requestId {}: {}&quot;, isTraceEnabled, requestId, pql);</span>
    }

<span class="fc" id="L159">    Map&lt;String, String&gt; debugOptions = null;</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (request.has(&quot;debugOptions&quot;)) {</span>
<span class="nc" id="L161">      String routingOptionParameter = request.getString(&quot;debugOptions&quot;);</span>
<span class="nc" id="L162">      debugOptions =</span>
          Splitter.on(';').omitEmptyStrings().trimResults().withKeyValueSeparator('=').split(routingOptionParameter);
<span class="nc" id="L164">      LOGGER.debug(&quot;Debug options are set to: {} for requestId {}: {}&quot;, debugOptions, requestId, pql);</span>
    }

    // Compile the request
<span class="fc" id="L168">    final long compilationStartTime = System.nanoTime();</span>
    BrokerRequest brokerRequest;
    try {
<span class="fc" id="L171">      brokerRequest = REQUEST_COMPILER.compileToBrokerRequest(pql, _splitInClause);</span>
<span class="fc" id="L172">    } catch (Exception e) {</span>
<span class="fc" id="L173">      LOGGER.info(&quot;Parsing error on requestId {}: {}, {}&quot;, requestId, pql, e.getMessage());</span>
<span class="fc" id="L174">      _brokerMetrics.addMeteredGlobalValue(BrokerMeter.REQUEST_COMPILATION_EXCEPTIONS, 1L);</span>
<span class="fc" id="L175">      return BrokerResponseFactory.getBrokerResponseWithException(DEFAULT_BROKER_RESPONSE_TYPE,</span>
          QueryException.getException(QueryException.PQL_PARSING_ERROR, e));
<span class="fc" id="L177">    }</span>
<span class="fc" id="L178">    final String tableName = brokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L179">    final String rawTableName = TableNameBuilder.extractRawTableName(tableName);</span>
<span class="fc" id="L180">    _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.REQUEST_COMPILATION,</span>
        System.nanoTime() - compilationStartTime);

<span class="fc" id="L183">    final long authStartTime = System.nanoTime();</span>
    try {
<span class="fc" id="L185">      boolean hasAccess = _accessControlFactory.create().hasAccess(requesterIdentity, brokerRequest);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">      if (!hasAccess) {</span>
<span class="nc" id="L187">        _brokerMetrics.addMeteredTableValue(brokerRequest.getQuerySource().getTableName(), BrokerMeter.REQUEST_DROPPED_DUE_TO_ACCESS_ERROR, 1);</span>
<span class="nc" id="L188">        return BrokerResponseFactory.getBrokerResponseWithException(DEFAULT_BROKER_RESPONSE_TYPE, QueryException.ACCESS_DENIED_ERROR);</span>
      }
    } finally {
<span class="pc" id="L191">      _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.AUTHORIZATION,</span>
          System.nanoTime() - authStartTime);
<span class="fc" id="L193">    }</span>

    // Get the resources hit by the request
<span class="fc" id="L196">    String offlineTableName = null;</span>
<span class="fc" id="L197">    String realtimeTableName = null;</span>
<span class="fc" id="L198">    CommonConstants.Helix.TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableName);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (tableType == CommonConstants.Helix.TableType.OFFLINE) {</span>
      // Offline table name
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">      if (_routingTable.routingTableExists(tableName)) {</span>
<span class="fc" id="L202">        offlineTableName = tableName;</span>
      }
<span class="fc bfc" id="L204" title="All 2 branches covered.">    } else if (tableType == CommonConstants.Helix.TableType.REALTIME) {</span>
      // Realtime table name
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">      if (_routingTable.routingTableExists(tableName)) {</span>
<span class="fc" id="L207">        realtimeTableName = tableName;</span>
      }
    } else {
      // Raw table name (check both OFFLINE and REALTIME)
<span class="fc" id="L211">      String offlineTableNameToCheck = TableNameBuilder.OFFLINE.tableNameWithType(tableName);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      if (_routingTable.routingTableExists(offlineTableNameToCheck)) {</span>
<span class="fc" id="L213">        offlineTableName = offlineTableNameToCheck;</span>
      }
<span class="fc" id="L215">      String realtimeTableNameToCheck = TableNameBuilder.REALTIME.tableNameWithType(tableName);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (_routingTable.routingTableExists(realtimeTableNameToCheck)) {</span>
<span class="fc" id="L217">        realtimeTableName = realtimeTableNameToCheck;</span>
      }
    }
<span class="fc bfc" id="L220" title="All 4 branches covered.">    if ((offlineTableName == null) &amp;&amp; (realtimeTableName == null)) {</span>
      // No table matches the request
<span class="fc" id="L222">      LOGGER.info(&quot;No table matches the name: {}&quot;, tableName);</span>
<span class="fc" id="L223">      _brokerMetrics.addMeteredGlobalValue(BrokerMeter.RESOURCE_MISSING_EXCEPTIONS, 1L);</span>
<span class="fc" id="L224">      return BrokerResponseFactory.getStaticNoTableHitBrokerResponse(ResponseType.BROKER_RESPONSE_TYPE_NATIVE);</span>
    }

    // Validate the request
    try {
<span class="fc" id="L229">      validateRequest(brokerRequest);</span>
<span class="nc" id="L230">    } catch (Exception e) {</span>
<span class="nc" id="L231">      LOGGER.info(&quot;Validation error on requestId {}: {}, {}&quot;, requestId, pql, e.getMessage());</span>
<span class="nc" id="L232">      _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.QUERY_VALIDATION_EXCEPTIONS, 1L);</span>
<span class="nc" id="L233">      return BrokerResponseFactory.getBrokerResponseWithException(DEFAULT_BROKER_RESPONSE_TYPE,</span>
          QueryException.getException(QueryException.QUERY_VALIDATION_ERROR, e));
<span class="fc" id="L235">    }</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (isTraceEnabled) {</span>
<span class="nc" id="L238">      brokerRequest.setEnableTrace(true);</span>
    }
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (debugOptions != null) {</span>
<span class="nc" id="L241">      brokerRequest.setDebugOptions(debugOptions);</span>
    }
<span class="fc" id="L243">    brokerRequest.setResponseFormat(ResponseType.BROKER_RESPONSE_TYPE_NATIVE.name());</span>
<span class="fc" id="L244">    _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.QUERIES, 1L);</span>

    // Execute the query.
<span class="fc" id="L247">    long executionStartTime = System.nanoTime();</span>
<span class="fc" id="L248">    ScatterGatherStats scatterGatherStats = new ScatterGatherStats();</span>
<span class="fc" id="L249">    BrokerResponse brokerResponse =</span>
        processBrokerRequest(brokerRequest, offlineTableName, realtimeTableName, scatterGatherStats, requestId);
<span class="fc" id="L251">    _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_EXECUTION,</span>
        System.nanoTime() - executionStartTime);

    // Set total query processing time.
<span class="fc" id="L255">    long totalTimeMs = TimeUnit.MILLISECONDS.convert(System.nanoTime() - compilationStartTime, TimeUnit.NANOSECONDS);</span>
<span class="fc" id="L256">    brokerResponse.setTimeUsedMs(totalTimeMs);</span>

<span class="fc" id="L258">    LOGGER.debug(&quot;Broker Response: {}&quot;, brokerResponse);</span>
    // Table name might have been changed (with suffix _OFFLINE/_REALTIME appended).
<span class="fc" id="L260">    LOGGER.info(&quot;RequestId: {}, table: {}, totalTimeMs: {}, numDocsScanned: {}, numEntriesScannedInFilter: {}, &quot;</span>
            + &quot;numEntriesScannedPostFilter: {}, totalDocs: {}, scatterGatherStats: {}, query: {}&quot;, requestId,
        brokerRequest.getQuerySource().getTableName(), totalTimeMs, brokerResponse.getNumDocsScanned(),
        brokerResponse.getNumEntriesScannedInFilter(), brokerResponse.getNumEntriesScannedPostFilter(),
        brokerResponse.getTotalDocs(), scatterGatherStats, StringUtils.substring(pql, 0, _queryLogLength));

<span class="fc" id="L266">    return brokerResponse;</span>
  }

  /**
   * Broker side validation on the broker request.
   * &lt;p&gt;Throw RuntimeException if query does not pass validation.
   * &lt;p&gt;Current validations are:
   * &lt;ul&gt;
   *   &lt;li&gt;Value for 'TOP' for aggregation group-by query is &lt;= configured value.&lt;/li&gt;
   *   &lt;li&gt;Value for 'LIMIT' for selection query is &lt;= configured value.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param brokerRequest broker request to be validated.
   */
  public void validateRequest(@Nonnull BrokerRequest brokerRequest) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">    if (brokerRequest.isSetAggregationsInfo()) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">      if (brokerRequest.isSetGroupBy()) {</span>
<span class="fc" id="L283">        long topN = brokerRequest.getGroupBy().getTopN();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (topN &gt; _queryResponseLimit) {</span>
<span class="fc" id="L285">          throw new RuntimeException(</span>
              &quot;Value for 'TOP' &quot; + topN + &quot; exceeded maximum allowed value of &quot; + _queryResponseLimit);
        }
<span class="fc" id="L288">      }</span>
    } else {
<span class="fc" id="L290">      int limit = brokerRequest.getSelections().getSize();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">      if (limit &gt; _queryResponseLimit) {</span>
<span class="fc" id="L292">        throw new RuntimeException(</span>
            &quot;Value for 'LIMIT' &quot; + limit + &quot; exceeded maximum allowed value of &quot; + _queryResponseLimit);
      }
    }
<span class="fc" id="L296">  }</span>

  /**
   * Main method to process the request.
   * &lt;p&gt;Following lifecycle stages:
   * &lt;ul&gt;
   *   &lt;li&gt;1. Find the candidate servers to be queried for each set of segments from the routing table.&lt;/li&gt;
   *   &lt;li&gt;2. Select servers for each segment set and scatter request to the servers.&lt;/li&gt;
   *   &lt;li&gt;3. Gather responses from the servers.&lt;/li&gt;
   *   &lt;li&gt;4. Deserialize the server responses.&lt;/li&gt;
   *   &lt;li&gt;5. Reduce (merge) the server responses and create a broker response to be returned.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param brokerRequest broker request to be processed.
   * @param offlineTableName offline table hit by the request.
   * @param realtimeTableName realtime table hit by the request.
   * @param scatterGatherStats scatter-gather statistics.
   * @param requestId broker request ID.
   * @return broker response.
   * @throws InterruptedException
   */
  @Nonnull
  public BrokerResponse processBrokerRequest(@Nonnull BrokerRequest brokerRequest, @Nullable String offlineTableName,
      @Nullable String realtimeTableName, @Nonnull ScatterGatherStats scatterGatherStats, long requestId)
      throws InterruptedException {
<span class="fc" id="L321">    ResponseType responseType = BrokerResponseFactory.getResponseType(brokerRequest.getResponseFormat());</span>
<span class="fc" id="L322">    LOGGER.debug(&quot;Broker Response Type: {}&quot;, responseType.name());</span>

    // TODO: get time column name from schema or table config so that we can apply it in realtime only use case.
    // We get timeColumnName from time boundary service currently, which only exists for offline table.
<span class="fc bfc" id="L326" title="All 2 branches covered.">    String timeColumnName = (offlineTableName != null) ? getTimeColumnName(offlineTableName) : null;</span>

<span class="fc" id="L328">    BrokerRequest offlineBrokerRequest = null;</span>
<span class="fc" id="L329">    BrokerRequest realtimeBrokerRequest = null;</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">    if ((offlineTableName != null) &amp;&amp; (realtimeTableName != null)) {</span>
      // Hybrid
<span class="fc" id="L332">      offlineBrokerRequest = _optimizer.optimize(getOfflineBrokerRequest(brokerRequest), timeColumnName);</span>
<span class="fc" id="L333">      realtimeBrokerRequest = _optimizer.optimize(getRealtimeBrokerRequest(brokerRequest), timeColumnName);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">    } else if (offlineTableName != null) {</span>
      // Offline only
<span class="fc" id="L336">      brokerRequest.getQuerySource().setTableName(offlineTableName);</span>
<span class="fc" id="L337">      offlineBrokerRequest = _optimizer.optimize(brokerRequest, timeColumnName);</span>
    } else {
      // Realtime only
<span class="fc" id="L340">      brokerRequest.getQuerySource().setTableName(realtimeTableName);</span>
<span class="fc" id="L341">      realtimeBrokerRequest = _optimizer.optimize(brokerRequest, timeColumnName);</span>
    }

<span class="fc" id="L344">    ReduceService reduceService = _reduceServiceRegistry.get(responseType);</span>
<span class="fc" id="L345">    return processOptimizedBrokerRequests(brokerRequest, offlineBrokerRequest, realtimeBrokerRequest, reduceService,</span>
        scatterGatherStats, requestId);
  }

  /**
   * Returns the time column name for the table name from the time boundary service.
   * Can return null if the time boundary service does not have the information.
   *
   * @param tableName Name of table for which to get the time column name
   * @return Time column name for the table.
   */
  @Nullable
  private String getTimeColumnName(@Nonnull String tableName) {
<span class="fc" id="L358">    TimeBoundaryInfo timeBoundary = _timeBoundaryService.getTimeBoundaryInfoFor(tableName);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">    return (timeBoundary != null) ? timeBoundary.getTimeColumn() : null;</span>
  }

  /**
   * Given a broker request, use it to create an offline broker request.
   *
   * @param brokerRequest original broker request.
   * @return offline broker request.
   */
  @Nonnull
  private BrokerRequest getOfflineBrokerRequest(@Nonnull BrokerRequest brokerRequest) {
<span class="fc" id="L370">    BrokerRequest offlineRequest = brokerRequest.deepCopy();</span>
<span class="fc" id="L371">    String hybridTableName = brokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L372">    String offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(hybridTableName);</span>
<span class="fc" id="L373">    offlineRequest.getQuerySource().setTableName(offlineTableName);</span>
<span class="fc" id="L374">    attachTimeBoundary(hybridTableName, offlineRequest, true);</span>
<span class="fc" id="L375">    return offlineRequest;</span>
  }

  /**
   * Given a broker request, use it to create a realtime broker request.
   *
   * @param brokerRequest original broker request.
   * @return realtime broker request.
   */
  @Nonnull
  private BrokerRequest getRealtimeBrokerRequest(@Nonnull BrokerRequest brokerRequest) {
<span class="fc" id="L386">    BrokerRequest realtimeRequest = brokerRequest.deepCopy();</span>
<span class="fc" id="L387">    String hybridTableName = brokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L388">    String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(hybridTableName);</span>
<span class="fc" id="L389">    realtimeRequest.getQuerySource().setTableName(realtimeTableName);</span>
<span class="fc" id="L390">    attachTimeBoundary(hybridTableName, realtimeRequest, false);</span>
<span class="fc" id="L391">    return realtimeRequest;</span>
  }

  /**
   * Attach time boundary to a broker request.
   *
   * @param hybridTableName hybrid table name.
   * @param brokerRequest original broker request.
   * @param isOfflineRequest flag for offline/realtime request.
   */
  private void attachTimeBoundary(@Nonnull String hybridTableName, @Nonnull BrokerRequest brokerRequest,
      boolean isOfflineRequest) {
<span class="fc" id="L403">    TimeBoundaryInfo timeBoundaryInfo =</span>
        _timeBoundaryService.getTimeBoundaryInfoFor(TableNameBuilder.OFFLINE.tableNameWithType(hybridTableName));
<span class="pc bpc" id="L405" title="3 of 6 branches missed.">    if (timeBoundaryInfo == null || timeBoundaryInfo.getTimeColumn() == null</span>
        || timeBoundaryInfo.getTimeValue() == null) {
<span class="nc" id="L407">      LOGGER.warn(&quot;No time boundary attached for table: {}&quot;, hybridTableName);</span>
<span class="nc" id="L408">      return;</span>
    }

    // Create a range filter based on the request type.
<span class="fc" id="L412">    String timeValue = timeBoundaryInfo.getTimeValue();</span>
<span class="fc" id="L413">    FilterQuery timeFilterQuery = new FilterQuery();</span>
<span class="fc" id="L414">    timeFilterQuery.setOperator(FilterOperator.RANGE);</span>
<span class="fc" id="L415">    timeFilterQuery.setColumn(timeBoundaryInfo.getTimeColumn());</span>
<span class="fc" id="L416">    timeFilterQuery.setNestedFilterQueryIds(new ArrayList&lt;Integer&gt;());</span>
<span class="fc" id="L417">    List&lt;String&gt; values = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">    if (isOfflineRequest) {</span>
<span class="fc" id="L419">      values.add(&quot;(*\t\t&quot; + timeValue + &quot;)&quot;);</span>
    } else {
<span class="fc" id="L421">      values.add(&quot;[&quot; + timeValue + &quot;\t\t*)&quot;);</span>
    }
<span class="fc" id="L423">    timeFilterQuery.setValue(values);</span>
<span class="fc" id="L424">    timeFilterQuery.setId(-1);</span>

    // Attach the range filter to the current filter.
<span class="fc" id="L427">    FilterQuery currentFilterQuery = brokerRequest.getFilterQuery();</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">    if (currentFilterQuery != null) {</span>
<span class="fc" id="L429">      FilterQuery andFilterQuery = new FilterQuery();</span>
<span class="fc" id="L430">      andFilterQuery.setOperator(FilterOperator.AND);</span>
<span class="fc" id="L431">      List&lt;Integer&gt; nestedFilterQueryIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L432">      nestedFilterQueryIds.add(currentFilterQuery.getId());</span>
<span class="fc" id="L433">      nestedFilterQueryIds.add(timeFilterQuery.getId());</span>
<span class="fc" id="L434">      andFilterQuery.setNestedFilterQueryIds(nestedFilterQueryIds);</span>
<span class="fc" id="L435">      andFilterQuery.setId(-2);</span>
<span class="fc" id="L436">      FilterQueryMap filterSubQueryMap = brokerRequest.getFilterSubQueryMap();</span>
<span class="fc" id="L437">      filterSubQueryMap.putToFilterQueryMap(timeFilterQuery.getId(), timeFilterQuery);</span>
<span class="fc" id="L438">      filterSubQueryMap.putToFilterQueryMap(andFilterQuery.getId(), andFilterQuery);</span>
<span class="fc" id="L439">      brokerRequest.setFilterQuery(andFilterQuery);</span>
<span class="fc" id="L440">      brokerRequest.setFilterSubQueryMap(filterSubQueryMap);</span>
<span class="fc" id="L441">    } else {</span>
<span class="fc" id="L442">      FilterQueryMap filterSubQueryMap = new FilterQueryMap();</span>
<span class="fc" id="L443">      filterSubQueryMap.putToFilterQueryMap(timeFilterQuery.getId(), timeFilterQuery);</span>
<span class="fc" id="L444">      brokerRequest.setFilterQuery(timeFilterQuery);</span>
<span class="fc" id="L445">      brokerRequest.setFilterSubQueryMap(filterSubQueryMap);</span>
    }
<span class="fc" id="L447">  }</span>

  /**
   * Process the optimized broker requests for both OFFLINE and REALTIME table.
   *
   * @param originalBrokerRequest original broker request.
   * @param offlineBrokerRequest broker request for OFFLINE table.
   * @param realtimeBrokerRequest broker request for REALTIME table.
   * @param reduceService reduce service.
   * @param scatterGatherStats scatter-gather statistics.
   * @param requestId request ID.
   * @return broker response.
   * @throws InterruptedException
   */
  @Nonnull
  private BrokerResponse processOptimizedBrokerRequests(@Nonnull BrokerRequest originalBrokerRequest,
      @Nullable BrokerRequest offlineBrokerRequest, @Nullable BrokerRequest realtimeBrokerRequest,
      @Nonnull ReduceService reduceService, @Nonnull ScatterGatherStats scatterGatherStats, long requestId)
      throws InterruptedException {
<span class="fc" id="L466">    ResponseType serverResponseType = BrokerResponseFactory.getResponseType(originalBrokerRequest.getResponseFormat());</span>
<span class="fc" id="L467">    PhaseTimes phaseTimes = new PhaseTimes();</span>

    // Step 1: find the candidate servers to be queried for each set of segments from the routing table.
    // Step 2: select servers for each segment set and scatter request to the servers.
<span class="fc" id="L471">    String offlineTableName = null;</span>
<span class="fc" id="L472">    CompositeFuture&lt;byte[]&gt; offlineCompositeFuture = null;</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">    if (offlineBrokerRequest != null) {</span>
<span class="fc" id="L474">      offlineTableName = offlineBrokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L475">      offlineCompositeFuture =</span>
          routeAndScatterBrokerRequest(offlineBrokerRequest, phaseTimes, scatterGatherStats, true, requestId);
    }
<span class="fc" id="L478">    String realtimeTableName = null;</span>
<span class="fc" id="L479">    CompositeFuture&lt;byte[]&gt; realtimeCompositeFuture = null;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">    if (realtimeBrokerRequest != null) {</span>
<span class="fc" id="L481">      realtimeTableName = realtimeBrokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L482">      realtimeCompositeFuture =</span>
          routeAndScatterBrokerRequest(realtimeBrokerRequest, phaseTimes, scatterGatherStats, false, requestId);
    }
<span class="fc bfc" id="L485" title="All 4 branches covered.">    if ((offlineCompositeFuture == null) &amp;&amp; (realtimeCompositeFuture == null)) {</span>
      // No server found in either OFFLINE or REALTIME table.
<span class="fc" id="L487">      return BrokerResponseFactory.getStaticEmptyBrokerResponse(serverResponseType);</span>
    }

    // Step 3: gather response from the servers.
<span class="fc" id="L491">    int numServersQueried = 0;</span>
<span class="fc" id="L492">    long gatherStartTime = System.nanoTime();</span>
<span class="fc" id="L493">    List&lt;ProcessingException&gt; processingExceptions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L494">    Map&lt;ServerInstance, byte[]&gt; offlineServerResponseMap = null;</span>
<span class="fc" id="L495">    Map&lt;ServerInstance, byte[]&gt; realtimeServerResponseMap = null;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">    if (offlineCompositeFuture != null) {</span>
<span class="fc" id="L497">      numServersQueried += offlineCompositeFuture.getNumFutures();</span>
<span class="fc" id="L498">      offlineServerResponseMap =</span>
          gatherServerResponses(offlineCompositeFuture, scatterGatherStats, true, offlineTableName,
              processingExceptions);
    }
<span class="fc bfc" id="L502" title="All 2 branches covered.">    if (realtimeCompositeFuture != null) {</span>
<span class="fc" id="L503">      numServersQueried += realtimeCompositeFuture.getNumFutures();</span>
<span class="fc" id="L504">      realtimeServerResponseMap =</span>
          gatherServerResponses(realtimeCompositeFuture, scatterGatherStats, false, realtimeTableName,
              processingExceptions);
    }
<span class="fc" id="L508">    phaseTimes.addToGatherTime(System.nanoTime() - gatherStartTime);</span>
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">    if ((offlineServerResponseMap == null) &amp;&amp; (realtimeServerResponseMap == null)) {</span>
      // No response gathered.
<span class="nc" id="L511">      return BrokerResponseFactory.getBrokerResponseWithExceptions(serverResponseType, processingExceptions);</span>
    }

    //Step 4: deserialize the server responses.
<span class="fc" id="L515">    int numServersResponded = 0;</span>
<span class="fc" id="L516">    long deserializationStartTime = System.nanoTime();</span>
<span class="fc" id="L517">    Map&lt;ServerInstance, DataTable&gt; dataTableMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">    if (offlineServerResponseMap != null) {</span>
<span class="fc" id="L519">      numServersResponded += offlineServerResponseMap.size();</span>
<span class="fc" id="L520">      deserializeServerResponses(offlineServerResponseMap, true, dataTableMap, offlineTableName, processingExceptions);</span>
    }
<span class="fc bfc" id="L522" title="All 2 branches covered.">    if (realtimeServerResponseMap != null) {</span>
<span class="fc" id="L523">      numServersResponded += realtimeServerResponseMap.size();</span>
<span class="fc" id="L524">      deserializeServerResponses(realtimeServerResponseMap, false, dataTableMap, realtimeTableName,</span>
          processingExceptions);
    }
<span class="fc" id="L527">    phaseTimes.addToDeserializationTime(System.nanoTime() - deserializationStartTime);</span>

    // Step 5: reduce (merge) the server responses and create a broker response to be returned.
<span class="fc" id="L530">    long reduceStartTime = System.nanoTime();</span>
<span class="fc" id="L531">    BrokerResponse brokerResponse =</span>
        reduceService.reduceOnDataTable(originalBrokerRequest, dataTableMap, _brokerMetrics);
<span class="fc" id="L533">    phaseTimes.addToReduceTime(System.nanoTime() - reduceStartTime);</span>

    // Set processing exceptions and number of servers queried/responded.
<span class="fc" id="L536">    brokerResponse.setExceptions(processingExceptions);</span>
<span class="fc" id="L537">    brokerResponse.setNumServersQueried(numServersQueried);</span>
<span class="fc" id="L538">    brokerResponse.setNumServersResponded(numServersResponded);</span>

    // Update broker metrics.
<span class="fc" id="L541">    String rawTableName = TableNameBuilder.extractRawTableName(originalBrokerRequest.getQuerySource().getTableName());</span>
<span class="fc" id="L542">    phaseTimes.addPhaseTimesToBrokerMetrics(_brokerMetrics, rawTableName);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">    if (brokerResponse.getExceptionsSize() &gt; 0) {</span>
<span class="fc" id="L544">      _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.BROKER_RESPONSES_WITH_PROCESSING_EXCEPTIONS, 1L);</span>
    }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">    if (numServersQueried &gt; numServersResponded) {</span>
<span class="nc" id="L547">      _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.BROKER_RESPONSES_WITH_PARTIAL_SERVERS_RESPONDED,</span>
          1L);
    }

<span class="fc" id="L551">    return brokerResponse;</span>
  }

  /**
   * Route and scatter the broker request.
   *
   * @return composite future used to gather responses.
   */
  @Nullable
  private CompositeFuture&lt;byte[]&gt; routeAndScatterBrokerRequest(@Nonnull BrokerRequest brokerRequest,
      @Nonnull PhaseTimes phaseTimes, @Nonnull ScatterGatherStats scatterGatherStats, boolean isOfflineTable,
      long requestId) throws InterruptedException {
    // Step 1: find the candidate servers to be queried for each set of segments from the routing table.
    // TODO: add checks for whether all segments are covered.
<span class="fc" id="L565">    long routingStartTime = System.nanoTime();</span>
<span class="fc" id="L566">    Map&lt;String, List&lt;String&gt;&gt; routingTable =</span>
        _routingTable.getRoutingTable(new RoutingTableLookupRequest(brokerRequest));
<span class="fc" id="L568">    phaseTimes.addToRoutingTime(System.nanoTime() - routingStartTime);</span>
<span class="pc bpc" id="L569" title="1 of 4 branches missed.">    if (routingTable == null || routingTable.isEmpty()) {</span>
<span class="fc" id="L570">      String tableNameWithType = brokerRequest.getQuerySource().getTableName();</span>
<span class="fc" id="L571">      LOGGER.info(&quot;No server found or all segments are pruned for table: {}&quot;, tableNameWithType);</span>
<span class="fc" id="L572">      _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.NO_SERVER_FOUND_EXCEPTIONS, 1L);</span>
<span class="fc" id="L573">      return null;</span>
    }

    // Step 2: select servers for each segment set and scatter request to the servers.
<span class="fc" id="L577">    long scatterStartTime = System.nanoTime();</span>
<span class="fc" id="L578">    ScatterGatherRequestImpl scatterRequest =</span>
        new ScatterGatherRequestImpl(brokerRequest, routingTable, requestId, _brokerTimeOutMs, _brokerId);
<span class="fc" id="L580">    CompositeFuture&lt;byte[]&gt; compositeFuture =</span>
        _scatterGatherer.scatterGather(scatterRequest, scatterGatherStats, isOfflineTable, _brokerMetrics);
<span class="fc" id="L582">    phaseTimes.addToScatterTime(System.nanoTime() - scatterStartTime);</span>
<span class="fc" id="L583">    return compositeFuture;</span>
  }

  /**
   * Gather responses from servers, append processing exceptions to the processing exception list passed in.
   *
   * @param compositeFuture composite future returned from scatter phase.
   * @param scatterGatherStats scatter-gather statistics.
   * @param isOfflineTable whether the scatter-gather target is an OFFLINE table.
   * @param tableNameWithType table name with type suffix.
   * @param processingExceptions list of processing exceptions.
   * @return server response map.
   */
  @Nullable
  private Map&lt;ServerInstance, byte[]&gt; gatherServerResponses(@Nonnull CompositeFuture&lt;byte[]&gt; compositeFuture,
      @Nonnull ScatterGatherStats scatterGatherStats, boolean isOfflineTable, @Nonnull String tableNameWithType,
      @Nonnull List&lt;ProcessingException&gt; processingExceptions) {
    try {
<span class="fc" id="L601">      Map&lt;ServerInstance, byte[]&gt; serverResponseMap = compositeFuture.get();</span>
<span class="fc" id="L602">      Iterator&lt;Entry&lt;ServerInstance, byte[]&gt;&gt; iterator = serverResponseMap.entrySet().iterator();</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">      while (iterator.hasNext()) {</span>
<span class="fc" id="L604">        Entry&lt;ServerInstance, byte[]&gt; entry = iterator.next();</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if (entry.getValue().length == 0) {</span>
<span class="nc" id="L606">          LOGGER.warn(&quot;Got empty response from server: {]&quot;, entry.getKey().getShortHostName());</span>
<span class="nc" id="L607">          iterator.remove();</span>
        }
<span class="fc" id="L609">      }</span>
<span class="fc" id="L610">      Map&lt;ServerInstance, Long&gt; responseTimes = compositeFuture.getResponseTimes();</span>
<span class="fc" id="L611">      scatterGatherStats.setResponseTimeMillis(responseTimes, isOfflineTable);</span>
<span class="fc" id="L612">      return serverResponseMap;</span>
<span class="nc" id="L613">    } catch (Exception e) {</span>
<span class="nc" id="L614">      LOGGER.error(&quot;Caught exception while fetching responses for table: {}&quot;, tableNameWithType, e);</span>
<span class="nc" id="L615">      _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.RESPONSE_FETCH_EXCEPTIONS, 1L);</span>
<span class="nc" id="L616">      processingExceptions.add(QueryException.getException(QueryException.BROKER_GATHER_ERROR, e));</span>
<span class="nc" id="L617">      return null;</span>
    }
  }

  /**
   * Deserialize the server responses, put the de-serialized data table into the data table map passed in, append
   * processing exceptions to the processing exception list passed in.
   * &lt;p&gt;For hybrid use case, multiple responses might be from the same instance. Use response sequence to distinguish
   * them.
   *
   * @param responseMap map from server to response.
   * @param isOfflineTable whether the responses are from an OFFLINE table.
   * @param dataTableMap map from server to data table.
   * @param tableNameWithType table name with type suffix.
   * @param processingExceptions list of processing exceptions.
   */
  private void deserializeServerResponses(@Nonnull Map&lt;ServerInstance, byte[]&gt; responseMap, boolean isOfflineTable,
      @Nonnull Map&lt;ServerInstance, DataTable&gt; dataTableMap, @Nonnull String tableNameWithType,
      @Nonnull List&lt;ProcessingException&gt; processingExceptions) {
<span class="fc bfc" id="L636" title="All 2 branches covered.">    for (Entry&lt;ServerInstance, byte[]&gt; entry : responseMap.entrySet()) {</span>
<span class="fc" id="L637">      ServerInstance serverInstance = entry.getKey();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">      if (!isOfflineTable) {</span>
<span class="fc" id="L639">        serverInstance = serverInstance.withSeq(1);</span>
      }
      try {
<span class="fc" id="L642">        dataTableMap.put(serverInstance, DataTableFactory.getDataTable(entry.getValue()));</span>
<span class="nc" id="L643">      } catch (Exception e) {</span>
<span class="nc" id="L644">        LOGGER.error(&quot;Caught exceptions while deserializing response for table: {} from server: {}&quot;, tableNameWithType,</span>
            serverInstance, e);
<span class="nc" id="L646">        _brokerMetrics.addMeteredTableValue(tableNameWithType, BrokerMeter.DATA_TABLE_DESERIALIZATION_EXCEPTIONS, 1L);</span>
<span class="nc" id="L647">        processingExceptions.add(QueryException.getException(QueryException.DATA_TABLE_DESERIALIZATION_ERROR, e));</span>
<span class="fc" id="L648">      }</span>
<span class="fc" id="L649">    }</span>
<span class="fc" id="L650">  }</span>

  /**
   * Container for time statistics in all phases.
   */
<span class="fc" id="L655">  private static class PhaseTimes {</span>
<span class="fc" id="L656">    private long _routingTime = 0L;</span>
<span class="fc" id="L657">    private long _scatterTime = 0L;</span>
<span class="fc" id="L658">    private long _gatherTime = 0L;</span>
<span class="fc" id="L659">    private long _deserializationTime = 0L;</span>
<span class="fc" id="L660">    private long _reduceTime = 0L;</span>

    public void addToRoutingTime(long routingTime) {
<span class="fc" id="L663">      _routingTime += routingTime;</span>
<span class="fc" id="L664">    }</span>

    public void addToScatterTime(long scatterTime) {
<span class="fc" id="L667">      _scatterTime += scatterTime;</span>
<span class="fc" id="L668">    }</span>

    public void addToGatherTime(long gatherTime) {
<span class="fc" id="L671">      _gatherTime += gatherTime;</span>
<span class="fc" id="L672">    }</span>

    public void addToDeserializationTime(long deserializationTime) {
<span class="fc" id="L675">      _deserializationTime += deserializationTime;</span>
<span class="fc" id="L676">    }</span>

    public void addToReduceTime(long reduceTime) {
<span class="fc" id="L679">      _reduceTime += reduceTime;</span>
<span class="fc" id="L680">    }</span>

    public void addPhaseTimesToBrokerMetrics(BrokerMetrics brokerMetrics, String tableName) {
<span class="fc" id="L683">      brokerMetrics.addPhaseTiming(tableName, BrokerQueryPhase.QUERY_ROUTING, _routingTime);</span>
<span class="fc" id="L684">      brokerMetrics.addPhaseTiming(tableName, BrokerQueryPhase.SCATTER_GATHER, _scatterTime + _gatherTime);</span>
<span class="fc" id="L685">      brokerMetrics.addPhaseTiming(tableName, BrokerQueryPhase.DESERIALIZATION, _deserializationTime);</span>
<span class="fc" id="L686">      brokerMetrics.addPhaseTiming(tableName, BrokerQueryPhase.REDUCE, _reduceTime);</span>
<span class="fc" id="L687">    }</span>
  }

  private static class ScatterGatherRequestImpl implements ScatterGatherRequest {
    private final BrokerRequest _brokerRequest;
    private final Map&lt;String, List&lt;String&gt;&gt; _routingTable;
    private final long _requestId;
    private final long _requestTimeoutMs;
    private final String _brokerId;

    public ScatterGatherRequestImpl(BrokerRequest request, Map&lt;String, List&lt;String&gt;&gt; routingTable, long requestId,
<span class="fc" id="L698">        long requestTimeoutMs, String brokerId) {</span>
<span class="fc" id="L699">      _brokerRequest = request;</span>
<span class="fc" id="L700">      _routingTable = routingTable;</span>
<span class="fc" id="L701">      _requestId = requestId;</span>
<span class="fc" id="L702">      _requestTimeoutMs = requestTimeoutMs;</span>
<span class="fc" id="L703">      _brokerId = brokerId;</span>
<span class="fc" id="L704">    }</span>

    @Override
    public Map&lt;String, List&lt;String&gt;&gt; getRoutingTable() {
<span class="fc" id="L708">      return _routingTable;</span>
    }

    @Override
    public byte[] getRequestForService(List&lt;String&gt; segments) {
<span class="fc" id="L713">      InstanceRequest r = new InstanceRequest();</span>
<span class="fc" id="L714">      r.setRequestId(_requestId);</span>
<span class="fc" id="L715">      r.setEnableTrace(_brokerRequest.isEnableTrace());</span>
<span class="fc" id="L716">      r.setQuery(_brokerRequest);</span>
<span class="fc" id="L717">      r.setSearchSegments(segments);</span>
<span class="fc" id="L718">      r.setBrokerId(_brokerId);</span>
      // _serde is not threadsafe.
<span class="fc" id="L720">      return new SerDe(new TCompactProtocol.Factory()).serialize(r);</span>
    }

    @Override
    public long getRequestId() {
<span class="fc" id="L725">      return _requestId;</span>
    }

    @Override
    public long getRequestTimeoutMs() {
<span class="fc" id="L730">      return _requestTimeoutMs;</span>
    }

    @Override
    public BrokerRequest getBrokerRequest() {
<span class="fc" id="L735">      return _brokerRequest;</span>
    }
  }

  public String getRoutingTableSnapshot(String tableName) throws Exception {
<span class="fc" id="L740">    return _routingTable.dumpSnapshot(tableName);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>