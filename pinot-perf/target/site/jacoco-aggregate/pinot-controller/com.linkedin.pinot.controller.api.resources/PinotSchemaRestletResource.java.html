<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PinotSchemaRestletResource.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-controller</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.controller.api.resources</a> &gt; <span class="el_source">PinotSchemaRestletResource.java</span></div><h1>PinotSchemaRestletResource.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.linkedin.pinot.controller.api.resources;

import com.linkedin.pinot.common.config.TableConfig;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.metrics.ControllerMeter;
import com.linkedin.pinot.common.metrics.ControllerMetrics;
import com.linkedin.pinot.controller.api.events.MetadataEventNotifierFactory;
import com.linkedin.pinot.controller.api.events.SchemaEventType;
import com.linkedin.pinot.controller.helix.core.PinotHelixResourceManager;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import org.codehaus.jackson.JsonParseException;
import org.codehaus.jackson.map.JsonMappingException;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;
import org.glassfish.jersey.media.multipart.FormDataMultiPart;
import org.json.JSONArray;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


@Api(tags = Constants.SCHEMA_TAG)
@Path(&quot;/&quot;)
<span class="fc" id="L57">public class PinotSchemaRestletResource {</span>
<span class="fc" id="L58">  public static final Logger LOGGER = LoggerFactory.getLogger(PinotSchemaRestletResource.class);</span>

  @Inject
  PinotHelixResourceManager _pinotHelixResourceManager;

  @Inject
  ControllerMetrics _controllerMetrics;

  @Inject
  MetadataEventNotifierFactory _metadataEventNotifierFactory;

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/schemas&quot;)
  @ApiOperation(value = &quot;List all schema names&quot;, notes = &quot;Lists all schema names&quot;)
  public String listSchemaNames() {
<span class="nc" id="L74">    List&lt;String&gt; schemaNames = _pinotHelixResourceManager.getSchemaNames();</span>
<span class="nc" id="L75">    JSONArray ret = new JSONArray();</span>

<span class="nc bnc" id="L77" title="All 2 branches missed.">    if (schemaNames != null) {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      for (String schema : schemaNames) {</span>
<span class="nc" id="L79">        ret.put(schema);</span>
<span class="nc" id="L80">      }</span>
    }
<span class="nc" id="L82">    return ret.toString();</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/schemas/{schemaName}&quot;)
  @ApiOperation(value = &quot;Get a schema&quot;, notes = &quot;Gets a schema by name&quot;)
  @ApiResponses(value = {@ApiResponse(code = 200, message = &quot;Success&quot;), @ApiResponse(code = 404, message = &quot;Schema not found&quot;), @ApiResponse(code = 500, message = &quot;Internal error&quot;)})
  public String getSchema(
      @ApiParam(value = &quot;Schema name&quot;, required = true) @PathParam(&quot;schemaName&quot;) String schemaName) {
<span class="fc" id="L92">    LOGGER.info(&quot;looking for schema {}&quot;, schemaName);</span>
<span class="fc" id="L93">    Schema schema = _pinotHelixResourceManager.getSchema(schemaName);</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    if (schema == null) {</span>
<span class="nc" id="L95">      throw new ControllerApplicationException(LOGGER, &quot;Schema not found&quot;, Response.Status.NOT_FOUND);</span>
    }
    // We need to return schema.getJSONSchema(). Returning schema ends up with many extra fields, &quot;jsonSchema&quot; being one of them,
    // Others like fieldSpecMap, etc., serialzing the entire Schema object.
<span class="fc" id="L99">    return schema.getJSONSchema();</span>
  }

  @DELETE
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/schemas/{schemaName}&quot;)
  @ApiOperation(value = &quot;Delete a schema&quot;, notes = &quot;Deletes a schema by name&quot;)
  @ApiResponses(value = {@ApiResponse(code = 200, message = &quot;Successfully deleted schema&quot;), @ApiResponse(code = 404, message = &quot;Schema not found&quot;), @ApiResponse(code = 409, message = &quot;Schema is in use&quot;), @ApiResponse(code = 500, message = &quot;Error deleting schema&quot;)})
  public SuccessResponse deleteSchema(
      @ApiParam(value = &quot;Schema name&quot;, required = true) @PathParam(&quot;schemaName&quot;) String schemaName) {
<span class="nc" id="L109">    deleteSchemaInternal(schemaName);</span>
<span class="nc" id="L110">    return new SuccessResponse(&quot;Schema &quot; + schemaName + &quot; deleted&quot;);</span>
  }

  @PUT
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/schemas/{schemaName}&quot;)
  @ApiOperation(value = &quot;Update a schema&quot;, notes = &quot;Updates a schema&quot;)
  @ApiResponses(value = {@ApiResponse(code = 200, message = &quot;Successfully updated schema&quot;),
      @ApiResponse(code = 404, message = &quot;Schema not found&quot;),
      @ApiResponse(code = 400, message = &quot;Missing or invalid request body&quot;),
      @ApiResponse(code = 500, message = &quot;Internal error&quot;)})
  public SuccessResponse updateSchema(
      @ApiParam(value = &quot;Name of the schema&quot;, required = true) @PathParam(&quot;schemaName&quot;) String schemaName,
      FormDataMultiPart multiPart) {
<span class="fc" id="L124">    return addOrUpdateSchema(schemaName, multiPart);</span>
  }

  // TODO: This should not update if the schema already exists
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/schemas&quot;)
  @ApiOperation(value = &quot;Add a new schema&quot;, notes = &quot;Adds a new schema&quot;)
  @ApiResponses(value = {@ApiResponse(code = 200, message = &quot;Successfully deleted schema&quot;), @ApiResponse(code = 404, message = &quot;Schema not found&quot;), @ApiResponse(code = 400, message = &quot;Missing or invalid request body&quot;), @ApiResponse(code = 500, message = &quot;Internal error&quot;)})
  public SuccessResponse addSchema(FormDataMultiPart multiPart) {
<span class="fc" id="L134">    return addOrUpdateSchema(null, multiPart);</span>
  }

  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/schemas/validate&quot;)
  @ApiOperation(value = &quot;Validate schema&quot;, notes = &quot;This API returns the schema that matches the one you get &quot;
      + &quot;from 'GET /schema/{schemaName}'. This allows us to validate schema before apply.&quot;)
  @ApiResponses(value = {@ApiResponse(code = 200, message = &quot;Successfully validated schema&quot;),
      @ApiResponse(code = 400, message = &quot;Missing or invalid request body&quot;),
      @ApiResponse(code = 500, message = &quot;Internal error&quot;)})
  public String validateSchema (FormDataMultiPart multiPart) throws Exception {
<span class="nc" id="L146">    Schema schema = getSchemaFromMultiPart(multiPart);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (!schema.validate(LOGGER)) {</span>
<span class="nc" id="L148">      throw new ControllerApplicationException(LOGGER, &quot;Invalid schema. Check controller logs&quot;, Response.Status.BAD_REQUEST);</span>
    }
<span class="nc" id="L150">    return schema.getJSONSchema();</span>
  }

  /**
   * Internal method to add or update schema
   * @param schemaName null value indicates new schema (POST request) where schemaName is
   *                   not part of URI
   * @return
   */
  private SuccessResponse addOrUpdateSchema(@Nullable String schemaName, FormDataMultiPart multiPart) {
<span class="fc bfc" id="L160" title="All 2 branches covered.">    final String schemaNameForLogging = (schemaName == null) ? &quot;new schema&quot; : schemaName + &quot; schema&quot;;</span>
<span class="fc" id="L161">    Schema schema = getSchemaFromMultiPart(multiPart);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">    if (!schema.validate(LOGGER)) {</span>
<span class="nc" id="L163">      LOGGER.info(&quot;Invalid schema during create/update of {}&quot;, schemaNameForLogging);</span>
<span class="nc" id="L164">      throw new ControllerApplicationException(LOGGER, &quot;Invalid schema&quot;, Response.Status.BAD_REQUEST);</span>
    }

<span class="fc bfc" id="L167" title="All 4 branches covered.">    if (schemaName != null &amp;&amp; !schema.getSchemaName().equals(schemaName)) {</span>
<span class="fc" id="L168">      _controllerMetrics.addMeteredGlobalValue(ControllerMeter.CONTROLLER_SCHEMA_UPLOAD_ERROR, 1L);</span>
<span class="fc" id="L169">      final String message =</span>
          &quot;Schema name mismatch for uploaded schema, tried to add schema with name &quot; + schema.getSchemaName() + &quot; as &quot;
              + schemaName;
<span class="fc" id="L172">      throw new ControllerApplicationException(LOGGER, message, Response.Status.BAD_REQUEST);</span>
    }

    try {
<span class="fc" id="L176">      SchemaEventType eventType = SchemaEventType.UPDATE;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (schemaName == null) {</span>
        // New schema posted
<span class="fc" id="L179">        eventType = SchemaEventType.CREATE;</span>
      }
<span class="fc" id="L181">      _pinotHelixResourceManager.addOrUpdateSchema(schema);</span>

      // Best effort notification. If controller fails at this point, no notification is given.
<span class="fc" id="L184">      LOGGER.info(&quot;Metadata change notification for schema {}, type {}&quot;, schema, eventType);</span>
<span class="fc" id="L185">      _metadataEventNotifierFactory.create().notifyOnSchemaEvents(schema, eventType);</span>

<span class="fc" id="L187">      return new SuccessResponse(schema.getSchemaName() + &quot; successfully added&quot;);</span>
<span class="nc" id="L188">    } catch (Exception e) {</span>
<span class="nc" id="L189">      _controllerMetrics.addMeteredGlobalValue(ControllerMeter.CONTROLLER_SCHEMA_UPLOAD_ERROR, 1L);</span>
<span class="nc" id="L190">      throw new ControllerApplicationException(LOGGER,</span>
          String.format(&quot;Failed to update schema %s&quot;, schemaNameForLogging), Response.Status.INTERNAL_SERVER_ERROR);
    }
  }

  private Schema getSchemaFromMultiPart(FormDataMultiPart multiPart) {
<span class="fc" id="L196">    Map&lt;String, List&lt;FormDataBodyPart&gt;&gt; map = multiPart.getFields();</span>
<span class="fc" id="L197">    PinotSegmentUploadRestletResource.validateMultiPart(map, null);</span>
<span class="fc" id="L198">    final String name = map.keySet().iterator().next();</span>
<span class="fc" id="L199">    final FormDataBodyPart bodyPart = map.get(name).get(0);</span>
<span class="fc" id="L200">    InputStream is = null;</span>
    try {
<span class="fc" id="L202">      is = bodyPart.getValueAs(InputStream.class);</span>
<span class="fc" id="L203">      return Schema.fromInputSteam(is);</span>
<span class="fc" id="L204">    } catch (JsonParseException | JsonMappingException e) {</span>
<span class="fc" id="L205">      throw new ControllerApplicationException(LOGGER,</span>
          String.format(&quot;Invalid json in schema request body, schema: %s&quot;, name),
          Response.Status.BAD_REQUEST);
<span class="nc" id="L208">    } catch (IOException e) {</span>
<span class="nc" id="L209">      throw new ControllerApplicationException(LOGGER,</span>
          String.format(&quot;Error reading request body for schema, name %s&quot;, name), Response.Status.INTERNAL_SERVER_ERROR,
          e);
    } finally {
<span class="fc" id="L213">      try {</span>
<span class="fc" id="L214">        is.close();</span>
<span class="nc" id="L215">      } catch (IOException e) {</span>
<span class="nc" id="L216">        LOGGER.warn(&quot;Failed to close request input stream&quot;);</span>
<span class="fc" id="L217">      }</span>
    }
  }

  private void deleteSchemaInternal(String schemaName) {
<span class="nc" id="L222">    Schema schema = _pinotHelixResourceManager.getSchema(schemaName);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">    if (schema == null) {</span>
<span class="nc" id="L224">      throw new ControllerApplicationException(LOGGER, String.format(&quot;Schema %s not found&quot;, schemaName),</span>
          Response.Status.NOT_FOUND);
    }

    // If the schema is associated with a table, we should not delete it.
<span class="nc" id="L229">    List&lt;String&gt; tableNames = _pinotHelixResourceManager.getAllRealtimeTables();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    for (String tableName : tableNames) {</span>
<span class="nc" id="L231">      TableConfig config = _pinotHelixResourceManager.getRealtimeTableConfig(tableName);</span>
<span class="nc" id="L232">      String tableSchema = config.getValidationConfig().getSchemaName();</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">      if (schemaName.equals(tableSchema)) {</span>
<span class="nc" id="L235">        throw new ControllerApplicationException(LOGGER,</span>
            String.format(&quot;Cannot delete schema %s, as it is associated with table %s&quot;, schemaName, tableName),
            Response.Status.CONFLICT);
      }
<span class="nc" id="L239">    }</span>

<span class="nc" id="L241">    LOGGER.info(&quot;Trying to delete schema {}&quot;, schemaName);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (_pinotHelixResourceManager.deleteSchema(schema)) {</span>
<span class="nc" id="L243">      LOGGER.info(&quot;Success: Deleted schema {}&quot;, schemaName);</span>
    } else {
<span class="nc" id="L245">      throw new ControllerApplicationException(LOGGER, String.format(&quot;Failed to delete schema %s&quot;, schemaName),</span>
          Response.Status.INTERNAL_SERVER_ERROR);
    }
<span class="nc" id="L248">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>