<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HelixInstanceDataManagerConfig.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-perf</a> &gt; <a href="../index.html" class="el_bundle">pinot-server</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.server.starter.helix</a> &gt; <span class="el_source">HelixInstanceDataManagerConfig.java</span></div><h1>HelixInstanceDataManagerConfig.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.server.starter.helix;

import com.linkedin.pinot.common.segment.ReadMode;
import com.linkedin.pinot.core.data.manager.config.InstanceDataManagerConfig;
import java.util.Iterator;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The config used for HelixInstanceDataManager.
 *
 *
 */
public class HelixInstanceDataManagerConfig implements InstanceDataManagerConfig {
<span class="fc" id="L33">  private static final Logger LOGGER = LoggerFactory.getLogger(HelixInstanceDataManagerConfig.class);</span>

  // Average number of values in multi-valued columns in any table in this instance.
  // This value is used to allocate initial memory for multi-valued columns in realtime segments in consuming state.
  private static final String AVERAGE_MV_COUNT = &quot;realtime.averageMultiValueEntriesPerRow&quot;;
  // Key of instance id
  public static final String INSTANCE_ID = &quot;id&quot;;
  // Key of instance data directory
  public static final String INSTANCE_DATA_DIR = &quot;dataDir&quot;;
  // Key of consumer directory
  public static final String CONSUMER_DIR = &quot;consumerDir&quot;;
  // Key of instance segment tar directory
  public static final String INSTANCE_SEGMENT_TAR_DIR = &quot;segmentTarDir&quot;;
  // Key of segment directory
  public static final String INSTANCE_BOOTSTRAP_SEGMENT_DIR = &quot;bootstrap.segment.dir&quot;;
  // Key of table data directory
  public static final String kEY_OF_TABLE_DATA_DIRECTORY = &quot;directory&quot;;
  // Key of table data directory
  public static final String kEY_OF_TABLE_NAME = &quot;name&quot;;
  // Key of instance level segment read mode
  public static final String READ_MODE = &quot;readMode&quot;;
  // Key of the segment format this server can read
  public static final String SEGMENT_FORMAT_VERSION = &quot;segment.format.version&quot;;

  // Key of whether to enable default columns
  private static final String ENABLE_DEFAULT_COLUMNS = &quot;enable.default.columns&quot;;

  // Key of how many parallel realtime segments can be built.
  // A value of &lt;= 0 indicates unlimited.
  // Unlimited parallel builds can cause high GC pauses during segment builds, causing
  // response times to suffer.
  private static final String MAX_PARALLEL_SEGMENT_BUILDS = &quot;realtime.max.parallel.segment.builds&quot;;

  // Key of whether to enable split commit
  private static final String ENABLE_SPLIT_COMMIT = &quot;enable.split.commit&quot;;

  // Whether memory for realtime consuming segments should be allocated off-heap.
  private static final String REALTIME_OFFHEAP_ALLOCATION = &quot;realtime.alloc.offheap&quot;;
  // And whether the allocation should be direct (default is to allocate via mmap)
  // Direct memory allocation may mean setting heap size appropriately when starting JVM.
  // The metric ServerGauge.REALTIME_OFFHEAP_MEMORY_USED should indicate how much memory is needed.
  private static final String DIRECT_REALTIME_OFFHEAP_ALLOCATION = &quot;realtime.alloc.offheap.direct&quot;;

  // Number of simultaneous segments that can be refreshed on one server.
  // Segment refresh works by loading the old as well as new versions of segments in memory, assigning
  // new incoming queries to use the new version. The old version is dropped when all the queries that
  // use the old version have completed. A server-wide semaphore is acquired before refreshing a segment so
  // that we exceed the memory in some limited fashion. If there are multiple
  // refresh requests, then they are queued on the semaphore (FIFO).
  // In some multi-tenant use cases, it may be fine to over-allocate memory.
  // Setting this config variable to a value greater than 1 will cause as many refresh threads to run simultaneously.
  //
  // NOTE: While segment load can be faster, multiple threads will be taken up loading segments, so
  //       it is possible that the query latencies increase during that period.
  //
  private static final String MAX_PARALLEL_REFRESH_THREADS = &quot;max.parallel.refresh.threads&quot;;

<span class="fc" id="L90">  private final static String[] REQUIRED_KEYS = { INSTANCE_ID, INSTANCE_DATA_DIR, READ_MODE };</span>
<span class="fc" id="L91">  private Configuration _instanceDataManagerConfiguration = null;</span>

<span class="fc" id="L93">  public HelixInstanceDataManagerConfig(Configuration serverConfig) throws ConfigurationException {</span>
<span class="fc" id="L94">    _instanceDataManagerConfiguration = serverConfig;</span>
<span class="fc" id="L95">    Iterator keysIterator = serverConfig.getKeys();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">    while (keysIterator.hasNext()) {</span>
<span class="fc" id="L97">      String key = (String) keysIterator.next();</span>
<span class="fc" id="L98">      LOGGER.info(&quot;InstanceDataManagerConfig, key: {} , value: {}&quot;,  key,</span>
          serverConfig.getProperty(key));
<span class="fc" id="L100">    }</span>
<span class="fc" id="L101">    checkRequiredKeys();</span>
<span class="fc" id="L102">  }</span>

  private void checkRequiredKeys() throws ConfigurationException {
<span class="fc bfc" id="L105" title="All 2 branches covered.">    for (String keyString : REQUIRED_KEYS) {</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">      if (!_instanceDataManagerConfiguration.containsKey(keyString)) {</span>
<span class="nc" id="L107">        throw new ConfigurationException(&quot;Cannot find required key : &quot; + keyString);</span>
      }
    }
<span class="fc" id="L110">  }</span>

  @Override
  public Configuration getConfig() {
<span class="nc" id="L114">    return _instanceDataManagerConfiguration;</span>
  }

  @Override
  public String getInstanceId() {
<span class="fc" id="L119">    return _instanceDataManagerConfiguration.getString(INSTANCE_ID);</span>
  }

  @Override
  public String getInstanceDataDir() {
<span class="fc" id="L124">    return _instanceDataManagerConfiguration.getString(INSTANCE_DATA_DIR);</span>
  }

  @Override
  public String getConsumerDir() {
<span class="fc" id="L129">    return _instanceDataManagerConfiguration.getString(CONSUMER_DIR);</span>
  }

  @Override
  public String getInstanceSegmentTarDir() {
<span class="fc" id="L134">    return _instanceDataManagerConfiguration.getString(INSTANCE_SEGMENT_TAR_DIR);</span>
  }

  @Override
  public String getInstanceBootstrapSegmentDir() {
<span class="fc" id="L139">    return _instanceDataManagerConfiguration.getString(INSTANCE_BOOTSTRAP_SEGMENT_DIR);</span>
  }

  @Override
  public ReadMode getReadMode() {
<span class="fc" id="L144">    return ReadMode.valueOf(_instanceDataManagerConfiguration.getString(READ_MODE));</span>
  }

  @Override
  public String getSegmentFormatVersion() {
<span class="fc" id="L149">    return _instanceDataManagerConfiguration.getString(SEGMENT_FORMAT_VERSION);</span>
  }

  @Override
  public boolean isEnableDefaultColumns() {
<span class="fc" id="L154">    return _instanceDataManagerConfiguration.getBoolean(ENABLE_DEFAULT_COLUMNS, false);</span>
  }

  @Override
  public boolean isEnableSplitCommit() {
<span class="fc" id="L159">    return _instanceDataManagerConfiguration.getBoolean(ENABLE_SPLIT_COMMIT, false);</span>
  }

  @Override
  public boolean isRealtimeOffHeapAllocation() {
<span class="fc" id="L164">    return _instanceDataManagerConfiguration.getBoolean(REALTIME_OFFHEAP_ALLOCATION, false);</span>
  }

  @Override
  public boolean isDirectRealtimeOffheapAllocation() {
<span class="fc" id="L169">    return _instanceDataManagerConfiguration.getBoolean(DIRECT_REALTIME_OFFHEAP_ALLOCATION, false);</span>
  }

  @Override
  public String getAvgMultiValueCount() {
<span class="fc" id="L174">    return _instanceDataManagerConfiguration.getString(AVERAGE_MV_COUNT, null);</span>
  }

  public int getMaxParallelRefreshThreads() {
<span class="fc" id="L178">    return _instanceDataManagerConfiguration.getInt(MAX_PARALLEL_REFRESH_THREADS, 1);</span>
  }

  public int getMaxParallelSegmentBuilds() {
<span class="fc" id="L182">    return _instanceDataManagerConfiguration.getInt(MAX_PARALLEL_SEGMENT_BUILDS, 0);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L187">    String configString = &quot;&quot;;</span>
<span class="fc" id="L188">    configString += &quot;Instance Id: &quot; + getInstanceId();</span>
<span class="fc" id="L189">    configString += &quot;\n\tInstance Data Dir: &quot; + getInstanceDataDir();</span>
<span class="fc" id="L190">    configString += &quot;\n\tInstance Segment Tar Dir: &quot; + getInstanceSegmentTarDir();</span>
<span class="fc" id="L191">    configString += &quot;\n\tBootstrap Segment Dir: &quot; + getInstanceBootstrapSegmentDir();</span>
<span class="fc" id="L192">    configString += &quot;\n\tRead Mode: &quot; + getReadMode();</span>
<span class="fc" id="L193">    configString += &quot;\n\tSegment format version: &quot; + getSegmentFormatVersion();</span>
<span class="fc" id="L194">    return configString;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>