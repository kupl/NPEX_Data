<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StarTreeDataTable.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-minion</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.startree</a> &gt; <span class="el_source">StarTreeDataTable.java</span></div><h1>StarTreeDataTable.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.startree;

import com.linkedin.pinot.common.utils.Pairs.IntPair;
import com.linkedin.pinot.core.segment.creator.impl.V1Constants;
import it.unimi.dsi.fastutil.Arrays;
import it.unimi.dsi.fastutil.Swapper;
import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.IntComparator;
import java.io.Closeable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Iterator;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import xerial.larray.buffer.LBuffer;
import xerial.larray.buffer.LBufferAPI;
import xerial.larray.mmap.MMapBuffer;


/**
 * The class &lt;code&gt;StarTreeDataTable&lt;/code&gt; works on a LBufferAPI and provides the helper methods to build the
 * star-tree.
 * &lt;p&gt;Implemented to be able to handle the memory range greater than 2GB.
 */
public class StarTreeDataTable implements Closeable {
  private final LBufferAPI _dataBuffer;
  private final int _dimensionSize;
  private final int _metricSize;
  private final long _docSize;
  private final int _startDocId;
  private final int _endDocId;

  /**
   * Constructor of the StarTreeDataTable.
   *
   * @param dataBuffer Data buffer
   * @param dimensionSize Size of all dimensions in bytes
   * @param metricSize Size of all metrics in bytes
   * @param startDocId Start document id of the data buffer
   * @param startDocId End document id of the data buffer
   */
<span class="fc" id="L58">  public StarTreeDataTable(LBufferAPI dataBuffer, int dimensionSize, int metricSize, int startDocId, int endDocId) {</span>
<span class="fc" id="L59">    _dataBuffer = dataBuffer;</span>
<span class="fc" id="L60">    _dimensionSize = dimensionSize;</span>
<span class="fc" id="L61">    _metricSize = metricSize;</span>
<span class="fc" id="L62">    _docSize = dimensionSize + metricSize;</span>
<span class="fc" id="L63">    _startDocId = startDocId;</span>
    // NOTE: number of documents cannot be derived from dataBuffer.size() because for MMapBuffer, dataBuffer.size()
    // could be larger than the given length because of page alignment
<span class="fc" id="L66">    _endDocId = endDocId;</span>
<span class="fc" id="L67">  }</span>

  /**
   * Sort the documents inside the data buffer based on the sort order.
   * &lt;p&gt;To reduce the number of swaps inside the data buffer, we first sort on an array which only read from the data
   * buffer, then re-arrange the actual document inside the data buffer based on the sorted array.
   * &lt;p&gt;This method may change the data, call {@link #flush()} before closing the data table.
   *
   * @param startDocId Start document id of the range to be sorted
   * @param endDocId End document id (exclusive) of the range to be sorted
   * @param sortOrder Sort order of dimensions
   */
  public void sort(int startDocId, int endDocId, final int[] sortOrder) {
    // Get sorted doc ids
<span class="fc" id="L81">    int numDocs = endDocId - startDocId;</span>
<span class="fc" id="L82">    int startDocIdOffset = startDocId - _startDocId;</span>
<span class="fc" id="L83">    final int[] sortedDocIds = new int[numDocs];</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">    for (int i = 0; i &lt; numDocs; i++) {</span>
<span class="fc" id="L85">      sortedDocIds[i] = i + startDocIdOffset;</span>
    }

<span class="fc" id="L88">    final LBuffer dimensionBuffer1 = new LBuffer(_dimensionSize);</span>
<span class="fc" id="L89">    final LBuffer dimensionBuffer2 = new LBuffer(_dimensionSize);</span>

<span class="fc" id="L91">    IntComparator comparator = new IntComparator() {</span>
      @Override
      public int compare(int i1, int i2) {
<span class="fc" id="L94">        long offset1 = sortedDocIds[i1] * _docSize;</span>
<span class="fc" id="L95">        long offset2 = sortedDocIds[i2] * _docSize;</span>

<span class="fc" id="L97">        _dataBuffer.copyTo(offset1, dimensionBuffer1, 0, _dimensionSize);</span>
<span class="fc" id="L98">        _dataBuffer.copyTo(offset2, dimensionBuffer2, 0, _dimensionSize);</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (int index : sortOrder) {</span>
<span class="fc" id="L101">          int v1 = dimensionBuffer1.getInt(index * V1Constants.Numbers.INTEGER_SIZE);</span>
<span class="fc" id="L102">          int v2 = dimensionBuffer2.getInt(index * V1Constants.Numbers.INTEGER_SIZE);</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">          if (v1 != v2) {</span>
<span class="fc" id="L104">            return v1 - v2;</span>
          }
        }
<span class="fc" id="L107">        return 0;</span>
      }

      @Override
      public int compare(Integer o1, Integer o2) {
<span class="nc" id="L112">        throw new UnsupportedOperationException();</span>
      }
    };

<span class="fc" id="L116">    Swapper swapper = new Swapper() {</span>
      @Override
      public void swap(int i, int j) {
<span class="fc" id="L119">        int temp = sortedDocIds[i];</span>
<span class="fc" id="L120">        sortedDocIds[i] = sortedDocIds[j];</span>
<span class="fc" id="L121">        sortedDocIds[j] = temp;</span>
<span class="fc" id="L122">      }</span>
    };

    try {
<span class="fc" id="L126">      Arrays.quickSort(0, numDocs, comparator, swapper);</span>
    } finally {
<span class="pc" id="L128">      dimensionBuffer1.release();</span>
<span class="pc" id="L129">      dimensionBuffer2.release();</span>
<span class="fc" id="L130">    }</span>

    // Re-arrange documents based on the sorted document ids
    // Each write places a document in it's proper location, so time complexity is O(n)
<span class="fc" id="L134">    LBuffer docBuffer = new LBuffer(_docSize);</span>
    try {
<span class="fc bfc" id="L136" title="All 2 branches covered.">      for (int i = 0; i &lt; numDocs; i++) {</span>
<span class="fc" id="L137">        int actualDocId = i + startDocIdOffset;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (actualDocId != sortedDocIds[i]) {</span>
          // Copy the document at actualDocId into the first document buffer
<span class="fc" id="L140">          _dataBuffer.copyTo(actualDocId * _docSize, docBuffer, 0, _docSize);</span>

          // The while loop will create a rotating cycle
<span class="fc" id="L143">          int currentIndex = i;</span>
          int properDocId;
<span class="fc bfc" id="L145" title="All 2 branches covered.">          while (actualDocId != (properDocId = sortedDocIds[currentIndex])) {</span>
            // Put the document at properDocId into the currentDocId
<span class="fc" id="L147">            int currentDocId = currentIndex + startDocIdOffset;</span>
<span class="fc" id="L148">            _dataBuffer.copyTo(properDocId * _docSize, _dataBuffer, currentDocId * _docSize, _docSize);</span>
<span class="fc" id="L149">            sortedDocIds[currentIndex] = currentDocId;</span>
<span class="fc" id="L150">            currentIndex = properDocId - startDocIdOffset;</span>
<span class="fc" id="L151">          }</span>

          // Put the document at actualDocId into the correct location (currentDocId)
<span class="fc" id="L154">          int currentDocId = currentIndex + startDocIdOffset;</span>
<span class="fc" id="L155">          docBuffer.copyTo(0L, _dataBuffer, currentDocId * _docSize, _docSize);</span>
<span class="fc" id="L156">          sortedDocIds[currentIndex] = currentDocId;</span>
        }
      }
    } finally {
<span class="pc" id="L160">      docBuffer.release();</span>
<span class="fc" id="L161">    }</span>
<span class="fc" id="L162">  }</span>

  /**
   * Group all documents based on a dimension's value.
   *
   * @param startDocId Start document id of the range to be grouped
   * @param endDocId End document id (exclusive) of the range to be grouped
   * @param dimensionId Index of the dimension to group on
   * @return Map from dimension value to a pair of start docId and end docId (exclusive)
   */
  public Int2ObjectMap&lt;IntPair&gt; groupOnDimension(int startDocId, int endDocId, int dimensionId) {
<span class="fc" id="L173">    int startDocIdOffset = startDocId - _startDocId;</span>
<span class="fc" id="L174">    int endDocIdOffset = endDocId - _startDocId;</span>
<span class="fc" id="L175">    Int2ObjectMap&lt;IntPair&gt; rangeMap = new Int2ObjectLinkedOpenHashMap&lt;&gt;();</span>
<span class="fc" id="L176">    int dimensionOffset = dimensionId * V1Constants.Numbers.INTEGER_SIZE;</span>
<span class="fc" id="L177">    int currentValue = _dataBuffer.getInt(startDocIdOffset * _docSize + dimensionOffset);</span>
<span class="fc" id="L178">    int groupStartDocId = startDocId;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">    for (int i = startDocIdOffset + 1; i &lt; endDocIdOffset; i++) {</span>
<span class="fc" id="L180">      int value = _dataBuffer.getInt(i * _docSize + dimensionOffset);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">      if (value != currentValue) {</span>
<span class="fc" id="L182">        int groupEndDocId = i + _startDocId;</span>
<span class="fc" id="L183">        rangeMap.put(currentValue, new IntPair(groupStartDocId, groupEndDocId));</span>
<span class="fc" id="L184">        currentValue = value;</span>
<span class="fc" id="L185">        groupStartDocId = groupEndDocId;</span>
      }
    }
<span class="fc" id="L188">    rangeMap.put(currentValue, new IntPair(groupStartDocId, endDocId));</span>
<span class="fc" id="L189">    return rangeMap;</span>
  }

  /**
   * Get the iterator to iterate over the documents inside the data buffer.
   *
   * @param startDocId Start document id of the range to iterate
   * @param endDocId End document id (exclusive) of the range to iterate
   * @return Iterator for pair of dimension bytes and metric bytes
   */
  public Iterator&lt;Pair&lt;byte[], byte[]&gt;&gt; iterator(int startDocId, int endDocId) {
<span class="fc" id="L200">    final int startDocIdOffset = startDocId - _startDocId;</span>
<span class="fc" id="L201">    final int endDocIdOffset = endDocId - _startDocId;</span>
<span class="fc" id="L202">    return new Iterator&lt;Pair&lt;byte[], byte[]&gt;&gt;() {</span>
<span class="fc" id="L203">      private int _currentIndex = startDocIdOffset;</span>

      @Override
      public boolean hasNext() {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        return _currentIndex &lt; endDocIdOffset;</span>
      }

      @Override
      public Pair&lt;byte[], byte[]&gt; next() {
<span class="fc" id="L212">        byte[] dimensionBytes = new byte[_dimensionSize];</span>
<span class="fc" id="L213">        byte[] metricBytes = new byte[_metricSize];</span>
<span class="fc" id="L214">        ByteBuffer byteBuffer = _dataBuffer.toDirectByteBuffer(_currentIndex++ * _docSize, (int) _docSize);</span>
<span class="fc" id="L215">        byteBuffer.get(dimensionBytes);</span>
<span class="fc" id="L216">        byteBuffer.get(metricBytes);</span>
<span class="fc" id="L217">        return new ImmutablePair&lt;&gt;(dimensionBytes, metricBytes);</span>
      }

      @Override
      public void remove() {
<span class="nc" id="L222">        throw new UnsupportedOperationException();</span>
      }
    };
  }

  /**
   * Set the value for each document at the specified index to the specified value.
   * &lt;p&gt;This method may change the data, call {@link #flush()} before closing the data table.
   *
   * @param dimensionId Index of the dimension to set the value
   * @param value Value to be set
   */
  public void setDimensionValue(int dimensionId, int value) {
<span class="fc" id="L235">    int numDocs = _endDocId - _startDocId;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">    for (int i = 0; i &lt; numDocs; i++) {</span>
<span class="fc" id="L237">      _dataBuffer.putInt(i * _docSize + dimensionId * V1Constants.Numbers.INTEGER_SIZE, value);</span>
    }
<span class="fc" id="L239">  }</span>

  /**
   * Flush any changes made to the data buffer to the disk if necessary (no-op if data buffer is LBuffer).
   */
  public void flush() {
<span class="fc bfc" id="L245" title="All 2 branches covered.">    if (_dataBuffer instanceof MMapBuffer) {</span>
<span class="fc" id="L246">      ((MMapBuffer) _dataBuffer).flush();</span>
    }
<span class="fc" id="L248">  }</span>

  @Override
  public void close() throws IOException {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (_dataBuffer instanceof MMapBuffer) {</span>
<span class="fc" id="L253">      ((MMapBuffer) _dataBuffer).close();</span>
    } else {
<span class="fc" id="L255">      _dataBuffer.release();</span>
    }
<span class="fc" id="L257">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>