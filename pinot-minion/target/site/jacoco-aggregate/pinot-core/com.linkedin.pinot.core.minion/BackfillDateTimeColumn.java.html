<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BackfillDateTimeColumn.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-minion</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.minion</a> &gt; <span class="el_source">BackfillDateTimeColumn.java</span></div><h1>BackfillDateTimeColumn.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.minion;

import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.data.DateTimeFieldSpec;
import com.linkedin.pinot.common.data.DateTimeFormatSpec;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.data.StarTreeIndexSpec;
import com.linkedin.pinot.common.data.TimeFieldSpec;
import com.linkedin.pinot.common.data.TimeGranularitySpec;
import com.linkedin.pinot.common.segment.StarTreeMetadata;
import com.linkedin.pinot.core.data.GenericRow;
import com.linkedin.pinot.core.data.readers.FileFormat;
import com.linkedin.pinot.core.data.readers.PinotSegmentRecordReader;
import com.linkedin.pinot.core.data.readers.RecordReader;
import com.linkedin.pinot.core.indexsegment.generator.SegmentGeneratorConfig;
import com.linkedin.pinot.core.segment.creator.RecordReaderSegmentCreationDataSource;
import com.linkedin.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import java.io.File;
import java.io.IOException;
import javax.annotation.Nonnull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The &lt;code&gt;BackfillDateTimeColumn&lt;/code&gt; class takes a segment, a timeSpec from the segment, and a
 * dateTimeSpec.
 * It creates a new segment with a new column corresponding to the dateTimeSpec configs, using the values from the timeSpec
 * &lt;ul&gt;
 *  &lt;li&gt;If a column corresponding to the dateTimeSpec already exists, it is overwritten&lt;/li&gt;
 *  &lt;li&gt;If not, a new date time column is created&lt;/li&gt;
 *  &lt;li&gt;If the segment contains star tree, it is recreated, putting date time column at the end&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 */
public class BackfillDateTimeColumn {
<span class="fc" id="L53">  private static final Logger LOGGER = LoggerFactory.getLogger(BackfillDateTimeColumn.class);</span>

  private final File _originalIndexDir;
  private final File _backfilledIndexDir;
  private final TimeFieldSpec _srcTimeFieldSpec;
  private final DateTimeFieldSpec _destDateTimeFieldSpec;

  public BackfillDateTimeColumn(@Nonnull File originalIndexDir, @Nonnull File backfilledIndexDir,
<span class="fc" id="L61">      @Nonnull TimeFieldSpec srcTimeSpec, @Nonnull DateTimeFieldSpec destDateTimeSpec) throws Exception {</span>
<span class="fc" id="L62">    _originalIndexDir = originalIndexDir;</span>
<span class="fc" id="L63">    _backfilledIndexDir = backfilledIndexDir;</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">    Preconditions.checkArgument(!_originalIndexDir.getAbsolutePath().equals(_backfilledIndexDir.getAbsolutePath()),</span>
        &quot;Original index dir and backfill index dir should not be the same&quot;);
<span class="fc" id="L66">    _srcTimeFieldSpec = srcTimeSpec;</span>
<span class="fc" id="L67">    _destDateTimeFieldSpec = destDateTimeSpec;</span>
<span class="fc" id="L68">  }</span>

  public boolean backfill() throws Exception {
<span class="nc" id="L71">    SegmentMetadataImpl originalSegmentMetadata = new SegmentMetadataImpl(_originalIndexDir);</span>
<span class="nc" id="L72">    String segmentName = originalSegmentMetadata.getName();</span>
<span class="nc" id="L73">    String tableName = originalSegmentMetadata.getTableName();</span>
<span class="nc" id="L74">    LOGGER.info(&quot;Start backfilling segment: {} in table: {}&quot;, segmentName, tableName);</span>

<span class="nc" id="L76">    PinotSegmentRecordReader segmentRecordReader = new PinotSegmentRecordReader(_originalIndexDir);</span>
<span class="nc" id="L77">    BackfillDateTimeRecordReader wrapperReader =</span>
        new BackfillDateTimeRecordReader(segmentRecordReader, _srcTimeFieldSpec, _destDateTimeFieldSpec);
<span class="nc" id="L79">    LOGGER.info(&quot;Segment dir: {} Output Dir: {}&quot;, _originalIndexDir.getAbsolutePath(),</span>
        _backfilledIndexDir.getAbsolutePath());

<span class="nc" id="L82">    LOGGER.info(&quot;Creating segment generator config for {}&quot;, segmentName);</span>
<span class="nc" id="L83">    SegmentGeneratorConfig config = new SegmentGeneratorConfig();</span>
<span class="nc" id="L84">    config.setFormat(FileFormat.PINOT);</span>
<span class="nc" id="L85">    config.setOutDir(_backfilledIndexDir.getAbsolutePath());</span>
<span class="nc" id="L86">    config.setOverwrite(true);</span>
<span class="nc" id="L87">    config.setTableName(tableName);</span>
<span class="nc" id="L88">    config.setSegmentName(segmentName);</span>
<span class="nc" id="L89">    config.setSchema(wrapperReader.getSchema());</span>

<span class="nc" id="L91">    StarTreeMetadata starTreeMetadata = originalSegmentMetadata.getStarTreeMetadata();</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (starTreeMetadata != null) {</span>
<span class="nc" id="L93">      config.enableStarTreeIndex(StarTreeIndexSpec.fromStarTreeMetadata(starTreeMetadata));</span>
    }

<span class="nc" id="L96">    LOGGER.info(&quot;Creating segment for {} with config {}&quot;, segmentName, config.toString());</span>
<span class="nc" id="L97">    SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();</span>
<span class="nc" id="L98">    driver.init(config, new RecordReaderSegmentCreationDataSource(wrapperReader));</span>
<span class="nc" id="L99">    driver.build();</span>

<span class="nc" id="L101">    return true;</span>
  }

  public BackfillDateTimeRecordReader getBackfillDateTimeRecordReader(RecordReader baseRecordReader) {
<span class="fc" id="L105">    return new BackfillDateTimeRecordReader(baseRecordReader, _srcTimeFieldSpec, _destDateTimeFieldSpec);</span>
  }

  /**
   * This record reader is a wrapper over another record reader.
   * It simply reads the records from the base record reader, and adds a new field according to the
   * dateTimeFieldSpec
   */
  public class BackfillDateTimeRecordReader implements RecordReader {
    private final RecordReader _baseRecordReader;
    private final TimeFieldSpec _timeFieldSpec;
    private final DateTimeFieldSpec _dateTimeFieldSpec;
    private final Schema _schema;

    public BackfillDateTimeRecordReader(RecordReader baseRecordReader, TimeFieldSpec timeFieldSpec,
<span class="fc" id="L120">        DateTimeFieldSpec dateTimeFieldSpec) {</span>
<span class="fc" id="L121">      _baseRecordReader = baseRecordReader;</span>
<span class="fc" id="L122">      _timeFieldSpec = timeFieldSpec;</span>
<span class="fc" id="L123">      _dateTimeFieldSpec = dateTimeFieldSpec;</span>
<span class="fc" id="L124">      _schema = baseRecordReader.getSchema();</span>

      // Add/replace the date time field spec to the schema
<span class="fc" id="L127">      _schema.removeField(_dateTimeFieldSpec.getName());</span>
<span class="fc" id="L128">      _schema.addField(_dateTimeFieldSpec);</span>
<span class="fc" id="L129">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc" id="L133">      return _baseRecordReader.hasNext();</span>
    }

    @Override
    public GenericRow next() throws IOException {
<span class="fc" id="L138">      return next(new GenericRow());</span>
    }

    /**
     * Reads the next row from the baseRecordReader, and adds a dateTimeFieldSPec column to it
     * {@inheritDoc}
     * @see com.linkedin.pinot.core.data.readers.RecordReader#next(com.linkedin.pinot.core.data.GenericRow)
     */
    @Override
    public GenericRow next(GenericRow reuse) throws IOException {
<span class="fc" id="L148">      reuse = _baseRecordReader.next(reuse);</span>
<span class="fc" id="L149">      Long timeColumnValue = (Long) reuse.getValue(_timeFieldSpec.getName());</span>
<span class="fc" id="L150">      Object dateTimeColumnValue = convertTimeFieldToDateTimeFieldSpec(timeColumnValue);</span>
<span class="fc" id="L151">      reuse.putField(_dateTimeFieldSpec.getName(), dateTimeColumnValue);</span>
<span class="fc" id="L152">      return reuse;</span>
    }

    /**
     * Converts the time column value from timeFieldSpec to dateTimeFieldSpec
     * @param timeColumnValue - time column value from timeFieldSpec
     * @return
     */
    private Object convertTimeFieldToDateTimeFieldSpec(Object timeColumnValue) {
<span class="fc" id="L161">      TimeGranularitySpec timeGranularitySpec = _timeFieldSpec.getOutgoingGranularitySpec();</span>

<span class="fc" id="L163">      DateTimeFormatSpec formatFromTimeSpec =</span>
          new DateTimeFormatSpec(timeGranularitySpec.getTimeUnitSize(), timeGranularitySpec.getTimeType().toString(),
              timeGranularitySpec.getTimeFormat());
<span class="fc bfc" id="L166" title="All 2 branches covered.">      if (formatFromTimeSpec.getFormat().equals(_dateTimeFieldSpec.getFormat())) {</span>
<span class="fc" id="L167">        return timeColumnValue;</span>
      }

<span class="fc" id="L170">      long timeColumnValueMS = timeGranularitySpec.toMillis(timeColumnValue);</span>
<span class="fc" id="L171">      DateTimeFormatSpec toFormat = new DateTimeFormatSpec(_dateTimeFieldSpec.getFormat());</span>
<span class="fc" id="L172">      return toFormat.fromMillisToFormat(timeColumnValueMS, Object.class);</span>
    }

    @Override
    public void rewind() throws IOException {
<span class="nc" id="L177">      _baseRecordReader.rewind();</span>
<span class="nc" id="L178">    }</span>

    @Override
    public Schema getSchema() {
<span class="fc" id="L182">      return _schema;</span>
    }

    @Override
    public void close() throws IOException {
<span class="fc" id="L187">      _baseRecordReader.close();</span>
<span class="fc" id="L188">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>