/* Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */
package org.apache.commons.math;
import java.util.ListResourceBundle;
/**
 * French localization message resources for the commons-math library.
 *
 * @version $Revision: 825925 $ $Date: 2009-10-16 17:11:47 +0200 (ven., 16 oct. 2009) $
 * @since 1.2
 */
public class MessagesResources_fr extends ListResourceBundle {
    /**
     * Non-translated/translated messages arrays.
     */
    private static final Object[][] CONTENTS = new Object[][]{ // org.apache.commons.math.util.MathUtils
    new Object[]{ "must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}", "n doit être supérieur ou égal à k " + "pour le coefficient du binôme (n,k), or n = {0}, k = {1}" }, new Object[]{ "must have n >= 0 for binomial coefficient (n,k), got n = {0}", "n doit être positif pour le coefficient du binôme (n,k), or n = {0}" }, new Object[]{ "must have n >= 0 for n!, got n = {0}", "n doit être positif pour le calcul de n!, or n = {0}" }, new Object[]{ "overflow: gcd({0}, {1}) is 2^31", "dépassement de capacité : le PGCD de {0} et {1} vaut 2^31" }, new Object[]{ "cannot raise an integral value to a negative power ({0}^{1})", "impossible d\'\'élever une valeur entière " + "à une puissance négative ({0}^{1})" }, new Object[]{ "invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4})," + " {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})", "méthode d\'\'arondi {0} invalide, méthodes valides : {1} ({2}), {3} ({4})," + " {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})" }, new Object[]{ "Cannot normalize to an infinite value", "impossible de normaliser vers une valeur infinie" }, new Object[]{ "Cannot normalize to NaN", "impossible de normaliser vers NaN" }, new Object[]{ "Array contains an infinite element, {0} at index {1}", "le tableau contient l\'\'élément infini {0} à l\'\'index {1}" }, // org.apache.commons.math.FunctionEvaluationException
    new Object[]{ "evaluation failed for argument = {0}", "erreur d\'\'évaluation pour l\'\'argument {0}" }, // org.apache.commons.math.DuplicateSampleAbscissaException
    new Object[]{ "Abscissa {0} is duplicated at both indices {1} and {2}", "Abscisse {0} dupliquée aux indices {1} et {2}" }, // org.apache.commons.math.ConvergenceException
    new Object[]{ "Convergence failed", "Échec de convergence" }, // org.apache.commons.math.ArgumentOutsideDomainException
    new Object[]{ "Argument {0} outside domain [{1} ; {2}]", "Argument {0} hors du domaine [{1} ; {2}]" }, // org.apache.commons.math.MaxIterationsExceededException
    new Object[]{ "Maximal number of iterations ({0}) exceeded", "Nombre maximal d\'\'itérations ({0}) dépassé" }, // org.apache.commons.math.MaxEvaluationsExceededException
    new Object[]{ "Maximal number of evaluations ({0}) exceeded", "Nombre maximal d\'\'évaluations ({0}) dépassé" }, // org.apache.commons.math.analysis.interpolation.SplineInterpolator
    // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm
    // org.apache.commons.math.DimensionMismatchException
    // org.apache.commons.math.optimization.LeastSquaresConverter
    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer
    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer
    // org.apache.commons.math.ode.ContinuousOutputModel
    // org.apache.commons.math.random.UncorrelatedRandomVectorGenerator
    // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression
    // org.apache.commons.math.stat.inference.ChiSquareTestImpl
    // org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatingFunction
    new Object[]{ "dimension mismatch {0} != {1}", "dimensions incompatibles {0} != {1}" }, // org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatingFunction
    new Object[]{ "no data", "aucune donnée" }, // org.apache.commons.math.analysis.interpolation.MicrosphereInterpolator
    new Object[]{ "brightness exponent should be positive or null, but got {0}", "l\'\'exposant de brillance devrait être positif ou null, or e = {0}" }, new Object[]{ "number of microsphere elements must be positive, but got {0}", "le nombre d\'\'éléments de la microsphère devrait être positif, or n = {0}" }, // org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException
    new Object[]{ "not positive definite matrix", "matrice non définie positive" }, // org.apache.commons.math.linear.decomposition.NotSymmetricMatrixException
    new Object[]{ "not symmetric matrix", "matrice non symmétrique" }, // org.apache.commons.math.fraction.FractionConversionException
    new Object[]{ "Unable to convert {0} to fraction after {1} iterations", "Impossible de convertir {0} en fraction après {1} itérations" }, new Object[]{ "Overflow trying to convert {0} to fraction ({1}/{2})", "Dépassement de capacité lors de la conversion de {0} en fraction ({1}/{2})" }, // org.apache.commons.math.fraction.BigFraction
    new Object[]{ "numerator is null", "le numérateur est null" }, new Object[]{ "denimonator is null", "le dénominateur est null" }, new Object[]{ "denominator must be different from 0", "le dénominateur doit être différent de 0" }, new Object[]{ "cannot convert NaN value", "les valeurs NaN ne peuvent être converties" }, new Object[]{ "cannot convert infinite value", "les valeurs infinies ne peuvent être converties" }, // org.apache.commons.math.fraction.AbstractFormat
    new Object[]{ "denominator format can not be null", "le format du dénominateur ne doit pas être nul" }, new Object[]{ "numerator format can not be null", "le format du numérateur ne doit pas être nul" }, // org.apache.commons.math.fraction.FractionFormat
    new Object[]{ "cannot convert given object to a fraction number: {0}", "impossible de convertir l''objet sous forme d''un nombre rationnel : {0}" }, // org.apache.commons.math.fraction.FractionFormat
    // org.apache.commons.math.fraction.BigFractionFormat
    new Object[]{ "unparseable fraction number: \"{0}\"", "échec d\'\'analyse du nombre rationnel \"{0}\"" }, new Object[]{ "cannot format given object as a fraction number", "impossible de formater l''objet sous forme d''un nombre rationnel" }, // org.apache.commons.math.fraction.ProperFractionFormat
    // org.apache.commons.math.fraction.ProperBigFractionFormat
    new Object[]{ "whole format can not be null", "le format complet ne doit pas être nul" }, // org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils
    new Object[]{ "function is null", "la fonction est nulle" }, new Object[]{ "bad value for maximum iterations number: {0}", "valeur invalide pour le nombre maximal d\'\'itérations : {0}" }, new Object[]{ "invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}", "paramètres d\'\'encadrement invalides : borne inférieure = {0}, valeur initiale = {1}, borne supérieure = {2}" }, new Object[]{ "number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}," + " final a value={5}, final b value={6}, f(a)={7}, f(b)={8}", "nombre d\'\'itérations = {0}, itérations maximum = {1}, valeur initiale = {2}," + (" borne inférieure = {3}, borne supérieure = {4}," + " valeur a finale = {5}, valeur b finale = {6}, f(a) = {7}, f(b) = {8}") }, // org.apache.commons.math.analysis.solvers.LaguerreSolver
    new Object[]{ "polynomial degree must be positive: degree={0}", "le polynôme doit être de degré positif : degré = {0}" }, // org.apache.commons.math.analysis.solvers.SecantSolver
    new Object[]{ "function values at endpoints do not have different signs, endpoints: [{0}, {1}], values: [{2}, {3}]", "les valeurs de la fonctions aux bornes sont de même signe, bornes : [{0}, {1}], valeurs : [{2}, {3}]" }, // org.apache.commons.math.analysis.interpolation.SplineInterpolator
    // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm
    new Object[]{ "{0} points are required, got only {1}", "{0} sont nécessaires, seuls {1} ont été fournis" }, // org.apache.commons.math.analysis.interpolation.SplineInterpolator
    new Object[]{ "points {0} and {1} are not strictly increasing ({2} >= {3})", "les points {0} et {1} ne sont pas strictements croissants ({2} >= {3})" }, // org.apache.commons.math.analysis.interpolation.LoessInterpolator
    new Object[]{ "bandwidth must be in the interval [0,1], but got {0}", "la largeur de bande doit être dans l\'\'intervalle [0, 1], alors qu\'elle vaut {0}" }, new Object[]{ "the number of robustness iterations must be non-negative, but got {0}", "le nombre d\'\'itérations robuste ne peut être négatif, alors qu\'\'il est de {0}" }, new Object[]{ "Loess expects the abscissa and ordinate arrays to be of the same size, " + "but got {0} abscisssae and {1} ordinatae", "la régression Loess nécessite autant d\'\'abscisses que d\'\'ordonnées, " + "mais {0} abscisses et {1} ordonnées ont été fournies" }, new Object[]{ "Loess expects at least 1 point", "la régression Loess nécessite au moins un point" }, new Object[]{ "the bandwidth must be large enough to accomodate at least 2 points. There are {0} " + " data points, and bandwidth must be at least {1}  but it is only {2}", "la largeur de bande doit être assez grande pour supporter au moins 2 points. Il y a {0}" + "données et la largeur de bande doit être au moins de {1}, or elle est seulement de {2}" }, new Object[]{ "all abscissae must be finite real numbers, but {0}-th is {1}", "toutes les abscisses doivent être des nombres réels finis, mais l\'\'abscisse {0} vaut {1}" }, new Object[]{ "all ordinatae must be finite real numbers, but {0}-th is {1}", "toutes les ordonnées doivent être des nombres réels finis, mais l\'\'ordonnée {0} vaut {1}" }, new Object[]{ "all weights must be finite real numbers, but {0}-th is {1}", "tous les poids doivent être des nombres réels finis, mais le poids {0} vaut {1}" }, new Object[]{ "the abscissae array must be sorted in a strictly increasing order, " + "but the {0}-th element is {1} whereas {2}-th is {3}", "les abscisses doivent être en ordre strictement croissant, " + "mais l\'\'élément {0} vaut {1} alors que l\'\'élément {2} vaut {3}" }, // org.apache.commons.math.util.ContinuedFraction
    new Object[]{ "Continued fraction convergents diverged to +/- infinity for value {0}", "Divergence de fraction continue à l\'\'infini pour la valeur {0}" }, new Object[]{ "Continued fraction convergents failed to converge for value {0}", "Échec de convergence de fraction continue pour la valeur {0}" }, // org.apache.commons.math.util.DefaultTransformer
    new Object[]{ "Conversion Exception in Transformation, Object is null", "Exception de conversion dans une transformation, l''objet est nul" }, new Object[]{ "Conversion Exception in Transformation: {0}", "Exception de conversion dans une transformation : {0}" }, // org.apache.commons.math.optimization.MultiStartOptimizer
    new Object[]{ "no optimum computed yet", "aucun optimum n\'\'a encore été calculé" }, // org.apache.commons.math.optimization.direct.DirectSearchOptimizer
    new Object[]{ "simplex must contain at least one point", "le simplex doit contenir au moins un point" }, new Object[]{ "equals vertices {0} and {1} in simplex configuration", "sommets {0} et {1} égaux dans la configuration du simplex" }, // org.apache.commons.math.estimation.AbstractEstimation
    new Object[]{ "maximal number of evaluations exceeded ({0})", "nombre maximal d\'\'évaluations dépassé ({0})" }, // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer
    new Object[]{ "unable to compute covariances: singular problem", "impossible de calculer les covariances : problème singulier" }, new Object[]{ "no degrees of freedom ({0} measurements, {1} parameters)", "aucun degré de liberté ({0} mesures, {1} paramètres)" }, // org.apache.commons.math.optimization.general.GaussNewtonOptimizer
    new Object[]{ "unable to solve: singular problem", "résolution impossible : problème singulier" }, // org.apache.commons.math.optimization.general.LevenbergMarquardtEstimator
    new Object[]{ "cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible", "trop petite tolérance relative sur le coût ({0}), aucune réduction de la somme des carrés n\'\'est possible" }, new Object[]{ "parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible", "trop petite tolérance relative sur les paramètres ({0}), aucune amélioration de la solution approximative n\'\'est possible" }, new Object[]{ "orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian", "trop petite tolérance sur l\'\'orthogonalité ({0}), la solution est orthogonale à la jacobienne" }, new Object[]{ "unable to perform Q.R decomposition on the {0}x{1} jacobian matrix", "impossible de calculer la factorisation Q.R de la matrice jacobienne {0}x{1}" }, // org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer
    new Object[]{ "unable to bracket optimum in line search", "impossible d\'\'encadrer l\'\'optimum lors de la recherche linéaire" }, // org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser
    new Object[]{ "unable to first guess the harmonic coefficients", "impossible de faire une première estimation des coefficients harmoniques" }, // org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser
    new Object[]{ "sample contains {0} observed points, at least {1} are required", "l\'\'échantillon ne contient que {0} points alors qu\'\'au moins {1} sont nécessaires" }, // org.apache.commons.math.optimization.linear.NoFeasibleSolutionException
    new Object[]{ "no feasible solution", "aucune solution réalisable" }, // org.apache.commons.math.optimization.linear.UnboundedSolutionException
    new Object[]{ "unbounded solution", "solution non bornée" }, // org.apache.commons.math.geometry.CardanEulerSingularityException
    new Object[]{ "Cardan angles singularity", "singularité d\'\'angles de Cardan" }, new Object[]{ "Euler angles singularity", "singularité d\'\'angles d\'\'Euler" }, // org.apache.commons.math.geometry.Rotation
    new Object[]{ "a {0}x{1} matrix cannot be a rotation matrix", "une matrice {0}x{1} ne peut pas être une matrice de rotation" }, new Object[]{ "the closest orthogonal matrix has a negative determinant {0}", "la matrice orthogonale la plus proche a un déterminant négatif {0}" }, new Object[]{ "unable to orthogonalize matrix in {0} iterations", "impossible de rendre la matrice orthogonale en {0} itérations" }, // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator
    new Object[]{ "minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}", "pas minimal ({0,number,0.00E00}) atteint, l\'\'intégration nécessite {1,number,0.00E00}" }, new Object[]{ "dimensions mismatch: state vector has dimension {0}," + " absolute tolerance vector has dimension {1}", "incompatibilité de dimensions entre le vecteur d\'\'état ({0})," + " et le vecteur de tolérance absolue ({1})" }, new Object[]{ "dimensions mismatch: state vector has dimension {0}," + " relative tolerance vector has dimension {1}", "incompatibilité de dimensions entre le vecteur d\'\'état ({0})," + " et le vecteur de tolérance relative ({1})" }, // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator,
    // org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator
    new Object[]{ "dimensions mismatch: ODE problem has dimension {0}," + " initial state vector has dimension {1}", "incompatibilité de dimensions entre le problème ODE ({0})," + " et le vecteur d\'\'état initial ({1})" }, new Object[]{ "dimensions mismatch: ODE problem has dimension {0}," + " final state vector has dimension {1}", "incompatibilité de dimensions entre le problème ODE ({0})," + " et le vecteur d\'\'état final ({1})" }, new Object[]{ "too small integration interval: length = {0}", "intervalle d\'\'intégration trop petit : {0}" }, // org.apache.commons.math.ode.MultistepIntegrator
    new Object[]{ "{0} method needs at least one previous point", "la méthode {0} nécessite au moins un point précédent" }, // org.apache.commons.math.ode.ContinuousOutputModel
    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer
    new Object[]{ "unexpected exception caught", "exception inattendue levée" }, new Object[]{ "propagation direction mismatch", "directions de propagation incohérentes" }, new Object[]{ "{0} wide hole between models time ranges", "trou de longueur {0} entre les domaines temporels des modèles" }, // org.apache.commons.math.optimization.direct.DirectSearchOptimizer
    new Object[]{ "none of the {0} start points lead to convergence", "aucun des {0} points de départ n\'\'aboutit à une convergence" }, // org.apache.commons.math.random.ValueServer
    new Object[]{ "unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})", "mode {0} inconnu, modes connus : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) et {11} ({12})" }, new Object[]{ "digest not initialized", "modèle empirique non initialisé" }, // org.apache.commons.math.random.EmpiricalDistributionImpl
    new Object[]{ "distribution not loaded", "aucune distribution n\'\'a été chargée" }, new Object[]{ "no bin selected", "aucun compartiment sélectionné" }, new Object[]{ "input data comes from unsupported datasource: {0}, supported sources: {1}, {2}", "les données d\'\'entrée proviennent " + "d\'\'une source non supportée : {0}, sources supportées : {1}, {2}" }, // org.apache.commons.math.random.EmpiricalDistributionImpl
    // org.apache.commons.math.random.ValueServer
    new Object[]{ "URL {0} contains no data", "l\'\'adresse {0} ne contient aucune donnée" }, // org.apache.commons.math.random.AbstractRandomGenerator
    // org.apache.commons.math.random.BitsStreamGenerator
    new Object[]{ "upper bound must be positive ({0})", "la borne supérieure doit être positive ({0})" }, // org.apache.commons.math.random.RandomDataImpl
    new Object[]{ "length must be positive ({0})", "la longueur doit être positive ({0})" }, new Object[]{ "upper bound ({0}) must be greater than lower bound ({1})", "la borne supérieure ({0}) doit être supérieure" + " à la borne inférieure ({1})" }, new Object[]{ "permutation k ({0}) exceeds n ({1})", "la permutation k ({0}) dépasse n ({1})" }, new Object[]{ "permutation k ({0}) must be positive", "la permutation k ({0}) doit être positive" }, new Object[]{ "sample size ({0}) exceeds collection size ({1})", "la taille de l\'\'échantillon ({0}) dépasse la taille de la collection ({1})" }, // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl
    new Object[]{ "cannot solve degree {0} equation", "impossible de résoudre une équation de degré {0}" }, new Object[]{ "eigen decomposition of assymetric matrices not supported yet", "la décomposition en valeurs/vecteurs propres de matrices " + "non symétriques n\'\'est pas encore disponible" }, // org.apache.commons.math.linear.decomposition.NonSquareMatrixException
    // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression
    new Object[]{ "a {0}x{1} matrix was provided instead of a square matrix", "une matrice {0}x{1} a été fournie à la place d\'\'une matrice carrée" }, // org.apache.commons.math.linear.decomposition.SingularMatrixException
    new Object[]{ "matrix is singular", "matrice singulière" }, // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl
    new Object[]{ "cutoff singular value is {0}, should be at most {1}", "la valeur singulière de coupure vaut {0}, elle ne devrait pas dépasser {1}" }, // org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl
    // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl
    // org.apache.commons.math.linear.decomposition.LUDecompositionImpl
    // org.apache.commons.math.linear.decomposition.QRDecompositionImpl
    // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl
    new Object[]{ "dimensions mismatch: got {0}x{1} but expected {2}x{3}", "dimensions erronnées : {0}x{1} à la place de {2}x{3}" }, // org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl
    // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl
    // org.apache.commons.math.linear.decomposition.LUDecompositionImpl
    // org.apache.commons.math.linear.decomposition.QRDecompositionImpl
    // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl
    // org.apache.commons.math.linear.ArrayRealVector
    // org.apache.commons.math.linear.SparseRealVector
    new Object[]{ "vector length mismatch: got {0} but expected {1}", "dimension de vecteur erronnée : {0} à la place de {1}" }, // org.apache.commons.math.linear.ArrayRealVector
    // org.apache.commons.math.linear.ArrayFieldVector
    // org.apache.commons.math.linear.SparseRealVector
    new Object[]{ "index {0} out of allowed range [{1}, {2}]", "index {0} hors de la plage autorisée [{1}, {2}]" }, new Object[]{ "vector must have at least one element", "un vecteur doit comporter au moins un élément" }, new Object[]{ "position {0} and size {1} don't fit to the size of the input array {2}", "la position {0} et la taille {1} sont incompatibles avec la taille du tableau d\'\'entrée {2}" }, // org.apache.commons.math.linear.AbstractRealMatrix
    // org.apache.commons.math.linear.AbstractFieldMatrix
    new Object[]{ "invalid row dimension: {0} (must be positive)", "nombre de lignes invalide : {0} (doit être positif)" }, new Object[]{ "invalid column dimension: {0} (must be positive)", "nombre de colonnes invalide : {0} (doit être positif)" }, new Object[]{ "vector length mismatch: got {0} but expected {1}", "taille de vecteur invalide : {0} au lieu de {1} attendue" }, new Object[]{ "dimensions mismatch: got {0}x{1} but expected {2}x{3}", "dimensions incohérentes : {0}x{1} à la place de {2}x{3}" }, new Object[]{ "matrix must have at least one row", "une matrice doit comporter au moins une ligne" }, new Object[]{ "matrix must have at least one column", "une matrice doit comporter au moins une colonne" }, // org.apache.commons.math.linear.AbstractRealMatrix
    // org.apache.commons.math.linear.AbstractFieldMatrix
    // org.apache.commons.math.stat.inference.ChiSquareTestImpl
    new Object[]{ "some rows have length {0} while others have length {1}", "certaines lignes ont une longueur de {0} alors que d''autres ont une longueur de {1}" }, // org.apache.commons.math.linear.MatrixUtils
    new Object[]{ "row index {0} out of allowed range [{1}, {2}]", "index de ligne {0} hors de la plage autorisée [{1}, {2}]" }, new Object[]{ "column index {0} out of allowed range [{1}, {2}]", "index de colonne {0} hors de la plage autorisée [{1}, {2}]" }, new Object[]{ "initial row {0} after final row {1}", "ligne initiale {0} après la ligne finale {1}" }, new Object[]{ "initial column {0} after final column {1}", "colonne initiale {0} après la colonne finale {1}" }, new Object[]{ "empty selected row index array", "tableau des indices de lignes sélectionnées vide" }, new Object[]{ "empty selected column index array", "tableau des indices de colonnes sélectionnées vide" }, new Object[]{ "{0}x{1} and {2}x{3} matrices are not addition compatible", "les dimensions {0}x{1} et {2}x{3} sont incompatibles pour l'addition matricielle" }, new Object[]{ "{0}x{1} and {2}x{3} matrices are not subtraction compatible", "les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la soustraction matricielle" }, new Object[]{ "{0}x{1} and {2}x{3} matrices are not multiplication compatible", "les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle" }, // org.apache.commons.math.linear.BlockRealMatrix
    new Object[]{ "wrong array shape (block length = {0}, expected {1})", "forme de tableau erronée (bloc de longueur {0} au lieu des {1} attendus)" }, // org.apache.commons.math.complex.Complex
    new Object[]{ "cannot compute nth root for null or negative n: {0}", "impossible de calculer la racine nième pour n négatif ou nul : {0}" }, // org.apache.commons.math.complex.ComplexFormat
    new Object[]{ "unparseable complex number: \"{0}\"", "échec d\'\'analyse du nombre complexe \"{0}\"" }, new Object[]{ "cannot format a {0} instance as a complex number", "impossible de formater une instance de {0} comme un nombre complexe" }, new Object[]{ "empty string for imaginary character", "chaîne vide pour le caractè imaginaire" }, new Object[]{ "null imaginary format", "format imaginaire nul" }, new Object[]{ "null real format", "format réel nul" }, // org.apache.commons.math.complex.ComplexUtils
    new Object[]{ "negative complex module {0}", "module négatif ({0}) pour un nombre complexe" }, // org.apache.commons.math.geometry.Vector3DFormat
    new Object[]{ "unparseable 3D vector: \"{0}\"", "échec d\'\'analyse du vecteur de dimension 3 \"{0}\"" }, new Object[]{ "cannot format a {0} instance as a 3D vector", "impossible de formater une instance de {0} comme un vecteur de dimension 3" }, // org.apache.commons.math.linear.RealVectorFormat
    new Object[]{ "unparseable real vector: \"{0}\"", "échec d\'\'analyse du vecteur réel \"{0}\"" }, new Object[]{ "cannot format a {0} instance as a real vector", "impossible de formater une instance de {0} comme un vecteur réel" }, // org.apache.commons.math.util.ResizableDoubleArray
    new Object[]{ "the index specified: {0} is larger than the current maximal index {1}", "l\'\'index spécifié ({0}) dépasse l\'\'index maximal courant ({1})" }, new Object[]{ "elements cannot be retrieved from a negative array index {0}", "impossible d\'\'extraire un élément à un index négatif ({0})" }, new Object[]{ "cannot set an element at a negative index {0}", "impossible de mettre un élément à un index négatif ({0})" }, new Object[]{ "cannot substitute an element from an empty array", "impossible de substituer un élément dans un tableau vide" }, new Object[]{ "contraction criteria ({0}) smaller than the expansion factor ({1}).  This would " + ("lead to a never ending loop of expansion and contraction as a newly expanded " + "internal storage array would immediately satisfy the criteria for contraction."), "critère de contraction ({0}) inférieur au facteur d\'\'extension. Ceci " + ("induit une boucle infinie d''extensions/contractions car tout tableau de stockage " + "fraîchement étendu respecte immédiatement le critère de contraction.") }, new Object[]{ "contraction criteria smaller than one ({0}).  This would lead to a never ending " + ("loop of expansion and contraction as an internal storage array length equal " + "to the number of elements would satisfy the contraction criteria."), "critère de contraction inférieur à un ({0}). Ceci induit une boucle " + ("infinie d\'\'extensions/contractions car tout tableau de stockage de longueur égale " + "au nombre d\'\'éléments respecte le critère de contraction.") }, new Object[]{ "expansion factor smaller than one ({0})", "facteur d\'\'extension inférieur à un ({0})" }, new Object[]{ "cannot discard {0} elements from a {1} elements array", "impossible d\'\'enlever {0} éléments d\'\'un tableau en contenant {1}" }, new Object[]{ "cannot discard a negative number of elements ({0})", "impossible d\'\'enlever un nombre d\'\'éléments{0} négatif" }, new Object[]{ "unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})", "mode d\'\'extension {0} no supporté, les modes supportés sont {1} ({2}) et {3} ({4})" }, new Object[]{ "initial capacity ({0}) is not positive", "la capacité initiale ({0}) n\'\'est pas positive" }, new Object[]{ "index ({0}) is not positive", "l''indice ({0}) n''est pas positif" }, // org.apache.commons.math.analysis.polynomials.PolynomialFunction
    // org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm
    new Object[]{ "empty polynomials coefficients array", "tableau de coefficients polynômiaux vide" }, // org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm
    new Object[]{ "array sizes should have difference 1 ({0} != {1} + 1)", "les tableaux devraient avoir une différence de taille de 1 ({0} != {1} + 1)" }, // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm
    new Object[]{ "identical abscissas x[{0}] == x[{1}] == {2} cause division by zero", "division par zéro causée par les abscisses identiques x[{0}] == x[{1}] == {2}" }, // org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction
    new Object[]{ "spline partition must have at least {0} points, got {1}", "une partiction spline nécessite au moins {0} points, seuls {1} ont été fournis" }, new Object[]{ "knot values must be strictly increasing", "les nœuds d\'\'interpolation doivent être strictement croissants" }, new Object[]{ "number of polynomial interpolants must match the number of segments ({0} != {1} - 1)", "le nombre d\'\'interpolants polynômiaux doit correspondre au nombre de segments ({0} != {1} - 1)" }, // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl
    new Object[]{ "function to solve cannot be null", "la fonction à résoudre ne peux pas être nulle" }, new Object[]{ "invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}", "paramètres de l\'\'intervalle initial invalides : borne inf = {0}, valeur initiale = {1}, borne sup = {2}" }, // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl
    // org.apache.commons.math.analysis.solvers.BrentSolver
    new Object[]{ "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]", "les valeurs de la fonction aux bornes n\'\'ont pas des signes différents. Bornes : [{0}, {1}], valeurs : [{2}, {3}]" }, // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl
    // org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl
    // org.apache.commons.math.transform.FastFourierTransformer
    new Object[]{ "endpoints do not specify an interval: [{0}, {1}]", "les extrémités ne constituent pas un intervalle : [{0}, {1}]" }, // org.apache.commons.math.analysis.solvers.LaguerreSolver
    new Object[]{ "function is not polynomial", "la fonction n\'\'est pas pôlynomiale" }, // org.apache.commons.math.analysis.solvers.NewtonSolver
    new Object[]{ "function is not differentiable", "la fonction n\'\'est pas différentiable" }, // org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl
    new Object[]{ "invalid iteration limits: min={0}, max={1}", "limites d\'\'itérations invalides : min = {0}, max = {1}" }, // org.apache.commons.math.analysis.integration.LegendreGaussIntegrator
    new Object[]{ "{0} points Legendre-Gauss integrator not supported," + " number of points must be in the {1}-{2} range", "intégrateur de Legendre-Gauss non supporté en {0} points, " + "le nombre de points doit être entre {1} et {2}" }, // org.apache.commons.math.fraction.Fraction
    new Object[]{ "zero denominator in fraction {0}/{1}", "dénominateur null dans le nombre rationnel {0}/{1}" }, new Object[]{ "overflow in fraction {0}/{1}, cannot negate", "dépassement de capacité pour la fraction {0}/{1}, son signe ne peut être changé" }, new Object[]{ "overflow, numerator too large after multiply: {0}", "dépassement de capacité pour le numérateur après multiplication : {0}" }, new Object[]{ "the fraction to divide by must not be zero: {0}/{1}", "division par un nombre rationnel nul : {0}/{1}" }, new Object[]{ "null fraction", "fraction nulle" }, // org.apache.commons.math.geometry.Rotation
    new Object[]{ "zero norm for rotation axis", "norme nulle pour un axe de rotation" }, new Object[]{ "zero norm for rotation defining vector", "norme nulle pour un axe de définition de rotation" }, // org.apache.commons.math.geometry.Vector3D
    // org.apache.commons.math.linear.ArrayRealVector
    new Object[]{ "cannot normalize a zero norm vector", "impossible de normer un vecteur de norme nulle" }, new Object[]{ "zero norm", "norme nulle" }, // org.apache.commons.math.ConvergingAlgorithmImpl
    new Object[]{ "no result available", "aucun résultat n\'\'est disponible" }, // org.apache.commons.math.linear.BigMatrixImpl
    new Object[]{ "first {0} rows are not initialized yet", "les {0} premières lignes ne sont pas encore initialisées" }, new Object[]{ "first {0} columns are not initialized yet", "les {0} premières colonnes ne sont pas encore initialisées" }, // org.apache.commons.math.stat.Frequency
    new Object[]{ "class ({0}) does not implement Comparable", "la classe ({0}) n''implante pas l''interface Comparable" }, new Object[]{ "instance of class {0} not comparable to existing values", "l''instance de la classe {0} n''est pas comparable aux valeurs existantes" }, // org.apache.commons.math.stat.StatUtils
    new Object[]{ "input arrays must have the same positive length ({0} and {1})", "les tableaux d\'\'entrée doivent avoir la même taille positive ({0} et {1})" }, new Object[]{ "input arrays must have the same length and at least two elements ({0} and {1})", "les tableaux d\'\'entrée doivent avoir la même taille" + " et au moins deux éléments ({0} et {1})" }, // org.apache.commons.math.stat.correlation.Covariance
    new Object[]{ "arrays must have the same length and both must have at " + "least two elements. xArray has size {0}, yArray has {1} elements", "les tableaux doivent avoir la même taille " + ("et comporter au moins deux éléments. " + "xArray a une taille de {0}, yArray a {1} éléments") }, new Object[]{ "insufficient data: only {0} rows and {1} columns.", "données insuffisantes : seulement {0} lignes et {1} colonnes." }, // org.apache.commons.math.stat.correlation.PearsonsCorrelation
    new Object[]{ "covariance matrix is null", "la matrice de covariance est nulle" }, new Object[]{ "invalid array dimensions. xArray has size {0}; yArray has {1} elements", "dimensions de tableaux invalides. xArray a une taille de {0}, " + "yArray a {1} éléments" }, // org.apache.commons.math.stat.descriptive.DescriptiveStatistics
    new Object[]{ "window size must be positive ({0})", "la taille de la fenêtre doit être positive ({0})" }, new Object[]{ "percentile implementation {0} does not support setQuantile", "l\'\'implantation de pourcentage {0} ne dispose pas de la méthode setQuantile" }, new Object[]{ "cannot access setQuantile method in percentile implementation {0}", "accès impossible à la méthode setQuantile" + " dans l''implantation de pourcentage {0}" }, new Object[]{ "out of bounds quantile value: {0}, must be in (0, 100]", "valeur de quantile {0} hors bornes, doit être dans l\'\'intervalle ]0, 100]" }, // org.apache.commons.math.stat.descriptive.moment.Variance
    // org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic
    // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
    new Object[]{ "input values array is null", "le tableau des valeurs d\'\'entrées est nul" }, // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
    new Object[]{ "start position cannot be negative ({0})", "la position de départ ne peut pas être négative" }, new Object[]{ "length cannot be negative ({0})", "la longueur ne peut pas être négative" }, new Object[]{ "subarray ends after array end", "le sous-tableau se termine après la fin du tableau" }, // org.apache.commons.math.stat.descriptive.moment.GeometricMean
    // org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics
    // org.apache.commons.math.stat.descriptive.SummaryStatistics
    new Object[]{ "{0} values have been added before statistic is configured", "{0} valeurs ont été ajoutées " + "avant que la statistique ne soit configurée" }, // org.apache.commons.math.stat.descriptive.moment.Kurtosis
    new Object[]{ "statistics constructed from external moments cannot be incremented", "les statistiques basées sur des moments externes " + "ne peuvent pas être incrémentées" }, new Object[]{ "statistics constructed from external moments cannot be cleared", "les statistiques basées sur des moments externes " + "ne peuvent pas être remises à zéro" }, // org.apache.commons.math.stat.inference.ChiSquareTestImpl
    new Object[]{ "expected array length = {0}, must be at least 2", "le tableau des valeurs attendues a une longueur de {0}, elle devrait être au moins de 2" }, new Object[]{ "observed array length = {0}, must be at least 2", "le tableau des valeurs observées a une longueur de {0}, elle devrait être au moins de 2" }, new Object[]{ "observed counts are all 0 in first observed array", "aucune occurrence dans le premier tableau des observations" }, new Object[]{ "observed counts are all 0 in second observed array", "aucune occurrence dans le second tableau des observations" }, new Object[]{ "observed counts are both zero for entry {0}", "les occurrences observées sont toutes deux nulles pour l\'entrée {0}" }, new Object[]{ "invalid row dimension: {0} (must be at least 2)", "nombre de lignes invalide : {0} (doit être au moins de 2)" }, new Object[]{ "invalid column dimension: {0} (must be at least 2)", "nombre de colonnes invalide : {0} (doit être au moins de 2)" }, new Object[]{ "element {0} is not positive: {1}", "l\'\'élément {0} n\'\'est pas positif : {1}" }, new Object[]{ "element {0} is negative: {1}", "l\'\'élément {0} est négatif : {1}" }, new Object[]{ "element ({0}, {1}) is negative: {2}", "l\'\'élément ({0}, {1}) est négatif : {2}" }, // org.apache.commons.math.stat.inference.OneWayAnovaImpl
    new Object[]{ "two or more categories required, got {0}", "deux catégories ou plus sont nécessaires, il y en a {0}" }, new Object[]{ "two or more values required in each category, one has {0}", "deux valeurs ou plus sont nécessaires pour chaque catégorie, une catégorie en a {0}" }, // org.apache.commons.math.stat.inference.TTestImpl
    new Object[]{ "insufficient data for t statistic, needs at least 2, got {0}", "deux valeurs ou plus sont nécessaires pour la statistique t, il y en a {0}" }, // org.apache.commons.math.stat.inference.ChiSquareTestImpl
    // org.apache.commons.math.stat.inference.TTestImpl
    // org.apache.commons.math.stat.inference.OneWayAnovaImpl
    // org.apache.commons.math.stat.Regression
    new Object[]{ "out of bounds significance level {0}, must be between {1} and {2}", "niveau de signification {0} hors domaine, doit être entre {1} et {2}" }, // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression
    new Object[]{ "not enough data ({0} rows) for this many predictors ({1} predictors)", "pas assez de données ({0} lignes) pour {1} prédicteurs" }, // org.apache.commons.math.distribution.AbstractContinuousDistribution
    // org.apache.commons.math.distribution.AbstractIntegerDistribution
    // org.apache.commons.math.distribution.ExponentialDistributionImpl
    // org.apache.commons.math.distribution.BinomialDistributionImpl
    // org.apache.commons.math.distribution.CauchyDistributionImpl
    // org.apache.commons.math.distribution.PascalDistributionImpl
    // org.apache.commons.math.distribution.WeibullDistributionImpl
    new Object[]{ "{0} out of [{1}, {2}] range", "{0} hors du domaine [{1}, {2}]" }, // org.apache.commons.math.distribution.AbstractDistribution
    // org.apache.commons.math.distribution.AbstractIntegerDistribution
    new Object[]{ "lower endpoint ({0}) must be less than or equal to upper endpoint ({1})", "la borne inférieure ({0}) devrait être inférieure " + "ou égale à la borne supérieure ({1})" }, // org.apache.commons.math.distribution.BinomialDistributionImpl
    new Object[]{ "number of trials must be non-negative ({0})", "le nombre d\'\'essais ne doit pas être négatif ({0})" }, // org.apache.commons.math.distribution.ExponentialDistributionImpl
    // org.apache.commons.math.random.RandomDataImpl
    new Object[]{ "mean must be positive ({0})", "la moyenne doit être positive ({0})" }, // org.apache.commons.math.distribution.FDistributionImpl
    // org.apache.commons.math.distribution.TDistributionImpl
    new Object[]{ "degrees of freedom must be positive ({0})", "les degrés de liberté doivent être positifs ({0})" }, // org.apache.commons.math.distribution.GammaDistributionImpl
    new Object[]{ "alpha must be positive ({0})", "alpha doit être positif ({0})" }, new Object[]{ "beta must be positive ({0})", "beta doit être positif ({0})" }, // org.apache.commons.math.distribution.HypergeometricDistributionImpl
    new Object[]{ "number of successes ({0}) must be less than or equal to population size ({1})", "le nombre de succès doit être inférieur " + "ou égal à la taille de la population ({1})" }, new Object[]{ "sample size ({0}) must be less than or equal to population size ({1})", "la taille de l\'\'échantillon doit être inférieure " + "ou égale à la taille de la population ({1})" }, new Object[]{ "population size must be positive ({0})", "la taille de la population doit être positive ({0})" }, // org.apache.commons.math.distribution.HypergeometricDistributionImpl
    // org.apache.commons.math.random.RandomDataImpl
    new Object[]{ "sample size must be positive ({0})", "la taille de l\'\'échantillon doit être positive ({0})" }, // org.apache.commons.math.distribution.HypergeometricDistributionImpl
    // org.apache.commons.math.distribution.PascalDistributionImpl
    new Object[]{ "number of successes must be non-negative ({0})", "le nombre de succès ne doit pas être négatif ({0})" }, // org.apache.commons.math.distribution.NormalDistributionImpl
    // org.apache.commons.math.random.RandomDataImpl
    new Object[]{ "standard deviation must be positive ({0})", "l\'\'écart type doit être positif ({0})" }, // org.apache.commons.math.distribution.PoissonDistributionImpl
    // org.apache.commons.math.random.RandomDataImpl
    new Object[]{ "the Poisson mean must be positive ({0})", "la moyenne de Poisson doit être positive ({0})" }, // org.apache.commons.math.distribution.WeibullDistributionImpl
    new Object[]{ "shape must be positive ({0})", "le facteur de forme doit être positif ({0})" }, // org.apache.commons.math.distribution.WeibullDistributionImpl
    // org.apache.commons.math.distribution.CauchyDistributionImpl
    new Object[]{ "scale must be positive ({0})", "l\'\'échelle doit être positive ({0})" }, // org.apache.commons.math.distribution.ZipfDistributionImpl
    new Object[]{ "invalid number of elements {0} (must be positive)", "nombre d\'\'éléments {0} invalide (doit être positif)" }, new Object[]{ "invalid exponent {0} (must be positive)", "exposant {0} invalide (doit être positif)" }, // org.apache.commons.math.transform.FastHadamardTransformer
    new Object[]{ "{0} is not a power of 2", "{0} n''est pas une puissance de 2" }, // org.apache.commons.math.transform.FastFourierTransformer
    new Object[]{ "cannot compute 0-th root of unity, indefinite result", "impossible de calculer la racine zéroième de l\'\'unité, " + "résultat indéfini" }, new Object[]{ "roots of unity have not been computed yet", "les racines de l\'\'unité n\'\'ont pas encore été calculées" }, new Object[]{ "out of range root of unity index {0} (must be in [{1};{2}])", "index de racine de l\'\'unité hors domaine (devrait être dans [{1}; {2}])" }, new Object[]{ "number of sample is not positive: {0}", "le nombre d\'\'échantillons n\'\'est pas positif : {0}" }, new Object[]{ "{0} is not a power of 2, consider padding for fix", "{0} n\'\'est pas une puissance de 2, ajoutez des éléments pour corriger" }, new Object[]{ "some dimensions don't match: {0} != {1}", "certaines dimensions sont incohérentes : {0} != {1}" }, // org.apache.commons.math.transform.FastCosineTransformer
    new Object[]{ "{0} is not a power of 2 plus one", "{0} n''est pas une puissance de 2 plus un" }, // org.apache.commons.math.transform.FastSineTransformer
    new Object[]{ "first element is not 0: {0}", "le premier élément n\'\'est pas nul : {0}" }, // org.apache.commons.math.util.OpenIntToDoubleHashMap
    new Object[]{ "map has been modified while iterating", "la table d\'\'adressage a été modifiée pendant l\'\'itération" }, new Object[]{ "iterator exhausted", "itération achevée" }, // org.apache.commons.math.MathRuntimeException
    new Object[]{ "internal error, please fill a bug report at {0}", "erreur interne, veuillez signaler l\'\'erreur à {0}" } };

    /**
     * Simple constructor.
     */
    public MessagesResources_fr() {
    }

    /**
     * Get the non-translated/translated messages arrays from this resource bundle.
     *
     * @return non-translated/translated messages arrays
     */
    @Override
    public Object[][] getContents() {
        return CONTENTS.clone();
    }
}