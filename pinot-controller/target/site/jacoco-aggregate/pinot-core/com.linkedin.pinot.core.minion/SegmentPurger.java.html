<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentPurger.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-controller</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.minion</a> &gt; <span class="el_source">SegmentPurger.java</span></div><h1>SegmentPurger.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.minion;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.data.StarTreeIndexSpec;
import com.linkedin.pinot.common.segment.SegmentMetadata;
import com.linkedin.pinot.common.segment.StarTreeMetadata;
import com.linkedin.pinot.core.data.GenericRow;
import com.linkedin.pinot.core.data.readers.PinotSegmentRecordReader;
import com.linkedin.pinot.core.data.readers.RecordReader;
import com.linkedin.pinot.core.indexsegment.generator.SegmentGeneratorConfig;
import com.linkedin.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;
import com.linkedin.pinot.core.segment.index.SegmentMetadataImpl;
import java.io.File;
import java.io.IOException;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * The &lt;code&gt;SegmentPurger&lt;/code&gt; class takes a segment and purges/modifies its records and generate a new segment with
 * the remaining modified records.
 */
public class SegmentPurger {
<span class="fc" id="L44">  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentPurger.class);</span>

  private final File _originalIndexDir;
  private final File _workingDir;
  private final RecordPurger _recordPurger;
  private final RecordModifier _recordModifier;

  private int _numRecordsPurged;
  private int _numRecordsModified;

  public SegmentPurger(@Nonnull File originalIndexDir, @Nonnull File workingDir, @Nullable RecordPurger recordPurger,
<span class="fc" id="L55">      @Nullable RecordModifier recordModifier) {</span>
<span class="pc bpc" id="L56" title="3 of 4 branches missed.">    Preconditions.checkArgument(recordPurger != null || recordModifier != null,</span>
        &quot;At least one of record purger and modifier should be non-null&quot;);
<span class="fc" id="L58">    _originalIndexDir = originalIndexDir;</span>
<span class="fc" id="L59">    _workingDir = workingDir;</span>
<span class="fc" id="L60">    _recordPurger = recordPurger;</span>
<span class="fc" id="L61">    _recordModifier = recordModifier;</span>
<span class="fc" id="L62">  }</span>

  public File purgeSegment() throws Exception {
<span class="fc" id="L65">    SegmentMetadata segmentMetadata = new SegmentMetadataImpl(_originalIndexDir);</span>
<span class="fc" id="L66">    String tableName = segmentMetadata.getTableName();</span>
<span class="fc" id="L67">    String segmentName = segmentMetadata.getName();</span>
<span class="fc" id="L68">    LOGGER.info(&quot;Start purging table: {}, segment: {}&quot;, tableName, segmentName);</span>

<span class="pc" id="L70">    try (PurgeRecordReader purgeRecordReader = new PurgeRecordReader()) {</span>
<span class="fc" id="L71">      SegmentGeneratorConfig config = new SegmentGeneratorConfig(purgeRecordReader.getSchema());</span>
<span class="fc" id="L72">      config.setOutDir(_workingDir.getPath());</span>
<span class="fc" id="L73">      config.setTableName(tableName);</span>
<span class="fc" id="L74">      config.setSegmentName(segmentName);</span>
      // Keep index creation time the same as original segment because both segments use the same raw data.
      // This way, for REFRESH case, when new segment gets pushed to controller, we can use index creation time to
      // identify if the new pushed segment has newer data than the existing one.
<span class="fc" id="L78">      config.setCreationTime(String.valueOf(segmentMetadata.getIndexCreationTime()));</span>

<span class="fc" id="L80">      StarTreeMetadata starTreeMetadata = segmentMetadata.getStarTreeMetadata();</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">      if (starTreeMetadata != null) {</span>
<span class="nc" id="L82">        config.enableStarTreeIndex(StarTreeIndexSpec.fromStarTreeMetadata(starTreeMetadata));</span>
      }

<span class="fc" id="L85">      SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();</span>
<span class="fc" id="L86">      driver.init(config, purgeRecordReader);</span>
<span class="fc" id="L87">      driver.build();</span>

<span class="fc" id="L89">      LOGGER.info(&quot;Finish purging table: {}, segment: {}, purged {} records, modified {} records&quot;, tableName,</span>
          segmentName, _numRecordsPurged, _numRecordsModified);
<span class="fc" id="L91">      return new File(_workingDir, segmentName);</span>
<span class="pc bpc" id="L92" title="6 of 8 branches missed.">    }</span>
  }

  @VisibleForTesting
  int getNumRecordsPurged() {
<span class="fc" id="L97">    return _numRecordsPurged;</span>
  }

  @VisibleForTesting
  int getNumRecordsModified() {
<span class="fc" id="L102">    return _numRecordsModified;</span>
  }

  private class PurgeRecordReader implements RecordReader {
    final PinotSegmentRecordReader _recordReader;

    // Reusable generic row to store the next row to return
<span class="fc" id="L109">    GenericRow _nextRow = new GenericRow();</span>
    // Flag to mark whether we need to fetch another row
<span class="fc" id="L111">    boolean _nextRowReturned = true;</span>
    // Flag to mark whether all records have been iterated
<span class="fc" id="L113">    boolean _finished = false;</span>

<span class="fc" id="L115">    PurgeRecordReader() throws Exception {</span>
<span class="fc" id="L116">      _recordReader = new PinotSegmentRecordReader(_originalIndexDir);</span>
<span class="fc" id="L117">    }</span>

    @Override
    public boolean hasNext() {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">      if (_recordPurger == null) {</span>
<span class="nc" id="L122">        return _recordReader.hasNext();</span>
      } else {
        // If all records have already been iterated, return false
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (_finished) {</span>
<span class="nc" id="L126">          return false;</span>
        }

        // If next row has not been returned, return true
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (!_nextRowReturned) {</span>
<span class="nc" id="L131">          return true;</span>
        }

        // Try to get the next row to return
<span class="fc bfc" id="L135" title="All 2 branches covered.">        while (_recordReader.hasNext()) {</span>
<span class="fc" id="L136">          _nextRow = _recordReader.next(_nextRow);</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">          if (_recordPurger.shouldPurge(_nextRow)) {</span>
<span class="fc" id="L139">            _numRecordsPurged++;</span>
          } else {
<span class="fc" id="L141">            _nextRowReturned = false;</span>
<span class="fc" id="L142">            return true;</span>
          }
        }

        // Cannot find next row to return, return false
<span class="fc" id="L147">        _finished = true;</span>
<span class="fc" id="L148">        return false;</span>
      }
    }

    @Override
    public GenericRow next() throws IOException {
<span class="nc" id="L154">      return next(new GenericRow());</span>
    }

    @Override
    public GenericRow next(GenericRow reuse) throws IOException {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">      if (_recordPurger == null) {</span>
<span class="nc" id="L160">        reuse = _recordReader.next(reuse);</span>
      } else {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; entry : _nextRow.getEntrySet()) {</span>
<span class="fc" id="L163">          reuse.putField(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L164">        }</span>
<span class="fc" id="L165">        _nextRowReturned = true;</span>
      }

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">      if (_recordModifier != null) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (_recordModifier.modifyRecord(reuse)) {</span>
<span class="fc" id="L170">          _numRecordsModified++;</span>
        }
      }

<span class="fc" id="L174">      return reuse;</span>
    }

    @Override
    public void rewind() throws IOException {
<span class="fc" id="L179">      _recordReader.rewind();</span>
<span class="fc" id="L180">      _nextRowReturned = true;</span>
<span class="fc" id="L181">      _finished = false;</span>

<span class="fc" id="L183">      _numRecordsPurged = 0;</span>
<span class="fc" id="L184">      _numRecordsModified = 0;</span>
<span class="fc" id="L185">    }</span>

    @Override
    public Schema getSchema() {
<span class="fc" id="L189">      return _recordReader.getSchema();</span>
    }

    @Override
    public void close() throws IOException {
<span class="fc" id="L194">      _recordReader.close();</span>
<span class="fc" id="L195">    }</span>
  }

  /**
   * Factory for {@link RecordPurger}
   */
  public interface RecordPurgerFactory {

    /**
     * Get the {@link RecordPurger} for the given table.
     */
    RecordPurger getRecordPurger(@Nonnull String tableName);
  }

  /**
   * Purger for each {@link GenericRow} record.
   */
  public interface RecordPurger {

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if the record should be purged.
     */
    boolean shouldPurge(GenericRow row);
  }

  /**
   * Factory for {@link RecordModifier}
   */
  public interface RecordModifierFactory {

    /**
     * Get the {@link RecordModifier} for the given table.
     */
    RecordModifier getRecordModifier(@Nonnull String tableName);
  }

  /**
   * Modifier for each {@link GenericRow} record.
   */
  public interface RecordModifier {

    /**
     * Modify the record inplace, and return &lt;code&gt;true&lt;/code&gt; if the record get modified.
     */
    boolean modifyRecord(GenericRow row);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>