<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentDictionaryCreator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-controller</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.segment.creator.impl</a> &gt; <span class="el_source">SegmentDictionaryCreator.java</span></div><h1>SegmentDictionaryCreator.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.segment.creator.impl;

import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.data.MetricFieldSpec;
import com.linkedin.pinot.core.io.writer.impl.FixedByteSingleValueMultiColWriter;
import it.unimi.dsi.fastutil.doubles.Double2IntOpenHashMap;
import it.unimi.dsi.fastutil.floats.Float2IntOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class SegmentDictionaryCreator implements Closeable {
<span class="fc" id="L37">  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentDictionaryCreator.class);</span>
<span class="fc" id="L38">  private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span>

  private final Object sortedList;
  private final FieldSpec spec;
  private final File dictionaryFile;
  private final int rowCount;

  private Int2IntOpenHashMap intValueToIndexMap;
  private Long2IntOpenHashMap longValueToIndexMap;
  private Float2IntOpenHashMap floatValueToIndexMap;
  private Double2IntOpenHashMap doubleValueToIndexMap;
  private Object2IntOpenHashMap&lt;String&gt; stringValueToIndexMap;

<span class="fc" id="L51">  private int stringColumnMaxLength = 0;</span>

  public SegmentDictionaryCreator(boolean hasNulls, Object sortedList, FieldSpec spec, File indexDir)
<span class="fc" id="L54">      throws IOException {</span>
<span class="fc" id="L55">    rowCount = ArrayUtils.getLength(sortedList);</span>

<span class="fc" id="L57">    Object first = null;</span>
<span class="fc" id="L58">    Object last = null;</span>

<span class="pc bpc" id="L60" title="1 of 2 branches missed.">    if (0 &lt; rowCount) {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">      if (sortedList instanceof int[]) {</span>
<span class="fc" id="L62">        int[] intSortedList = (int[]) sortedList;</span>
<span class="fc" id="L63">        first = intSortedList[0];</span>
<span class="fc" id="L64">        last = intSortedList[rowCount - 1];</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">      } else if (sortedList instanceof long[]) {</span>
<span class="fc" id="L66">        long[] longSortedList = (long[]) sortedList;</span>
<span class="fc" id="L67">        first = longSortedList[0];</span>
<span class="fc" id="L68">        last = longSortedList[rowCount - 1];</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">      } else if (sortedList instanceof float[]) {</span>
<span class="fc" id="L70">        float[] floatSortedList = (float[]) sortedList;</span>
<span class="fc" id="L71">        first = floatSortedList[0];</span>
<span class="fc" id="L72">        last = floatSortedList[rowCount - 1];</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">      } else if (sortedList instanceof double[]) {</span>
<span class="fc" id="L74">        double[] doubleSortedList = (double[]) sortedList;</span>
<span class="fc" id="L75">        first = doubleSortedList[0];</span>
<span class="fc" id="L76">        last = doubleSortedList[rowCount - 1];</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">      } else if (sortedList instanceof String[]) {</span>
<span class="fc" id="L78">        String[] intSortedList = (String[]) sortedList;</span>
<span class="fc" id="L79">        first = intSortedList[0];</span>
<span class="fc" id="L80">        last = intSortedList[rowCount - 1];</span>
<span class="pc bnc" id="L81" title="All 2 branches missed.">      } else if (sortedList instanceof Object[]) {</span>
<span class="nc" id="L82">        Object[] intSortedList = (Object[]) sortedList;</span>
<span class="nc" id="L83">        first = intSortedList[0];</span>
<span class="nc" id="L84">        last = intSortedList[rowCount - 1];</span>
      }
    }

    // make hll column log info different than other columns, since range makes no sense for hll column
<span class="fc bfc" id="L89" title="All 4 branches covered.">    if (spec instanceof MetricFieldSpec &amp;&amp;</span>
        ((MetricFieldSpec)spec).getDerivedMetricType() == MetricFieldSpec.DerivedMetricType.HLL) {
<span class="fc" id="L91">      LOGGER.info(</span>
          &quot;Creating segment for column {}, hasNulls = {}, cardinality = {}, dataType = {}, single value field = {}, is HLL derived column&quot;,
          spec.getName(), hasNulls, rowCount, spec.getDataType(), spec.isSingleValueField());
    } else {
<span class="fc" id="L95">      LOGGER.info(</span>
          &quot;Creating segment for column {}, hasNulls = {}, cardinality = {}, dataType = {}, single value field = {}, range = {} to {}&quot;,
          spec.getName(), hasNulls, rowCount, spec.getDataType(), spec.isSingleValueField(), first, last);
    }
<span class="fc" id="L99">    this.sortedList = sortedList;</span>
<span class="fc" id="L100">    this.spec = spec;</span>
<span class="fc" id="L101">    dictionaryFile = new File(indexDir, spec.getName() + V1Constants.Dict.FILE_EXTENSION);</span>
<span class="fc" id="L102">    FileUtils.touch(dictionaryFile);</span>
<span class="fc" id="L103">  }</span>

  @Override
  public void close() throws IOException {
<span class="fc" id="L107">  }</span>

  public void build() throws Exception {
<span class="pc bpc" id="L110" title="1 of 6 branches missed.">    switch (spec.getDataType()) {</span>
      case INT:
<span class="fc" id="L112">        final FixedByteSingleValueMultiColWriter intDictionaryWrite =</span>
            new FixedByteSingleValueMultiColWriter(dictionaryFile, rowCount, 1,
                V1Constants.Dict.INT_DICTIONARY_COL_SIZE);
<span class="fc" id="L115">        intValueToIndexMap = new Int2IntOpenHashMap(rowCount);</span>
<span class="fc" id="L116">        int[] sortedInts = (int[]) sortedList;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (int i = 0; i &lt; rowCount; i++) {</span>
<span class="fc" id="L118">          final int entry = sortedInts[i];</span>
<span class="fc" id="L119">          intDictionaryWrite.setInt(i, 0, entry);</span>
<span class="fc" id="L120">          intValueToIndexMap.put(entry, i);</span>
        }
<span class="fc" id="L122">        intDictionaryWrite.close();</span>
<span class="fc" id="L123">        break;</span>
      case FLOAT:
<span class="fc" id="L125">        final FixedByteSingleValueMultiColWriter floatDictionaryWrite =</span>
            new FixedByteSingleValueMultiColWriter(dictionaryFile, rowCount, 1,
                V1Constants.Dict.FLOAT_DICTIONARY_COL_SIZE);
<span class="fc" id="L128">        floatValueToIndexMap = new Float2IntOpenHashMap(rowCount);</span>
<span class="fc" id="L129">        float[] sortedFloats = (float[]) sortedList;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (int i = 0; i &lt; rowCount; i++) {</span>
<span class="fc" id="L131">          final float entry = sortedFloats[i];</span>
<span class="fc" id="L132">          floatDictionaryWrite.setFloat(i, 0, entry);</span>
<span class="fc" id="L133">          floatValueToIndexMap.put(entry, i);</span>
        }
<span class="fc" id="L135">        floatDictionaryWrite.close();</span>
<span class="fc" id="L136">        break;</span>
      case LONG:
<span class="fc" id="L138">        final FixedByteSingleValueMultiColWriter longDictionaryWrite =</span>
            new FixedByteSingleValueMultiColWriter(dictionaryFile, rowCount, 1,
                V1Constants.Dict.LONG_DICTIONARY_COL_SIZE);
<span class="fc" id="L141">        longValueToIndexMap = new Long2IntOpenHashMap(rowCount);</span>
<span class="fc" id="L142">        long[] sortedLongs = (long[]) sortedList;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (int i = 0; i &lt; rowCount; i++) {</span>
<span class="fc" id="L144">          final long entry = sortedLongs[i];</span>
<span class="fc" id="L145">          longDictionaryWrite.setLong(i, 0, entry);</span>
<span class="fc" id="L146">          longValueToIndexMap.put(entry, i);</span>
        }
<span class="fc" id="L148">        longDictionaryWrite.close();</span>
<span class="fc" id="L149">        break;</span>
      case DOUBLE:
<span class="fc" id="L151">        final FixedByteSingleValueMultiColWriter doubleDictionaryWrite =</span>
            new FixedByteSingleValueMultiColWriter(dictionaryFile, rowCount, 1,
                V1Constants.Dict.DOUBLE_DICTIONARY_COL_SIZE);
<span class="fc" id="L154">        doubleValueToIndexMap = new Double2IntOpenHashMap(rowCount);</span>
<span class="fc" id="L155">        double[] sortedDoubles = (double[]) sortedList;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (int i = 0; i &lt; rowCount; i++) {</span>
<span class="fc" id="L157">          final double entry = sortedDoubles[i];</span>
<span class="fc" id="L158">          doubleDictionaryWrite.setDouble(i, 0, entry);</span>
<span class="fc" id="L159">          doubleValueToIndexMap.put(entry, i);</span>
        }
<span class="fc" id="L161">        doubleDictionaryWrite.close();</span>
<span class="fc" id="L162">        break;</span>
      case STRING:
        // TODO: here we call getBytes() multiple times, could be optimized
<span class="fc" id="L165">        String[] sortedStrings = (String[]) sortedList;</span>

        // Get the maximum length of all entries
<span class="fc" id="L168">        stringColumnMaxLength = 1; // make sure that there is non-zero sized dictionary JIRA:PINOT-2947</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (String entry : sortedStrings) {</span>
<span class="fc" id="L170">          int length = entry.getBytes(UTF_8).length;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">          if (stringColumnMaxLength &lt; length) {</span>
<span class="fc" id="L172">            stringColumnMaxLength = length;</span>
          }
        }

<span class="fc" id="L176">        final FixedByteSingleValueMultiColWriter stringDictionaryWrite =</span>
            new FixedByteSingleValueMultiColWriter(dictionaryFile, rowCount, 1, new int[]{stringColumnMaxLength});
<span class="fc" id="L178">        stringValueToIndexMap = new Object2IntOpenHashMap&lt;&gt;(rowCount);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        for (int i = 0; i &lt; rowCount; i++) {</span>
<span class="fc" id="L180">          String entry = sortedStrings[i];</span>
<span class="fc" id="L181">          stringDictionaryWrite.setString(i, 0, getPaddedString(entry, stringColumnMaxLength));</span>
<span class="fc" id="L182">          stringValueToIndexMap.put(entry, i);</span>
        }
<span class="fc" id="L184">        stringDictionaryWrite.close();</span>
<span class="fc" id="L185">        break;</span>
      default:
<span class="nc" id="L187">        throw new RuntimeException(&quot;Unhandled type &quot; + spec.getDataType());</span>
    }
<span class="fc" id="L189">  }</span>

  public int getStringColumnMaxLength() {
<span class="fc" id="L192">    return stringColumnMaxLength;</span>
  }

  public int indexOfSV(Object e) {
<span class="pc bpc" id="L196" title="1 of 6 branches missed.">    switch (spec.getDataType()) {</span>
      case INT:
<span class="fc" id="L198">        return intValueToIndexMap.get(e);</span>
      case FLOAT:
<span class="fc" id="L200">        return floatValueToIndexMap.get(e);</span>
      case DOUBLE:
<span class="fc" id="L202">        return doubleValueToIndexMap.get(e);</span>
      case LONG:
<span class="fc" id="L204">        return longValueToIndexMap.get(e);</span>
      case STRING:
      case BOOLEAN:
<span class="fc" id="L207">        String value = e.toString();</span>
<span class="fc" id="L208">        return stringValueToIndexMap.get(value);</span>
      default:
<span class="nc" id="L210">        throw new UnsupportedOperationException(&quot;Unsupported data type : &quot; + spec.getDataType() +</span>
            &quot; for column : &quot; + spec.getName());
    }
  }

  public int[] indexOfMV(Object e) {

<span class="fc" id="L217">    final Object[] multiValues = (Object[]) e;</span>
<span class="fc" id="L218">    final int[] ret = new int[multiValues.length];</span>

<span class="pc bpc" id="L220" title="4 of 6 branches missed.">    switch (spec.getDataType()) {</span>
      case INT:
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (int i = 0; i &lt; multiValues.length; i++) {</span>
<span class="fc" id="L223">          ret[i] = intValueToIndexMap.get(multiValues[i]);</span>
        }
<span class="fc" id="L225">        break;</span>
      case FLOAT:
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (int i = 0; i &lt; multiValues.length; i++) {</span>
<span class="nc" id="L228">          ret[i] = floatValueToIndexMap.get(multiValues[i]);</span>
        }
<span class="nc" id="L230">        break;</span>
      case LONG:
<span class="nc bnc" id="L232" title="All 2 branches missed.">        for (int i = 0; i &lt; multiValues.length; i++) {</span>
<span class="nc" id="L233">          ret[i] = longValueToIndexMap.get(multiValues[i]);</span>
        }
<span class="nc" id="L235">        break;</span>
      case DOUBLE:
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (int i = 0; i &lt; multiValues.length; i++) {</span>
<span class="nc" id="L238">          ret[i] = doubleValueToIndexMap.get(multiValues[i]);</span>
        }
<span class="nc" id="L240">        break;</span>
      case STRING:
      case BOOLEAN:
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (int i = 0; i &lt; multiValues.length; i++) {</span>
<span class="fc" id="L244">          String value = multiValues[i].toString();</span>
<span class="fc" id="L245">          ret[i] = stringValueToIndexMap.get(value);</span>
        }
<span class="fc" id="L247">        break;</span>
      default:
<span class="nc" id="L249">        throw new UnsupportedOperationException(&quot;Unsupported data type : &quot; + spec.getDataType() +</span>
            &quot; for multivalue column : &quot; + spec.getName());
    }

<span class="fc" id="L253">    return ret;</span>
  }

  /**
   * Given an input string and a target length, appends padding characters (&lt;code&gt;'\0'&lt;/code&gt;) to the string to make it
   * of desired length.
   */
  public static String getPaddedString(String inputString, int targetLength) {
<span class="fc" id="L261">    byte[] bytes = inputString.getBytes(UTF_8);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">    if (bytes.length == targetLength) {</span>
<span class="fc" id="L263">      return inputString;</span>
    }

<span class="fc" id="L266">    StringBuilder stringBuilder = new StringBuilder(inputString);</span>
<span class="fc" id="L267">    int numBytesToPad = targetLength - bytes.length;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">    for (int i = 0; i &lt; numBytesToPad; i++) {</span>
<span class="fc" id="L269">      stringBuilder.append(V1Constants.Str.DEFAULT_STRING_PAD_CHAR);</span>
    }
<span class="fc" id="L271">    return stringBuilder.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>