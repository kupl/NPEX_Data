<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeFormatSpec.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-controller</a> &gt; <a href="../index.html" class="el_bundle">pinot-common</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.common.data</a> &gt; <span class="el_source">DateTimeFormatSpec.java</span></div><h1>DateTimeFormatSpec.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.common.data;

import com.linkedin.pinot.common.utils.EqualityUtils;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.linkedin.pinot.common.data.DateTimeFieldSpec.TimeFormat;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTimeZone;
import org.joda.time.format.DateTimeFormatter;


/**
 * Class to represent format from {@link DateTimeFieldSpec}
 */
public class DateTimeFormatSpec {

  public static final String FORMAT_TOKENS_ERROR_STR = &quot;format must be of pattern size:timeunit:timeformat(:pattern)&quot;;
  public static final String FORMAT_PATTERN_ERROR_STR =
      &quot;format must be of format [0-9]+:&lt;TimeUnit&gt;:&lt;TimeFormat&gt;(:pattern)&quot;;
  public static final String TIME_FORMAT_ERROR_STR =
      &quot;format must be of format [0-9]+:&lt;TimeUnit&gt;:EPOCH or [0-9]+:&lt;TimeUnit&gt;:SIMPLE_DATE_FORMAT:&lt;format&gt;&quot;;

  public static final String NUMBER_REGEX = &quot;[1-9][0-9]*&quot;;

  public static final String COLON_SEPARATOR = &quot;:&quot;;

  /* DateTimeFieldSpec format is of format size:timeUnit:timeformat:pattern tz(timezone)
   * tz(timezone) is optional. If not specified, UTC timezone is used */
  public static final int FORMAT_SIZE_POSITION = 0;
  public static final int FORMAT_UNIT_POSITION = 1;
  public static final int FORMAT_TIMEFORMAT_POSITION = 2;
  public static final int FORMAT_PATTERN_POSITION = 3;
  public static final int MIN_FORMAT_TOKENS = 3;
  public static final int MAX_FORMAT_TOKENS = 4;

  private String _format;
  private int _size;
  private DateTimeFormatUnitSpec _unitSpec;
  private DateTimeFormatPatternSpec _patternSpec;

<span class="fc" id="L59">  public DateTimeFormatSpec(String format) {</span>
<span class="fc" id="L60">    _format = format;</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">    if (isValidFormat(format)) {</span>
<span class="fc" id="L62">      String[] formatTokens = format.split(COLON_SEPARATOR, MAX_FORMAT_TOKENS);</span>
<span class="fc" id="L63">      _size = Integer.valueOf(formatTokens[FORMAT_SIZE_POSITION]);</span>
<span class="fc" id="L64">      _unitSpec = new DateTimeFormatUnitSpec(formatTokens[FORMAT_UNIT_POSITION]);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">      if (formatTokens.length == MAX_FORMAT_TOKENS) {</span>
<span class="fc" id="L66">         _patternSpec = new DateTimeFormatPatternSpec(formatTokens[FORMAT_TIMEFORMAT_POSITION],</span>
            formatTokens[FORMAT_PATTERN_POSITION]);
      } else {
<span class="fc" id="L69">         _patternSpec = new DateTimeFormatPatternSpec(formatTokens[FORMAT_TIMEFORMAT_POSITION], null);</span>
      }
    }
<span class="fc" id="L72">  }</span>

  /**
   * Constructs a dateTimeSpec format, given the components of a format
   * @param columnSize
   * @param columnUnit
   * @param columnTimeFormat
   * @return
   */
<span class="fc" id="L81">  public DateTimeFormatSpec(int columnSize, String columnUnit, String columnTimeFormat) {</span>
<span class="fc" id="L82">    _format = Joiner.on(COLON_SEPARATOR).join(columnSize, columnUnit, columnTimeFormat);</span>
<span class="fc" id="L83">    isValidFormat(_format);</span>

<span class="fc" id="L85">    _size = columnSize;</span>
<span class="fc" id="L86">    _unitSpec = new DateTimeFormatUnitSpec(columnUnit);</span>
<span class="fc" id="L87">    _patternSpec = new DateTimeFormatPatternSpec(columnTimeFormat, null);</span>
<span class="fc" id="L88">  }</span>

  /**
   * Constructs a dateTimeSpec format, given the components of a format
   * @param columnSize
   * @param columnUnit
   * @param columnTimeFormat
   * @param sdfPattern and tz
   * @return
   */
  public DateTimeFormatSpec(int columnSize, String columnUnit, String columnTimeFormat,
<span class="fc" id="L99">      String sdfPattern) {</span>
<span class="fc" id="L100">    _format = Joiner.on(COLON_SEPARATOR).join(columnSize, columnUnit, columnTimeFormat, sdfPattern);</span>
<span class="fc" id="L101">    isValidFormat(_format);</span>

<span class="fc" id="L103">    _size = columnSize;</span>
<span class="fc" id="L104">    _unitSpec = new DateTimeFormatUnitSpec(columnUnit);</span>
<span class="fc" id="L105">    _patternSpec = new DateTimeFormatPatternSpec(columnTimeFormat, sdfPattern);</span>
<span class="fc" id="L106">  }</span>

  public String getFormat() {
<span class="fc" id="L109">    return _format;</span>
  }

  public int getColumnSize() {
<span class="fc" id="L113">    return _size;</span>
  }

  public TimeUnit getColumnUnit() {
<span class="fc" id="L117">    return _unitSpec.getTimeUnit();</span>
  }

  public DateTimeFormatUnitSpec.DateTimeTransformUnit getColumnDateTimeTransformUnit() {
<span class="fc" id="L121">    return _unitSpec.getDateTimeTransformUnit();</span>
  }

  public TimeFormat getTimeFormat() {
<span class="fc" id="L125">    return _patternSpec.getTimeFormat();</span>
  }

  public String getSDFPattern() {
<span class="fc" id="L129">    return _patternSpec.getSdfPattern();</span>
  }

  public DateTimeZone getDateTimezone() {
<span class="fc" id="L133">    return _patternSpec.getDateTimeZone();</span>
  }

  public DateTimeFormatter getDateTimeFormatter() {
<span class="fc" id="L137">    return _patternSpec.getDateTimeFormatter();</span>
  }

  /**
   * &lt;ul&gt;
   * &lt;li&gt;Given a timestamp in millis, convert it to the given format
   * This method should not do validation of outputGranularity.
   * The validation should be handled by caller using {@link #isValidFormat(String)}&lt;/li&gt;
   * &lt;ul&gt;
   * &lt;li&gt;1) given dateTimeColumnValueMS = 1498892400000 and format=1:HOURS:EPOCH,
   * dateTimeSpec.fromMillis(1498892400000) = 416359 (i.e. dateTimeColumnValueMS/(1000*60*60))&lt;/li&gt;
   * &lt;li&gt;2) given dateTimeColumnValueMS = 1498892400000 and format=5:MINUTES:EPOCH,
   * dateTimeSpec.fromMillis(1498892400000) = 4996308 (i.e. timeColumnValueMS/(1000*60*5))&lt;/li&gt;
   * &lt;li&gt;3) given dateTimeColumnValueMS = 1498892400000 and
   * format=1:DAYS:SIMPLE_DATE_FORMAT:yyyyMMdd, dateTimeSpec.fromMillis(1498892400000) = 20170701&lt;/li&gt;
   * &lt;/ul&gt;
   * &lt;/ul&gt;
   * @param dateTimeColumnValueMS
   * @param toFormat - the format in which to convert the millis value
   * @param type - type of return value (can be int/long or string depending on time format)
   * @return dateTime column value in dateTimeFieldSpec
   */
  public &lt;T extends Object&gt; T fromMillisToFormat(Long dateTimeColumnValueMS, Class&lt;T&gt; type) {
<span class="fc" id="L160">    Preconditions.checkNotNull(dateTimeColumnValueMS);</span>

<span class="fc" id="L162">    Object dateTimeColumnValue = null;</span>

<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (_patternSpec.getTimeFormat().equals(TimeFormat.EPOCH)) {</span>
<span class="fc" id="L165">      dateTimeColumnValue = _unitSpec.getTimeUnit().convert(dateTimeColumnValueMS, TimeUnit.MILLISECONDS) / _size;</span>
    } else {
<span class="fc" id="L167">      dateTimeColumnValue = _patternSpec.getDateTimeFormatter().print(dateTimeColumnValueMS);</span>
    }
<span class="fc" id="L169">    return type.cast(dateTimeColumnValue);</span>
  }

  /**
   * &lt;ul&gt;
   * &lt;li&gt;Convert a time value in a format, to millis.
   * This method should not do validation of outputGranularity.
   * The validation should be handled by caller using {@link #isValidFormat(String)}&lt;/li&gt;
   * &lt;ul&gt;
   * &lt;li&gt;1) given dateTimeColumnValue = 416359 and format=1:HOURS:EPOCH
   * dateTimeSpec.toMillis(416359) = 1498892400000 (i.e. timeColumnValue*60*60*1000)&lt;/li&gt;
   * &lt;li&gt;2) given dateTimeColumnValue = 4996308 and format=5:MINUTES:EPOCH
   * dateTimeSpec.toMillis(4996308) = 1498892400000 (i.e. timeColumnValue*5*60*1000)&lt;/li&gt;
   * &lt;li&gt;3) given dateTimeColumnValue = 20170701 and format=1:DAYS:SIMPLE_DATE_FORMAT:yyyyMMdd
   * dateTimeSpec.toMillis(20170701) = 1498892400000&lt;/li&gt;
   * &lt;/ul&gt;
   * &lt;ul&gt;
   * @param dateTimeColumnValue - datetime Column value to convert to millis
   * @param fromFormat - the format in which the date time column value is expressed
   * @return datetime value in millis
   */
  public Long fromFormatToMillis(Object dateTimeColumnValue) {
<span class="fc" id="L191">    Preconditions.checkNotNull(dateTimeColumnValue);</span>

<span class="fc" id="L193">    Long timeColumnValueMS = 0L;</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (_patternSpec.getTimeFormat().equals(TimeFormat.EPOCH)) {</span>
<span class="fc" id="L196">      timeColumnValueMS = TimeUnit.MILLISECONDS.convert((Long) dateTimeColumnValue * _size, _unitSpec.getTimeUnit());</span>
    } else {
<span class="fc" id="L198">      timeColumnValueMS = _patternSpec.getDateTimeFormatter().parseMillis(String.valueOf(dateTimeColumnValue));</span>
    }

<span class="fc" id="L201">    return timeColumnValueMS;</span>
  }

  public static boolean isValidFormat(String format) {
<span class="fc" id="L205">    Preconditions.checkNotNull(format);</span>

<span class="fc" id="L207">    String[] formatTokens = format.split(COLON_SEPARATOR, MAX_FORMAT_TOKENS);</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">    Preconditions.checkArgument(formatTokens.length == MIN_FORMAT_TOKENS || formatTokens.length == MAX_FORMAT_TOKENS,</span>
        FORMAT_TOKENS_ERROR_STR);

<span class="fc" id="L211">    Preconditions.checkArgument(formatTokens[FORMAT_SIZE_POSITION].matches(NUMBER_REGEX), FORMAT_PATTERN_ERROR_STR);</span>
<span class="fc" id="L212">    Preconditions.checkArgument(DateTimeFormatUnitSpec.isValidUnitSpec(formatTokens[FORMAT_UNIT_POSITION]));</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">    if (formatTokens.length == MIN_FORMAT_TOKENS) {</span>
<span class="fc" id="L214">      Preconditions.checkArgument(formatTokens[FORMAT_TIMEFORMAT_POSITION].equals(TimeFormat.EPOCH.toString()),</span>
          TIME_FORMAT_ERROR_STR);
    } else {
<span class="fc" id="L217">      Preconditions.checkArgument(</span>
          formatTokens[FORMAT_TIMEFORMAT_POSITION].equals(TimeFormat.SIMPLE_DATE_FORMAT.toString()),
          TIME_FORMAT_ERROR_STR);
    }
<span class="fc" id="L221">    return true;</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">    if (EqualityUtils.isSameReference(this, o)) {</span>
<span class="nc" id="L227">      return true;</span>
    }

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    if (EqualityUtils.isNullOrNotSameClass(this, o)) {</span>
<span class="nc" id="L231">      return false;</span>
    }

<span class="fc" id="L234">    DateTimeFormatSpec that = (DateTimeFormatSpec) o;</span>

<span class="pc bpc" id="L236" title="4 of 8 branches missed.">    return EqualityUtils.isEqual(_size, that._size) &amp;&amp;</span>
        EqualityUtils.isEqual(_format, that._format) &amp;&amp;
        EqualityUtils.isEqual(_unitSpec, that._unitSpec) &amp;&amp;
        EqualityUtils.isEqual(_patternSpec, that._patternSpec);
  }

  @Override
  public int hashCode() {
<span class="nc" id="L244">    int result = EqualityUtils.hashCodeOf(_format);</span>
<span class="nc" id="L245">    result = EqualityUtils.hashCodeOf(result, _size);</span>
<span class="nc" id="L246">    result = EqualityUtils.hashCodeOf(result, _unitSpec);</span>
<span class="nc" id="L247">    result = EqualityUtils.hashCodeOf(result, _patternSpec);</span>
<span class="nc" id="L248">    return result;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L253">    return &quot;DateTimeFormatSpec{&quot; + &quot;_format='&quot; + _format + '\'' + &quot;, _size=&quot; + _size + &quot;, _unitSpec=&quot; + _unitSpec</span>
        + &quot;, _patternSpec=&quot; + _patternSpec + '}';
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>