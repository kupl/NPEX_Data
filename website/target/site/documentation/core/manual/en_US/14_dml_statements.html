<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DML statements</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#dml-statements">DML statements</a>
<ul class="sectlevel2">
<li><a href="#delete-statement">DELETE statement</a></li>
<li><a href="#delete-collection-statement">DELETE collection statement</a></li>
<li><a href="#update-statement">UPDATE statement</a></li>
<li><a href="#update-collection-statement">UPDATE collection statement</a></li>
<li><a href="#insert-select-statement">INSERT-SELECT statement</a></li>
<li><a href="#insert-select-collection-statement">INSERT-SELECT collection statement</a></li>
<li><a href="#cte-support">CTE support</a></li>
<li><a href="#returning-clause-support">RETURNING clause support</a></li>
<li><a href="#anchor-dml-dbms-compatibility">DBMS compatibility</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="dml-statements"><a class="anchor" href="#dml-statements"></a>DML statements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next to the support for <code>SELECT</code> statements, {projectname} also has support for</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>INSERT &#8230;&#8203; SELECT</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Apart from support for DML for JPA entity types, there is also support for DML for entity collections.
The construction of query builders for such statements works through the <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a> API.</p>
</div>
<div class="sect2">
<h3 id="delete-statement"><a class="anchor" href="#delete-statement"></a>DELETE statement</h3>
<div class="paragraph">
<p>The <code>DELETE</code> statement deletes entities that satisfy the <code>WHERE</code> clause of the statement.
A delete builder can be created via <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html#delete(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.delete()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">DeleteCriteriaBuilder&lt;Cat&gt; cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").isNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE FROM Cat cat
WHERE cat.name IS NULL</pre>
</div>
</div>
<div class="paragraph">
<p>You can immediately execute the query by calling <a href="{core_jdoc}/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a>
or create a JPA <code>Query</code> by calling <a href="{core_jdoc}/persistence/Executable.html#getQuery()"><code>getQuery()</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since a <code>DELETE</code> statement can&#8217;t have joins, implicit joins generated by deep path expressions are disallowed. Use an <code>EXISTS</code> subquery if you need to join relations.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently you can&#8217;t make use of advanced SQL features like CTEs when having a polymorphic <code>DELETE</code> except for single table inheritance. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/345">#345</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If your DBMS supports it, cascading deletes will be implemented as CTEs when deleting entities through this API.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="delete-collection-statement"><a class="anchor" href="#delete-collection-statement"></a>DELETE collection statement</h3>
<div class="paragraph">
<p>The <code>DELETE</code> collection statement deletes collection entries of entities that satisfy the <code>WHERE</code> clause of the statement.
A collection delete builder can be created via <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html#deleteCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.deleteCollection()</code></a>.
The statement only works on collections that have a join or collection table.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">DeleteCriteriaBuilder&lt;Cat&gt; cb = cbf.deleteCollection(em, Cat.class, "kittens", "cat")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("cat.id").eqExpression("subCat.id")
        .where("subCat.name").isNull()
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>The alias <code>cat</code> or in general, an delete collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source id i.e. <code>cat.id</code></p>
</li>
<li>
<p>The target id i.e. <code>cat.kittens.id</code></p>
</li>
<li>
<p>The collection index/key i.e. <code>KEY(cat.kittens)</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE FROM Cat(kittens) cat
WHERE EXISTS(
    SELECT 1 FROM Cat subCat
    WHERE cat.id = subCat.id
      AND cat.name IS NULL
)</pre>
</div>
</div>
<div class="paragraph">
<p>You can immediately execute the query by calling <a href="{core_jdoc}/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a>
or create a JPA <code>Query</code> by calling <a href="{core_jdoc}/persistence/Executable.html#getQuery()"><code>getQuery()</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="update-statement"><a class="anchor" href="#update-statement"></a>UPDATE statement</h3>
<div class="paragraph">
<p>The <code>UPDATE</code> statement updates attributes as specified in the <code>SET</code> clause on entities that satisfy the <code>WHERE</code> clause of the statement.
An update builder can be created via <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html#update(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.update()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("name").isNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name IS NULL</pre>
</div>
</div>
<div class="paragraph">
<p>There are multiple <code>set()</code> variants to be able to cover all possible expressions.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String,%20java.lang.Object)"><code>set(String, Object)</code></a></dt>
<dd>
<p>Set the attribute to the given value. This will create an implicit parameter expression and set the value.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .set("name", "Billy2")
    .where("name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = :param_1
WHERE cat.name = :param_2</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String)"><code>set(String)</code></a></dt>
<dd>
<p>Starts a subquery builder for the attribute.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("cat.name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#setExpression(java.lang.String,%20java.lang.String)"><code>setExpression(String, String)</code></a></dt>
<dd>
<p>Uses the given expression for the assignment to the attribute.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .setExpression("name", "UPPER(name)")
    .where("cat.name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#setSubqueries(java.lang.String,%20java.lang.String)"><code>setSubqueries(String, String)</code></a></dt>
<dd>
<p>Starts a subquery builder capable of handling multiple subqueries and assigns the given <code>expression</code> to the attribute.
Subqueries are started with <code>with(String subqueryAlias)</code> and aliases occurring in the expression will be replaced by the respective subquery expressions.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .setSubqueries("name", "CONCAT(ownerSubquery, ' the cat'")
        .with("ownerSubquery")
            .from(Person.class, "p")
            .where("p").eqExpression("cat.owner")
            .select("p.name")
        .end()
    .end()
    .where("cat.name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = CONCAT((
    SELECT p.name
    FROM Person p
    WHERE p = cat.owner
), '''s cat')
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently there is no possibility to do a <code>VERSIONED</code> update like you could do with e.g. Hibernate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can immediately execute the query by calling <a href="{core_jdoc}/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a>
or create a JPA <code>Query</code> by calling <a href="{core_jdoc}/persistence/Executable.html#getQuery()"><code>getQuery()</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since an <code>UPDATE</code> statement can&#8217;t have joins, implicit joins generated by deep path expressions are disallowed. Use an <code>EXISTS</code> subquery if you need to join relations in the <code>WHERE</code> clause or a scalar subquery if you need joins for the <code>SET</code> clause.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently you can&#8217;t make use of advanced SQL features like CTEs when having a polymorphic <code>UPDATE</code> except for single table inheritance. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/345">#345</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="update-collection-statement"><a class="anchor" href="#update-collection-statement"></a>UPDATE collection statement</h3>
<div class="paragraph">
<p>The <code>UPDATE</code> collection statement updates attributes as specified in the <code>SET</code> clause on entries of a collection of entities that satisfy the <code>WHERE</code> clause of the statement.
A collection update builder can be created via <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html#updateCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.updateCollection()</code></a>.
The statement only works on collections that have a join or collection table.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.updateCollection(em, Cat.class, "kittens", "cat")
    .set("cat.id", 2)
    .where("cat.id").eq(1);</pre>
</div>
</div>
<div class="paragraph">
<p>The alias <code>cat</code> or in general, an update collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source id i.e. <code>cat.id</code></p>
</li>
<li>
<p>The target id i.e. <code>cat.kittens.id</code></p>
</li>
<li>
<p>The collection index/key i.e. <code>KEY(cat.kittens)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The logical SQL for this <em>re-parenting query</em> looks like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat(kittens) cat
SET cat.id = :param_1
WHERE cat.id = :param_2</pre>
</div>
</div>
<div class="paragraph">
<p>This will cause all kittens that previously were associated with the cat with id 1 now to be the kittens of the cat with id 2.</p>
</div>
</div>
<div class="sect2">
<h3 id="insert-select-statement"><a class="anchor" href="#insert-select-statement"></a>INSERT-SELECT statement</h3>
<div class="paragraph">
<p>The <code>INSERT-SELECT</code> statement allows to create new entities based on result of a <code>SELECT</code> query.
An insert builder can be created via <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html#insert(javax.persistence.EntityManager,%20java.lang.Class)"><code>CriteriaBuilderFactory.insert()</code></a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This feature is currently only supported with Hibernate!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s consider a simple entity class for <code>INSERT</code> statement examples</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
public class Pet {

    @Id
    @GeneratedValue
    private Long id;
    @ManyToOne(optional = false)
    private Cat cat;
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">InsertCriteriaBuilder&lt;Cat&gt; cb = cbf.insert(em, Pet.class)
    .from(Cat.class, "c")
    .bind("cat").select("c")
    .where("owner").isNotNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">INSERT INTO Pet(cat)
SELECT c
FROM Cat c
WHERE c.owner IS NOT NULL</pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="{core_jdoc}/persistence/BaseInsertCriteriaBuilder.html#bind(java.lang.String)"><code>bind()</code></a> method allows to bind any select expression to an attribute of the <code>Pet</code> entity.
You can also bind values directly with <a href="{core_jdoc}/persistence/BaseInsertCriteriaBuilder.html#bind(java.lang.String,%20java.lang.Object)"><code>bind(String, Object)</code></a> if you want.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate 4.2 does not support parameters in the <code>SELECT</code> clause, so you will have to render values as literals instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see, we didn&#8217;t specify the <code>id</code> attribute. This is because it&#8217;s value is going to be generated by the database.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using Hibernate with embedded ids, you <strong>must</strong> map all the columns as <strong>basic values</strong>(no relations) directly into the entity itself, otherwise you won&#8217;t be able to assign a value to the attributes/columns.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When using Oracle, generated identifiers currently don&#8217;t work. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/306">#306</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="insert-select-collection-statement"><a class="anchor" href="#insert-select-collection-statement"></a>INSERT-SELECT collection statement</h3>
<div class="paragraph">
<p>The <code>INSERT-SELECT</code> collection statement inserts new collection entries.
A collection insert builder can be created via <a href="{core_jdoc}/persistence/CriteriaBuilderFactory.html#insertCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.insertCollection()</code></a>.
The statement only works on collections that have a join or collection table.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">InsertCriteriaBuilder&lt;Cat&gt; cb = cbf.insertCollection(em, Cat.class, "kittens", "cat")
    .from(Cat.class, "c")
    .bind("cat.id", 2)
    .bind("cat.kittens.id").select("c.kittens.id)
    .where("c.id").eq(1);</pre>
</div>
</div>
<div class="paragraph">
<p>The alias <code>cat</code> or in general, an insert collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source id i.e. <code>cat.id</code></p>
</li>
<li>
<p>The target id i.e. <code>cat.kittens.id</code></p>
</li>
<li>
<p>The collection index/key i.e. <code>KEY(cat.kittens)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The logical SQL for this <em>kittens copying query</em> looks like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">INSERT INTO Cat.kittens(id, _collection.id)
SELECT :param_1, kittens_1.id
FROM Cat c
LEFT JOIN c.kittens kittens_1
WHERE c.id = :param_2</pre>
</div>
</div>
<div class="paragraph">
<p>This will copy all kittens that are associated with the cat with id 1 to the kittens of the cat with id 2.</p>
</div>
</div>
<div class="sect2">
<h3 id="cte-support"><a class="anchor" href="#cte-support"></a>CTE support</h3>
<div class="paragraph">
<p>If the underlying DBMS supports the use of CTEs on <em>modification</em> statements, you can make use of those by defining them via <a href="{core_jdoc}/persistence/CTEBuilder.html#with(java.lang.Class)"><code>with()</code></a>.
For further information on this, check out the <a href="#ctes">CTE chapter</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="returning-clause-support"><a class="anchor" href="#returning-clause-support"></a>RETURNING clause support</h3>
<div class="paragraph">
<p>The <code>RETURNING</code> clause allows to return values to the client based on the modified entities of a DML statement.
Every DML statement can return any attributes of the entities that the statement modified.</p>
</div>
<div class="paragraph">
<p>All query builders for DML statements provide <a href="{core_jdoc}/persistence/ModificationCriteriaBuilder.html#getWithReturningQuery(java.lang.String,%20java.lang.Class)"><code>getWithReturningQuery()</code></a> variants
for creating a JPA <code>TypedQuery</code> from specifiable attributes which should be <em>returned</em> for modified entities.</p>
</div>
<div class="paragraph">
<p>The <code>TypedQuery</code> instance always returns a single <code>ReturningResult</code>. Calling <code>getResultList()</code> will just wrap the result of <code>getSingleResult()</code> in a list.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although the builder returns a <code>TypedQuery</code> which normally doesn&#8217;t require a transaction, you have to execute such a query within an active transaction since it actually modifies entities.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For every <code>getWithReturningQuery()</code> variant, there exists a <code>executeWithReturning()</code> variant that can be used as a short hand for <code>getWithReturningQuery().getSingleResult()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>ReturningResult</code> basically gives you access to the update count via <a href="{core_jdoc}/persistence/ReturningResult.html#getUpdateCount()"><code>getUpdateCount()</code></a>
and a result list, representing the attributes of modified entities that were requested to be returned, via <a href="{core_jdoc}/persistence/ReturningResult.html#getResultList()"><code>getResultList()</code></a>.
In addition to that, it also offers access to the <em>last returned result</em> via <a href="{core_jdoc}/persistence/ReturningResult.html#getLastResult()"><code>getLastResult()</code></a>, but this might get removed in the future.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As you will see in the <a href="#updatable-ctes">next chapter</a>, on some DBMS you can even <em>pipe</em> data returned by DML into other queries.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following examples will show how the different <code>executeWithReturning()</code> variants can be used.</p>
</div>
<div class="sect3">
<h4 id="returning-from-delete-statement"><a class="anchor" href="#returning-from-delete-statement"></a>RETURNING from DELETE statement</h4>
<div class="paragraph">
<p>Let&#8217;s see how we can retrieve the names of cats that have been deleted.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">DeleteCriteriaBuilder&lt;Cat&gt; cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").like().value("Billy%").noEscape();
ReturningResult&lt;String&gt; result = cb.executeWithReturning("name", String.class);
List&lt;String&gt; names = result.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Make sure your DBMS supports returning non-generated columns in the <a href="#anchor-dml-dbms-compatibility">DBMS compatibility matrix</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE FROM Cat cat
WHERE cat.name LIKE :param_1
RETURNING name</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="returning-from-update-statement"><a class="anchor" href="#returning-from-update-statement"></a>RETURNING from UPDATE statement</h4>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .setExpression("cat.name", "UPPER(cat.name)")
    .where("cat.name").like().value("Billy%").noEscape();
ReturningResult&lt;Tuple&gt; result = cb.executeWithReturning("id", "name");
List&lt;Tuple&gt; updatedCatIdAndNames = result.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Also make sure your DBMS supports returning multiple modified rows in the <a href="#anchor-dml-dbms-compatibility">DBMS compatibility matrix</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name LIKE :param_1
RETURNING id, name</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="returning-from-insert-select-statement"><a class="anchor" href="#returning-from-insert-select-statement"></a>RETURNING from INSERT-SELECT statement</h4>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">InsertCriteriaBuilder&lt;Cat&gt; cb = cbf.insert(em, Pet.class)
    .from(Cat.class, "c")
    .bind("cat").select("c")
    .where("owner").isNotNull();
ReturningResult&lt;Pet&gt; result = cb.executeWithReturning(new ReturningObjectBuilder&lt;Pet&gt;() {
    @Override
    public &lt;X extends ReturningBuilder&lt;X&gt;&gt; void applyReturning(X returningBuilder) {
        returningBuilder.returning("id");
    }

    @Override
    public Pet build(Object[] tuple) {
        return new Pet((Long) tuple[0]);
    }

    @Override
    public List&lt;T&gt; buildList(List&lt;T&gt; list) {
        return list;
    }
});
List&lt;Pet&gt; createdPetIds = result.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Although not very useful, this will return pet objects with the ids of the inserted pet entities set.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">INSERT INTO Pet(cat)
SELECT c
FROM Cat c
WHERE c.owner IS NOT NULL
RETURNING id</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-dml-dbms-compatibility"><a class="anchor" href="#anchor-dml-dbms-compatibility"></a>DBMS compatibility</h3>
<div class="paragraph">
<p>Although it might be possible to retrieve other columns based on identifiers for DBMS that don&#8217;t support <code>RETURNING</code> all columns natively, there is no emulation implemented yet.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>DBMS</strong></th>
<th class="tableblock halign-left valign-top">RETURNING generated</th>
<th class="tableblock halign-left valign-top">RETURNING multiple rows</th>
<th class="tableblock halign-left valign-top">RETURNING all</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL Server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-04 13:32:35 KST
</div>
</div>
</body>
</html>