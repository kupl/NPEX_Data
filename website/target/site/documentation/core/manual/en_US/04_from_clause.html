<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>From clause</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#from-clause">From clause</a>
<ul class="sectlevel2">
<li><a href="#joins">Joins</a></li>
<li><a href="#on-clause">On clause</a></li>
<li><a href="#anchor-values-clause">VALUES clause</a></li>
<li><a href="#before-and-after-dml-in-ctes">Before and after DML in CTEs</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="from-clause"><a class="anchor" href="#from-clause"></a>From clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>FROM</code> clause contains the entities which should be queried.
Normally a query will have one root entity which is why {projectname} offers a convenient factory for creating queries that select the root entity.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class);</pre>
</div>
</div>
<div class="paragraph">
<p>The type <code>Cat</code> has multiple purposes in this case.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It defines the result type of the query</p>
</li>
<li>
<p>Creates an implicit query root with that type and the alias <em>cat</em></p>
</li>
<li>
<p>Implicitly selects <em>cat</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This implicit logic will help to avoid some boilerplate code in most of the cases.
The JPQL generated for such a simple query is just like you would expect</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>As soon as a query root is added via <code>from()</code>, the implicitly created query root is removed.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Person.class, "person")
    .select("person.kittens");</pre>
</div>
</div>
<div class="paragraph">
<p>In such a query, the type <code>Cat</code> only serves the purpose of defining the query result type.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT kittens_1
FROM Person person
LEFT JOIN person.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>Contrary to the described behavior, using the overload of the <code>create</code> method that allows to specify the alias for the query root will result in an explicit query root.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "myCat");</pre>
</div>
</div>
<div class="paragraph">
<p>This is essentially a shorthand for</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "myCat");</pre>
</div>
</div>
<div class="paragraph">
<p>A query can also have multiple root entities which are connected with the <code>,</code> operator that essentially has the semantics of a <code>CROSS JOIN</code>.
Beware that when having multiple root entities, path expression must use absolute paths.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "myCat")
    .select("name");</pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>name</code> in this case is interpreted as relative to the query root, so it is equivalent to <code>myCat.name</code>.
When having multiple query roots, the use of a relative path will lead to an exception saying that relative resolving is not allowed with multiple query roots!</p>
</div>
<div class="sect2">
<h3 id="joins"><a class="anchor" href="#joins"></a>Joins</h3>
<div class="paragraph">
<p>JPQL offers support for <code>CROSS</code>, <code>INNER</code>, <code>LEFT</code> and <code>RIGHT JOIN</code> which are all well supported by {projectname}.
In contrast to JPQL, {projectname} also has a notion of implicit/default and explicit joins which makes it very convenient to write queries as can be seen a few sections later.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>RIGHT JOIN</code> support is optional in JPA so we recommend not using it at all.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In addition to joins on mapped relations, {projectname} also offers support for unrelated or entity joins offered by all major JPA providers.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="implicit-joins"><a class="anchor" href="#implicit-joins"></a>Implicit joins</h4>
<div class="paragraph">
<p>An implicit or default join is a special join that can be referred to by</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>an absolute path from a root entity to an association</p>
</li>
<li>
<p>alias if an explicit alias has been defined via <a href="{core_jdoc}/persistence/FromBuilder.html#joinDefault(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>joinDefault()</code></a> means</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A path is considered <em>absolute</em> also if it is relative to the query root
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following query builder will create an implicit join for the path <code>kittens</code> when inspecting the select clause and reuse that implicit join in the where clause because of the use of an absolute path.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("kittens.age")
    .where("kittens.age").gt(1);</pre>
</div>
</div>
<div class="paragraph">
<p>This will result in the following JPQL query</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT kittens_1.age
FROM Cat cat
LEFT JOIN cat.kittens kittens_1
WHERE kittens_1.age &gt; 1</pre>
</div>
</div>
<div class="paragraph">
<p>A relation dereference like <code>alias.relation.property</code> will always result in a JOIN being added for <code>alias.relation</code>.
The exception to that is when the accessed property is the identifier property of the type of <code>relation</code> and that identifier is owned by <code>alias</code> i.e. the column is contained in the owner&#8217;s table.
If the property is the identifier and the <code>JpaProvider</code> supports <a href="{core_jdoc}/persistence/spi/JpaProvider.html#supportsSingleValuedAssociationIdExpressions()">optimized id access</a>,
no join is generated but instead the expression is rendered as it is <code>alias.relation.identifier</code>.</p>
</div>
<div class="sect4">
<h5 id="model-awareness"><a class="anchor" href="#model-awareness"></a>Model awareness</h5>
<div class="paragraph">
<p>Implicit joins are a result of a path dereference or explicit fetching. A path dereference can happen in any place where an expression is expected.
An explicit fetch can be invoked on <a href="{core_jdoc}/persistence/FullQueryBuilder.html"><code>FullQueryBuilder</code></a> instances which is the top type for
<a href="{core_jdoc}/persistence/CriteriaBuilder.html"><code>CriteriaBuilder</code></a> and <a href="{core_jdoc}/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a>.</p>
</div>
<div class="paragraph">
<p>Every implicit join will result in a so called "model-aware" join. The model-awareness of a join is responsible for determining the join type to use.
Generally it is a good intuition to think of a model-aware join to always produce results, thus never restricting the result set but only extending it.
A model-aware join currently decides between <code>INNER</code> and <code>LEFT JOIN</code>. The <code>INNER JOIN</code> is only used if</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The parent join is an <code>INNER JOIN</code></p>
</li>
<li>
<p>The relation is non-optional e.g. the <code>optional</code> attribute of a <code>@ManyToOne</code> or <code>@OneToOne</code> is false</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is different from how JPQL path expressions are normally interpreted but will result in a more natural output.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you aren&#8217;t happy with the join types you can override them and even specify an alias for implicit joins via the
<a href="{core_jdoc}/persistence/FromBuilder.html#joinDefault(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>joinDefault</code></a> method and variants.
Consider the following example for illustration purposes of the implicit joins.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("kittens.age")
    .where("kittens.age").gt(1)
    .innerJoinDefault("kittens", "kitty");</pre>
</div>
</div>
<div class="paragraph">
<p>The builder first creates an implicit join for <code>kittens</code> with the join type <code>LEFT JOIN</code> because a Collection can never be non-optional.
If you just had the <code>SELECT</code> clause, a <code>NULL</code> value would be produced for cats that don&#8217;t have kittens.
But in this case the <code>WHERE</code> clause filters out these cats, because any comparison with <code>NULL</code> will result in <code>UNKNOWN</code> and thus <code>FALSE</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Null-aware predicates like <code>IS NULL</code> are obviously an exception to this.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The last statement will take the default/implicit join for the path <code>kittens</code>, set the join type to <code>INNER</code> and the alias to <code>kitty</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Although the generated aliases for implicit joins are deterministic, they might change over time so you should never use them to refer to implicit joins.
Always use the full path to the join relation or define an alias and use that instead!
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="explicit-joins"><a class="anchor" href="#explicit-joins"></a>Explicit joins</h4>
<div class="paragraph">
<p>Explicit joins are different from implicit/default joins in a sense that they are only accessible through their alias. You can have only one default join which is identified by it&#8217;s absolute path,
but multiple explicit joins as these are identified by their alias. This means that you can also join a relation multiple times with different aliases.</p>
</div>
<div class="paragraph">
<p>You can create explicit joins with the <a href="{core_doc]/persistence/FromBuilder.html#join(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>join()</code></a> method and variants.
The following shows explicit and implicit joins used together.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("kittens.age")
    .where("kitty.age").gt(1)
    .innerJoin("kittens", "kitty");</pre>
</div>
</div>
<div class="paragraph">
<p>This query will in fact create two joins. One for the explicitly inner joined <code>kittens</code> with the alias <code>kitty</code> and another for the implicitly left joined <code>kittens</code> used in the <code>SELECT</code> clause.
The resulting JPQL looks like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT kittens_1.age
FROM Cat cat
INNER JOIN cat.kittens kitty
LEFT JOIN cat.kittens kittens_1
WHERE kitty.age &gt; 1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fetched-joins"><a class="anchor" href="#fetched-joins"></a>Fetched joins</h4>
<div class="paragraph">
<p>Analogous to the <code>FETCH</code> keyword in JPQL, you can specify for every join node of a <a href="{core_jdoc}/persistence/FullQueryBuilder.html"><code>FullQueryBuilder</code></a> if it should be fetched.
Every <a href="{core_jdoc}/persistence/FromBuilder.html#join(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>join()</code></a> method variant comes with a partner method,
that does fetching for the joined path. In addition to that, there is also a simple <a href="{core_jdoc}/persistence/FullQueryBuilder.html#fetch(java.lang.String&#8230;&#8203;)"><code>fetch()</code></a> method which can be provided with absolute paths to relations.
These relations are then implicit/default join fetched, i.e. a default join node with fetching enabled is created for every relation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can make use of deep paths like <code>kittens.kittens</code> which will result in fetch joining two levels of kittens.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class)
    .leftJoinFetch("father", "dad")
    .whereOr()
        .where("dad").isNull()
        .where("dad.age").gt(1)
    .endOr()
    .fetch("kittens.kittens", "mother");</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>father</code> relation is left join fetched and given an alias which is then used in the <code>WHERE</code> clause. Two levels of <code>kittens</code> and the <code>mother</code> relation are join fetched.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.father dad
LEFT JOIN FETCH cat.kittens kittens_1
LEFT JOIN FETCH kittens_1.kittens kittens_2
LEFT JOIN FETCH cat.mother mother_1
WHERE dad IS NULL
   OR dad.age &gt; 1</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Although the JPA spec does not specifically allow aliasing fetch joins, every major JPA provider supports this.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When doing a scalar select instead of a query root select, {projectname} automatically adapts the fetches to the new fetch owners.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class)
    .fetch("father.kittens")
    .select("father");</pre>
</div>
</div>
<div class="paragraph">
<p>In this case we fetch the <code>father</code> relation and the <code>kittens</code> of the <code>father</code>. By also selecting the <code>father</code> relation, the fetch owner changes from the query root to the <code>father</code>.
This has the effect, that the <code>father</code> is not fetch joined, as that would be invalid.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT father_1
FROM Cat cat
LEFT JOIN cat.father father_1
LEFT JOIN FETCH father_1.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="array-joins"><a class="anchor" href="#array-joins"></a>Array joins</h4>
<div class="paragraph">
<p>Array joins are an extension to the JPQL grammar which offer a convenient way to create joins with an <code>ON</code> clause condition.
An array join expression is a path expression followed by an opening bracket, the index expression and then the closing bracket e.g. <code>arrayBase[indexExpression]</code>.</p>
</div>
<div class="paragraph">
<p>The type of the <code>arrayBase</code> expression must be either an indexed <code>List</code> e.g. use an <code>@OrderColumn</code> or a <code>Map</code>.
In case of an indexed list, the type of the <code>indexExpression</code> must be numeric. For maps, the type must match the map key type as defined in the entity.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class)
    .select("localizedName[:language]")
    .where("localizedName[:language]").isNotNull();</pre>
</div>
</div>
<div class="paragraph">
<p>Such a query will result in the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT localizedName_language
FROM Cat cat
LEFT JOIN cat.localizedName localizedName_language
       ON KEY(localizedName_language) = :language
WHERE localizedName_language IS NOT NULL</pre>
</div>
</div>
<div class="paragraph">
<p>The relation <code>localizedName</code> is assumed to be a map of type <code>Map&lt;String, String&gt;</code> which maps a language code to a localized name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In case of array expressions, the generated implicit/default join node is identified not only by the absolute path, but also by the index expression.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="correlated-joins"><a class="anchor" href="#correlated-joins"></a>Correlated joins</h4>
<div class="paragraph">
<p>JPQL allows subqueries to refer to a relation based on a join alias of the outer query within the from clause, also known as correlated join.
A correlated join in {projectname} can be done when <a href="{core_jdoc}/persistence/SubqueryInitiator.html#from(java.lang.String)">initiating a subquery</a>
or be added as <a href="{core_jdoc}/persistence/BaseSubqueryBuilder.html#from(java.lang.String)">cross join</a> to an existing subquery builder.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "c")
    .selectSubquery()
        .from("c.kittens", "kitty")
        .select("COUNT(kitty.id)")
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>Such a query will result in the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    (
        SELECT COUNT(kitty.id)
        FROM c.kittens kitty
    )
FROM Cat c</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although JPA does not mandate the support for subqueries in the <code>SELECT</code> clause, every major JPA provider supports it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="anchor-entity-joins"><a class="anchor" href="#anchor-entity-joins"></a>Entity joins</h4>
<div class="paragraph">
<p>An entity join is a type of join for unrelated entities, in the sense that no JPA mapping is required to join the entities.
Entity joins are quite useful, especially when information from separate models(i.e. models that have no static dependency on each other) should be queried.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine a query that reports the count of people that are older than a cat for each cat</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "c")
    .leftJoinOn(Person.class, "p")
        .on("c.age").ltExpression("p.age")
    .end()
    .select("c.name")
    .select("COUNT(p.id)")
    .groupBy("c.id", "c.name");</pre>
</div>
</div>
<div class="paragraph">
<p>The JPQL representation looks just as expected</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT c.name, COUNT(p.id)
FROM Cat c
LEFT JOIN Person p
       ON c.age &lt; p.age
GROUP BY c.id, c.name</pre>
</div>
</div>
<div class="paragraph">
<p>Entity joins normally <a href="{core_jdoc}/persistence/FromBuilder.html#joinOn(java.lang.String,%20java.lang.Class,%20java.lang.String,%20com.blazebit.persistence.JoinType)">require a base alias</a>
but <a href="{core_jdoc}/persistence/FromBuilder.html#joinOn(java.lang.Class,%20java.lang.String,%20com.blazebit.persistence.JoinType)">default to the query root</a> when only a single query root is available.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>INNER</code> entity joins don&#8217;t need support from the JPA provider because these are rewritten to a JPQL compliant <code>CROSS JOIN</code> if necessary.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="on-clause"><a class="anchor" href="#on-clause"></a>On clause</h3>
<div class="paragraph">
<p>The <code>ON</code> clause is a filter predicate similar to the <code>WHERE</code> clause, but is evaluated while joining to restrict the joined elements.
In case of <code>INNER</code> joins the <code>ON</code> clause has the same effect as when putting the predicate into the <code>WHERE</code> clause.
However <code>LEFT</code> joins won&#8217;t filter out objects from the source even if the predicate doesn&#8217;t match any joinable object, but instead will produce a <code>NULL</code> value for the joined element.</p>
</div>
<div class="paragraph">
<p>The <code>ON</code> clause is used when using array joins to restrict the key of a join to the index expression.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Since the <code>ON</code> clause is only supported as of JPA 2.1, the usage with JPA 2.0 providers that have no equivalent vendor extension will fail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ON</code> clause can be constructed by setting a JPQL predicate expression with <code>setOnExpression()</code> or by using the <a href="#predicate builder&gt;">Predicate Builder API</a>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">setOnExpression()</th>
<th class="tableblock halign-left valign-top">Predicate Builder API</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb =
    cbf.create(em, String.class)
    .from(Cat.class)
    .select("l10nName")
    .leftJoinOn("localizedName", "l10nName")
      .setOnExpression("KEY(l10nName) = :lang")
    .where("l10nName").isNotNull();</pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb =
    cbf.create(em, String.class)
    .from(Cat.class)
    .select("l10nName")
    .leftJoinOn("localizedName", "l10nName")
        .on("KEY(l10nName)").eq(":lang")
    .end()
    .where("l10nName").isNotNull();</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The resulting JPQL looks as expected</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT localizedNameForLanguage
FROM Cat cat
LEFT JOIN cat.localizedName l10nName
       ON KEY(l10nName) = :lang
WHERE l10nName IS NOT NULL</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-values-clause"><a class="anchor" href="#anchor-values-clause"></a>VALUES clause</h3>
<div class="paragraph">
<p>The <code>VALUES</code> clause is similar to the SQL <code>VALUES</code> clause in the sense that it allows to define a temporary set of objects for querying.
There are 3 different types of values for which a <code>VALUES</code> clause can be created</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic values (Integer, String, etc.)</p>
</li>
<li>
<p>Managed values (Entities, Embeddables, CTEs)</p>
</li>
<li>
<p>Identifiable values (Entities, CTEs)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For query caching reasons, a <code>VALUES</code> clause has a fixed number of elements. If you bind a collection that has a smaller size, the rest is filled up with <code>NULL</code> values which are filtered out by a <code>WHERE</code> clause.
Trying to bind a collection with a larger size will lead to an exception at bind time.</p>
</div>
<div class="paragraph">
<p>The <code>VALUES</code> clause is a feature that can be used for doing efficient batching. The number of elements can serve as batch size. Processing a collection iteratively and binding subsets to a query efficiently reuses query caches.
For one-shot or rarely executed queries it might not be necessary to implement batching.
In such cases use one of the <a href="{core_jdoc}/persistence/FromBuilder.html#fromValues(java.lang.Class,%20java.lang.String,%20java.util.Collection)">overloads</a> that use the collection size as number of elements.</p>
</div>
<div class="paragraph">
<p>The join alias that must be defined for a <code>VALUES</code> clause is reused as alias for the parameter to bind values.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .fromValues(String.class, "myValue", 10)
    .select("myValue.value")
    .setParameter("myValue", valueCollection);</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently it is not possible to use the <code>VALUES</code> when using parameters in the <code>SELECT</code> clause due to <a href="https://github.com/Blazebit/blaze-persistence/issues/305">#305</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For some cases it might be better to make use of <a href="#entity-functions">entity functions</a> instead of a <code>VALUES</code>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="basic-values"><a class="anchor" href="#basic-values"></a>Basic values</h4>
<div class="paragraph">
<p>The following basic value types are supported</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code></p>
</li>
<li>
<p><code>Byte</code></p>
</li>
<li>
<p><code>Short</code></p>
</li>
<li>
<p><code>Integer</code></p>
</li>
<li>
<p><code>Long</code></p>
</li>
<li>
<p><code>Float</code></p>
</li>
<li>
<p><code>Double</code></p>
</li>
<li>
<p><code>Character</code></p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p><code>BigInteger</code></p>
</li>
<li>
<p><code>BigDecimal</code></p>
</li>
<li>
<p><code>java.sql.Time</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to access the actual value in an expression, the <code>value</code> property of the alias for the <code>VALUES</code> clause has to be dereferenced.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Collection&lt;String&gt; valueCollection = Arrays.asList("value1", "value2");
CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .fromValues(String.class, "myValue", valueCollection)
    .select("myValue.value");</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting logical JPQL doesn&#8217;t include individual parameters, but specifies the count of the values. The alias of the values clause from item also represents the parameter name.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT TREAT_STRING(myValue.value)
FROM String(2 VALUES) myValue</pre>
</div>
</div>
<div class="paragraph">
<p>The use of <code>TREAT_STRING</code> as the name suggests, has the effect that the expression is treated like a string expression.
Behind the scenes, a type called <code>ValuesEntity</code> is used to be able to implement the VALUES clause.</p>
</div>
<div class="paragraph">
<p>For further information on <code>TREAT</code> functions, take a look at the <a href="#treat-functions">JPQL functions</a> chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="managed-values"><a class="anchor" href="#managed-values"></a>Managed values</h4>
<div class="paragraph">
<p>Managed values are objects of a JPA managed type i.e. entities or embeddables. A <code>VALUES</code> clause for such types will include <strong>all</strong> properties of that type,
so be careful when using this variant. For using only the <em>id</em> part of a managed type, take a look at the <a href="#identifiable-values">identifiable values</a> variant.
If using all properties of an entity or embeddable is not appropriate for you, you should consider creating a custom <a href="#ctes"><em>CTE entity</em></a> that covers only the subset of properties you are interested in
and finally convert your entity or embeddable object to that new type so it can be used with the <code>VALUES</code> clause.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Embeddable
class MyEmbeddable {
    private String property1;
    private String property2;
}</pre>
</div>
</div>
<div class="paragraph">
<p>The embeddable defines 2 properties and a <code>VALUES</code> query for objects of that type might look like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Collection&lt;MyEmbeddable&gt; valueCollection = ...
CriteriaBuilder&lt;MyEmbeddable&gt; cb = cbf.create(em, MyEmbeddable.class)
    .fromValues(MyEmbeddable.class, "myValue", valueCollection)
    .select("myValue");</pre>
</div>
</div>
<div class="paragraph">
<p>The JPQL for such a query looks roughly like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT myValue
FROM MyEmbeddable(1 VALUES) myValue</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiable-values"><a class="anchor" href="#identifiable-values"></a>Identifiable values</h4>
<div class="paragraph">
<p>Identifiable values are also objects of a JPA managed type, but restricted to identifiable managed types i.e. no embeddables.
Every entity and <a href="#ctes"><em>CTE entity</em></a> is an identifiable managed type and can thus be used in
<a href="{core_jdoc}/persistence/FromBuilder.html#fromIdentifiableValues(java.lang.Class,%20java.lang.String,%20java.util.Collection)"><code>fromIdentifiableValues()</code></a>.</p>
</div>
<div class="paragraph">
<p>The main difference to the <a href="{core_jdoc}/persistence/FromBuilder.html#fromValues(java.lang.Class,%20java.lang.String,%20java.util.Collection)">managed values variant</a>
is that only the identifier properties of the objects are bound instead of all properties.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Collection&lt;Cat&gt; valueCollection = ...
CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .fromIdentifiableValues(Cat.class, "cat", valueCollection)
    .select("cat.id");</pre>
</div>
</div>
<div class="paragraph">
<p>The JPQL for such a query looks roughly like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id
FROM Cat.id(1 VALUES) cat</pre>
</div>
</div>
<div class="paragraph">
<p>The values parameter "cat" will still expect instances of the type <code>Cat</code>, but will only bind the id attribute values.
This also works for embedded ids and access to the embedded values works just like expected, by dereferencing the embeddable further i.e. <code>alias.embeddable.property</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When using the identifiable values, only the id values are available for the query. Using any other property will lead to an exception.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="before-and-after-dml-in-ctes"><a class="anchor" href="#before-and-after-dml-in-ctes"></a>Before and after DML in CTEs</h3>
<div class="paragraph">
<p>When using <a href="#updatable-ctes">DML in CTEs</a> it depends on the DBMS what state a <code>FROM</code> element might give.
Normally this is not problematic as it is rarely necessary to do DML and a <code>SELECT</code> for the same entity in one query.
When it is necessary to do that, it is strongly advised to make use of <a href="{core_jdoc}/persistence/FromBuilder.html#fromOld(java.lang.Class)"><code>fromOld()</code></a>
or <a href="{core_jdoc}/persistence/FromBuilder.html#fromNew(java.lang.Class)"><code>fromNew()</code></a> to use the state before or after side-effects happen.</p>
</div>
<div class="paragraph">
<p>For example usage and further information, take a look into the <a href="#updatable-ctes">Updatable CTEs chapter</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>