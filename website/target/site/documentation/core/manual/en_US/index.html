<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="Christian Beikov, Blazebit">
<title>Blaze Persistence - Criteria API for JPA backends</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<h1>Blaze Persistence - Criteria API for JPA backends</h1>
<div class="details"><div class="author-wrapper">
<span id="author" class="author">Christian Beikov, Blazebit</span><br>
<span id="email" class="email"><a href="mailto:christian@blazebit.com">christian@blazebit.com</a></span></div><br>
<div class="author-wrapper"><span id="author2" class="author">Moritz Becker, Curecomp</span><br>
<span id="email2" class="email"><a href="mailto:moritz.becker@gmx.at">moritz.becker@gmx.at</a></span></div><br>
<span id="revnumber">1.2.0-SNAPSHOT</span>
<br>
<span class="copyright">Copyright (C) 2014 - 2018 Blazebit</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">Preface</a>
<ul class="sectlevel2">
<li><a href="#relation-to-jpa-and-implementations">Relation to JPA and implementations</a></li>
</ul>
</li>
<li><a href="#system-requirements">System requirements</a></li>
<li><a href="#getting-started">1. Getting started</a>
<ul class="sectlevel2">
<li><a href="#getting-started-setup">1.1. Setup</a></li>
<li><a href="#anchor-environment">1.2. Environments</a></li>
<li><a href="#supported-java-runtimes">1.3. Supported Java runtimes</a></li>
<li><a href="#supported-environments-libraries">1.4. Supported environments/libraries</a></li>
<li><a href="#first-criteria-query">1.5. First criteria query</a></li>
<li><a href="#getting-started-summary">1.6. Summary</a></li>
</ul>
</li>
<li><a href="#architecture">2. Architecture</a>
<ul class="sectlevel2">
<li><a href="#architecture-interfaces">2.1. Interfaces</a></li>
<li><a href="#architecture-query-building">2.2. Query building</a></li>
<li><a href="#architecture-jpa-provider-integration">2.3. JPA Provider Integration</a></li>
</ul>
</li>
<li><a href="#from-clause">3. From clause</a>
<ul class="sectlevel2">
<li><a href="#joins">3.1. Joins</a></li>
<li><a href="#on-clause">3.2. On clause</a></li>
<li><a href="#anchor-values-clause">3.3. VALUES clause</a></li>
<li><a href="#before-and-after-dml-in-ctes">3.4. Before and after DML in CTEs</a></li>
</ul>
</li>
<li><a href="#predicate-builder">4. Predicate Builder</a>
<ul class="sectlevel2">
<li><a href="#restriction-builder">4.1. Restriction Builder</a></li>
<li><a href="#anchor_predicate_builder_case_when">4.2. Case When Expression Builder</a></li>
</ul>
</li>
<li><a href="#where-clause">5. Where clause</a>
<ul class="sectlevel2">
<li><a href="#keyset-pagination-support">5.1. Keyset pagination support</a></li>
</ul>
</li>
<li><a href="#group-by-and-having-clause">6. Group by and having clause</a>
<ul class="sectlevel2">
<li><a href="#group-by">6.1. Group by</a></li>
<li><a href="#having-clause">6.2. Having clause</a></li>
</ul>
</li>
<li><a href="#anchor-order-by-clause">7. Order by clause</a></li>
<li><a href="#select-clause">8. Select clause</a>
<ul class="sectlevel2">
<li><a href="#distinct-support">8.1. Distinct support</a></li>
<li><a href="#tuple-select">8.2. Tuple select</a></li>
<li><a href="#anchor_select_case_when">8.3. Case expressions</a></li>
<li><a href="#subqueries">8.4. Subqueries</a></li>
<li><a href="#select-new-support">8.5. Select new support</a></li>
<li><a href="#object-builder">8.6. Object builder</a></li>
</ul>
</li>
<li><a href="#polymorphism">9. Polymorphism</a>
<ul class="sectlevel2">
<li><a href="#polymorphism-treat-limitations">9.1. Limitations</a></li>
<li><a href="#subtype-property-access">9.2. Subtype property access</a></li>
<li><a href="#subtype-relation-join">9.3. Subtype relation join</a></li>
<li><a href="#querying-non-managed-types">9.4. Querying non-managed types</a></li>
</ul>
</li>
<li><a href="#expressions">10. Expressions</a>
<ul class="sectlevel2">
<li><a href="#identification-variables">10.1. Identification variables</a></li>
<li><a href="#path-expressions">10.2. Path expressions</a></li>
<li><a href="#array-expressions">10.3. Array expressions</a></li>
<li><a href="#treat-expressions">10.4. Treat expressions</a></li>
<li><a href="#qualified-expressions">10.5. Qualified expressions</a></li>
<li><a href="#parameter-and-literal-expressions">10.6. Parameter and Literal expressions</a></li>
<li><a href="#arithmetic-expressions">10.7. Arithmetic expressions</a></li>
<li><a href="#function-expressions">10.8. Function expressions</a></li>
<li><a href="#subquery-expressions">10.9. Subquery expressions</a></li>
<li><a href="#nullif-expressions">10.10. Nullif expressions</a></li>
<li><a href="#coalesce-expressions">10.11. Coalesce expressions</a></li>
<li><a href="#case-expressions">10.12. Case expressions</a></li>
<li><a href="#predicate-expressions">10.13. Predicate expressions</a></li>
<li><a href="#relational-comparison-predicate">10.14. Relational comparison predicate</a></li>
<li><a href="#nullness-predicate">10.15. Nullness predicate</a></li>
<li><a href="#like-predicate">10.16. Like predicate</a></li>
<li><a href="#between-predicate">10.17. Between predicate</a></li>
<li><a href="#in-predicate">10.18. In predicate</a></li>
<li><a href="#exists-predicate">10.19. Exists predicate</a></li>
<li><a href="#empty-predicate">10.20. Empty predicate</a></li>
<li><a href="#member-of-predicate">10.21. Member-of predicate</a></li>
</ul>
</li>
<li><a href="#query-api">11. Query API</a>
<ul class="sectlevel2">
<li><a href="#parameter-binding">11.1. Parameter binding</a></li>
<li><a href="#query-properties">11.2. Query properties</a></li>
<li><a href="#query-result-caching">11.3. Query result caching</a></li>
<li><a href="#query-api-limitations">11.4. Limitations</a></li>
</ul>
</li>
<li><a href="#pagination">12. Pagination</a>
<ul class="sectlevel2">
<li><a href="#pagination-under-the-hood">12.1. Under the hood</a></li>
<li><a href="#anchor-offset-pagination">12.2. Offset pagination</a></li>
<li><a href="#anchor-keyset-pagination">12.3. Keyset pagination</a></li>
<li><a href="#anchor-navigate-entity-page">12.4. Navigate to entity page</a></li>
<li><a href="#pagination-limitations">12.5. Limitations</a></li>
</ul>
</li>
<li><a href="#dml-statements">13. DML statements</a>
<ul class="sectlevel2">
<li><a href="#delete-statement">13.1. DELETE statement</a></li>
<li><a href="#delete-collection-statement">13.2. DELETE collection statement</a></li>
<li><a href="#update-statement">13.3. UPDATE statement</a></li>
<li><a href="#update-collection-statement">13.4. UPDATE collection statement</a></li>
<li><a href="#insert-select-statement">13.5. INSERT-SELECT statement</a></li>
<li><a href="#insert-select-collection-statement">13.6. INSERT-SELECT collection statement</a></li>
<li><a href="#cte-support">13.7. CTE support</a></li>
<li><a href="#returning-clause-support">13.8. RETURNING clause support</a></li>
<li><a href="#anchor-dml-dbms-compatibility">13.9. DBMS compatibility</a></li>
</ul>
</li>
<li><a href="#ctes">14. CTEs</a>
<ul class="sectlevel2">
<li><a href="#cte-implementation-notes">14.1. Implementation notes</a></li>
<li><a href="#recursive-ctes">14.2. Recursive CTEs</a></li>
<li><a href="#updatable-ctes">14.3. Updatable CTEs</a></li>
<li><a href="#anchor-ctes-dbms-compatibility">14.4. DBMS compatibility</a></li>
</ul>
</li>
<li><a href="#set-operations">15. Set operations</a>
<ul class="sectlevel2">
<li><a href="#normal-set-operations">15.1. Normal set operations</a></li>
<li><a href="#anchor-set-operations-right-nesting">15.2. Right nested set operations</a></li>
<li><a href="#left-nested-set-operations">15.3. Left nested set operations</a></li>
<li><a href="#empty-nested-set-operations">15.4. Empty nested set operations</a></li>
<li><a href="#ordering-and-limiting-with-set-operations">15.5. Ordering and limiting with set operations</a></li>
<li><a href="#anchor-set-dbms-compatibility">15.6. DBMS compatibility</a></li>
</ul>
</li>
<li><a href="#entity-functions">16. Entity functions</a>
<ul class="sectlevel2">
<li><a href="#built-in-entity-functions">16.1. Built-in entity functions</a></li>
<li><a href="#custom-entity-functions">16.2. Custom entity functions</a></li>
</ul>
</li>
<li><a href="#jpql-functions">17. JPQL functions</a>
<ul class="sectlevel2">
<li><a href="#special-built-in-functions">17.1. Special built-in functions</a></li>
<li><a href="#built-in-functions">17.2. Built-in functions</a></li>
<li><a href="#custom-jpql-functions">17.3. Custom JPQL functions</a></li>
<li><a href="#custom-jpql-macros">17.4. Custom JPQL macros</a></li>
</ul>
</li>
<li><a href="#customize-dbms-dialect">18. Customize DBMS dialect</a>
<ul class="sectlevel2">
<li><a href="#custom-sql-type-mappings">18.1. Custom SQL type mappings</a></li>
<li><a href="#custom-dbms-dialect-other-customizations">18.2. Other customizations</a></li>
</ul>
</li>
<li><a href="#configuration">19. Configuration</a>
<ul class="sectlevel2">
<li><a href="#configuration-properties">19.1. Configuration properties</a></li>
<li><a href="#configuration-jpql-functions">19.2. Jpql functions</a></li>
<li><a href="#configuration-dbms-dialects">19.3. Dbms dialects</a></li>
<li><a href="#configuration-entity-manager-factory-integrators">19.4. Entity manager factory integrators</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Every JPA application that requires some kind of dynamic queries for e.g. filtering has to decide between duplicating parts of queries or building queries conditionally.
JPA offers the Criteria API for constructing such dynamic queries, but using this API often results in unreadable and hard to maintain code.
Concatenating query string parts is often an alternative that might even work for simple cases, but quickly falls apart in many real world scenarios.
Implementing pagination with JPA and especially when fetching collections is hard to do efficiently and often sub-optimal ways are chosen for keeping maintainability.</p>
</div>
<div class="paragraph">
<p>Blaze Persistence is a library that lives on top of a JPA provider and tries to solve these and many more problems a developer faces when having complex requirements.
It is composed of multiple modules that all depend on the core module which this documentation deals with.</p>
</div>
<div class="paragraph">
<p>The core module tries to ease the pain of writing dynamic queries by offering a fluent builder API that puts readability first.
In addition to that, it also integrates deeply with the JPA provider to provide advanced SQL features that not even the JPA providers offer.
The deep integration makes it possible to even workaround some known JPA provider bugs.</p>
</div>
<div class="paragraph">
<p>The <a href="https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html">entity view module</a> builds on top of the core module and provides a way to define DTOs with mappings to the entity model.
The mapping information is used in the query builder to generate projections that perfectly fit the DTO structure along with possible required joins.</p>
</div>
<div class="paragraph">
<p>The jpa-criteria module is an implementation of the JPA Criteria API based on the query builder of the core module.
It offers extensions to the JPA Criteria API that enable the use of some of the concepts and advanced features that are also offered by the core module.
The main intent of this module is to ease the migration of existing queries or to allow the use of advanced features in existing queries on a case by case basis.</p>
</div>
<div class="sect2">
<h3 id="relation-to-jpa-and-implementations"><a class="anchor" href="#relation-to-jpa-and-implementations"></a>Relation to JPA and implementations</h3>
<div class="paragraph">
<p>You can view the Blaze Persistence core module as being a builder for query objects similar to the JPA Criteria API. The builder generally tries to check correctness as early as possible,
but defers some checks to query generation time which allows to write query building code that looks almost like JPQL.</p>
</div>
<div class="paragraph">
<p>Behind the scenes Blaze Persistence core generates a JPQL query or a provider native query string. When advanced features like e.g. CTEs are used, the query string represents the <em>logical query structure</em>
and looks very much like a possible future revision of JPQL.</p>
</div>
<div class="paragraph">
<p>The developers of Blaze Persistence see entity views as a better alternative to JPA 2.1 entity graphs which is why there is no special support for entity graphs.
Nevertheless, using entity graph with queries produced by Blaze Persistence shouldn&#8217;t be a problem as long as no advanced features are used and can be applied as usual via query hints.
Also note that entity graphs require a JPA 2.1 implementation whereas entity views also work with a provider that only implements JPA 2.0.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="system-requirements"><a class="anchor" href="#system-requirements"></a>System requirements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Blaze Persistence core requires at least Java 1.7 and at least a JPA 2.0 implementation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>1. Getting started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a step-by-step introduction about how to get started with the core module of Blaze Persistence.</p>
</div>
<div class="sect2">
<h3 id="getting-started-setup"><a class="anchor" href="#getting-started-setup"></a>1.1. Setup</h3>
<div class="paragraph">
<p>Every <a href="https://github.com/Blazebit/blaze-persistence/releases">release</a> comes with a distribution bundle named like <em>blaze-persistence-dist-VERSION</em>.
This distribution contains the <em>required</em> artifacts for the Blaze Persistence core module as well as artifacts for integrations and other modules.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>required - The core module artifacts and dependencies</p>
</li>
<li>
<p>entity-view - The entity view module artifacts and dependencies</p>
</li>
<li>
<p>jpa-criteria - The jpa-criteria module artifacts and dependencies</p>
</li>
<li>
<p>integration/hibernate - The integrations for various Hibernate versions</p>
</li>
<li>
<p>integration/datanucleus - The integration for DataNucleus</p>
</li>
<li>
<p>integration/eclipselink - The integration for EclipseLink</p>
</li>
<li>
<p>integration/openjpa - The integration for OpenJPA</p>
</li>
<li>
<p>integration/entity-view - Integrations for the entity view module</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>required</em> artifacts are always necessary. Every other module builds up on that. Based on the JPA provider that is used, one of the integrations should be used.
Other modules are optional and normally don&#8217;t have dependencies on each other.</p>
</div>
<div class="sect3">
<h4 id="maven-setup"><a class="anchor" href="#maven-setup"></a>1.1.1. Maven setup</h4>
<div class="paragraph">
<p>We recommend you introduce a version property for Blaze Persistence which can be used for all artifacts.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;properties&gt;
    &lt;blaze-persistence.version&gt;{version}&lt;/blaze-persistence.version&gt;
&lt;/properties&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The required dependencies for the core module are</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-core-api&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-core-impl&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the JPA provider that should be used, one of the following integrations is required</p>
</div>
<div class="sect4">
<h5 id="maven-setup-hibernate53"><a class="anchor" href="#maven-setup-hibernate53"></a>Hibernate 5.3</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-hibernate-5.3&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-hibernate52"><a class="anchor" href="#maven-setup-hibernate52"></a>Hibernate 5.2</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-hibernate-5.2&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-hibernate5"><a class="anchor" href="#maven-setup-hibernate5"></a>Hibernate 5+</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-hibernate-5&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-hibernate43"><a class="anchor" href="#maven-setup-hibernate43"></a>Hibernate 4.3</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-hibernate-4.3&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-hibernate42"><a class="anchor" href="#maven-setup-hibernate42"></a>Hibernate 4.2</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-hibernate-4.2&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-datanucleus51"><a class="anchor" href="#maven-setup-datanucleus51"></a>Datanucleus 5.1</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-datanucleus-5.1&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-datanucleus"><a class="anchor" href="#maven-setup-datanucleus"></a>Datanucleus 4 and 5</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-datanucleus&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-eclipselink"><a class="anchor" href="#maven-setup-eclipselink"></a>EclipseLink</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-eclipselink&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maven-setup-openjpa"><a class="anchor" href="#maven-setup-openjpa"></a>OpenJPA</h5>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.blazebit&lt;/groupId&gt;
    &lt;artifactId&gt;blaze-persistence-integration-openjpa&lt;/artifactId&gt;
    &lt;version&gt;${blaze-persistence.version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-environment"><a class="anchor" href="#anchor-environment"></a>1.2. Environments</h3>
<div class="paragraph">
<p>Blaze Persistence is usable in Java EE, Spring as well as in Java SE environments.</p>
</div>
<div class="sect3">
<h4 id="environments-java-se"><a class="anchor" href="#environments-java-se"></a>1.2.1. Java SE</h4>
<div class="paragraph">
<p>An instance of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a> can be obtained as follows:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = Criteria.getDefault();
// optionally, perform dynamic configuration
CriteriaBuilderFactory cbf = config.createCriteriaBuilderFactory(entityManagerFactory);</pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Criteria.html#getDefault()"><code>Criteria.getDefault()</code></a> method uses the <code>java.util.ServiceLoader</code> to locate
the first implementation of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfigurationProvider.html"><code>CriteriaBuilderConfigurationProvider</code></a> on the classpath
which it uses to obtain an instance of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html"><code>CriteriaBuilderConfiguration</code></a>.
The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html"><code>CriteriaBuilderConfiguration</code></a> instance also allows dynamic configuration of the
factory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a> should only be built once.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Creating the criteria builder factory eagerly at startup is required so that the integration can work properly.
Initializing it differently might result in data races because at creation time e.g. custom functions are registered.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="environments-java-ee"><a class="anchor" href="#environments-java-ee"></a>1.2.2. Java EE</h4>
<div class="paragraph">
<p>The most convenient way to use Blaze Persistence within a Java EE environment is by using a startup EJB and a CDI producer.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Singleton // From javax.ejb
@Startup   // From javax.ejb
public class CriteriaBuilderFactoryProducer {

    // inject your entity manager factory
    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    private CriteriaBuilderFactory criteriaBuilderFactory;

    @PostConstruct
    public void init() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        // do some configuration
        this.criteriaBuilderFactory = config.createCriteriaBuilderFactory(entityManagerFactory);
    }

    @Produces
    @ApplicationScoped
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        return criteriaBuilderFactory;
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="environments-cdi"><a class="anchor" href="#environments-cdi"></a>1.2.3. CDI</h4>
<div class="paragraph">
<p>If EJBs aren&#8217;t available, the <code>CriteriaBuilderFactory</code> can also be configured in a CDI 1.1 specific way by creating a simple producer method like the following example shows.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@ApplicationScoped
public class CriteriaBuilderFactoryProducer {

    // inject your entity manager factory
    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    private volatile CriteriaBuilderFactory criteriaBuilderFactory;

    public void init(@Observes @Initialized(ApplicationScoped.class) Object init) {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        // do some configuration
        this.criteriaBuilderFactory = config.createCriteriaBuilderFactory(entityManagerFactory);
    }

    @Produces
    @ApplicationScoped
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        return criteriaBuilderFactory;
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="environments-spring"><a class="anchor" href="#environments-spring"></a>1.2.4. Spring</h4>
<div class="paragraph">
<p>Within a Spring application the <code>CriteriaBuilderFactory</code> can be provided for injection like this.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Configuration
public class BlazePersistenceConfiguration {

    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy(false)
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        // do some configuration
        return config.createCriteriaBuilderFactory(entityManagerFactory);
    }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="supported-java-runtimes"><a class="anchor" href="#supported-java-runtimes"></a>1.3. Supported Java runtimes</h3>
<div class="paragraph">
<p>All projects are built for Java 7 except for the ones where dependencies already use Java 8 like e.g. Hibernate 5.2, Spring Data 2.0 etc.
So you are going to need at least JDK 8 for building the project.</p>
</div>
<div class="paragraph">
<p>We also support building the project with JDK 9 and try to keep up with newer versions.
If you want to run your application on a Java 9 JVM you need to handle the fact that JDK 9+ doesn&#8217;t export some APIs like the JAXB, JAF, javax.annotations and JTA anymore.
In fact, JDK 11 will even remove the modules so the command line flags to add modules to the classpath won&#8217;t work.</p>
</div>
<div class="paragraph">
<p>Since libraries like Hibernate and others require these APIs you need to make them available. The easiest way to get these APIs back on the classpath is to package them along with your application.
This will also work when running on Java 8. We suggest you add the following dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint xml lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
    &lt;version&gt;2.2.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt;
    &lt;version&gt;2.2.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;
    &lt;version&gt;2.2.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
    &lt;artifactId&gt;javax.transaction-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
    &lt;!-- In a managed environment like Java EE, use 'provided'. Otherwise use 'compile' --&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.activation&lt;/groupId&gt;
    &lt;artifactId&gt;activation&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;!-- In a managed environment like Java EE, use 'provided'. Otherwise use 'compile' --&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
    &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;!-- In a managed environment like Java EE, use 'provided'. Otherwise use 'compile' --&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Automatic module names for modules.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Module</th>
<th class="tableblock halign-left valign-top">Automatic module name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Core API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Core Impl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.core.impl</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Core Parser</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.core.parser</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JPA Criteria API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.criteria</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Core Impl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.criteria.impl</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JPA Criteria JPA2 Compatibility</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.criteria.jpa2compatibility</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="supported-environments-libraries"><a class="anchor" href="#supported-environments-libraries"></a>1.4. Supported environments/libraries</h3>
<div class="paragraph">
<p>The bare minimum is JPA 2.0. If you want to use the JPA Criteria API module, you will also have to add the JPA 2 compatibility module.
Generally, we support the usage in Java EE 6+ or Spring 4+ applications.</p>
</div>
<div class="paragraph">
<p>The following table outlines the supported library versions for the integrations.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Module</th>
<th class="tableblock halign-left valign-top">Automatic module name</th>
<th class="tableblock halign-left valign-top">Minimum version</th>
<th class="tableblock halign-left valign-top">Supported versions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.hibernate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate 4.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.2, 4.3, 5.0, 5.1, 5.2, 5.3 (not all features are available in older versions)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EclipseLink integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.eclipselink</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EclipseLink 2.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.6 (Probably 2.4 and 2.5 work as well, but only tested against 2.6)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataNucleus integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.datanucleus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataNucleus 4.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.1, 5.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenJPA integration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.integration.openjpa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Currently not usable. OpenJPA doesn&#8217;t seem to be actively developed anymore and no users asked for support yet)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="first-criteria-query"><a class="anchor" href="#first-criteria-query"></a>1.5. First criteria query</h3>
<div class="paragraph">
<p>This section is supposed to give you a first feeling of how to use the criteria
builder. For more detailed information, please see the subsequent chapters.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the following we suppose <code>cbf</code> and <code>em</code> to refer to an instance of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a>
and JPA&#8217;s <code>EntityManager</code>, respectively.
Take a look at the <a href="#anchor-environment">environments</a> chapter for how to obtain a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s start with the simplest query possible:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class);</pre>
</div>
</div>
<div class="paragraph">
<p>This query simply selects all Cat objects and is equivalent to following JPQL query:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT c FROM Cat c</pre>
</div>
</div>
<div class="paragraph">
<p>Once the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#create(javax.persistence.EntityManager,%20java.lang.Class)"><code>create()</code></a> method is called the expression
returns a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilder.html"><code>CriteriaBuilder&lt;T&gt;</code></a> where <code>T</code> is specified via the second parameter of the
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#create(javax.persistence.EntityManager,%20java.lang.Class)"><code>create()</code></a> method and denotes the result type of the query.
The default behavior of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#create(javax.persistence.EntityManager,%20java.lang.Class)"><code>create()</code></a> is that the result type
is assumed to be the entity class from which to select. So if we would like to only select the cats' age we would have to write:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("cat.age");</pre>
</div>
</div>
<div class="paragraph">
<p>Here we can see that the criteria builder assigns a default alias (the simple lower-case name of the entity class)
to the entity class from which we select (root entity) if we do not specify one. If we want to save some
writing, both the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#create(javax.persistence.EntityManager,%20java.lang.Class)"><code>create()</code></a> and
the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#from(java.lang.Class,%20java.lang.String)"><code>from()</code></a> method allow the specification of a custom alias for the root entity:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class, "c")
    .select("c.age");</pre>
</div>
</div>
<div class="paragraph">
<p>Next we want to build a more complicated query. Let&#8217;s select all cats with an
age between 5 and 10 years and with at least two kittens. Additionally, we would
like to order the results by name ascending and by id in case of equal names.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "c")
    .where("c.age").betweenExpression("5").andExpression("10")
    .where("SIZE(c.kittens)").geExpression("2")
    .orderByAsc("c.name")
    .orderByAsc("c.id");</pre>
</div>
</div>
<div class="paragraph">
<p>We have built a couple of queries so far but how can we retrieve the results?
There are two possible ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;Cat&gt; cats = cb.getResultList();</code> to retrieve all results</p>
</li>
<li>
<p><code>PagedList&lt;Cat&gt; cats = cb.page(0, 10).getResultList();</code> to retrieve 10 results starting from the first result
(you must specify at least one unique column to determine the order of results)</p>
<div class="paragraph">
<p>The <code>PagedList&lt;Cat&gt;</code> features the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PagedList.html#getTotalSize()"><code>getTotalSize()</code></a> method which is perfectly suited for displaying the results in a
paginated table. Moreover the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PagedList.html#getKeysetPage()"><code>getKeysetPage()</code></a> method can be used to switch to keyset pagination for further paging.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-summary"><a class="anchor" href="#getting-started-summary"></a>1.6. Summary</h3>
<div class="paragraph">
<p>If you want to go into more detail, you are now ready to discover the other chapters of the documentation or
the API yourself.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>2. Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is just a high level view for those that are interested about how Blaze Persistence works.</p>
</div>
<div class="sect2">
<h3 id="architecture-interfaces"><a class="anchor" href="#architecture-interfaces"></a>2.1. Interfaces</h3>
<div class="paragraph">
<p>A quick overview that presents the interfaces that are essential for users and how they are related.</p>
</div>
<div class="sect3">
<h4 id="architecture-interfaces-basic"><a class="anchor" href="#architecture-interfaces-basic"></a>2.1.1. Basic functionality</h4>
<div class="paragraph">
<p>Blaze Persistence has a builder API for building JPQL queries in a comfortable fashion.</p>
</div>
<div class="paragraph">
<p>The most important interfaces that a user should be concerned with are</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilder.html"><code>com.blazebit.persistence.CriteriaBuilder</code></a></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html"><code>com.blazebit.persistence.PaginatedCriteriaBuilder</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The functionalities of the query builders are separated into base interfaces to avoid duplication where possible.
All functionality for the <code>WHERE</code>-clause for example can be found in <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html"><code>com.blazebit.persistence.BaseWhereBuilder</code></a>.
Analogous to that, there also exist interfaces for other clauses.</p>
</div>
<div class="paragraph">
<p>Unless some advanced features(e.g. CTEs) are used, the query string returned by every query builder is JPQL compliant and thus can also be directly compiled via <code>EntityManager#createQuery(String)</code>.
In case of advanced features the query string that is returned might contain syntax elements which are not supported by JPQL. Some features like CTEs simply can not be modeled with JPQL,
therefore a syntax similar to SQL was used to visualize the query model. The query objects returned for such queries are custom implementations,
so beware that you can&#8217;t simply cast them to provider specific subtypes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x1f41fb77&gt;&gt;
interface BaseQueryBuilder
interface QueryBuilder
interface BaseCriteriaBuilder
interface FullCriteriaBuilder
interface PaginatedCriteriaBuilder
interface CriteriaBuilder
interface SetOperationBuilder

BaseQueryBuilder &lt;|-- QueryBuilder
BaseQueryBuilder &lt;|-- BaseCriteriaBuilder

QueryBuilder &lt;|-- FullCriteriaBuilder
FullCriteriaBuilder &lt;|-- PaginatedCriteriaBuilder
FullCriteriaBuilder &lt;|-- CriteriaBuilder
BaseCriteriaBuilder &lt;|-- CriteriaBuilder
SetOperationBuilder &lt;|-- CriteriaBuilder

hide members</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="architecture-interfaces-dml"><a class="anchor" href="#architecture-interfaces-dml"></a>2.1.2. DML support</h4>
<div class="paragraph">
<p>If a user uses Blaze Persistence for data manipulation too, then the following interfaces are unavoidable to know</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/InsertCriteriaBuilder.html"><code>com.blazebit.persistence.InsertCriteriaBuilder</code></a></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/UpdateCriteriaBuilder.html"><code>com.blazebit.persistence.UpdateCriteriaBuilder</code></a></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/DeleteCriteriaBuilder.html"><code>com.blazebit.persistence.DeleteCriteriaBuilder</code></a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x1f41fb77&gt;&gt;
interface BaseModificationCriteriaBuilder
interface BaseInsertCriteriaBuilder
interface BaseDeleteCriteriaBuilder
interface BaseUpdateCriteriaBuilder

interface ModificationCriteriaBuilder
interface InsertCriteriaBuilder
interface DeleteCriteriaBuilder
interface UpdateCriteriaBuilder

BaseModificationCriteriaBuilder &lt;|-- BaseInsertCriteriaBuilder
BaseModificationCriteriaBuilder &lt;|-- BaseDeleteCriteriaBuilder
BaseModificationCriteriaBuilder &lt;|-- BaseUpdateCriteriaBuilder
BaseModificationCriteriaBuilder &lt;|-- ModificationCriteriaBuilder

ModificationCriteriaBuilder &lt;|-- InsertCriteriaBuilder
BaseInsertCriteriaBuilder &lt;|-- InsertCriteriaBuilder

ModificationCriteriaBuilder &lt;|-- DeleteCriteriaBuilder
BaseDeleteCriteriaBuilder &lt;|-- DeleteCriteriaBuilder

ModificationCriteriaBuilder &lt;|-- UpdateCriteriaBuilder
BaseUpdateCriteriaBuilder &lt;|-- UpdateCriteriaBuilder

hide members</pre>
</div>
</div>
<div class="paragraph">
<p>Every interface has a dual partner interface prefixed with <code>Returning</code> that is relevant for data manipulation queries that return results.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>Returning</code> interfaces are only relevant when using <a href="#updatable-ctes">CTEs (Common Table Expressions)</a>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x1f41fb77&gt;&gt;
interface ReturningBuilder
interface BaseModificationCriteriaBuilder
interface BaseInsertCriteriaBuilder
interface BaseDeleteCriteriaBuilder
interface BaseUpdateCriteriaBuilder

interface ReturningModificationCriteriaBuilder
interface InsertCriteriaBuilder
interface DeleteCriteriaBuilder
interface UpdateCriteriaBuilder
interface ReturningInsertCriteriaBuilder
interface ReturningDeleteCriteriaBuilder
interface ReturningUpdateCriteriaBuilder

BaseModificationCriteriaBuilder &lt;|-- BaseInsertCriteriaBuilder
BaseModificationCriteriaBuilder &lt;|-- BaseDeleteCriteriaBuilder
BaseModificationCriteriaBuilder &lt;|-- BaseUpdateCriteriaBuilder
BaseModificationCriteriaBuilder &lt;|-- ReturningModificationCriteriaBuilder
ReturningBuilder &lt;|-- ReturningModificationCriteriaBuilder

ReturningModificationCriteriaBuilder &lt;|-- InsertCriteriaBuilder
BaseInsertCriteriaBuilder &lt;|-- ReturningInsertCriteriaBuilder

ReturningModificationCriteriaBuilder &lt;|-- DeleteCriteriaBuilder
BaseDeleteCriteriaBuilder &lt;|-- ReturningDeleteCriteriaBuilder

ReturningModificationCriteriaBuilder &lt;|-- UpdateCriteriaBuilder
BaseUpdateCriteriaBuilder &lt;|-- ReturningUpdateCriteriaBuilder

hide members</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="architecture-interfaces-cte"><a class="anchor" href="#architecture-interfaces-cte"></a>2.1.3. CTE support</h4>
<div class="paragraph">
<p>CTE builders are split into two families of interface groups. One group is concerned with CTEs that do select queries, the other with DML queries.</p>
</div>
<div class="paragraph">
<p>Select CTE queries can either be recursive or non-recursive. Recursive CTEs always have a base part and a recursive part which is explicitly modeled in the API.
One starts with a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectRecursiveCTECriteriaBuilder.html"><code>com.blazebit.persistence.SelectRecursiveCTECriteriaBuilder</code></a> for defining the base part
and then unions the recursive part of the query in a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectCTECriteriaBuilder.html"><code>com.blazebit.persistence.SelectCTECriteriaBuilder</code></a>.
The non-recursive builder is very similar but does not have an explicit notion of a base or recursive part. Although it supports set operations,
we do not recommend building recursive queries with the non-recursive builder especially because it&#8217;s not portable and less readable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x1f41fb77&gt;&gt;
interface BaseCTECriteriaBuilder
interface SelectBaseCTECriteriaBuilder
interface FullSelectCTECriteriaBuilder
interface SelectCTECriteriaBuilder
interface SelectRecursiveCTECriteriaBuilder
interface SetOperationBuilder

BaseCTECriteriaBuilder &lt;|-- SelectBaseCTECriteriaBuilder

SelectBaseCTECriteriaBuilder &lt;|-- SelectRecursiveCTECriteriaBuilder
SelectBaseCTECriteriaBuilder &lt;|-- SelectCTECriteriaBuilder
SelectBaseCTECriteriaBuilder &lt;|-- FullSelectCTECriteriaBuilder
SetOperationBuilder &lt;|-- FullSelectCTECriteriaBuilder

hide members</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="architecture-interfaces-set"><a class="anchor" href="#architecture-interfaces-set"></a>2.1.4. Set operations support</h4>
<div class="paragraph">
<p>Every query builder has support for set operations as defined by the interface <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html"><code>com.blazebit.persistence.SetOperationBuilder</code></a>.
One can start a nested group of query builders concatenated with set operations. This group has to be ended and concatenated with another query build or another nested group.
When an empty set operation group is encountered during the query building, it is removed internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: can't modify frozen #&lt;Class:#&lt;Asciidoctor::Diagram::PlantUmlBlockProcessor:0x1f41fb77&gt;&gt;
interface BaseOngoingSetOperationBuilder

interface StartOngoingSetOperationBuilder
interface OngoingSetOperationBuilder

interface BaseXXXBuilder
interface LeafOngoingFinalSetOperationXXXBuilder
interface MiddleOngoingSetOperationXXXBuilder
interface StartOngoingSetOperationXXXBuilder
interface OngoingSetOperationXXXBuilder
interface LeafOngoingSetOperationXXXBuilder

interface BaseFinalSetOperationBuilder

interface BaseOngoingFinalSetOperationBuilder
interface OngoingFinalSetOperationXXXBuilder
interface FinalSetOperationXXXBuilder

BaseOngoingSetOperationBuilder &lt;|-- StartOngoingSetOperationBuilder
BaseOngoingSetOperationBuilder &lt;|-- OngoingSetOperationBuilder
BaseOngoingSetOperationBuilder &lt;|-- LeafOngoingFinalSetOperationXXXBuilder
BaseOngoingSetOperationBuilder &lt;|-- LeafOngoingSetOperationXXXBuilder

OngoingSetOperationBuilder &lt;|-- MiddleOngoingSetOperationXXXBuilder
StartOngoingSetOperationBuilder &lt;|-- StartOngoingSetOperationXXXBuilder

MiddleOngoingSetOperationXXXBuilder &lt;|-- StartOngoingSetOperationXXXBuilder
BaseXXXBuilder &lt;|-- StartOngoingSetOperationXXXBuilder
MiddleOngoingSetOperationXXXBuilder &lt;|-- OngoingSetOperationXXXBuilder
BaseXXXBuilder &lt;|-- OngoingSetOperationXXXBuilder
BaseXXXBuilder &lt;|-- LeafOngoingSetOperationXXXBuilder

BaseFinalSetOperationBuilder &lt;|-- BaseOngoingFinalSetOperationBuilder
BaseFinalSetOperationBuilder &lt;|-- FinalSetOperationXXXBuilder
FinalSetOperationXXXBuilder &lt;|-- OngoingFinalSetOperationXXXBuilder

hide members</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder
    .startSet(Cat.class) <i class="conum" data-value="1"></i><b>(1)</b>
        .startUnionAll() <i class="conum" data-value="2"></i><b>(2)</b>
        .endSetWith() <i class="conum" data-value="3"></i><b>(3)</b>
        .endSet() <i class="conum" data-value="4"></i><b>(4)</b>
        .unionAll() <i class="conum" data-value="5"></i><b>(5)</b>
    .endSet() <i class="conum" data-value="6"></i><b>(6)</b>
    .unionAll() <i class="conum" data-value="7"></i><b>(7)</b>
    .endSet() <i class="conum" data-value="8"></i><b>(8)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Starting a builder with a nested set operation group returns <code>StartOngoingSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Starting any nested set operation group returns <code>StartOngoingSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ending nested set operation group with <code>endSetWith()</code> to specify ordering and limiting returns <code>OngoingFinalSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Ending a nested set operation group with <code>endSet()</code> results in <code>MiddleOngoingSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Connecting a nested set operation group with a set operation results in <code>OngoingSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Ending a top level set operation nested group results in <code>LeafOngoingFinalSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Connecting a top level set operation group with a set operation results in <code>LeafOngoingSetOperationXXXBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Ending the top level set operation results in <code>FinalSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="architecture-interfaces-set-toplevel"><a class="anchor" href="#architecture-interfaces-set-toplevel"></a>Top-level query builder set operations</h5>
<div class="paragraph">
<p>Invoking a set operation on a top level query builder results in a <code>LeafOngoingSetOperationXXXBuilder</code> type.
<code>LeafOngoingSetOperationXXXBuilder</code> types are the possible <em>exit types</em> for a top level set operation group.</p>
</div>
<div class="paragraph">
<p>Further connecting the builder via a set operation will produce a builder of the same type <code>LeafOngoingSetOperationXXXBuilder</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .unionAll() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The set operation on a top level query builder produces <code>LeafOngoingSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When ending such a builder via <code>endSet()</code>, a <code>FinalSetOperationXXXBuilder</code> is produced.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .unionAll()
    .endSet() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The ending of a top level set operation builder produces <code>FinalSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>FinalSetOperationXXXBuilder</code> types are the result of a top level set operation and once constructed only support specifying ordering or limiting.</p>
</div>
</div>
<div class="sect4">
<h5 id="architecture-interfaces-set-nested"><a class="anchor" href="#architecture-interfaces-set-nested"></a>Nested query builder set operations</h5>
<div class="paragraph">
<p>Invoking a nested set operation on a query builder results in a <code>StartOngoingSetOperationXXXBuilder</code> type.
<code>StartOngoingSetOperationXXXBuilder</code> types represent a builder for a group of set operations within parenthesis.
With such a builder the normal query builder methods are available and additionally, it can end the group.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The nested set operation on a query builder produces <code>StartOngoingSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When connecting the builder with another set operation a <code>OngoingSetOperationXXXBuilder</code> is produced which essentially has the same functionality.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll()
    .unionAll() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A set operation on a <code>StartOngoingSetOperationXXXBuilder</code> produces <code>OngoingSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When ending such a top level nested builder via <code>endSet()</code>, a <code>LeafOngoingFinalSetOperationXXXBuilder</code> is produced.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll()
    .endSet() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Results in <code>LeafOngoingFinalSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Or when in a nested context, a <code>MiddleOngoingSetOperationXXXBuilder</code> is produced.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll()
    .startUnionAll()
    .endSet() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Results in <code>MiddleOngoingSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The ending of the builder is equivalent to doing a <em>closing parenthesis</em>.</p>
</div>
<div class="paragraph">
<p>Since a nested group only makes sense when connecting the group with something else, the <code>LeafOngoingFinalSetOperationXXXBuilder</code> and <code>MiddleOngoingSetOperationXXXBuilder</code> only allow connecting
a new builder with a set operation or ending the whole query builder.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll()
    .endSet()
    .unionAll() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Results in <code>LeafOngoingSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Or when in a nested context, a <code>OngoingSetOperationXXXBuilder</code> is produced.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll()
    .startUnionAll()
    .endSet()
    .unionAll() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Results in <code>OngoingSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ending a nested group with <code>endSetWith()</code> allows to specify ordering and limiting for the group and returns a <code>OngoingFinalSetOperationXXXBuilder</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">criteriaBuilder.from(Cat.class)
    .startUnionAll()
    .endSetWith() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Results in <code>OngoingFinalSetOperationXXXBuilder</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="architecture-query-building"><a class="anchor" href="#architecture-query-building"></a>2.2. Query building</h3>
<div class="paragraph">
<p>Every query builder has several clause specific <em>managers</em> that it delegates to. These <em>managers</em> contain the state for a clause and might interact with other clauses.
Depending on which query builder features are used, the query object that is produced by a query builder through <code>getTypeQuery()</code> or <code>getQuery()</code> is either the JPA provider&#8217;s native query or a custom query.</p>
</div>
<div class="paragraph">
<p>If no advanced features are used, nothing special happens. The query string is built and passed to <code>EntityManager.createQuery()</code> which is then returned.
When advanced features are used, an <em>example query</em> is built which most of the time is very similar to the original query except for advanced features.
This <em>example query</em> serves as a basis for execution of advanced SQL. It almost contains all the necessary parts, there is just some SQL that needs to be replaced.</p>
</div>
<div class="paragraph">
<p>If CTEs are involved, one query per CTE is built via the same mechanism and added to the <em>participating queries</em> list. This list is ordered and contains all query parts that are involved in an advanced query.
The ordering is important because in the end, parameters are positionally set in SQL and the order within the list represents the order of the query parts in the SQL.
All these query objects are then passed to a <em>QuerySpecification</em> which is capable of producing the SQL for the whole query from it&#8217;s query parts.
It serves as component that can be composed into a bigger query but also provides a method for creating a <em>SelectQueryPlan</em> or <em>ModificationQueryPlan</em>.
Such query plans represent the executable form of query specifications that are fixed. The reason for the separation between the two is that <em>list parameters</em> or calls to <code>setFirstResult()</code> and <code>setMaxResults()</code> could change the SQL.</p>
</div>
<div class="paragraph">
<p>The query specification is wrapped in an implementation of the JPA query interfaces <code>javax.persistence.Query</code> or <code>javax.persistence.TypedQuery</code> and a query plan is only created on demand just before executing.
Parameters, lock modes and flush modes are propagated to all necessary <em>participating queries</em>.</p>
</div>
<div class="paragraph">
<p>Set operations on top level queries essentially are special query specifications that contain multiple other query specifications.</p>
</div>
<div class="paragraph">
<p>To really execute such advanced queries, query plans use the <code>ExtendedQuerySupport</code>. It offers methods to run an JPA query with an SQL replacement and a list of <em>participating queries</em>.
The <code>ExtendedQuerySupport</code> is JPA provider specific and is responsible for proper query caching and giving access to SQL specifics of JPA query objects.</p>
</div>
<div class="paragraph">
<p>The integration of <code>ObjectBuilder</code> is done by introducing a query wrapper that takes results, passes them through the object builder and then returns the results.</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture-jpa-provider-integration"><a class="anchor" href="#architecture-jpa-provider-integration"></a>2.3. JPA Provider Integration</h3>
<div class="paragraph">
<p>The essential integration points with the JPA provider are encapsulated in <code>EntityManagerFactoryIntegrator</code> and <code>ExtendedQuerySupport</code>.</p>
</div>
<div class="paragraph">
<p>The <code>EntityManagerFactoryIntegrator</code> offers support for DBMS detection, function registration and
the construction of a <code>JpaProvider</code> through a <code>JpaProviderFactory</code>. The <code>JpaProvider</code> is a contract that can be used to query JPA provider specifics.
Some of those specifics are whether a feature like entity joins is supported but also metamodel specifics like whether an attribute has a join table.</p>
</div>
<div class="paragraph">
<p>The <code>ExtendedQuerySupport</code> is necessary for advanced SQL related functionality and might not be available for a JPA provider.
It provides access to SQL related information like the column names of an entity attribute or simply the SQL query for a JPA query.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="from-clause"><a class="anchor" href="#from-clause"></a>3. From clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>FROM</code> clause contains the entities which should be queried.
Normally a query will have one root entity which is why Blaze Persistence offers a convenient factory for creating queries that select the root entity.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class);</pre>
</div>
</div>
<div class="paragraph">
<p>The type <code>Cat</code> has multiple purposes in this case.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It defines the result type of the query</p>
</li>
<li>
<p>Creates an implicit query root with that type and the alias <em>cat</em></p>
</li>
<li>
<p>Implicitly selects <em>cat</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This implicit logic will help to avoid some boilerplate code in most of the cases.
The JPQL generated for such a simple query is just like you would expect</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>As soon as a query root is added via <code>from()</code>, the implicitly created query root is removed.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Person.class, "person")
    .select("person.kittens");</pre>
</div>
</div>
<div class="paragraph">
<p>In such a query, the type <code>Cat</code> only serves the purpose of defining the query result type.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT kittens_1
FROM Person person
LEFT JOIN person.kittens kittens_1</pre>
</div>
</div>
<div class="paragraph">
<p>Contrary to the described behavior, using the overload of the <code>create</code> method that allows to specify the alias for the query root will result in an explicit query root.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "myCat");</pre>
</div>
</div>
<div class="paragraph">
<p>This is essentially a shorthand for</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "myCat");</pre>
</div>
</div>
<div class="paragraph">
<p>A query can also have multiple root entities which are connected with the <code>,</code> operator that essentially has the semantics of a <code>CROSS JOIN</code>.
Beware that when having multiple root entities, path expression must use absolute paths.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "myCat")
    .select("name");</pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>name</code> in this case is interpreted as relative to the query root, so it is equivalent to <code>myCat.name</code>.
When having multiple query roots, the use of a relative path will lead to an exception saying that relative resolving is not allowed with multiple query roots!</p>
</div>
<div class="sect2">
<h3 id="joins"><a class="anchor" href="#joins"></a>3.1. Joins</h3>
<div class="paragraph">
<p>JPQL offers support for <code>CROSS</code>, <code>INNER</code>, <code>LEFT</code> and <code>RIGHT JOIN</code> which are all well supported by Blaze Persistence.
In contrast to JPQL, Blaze Persistence also has a notion of implicit/default and explicit joins which makes it very convenient to write queries as can be seen a few sections later.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>RIGHT JOIN</code> support is optional in JPA so we recommend not using it at all.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In addition to joins on mapped relations, Blaze Persistence also offers support for unrelated or entity joins offered by all major JPA providers.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="implicit-joins"><a class="anchor" href="#implicit-joins"></a>3.1.1. Implicit joins</h4>
<div class="paragraph">
<p>An implicit or default join is a special join that can be referred to by</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>an absolute path from a root entity to an association</p>
</li>
<li>
<p>alias if an explicit alias has been defined via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#joinDefault(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>joinDefault()</code></a> means</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A path is considered <em>absolute</em> also if it is relative to the query root
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following query builder will create an implicit join for the path <code>kittens</code> when inspecting the select clause and reuse that implicit join in the where clause because of the use of an absolute path.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("kittens.age")
    .where("kittens.age").gt(1);</pre>
</div>
</div>
<div class="paragraph">
<p>This will result in the following JPQL query</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT kittens_1.age
FROM Cat cat
LEFT JOIN cat.kittens kittens_1
WHERE kittens_1.age &gt; 1</pre>
</div>
</div>
<div class="paragraph">
<p>A relation dereference like <code>alias.relation.property</code> will always result in a JOIN being added for <code>alias.relation</code>.
The exception to that is when the accessed property is the identifier property of the type of <code>relation</code> and that identifier is owned by <code>alias</code> i.e. the column is contained in the owner&#8217;s table.
If the property is the identifier and the <code>JpaProvider</code> supports <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/JpaProvider.html#supportsSingleValuedAssociationIdExpressions()">optimized id access</a>,
no join is generated but instead the expression is rendered as it is <code>alias.relation.identifier</code>.</p>
</div>
<div class="sect4">
<h5 id="model-awareness"><a class="anchor" href="#model-awareness"></a>Model awareness</h5>
<div class="paragraph">
<p>Implicit joins are a result of a path dereference or explicit fetching. A path dereference can happen in any place where an expression is expected.
An explicit fetch can be invoked on <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html"><code>FullQueryBuilder</code></a> instances which is the top type for
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilder.html"><code>CriteriaBuilder</code></a> and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a>.</p>
</div>
<div class="paragraph">
<p>Every implicit join will result in a so called "model-aware" join. The model-awareness of a join is responsible for determining the join type to use.
Generally it is a good intuition to think of a model-aware join to always produce results, thus never restricting the result set but only extending it.
A model-aware join currently decides between <code>INNER</code> and <code>LEFT JOIN</code>. The <code>INNER JOIN</code> is only used if</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The parent join is an <code>INNER JOIN</code></p>
</li>
<li>
<p>The relation is non-optional e.g. the <code>optional</code> attribute of a <code>@ManyToOne</code> or <code>@OneToOne</code> is false</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is different from how JPQL path expressions are normally interpreted but will result in a more natural output.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you aren&#8217;t happy with the join types you can override them and even specify an alias for implicit joins via the
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#joinDefault(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>joinDefault</code></a> method and variants.
Consider the following example for illustration purposes of the implicit joins.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("kittens.age")
    .where("kittens.age").gt(1)
    .innerJoinDefault("kittens", "kitty");</pre>
</div>
</div>
<div class="paragraph">
<p>The builder first creates an implicit join for <code>kittens</code> with the join type <code>LEFT JOIN</code> because a Collection can never be non-optional.
If you just had the <code>SELECT</code> clause, a <code>NULL</code> value would be produced for cats that don&#8217;t have kittens.
But in this case the <code>WHERE</code> clause filters out these cats, because any comparison with <code>NULL</code> will result in <code>UNKNOWN</code> and thus <code>FALSE</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Null-aware predicates like <code>IS NULL</code> are obviously an exception to this.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The last statement will take the default/implicit join for the path <code>kittens</code>, set the join type to <code>INNER</code> and the alias to <code>kitty</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Although the generated aliases for implicit joins are deterministic, they might change over time so you should never use them to refer to implicit joins.
Always use the full path to the join relation or define an alias and use that instead!
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="explicit-joins"><a class="anchor" href="#explicit-joins"></a>3.1.2. Explicit joins</h4>
<div class="paragraph">
<p>Explicit joins are different from implicit/default joins in a sense that they are only accessible through their alias. You can have only one default join which is identified by it&#8217;s absolute path,
but multiple explicit joins as these are identified by their alias. This means that you can also join a relation multiple times with different aliases.</p>
</div>
<div class="paragraph">
<p>You can create explicit joins with the <a href="{core_doc]/persistence/FromBuilder.html#join(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>join()</code></a> method and variants.
The following shows explicit and implicit joins used together.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class)
    .select("kittens.age")
    .where("kitty.age").gt(1)
    .innerJoin("kittens", "kitty");</pre>
</div>
</div>
<div class="paragraph">
<p>This query will in fact create two joins. One for the explicitly inner joined <code>kittens</code> with the alias <code>kitty</code> and another for the implicitly left joined <code>kittens</code> used in the <code>SELECT</code> clause.
The resulting JPQL looks like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT kittens_1.age
FROM Cat cat
INNER JOIN cat.kittens kitty
LEFT JOIN cat.kittens kittens_1
WHERE kitty.age &gt; 1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fetched-joins"><a class="anchor" href="#fetched-joins"></a>3.1.3. Fetched joins</h4>
<div class="paragraph">
<p>Analogous to the <code>FETCH</code> keyword in JPQL, you can specify for every join node of a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html"><code>FullQueryBuilder</code></a> if it should be fetched.
Every <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#join(java.lang.String,%20java.lang.String,%20com.blazebit.persistence.JoinType)"><code>join()</code></a> method variant comes with a partner method,
that does fetching for the joined path. In addition to that, there is also a simple <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#fetch(java.lang.String&#8230;&#8203;)"><code>fetch()</code></a> method which can be provided with absolute paths to relations.
These relations are then implicit/default join fetched, i.e. a default join node with fetching enabled is created for every relation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can make use of deep paths like <code>kittens.kittens</code> which will result in fetch joining two levels of kittens.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class)
    .leftJoinFetch("father", "dad")
    .whereOr()
        .where("dad").isNull()
        .where("dad.age").gt(1)
    .endOr()
    .fetch("kittens.kittens", "mother");</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>father</code> relation is left join fetched and given an alias which is then used in the <code>WHERE</code> clause. Two levels of <code>kittens</code> and the <code>mother</code> relation are join fetched.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.father dad
LEFT JOIN FETCH cat.kittens kittens_1
LEFT JOIN FETCH kittens_1.kittens kittens_2
LEFT JOIN FETCH cat.mother mother_1
WHERE dad IS NULL
   OR dad.age &gt; 1</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Although the JPA spec does not specifically allow aliasing fetch joins, every major JPA provider supports this.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When doing a scalar select instead of a query root select, Blaze Persistence automatically adapts the fetches to the new fetch owners.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class)
    .fetch("father.kittens")
    .select("father");</pre>
</div>
</div>
<div class="paragraph">
<p>In this case we fetch the <code>father</code> relation and the <code>kittens</code> of the <code>father</code>. By also selecting the <code>father</code> relation, the fetch owner changes from the query root to the <code>father</code>.
This has the effect, that the <code>father</code> is not fetch joined, as that would be invalid.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT father_1
FROM Cat cat
LEFT JOIN cat.father father_1
LEFT JOIN FETCH father_1.kittens kittens_1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="array-joins"><a class="anchor" href="#array-joins"></a>3.1.4. Array joins</h4>
<div class="paragraph">
<p>Array joins are an extension to the JPQL grammar which offer a convenient way to create joins with an <code>ON</code> clause condition.
An array join expression is a path expression followed by an opening bracket, the index expression and then the closing bracket e.g. <code>arrayBase[indexExpression]</code>.</p>
</div>
<div class="paragraph">
<p>The type of the <code>arrayBase</code> expression must be either an indexed <code>List</code> e.g. use an <code>@OrderColumn</code> or a <code>Map</code>.
In case of an indexed list, the type of the <code>indexExpression</code> must be numeric. For maps, the type must match the map key type as defined in the entity.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class)
    .select("localizedName[:language]")
    .where("localizedName[:language]").isNotNull();</pre>
</div>
</div>
<div class="paragraph">
<p>Such a query will result in the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT localizedName_language
FROM Cat cat
LEFT JOIN cat.localizedName localizedName_language
       ON KEY(localizedName_language) = :language
WHERE localizedName_language IS NOT NULL</pre>
</div>
</div>
<div class="paragraph">
<p>The relation <code>localizedName</code> is assumed to be a map of type <code>Map&lt;String, String&gt;</code> which maps a language code to a localized name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In case of array expressions, the generated implicit/default join node is identified not only by the absolute path, but also by the index expression.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="correlated-joins"><a class="anchor" href="#correlated-joins"></a>3.1.5. Correlated joins</h4>
<div class="paragraph">
<p>JPQL allows subqueries to refer to a relation based on a join alias of the outer query within the from clause, also known as correlated join.
A correlated join in Blaze Persistence can be done when <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SubqueryInitiator.html#from(java.lang.String)">initiating a subquery</a>
or be added as <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseSubqueryBuilder.html#from(java.lang.String)">cross join</a> to an existing subquery builder.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "c")
    .selectSubquery()
        .from("c.kittens", "kitty")
        .select("COUNT(kitty.id)")
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>Such a query will result in the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    (
        SELECT COUNT(kitty.id)
        FROM c.kittens kitty
    )
FROM Cat c</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although JPA does not mandate the support for subqueries in the <code>SELECT</code> clause, every major JPA provider supports it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="anchor-entity-joins"><a class="anchor" href="#anchor-entity-joins"></a>3.1.6. Entity joins</h4>
<div class="paragraph">
<p>An entity join is a type of join for unrelated entities, in the sense that no JPA mapping is required to join the entities.
Entity joins are quite useful, especially when information from separate models(i.e. models that have no static dependency on each other) should be queried.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine a query that reports the count of people that are older than a cat for each cat</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "c")
    .leftJoinOn(Person.class, "p")
        .on("c.age").ltExpression("p.age")
    .end()
    .select("c.name")
    .select("COUNT(p.id)")
    .groupBy("c.id", "c.name");</pre>
</div>
</div>
<div class="paragraph">
<p>The JPQL representation looks just as expected</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT c.name, COUNT(p.id)
FROM Cat c
LEFT JOIN Person p
       ON c.age &lt; p.age
GROUP BY c.id, c.name</pre>
</div>
</div>
<div class="paragraph">
<p>Entity joins normally <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#joinOn(java.lang.String,%20java.lang.Class,%20java.lang.String,%20com.blazebit.persistence.JoinType)">require a base alias</a>
but <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#joinOn(java.lang.Class,%20java.lang.String,%20com.blazebit.persistence.JoinType)">default to the query root</a> when only a single query root is available.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>INNER</code> entity joins don&#8217;t need support from the JPA provider because these are rewritten to a JPQL compliant <code>CROSS JOIN</code> if necessary.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="on-clause"><a class="anchor" href="#on-clause"></a>3.2. On clause</h3>
<div class="paragraph">
<p>The <code>ON</code> clause is a filter predicate similar to the <code>WHERE</code> clause, but is evaluated while joining to restrict the joined elements.
In case of <code>INNER</code> joins the <code>ON</code> clause has the same effect as when putting the predicate into the <code>WHERE</code> clause.
However <code>LEFT</code> joins won&#8217;t filter out objects from the source even if the predicate doesn&#8217;t match any joinable object, but instead will produce a <code>NULL</code> value for the joined element.</p>
</div>
<div class="paragraph">
<p>The <code>ON</code> clause is used when using array joins to restrict the key of a join to the index expression.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Since the <code>ON</code> clause is only supported as of JPA 2.1, the usage with JPA 2.0 providers that have no equivalent vendor extension will fail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ON</code> clause can be constructed by setting a JPQL predicate expression with <code>setOnExpression()</code> or by using the <a href="#predicate builder&gt;">Predicate Builder API</a>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">setOnExpression()</th>
<th class="tableblock halign-left valign-top">Predicate Builder API</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb =
    cbf.create(em, String.class)
    .from(Cat.class)
    .select("l10nName")
    .leftJoinOn("localizedName", "l10nName")
      .setOnExpression("KEY(l10nName) = :lang")
    .where("l10nName").isNotNull();</pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb =
    cbf.create(em, String.class)
    .from(Cat.class)
    .select("l10nName")
    .leftJoinOn("localizedName", "l10nName")
        .on("KEY(l10nName)").eq(":lang")
    .end()
    .where("l10nName").isNotNull();</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The resulting JPQL looks as expected</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT localizedNameForLanguage
FROM Cat cat
LEFT JOIN cat.localizedName l10nName
       ON KEY(l10nName) = :lang
WHERE l10nName IS NOT NULL</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-values-clause"><a class="anchor" href="#anchor-values-clause"></a>3.3. VALUES clause</h3>
<div class="paragraph">
<p>The <code>VALUES</code> clause is similar to the SQL <code>VALUES</code> clause in the sense that it allows to define a temporary set of objects for querying.
There are 3 different types of values for which a <code>VALUES</code> clause can be created</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic values (Integer, String, etc.)</p>
</li>
<li>
<p>Managed values (Entities, Embeddables, CTEs)</p>
</li>
<li>
<p>Identifiable values (Entities, CTEs)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For query caching reasons, a <code>VALUES</code> clause has a fixed number of elements. If you bind a collection that has a smaller size, the rest is filled up with <code>NULL</code> values which are filtered out by a <code>WHERE</code> clause.
Trying to bind a collection with a larger size will lead to an exception at bind time.</p>
</div>
<div class="paragraph">
<p>The <code>VALUES</code> clause is a feature that can be used for doing efficient batching. The number of elements can serve as batch size. Processing a collection iteratively and binding subsets to a query efficiently reuses query caches.
For one-shot or rarely executed queries it might not be necessary to implement batching.
In such cases use one of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromValues(java.lang.Class,%20java.lang.String,%20java.util.Collection)">overloads</a> that use the collection size as number of elements.</p>
</div>
<div class="paragraph">
<p>The join alias that must be defined for a <code>VALUES</code> clause is reused as alias for the parameter to bind values.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .fromValues(String.class, "myValue", 10)
    .select("myValue.value")
    .setParameter("myValue", valueCollection);</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently it is not possible to use the <code>VALUES</code> when using parameters in the <code>SELECT</code> clause due to <a href="https://github.com/Blazebit/blaze-persistence/issues/305">#305</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For some cases it might be better to make use of <a href="#entity-functions">entity functions</a> instead of a <code>VALUES</code>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="basic-values"><a class="anchor" href="#basic-values"></a>3.3.1. Basic values</h4>
<div class="paragraph">
<p>The following basic value types are supported</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code></p>
</li>
<li>
<p><code>Byte</code></p>
</li>
<li>
<p><code>Short</code></p>
</li>
<li>
<p><code>Integer</code></p>
</li>
<li>
<p><code>Long</code></p>
</li>
<li>
<p><code>Float</code></p>
</li>
<li>
<p><code>Double</code></p>
</li>
<li>
<p><code>Character</code></p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p><code>BigInteger</code></p>
</li>
<li>
<p><code>BigDecimal</code></p>
</li>
<li>
<p><code>java.sql.Time</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to access the actual value in an expression, the <code>value</code> property of the alias for the <code>VALUES</code> clause has to be dereferenced.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Collection&lt;String&gt; valueCollection = Arrays.asList("value1", "value2");
CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .fromValues(String.class, "myValue", valueCollection)
    .select("myValue.value");</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting logical JPQL doesn&#8217;t include individual parameters, but specifies the count of the values. The alias of the values clause from item also represents the parameter name.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT TREAT_STRING(myValue.value)
FROM String(2 VALUES) myValue</pre>
</div>
</div>
<div class="paragraph">
<p>The use of <code>TREAT_STRING</code> as the name suggests, has the effect that the expression is treated like a string expression.
Behind the scenes, a type called <code>ValuesEntity</code> is used to be able to implement the VALUES clause.</p>
</div>
<div class="paragraph">
<p>For further information on <code>TREAT</code> functions, take a look at the <a href="#treat-functions">JPQL functions</a> chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="managed-values"><a class="anchor" href="#managed-values"></a>3.3.2. Managed values</h4>
<div class="paragraph">
<p>Managed values are objects of a JPA managed type i.e. entities or embeddables. A <code>VALUES</code> clause for such types will include <strong>all</strong> properties of that type,
so be careful when using this variant. For using only the <em>id</em> part of a managed type, take a look at the <a href="#identifiable-values">identifiable values</a> variant.
If using all properties of an entity or embeddable is not appropriate for you, you should consider creating a custom <a href="#ctes"><em>CTE entity</em></a> that covers only the subset of properties you are interested in
and finally convert your entity or embeddable object to that new type so it can be used with the <code>VALUES</code> clause.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Embeddable
class MyEmbeddable {
    private String property1;
    private String property2;
}</pre>
</div>
</div>
<div class="paragraph">
<p>The embeddable defines 2 properties and a <code>VALUES</code> query for objects of that type might look like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Collection&lt;MyEmbeddable&gt; valueCollection = ...
CriteriaBuilder&lt;MyEmbeddable&gt; cb = cbf.create(em, MyEmbeddable.class)
    .fromValues(MyEmbeddable.class, "myValue", valueCollection)
    .select("myValue");</pre>
</div>
</div>
<div class="paragraph">
<p>The JPQL for such a query looks roughly like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT myValue
FROM MyEmbeddable(1 VALUES) myValue</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiable-values"><a class="anchor" href="#identifiable-values"></a>3.3.3. Identifiable values</h4>
<div class="paragraph">
<p>Identifiable values are also objects of a JPA managed type, but restricted to identifiable managed types i.e. no embeddables.
Every entity and <a href="#ctes"><em>CTE entity</em></a> is an identifiable managed type and can thus be used in
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromIdentifiableValues(java.lang.Class,%20java.lang.String,%20java.util.Collection)"><code>fromIdentifiableValues()</code></a>.</p>
</div>
<div class="paragraph">
<p>The main difference to the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromValues(java.lang.Class,%20java.lang.String,%20java.util.Collection)">managed values variant</a>
is that only the identifier properties of the objects are bound instead of all properties.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Collection&lt;Cat&gt; valueCollection = ...
CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .fromIdentifiableValues(Cat.class, "cat", valueCollection)
    .select("cat.id");</pre>
</div>
</div>
<div class="paragraph">
<p>The JPQL for such a query looks roughly like the following</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id
FROM Cat.id(1 VALUES) cat</pre>
</div>
</div>
<div class="paragraph">
<p>The values parameter "cat" will still expect instances of the type <code>Cat</code>, but will only bind the id attribute values.
This also works for embedded ids and access to the embedded values works just like expected, by dereferencing the embeddable further i.e. <code>alias.embeddable.property</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When using the identifiable values, only the id values are available for the query. Using any other property will lead to an exception.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="before-and-after-dml-in-ctes"><a class="anchor" href="#before-and-after-dml-in-ctes"></a>3.4. Before and after DML in CTEs</h3>
<div class="paragraph">
<p>When using <a href="#updatable-ctes">DML in CTEs</a> it depends on the DBMS what state a <code>FROM</code> element might give.
Normally this is not problematic as it is rarely necessary to do DML and a <code>SELECT</code> for the same entity in one query.
When it is necessary to do that, it is strongly advised to make use of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromOld(java.lang.Class)"><code>fromOld()</code></a>
or <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromNew(java.lang.Class)"><code>fromNew()</code></a> to use the state before or after side-effects happen.</p>
</div>
<div class="paragraph">
<p>For example usage and further information, take a look into the <a href="#updatable-ctes">Updatable CTEs chapter</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="predicate-builder"><a class="anchor" href="#predicate-builder"></a>4. Predicate Builder</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Predicate Builder API tries to simplify construction but also the reuse of predicates. There are multiple clauses and expressions that support entering the API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#where-clause">Where clause</a></p>
</li>
<li>
<p><a href="#having-clause">Having clause</a></p>
</li>
<li>
<p><a href="#on-clause">On clause</a></p>
</li>
<li>
<p><a href="#case-when-expression-builder">Case When expression</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Every predicate builder follows the same scheme:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An entry method can be used to start the builder with the left hand side of a predicate</p>
</li>
<li>
<p>Entry methods are additive, and finishing a predicate results in adding that to the compound predicate</p>
</li>
<li>
<p>Once a predicate has been started, it must be properly finished</p>
</li>
<li>
<p>On the top level, a method to directly set a JPQL predicate expression is provided</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Subqueries are not supported to be directly embedded into expressions but instead have to be built with the builder API.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are multiple different entry methods to cover all possible usage scenarios. The entry methods are mostly named after the clause in which they are defined
e.g. in the <code>WHERE</code> clause the entry methods are named <code>where()</code>, <code>whereExists()</code> etc.
The following list of possible entry methods refers to <code>WHERE</code> clause entry methods for easier readability.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/WhereBuilder.html#where(java.lang.String)"><code>where(String expression)</code></a></dt>
<dd>
<p>Starts a builder for a predicate with the given expression on the left hand side.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("name").eq("Felix");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereExists()"><code>whereExists()</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereNotExists()"><code>whereNotExists()</code></a></dt>
<dd>
<p>Starts a subquery builder for an exists predicate.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereExists()
        .from(Cat.class, "subCat")
        .select("1")
        .where("subCat").notEqExpression("cat")
        .where("subCat.name").eqExpression("cat.name")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE EXISTS (SELECT 1 FROM Cat subCat WHERE subCat &lt;&gt; cat AND subCat.name = cat.name)</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereCase()"><code>whereCase()</code></a></dt>
<dd>
<p>Starts a general case when builder for a predicate with the resulting case when expression on the left hand side.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereCase()
        .when("cat.name").isNull()
            .then(1)
        .when("LENGTH(cat.name)").gt(10)
            .then(2)
        .otherwise(3)
    .eqExpression(":someValue");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE CASE
      WHEN cat.name IS NULL THEN :param_1
      WHEN LENGTH(cat.name) &gt; 10 THEN :param_2
      ELSE :param_3
      END = :someValue</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereSimpleCase(java.lang.String)"><code>whereSimpleCase(String expression)</code></a></dt>
<dd>
<p>Starts a general case when builder for a predicate with the resulting case when expression on the left hand side.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereSimpleCase("SUBSTRING(cat.name, 1, 2)")
        .when("'Dr.'", "'Doctor'")
        .when("'Mr'", "'Mister'")
        .otherwise("'Unknown'")
    .notEqExpression("cat.fullTitle");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE CASE SUBSTRING(cat.name, 1, 2)
      WHEN 'Dr.' THEN 'Doctor'
      WHEN 'Mr.' THEN 'Mister'
      ELSE 'Unknown'
      END &lt;&gt; cat.fullTitle</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereSubquery()"><code>whereSubquery()</code></a></dt>
<dd>
<p>Starts a subquery builder for a predicate with the resulting subquery expression on the left hand side.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereSubquery()
        .from(Cat.class, "subCat")
        .select("subCat.name")
        .where("subCat.id").eq(123)
    .end()
    .eqExpression("cat.name");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE (SELECT subCat.name FROM Cat subCat WHERE subCat.id = :param_1) = cat.name</pre>
</div>
</div>
<div id="anchor_predicate_builder_subqueries" class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereSubquery(java.lang.String,%20java.lang.String)"><code>whereSubquery(String subqueryAlias, String expression)</code></a></dt>
<dd>
<p>Like <code>whereSubquery()</code> but instead the <code>expression</code> is used on the left hand side. Occurrences of subqueryAlias in the expression will be replaced by the subquery expression.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereSubquery("subQuery1", "subQuery1 + 10")
        .from(Cat.class, "subCat")
        .select("subCat.age")
        .where("subCat.id").eq(123)
    .end()
    .gt(10);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE (SELECT subCat.age FROM Cat subCat WHERE subCat.id = :param_1) + 10 &gt; 10</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseWhereBuilder.html#whereSubqueries(java.lang.String)"><code>whereSubqueries(String expression)</code></a></dt>
<dd>
<p>Starts a subquery builder capable of handling multiple subqueries and uses the given <code>expression</code> on the left hand side of the predicate.
Subqueries are started with <code>with(String subqueryAlias)</code> and aliases occurring in the expression will be replaced by the respective subquery expressions.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereSubqueries("subQuery1 + subQuery2")
        .with("subQuery1")
            .from(Cat.class, "subCat")
            .select("subCat.age")
            .where("subCat.id").eq(123)
        .end()
        .with("subQuery2")
            .from(Cat.class, "subCat")
            .select("subCat.age")
            .where("subCat.id").eq(456)
        .end()
    .end()
    .gt(10);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE (SELECT subCat.age FROM Cat subCat WHERE subCat.id = :param_1)
      + (SELECT subCat.age FROM Cat subCat WHERE subCat.id = :param_2) &gt; 10</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/WhereBuilder.html#whereOr()"><code>whereOr()</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/WhereOrBuilder.html#whereAnd()"><code>whereAnd()</code></a></dt>
<dd>
<p>Starts a builder for a nested compound predicate. Elements of that predicate are connected with <code>OR</code> or <code>AND</code> respectively.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .whereOr()
        .where("cat.name").isNull()
        .whereAnd()
            .where("LENGTH(cat.name)").gt(10)
            .where("cat.name").like().value("F%").noEscape()
        .endAnd()
    .endOr();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.name IS NULL OR LENGTH(cat.name) &gt; :param_1 AND cat.name LIKE :param_2</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/WhereBuilder.html#setWhereExpression(java.lang.String)"><code>setWhereExpression(String expression)</code></a></dt>
<dd>
<p>Sets the <code>WHERE</code> clause to the given JPQL predicate expression overwriting existing predicates.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .setWhereExpression("cat.name IS NULL OR LENGTH(cat.name) &gt; 10 AND cat.name LIKE 'F%'");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.name IS NULL OR LENGTH(cat.name) &gt; 10 AND cat.name LIKE 'F%'</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/WhereBuilder.html#setWhereExpressionSubqueries(java.lang.String)"><code>setWhereExpressionSubqueries(String expression)</code></a></dt>
<dd>
<p>A combination of <code>setWhereExpression</code> and <code>whereSubqueries</code>. Sets the <code>WHERE</code> clause to the given JPQL predicate expression overwriting existing predicates. Subqueries replace aliases in the expression.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .setWhereExpressionSubqueries("cat.name IS NULL AND subQuery1 + subQuery2 &gt; 10")
        .with("subQuery1")
            .from(Cat.class, "subCat")
            .select("subCat.age")
            .where("subCat.id").eq(123)
        .end()
        .with("subQuery2")
            .from(Cat.class, "subCat")
            .select("subCat.age")
            .where("subCat.id").eq(456)
        .end()
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.name IS NULL
  AND (SELECT subCat.age FROM Cat subCat WHERE subCat.id = :param_1)
      + (SELECT subCat.age FROM Cat subCat WHERE subCat.id = :param_2) &gt; 10</pre>
</div>
</div>
<div class="sect2">
<h3 id="restriction-builder"><a class="anchor" href="#restriction-builder"></a>4.1. Restriction Builder</h3>
<div class="paragraph">
<p>The restriction builder is used to build a predicate for an existing left hand side expression and chains to the right hand side expression.
It supports all standard predicates from JPQL and expressions can be of the following types:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Value/Parameter</dt>
<dd>
<p>The actual value will be registered as parameter value and a named parameter expression will be added instead.
Methods that accept values typical accept arguments of type <code>Object</code>.</p>
</dd>
<dt class="hdlist1">Expression</dt>
<dd>
<p>A JPQL scalar expression can be anything. A path expression, literal, parameter expression, etc.</p>
</dd>
<dt class="hdlist1">Subquery</dt>
<dd>
<p>A subquery is always created via a subquery builder. Variants for replacing aliases in expressions with subqueries also exist.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Available predicates</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#between(java.lang.Object)"><code>BETWEEN</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#notBetween(java.lang.Object)"><code>NOT BETWEEN</code></a></dt>
<dd>
<p>The <code>between</code> methods expect the <strong>start value</strong> and chain to the between builder which is terminated with the <strong>end value</strong>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.age").between(1).and(10)
    .where("cat.age").notBetween(5).and(6);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.age     BETWEEN :param_1 AND :param_2
  AND cat.age NOT BETWEEN :param_3 AND :param_4</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#eq(java.lang.Object)"><code>EQ</code></a>, <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#notEq(java.lang.Object)"><code>NOT EQ</code></a>, <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#lt(java.lang.Object)"><code>LT</code></a>, <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#le(java.lang.Object)"><code>LE</code></a>, <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#gt(java.lang.Object)"><code>GT</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#ge(java.lang.Object)"><code>GE</code></a></dt>
<dd>
<p>The comparison predicates additionally support quantified subqueries e.g. <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/QuantifiableBinaryPredicateBuilder.html#all()"><code>ALL</code></a>
and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/QuantifiableBinaryPredicateBuilder.html#any()"><code>ANY</code></a>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.age").notEq(10)
    .where("cat.age").ge().all()
        .from(Cat.class, "subCat")
        .select("subCat.age")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.age &lt;&gt; :param_1
  AND cat.age &gt;= ALL(
      SELECT subCat.age
      FROM Cat subCat
  )</pre>
</div>
</div>
<div id="anchor_predicate_builder_in_predicate" class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#in(java.lang.Object&#8230;&#8203;)"><code>IN</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#notIn(java.lang.Object&#8230;&#8203;)"><code>NOT IN</code></a></dt>
<dd>
<p>This predicate supports value collections, literal expressions or in case of a single parameter expression, that parameter expression can be a collection valued parameter.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.age").in(1, 2, 3, 4)
    .where("cat.age").notIn()
        .from(Cat.class, "subCat")
        .select("subCat.age")
        .where("subCat.name").notEqExpression("cat.name")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.age IN (:param_1, :param_2, :param_3, :param_4)
  AND cat.age NOT IN(
      SELECT subCat.age
      FROM Cat subCat
      WHERE subCat.name &lt;&gt; cat.name
  )</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#isNull()"><code>IS NULL</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#isNotNull()"><code>IS NOT NULL</code></a></dt>
<dd>
<p>A simple null check.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.age").isNotNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.age IS NOT NULL</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#isEmpty()"><code>IS EMPTY</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#isNotEmpty()"><code>IS NOT EMPTY</code></a></dt>
<dd>
<p>Checks if the left hand side is empty. Only valid for path expressions that evaluate to collections.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.kittens").isNotEmpty();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.kittens IS NOT EMPTY</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#isMemberOf(java.lang.String)"><code>MEMBER OF</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#isNotMemberOf(java.lang.String)"><code>NOT MEMBER OF</code></a></dt>
<dd>
<p>Checks if the left hand side is a member of the collection typed path expression.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.father").isNotMemberOf("cat.kittens");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.father NOT MEMBER OF cat.kittens</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#like()"><code>LIKE</code></a> &amp; <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/RestrictionBuilder.html#notLike()"><code>NOT LIKE</code></a></dt>
<dd>
<p>A <code>LIKE</code> with specifiable case sensitivity that must be terminated finally with an escape character or <code>noEscape()</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.name").like().value("Bill%").noEscape()
    .where("cat.name").notLike(false).expression("'%abc%'").noEscape();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.name LIKE :param_1
  AND UPPER(cat.name) NOT LIKE UPPER('%abc%')</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor_predicate_builder_case_when"><a class="anchor" href="#anchor_predicate_builder_case_when"></a>4.2. Case When Expression Builder</h3>
<div class="paragraph">
<p>The binary predicates <code>EQ</code>, <code>NOT EQ</code>, <code>LT</code>, <code>LE</code>, <code>GT</code> &amp; <code>GE</code> also allow to create case when expressions for the right hand side via a builder API.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .where("cat.name").eq()
        .caseWhen("cat.father").isNotNull()
            .thenExpression("cat.father.name")
        .caseWhen("cat.mother").isNotNull()
            .thenExpression("cat.mother.name")
        .otherwise("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN cat.father father_1
LEFT JOIN cat.mother mother_1
WHERE cat.name = CASE
    WHEN father_1 IS NOT NULL
        THEN father_1.name
    WHEN mother_1 IS NOT NULL
        THEN mother_1.name
    ELSE
        :param_1
    END</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="where-clause"><a class="anchor" href="#where-clause"></a>5. Where clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>WHERE</code> clause has mostly been described already in the <a href="#predicate-builder">Predicate Builder</a> chapter.
The clause is applicable to all statement types, but <a href="#implicit-joins">implicit joins</a> are only possible in <code>SELECT</code> statements,
therefore it is advised to move relation access to an exists subquery in DML statements like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.update(em, Cat.class, "c")
    .setExpression("age", "age + 1")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("subCat.id").eqExpression("c.id")
        .where("subCat.father.name").like().value("Bill%").noEscape()
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>Which will roughly render to the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat c
SET c.age = c.age + 1
WHERE EXISTS(
    SELECT 1
    FROM Cat subCat
    LEFT JOIN subCat.father father_1
    WHERE subCat.id = c.id
      AND father_1.name LIKE :param_1
)</pre>
</div>
</div>
<div class="sect2">
<h3 id="keyset-pagination-support"><a class="anchor" href="#keyset-pagination-support"></a>5.1. Keyset pagination support</h3>
<div class="paragraph">
<p>Keyset pagination or scrolling/filtering is way to efficiently paginate or scroll through a large data set.
The idea of a keyset is, that every tuple can be uniquely identified by that keyset. Pagination only makes sense when the tuples in a data set are ordered
and keyset pagination in contrast to offset pagination makes efficient use of the ordering property of the data set.
By remembering the highest and lowest keysets of a page, it is possible to query the previous and next pages efficiently.</p>
</div>
<div class="paragraph">
<p>Apart from the <a href="#keyset-pagination">transparent keyset pagination support</a>, it is also possible to implement keyset scrolling/filtering manually.
A keyset consists of the values of the <code>ORDER BY</code> expressions of a tuple and the last expression must uniquely identify a tuple.
The id of an entity is not only a good candidate in general for the last expression, but also currently the only possible expression to satisfy this constraint.</p>
</div>
<div class="paragraph">
<p>The following query will order cats by their birthday and second by their id.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class, "cat")
    .orderByAsc("cat.birthday")
    .orderByAsc("cat.id")</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
ORDER BY cat.birthday ASC, cat.id ASC</pre>
</div>
</div>
<div class="sect3">
<h4 id="positional-keyset-pagination"><a class="anchor" href="#positional-keyset-pagination"></a>5.1.1. Positional keyset pagination</h4>
<div class="paragraph">
<p>In order to receive only the first 10 cats you would do</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; cats = cb.setMaxResults(10)
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>In order to receive the next cats after the last seen cat (highest keyset) with positional keyset elements you would do</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat lastCat = cats.get(cats.size() - 1);
List&lt;Cat&gt; nextCats = cb.afterKeyset(lastCat.getBirthday(), lastCat.getId())
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>which roughly translates to the following JPQL</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.birthday &gt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &gt; :_keysetParameter_1
)
ORDER BY cat.birthday ASC NULLS LAST, cat.id ASC NULLS LAST</pre>
</div>
</div>
<div class="paragraph">
<p>The positional part roughly means that the keyset element as passed into <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetQueryBuilder.html#afterKeyset(java.io.Serializable&#8230;&#8203;)">afterKeyset()</a>
or <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetQueryBuilder.html#beforeKeyset(java.io.Serializable&#8230;&#8203;)">beforeKeyset()</a> must match the order of the corresponding <code>ORDER BY</code> expressions.</p>
</div>
<div class="paragraph">
<p>Note that this is in general much more efficient than an <code>OFFSET</code> based paging/scrolling because this approach can <em>scroll</em> to the next and previous page in <code>O(log n)</code>,
whereas using <code>OFFSET</code> results in a complexity of <code>O(n)</code>, thus making it harder to get to latter pages in big data sets.
This is due to how a keyset paginated query can efficiently traverse an index on the DBMS side. Using <code>OFFSET</code> paging requires actually counting tuples that should be skipped which is less efficient.</p>
</div>
<div class="paragraph">
<p>Similarly to scrolling to a page that comes <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetQueryBuilder.html#afterKeyset(java.io.Serializable&#8230;&#8203;)">after a keyset</a>,
it is also possible to scroll to a page that comes <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetQueryBuilder.html#beforeKeyset(java.io.Serializable&#8230;&#8203;)">before a keyset</a></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat firstCat = nextCats.get(0);
List&lt;Cat&gt; previousCats = cb.beforeKeyset(firstCat.getBirthday(), firstCat.getId())
    .getResultList();
// cats and previousCats are equal</pre>
</div>
</div>
<div class="paragraph">
<p>but this time the JPQL looks differently</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat
WHERE cat.birthday &lt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &lt; :_keysetParameter_1
)
ORDER BY cat.birthday DESC NULLS FIRST, cat.id DESC NULLS FIRST</pre>
</div>
</div>
<div class="paragraph">
<p>This is how keyset pagination works, but still, the DBMS can use the same index as before. This time, it just traverses it backwards!</p>
</div>
</div>
<div class="sect3">
<h4 id="expression-based-keyset-pagination"><a class="anchor" href="#expression-based-keyset-pagination"></a>5.1.2. Expression based keyset pagination</h4>
<div class="paragraph">
<p>This is just like <a href="#positional-keyset-pagination">positional keyset pagination</a> but instead of relying on the order of keyset elements and <code>ORDER BY</code> expressions,
this makes use of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetBuilder.html"><code>KeysetBuilder</code></a> which matches by the expression.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat firstCat = nextCats.get(0);
List&lt;Cat&gt; previousCats = cb.beforeKeyset()
        .with("cat.birthday", firstCat.getBirthday())
        .with("cat.id", firstCat.getId())
    .end()
    .getResultList();
// cats and previousCats are equal</pre>
</div>
</div>
<div class="paragraph">
<p>This results in the same JPQL as seen above. It&#8217;s a matter of taste which style to choose.</p>
</div>
</div>
<div class="sect3">
<h4 id="keyset-page-based-keyset-pagination"><a class="anchor" href="#keyset-page-based-keyset-pagination"></a>5.1.3. Keyset page based keyset pagination</h4>
<div class="paragraph">
<p>When using the <a href="#keyset-pagination">transparent keyset pagination support</a> through the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#page(int,%20int)"><code>PaginatedQueryBuilder</code></a> API
with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html#withKeysetExtraction(boolean)">keyset extraction</a> it is possible to get access to an extracted
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PagedList.html#getKeysetPage()"><code>KeysetPage</code></a> and thus also to the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetPage.html#getHighest()">highest</a>
and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetPage.html#getLowest()">lowest</a> keysets.</p>
</div>
<div class="paragraph">
<p>These keysets can also be used for paging/scrolling although when already having access to a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetPage.html"><code>KeysetPage</code></a> it might be better to use the
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedQueryBuilder.html"><code>PaginatedQueryBuilder</code></a> API instead.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="group-by-and-having-clause"><a class="anchor" href="#group-by-and-having-clause"></a>6. Group by and having clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>GROUP BY</code> and <code>HAVING</code> clause are closely. Logically the <code>HAVING</code> clause is evaluated after the <code>GROUP BY</code> clause.
A <code>HAVING</code> clause does not make sense without a <code>GROUP BY</code> clause.</p>
</div>
<div class="sect2">
<h3 id="group-by"><a class="anchor" href="#group-by"></a>6.1. Group by</h3>
<div class="paragraph">
<p>When a <code>GROUP BY</code> clause is used, most DBMS require that every non-aggregate expression that appears in the following clauses must also appear in the <code>GROUP BY</code> clause</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SELECT</code></p>
</li>
<li>
<p><code>ORDER BY</code></p>
</li>
<li>
<p><code>HAVING</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is due to the fact that these clauses are logically executed after the <code>GROUP BY</code> clause.
Some DBMS even go as far as not allowing expressions of a certain complexity in the <code>GROUP BY</code> clause. For such expressions,
the property/column references have to be extracted and put into the <code>GROUP BY</code> clause instead, so that the composite expressions can be built after grouping.</p>
</div>
<div class="paragraph">
<p>By default, the use of complex expressions is allowed in <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/GroupByBuilder.html#groupBy(java.lang.String)"><code>groupBy()</code></a>,
but can be disabled by turning on the <a href="#compatible_mode">compatible mode</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OpenJPA only supports path expressions and simple function expression in the <code>GROUP BY</code> clause
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently it is not possible to have a custom <code>GROUP BY</code> and thus also <code>HAVING</code> clause when using the <code>PaginatedCriteriaBuilder</code> API. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/194">#194</a>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="implicit-group-by-generation"><a class="anchor" href="#implicit-group-by-generation"></a>6.1.1. Implicit group by generation</h4>
<div class="paragraph">
<p>Fortunately all these issues with different DBMS and the <code>GROUP BY</code> clause is handled by Blaze Persistence through implicit group by generation.
Implicit group by generation adds just the expressions that are necessary for a query to work on a DBMS without changing it&#8217;s semantics.
The generation will kick in as soon as</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>GROUP BY</code> clause is used</p>
</li>
<li>
<p>An aggregate function is used</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you don&#8217;t like the group by generation or you run into a bug, you can always disable it on a per-query and per-clause basis if you like.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#implicit_group_by_from_select">Property for <code>SELECT</code> clause</a></p>
</li>
<li>
<p><a href="#implicit_group_by_from_having">Property for <code>HAVING</code> clause</a></p>
</li>
<li>
<p><a href="#implicit_group_by_from_order_by">Property for <code>ORDER BY</code> clause</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("COUNT(*)");</pre>
</div>
</div>
<div class="paragraph">
<p>This will result in the following JPQL query</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.age, COUNT(*)
FROM Cat cat
GROUP BY cat.age</pre>
</div>
</div>
<div class="paragraph">
<p>The grouping is done based on the non-aggregate expressions, in this case, it is just the <code>age</code> of the cat.
If you disabled the implicit group by generation for the <code>SELECT</code> clause, the <code>GROUP BY</code> clause would be missing and you&#8217;d have to add it manually like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("COUNT(*)")
    .groupBy("age");</pre>
</div>
</div>
<div class="paragraph">
<p>which isn&#8217;t too painful at first, but can get quite cumbersome when having many expressions.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not using implicit group by generation for the <code>HAVING</code> clause when using non-trivial expression like e.g. <code>age + 1</code> might lead to problems on some DBMS. MySQL for example can only handle column references in the <code>GROUP BY</code> and doesn&#8217;t match complex expressions for the <code>HAVING</code> clause.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Subqueries are generally not allowed in the <code>GROUP BY</code> clause, thus correlated properties/columns have to be extracted. Implicit group by generation also takes care of that.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Due to the fact that subqueries are not allowed, the <code>SIZE()</code> function can&#8217;t be used in this clause.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="group-by-entity"><a class="anchor" href="#group-by-entity"></a>6.1.2. Group by Entity</h4>
<div class="paragraph">
<p>Although the JPA spec mandates that a JPA provider must support grouping by an entity, it is apparently not asserted by the JPA TCK.
Some implementations don&#8217;t support this feature which is why Blaze Persistence expands an entity in the <code>GROUP BY</code> clause automatically for you.</p>
</div>
<div class="paragraph">
<p>This also works when relying on implicit group by generation i.e.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "c")
    .leftJoin("c.kittens", "kitty")
    .select("c")
    .select("COUNT(*)");</pre>
</div>
</div>
<div class="paragraph">
<p>will result in the following <em>logical</em> JPQL query</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT c, COUNT(*)
FROM Cat c
LEFT JOIN c.kittens kitty
GROUP BY c</pre>
</div>
</div>
<div class="paragraph">
<p>but will expand <code>c</code> to all singular attributes of it&#8217;s type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate still lacks support for this <a href="https://hibernate.atlassian.net/browse/HHH-1615">feature</a> which is one of the reasons for doing the expansion within Blaze Persistence
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="having-clause"><a class="anchor" href="#having-clause"></a>6.2. Having clause</h3>
<div class="paragraph">
<p>The <code>HAVING</code> clause is similar to the <a href="#where_clause"><code>WHERE</code> clause</a> and most of the inner workings are described in the <a href="#predicate-builder">Predicate Builder</a> chapter.
The only difference is that the <code>HAVING</code> clause in contrast to the <code>WHERE</code> clause can contain aggregate functions and is logically executed after the <code>GROUP BY</code> clause.</p>
</div>
<div class="paragraph">
<p>The API for using the <code>HAVING</code> clause is the same as for the <code>WHERE</code> clause, except that it uses <code>having</code> instead of the <code>where</code> prefix.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("COUNT(*)")
    .groupBy("age")
    .having("COUNT(*)").gt(2);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.age, COUNT(*)
FROM Cat cat
GROUP BY cat.age
HAVING COUNT(*) &gt; :param_1</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anchor-order-by-clause"><a class="anchor" href="#anchor-order-by-clause"></a>7. Order by clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An <code>ORDER BY</code> clause can be used to order the underlying result list.
Depending on the mapping and the collection type in an entity, the order of elements contained in collection may or may not be preserved.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Contrary to what the JPA spec allows, Blaze Persistence also allows to use the <code>ORDER BY</code> clause in subqueries.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the use of complex expressions is allowed in <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/OrderByBuilder.html#orderBy(java.lang.String,%20boolean,%20boolean)"><code>orderBy()</code></a>,
but can be disabled by turning on the <a href="#compatible_mode">compatible mode</a>.</p>
</div>
<div class="paragraph">
<p>Also note that by default, Blaze Persistence chose to use the <code>NULLS LAST</code> behavior instead of relying on the DBMS default, in order to provide better portability.
It is strongly advised to always define the <em>null precedence</em> in order to get deterministic results.</p>
</div>
<div class="paragraph">
<p>For convenience Blaze Persistence also offers you shorthand methods for ordering <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/OrderByBuilder.html#orderByAsc(java.lang.String)">ascending</a>
or <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/OrderByBuilder.html#orderByDesc(java.lang.String)">descending</a> that make use of the default <em>null precedence</em>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("id")
    .orderByAsc("age")
    .orderByDesc("id");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.age, cat.id
FROM Cat cat
ORDER BY
    cat.age ASC NULLS LAST,
    cat.id DESC NULLS LAST</pre>
</div>
</div>
<div class="paragraph">
<p>Apart from specifying the expression itself for an <code>ORDER BY</code> element, you can also refer to a select alias.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is also the only way to order by the result of a subquery. Many DBMS do not support the occurrence of a subquery in <code>ORDER BY</code> directly, so Blaze Persistence dos not allow to do that either.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .selectSubquery("olderCatCount")
        .from(Cat.class, "subCat")
        .select("COUNT(*)")
        .where("subCat.age").gtExpression("cat.age")
    .end()
    .select("id")
    .orderByAsc("olderCatCount")
    .orderByDesc("id");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCat.age &gt; cat.age
    ) AS olderCatCount,
    cat.id
FROM Cat cat
ORDER BY
    olderCatCount ASC NULLS LAST,
    cat.id DESC NULLS LAST</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="select-clause"><a class="anchor" href="#select-clause"></a>8. Select clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>SELECT</code> clause can be used to specify projections that should be returned by a query.
Blaze Persistence completely aligns with JPQL regarding the support of the <code>SELECT</code> clause,
except for constructor expressions. The reason for this is</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Since select items are defined separately, there is no easy syntax that could be supported</p>
</li>
<li>
<p>Classes that users would like to use, might not be available on the classpath</p>
</li>
<li>
<p>The use of a fully qualified class name and pass elements by position makes the query hard to read</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Instead of constructor expressions, Blaze Persistence introduces the concept of an <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ObjectBuilder.html"><code>ObjectBuilder</code></a>
which, as you will see in the <a href="#select-new-support">Select new support</a> and <a href="#object-builder">Object builder</a> chapters, are a lot mightier.</p>
</div>
<div class="paragraph">
<p>Note that by default most types of queries have a default select clause that fits most of the needs.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Query with single root</dt>
<dd>
<p>Such queries have the alias of the root as default select item which has the effect that entities of the query root type are selected.</p>
</dd>
<dt class="hdlist1">Subquery in <code>EXISTS</code></dt>
<dd>
<p>Uses the scalar value <code>1</code> as default select item.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The defaults are replaced by the first call to one of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectBuilder.html#select(java.lang.String)"><code>select()</code></a> variants.</p>
</div>
<div class="sect2">
<h3 id="distinct-support"><a class="anchor" href="#distinct-support"></a>8.1. Distinct support</h3>
<div class="paragraph">
<p>Distinct can be applied on any query by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/DistinctBuilder.html#distinct()"><code>distinct()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .distinct()
    .select("age");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT DISTINCT cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently it is not possible to do a distinct when using the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a> API.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to that, all aggregate functions as defined per JPQL support aggregating distinct values.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("COUNT(DISTINCT age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(DISTINCT cat.age)
FROM Cat cat</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This even works with embedded ids with Hibernate on DBMS that don&#8217;t support a distinct count for tuple. Also see <a href="https://hibernate.atlassian.net/browse/HHH-11042">HHH-11042</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="tuple-select"><a class="anchor" href="#tuple-select"></a>8.2. Tuple select</h3>
<div class="paragraph">
<p>When selecting multiple expressions, you can decide between the query return types <code>Object[]</code> and <code>javax.persistence.Tuple</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Some persistence providers might return the object directly when having just a single select item, even if you pass <code>Object[]</code>. This will not happen when using <code>javax.persistence.Tuple</code> as query return type.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can define aliases for select items and access the tuple elements by name or by a 0-based index.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("name", "catName")
    .select("age", "catAge");
Tuple firstTuple = cb.getResultList().get(0);
// Access tuple element by alias
String name = firstTuple.get("catName", String.class);
// Access tuple element by index
Long age = firstTuple.get(1, Long.class);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.name, cat.age
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor_select_case_when"><a class="anchor" href="#anchor_select_case_when"></a>8.3. Case expressions</h3>
<div class="paragraph">
<p>The builder API for <code>CASE WHEN</code> in the <code>SELECT</code> clause is the same as for <a href="#case-when-expression-builder">predicate builders</a> except for different entry points.
All entry methods take an optional select alias too.</p>
</div>
<div class="paragraph">
<p>Although there is an API for constructing <code>CASE WHEN</code> expressions, you can also just make use of them in a normal expression of
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectBuilder.html#select(java.lang.String)"><code>select()</code></a></p>
</div>
<div class="sect3">
<h4 id="searched-case-expression-simple-case"><a class="anchor" href="#searched-case-expression-simple-case"></a>8.3.1. Searched case expression (simple case)</h4>
<div class="paragraph">
<p>Simple case expressions can be done with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectBuilder.html#selectSimpleCase(java.lang.String)"><code>selectSimpleCase()</code></a>
and support matching a case expression by equality with an expression for every <code>WHEN</code> branch.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .selectSimpleCase("SUBSTRING(cat.name, 1, 2)")
        .when("'Dr'", "'Doctor'")
        .when("'Mr'", "'Mister'")
        .otherwise("'Unknown'")
    .select("cat.age");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    CASE SUBSTRING(cat.name, 1, 2)
          WHEN 'Dr.' THEN 'Doctor'
          WHEN 'Mr.' THEN 'Mister'
          ELSE 'Unknown'
    END,
    cat.age
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="conditional-case-expression"><a class="anchor" href="#conditional-case-expression"></a>8.3.2. Conditional case expression</h4>
<div class="paragraph">
<p>The more general form of a <code>CASE WHEN</code> supports arbitrary conditions in the <code>WHEN</code> part.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .selectCase()
        .when("cat.name").isNull()
            .then(1)
        .when("LENGTH(cat.name)").gt(10)
            .then(2)
        .otherwise(3)
    .select("cat.age");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    CASE
          WHEN cat.name IS NULL THEN :param_1
          WHEN LENGTH(cat.name) &gt; 10 THEN :param_2
          ELSE :param_3
    END,
    cat.age
FROM Cat cat</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="subqueries"><a class="anchor" href="#subqueries"></a>8.4. Subqueries</h3>
<div class="paragraph">
<p>Although the JPA spec does mandate support for subqueries in the <code>SELECT</code> clause, every major JPA provider <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectBuilder.html#selectSubquery()">supports it</a>,
which is why Blaze Persistence also allows it. A subquery is the only type of expression that has to be created through the builder API, all other expressions can be created by passing the expression as string.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .selectSubquery()
        .from(Cat.class, "subCat")
        .select("COUNT(*)")
        .where("subCat.age").gtExpression("cat.age")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCa.age &gt; cat.age
    )
FROM Cat cat</pre>
</div>
</div>
<div class="sect3">
<h4 id="anchor_select_subqueries"><a class="anchor" href="#anchor_select_subqueries"></a>8.4.1. Wrapping expression</h4>
<div class="paragraph">
<p>Sometimes you might want to have more complex expressions that contain one or multiple subqueries. For such cases there are variants that accept</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a single subquery through <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectBuilder.html#selectSubquery(java.lang.String,%20java.lang.String)"><code>selectSubquery(String, String)</code></a></p>
</li>
<li>
<p>multiple subqueries through <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SelectBuilder.html#selectSubqueries(java.lang.String)"><code>selectSubqueries(String)</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The single subquery variant requires a temporary alias for the subquery and an expression containing it. Every occurrence of the so called <code>subqueryAlias</code> will be replaced logically by the subquery itself.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .selectSubquery("mySubqueryAlias", "1 + mySubqueryAlias")
        .from(Cat.class, "subCat")
        .select("COUNT(*)")
        .where("subCat.age").gtExpression("cat.age")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    1 + (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCa.age &gt; cat.age
    )
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the subquery alias <code>mySubqueryAlias</code> in the expression <code>1 + mySubqueryAlias</code> has been replaced by the subquery.</p>
</div>
<div class="paragraph">
<p>The multiple subquery variant is very similar, except that you first have to define the expression i.e. <code>1 + mySubqueryAlias1 + mySubqueryAlias2</code> and then,
subsequently define for each alias the respective subquery.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .selectSubqueries("1 + mySubqueryAlias1 + mySubqueryAlias2")
        .with("mySubqueryAlias1")
            .from(Cat.class, "subCat")
            .select("COUNT(*)")
            .where("subCat.age").gtExpression("cat.age")
        .end()
        .with("mySubqueryAlias2")
            .from(Cat.class, "subCat")
            .select("COUNT(*)")
            .where("subCat.age").ltExpression("cat.age")
        .end()
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    1 + (
        SELECT COUNT(*)
        FROM Cat subCat
        WHERE subCa.age &gt; cat.age
    ) + (
         SELECT COUNT(*)
         FROM Cat subCat
         WHERE subCa.age &lt; cat.age
     )
FROM Cat cat</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="select-new-support"><a class="anchor" href="#select-new-support"></a>8.5. Select new support</h3>
<div class="paragraph">
<p>Like already explained in the <a href="#select-clause">beginning</a>, constructor expressions are supported differently in Blaze Persistence.
Instead of having to use the fully qualified class name in the query, Blaze Persistence offers a concept called <a href="#object-builder">Object builder</a>.
On top of that API, it implements features similar to the constructor expression of JPQL.</p>
</div>
<div class="paragraph">
<p>The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#selectNew(java.lang.reflect.Constructor)"><code>selectNew(Constructor)</code></a> variant is probably the one that comes closest
to the constructor expression. That method allows to pass in a constructor object which will be used to construct objects when building the result list.
The argument types of the constructor must match the types of the select items.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">class CatModel {

    public CatModel(String name, Long age) {
        //...
    }
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;CatModel&gt; cb = cbf.create(em, Tuple.class)  <i class="conum" data-value="1"></i><b>(1)</b>
    .from(Cat.class, "cat")
    .selectNew(CatModel.class.getConstructor(String.class, Long.class))  <i class="conum" data-value="2"></i><b>(2)</b>
        .with("cat.name")
        .with("cat.age")
    .end();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Query type is <code>Tuple</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Query type changed to <code>CatModel</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See how the query type changed because of the call to <code>selectNew()</code>?
The JPQL contains no information about the constructor, just the scalar selects.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.name, cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>Having to explicitly declare the parameter types for retrieving the constructor is not very convenient. That&#8217;s why there is the variant which accepts the <code>Class</code> instead.
That way the constructor selection is deferred to the runtime and is done based on the tuple elements types. The selection is done once based on the types of the first tuple.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;CatModel&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .selectNew(CatModel.class)
        .with("cat.name")
        .with("cat.age")
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>Not only looks like the one from before, but also does the same. It&#8217;s just less code that is required.
The only difference is the point in time where errors can happen. By choosing an explicit constructor at query building time,
errors like non-accessible or non-existing constructors can show up earlier. By using the <code>Class</code> approach, errors would only show up when processing the query results.
This behavior might change in the future i.e. due to improvements we might be able to determine the constructor already at query building time. Such a behavior could then of course be disabled if required.</p>
</div>
</div>
<div class="sect2">
<h3 id="object-builder"><a class="anchor" href="#object-builder"></a>8.6. Object builder</h3>
<div class="paragraph">
<p>As mentioned before, the <code>selectNew()</code> approaches with <code>Class</code> and <code>Constructor</code> both build on top of the more general approach of <code>ObjectBuilder</code>.
An <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ObjectBuilder.html"><code>ObjectBuilder</code></a> instance can be provided to a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilder.html"><code>CriteriaBuilder</code></a>
and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#selectNew(com.blazebit.persistence.ObjectBuilder)"><code>selectNew(ObjectBuilder)</code></a>.</p>
</div>
<div class="paragraph">
<p>It is responsible for</p>
</div>
<div class="ulist">
<ul>
<li>
<p>providing the JPQL expressions for select items</p>
</li>
<li>
<p>build objects of the target type from an object array representing the tuple for the select items</p>
</li>
<li>
<p>reduce the result list or simply return it</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example should illustrate the functionality</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;CatModel&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .selectNew(new ObjectBuilder&lt;CatModel&gt;() {

        @Override
        public &lt;X extends SelectBuilder&lt;X&gt;&gt; void applySelects(X queryBuilder) {
            queryBuilder
                .select("name")
                .select("age");
        }

        @Override
        public CatModel build(Object[] tuple) {
            return new CatModel(
                (String) tuple[0],
                (Long)   tuple[1]
            );
        }

        @Override
        public List&lt;CatModel&gt; buildList(List&lt;CatModel&gt; list) {
            return list;
        }
    });</pre>
</div>
</div>
<div class="paragraph">
<p>Looks like boilerplate for this simple query?</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.name, cat.age
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>You are right, but keep in mind, this isn&#8217;t an API that a simple user should directly implement.
This API allows to keep the select item providing and consuming parts together, but decouple it from the actual query.
You can have one <code>ObjectBuilder</code> for multiple queries of the same query root.</p>
</div>
<div class="paragraph">
<p>In real life applications it is often required to have some sort of <em>view model</em> i.e. a model specifically for the UI.
Without an API that allows to decouple the projection from the rest, you would</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duplicate querying code and adapt only necessary projection parts</p>
</li>
<li>
<p>Implement dynamic queries through string concatenation and essentially implement a custom query builder</p>
</li>
<li>
<p>Stick with using just the entity model and try to cope with limitations and problems</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ObjectBuilder</code> API helps you in all these regards</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No need to copy querying code, only need to make use of object builders and depending on the needs, use a different builder</p>
</li>
<li>
<p>Blaze Persistence already is a dynamic query builder API and strictly works with the JPA metamodel to catch errors early</p>
</li>
<li>
<p>As long as you stick to using basic values lazy loading won&#8217;t bite you</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although this simple example doesn&#8217;t do anything fancy in <code>buildList()</code>, you could do anything in there</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build nested structures</p>
</li>
<li>
<p>Filter/Sort objects</p>
</li>
<li>
<p>Query other data stores</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The best example for a consumer of this API is the <a href="https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html">entity-view</a> module which makes use of the <code>ObjectBuilder</code> interface to implement efficient projection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Before you start building a sophisticated <code>ObjectBuilder</code>, take a look at <a href="https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html">entity views</a> to see if it fits your needs.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="polymorphism"><a class="anchor" href="#polymorphism"></a>9. Polymorphism</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In JPA, every query is by default polymorphic. This means that whenever a <code>FROM</code> clause element might have subtypes, all subtypes are queried.
The JPA spec only requires providers to support polymorphic querying for entity types, but some providers allow querying also for non-managed types like interfaces.
Querying an interface is like querying all entities that implement that particular interface.</p>
</div>
<div class="paragraph">
<p>JPA 2.1 introduced the <code>TREAT</code> operator to downcast a polymorphic <code>FROM</code> clause element to a subtype so that properties of that subtype can be accessed.
Some JPA providers implemented support for an implicit or automatic downcast, but that doesn&#8217;t always work as expected, which is why Blaze Persistence only supports explicit downcasts via the <code>TREAT</code> operator.</p>
</div>
<div class="paragraph">
<p>Unfortunately the <code>TREAT</code> operator implementations of the JPA providers often do the wrong thing. This is due to the JPA spec not being explicit enough about the expected behavior and apparently the TCK not testing enough use cases.
Blaze Persistence tries hard to workaround the problems where possible so that you can make use of the <code>TREAT</code> operator without worrying too much.
Regardless of what the JPA spec says, Blaze Persistence allows the use of the <code>TREAT</code> operator in any clause, although you should note that some providers have limitations.</p>
</div>
<div class="sect2">
<h3 id="polymorphism-treat-limitations"><a class="anchor" href="#polymorphism-treat-limitations"></a>9.1. Limitations</h3>
<div class="paragraph">
<p>Apart from Hibernate, all JPA providers have severe limitations regarding the <code>TREAT</code> operator support.
The only way to reliably workaround these limitations is to introduce separate joins for the desired subtypes.
Blaze Persistence currently does not implement a transparent translation to the described workaround, but may soon do.
Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/123">#123</a> for more information.</p>
</div>
<div class="sect3">
<h4 id="polymorphism-treat-limitations-hibernate"><a class="anchor" href="#polymorphism-treat-limitations-hibernate"></a>9.1.1. Hibernate</h4>
<div class="paragraph">
<p>Hibernate itself does not support the treat operator very well but instead has support for implicit/automatic downcasting which is very powerful.
Blaze Persistence <em>emulates</em> the <code>TREAT</code> operator on top of Hibernate by applying type constraints to surrounding predicates or wrapping in <code>CASE</code> statements.</p>
</div>
<div class="paragraph">
<p>The only problems that might arise are related to Hibernate bugs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>multiple joins to associations that use the <em>table per class</em> inheritance strategy will result in ambiguous SQL</p>
</li>
<li>
<p>treat joining relations with a type that uses the <em>table per class</em> inheritance strategy will not work because of ambiguous SQL</p>
</li>
<li>
<p>subquery correlations that use inverse mappings only work as of Hibernate 5</p>
</li>
<li>
<p>map key associations can only be de-referenced as of Hibernate 5.2.8</p>
</li>
<li>
<p>determining the type of a map key in a subquery doesn&#8217;t work</p>
</li>
<li>
<p>multiple inner treat joins of an association with a type that uses the <em>single table</em> inheritance strategy, results in <em>type constraint sharing</em></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="polymorphism-treat-limitations-eclipselink"><a class="anchor" href="#polymorphism-treat-limitations-eclipselink"></a>9.1.2. EclipseLink</h4>
<div class="paragraph">
<p>EclipseLink unfortunately does not support implicit or automatic downcasting and it&#8217;s implementation of the <code>TREAT</code> operator is partly broken.
Blaze Persistence tries to help as good as possible by throwing exceptions for usages that are known to be broken but mostly renders through the uses of the <code>TREAT</code> operator.</p>
</div>
<div class="paragraph">
<p>The following limitations and problems are known</p>
</div>
<div class="ulist">
<ul>
<li>
<p>no support for <code>TREAT</code> in subquery correlations</p>
</li>
<li>
<p>no support for <code>TREAT</code> of join alias in a join path i.e. <code>JOIN TREAT(alias AS Subtype).property</code> is not possible</p>
</li>
<li>
<p>no support for <code>TREAT</code> of join alias in a treat join path i.e. <code>JOIN TREAT(TREAT(alias AS Subtype).property AS Subtype)</code> is not possible</p>
</li>
<li>
<p>the <code>TREAT</code> operator is not supported with the <em>table per class</em> inheritance strategy</p>
</li>
<li>
<p>any use of the <code>TREAT</code> operator will result in global filter being applied <em>breaking</em> left treat join semantics</p>
</li>
<li>
<p>using the <code>TREAT</code> operator on associations of type <code>Map</code> is not supported</p>
</li>
<li>
<p>using the <code>TREAT</code> operator to downcast a join alias from an outer query is not supported</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="polymorphism-treat-limitations-datanucleus"><a class="anchor" href="#polymorphism-treat-limitations-datanucleus"></a>9.1.3. DataNucleus</h4>
<div class="paragraph">
<p>DataNucleus unfortunately does not support the <code>TREAT</code> operator in any meaningful way. It has limited support for implicit/automatic downcasting in join paths.
Blaze Persistence tries to help as good as possible by throwing exceptions for usages that are known to be broken but mostly renders through the uses of the <code>TREAT</code> operator.</p>
</div>
<div class="paragraph">
<p>The following limitations and problems are known</p>
</div>
<div class="ulist">
<ul>
<li>
<p>no support for <code>TREAT</code> in subquery correlations</p>
</li>
<li>
<p>no support for <code>TREAT</code> of join alias in a treat join path i.e. <code>JOIN TREAT(TREAT(alias AS Subtype).property AS Subtype)</code> is not possible</p>
</li>
<li>
<p>the <code>TREAT</code> operator is not supported with the <em>joined</em> inheritance strategy</p>
</li>
<li>
<p>any use of the <code>TREAT</code> operator will result in global filter being applied <em>breaking</em> left treat join semantics</p>
</li>
<li>
<p>many more issues</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="subtype-property-access"><a class="anchor" href="#subtype-property-access"></a>9.2. Subtype property access</h3>
<div class="paragraph">
<p>Every join alias and property of an alias can be polymorphic and therefore the <code>TREAT</code> operator can be applied to the expression.
Since every <code>FROM</code> element in JPA is polymorphic by default, the <code>TREAT</code> operator merely gives access to the subtype properties.
When the operator is used in an <em>expression context</em> like in a select item, the expression will return <code>NULL</code> if the treated element is not of the desired subtype.
Similarly the use of the operator in a <em>conditional context</em> like in a WHERE predicate, will make the <em>parent predicate</em> evaluate to false if the treated element is not of the desired subtype.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Every use of a <code>TREAT</code> operator has to be followed up by a de-reference i.e. <code>TREAT(alias AS Subtype)</code> is illegal, but <code>TREAT(alias AS Subtype).property</code> is legal.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following simple model</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
class Animal {
    @Id
    Long id;
    String name;
}

@Entity
class Cat extends Animal {
    String kittyName;
}

@Entity
class Dog extends Animal {
    String doggyName;
}</pre>
</div>
</div>
<div class="paragraph">
<p>For simplicity this uses <em>single table inheritance strategy</em> but applies to all strategies. Consider the following test data.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Animal</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dtype</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kittyName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">doggyName</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NULL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A query for animals and optionally selecting the <code>kittyName</code> would roughly look like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Animal.class, "a")
    .select("name")
    .select("TREAT(a AS Cat).kittyName");</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting query might look like the following, but might differ depending on the actual support of the JPA provider.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    a.name,
    CASE WHEN TYPE(a) = Cat THEN a.kittyName END
FROM Animal a</pre>
</div>
</div>
<div class="paragraph">
<p>The result list will contain <strong>2 tuples</strong>.</p>
</div>
<div class="paragraph">
<p>Querying for a specific name i.e. using the <code>kittyName</code> in the <code>WHERE</code> clause like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Animal.class, "a")
    .select("name")
    .where("TREAT(a AS Cat).kittyName").eq("A");</pre>
</div>
</div>
<div class="paragraph">
<p>will actually filter the result set by adding a type restriction predicate to the <em>parent predicate</em></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    a.name
FROM Animal a
WHERE TYPE(a) = Cat AND a.kittyName = :param_0</pre>
</div>
</div>
<div class="paragraph">
<p>The part about the parent predicate is very important. The JPA spec didn&#8217;t test for this which is why most JPA implementations got this wrong.
When the <code>TREAT</code> operator is for example used within an <em>OR</em> predicate, Blaze Persistence will handle this correctly.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Animal.class, "a")
    .select("name")
    .whereOr()
        .where("TREAT(a AS Cat).kittyName").eq("A")
        .where("a.name").eq("B")
    .endOr();</pre>
</div>
</div>
<div class="paragraph">
<p>This will correctly render to</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    a.name
FROM Animal a
WHERE (TYPE(a) = Cat AND a.kittyName = :param_0)
   OR a.name = :param_1</pre>
</div>
</div>
<div class="paragraph">
<p>which will return as expected <strong>2 tuples</strong>, the cat and the dog.</p>
</div>
<div class="paragraph">
<p>If Blaze Persistence were rendering the <code>TREAT</code> operator through to the JPA provider as is, most JPA implementations will behave as if the following query was written</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT
    a.name
FROM Animal a
WHERE TYPE(a) = Cat AND (
    a.kittyName = :param_0
 OR a.name = :param_1
)</pre>
</div>
</div>
<div class="paragraph">
<p>This will filter out the dog thus resulting in only <strong>1 tuple</strong> in the result list which is mostly undesired.</p>
</div>
</div>
<div class="sect2">
<h3 id="subtype-relation-join"><a class="anchor" href="#subtype-relation-join"></a>9.3. Subtype relation join</h3>
<div class="paragraph">
<p>Apart from accessing the properties of subtypes, JPA also specifies the use of the <code>TREAT</code> operator in a join path which allows to restrict the <em>join scope</em> and cast to specific subtypes.
A treat join is just like a normal join, except that it additionally uses a predicate like <code>TYPE(alias) = Subtype</code> in the <code>ON</code> clause condition and hints the runtime to restrict the joined tables.</p>
</div>
<div class="paragraph">
<p>Consider the following simple model</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
class Person {
    @Id
    Long id;
    String name;
    @ManyToOne
    Animal favoritePet;
}

@Entity
class Animal {
    @Id
    Long id;
    String name;
}

@Entity
class Cat extends Animal {
    String kittyName;
}

@Entity
class Dog extends Animal {
    String doggyName;
}</pre>
</div>
</div>
<div class="paragraph">
<p>For simplicity this uses <em>single table inheritance strategy</em> but applies to all strategies. Consider the following test data.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Person</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">favoritePet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">P1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">P2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">P3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Animal</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dtype</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kittyName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">doggyName</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NULL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A query for cat people would roughly look like this</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Person.class, "p")
    .select("p.name")
    .select("c.name")
    .innerJoin("TREAT(p.favoritePet AS Cat)", "c");</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting query might look like the following, but might differ depending on the actual support of the JPA provider.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT p.name, c.name
FROM Person p
JOIN TREAT(p.favoritePet AS Cat) c</pre>
</div>
</div>
<div class="paragraph">
<p>The result list will contain <strong>1 tuple</strong>, that is the cat person&#8217;s name and the name of the cat.</p>
</div>
<div class="paragraph">
<p>When doing a left treat join, all people are retained.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Person.class, "p")
    .select("p.name")
    .select("c.name")
    .leftJoin("TREAT(p.favoritePet AS Cat)", "c");</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting query might look like the following, but again might differ depending on the actual support of the JPA provider.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT p.name, c.name
FROM Person p
LEFT JOIN TREAT(p.favoritePet AS Cat) c</pre>
</div>
</div>
<div class="paragraph">
<p>The result list will contain <strong>3 tuples</strong>. Note that only the tuple of the cat person <strong>P1</strong> will have a non-null name for the <code>favoritePet</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="querying-non-managed-types"><a class="anchor" href="#querying-non-managed-types"></a>9.4. Querying non-managed types</h3>
<div class="paragraph">
<p>Currently there is no direct support for this type of querying, but this will change soon. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/204">#204</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions"><a class="anchor" href="#expressions"></a>10. Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Blaze Persistence supports almost all expressions that are also valid JPQL expressions and in addition to that also has some extensions.
Keywords are case insensitive and optional parenthesis are ignored i.e. not reflected in the expression tree model.
Expression optimizations like double invert signum and double negation simplifications can be configured via a <a href="#expression_optimization">configuration property</a> and are enabled by default.</p>
</div>
<div class="paragraph">
<p>Almost all APIs of Blaze Persistence accept expressions as strings. A few like <code>setWhereExpression(String)</code>, <code>setHavingExpression(String)</code>, <code>setOnExpression(String)</code> require predicates as strings as they replace the whole predicate.
Predicates are a subtype of expressions that produce a boolean value. Until <a href="https://github.com/Blazebit/blaze-persistence/issues/340">#340</a> is resolved, it is necessary to wrap predicates in a <code>CASE WHEN</code> expression for producing boolean values for a <code>SELECT</code> clause.</p>
</div>
<div class="sect2">
<h3 id="identification-variables"><a class="anchor" href="#identification-variables"></a>10.1. Identification variables</h3>
<div class="paragraph">
<p>Identification variables are aliases of <code>FROM</code> clause elements. Since <code>FROM</code> clause aliases and <code>SELECT</code> aliases have to be unique,
you can use <code>SELECT</code> aliases just like <code>FROM</code> clause aliases. The only exception to this are <code>ON</code> clauses of <code>FROM</code> clause elements.</p>
</div>
</div>
<div class="sect2">
<h3 id="path-expressions"><a class="anchor" href="#path-expressions"></a>10.2. Path expressions</h3>
<div class="paragraph">
<p>Path expressions use the navigation operator <code>.</code> to navigate to properties of an object. A path expression has the form of <code>identificationVariable.attribute</code>
where <code>attribute</code> is the name of an attribute which is part of the type of <code>identificationVariable</code>. Path expressions can also use multiple navigation operators like <code>identificationVariable.association.attribute</code>
where <code>association</code> is an object typed attribute. In general, the use of a navigation operator will result in a <a href="#model-awareness">model aware join</a> of the attributes.
In some cases the join will be omitted</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The attribute is not joinable i.e. it has a basic type like <code>String</code>, <code>Integer</code></p>
</li>
<li>
<p>The attribute has a managed type and is used in a predicate</p>
</li>
<li>
<p>The path is a single valued id expression and the JPA provider supports that. A single valued id expression is given when</p>
</li>
<li>
<p>The expression has the form <code>identificationVariable.association.id</code></p>
</li>
<li>
<p>The <code>association</code> is an attribute with an entity type</p>
</li>
<li>
<p>The <code>id</code> is the identifier of the association&#8217;s entity type</p>
</li>
<li>
<p>The column for the identifier is physically located in the table that is backing the type of <code>identificationVariable</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="array-expressions"><a class="anchor" href="#array-expressions"></a>10.3. Array expressions</h3>
<div class="paragraph">
<p>The array expression syntax is an extension to the JPQL grammar that allows to refer to a specific element of a collection.
Currently this is limited to associations mapped as <code>java.util.Map</code> and indexed <code>java.util.List</code> i.e. lists that use <code>@OrderColumn</code>.</p>
</div>
<div class="paragraph">
<p>A normal path expression like <code>identificationVariable.collection.name</code> will create an unconditional join for the attribute <code>collection</code> i.e. it refers to all collection elements.
An array expression like <code>identificationVariable.collection[:someParam].name</code> on the other hand joins the attribute <code>collection</code> with a <code>ON</code> clause condition <code>KEY(collection) = :someParam</code>
if the collection is a <code>java.util.Map</code> and <code>INDEX(collection) = :someParam</code> if it is a <code>java.util.List</code>. So an array expression refers to a single collection element.</p>
</div>
<div class="paragraph">
<p>Since array expressions by default use the join type <code>LEFT</code>, the expression result is either the value for the specific element or <code>NULL</code> if no collection element for the key or index exists.
The array expression syntax can be used anywhere within a path expression. Even multiple uses like this are ok <code>identificationVariable.collection1[:param1].association.collection2[:param2].attribute</code></p>
</div>
</div>
<div class="sect2">
<h3 id="treat-expressions"><a class="anchor" href="#treat-expressions"></a>10.4. Treat expressions</h3>
<div class="paragraph">
<p>Every expression in JPQL has a static type that can be determined through the metamodel. Since associations can refer to polymorphic types, it might be necessary to downcast identification variables or path expressions.
JPA 2.1 introduced the concept of a <code>TREAT</code> expression to actually downcast to a specific subtype. Blaze Persistence follows the strict rules of JPQL regarding static type resolving and thus requires the use of <code>TREAT</code> when accessing subtype properties.
A <code>TREAT</code> expression can be used in any clause and the result of such an expression is either the <em>casted</em> object or <code>NULL</code> if the object is not an instance of the requested type.
If <code>TREAT</code> is used as part of a predicate and an object is not of the requested type, the predicate will evaluate to <code>FALSE</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The use of <code>TREAT</code> will not necessarily result in a filter for that subtype.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="qualified-expressions"><a class="anchor" href="#qualified-expressions"></a>10.5. Qualified expressions</h3>
<div class="paragraph">
<p>JPQL has the concept of qualified expressions for collections which is also supported in Blaze Persistence.
By default, a join for a collection or an expression using an attribute referring to a collection type, will have the collection value as type.
For allowing access to the key of a <code>java.util.Map</code> or the index of an indexed <code>java.util.List</code>, JPQL has a notion of qualification expressions.</p>
</div>
<div class="sect3">
<h4 id="value"><a class="anchor" href="#value"></a>10.5.1. VALUE</h4>
<div class="paragraph">
<p>The <code>VALUE</code> qualification expression is used to refer to the value of a collection explicitly. Since an identification variable by default has this type, the use of <code>VALUE</code> can always be omitted.</p>
</div>
</div>
<div class="sect3">
<h4 id="key"><a class="anchor" href="#key"></a>10.5.2. KEY</h4>
<div class="paragraph">
<p>The <code>KEY</code> qualification expression is used to refer to the key of a <code>java.util.Map</code>. If the key type is an entity type, it can be further navigated on.</p>
</div>
<div class="paragraph">
<p>WARN: Further navigation might not be supported by all JPA providers.</p>
</div>
</div>
<div class="sect3">
<h4 id="entry"><a class="anchor" href="#entry"></a>10.5.3. ENTRY</h4>
<div class="paragraph">
<p>The <code>ENTRY</code> qualification expression is used to construct <code>java.util.Map.Entry</code> instances for an identification variable that refers to a collection of the type <code>java.util.Map</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This qualification expression can only be used in the select clause.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="index"><a class="anchor" href="#index"></a>10.5.4. INDEX</h4>
<div class="paragraph">
<p>The <code>INDEX</code> qualification expression is used to refer to the index of a an indexed <code>java.util.List</code> i.e. mapping that uses <code>@OrderColumn</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="parameter-and-literal-expressions"><a class="anchor" href="#parameter-and-literal-expressions"></a>10.6. Parameter and Literal expressions</h3>
<div class="paragraph">
<p>Blaze Persistence only supports named parameters i.e. the <code>:parameterName</code> notation. There are multiple reasons for not supporting positional parameters but the main one being,
that positional parameters were never needed by the authors of Blaze Persistence in any of their projects.
Values can used in a query either through a parameter expression or by rendering it as literal expression. The syntaxes for literals depend on the data type of the value
and roughly align with the syntax of EclipseLink and Hibernate.</p>
</div>
<div class="paragraph">
<p>Next to the normal literals, Blaze Persistence also has support for a <code>NULL</code> literal. Behind the scenes it renders as <code>NULLIF(1,1)</code>.</p>
</div>
<div class="sect3">
<h4 id="string-literals"><a class="anchor" href="#string-literals"></a>10.6.1. String literals</h4>
<div class="paragraph">
<p>Just like in JPQL, the values for literals of string types are enclosed in single quotes. To escape a single quote within the value, a single quote is prefixed.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .whereOr()
        .where("owner.name").like().expression("'Billy'").noEscape()
        .where("name").like().expression("'Billy''s cat'").noEscape()
    .endOr();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN cat.owner owner_1
WHERE owner_1.name LIKE 'Billy'
   OR cat.name LIKE 'Billy''s cat'</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="numeric-literals"><a class="anchor" href="#numeric-literals"></a>10.6.2. Numeric literals</h4>
<div class="paragraph">
<p>By default, an integer literal has the type <code>int</code> or <code>Integer</code> and a decimal literal has the type <code>double</code> or <code>Double</code>. If you need other types, you can use the type suffixes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>L</code> for <code>long</code> or <code>Long</code> i.e. <code>1L</code></p>
</li>
<li>
<p><code>F</code> for <code>float</code> or <code>Float</code> i.e. <code>1.1F</code></p>
</li>
<li>
<p><code>D</code> for <code>double</code> or <code>Double</code> i.e. <code>0D</code></p>
</li>
<li>
<p><code>BI</code> for <code>bigint</code> or <code>BigInteger</code> i.e. <code>1BI</code></p>
</li>
<li>
<p><code>BD</code> for <code>decimal</code> or <code>BigDecimal</code> i.e. <code>0BD</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are no literal suffixes for the types <code>byte</code> and <code>short</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="boolean-literals"><a class="anchor" href="#boolean-literals"></a>10.6.3. Boolean literals</h4>
<div class="paragraph">
<p>Boolean literals <code>TRUE</code> and <code>FALSE</code> are case insensitive and can appear as expression directly or as predicate.</p>
</div>
</div>
<div class="sect3">
<h4 id="date-time-literals"><a class="anchor" href="#date-time-literals"></a>10.6.4. Date &amp; Time literals</h4>
<div class="paragraph">
<p>Date &amp; Time literals work with the JDBC escape syntax just like in JPQL.</p>
</div>
<div class="paragraph">
<p>Date literal::<code>{d 'yyyy-mm-dd'}</code>
Time literal::<code>{t 'hh:mm:ss'}</code>
Timestamp literal::<code>{ts 'yyyy-mm-dd hh:mm:ss(.millis)?'}</code> with optional milliseconds</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-type-literals"><a class="anchor" href="#entity-type-literals"></a>10.6.5. Entity type literals</h4>
<div class="paragraph">
<p>Whenever you compare against a <code>TYPE()</code> expression, you can use entity type literals.
An entity type literal is either the <em>entity name</em> or the fully qualified class name of the entity.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .where("TYPE(owner)").eqExpression("Student");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN cat.owner owner_1
WHERE TYPE(owner_1) = Student</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enum-literals"><a class="anchor" href="#enum-literals"></a>10.6.6. Enum literals</h4>
<div class="paragraph">
<p>An enum literal can be used by writing the fully qualified class name of the enum followed by the enum key.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .where("cat.status").eqExpression("org.mypackage.Status.ALIVE");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE TYPE(cat.status) = org.mypackage.Status.ALIVE</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="arithmetic-expressions"><a class="anchor" href="#arithmetic-expressions"></a>10.7. Arithmetic expressions</h3>
<div class="paragraph">
<p>Arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) are available on numeric types.
The type rules follow the JPQL rules which roughly say that if any operand in an arithmetic expression is of type &#8230;&#8203;
* <code>Double</code>, then the result is of type <code>Double</code>
* <code>Float</code>, then the result is of type <code>Float</code>
* <code>BigDecimal</code>, then the result is of type <code>BigDecimal</code>
* <code>BigInteger</code>, then the result is of type <code>BigInteger</code>
* <code>Long</code>, then the result is of type <code>Long</code></p>
</div>
<div class="paragraph">
<p>In all other cases, the result is of the type <code>Integer</code>.
The only exception to all of these rules is the division operator <code>/</code> for which the result type is undefined.</p>
</div>
<div class="paragraph">
<p>The operators can&#8217;t be used for date arithmetic. Instead the <em>date diff functions</em> have to be used.</p>
</div>
</div>
<div class="sect2">
<h3 id="function-expressions"><a class="anchor" href="#function-expressions"></a>10.8. Function expressions</h3>
<div class="paragraph">
<p>Blaze Persistence decided to only allow the standard JPQL and some extension functions to be used directly with the function call syntax <code>FUNCTION_NAME ( (args)* )</code>.
Non-standard functions have to be used via the <code>FUNCTION ( function_name (, args)* )</code> syntax that got introduced in JPA 2.1.</p>
</div>
<div class="sect3">
<h4 id="string-functions"><a class="anchor" href="#string-functions"></a>10.8.1. String functions</h4>
<div class="paragraph">
<p>Functions that return a result of type string.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>CONCAT ( string1, string2 (, args)* )</code></dt>
<dd>
<p>Concatenates the arguments to one string. Contrary to JPQL, this function allows varargs.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("CONCAT(cat.name, ' the cat')");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT CONCAT(cat.name, ' the cat')
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SUBSTRING ( string, start (, length)? )</code></dt>
<dd>
<p>Returns the subsequence of the first argument beginning at <code>start</code> which is 1-based. The length is optional.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("SUBSTRING(cat.name, 1, 2)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT SUBSTRING(cat.name, 1, 2)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>TRIM ( ( (LEADING | TRAILING | BOTH)? trimChar? FROM)? string )</code></dt>
<dd>
<p>Trims a character from the string. By default the <em>whitespace character</em> is trimmed from <em>BOTH</em> sides.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("TRIM(BOTH ' ' FROM cat.name)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT TRIM(BOTH ' ' FROM cat.name)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>LOWER ( string )</code></dt>
<dd>
<p>Returns the string in all lower case form.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("LOWER(cat.name)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT LOWER(cat.name)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>UPPER ( string )</code></dt>
<dd>
<p>Returns the string in all upper case form.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("UPPER(cat.name)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT UPPER(cat.name)
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="numeric-functions"><a class="anchor" href="#numeric-functions"></a>10.8.2. Numeric functions</h4>
<div class="paragraph">
<p>Functions that return a numeric result.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>LENGTH ( string )</code></dt>
<dd>
<p>Returns the length of the string.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class, "cat")
    .select("LENGTH(cat.name)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT LENGTH(cat.name)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>LOCATE ( string1, string2, start? )</code></dt>
<dd>
<p>Returns the first position of <code>string2</code> within <code>string1</code> from left to right, starting at <code>start</code>. By default starts at the beginning.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class, "cat")
    .select("LOCATE(cat.name, ' ')");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT LOCATE(cat.name, ' ')
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ABS ( numeric )</code></dt>
<dd>
<p>Returns the absolute value of the numeric value.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class, "cat")
    .select("ABS(cat.age / 3)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT ABS(cat.age / 3)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SQRT ( numeric )</code></dt>
<dd>
<p>Returns the square root of the numeric value.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Double&gt; cb = cbf.create(em, Double.class)
    .from(Cat.class, "cat")
    .select("SQRT(cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT SQRT(cat.age)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>MOD ( numeric1, numeric2 )</code></dt>
<dd>
<p>Returns the remainder for the division <code>numeric1 / numeric2</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class, "cat")
    .select("MOD(cat.age, 3)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT MOD(cat.age, 3)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The functions <code>SIZE</code> and <code>INDEX</code> also return numeric values but are described in <a href="#collection-functions">Collection functions</a></p>
</div>
</div>
<div class="sect3">
<h4 id="date-time-functions"><a class="anchor" href="#date-time-functions"></a>10.8.3. Date &amp; Time functions</h4>
<div class="paragraph">
<p>Functions that return a result with a date or time type.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>CURRENT_DATE</code></dt>
<dd>
<p>Returns the databases current date.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;java.sql.Date&gt; cb = cbf.create(em, java.sql.Date.class)
    .from(Cat.class, "cat")
    .select("CURRENT_DATE");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT CURRENT_DATE
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>CURRENT_TIME</code></dt>
<dd>
<p>Returns the databases current time.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;java.sql.Time&gt; cb = cbf.create(em, java.sql.Time.class)
    .from(Cat.class, "cat")
    .select("CURRENT_TIME");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT CURRENT_TIME
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>CURRENT_TIMESTAMP</code></dt>
<dd>
<p>Returns the databases current timestamp.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;java.sql.Timestamp&gt; cb = cbf.create(em, java.sql.Timestamp.class)
    .from(Cat.class, "cat")
    .select("CURRENT_TIMESTAMP");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT CURRENT_TIME
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collection-functions"><a class="anchor" href="#collection-functions"></a>10.8.4. Collection functions</h4>
<div class="paragraph">
<p>Functions that operate on collection mappings.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>INDEX ( collection_join_alias )</code></dt>
<dd>
<p>Returns the index of a collection element. The collection must be a <code>java.util.List</code> and have a <code>@OrderColumn</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Integer&gt; cb = cbf.create(em, Integer.class)
    .from(Cat.class, "cat")
    .select("INDEX(cat.favouriteKittens)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT INDEX(favouriteKittens_1)
FROM Cat cat
LEFT JOIN cat.favouriteKittens favouriteKittens_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>KEY ( collection_join_alias )</code></dt>
<dd>
<p>Returns the key of a collection element. The collection must be a <code>java.util.Map</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;AddressType&gt; cb = cbf.create(em, AddressType.class)
    .from(Person.class, "p")
    .select("KEY(p.addresses)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT KEY(addresses_1)
FROM Person p
LEFT JOIN p.addresses addresses_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SIZE ( collection_path )</code></dt>
<dd>
<p>Returns the size of a collection.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "cat")
    .select("SIZE(cat.favouriteKittens)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(KEY(favouriteKittens_1))
FROM Cat cat
LEFT JOIN cat.favouriteKittens favouriteKittens_1
GROUP BY cat.id</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The implementation for <code>SIZE</code> is highly optimized and tries to avoid subqueries to improve performance. It <strong>does not</strong> delegate to the <code>SIZE</code> implementation of the JPA provider.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information go to the <a href="#size-function">SIZE function</a> chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="aggregate-functions"><a class="anchor" href="#aggregate-functions"></a>10.8.5. Aggregate functions</h4>
<div class="paragraph">
<p>Blaze Persistence supports all aggregates as defined by JPQL and some non-standard aggregates. On top of that, it also has support for defining custom aggregate functions.
For further information on custom aggregates take a look at the <a href="#custom-jpql-functions">Custom JPQL functions</a> chapter.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>COUNT ( DISTINCT? arg )</code></dt>
<dd>
<p>Returns the number of elements that are not null as <code>Long</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "cat")
    .leftJoin("cat.favouriteKittens", "fav")
    .select("COUNT(KEY(fav))");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(KEY(fav))
FROM Cat cat
LEFT JOIN cat.favouriteKittens fav</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Blaze Persistence has a custom implementation for <code>COUNT(DISTINCT)</code> to support counting tuples even when the JPA provider and/or DBMS do not support it natively.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>COUNT ( * )</code></dt>
<dd>
<p>Returns the number of elements as <code>Long</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>WARN: This is a non-standard function that is not specified by JPQL but supported by all major JPA providers.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "cat")
    .leftJoin("cat.favouriteKittens", "fav")
    .select("COUNT(*)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(*)
FROM Cat cat
LEFT JOIN cat.favouriteKittens fav</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>AVG ( DISTINCT? numeric )</code></dt>
<dd>
<p>Returns the average numeric value as <code>Double</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Double&gt; cb = cbf.create(em, Double.class)
    .from(Cat.class, "cat")
    .select("AVG(cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT AVG(cat.age)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>MAX ( arg )</code></dt>
<dd>
<p>Returns the maximum element.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Double&gt; cb = cbf.create(em, Double.class)
    .from(Cat.class, "cat")
    .select("MAX(cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT MAX(cat.age)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>MIN ( arg )</code></dt>
<dd>
<p>Returns the minimum element.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Double&gt; cb = cbf.create(em, Double.class)
    .from(Cat.class, "cat")
    .select("MIN(cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT MIN(cat.age)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SUM ( numeric )</code></dt>
<dd>
<p>Returns the sum of all elements. Integral argument types have the result type <code>Long</code>, except for <code>BigInteger</code> which has the result type <code>BigInteger</code>. Decimal argument types have the result type <code>Double</code>, except for <code>BigDecimal</code> which has the result type <code>BigDecimal</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Cat.class, "cat")
    .select("SUM(cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT SUM(cat.age)
FROM Cat cat</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>FUNCTION ( 'GROUP_CONCAT' (, 'DISTINCT' )? , string (, 'SEPARATOR', separatorString)? (, 'ORDER BY', ( orderByExpr, ( 'ASC' | 'DESC' ) )+ ) )</code></dt>
<dd>
<p>Concatenates elements to a single string connected with the <code>separatorString</code> in the requested order.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>WARN: This is a non-standard function that might not be supported on all DBMS. See <a href="#group_concat-function">JPQL functions</a> for further information.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("FUNCTION('GROUP_CONCAT', cat.name, 'SEPARATOR', ' - ', 'ORDER BY', cat.name, 'ASC')");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT FUNCTION('GROUP_CONCAT', cat.name, 'SEPARATOR', ' - ', 'ORDER BY', cat.name, 'ASC')
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cast-and-treat-functions"><a class="anchor" href="#cast-and-treat-functions"></a>10.8.6. Cast and treat functions</h4>
<div class="paragraph">
<p>The cast functions offered by Blaze Persistence allow to do an SQL cast. The following data types are supported</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code> - <code>CAST_BOOLEAN</code></p>
</li>
<li>
<p><code>Byte</code> - <code>CAST_BYTE</code></p>
</li>
<li>
<p><code>Short</code> - <code>CAST_SHORT</code></p>
</li>
<li>
<p><code>Integer</code> - <code>CAST_INTEGER</code></p>
</li>
<li>
<p><code>Long</code> - <code>CAST_LONG</code></p>
</li>
<li>
<p><code>Float</code> - <code>CAST_FLOAT</code></p>
</li>
<li>
<p><code>Double</code> - <code>CAST_DOUBLE</code></p>
</li>
<li>
<p><code>Character</code> - <code>CAST_CHARACTER</code></p>
</li>
<li>
<p><code>String</code> - <code>CAST_STRING</code></p>
</li>
<li>
<p><code>BigInteger</code> - <code>CAST_BIGINTEGER</code></p>
</li>
<li>
<p><code>BigDecimal</code> - <code>CAST_BIGDECIMAL</code></p>
</li>
<li>
<p><code>java.sql.Time</code> - <code>CAST_TIME</code></p>
</li>
<li>
<p><code>java.sql.Date</code> - <code>CAST_DATE</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code> - <code>CAST_TIMESTAMP</code></p>
</li>
<li>
<p><code>java.util.Calendar</code> - <code>CAST_CALENDAR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The SQL type for a java type can be customized in the <a href="#customize-dbms-dialect">DBMS dialect</a> globally. If you need to cast to other types, you need to <a href="#custom-jpql-functions">create a custom function</a>.</p>
</div>
<div class="paragraph">
<p>Although JPQL is strictly typed, it might not always be possible to determine an appropriate type for an expression.
For such cases Blaze Persistence created various <code>TREAT_</code> functions that allow to give a subexpression an explicit type within the JPQL expression.
Normally, users shouldn&#8217;t get in touch with this directly. It is currently used internally to implement the <a href="#values-clause"><code>VALUES</code> clause</a> and is only mentioned for completeness.</p>
</div>
</div>
<div class="sect3">
<h4 id="function-function"><a class="anchor" href="#function-function"></a>10.8.7. Function function</h4>
<div class="paragraph">
<p>As of JPA 2.1 it is possible to invoke non-standard functions via the <code>FUNCTION ( function_name (, args)* )</code>. Blaze Persistence not only has support for that,
but prefers this syntax for non-standard functions over a proprietary syntax. The reason for that is mainly that the JPQL rendered by Blaze Persistence stays directly executable, even if proprietary functions are used.</p>
</div>
<div class="paragraph">
<p>By default, all non-standard functions of the JPA provider are imported. This means that you can make use of functions provided by the JPA provider with the <code>FUNCTION ( function_name (, args)* )</code> syntax
and it will get rendered into the JPA provider specific way of invoking such functions automatically.</p>
</div>
<div class="paragraph">
<p>A list of functions provided by Blaze Persistence and information on how to implement a custom function can be found in the <a href="#jpql-functions">JPQL functions</a> chapter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="subquery-expressions"><a class="anchor" href="#subquery-expressions"></a>10.9. Subquery expressions</h3>
<div class="paragraph">
<p>Since subqueries aren&#8217;t supported to be written as a whole but only through a builder API, Blaze Persistence offers a special API to construct complex expressions that contain subqueries.
The API was explained for <a href="#anchor_predicate_builder_subqueries">predicates</a> and <a href="#anchor_select_subqueries">select expressions</a> already.
The general idea is that you introduce aliases for subqueries in a complex expression that later get replaced with the actual subquery in the expression tree.</p>
</div>
<div class="paragraph">
<p>Within subqueries, Blaze Persistence supports a function called <code>OUTER()</code> which can be used to refer to attributes of the parent query&#8217;s root.
By using <code>OUTER</code> you can avoid introducing the query root alias of the outer query into the subquery directly.</p>
</div>
<div class="paragraph">
<p>For further information on <code>OUTER</code> take a look into the <a href="#outer-function">JPQL functions</a> chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="nullif-expressions"><a class="anchor" href="#nullif-expressions"></a>10.10. Nullif expressions</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NULLIF ( arg1, arg2 )</code></dt>
<dd>
<p>Returns <code>NULL</code> if <code>arg1</code> and <code>arg2</code> are equal.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("NULLIF(cat.name, cat.owner.name)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT NULLIF(cat.name, owner_1.name)
FROM Cat cat
LEFT JOIN cat.owner owner_1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coalesce-expressions"><a class="anchor" href="#coalesce-expressions"></a>10.11. Coalesce expressions</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>COALESCE ( arg1, arg2 (, args)* )</code></dt>
<dd>
<p>Returns the first non-<code>NULL</code> argument or <code>NULL</code> if all arguments are <code>NULL</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("COALESCE(cat.name, cat.owner.name, 'default')");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COALESCE(cat.name, owner_1.name, 'default')
FROM Cat cat
LEFT JOIN cat.owner owner_1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="case-expressions"><a class="anchor" href="#case-expressions"></a>10.12. Case expressions</h3>
<div class="paragraph">
<p>Although Blaze Persistence already supports building <code>CASE WHEN</code> expressions via a builder API, it also supports an expression form.
The API was explained for <a href="#anchor_select_case_when">predicates</a> and <a href="#anchor_predicate_builder_case_when">select expressions</a> already.</p>
</div>
<div class="sect3">
<h4 id="simple-case-expressions"><a class="anchor" href="#simple-case-expressions"></a>10.12.1. Simple case expressions</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>CASE operand (WHEN valueN THEN resultN)+ ELSE resultOther END</code></dt>
<dd>
<p>Tests if the <code>operand</code> equals one of <code>valueN</code> and if so, returns the respective <code>resultN</code>, otherwise returns <code>resultOther</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("CASE cat.age WHEN 1 THEN 'Baby' ELSE 'Other' END");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT CASE cat.age WHEN 1 THEN 'Baby' ELSE 'Other' END
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="searched-case-expressions"><a class="anchor" href="#searched-case-expressions"></a>10.12.2. Searched case expressions</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>CASE (WHEN conditionN THEN resultN)+ ELSE resultOther END</code></dt>
<dd>
<p>Tests if any <code>conditionN</code> evaluates to true and if so, returns the respective <code>resultN</code>, otherwise returns <code>resultOther</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("CASE WHEN cat.age &lt; 2 THEN 'Baby' ELSE 'Other' END");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT CASE WHEN cat.age &lt; 2 THEN 'Baby' ELSE 'Other' END
FROM Cat cat</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="predicate-expressions"><a class="anchor" href="#predicate-expressions"></a>10.13. Predicate expressions</h3>
<div class="paragraph">
<p>Blaze Persistence supports constructing predicates via a builder API as has been shown in the <a href="#predicate-builder">Predicate Builder</a> chapter,
but sometimes it is necessary to define predicates as strings.
It is necessary for <code>CASE WHEN</code> expressions or when wanting to replace a whole predicate via e.g. <code>setWhereExpression(String)</code>.</p>
</div>
<div class="paragraph">
<p>Predicates can be connected with the logical operators <code>AND</code> and <code>OR</code> and form a compound predicate. Predicates can be grouped by using parenthesis and
can be prefixed with the unary operator <code>NOT</code> for negating the predicate.
All predicates except for null-aware predicates like e.g. <code>IS NULL</code> that compare against <code>NULL</code>, will result in <code>UNKNOWN</code> which is intuitively equal to <code>FALSE</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="relational-comparison-predicate"><a class="anchor" href="#relational-comparison-predicate"></a>10.14. Relational comparison predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>expression1 ( = | &lt;&gt; | &gt; | &gt;= | &lt; | &lt;= | != ) ( expression2 | ( ( ALL | ANY | SOME ) subquery_alias ) )</code></dt>
<dd>
<p>Compares same typed operands with one of the operators <code>=</code>, <code>&lt;&gt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>. Blaze Persistence also defines the <code>!=</code> as synonym for the <code>&lt;&gt;</code> operator.
In addition to normal comparison, relational predicates can also have a quantifier to do comparisons against <code>ALL</code> or <code>ANY</code>/<code>SOME</code> elements of a set.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpressionSubqueries("cat.age &lt; 2 AND LENGTH(cat.name) &gt;= ALL catNameLengths")
        .with("catNameLengths")
            .from(Cat.class, "subCat")
            .select("LENGTH(subCat.name)")
        .end()
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat.age &lt; 2
  AND LENGTH(cat.name) &gt;= ALL (
      SELECT LENGTH(subCat.name)
      FROM Cat subCat
  )</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nullness-predicate"><a class="anchor" href="#nullness-predicate"></a>10.15. Nullness predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>expression IS NOT? NULL</code></dt>
<dd>
<p>Evaluates whether a value is <code>NULL</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpression("cat.owner IS NOT NULL");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat.owner IS NOT NULL</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="like-predicate"><a class="anchor" href="#like-predicate"></a>10.16. Like predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>string NOT? LIKE pattern (ESCAPE escape_character)?</code></dt>
<dd>
<p>Tests if <code>string</code> matches <code>pattern</code>. The <code>escape_character</code> can be used to escape usages of the single char wildcard <code>_</code> and multi-char wildcard <code>%</code> characters in <code>pattern</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpression("cat.name LIKE 'Mr.%'");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat.name LIKE 'Mr.%'</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="between-predicate"><a class="anchor" href="#between-predicate"></a>10.17. Between predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>expression1 NOT? BETWEEN expression2 AND expression3</code></dt>
<dd>
<p>Between is a shorthand syntax for the tests <code>expression1 &gt;=</code> <code>expression2 AND expression1 &lt;= expression3</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpression("cat.age BETWEEN 1 AND 2");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat.age BETWEEN 1 AND 2</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="in-predicate"><a class="anchor" href="#in-predicate"></a>10.18. In predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>expression1 NOT? IN ( subquery_alias | collection_parameter | ( '(' item1 (, itemN)* ')' ) )</code></dt>
<dd>
<p>The <code>IN</code> predicate checks if <code>expression1</code> is contained in any of the values on the right hand side i.e. <em>item1..itemN</em>.
Items can be parameters or literals. If just one item is given, the IN predicate is rewritten to an <code>EQ</code> predicate and thus allows the single item to be any expression.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When the collection value for <code>collection_parameter</code> is bound on the query builder of Blaze Persistence, empty collections will work as expected. Behind the scenes the <code>IN</code> predicate is replace by a <code>TRUE</code> or <code>FALSE</code> predicate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>subquery_alias</code> is replaced with the subquery defined via the builder API as explained in the <a href="#anchor_predicate_builder_subqueries">predicates chapter</a> and the builder section for the <a href="#anchor_predicate_builder_in_predicate"><code>IN</code> predicate</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpression("cat.age IN (1L, 2L, 3L, :param)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat.age IN (1L, 2L, 3L, :param)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some JPA providers support a row-value constructor syntax which is not supported by Blaze Persistence. Consider rewriting queries that use that syntax to the <code>EXISTS</code> equivalent.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="exists-predicate"><a class="anchor" href="#exists-predicate"></a>10.19. Exists predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NOT? EXISTS subquery_alias</code></dt>
<dd>
<p>The <code>EXISTS</code> predicate checks if the subquery for <code>subquery_alias</code> has rows.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpressionSubqueries("EXISTS subquery_alias")
        .with("subquery_alias")
            .from(Cat.class, "subCat")
            .where("cat").notEqExpression("subCat")
        .end()
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE EXISTS(
    SELECT 1
    FROM Cat subCat
    WHERE cat &lt;&gt; subCat
)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="empty-predicate"><a class="anchor" href="#empty-predicate"></a>10.20. Empty predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>collection_path IS NOT? EMPTY</code></dt>
<dd>
<p>The <code>IS EMPTY</code> predicate checks if the collection for an element as specified by <code>collection_path</code> is empty i.e. contains no elements.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpression("cat.kittens IS EMPTY");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat.kittens IS EMPTY</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="member-of-predicate"><a class="anchor" href="#member-of-predicate"></a>10.21. Member-of predicate</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>expression NOT? MEMBER OF? collection_path</code></dt>
<dd>
<p>The <code>MEMBER OF</code> predicate checks if <code>expression</code> is an element of the collection as specified by <code>collection_path</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .from(Cat.class, "cat")
    .setWhereExpression("cat MEMBER OF cat.kittens");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE cat MEMBER OF cat.kittens</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query-api"><a class="anchor" href="#query-api"></a>11. Query API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The central element to the construction of criteria or query builders is the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a>.
The factory provides methods for constructing <a href="#dml-statements">DML statements</a>, <a href="#set-operations">left nested set operations</a> and
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#create(javax.persistence.EntityManager,%20java.lang.Class)"><code>CriteriaBuilder</code></a> instances for <code>SELECT</code> statements.</p>
</div>
<div class="paragraph">
<p>The top level query builders allow access to the query string and also to construct JPA <code>javax.persistence.Query</code> or <code>javax.persistence.TypedQuery</code> instances through the interfaces</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Queryable.html"><code>Queryable</code></a></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html"><code>Executable</code></a></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ModificationCriteriaBuilder.html"><code>ModificationCriteriaBuilder</code></a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">String queryString = cbf.create(em, Cat.class, "cat")
    .getQueryString();
TypedQuery&lt;Cat&gt; query = em.createQuery(queryString, Cat.class);</pre>
</div>
</div>
<div class="paragraph">
<p>The possibility to access the query string is a convenience for debugging or monitoring, but queries should always be constructed via the respective query construction methods.
If advanced features like CTEs, Set-Operations or others are used, the query string returned really is just a <em>logical representation</em> of the query structure,
so don&#8217;t rely on the query string being compilable through <code>EntityManager#createQuery()</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The constructed JPA query instances for queries that use some of the advanced features currently do not support query hints or unwrapping.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">TypedQuery&lt;Cat&gt; query = cbf.create(em, Cat.class, "cat")
    .getTypedQuery();</pre>
</div>
</div>
<div class="paragraph">
<p>Queries should always be created that way and also can be reused for the transaction just like any other query.</p>
</div>
<div class="paragraph">
<p>Blaze Persistence also offers convenience methods on the top level query builder interfaces to execute the queries</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Queryable.html#getSingleResult()"><code>getSingleResult()</code></a> is equivalent to <code>getTypedQuery().getSingleResult()</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Queryable.html#getResultList()"><code>getResultList()</code></a> is equivalent to <code>getTypedQuery().getResultList()</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a> is equivalent to <code>getQuery().executeUpdate()</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; query = cbf.create(em, Cat.class, "cat")
    .getResultList();</pre>
</div>
</div>
<div class="sect2">
<h3 id="parameter-binding"><a class="anchor" href="#parameter-binding"></a>11.1. Parameter binding</h3>
<div class="paragraph">
<p>Apart from support for binding parameters on the constructed JPA query, Blaze Persistence also allows to bind parameters on the query builder itself.
All query builders(including subquery and other builders) support setting parameters through the same <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ParameterHolder.html#setParameter(java.lang.String,%20java.lang.Object)"><code>setParameter()</code></a> API that is offered by the JPA query API.
In addition to that, it is also possible to inspect the parameters and the bound values while building through <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ParameterHolder.html#getParameters()"><code>getParameters()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; query = cbf.create(em, Cat.class, "cat")
    .where("name").eqExpression(":nameParam")
    .setParameter("nameParam", "Billy")
    .getResultList();</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Beware that positional parameters are not supported!
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="query-properties"><a class="anchor" href="#query-properties"></a>11.2. Query properties</h3>
<div class="paragraph">
<p>As mentioned in the <a href="#configuration">configuration chapter</a>, a query builder can be further configured via the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CommonQueryBuilder.html#setProperty(java.lang.String,%20java.lang.String)"><code>setProperty(String, String)</code></a> method.
This allows for disabling optimizations when encountering bugs or fine tuning on a case by case basis.</p>
</div>
<div class="paragraph">
<p>If you encounter, that you make use of a configuration very often, you should consider configuring the property globally via the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html"><code>CriteriaBuilderConfiguration</code></a>
and only switch to a different value when needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-result-caching"><a class="anchor" href="#query-result-caching"></a>11.3. Query result caching</h3>
<div class="paragraph">
<p>Query result caching can be enabled by invoking the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CommonQueryBuilder.html#setCacheable(boolean)"><code>setCacheable(boolean)</code></a> method on a query builder.</p>
</div>
<div class="paragraph">
<p>Note that additional configuration might be required for the caching to work properly. For details, refer to the documentation of your JPA provider.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-api-limitations"><a class="anchor" href="#query-api-limitations"></a>11.4. Limitations</h3>
<div class="paragraph">
<p>Although we try to adopt or at least allow the use of JPA provider extension there are some limitations to the query API that are known and currently not addressed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No support for iterative result processing i.e. <em>scrolling</em> yet. See <a href="https://github.com/Blazebit/blaze-persistence/issues/254">#254</a></p>
</li>
<li>
<p>No support for passing query hints</p>
</li>
<li>
<p>No way for query caching for static queries that use advanced features. This is going to be addressed as part of <a href="https://github.com/Blazebit/blaze-persistence/issues/252">#252</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pagination"><a class="anchor" href="#pagination"></a>12. Pagination</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pagination is often used to make large data sets consumable. It requires an ordered set of elements/rows to be able to deterministically split the data into pages.
Imagine the following ordered data set</p>
</div>
<div class="imageblock">
  <div class="content">
        <img src="images/diag-f483c03175a48593dea1cac3c31c7f79.png" alt="diag f483c03175a48593dea1cac3c31c7f79" width="1090" height="98">
  </div>
</div>
<div class="paragraph">
<p>If we split it up into pages of the size of 5 elements we get 6 pages and the last one only containing 1 element</p>
</div>
<div class="imageblock">
  <div class="content">
        <img src="images/diag-4c8b83ab63944d674ba8c39498440fe5.png" alt="diag 4c8b83ab63944d674ba8c39498440fe5" width="470" height="238">
  </div>
</div>
<div class="paragraph">
<p>Blaze Persistence provides two ways to do pagination.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conventional pagination via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/LimitBuilder.html#setFirstResult(int)"><code>setFirstResult()</code></a> and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/LimitBuilder.html#setMaxResults(int)"><code>setMaxResults()</code></a></p>
</li>
<li>
<p>Extended pagination support via the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a> API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Conventional pagination in JPA only works on the main query which is also possible with Blaze Persistence.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; secondCat = cbf.create(em, Cat.class)
    .orderByAsc("id")
    .setFirstResult(1)
    .setMaxResults(1)
    .getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
ORDER BY cat.id ASC NULLS LAST
--LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="paragraph">
<p>In addition to that, offset pagination for subqueries is also possible.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">List&lt;Cat&gt; secondCat = cbf.create(em, Cat.class)
    .fetch("kittens")
    .where("id").in()
        .from(Cat.class, "subCat")
        .select("subCat.id")
        .orderByAsc("id")
        .setFirstResult(1)
        .setMaxResults(1)
    .end()
    .getResultList();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.kittens kittens_1
WHERE cat.id IN LIMIT((                 <i class="conum" data-value="1"></i><b>(1)</b>
    SELECT subCat.id
    FROM Cat cat
    ORDER BY cat.id ASC NULLS LAST
),1 ,1) --LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uses the <a href="#limit-function"><code>LIMIT</code> function</a> to apply a <code>LIMIT</code>/<code>OFFSET</code> clause on the subquery</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The extended pagination support comes via the criteria builder&#8217;s <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#page(int,%20int)"><code>page()</code></a> methods which come in three flavours:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#page(int,%20int)"><code>page(int firstResult, int maxResults)</code></a></dt>
<dd>
<p>Performs <a href="#anchor-offset-pagination">offset pagination</a> by skipping <code>firstResult</code> elements and from there on, show <code>maxResults</code> elements.</p>
</dd>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#page(com.blazebit.persistence.KeysetPage,%20int,%20int)"><code>page(KeysetPage keysetPage, int firstResult, int maxResults)</code></a></dt>
<dd>
<p>Performs <a href="#anchor-keyset-pagination">keyset pagination</a> if possible and falls back to offset pagination otherwise.</p>
</dd>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#page(java.lang.Object,%20int)"><code>page(Object entityId, int maxResults)</code></a></dt>
<dd>
<p>Navigates to the <a href="#anchor-navigate-entity-page">page containing the entity</a> with the given <code>entityId</code>. Falls back to the first page if no entity for the id exists.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="pagination-under-the-hood"><a class="anchor" href="#pagination-under-the-hood"></a>12.1. Under the hood</h3>
<div class="paragraph">
<p>In Blaze Persistence we have followed a more involved approach for implementing pagination than plainly using JPA standard
methods like <code>javax.persistence.Query.setMaxResults()</code> or <code>javax.persistence.Query.setFirstResult()</code> to steer the result set
dimensions. This is due to deficiencies in some JPA providers when it comes to handling paginated queries containing
join fetches for collections.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, when using fetch joins for collections with Hibernate, all results are fetched instead of only the selected page.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The approach used in Blaze Persistence consists of up to three queries executed consecutively:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <strong>count query</strong> is used to fetch the total element count which is needed to populate <code>com.blazebit.persistence.PagedList.getTotalSize()</code> and
<code>com.blazebit.persistence.PagedList.getTotalPages()</code>. If this query returns 0, no further queries are executed.</p>
</li>
<li>
<p>The <strong>ID query</strong> is used to fetch the entity ids that are contained in the target page. In this step, the previously
mentioned <code>javax.persistence.Query.setMaxResults()</code> and <code>javax.persistence.Query.setFirstResult()</code> are used to select the
target ID set. Only selecting the IDs allows to omit all fetch joins, especially collection joins that might trigger inefficient jpa provider
strategies. The <strong>ID query</strong> is omitted if no collection fetch joins are done, because in that case JPA providers tend to do the right thing when paginating directly.</p>
</li>
<li>
<p>Finally, the <strong>object query</strong> is used to fetch the entities as described by the original query specified by the user.
This query uses an <code>IN</code> predicate for the ID set retrieved in the previous step to restrict the fetched entities to the target
page.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In a future version it might be possible to combine queries or disable the count query. For more information on that see <a href="https://github.com/Blazebit/blaze-persistence/issues/248">#248</a>,
<a href="https://github.com/Blazebit/blaze-persistence/issues/249">#249</a> and <a href="https://github.com/Blazebit/blaze-persistence/issues/255">#255</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can inspect the query strings by using <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html#getPageCountQueryString()"><code>getPageCountQueryString()</code></a>,
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html#getPageIdQueryString()"><code>getPageIdQueryString()</code></a> and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Queryable.html#getQueryString()"><code>getQueryString()</code></a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="anchor-offset-pagination"><a class="anchor" href="#anchor-offset-pagination"></a>12.2. Offset pagination</h3>
<div class="paragraph">
<p>As already laid out in the <a href="#pagination">introduction</a>, pagination works on an ordered set of elements/rows.
Offset pagination basically looks at the ordered set from left to right and counts elements until the count reaches <code>firstResult</code>.
From that point on elements are collected until <code>maxResults</code> of elements have been collected or no more elements are available.</p>
</div>
<div class="paragraph">
<p>This basically means that the <code>OFFSET</code> i.e. <code>firstResult</code> part forces a DBMS to actually determine an element/row is visible for a transaction and then <em>ignore</em>/<em>skip</em> it.
The bigger the <code>firstResult</code> value, the more resources the DBMS has to waste for <em>skipping</em> elements/rows.
This essentially means that when employing offset pagination, accessing the latter pages will become more and more expensive.
In order for this approach to be actually usable with larger data sets, a DBMS index that can be used for the ordering is required to avoid constantly loading and sorting data.
In addition to that, the DBMS should have enough RAM to keep the index fully in-memory to avoid costly disk fetches.</p>
</div>
<div class="paragraph">
<p>Although offset pagination works in every case, it should be avoided if possible because of the performance implications.
As you will see in the <a href="#anchor-keyset-pagination">keyset pagination part</a> there is a more efficient approach to pagination that almost uses the same API.</p>
</div>
<div class="paragraph">
<p>The following example illustrates the usage and what happens behind the scenes</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">PagedList&lt;Cat&gt; page2 = cbf.create(em, Cat.class)
    .fetch("kittens")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(5, 5)
    .getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Executes the following queries</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(*)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <strong>ID query</strong> is necessary because of the join fetched collection <code>kittens</code></p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.id
FROM Cat cat
ORDER BY cat.id ASC NULLS LAST
--LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.kittens kittens_1
WHERE cat.id IN :idParams
ORDER BY cat.id ASC NULLS LAST</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-keyset-pagination"><a class="anchor" href="#anchor-keyset-pagination"></a>12.3. Keyset pagination</h3>
<div class="paragraph">
<p>Keyset pagination is a way to efficiently paginate or scroll through a large data set by querying for elements that come before or after a reference point.
The idea of a keyset is, that every tuple can be uniquely identified by that keyset. So a keyset essentially is a reference point of a tuple in a data set ordered by keysets.
Keyset pagination in contrast to offset pagination makes efficient use of the ordering property of the data set.
By remembering the highest and lowest keysets of a page, it is possible to query the previous and next pages efficiently.</p>
</div>
<div class="paragraph">
<p>A keyset in terms of query results consists of the values of the <code>ORDER BY</code> expressions of a tuple.
In order to satisfy the uniqueness constraint, it is generally a good idea to use an entity&#8217;s id as last expression in the <code>ORDER BY</code> clause.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently the entity id is the <strong>only</strong> possible expression that satisfies the uniqueness constraint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Keyset pagination just like offset pagination requires index support on the DBMS side to work efficiently. A range-scan enabled index like provided by a b-tree index is required for keyset pagination to work best.
In contrast to offset pagination, an index does not have to be traversed like a list in order to <em>ignore</em>/<em>skip</em> a certain amount of elements/rows. Instead, a DBMS can make use of the structure of the index
and traverse it in <code>O(log N)</code> as compared to <code>O(N)</code> to get to the <code>firstResult</code>. This characteristic makes keyset pagination especially useful for accessing latter pages.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t allow too many different sort combinations as every combination requires a custom index to work efficiently.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the obvious requirements for keyset pagination to work, is the need for a reference point i.e. a keyset from which point on the next or previous elements should be queried.</p>
</div>
<div class="paragraph">
<p>The API in Blaze Persistence tries to allow making use of keyset pagination in a transparent and easy manner without compromises.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">// In the beginning we don't have a keyset page
KeysetPage oldPage = null;
PagedList&lt;Cat&gt; page2 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(oldPage, 5, 5) <i class="conum" data-value="1"></i><b>(1)</b>
    .getResultList();

// Query the next page with the keyset page of page2
PagedList&lt;Cat&gt; page3 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(page2.getKeysetPage(), 10, 5) <i class="conum" data-value="2"></i><b>(2)</b>
    .getResultList();

// Query the previous page with the keyset page of page2
PagedList&lt;Cat&gt; page1 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page(page2.getKeysetPage(), 0, 5) <i class="conum" data-value="3"></i><b>(3)</b>
    .getResultList();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The oldPage in this case is <code>null</code>, so internally it falls back to offset pagination</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When querying the <em>next</em> page of <code>page2</code>, it can use the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetPage.html#getHighest()">upper bound</a> of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PagedList.html#getKeysetPage()">keyset page</a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>When querying the <em>previous</em> page of <code>page2</code>, it can use the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetPage.html#getLowest()">lower bound</a> of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PagedList.html#getKeysetPage()">keyset page</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since we are not fetching any collections, the ID query is avoided. For brevity, we skip the count query.
So let&#8217;s look at the object queries generated</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat, cat.id <i class="conum" data-value="1"></i><b>(1)</b>
FROM Cat cat
ORDER BY cat.birthday ASC NULLS LAST, cat.id ASC NULLS LAST
--LIMIT 5 OFFSET 5</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The expression <code>cat.id</code> is for constructing the keyset and contains all expressions of the <code>ORDER BY</code> clause</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see, nothing fancy, except for the additional select that is used for extracting the keyset.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat, cat.id
FROM Cat cat
WHERE cat.birthday &gt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &gt; :_keysetParameter_1
)
ORDER BY cat.birthday ASC NULLS LAST, cat.id ASC NULLS LAST
--LIMIT 5</pre>
</div>
</div>
<div class="paragraph">
<p>This time the query made efficient use of the keyset by filtering out elements/rows that come before the reference point</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat, cat.id
FROM Cat cat
WHERE cat.birthday &lt; :_keysetParameter_0 OR (
    cat.birthday = :_keysetParameter_0 AND
    cat.id &lt; :_keysetParameter_1
)
ORDER BY cat.birthday DESC NULLS FIRST, cat.id DESC NULLS FIRST
--LIMIT 5</pre>
</div>
</div>
<div class="paragraph">
<p>Before the query filtered out elements/rows that came <strong>before</strong> the reference point, this time it does the opposite. It filters out elements/rows coming <strong>after</strong> the reference point.
Another interesting thing to notice, the ordering was reversed too. This has the effect that the DBMS can traverse the index backwards and essentially is how keyset pagination works.
The ordering is reversed again in-memory, so you don&#8217;t notice anything of these details.</p>
</div>
<div class="paragraph">
<p>Note that in the following situations, the implementation automatically falls back to offset pagination</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The keyset is invalid i.e. it is <code>null</code></p>
</li>
<li>
<p>The ordering of the query changed</p>
</li>
<li>
<p>The page to navigate to is arbitrary i.e. not the next or previous page of a <code>keysetPage</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To be able to make use of keyset pagination either via the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/PaginatedCriteriaBuilder.html"><code>PaginatedCriteriaBuilder</code></a> API or the <a href="#keyset-pagination-support">manual keyset filter API</a>,
the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/KeysetPage.html"><code>KeysetPage</code></a> or the respective <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Keyset.html"><code>Keyset</code></a> elements have to be preserved across page requests.
Applications that can retain state between requests(i.e. via a session) can just preserve the <code>KeysetPage</code> object itself. Applications that try to avoid server side state have to serialize and deserialize the state somehow.</p>
</div>
<div class="paragraph">
<p>Since the keyset state is available through <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Keyset.html#getTuple()">getter methods</a>, it shouldn&#8217;t be too hard to do the serialization and deserialization.
When implementing a custom <code>Keyset</code>, the <code>equals()</code> and <code>hashCode()</code> contracts have to make use of just the tuple. A custom <code>KeysetPage</code> implementation has to provide access to the lowest and highest  keysets,
as well as the <code>firstResult</code> and <code>maxResults</code> values used for querying that page.</p>
</div>
<div class="paragraph">
<p>Beware that keyset pagination isn&#8217;t perfect. If entries can be <em>prepended</em> relative to the current keyset/reference point,
it might happen that the page number calculation becomes wrong over time. Most of the time this is negligible as it kind of gives the illusion that the user works on a snapshot of the data.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-navigate-entity-page"><a class="anchor" href="#anchor-navigate-entity-page"></a>12.4. Navigate to entity page</h3>
<div class="paragraph">
<p>The navigation to the page on which an entity with a specific id is involves finding out the position of the entity.
Blaze Persistence offers a custom function named <a href="#page-position"><code>PAGE_POSITION</code></a> which determines the absolute position of an entity in an ordered set.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">Cat knownCat = //...
PagedList&lt;Cat&gt; page3 = cbf.create(em, Cat.class)
    .orderByAsc("birthday")
    .orderByAsc("id") // unique ordering is required for pagination
    .page((Object) knownCat.getId(), 3) <i class="conum" data-value="1"></i><b>(1)</b>
    .getResultList();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If your id type is a primitive <code>int</code>, you must cast to <code>Object</code> or <code>Integer</code> to use the right method</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT COUNT(*), FUNCTION('PAGE_POSITION',(
    SELECT _page_position_cat.id
    FROM Cat _page_position_cat
    GROUP BY _page_position_cat.id, _page_position_cat.birthday
    ORDER BY _page_position_cat.birthday DESC NULLS FIRST, _page_position_cat.id DESC NULLS FIRST
), :_entityPagePositionParameter)
FROM Cat cat</pre>
</div>
</div>
<div class="paragraph">
<p>The count query contains the page position determination logic. It essentially passes an ID query as subquery to the <code>PAGE_POSITION</code> function.
The concrete SQL implementation of that function depends on the DBMS, but they all follow the same main idea.
Wrap the ID query and count the row numbers. In another wrapper around that, filter for the row with the matching id and return the row number as position.
The element/row number of the first element on that page is calculated and used as <code>firstResult</code>. Apart from this speciality, the rest of the query is just like a normal offset pagination query.</p>
</div>
</div>
<div class="sect2">
<h3 id="pagination-limitations"><a class="anchor" href="#pagination-limitations"></a>12.5. Limitations</h3>
<div class="paragraph">
<p>Since the <code>PaginatedCriteriaBuilder</code> API can only paginate on entity level, the results are implicitly grouped by id and therefore distinct.
Because of that, the usage of <code>distinct()</code> or <code>groupBy()</code> on a <code>PaginatedCriteriaBuilder</code> is disallowed and will result in an exception.</p>
</div>
<div class="paragraph">
<p>If these limitations are not ok for your use case, you will have to implement a custom pagination strategy via <code>setFirstResult()</code> and <code>setMaxResults()</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dml-statements"><a class="anchor" href="#dml-statements"></a>13. DML statements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next to the support for <code>SELECT</code> statements, Blaze Persistence also has support for</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>INSERT ... SELECT</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Apart from support for DML for JPA entity types, there is also support for DML for entity collections.
The construction of query builders for such statements works through the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html"><code>CriteriaBuilderFactory</code></a> API.</p>
</div>
<div class="sect2">
<h3 id="delete-statement"><a class="anchor" href="#delete-statement"></a>13.1. DELETE statement</h3>
<div class="paragraph">
<p>The <code>DELETE</code> statement deletes entities that satisfy the <code>WHERE</code> clause of the statement.
A delete builder can be created via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#delete(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.delete()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">DeleteCriteriaBuilder&lt;Cat&gt; cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").isNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE FROM Cat cat
WHERE cat.name IS NULL</pre>
</div>
</div>
<div class="paragraph">
<p>You can immediately execute the query by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a>
or create a JPA <code>Query</code> by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#getQuery()"><code>getQuery()</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since a <code>DELETE</code> statement can&#8217;t have joins, implicit joins generated by deep path expressions are disallowed. Use an <code>EXISTS</code> subquery if you need to join relations.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently you can&#8217;t make use of advanced SQL features like CTEs when having a polymorphic <code>DELETE</code> except for single table inheritance. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/345">#345</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If your DBMS supports it, cascading deletes will be implemented as CTEs when deleting entities through this API.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="delete-collection-statement"><a class="anchor" href="#delete-collection-statement"></a>13.2. DELETE collection statement</h3>
<div class="paragraph">
<p>The <code>DELETE</code> collection statement deletes collection entries of entities that satisfy the <code>WHERE</code> clause of the statement.
A collection delete builder can be created via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#deleteCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.deleteCollection()</code></a>.
The statement only works on collections that have a join or collection table.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">DeleteCriteriaBuilder&lt;Cat&gt; cb = cbf.deleteCollection(em, Cat.class, "kittens", "cat")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("cat.id").eqExpression("subCat.id")
        .where("subCat.name").isNull()
    .end();</pre>
</div>
</div>
<div class="paragraph">
<p>The alias <code>cat</code> or in general, an delete collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source id i.e. <code>cat.id</code></p>
</li>
<li>
<p>The target id i.e. <code>cat.kittens.id</code></p>
</li>
<li>
<p>The collection index/key i.e. <code>KEY(cat.kittens)</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE FROM Cat(kittens) cat
WHERE EXISTS(
    SELECT 1 FROM Cat subCat
    WHERE cat.id = subCat.id
      AND cat.name IS NULL
)</pre>
</div>
</div>
<div class="paragraph">
<p>You can immediately execute the query by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a>
or create a JPA <code>Query</code> by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#getQuery()"><code>getQuery()</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="update-statement"><a class="anchor" href="#update-statement"></a>13.3. UPDATE statement</h3>
<div class="paragraph">
<p>The <code>UPDATE</code> statement updates attributes as specified in the <code>SET</code> clause on entities that satisfy the <code>WHERE</code> clause of the statement.
An update builder can be created via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#update(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.update()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("name").isNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name IS NULL</pre>
</div>
</div>
<div class="paragraph">
<p>There are multiple <code>set()</code> variants to be able to cover all possible expressions.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String,%20java.lang.Object)"><code>set(String, Object)</code></a></dt>
<dd>
<p>Set the attribute to the given value. This will create an implicit parameter expression and set the value.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .set("name", "Billy2")
    .where("name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = :param_1
WHERE cat.name = :param_2</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String)"><code>set(String)</code></a></dt>
<dd>
<p>Starts a subquery builder for the attribute.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("cat.name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseUpdateCriteriaBuilder.html#setExpression(java.lang.String,%20java.lang.String)"><code>setExpression(String, String)</code></a></dt>
<dd>
<p>Uses the given expression for the assignment to the attribute.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .setExpression("name", "UPPER(name)")
    .where("cat.name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseUpdateCriteriaBuilder.html#setSubqueries(java.lang.String,%20java.lang.String)"><code>setSubqueries(String, String)</code></a></dt>
<dd>
<p>Starts a subquery builder capable of handling multiple subqueries and assigns the given <code>expression</code> to the attribute.
Subqueries are started with <code>with(String subqueryAlias)</code> and aliases occurring in the expression will be replaced by the respective subquery expressions.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .setSubqueries("name", "CONCAT(ownerSubquery, ' the cat'")
        .with("ownerSubquery")
            .from(Person.class, "p")
            .where("p").eqExpression("cat.owner")
            .select("p.name")
        .end()
    .end()
    .where("cat.name").eq("Billy");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = CONCAT((
    SELECT p.name
    FROM Person p
    WHERE p = cat.owner
), '''s cat')
WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently there is no possibility to do a <code>VERSIONED</code> update like you could do with e.g. Hibernate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can immediately execute the query by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#executeUpdate()"><code>executeUpdate()</code></a>
or create a JPA <code>Query</code> by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Executable.html#getQuery()"><code>getQuery()</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since an <code>UPDATE</code> statement can&#8217;t have joins, implicit joins generated by deep path expressions are disallowed. Use an <code>EXISTS</code> subquery if you need to join relations in the <code>WHERE</code> clause or a scalar subquery if you need joins for the <code>SET</code> clause.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Currently you can&#8217;t make use of advanced SQL features like CTEs when having a polymorphic <code>UPDATE</code> except for single table inheritance. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/345">#345</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="update-collection-statement"><a class="anchor" href="#update-collection-statement"></a>13.4. UPDATE collection statement</h3>
<div class="paragraph">
<p>The <code>UPDATE</code> collection statement updates attributes as specified in the <code>SET</code> clause on entries of a collection of entities that satisfy the <code>WHERE</code> clause of the statement.
A collection update builder can be created via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#updateCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.updateCollection()</code></a>.
The statement only works on collections that have a join or collection table.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.updateCollection(em, Cat.class, "kittens", "cat")
    .set("cat.id", 2)
    .where("cat.id").eq(1);</pre>
</div>
</div>
<div class="paragraph">
<p>The alias <code>cat</code> or in general, an update collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source id i.e. <code>cat.id</code></p>
</li>
<li>
<p>The target id i.e. <code>cat.kittens.id</code></p>
</li>
<li>
<p>The collection index/key i.e. <code>KEY(cat.kittens)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The logical SQL for this <em>re-parenting query</em> looks like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat(kittens) cat
SET cat.id = :param_1
WHERE cat.id = :param_2</pre>
</div>
</div>
<div class="paragraph">
<p>This will cause all kittens that previously were associated with the cat with id 1 now to be the kittens of the cat with id 2.</p>
</div>
</div>
<div class="sect2">
<h3 id="insert-select-statement"><a class="anchor" href="#insert-select-statement"></a>13.5. INSERT-SELECT statement</h3>
<div class="paragraph">
<p>The <code>INSERT-SELECT</code> statement allows to create new entities based on result of a <code>SELECT</code> query.
An insert builder can be created via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#insert(javax.persistence.EntityManager,%20java.lang.Class)"><code>CriteriaBuilderFactory.insert()</code></a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This feature is currently only supported with Hibernate!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s consider a simple entity class for <code>INSERT</code> statement examples</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@Entity
public class Pet {

    @Id
    @GeneratedValue
    private Long id;
    @ManyToOne(optional = false)
    private Cat cat;
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">InsertCriteriaBuilder&lt;Cat&gt; cb = cbf.insert(em, Pet.class)
    .from(Cat.class, "c")
    .bind("cat").select("c")
    .where("owner").isNotNull();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">INSERT INTO Pet(cat)
SELECT c
FROM Cat c
WHERE c.owner IS NOT NULL</pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseInsertCriteriaBuilder.html#bind(java.lang.String)"><code>bind()</code></a> method allows to bind any select expression to an attribute of the <code>Pet</code> entity.
You can also bind values directly with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseInsertCriteriaBuilder.html#bind(java.lang.String,%20java.lang.Object)"><code>bind(String, Object)</code></a> if you want.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate 4.2 does not support parameters in the <code>SELECT</code> clause, so you will have to render values as literals instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see, we didn&#8217;t specify the <code>id</code> attribute. This is because it&#8217;s value is going to be generated by the database.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using Hibernate with embedded ids, you <strong>must</strong> map all the columns as <strong>basic values</strong>(no relations) directly into the entity itself, otherwise you won&#8217;t be able to assign a value to the attributes/columns.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When using Oracle, generated identifiers currently don&#8217;t work. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/306">#306</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="insert-select-collection-statement"><a class="anchor" href="#insert-select-collection-statement"></a>13.6. INSERT-SELECT collection statement</h3>
<div class="paragraph">
<p>The <code>INSERT-SELECT</code> collection statement inserts new collection entries.
A collection insert builder can be created via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#insertCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)"><code>CriteriaBuilderFactory.insertCollection()</code></a>.
The statement only works on collections that have a join or collection table.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">InsertCriteriaBuilder&lt;Cat&gt; cb = cbf.insertCollection(em, Cat.class, "kittens", "cat")
    .from(Cat.class, "c")
    .bind("cat.id", 2)
    .bind("cat.kittens.id").select("c.kittens.id)
    .where("c.id").eq(1);</pre>
</div>
</div>
<div class="paragraph">
<p>The alias <code>cat</code> or in general, an insert collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The source id i.e. <code>cat.id</code></p>
</li>
<li>
<p>The target id i.e. <code>cat.kittens.id</code></p>
</li>
<li>
<p>The collection index/key i.e. <code>KEY(cat.kittens)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The logical SQL for this <em>kittens copying query</em> looks like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">INSERT INTO Cat.kittens(id, _collection.id)
SELECT :param_1, kittens_1.id
FROM Cat c
LEFT JOIN c.kittens kittens_1
WHERE c.id = :param_2</pre>
</div>
</div>
<div class="paragraph">
<p>This will copy all kittens that are associated with the cat with id 1 to the kittens of the cat with id 2.</p>
</div>
</div>
<div class="sect2">
<h3 id="cte-support"><a class="anchor" href="#cte-support"></a>13.7. CTE support</h3>
<div class="paragraph">
<p>If the underlying DBMS supports the use of CTEs on <em>modification</em> statements, you can make use of those by defining them via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CTEBuilder.html#with(java.lang.Class)"><code>with()</code></a>.
For further information on this, check out the <a href="#ctes">CTE chapter</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="returning-clause-support"><a class="anchor" href="#returning-clause-support"></a>13.8. RETURNING clause support</h3>
<div class="paragraph">
<p>The <code>RETURNING</code> clause allows to return values to the client based on the modified entities of a DML statement.
Every DML statement can return any attributes of the entities that the statement modified.</p>
</div>
<div class="paragraph">
<p>All query builders for DML statements provide <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ModificationCriteriaBuilder.html#getWithReturningQuery(java.lang.String,%20java.lang.Class)"><code>getWithReturningQuery()</code></a> variants
for creating a JPA <code>TypedQuery</code> from specifiable attributes which should be <em>returned</em> for modified entities.</p>
</div>
<div class="paragraph">
<p>The <code>TypedQuery</code> instance always returns a single <code>ReturningResult</code>. Calling <code>getResultList()</code> will just wrap the result of <code>getSingleResult()</code> in a list.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although the builder returns a <code>TypedQuery</code> which normally doesn&#8217;t require a transaction, you have to execute such a query within an active transaction since it actually modifies entities.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For every <code>getWithReturningQuery()</code> variant, there exists a <code>executeWithReturning()</code> variant that can be used as a short hand for <code>getWithReturningQuery().getSingleResult()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>ReturningResult</code> basically gives you access to the update count via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ReturningResult.html#getUpdateCount()"><code>getUpdateCount()</code></a>
and a result list, representing the attributes of modified entities that were requested to be returned, via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ReturningResult.html#getResultList()"><code>getResultList()</code></a>.
In addition to that, it also offers access to the <em>last returned result</em> via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ReturningResult.html#getLastResult()"><code>getLastResult()</code></a>, but this might get removed in the future.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As you will see in the <a href="#updatable-ctes">next chapter</a>, on some DBMS you can even <em>pipe</em> data returned by DML into other queries.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following examples will show how the different <code>executeWithReturning()</code> variants can be used.</p>
</div>
<div class="sect3">
<h4 id="returning-from-delete-statement"><a class="anchor" href="#returning-from-delete-statement"></a>13.8.1. RETURNING from DELETE statement</h4>
<div class="paragraph">
<p>Let&#8217;s see how we can retrieve the names of cats that have been deleted.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">DeleteCriteriaBuilder&lt;Cat&gt; cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").like().value("Billy%").noEscape();
ReturningResult&lt;String&gt; result = cb.executeWithReturning("name", String.class);
List&lt;String&gt; names = result.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Make sure your DBMS supports returning non-generated columns in the <a href="#anchor-dml-dbms-compatibility">DBMS compatibility matrix</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">DELETE FROM Cat cat
WHERE cat.name LIKE :param_1
RETURNING name</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="returning-from-update-statement"><a class="anchor" href="#returning-from-update-statement"></a>13.8.2. RETURNING from UPDATE statement</h4>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">UpdateCriteriaBuilder&lt;Cat&gt; cb = cbf.update(em, Cat.class, "cat")
    .setExpression("cat.name", "UPPER(cat.name)")
    .where("cat.name").like().value("Billy%").noEscape();
ReturningResult&lt;Tuple&gt; result = cb.executeWithReturning("id", "name");
List&lt;Tuple&gt; updatedCatIdAndNames = result.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Also make sure your DBMS supports returning multiple modified rows in the <a href="#anchor-dml-dbms-compatibility">DBMS compatibility matrix</a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name LIKE :param_1
RETURNING id, name</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="returning-from-insert-select-statement"><a class="anchor" href="#returning-from-insert-select-statement"></a>13.8.3. RETURNING from INSERT-SELECT statement</h4>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">InsertCriteriaBuilder&lt;Cat&gt; cb = cbf.insert(em, Pet.class)
    .from(Cat.class, "c")
    .bind("cat").select("c")
    .where("owner").isNotNull();
ReturningResult&lt;Pet&gt; result = cb.executeWithReturning(new ReturningObjectBuilder&lt;Pet&gt;() {
    @Override
    public &lt;X extends ReturningBuilder&lt;X&gt;&gt; void applyReturning(X returningBuilder) {
        returningBuilder.returning("id");
    }

    @Override
    public Pet build(Object[] tuple) {
        return new Pet((Long) tuple[0]);
    }

    @Override
    public List&lt;T&gt; buildList(List&lt;T&gt; list) {
        return list;
    }
});
List&lt;Pet&gt; createdPetIds = result.getResultList();</pre>
</div>
</div>
<div class="paragraph">
<p>Although not very useful, this will return pet objects with the ids of the inserted pet entities set.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">INSERT INTO Pet(cat)
SELECT c
FROM Cat c
WHERE c.owner IS NOT NULL
RETURNING id</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-dml-dbms-compatibility"><a class="anchor" href="#anchor-dml-dbms-compatibility"></a>13.9. DBMS compatibility</h3>
<div class="paragraph">
<p>Although it might be possible to retrieve other columns based on identifiers for DBMS that don&#8217;t support <code>RETURNING</code> all columns natively, there is no emulation implemented yet.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>DBMS</strong></th>
<th class="tableblock halign-left valign-top">RETURNING generated</th>
<th class="tableblock halign-left valign-top">RETURNING multiple rows</th>
<th class="tableblock halign-left valign-top">RETURNING all</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL Server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ctes"><a class="anchor" href="#ctes"></a>14. CTEs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>CTEs provide a way to introduce statements into a larger query that can be reused. CTEs are like temporary entity sets/tables that are created for the scope of the query and then deleted.
A CTE normally contains a <code>SELECT</code> statement, but depending on the DBMS support, can also contain <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This feature is currently only supported with Hibernate!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Before you can define a query for a CTE, the structure of the it has to be defined in a similar manner as an entity is defined.
Don&#8217;t forget to also add it to your persistence.xml so that the JPA provider can discover it.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@CTE    // from com.blazebit.persistence
@Entity // from javax.persistence
public class MyCte {

    private Long id;

    @Id // from javax.persistence
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
}</pre>
</div>
</div>
<div class="paragraph">
<p>The difference to a normal entity is that in addition to that, the <code>CTE</code> annotation is applied which treats it like a view i.e. no DDL is generated for it.
A CTE can be defined on a top level query builder by using the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CTEBuilder.html#with(java.lang.Class)"><code>with(Class&lt;?&gt;)</code></a> method.
The created CTE builder has to be finished by calling <code>end()</code> on it.</p>
</div>
<div class="paragraph">
<p>All attributes of a CTE must be bound to expressions with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/SelectBaseCTECriteriaBuilder.html#bind(java.lang.String)"><code>bind()</code></a> like in the following.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;MyCte&gt; cb = cbf.create(em, MyCte.class)
    .with(MyCte.class)
        .from(Cat.class, "cat")
        .bind("id").select("cat.id")
    .end();</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since you can map columns multiple times in the CTE entity, it is sufficient to make sure that all columns have values bound through attribute bindings. If a column is left out, you will get an exception.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see from the example, the API tries to look as much as possible like the CTE syntax as defined in the SQL-99 standard.
As for all advanced features, the query string returned by <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Queryable.html#getQueryString()"><code>getQueryString()</code></a> only represents the <em>logical structure</em> of the whole query in a syntax that might be used one day by JPA providers to support this feature natively.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    SELECT cat.id FROM Cat cat
)
SELECT myCte FROM MyCte myCte</pre>
</div>
</div>
<div class="sect2">
<h3 id="cte-implementation-notes"><a class="anchor" href="#cte-implementation-notes"></a>14.1. Implementation notes</h3>
<div class="paragraph">
<p>Currently the CTE support is only implemented for Hibernate because of the deep integration that is needed for it to work.
The integration with the persistence provider happens in the implementation of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/ExtendedQuerySupport.html"><code>com.blazebit.persistence.spi.ExtendedQuerySupport</code></a>
which tries to focus on the minimal necessary methods needed for the integration to work.</p>
</div>
<div class="paragraph">
<p>In case of Hibernate, a CTE entity class is treated as if <code>org.hibernate.annotations.Subselect</code> was annotated.
Hibernate generally generates from clause elements of the form <code>( select * from MyCTE )</code> for <code>Subselect</code> entities which we replace simply by the name of the CTE.</p>
</div>
<div class="paragraph">
<p>The current implementation extracts the SQL from various template JPQL queries that are created behind the scenes.
After applying different transformations on the SQL and merging it together to a single SQL query, the new SQL replaces is used in a special JPQL query object.
The special JPQL query object is what you can finally execute. It will make use of the SQL query that was created before.</p>
</div>
<div class="paragraph">
<p>Every CTE will result in a separate JPQL query behind the scenes from which the SQL is extracted.
The SQL from the main query, together with the SQLs from the CTEs are put together to form the full SQL query.
It is that SQL, the special JPQL query receives for later execution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In order to support the <code>org.hibernate.FetchMode.SUBSELECT</code> this library ships with custom implementations of <code>org.hibernate.persister.collection.CollectionPersister</code>.
Custom persister implementations should be made aware of CTEs in a similar fashion to be able to make use of the fetch mode.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="recursive-ctes"><a class="anchor" href="#recursive-ctes"></a>14.2. Recursive CTEs</h3>
<div class="paragraph">
<p>CTEs not only provide a way to extract subqueries or use subqueries in the FROM clause, but also to implement recursive queries.</p>
</div>
<div class="paragraph">
<p>A recursive CTE is normally composed of two parts, a base query(non-recursive query) and a recursive query connected with the <strong>SET</strong> operator <code>UNION</code> or <code>UNION ALL</code>.
The recursive part is allowed to refer to the CTE itself.</p>
</div>
<div class="paragraph">
<p>A recursive CTE is normally evaluated in iterations</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The base query is evaluated and the result put into a temporary work set/table</p>
</li>
<li>
<p>The recursive query operates on the work set/table data and replaces it with the newly produced data</p>
</li>
<li>
<p>When the recursive query didn&#8217;t produce data, the recursion and thus the query is finished</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following illustrates how the ancestor hierarchy of an entity can be retrieved.</p>
</div>
<div class="listingblock">
<div class="title">CTE structure definition</div>
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@CTE    // from com.blazebit.persistence
@Entity // from javax.persistence
public class CatCte {

    private Long id;
    private Cat ancestor;

    @Id // from javax.persistence
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    @ManyToOne
    public Cat getAncestor() { return ancestor; }
    public void setAncestor(Cat ancestor) { this.ancestor = ancestor; }
}</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Recursive query</div>
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;CatCte&gt; cb = cbf.create(em, CatCte.class)
    .withRecursive(CatCte.class)
        .from(Cat.class, "cat") <i class="conum" data-value="1"></i><b>(1)</b>
        .bind("id").select("cat.id")
        .bind("ancestor").select("cat.ancestor")
        .where("id").eq(someCatId)
    .unionAll()
        .from(Cat.class, "cat")
        .from(CatCte.class, "parentCat") <i class="conum" data-value="2"></i><b>(2)</b>
        .bind("id").select("cat.id")
        .bind("ancestor").select("cat.ancestor")
        .where("id").eqExpression("parentCat.ancestor.id") <i class="conum" data-value="3"></i><b>(3)</b>
    .end();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start with the non-recursive query and just bind the cat attributes of the desired cat</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We refer to the CTE itself in the recursive query to be able to <em>join</em> data with data of the previous iteration</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Only <em>join</em> the cats that are an <code>ancestor</code> of the cats from the previous iteration</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Logical representation</div>
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH RECURSIVE CatCte(id, ancestor) AS(
    SELECT cat.id, cat.ancestor FROM Cat cat WHERE cat.id = :someCatId
    UNION ALL
    SELECT cat.id, cat.ancestor FROM Cat cat, CatCte parentCat WHERE cat.id = parentCat.ancestor.id
)
SELECT catCte FROM CatCte catCte</pre>
</div>
</div>
<div class="paragraph">
<p>This will return all the ancestors of the Cat with an id equal to <strong>someCatId</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="updatable-ctes"><a class="anchor" href="#updatable-ctes"></a>14.3. Updatable CTEs</h3>
<div class="paragraph">
<p>An updatable CTE is like a normal CTE, but the data comes from returned attributes of a DML statement.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At this point, only PostgreSQL and DB2 support this feature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can start an updatable CTE with the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CTEBuilder.html#withReturning(java.lang.Class)"><code>withReturning()</code></a> method and subsequently decide the DML statement type.
The query builder for the DML statement provides a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/ReturningBuilder.html#returning(java.lang.String,%20java.lang.String)"><code>returning()</code></a> method for binding attributes of the DML statement to a CTE attribute.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;MyCte&gt; cb = cbf.create(em, MyCte.class)
    .withReturning(MyCte.class)
        .delete(Cat.class, "cat")
        .where("cat.name").isNull()
        .returning("id", "cat.id")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    DELETE FROM Cat cat
    WHERE cat.name IS NULL
    RETURNING id
)
SELECT myCte FROM MyCte myCte</pre>
</div>
</div>
<div class="paragraph">
<p>The query deletes cats with a <code>NULL</code> name. For every deleted cat, a temporary <code>MyCte</code> entity with the cat&#8217;s id bound is created. Finally the deleted cats are queried through <code>MyCte</code>.</p>
</div>
<div class="paragraph">
<p>As you can imagine, this can be used to define very efficient data pipelines.</p>
</div>
<div class="paragraph">
<p>One problem with updatable CTEs that might come up is, that you might want to query an entity in one CTE, while also wanting to do a modification in a different CTE.
Since the visibility of changes that are done in updatable CTEs might differ from one to another DBMS, Blaze Persistence offers a way to resolve this special case.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .withReturning(MyCte.class)
        .delete(Cat.class, "cat")
        .where("cat.name").isNull()
        .returning("id", "cat.id")
    .end()
    .from(Cat.class, "theCat");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    DELETE FROM Cat cat
    WHERE cat.name IS NULL
    RETURNING id
)
SELECT theCat FROM Cat theCat</pre>
</div>
</div>
<div class="paragraph">
<p>Although the CTE <code>MyCte</code> is never used, it is still executed. Depending on the DBMS you are on, the <code>SELECT</code> statement will return the state before or after the <code>DELETE</code> statement happened.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Multiple updatable CTEs for the same entity in a single query are not supported.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to make the <code>SELECT</code> statement portable, Blaze Persistence provides a way to qualify a <code>FROM</code> clause element to use the <em>old</em> or <em>new</em> state i.e. before or after modifications happened.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb = cbf.create(em, Cat.class)
    .withReturning(MyCte.class)
        .delete(Cat.class, "cat")
        .where("cat.name").isNull()
        .returning("id", "cat.id")
    .end()
    .fromOld(Cat.class, "theCat");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS(
    DELETE FROM Cat cat
    WHERE cat.name IS NULL
    RETURNING id
)
SELECT theCat FROM OLD(Cat) theCat</pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromOld(java.lang.Class,%20java.lang.String)"><code>fromOld()</code></a> method qualifies the <code>FROM</code> element in the query as <em>old</em>.
In the same way does <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FromBuilder.html#fromNew(java.lang.Class,%20java.lang.String)"><code>fromNew()</code></a> qualify the <code>FROM</code> element as <em>new</em>.</p>
</div>
<div class="paragraph">
<p>In general, we advise you to rethink how you do the querying when having a need for this feature. It should only be used as a last resort.</p>
</div>
</div>
<div class="sect2">
<h3 id="anchor-ctes-dbms-compatibility"><a class="anchor" href="#anchor-ctes-dbms-compatibility"></a>14.4. DBMS compatibility</h3>
<div class="paragraph">
<p>Currently there is no emulation implemented for databases that do not support CTEs natively.
CTEs are well tested with <strong>PostgreSQL</strong>, <strong>DB2</strong>, <strong>Oracle</strong> and <strong>Microsoft SQL Server</strong>. Many of the basic features work with <strong>H2</strong>, but beware that H2 support for CTEs is still experimental.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
We do not recommend using CTEs with H2 because of some very serious limitations. Using a CTE in an <code>IN</code> predicate or using <code>LIMIT</code> within the CTE have proven to produce wrong results. You also can&#8217;t have multiple CTEs per query.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DB2 does not support JOINs in the recursive part of a CTE: <a href="https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/com.ibm.db2z10.doc.codes/src/tpc/n345.dita" class="bare">https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/com.ibm.db2z10.doc.codes/src/tpc/n345.dita</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>CTEs in DML</em> are uses of a CTE where the top level statement is a DML. In contrast, <em>Updatable CTEs</em> are CTEs that <strong>contain</strong> DML and get their values from a <code>RETURNING</code> clause of the DML.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>DBMS</strong></th>
<th class="tableblock halign-left valign-top">Normal CTEs</th>
<th class="tableblock halign-left valign-top">Recursive CTEs</th>
<th class="tableblock halign-left valign-top">CTEs in DML</th>
<th class="tableblock halign-left valign-top">Updatable CTEs</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">partly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL Server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="set-operations"><a class="anchor" href="#set-operations"></a>15. Set operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A set operation connects result lists of queries. The most well-known set operations are <code>UNION</code> and <code>UNION ALL</code> which merge the result lists of two queries.
Apart from that, there is an operation that produces the commonalities of two result lists i.e. the intersection and an operation that subtracts commonalities i.e. minus/except.</p>
</div>
<div class="paragraph">
<p>All operations require that the connected queries must have the same number of select items with the same data types.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This feature is currently only supported with Hibernate!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The SQL standard defines the following set operations for connecting two queries <em>query1</em> and <em>query2</em> which is also what Blaze Persistence adopts</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UNION</code> - Merges results from <em>query1</em> and <em>query2</em> but filters out duplicates.</p>
</li>
<li>
<p><code>UNION ALL</code> - Merges results from <em>query1</em> and <em>query2</em> <strong>without</strong> filtering duplicates.</p>
</li>
<li>
<p><code>INTERSECT</code> - Creates a result based on distinct elements that appear in both <em>query1</em> and <em>query2</em></p>
</li>
<li>
<p><code>INTERSECT ALL</code> - Creates a result based on all elements that appear in both <em>query1</em> and <em>query2</em> i.e. not filtering out duplicates</p>
</li>
<li>
<p><code>EXCEPT</code> - Creates a result based on distinct elements of <em>query1</em> that don&#8217;t appear in <em>query2</em></p>
</li>
<li>
<p><code>EXCEPT ALL</code> - Creates a result based on all elements of <em>query1</em> that don&#8217;t appear in <em>query2</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These set operations are not only useful for scalar queries, but can also be used when querying for entities.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are some limitations to using set operations with <a href="#polymorphism">polymorphic queries</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="normal-set-operations"><a class="anchor" href="#normal-set-operations"></a>15.1. Normal set operations</h3>
<div class="paragraph">
<p>A set operation ends the source query builder and starts a new query builder. This new builder then has to be explicitly ended.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">FinalSetOperationCriteriaBuilder&lt;Cat&gt; cb = <i class="conum" data-value="1"></i><b>(1)</b>
    cbf.create(em, Cat.class)
        .from(Cat.class, "cat")
        .where("name").eq("Billy")
    .unionAll() <i class="conum" data-value="2"></i><b>(2)</b>
        .from(Cat.class, "cat")
        .where("name").eq("Johnny")
    .endSet(); <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The query builder has a different type, since it represents the builder for the set operation query</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use any set operation here</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You must end the set operation explicitly</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The call to <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#unionAll()"><code>unionAll()</code></a> ends the previous query builder making any operations on it fail with an exception.
Finally <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseOngoingSetOperationBuilder.html#endSet()"><code>endSet()</code></a> ends the last query builder.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat WHERE cat.name = :param_1
UNION ALL
SELECT cat FROM Cat cat WHERE cat.name = :param_2</pre>
</div>
</div>
<div class="paragraph">
<p>You can chain as many queries with set operations with the following methods</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#union()"><code>union()</code></a> - <code>query1 UNION query2</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#unionAll()"><code>unionAll()</code></a> - <code>query1 UNION ALL query2</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#intersect()"><code>intersect()</code></a> - <code>query1 INTERSECT query2</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#intersectAll()"><code>intersectAll()</code></a> - <code>query1 INTERSECT ALL query2</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#except()"><code>except()</code></a> - <code>query1 EXCEPT query2</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#exceptAll()"><code>exceptAll()</code></a> - <code>query1 EXCEPT ALL query2</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All operations have the same precedence i.e. they are executed from left to right.
The only way to order the operations is by grouping them with <em>parenthesis</em> as shown in the next <a href="#anchor-set-operations-right-nesting">chapter</a>.</p>
</div>
<div class="paragraph">
<p>You can also make use of set operations in CTEs like the following example shows.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">@CTE    // from com.blazebit.persistence
@Entity // from javax.persistence
public class MyCte {

    private Long id;

    @Id // from javax.persistence
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb =
    cbf.create(em, Cat.class)
        .with(MyCte.class)
                .from(Cat.class, "cat1")
                .bind("id").select("cat1.id")
                .where("name").eq("Billy")
            .unionAll()
                .from(Cat.class, "cat2")
                .bind("id").select("cat2.id")
                .where("name").eq("Johnny")
            .unionAll()
                .from(Cat.class, "cat3")
                .bind("id").select("cat3.id")
                .where("name").eq("Franky")
            .endSet() <i class="conum" data-value="1"></i><b>(1)</b>
        .end()
        .from(Cat.class, "cat")
        .where("id").in()
            .from(MyCte.class, "myCte")
            .select("myCte.id")
        .end();</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseFinalSetOperationBuilder.html">result of <code>endSet()</code></a> allows to apply sorting and limiting</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The API is the same, and produces the expected query.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">WITH MyCte(id) AS (
    SELECT cat1.id FROM Cat cat1 WHERE cat1.name = :param_1
    UNION ALL
    SELECT cat2.id FROM Cat cat2 WHERE cat2.name = :param_2
    UNION ALL
    SELECT cat3.id FROM Cat cat3 WHERE cat3.name = :param_3
)
SELECT cat FROM Cat cat WHERE cat.id IN (
    SELECT myCte.id FROM MyCte myCte
)</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, there is also support for set operations within subqueries.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Cat&gt; cb =
    cbf.create(em, Cat.class)
        .from(Cat.class, "cat")
        .where("id").in()
                .from(Cat.class, "cat1")
                .select("cat1.id")
                .where("name").eq("Billy")
            .unionAll()
                .from(Cat.class, "cat2")
                .select("cat2.id")
                .where("name").eq("Johnny")
            .unionAll()
                .from(Cat.class, "cat3")
                .select("cat3.id")
                .where("name").eq("Franky")
            .endSet()
        .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat WHERE cat.id IN (
    FUNCTION(
        'SET_UNION_ALL',
        (SELECT cat1.id FROM Cat cat1 WHERE cat1.name = :param_1),
        (SELECT cat2.id FROM Cat cat2 WHERE cat2.name = :param_2),
        (SELECT cat3.id FROM Cat cat3 WHERE cat3.name = :param_3)
    )
)</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, this is rendered differently. It makes use of custom <a href="#jpql-functions">JPQL functions</a> that could even be directly executed by the JPA provider.
This is possible because Blaze Persistence registers the <a href="#jpql-functions">JPQL functions</a> for the entire persistence unit. These functions produce the necessary SQL
in-place which is more efficient than a complete SQL replacement. The following set operation functions are registered by default:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#set-union-function"><code>SET_UNION</code></a></p>
</li>
<li>
<p><a href="#set-union-all-function"><code>SET_UNION_ALL</code></a></p>
</li>
<li>
<p><a href="#set-intersect-function"><code>SET_INTERSECT</code></a></p>
</li>
<li>
<p><a href="#set-intersect-all-function"><code>SET_INTERSECT_ALL</code></a></p>
</li>
<li>
<p><a href="#set-except-function"><code>SET_EXCEPT</code></a></p>
</li>
<li>
<p><a href="#set-except-all-function"><code>SET_EXCEPT_ALL</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="anchor-set-operations-right-nesting"><a class="anchor" href="#anchor-set-operations-right-nesting"></a>15.2. Right nested set operations</h3>
<div class="paragraph">
<p>In order to support grouping of set operations, Blaze Persistence has a special API for grouping the left and right hand sides of set operations.
Normally in SQL, the grouping can be achieved by using parenthesis which you can see in the <em>logical query</em>. Unfortunately it is not so easy to provide support
for such a grouping in a builder API which is why there are special methods for starting and connecting such a group with set operations.
Applying a set operation on such a parenthesis is possible with one of the <code>startXXX()</code> methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startUnion()"><code>startUnion()</code></a> - <code>query1 UNION (...)</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startUnionAll()"><code>startUnionAll()</code></a> - <code>query1 UNION ALL (...)</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startIntersect()"><code>startIntersect()</code></a> - <code>query1 INTERSECT (...)</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startIntersectAll()"><code>startIntersectAll()</code></a> - <code>query1 INTERSECT ALL (...)</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startExcept()"><code>startExcept()</code></a> - <code>query1 EXCEPT (...)</code></p>
</li>
<li>
<p><a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startExceptAll()"><code>startExceptAll()</code></a> - <code>query1 EXCEPT ALL (...)</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">FinalSetOperationCriteriaBuilder&lt;Cat&gt; cb =
    cbf.create(em, Cat.class)
            .from(Cat.class, "cat")
            .where("name").eq("Billy")
        .startUnionAll()
                .from(Cat.class, "cat")
                .where("name").eq("Johnny")
            .union()
                .from(Cat.class, "cat")
                .where("name").eq("Franky")
        .endSet() <i class="conum" data-value="1"></i><b>(1)</b>
    .endSet(); <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ends the nested set operation group started by <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/SetOperationBuilder.html#startUnionAll()"><code>startUnionAll()</code></a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The second <code>endSet()</code> might feel weird, but is actually necessary to end the implicitly started set operation on the main query</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can imagine any <code>startXXX()</code> being the opening parenthesis that must be ended with a <code>endSet()</code> representing the closing parenthesis.
Since you could apply other set operations on that <em>group</em>, you are required to signal that you are done with the builder by calling <code>endSet()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat WHERE cat.name = :param_1
UNION ALL
(
    SELECT cat FROM Cat cat WHERE cat.name = :param_2
    UNION
    SELECT cat FROM Cat cat WHERE cat.name = :param_3
)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="left-nested-set-operations"><a class="anchor" href="#left-nested-set-operations"></a>15.3. Left nested set operations</h3>
<div class="paragraph">
<p>Similarly you can also have a left nested group for set operations.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">FinalSetOperationCriteriaBuilder&lt;Cat&gt; cb =
    cbf.startSet(em, Cat.class) <i class="conum" data-value="1"></i><b>(1)</b>
            .from(Cat.class, "cat")
            .where("name").eq("Billy")
        .unionAll()
            .from(Cat.class, "cat")
            .where("name").eq("Johnny")
        .endSet()
    .union()
        .from(Cat.class, "cat")
        .where("name").eq("Franky")
    .endSet();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">(
    SELECT cat FROM Cat cat WHERE cat.name = :param_1
    UNION ALL
    SELECT cat FROM Cat cat WHERE cat.name = :param_2
)
UNION
SELECT cat FROM Cat cat WHERE cat.name = :param_3</pre>
</div>
</div>
<div class="paragraph">
<p>The left nesting is started by <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CriteriaBuilderFactory.html#startSet(javax.persistence.EntityManager,%20java.lang.Class)"><code>startSet()</code></a> which
more or less represents the <em>open parenthesis</em>. The parenthesis is then closed by calling <code>endSet()</code>.</p>
</div>
<div class="paragraph">
<p>At the beginning of every <em>nesting group</em>, you can start as many left nestings as you want by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/StartOngoingSetOperationBuilder.html#startSet()"><code>startSet()</code></a>
and doing so intuitively always results in an <em>open parenthesis</em> that has to be closed by a <code>endSet()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="empty-nested-set-operations"><a class="anchor" href="#empty-nested-set-operations"></a>15.4. Empty nested set operations</h3>
<div class="paragraph">
<p>As a convenience, Blaze Persistence allows to have <em>empty</em> nested set operation groups like the following.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">FinalSetOperationCriteriaBuilder&lt;Cat&gt; cb =
    cbf.startSet(em, Cat.class)
    .endSet()
    .union()
        .from(Cat.class, "cat")
        .where("name").eq("Franky")
    .endSet();</pre>
</div>
</div>
<div class="paragraph">
<p>Contrary to what you might think, this is allowed and results in the following query.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat WHERE cat.name = :param_1</pre>
</div>
</div>
<div class="paragraph">
<p>This is done to make it possible to pass the result of <code>startSet()</code> to consumers which may or may not add set operands.</p>
</div>
</div>
<div class="sect2">
<h3 id="ordering-and-limiting-with-set-operations"><a class="anchor" href="#ordering-and-limiting-with-set-operations"></a>15.5. Ordering and limiting with set operations</h3>
<div class="paragraph">
<p>Since set operations might change the order of elements in the overall result, they also allow to define an <code>ORDER BY</code> clause for the result of a set operation group.</p>
</div>
<div class="paragraph">
<p>The order by elements are resolved against the first set operand. This means that you can only order by select aliases of the first query in the set operation.
If the order by element does not refer to a select alias, it is implicitly resolved against the query root like in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">FinalSetOperationCriteriaBuilder&lt;Cat&gt; cb =
    cbf.create(em, Cat.class)
        .from(Cat.class, "cat")
        .where("name").eq("Billy")
    .unionAll()
        .from(Cat.class, "cat")
        .where("name").eq("Johnny")
    .endSet()
    .orderByAsc("name")
    .setFirstResult(1)
    .setMaxResults(1);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat FROM Cat cat WHERE cat.name = :param_1
UNION ALL
SELECT cat FROM Cat cat WHERE cat.name = :param_2
ORDER BY name ASC NULLS LAST
LIMIT 1 OFFSET 1</pre>
</div>
</div>
<div class="paragraph">
<p>Apart from the ordering by name, this query will also skip the first element and <em>limit</em> the elements to be returned to one.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Note that <code>LIMIT</code> and <code>OFFSET</code> operate on the scalar results and not on entity elements. A collection joins might result in multiple elements per entity.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ordering and limiting is also possible for nested set operation groups and can be realized by invoking the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/OngoingSetOperationCriteriaBuilder.html#endSetWith()"><code>endSetWith()</code></a> operation.
Calling <code>endSetWith()</code> is necessary to end the current query builder i.e. switch the context to the whole set operation group.
After applying ordering and limiting the set operation group has to be closed with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/BaseOngoingFinalSetOperationBuilder.html#endSet()"><code>endSet()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">FinalSetOperationCriteriaBuilder&lt;Cat&gt; cb =
    cbf.startSet(em, Cat.class) <i class="conum" data-value="1"></i><b>(1)</b>
            .from(Cat.class, "cat")
            .where("name").eq("Billy")
        .unionAll()
            .from(Cat.class, "cat")
            .where("name").eq("Johnny")
        .endSetWith()
            .orderByAsc("name")
            .setMaxResults(1)
        .endSet()
    .union()
        .from(Cat.class, "cat")
        .where("name").eq("Franky")
    .endSet();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">(
    SELECT cat FROM Cat cat WHERE cat.name = :param_1
    UNION ALL
    SELECT cat FROM Cat cat WHERE cat.name = :param_2
    ORDER BY name
    LIMIT 1
)
UNION
SELECT cat FROM Cat cat WHERE cat.name = :param_3</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-set-dbms-compatibility"><a class="anchor" href="#anchor-set-dbms-compatibility"></a>15.6. DBMS compatibility</h3>
<div class="paragraph">
<p>Currently there is no emulation implemented for databases that do not support set operations natively.
One type of emulation that is implemented however is for the non-distinct variants <code>INTERSECT ALL</code> and <code>EXCEPT ALL</code> in case the distinct variant is supported.
The emulation for the non-distinct variants is implemented by adding the <code>ROW_NUMBER</code> to an operand which is removed afterwards.</p>
</div>
<div class="paragraph">
<p>The DBMS support for set operations is quite good.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>DBMS</strong></th>
<th class="tableblock halign-left valign-top">UNION ALL</th>
<th class="tableblock halign-left valign-top">UNION</th>
<th class="tableblock halign-left valign-top">INTERSECT ALL</th>
<th class="tableblock halign-left valign-top">INTERSECT</th>
<th class="tableblock halign-left valign-top">EXCEPT ALL</th>
<th class="tableblock halign-left valign-top">EXCEPT</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>1</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>1</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>1</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>1</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>2</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>2</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes <sup>3</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes <sup>3</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL Server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes <sup>3</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes <sup>3</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>MySQL only supports the <code>UNION</code> and <code>UNION ALL</code> operator</p>
</li>
<li>
<p>For implementing the <code>ALL</code> variant, a row number for a grouping is required i.e. <code>ROW_NUMER() OVER()</code> which isn&#8217;t supported by H2</p>
</li>
<li>
<p>Emulated via <code>ROW_NUMBER</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Except for H2 the operations can also be used in almost any context.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>DBMS</strong></th>
<th class="tableblock halign-left valign-top">Use in CTE</th>
<th class="tableblock halign-left valign-top">In Subquery with LIMIT</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no <sup>1</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL Server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Since CTEs are pretty much experimental in H2, you might encounter problems like with parameters</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="entity-functions"><a class="anchor" href="#entity-functions"></a>16. Entity functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity functions are the equivalent of table-valued or table-generating functions in the ORM realm.</p>
</div>
<div class="paragraph">
<p>Currently, entity functions aren&#8217;t implemented but are about to be. See <a href="https://github.com/Blazebit/blaze-persistence/issues/181">#181</a> for further information.</p>
</div>
<div class="sect2">
<h3 id="built-in-entity-functions"><a class="anchor" href="#built-in-entity-functions"></a>16.1. Built-in entity functions</h3>

</div>
<div class="sect2">
<h3 id="custom-entity-functions"><a class="anchor" href="#custom-entity-functions"></a>16.2. Custom entity functions</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="jpql-functions"><a class="anchor" href="#jpql-functions"></a>17. JPQL functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JPQL offers many built-in functions as you can see in the <a href="#string-functions">expressions</a> chapter and as of JPA 2.1 has a syntax for calling database specific functions.
Normally when using the function syntax <code>FUNCTION ( function_name (, args)* )</code>, the JPA provider puts a function call into the SQL like <code>function_name ( args* )</code>.
Instead of simply passing through the function invocation to the SQL, Blaze Persistence decided to reuse the function syntax to allow calling so called JPQL functions.</p>
</div>
<div class="paragraph">
<p>JPQL functions are registered at configuration time and are integrated into a persistence unit, so you could even use the functions by using the JPA provider specific invocation syntax directly.
Except for a few special built-in functions, every function has DBMS specific implementations of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/JpqlFunction.html"><code>JpqlFunction</code></a> interface
that are registered through a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/JpqlFunctionGroup.html#add(java.lang.String,%20com.blazebit.persistence.spi.JpqlFunction)"><code>JpqlFunctionGroup</code></a> on the
<a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#registerFunction(com.blazebit.persistence.spi.JpqlFunctionGroup)"><code>CriteriaBuilderConfiguration</code></a>.</p>
</div>
<div class="paragraph">
<p>Depending on the DBMS that is encountered at runtime, Blaze Persistence selects the appropriate functions during configuration and registers them in the persistence unit.</p>
</div>
<div class="sect2">
<h3 id="special-built-in-functions"><a class="anchor" href="#special-built-in-functions"></a>17.1. Special built-in functions</h3>
<div class="paragraph">
<p>These functions have a deeper integration with the query building process and do not directly generate SQL.</p>
</div>
<div class="sect3">
<h4 id="size-function"><a class="anchor" href="#size-function"></a>17.1.1. SIZE function</h4>
<div class="paragraph">
<p>The <code>SIZE</code> function, which was already briefly explained in the <a href="#collection-functions">Collection functions</a> section, returns the number of elements of a mapped collection.
This function is defined by JPQL and Blaze Persistence chose to improve the performance by applying custom query transformations when encountering it.
Normally, a JPA provider will not care to optimize the <code>SIZE</code> function for you and will simply generate a correlated subquery for any uses.</p>
</div>
<div class="paragraph">
<p>Blaze Persistence currently has transformations for <code>SIZE</code> invocations in the <code>SELECT</code> and <code>ORDER BY</code> clauses.
These transformations happen during query generation, so you can see the result by calling <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/Queryable.html#getQueryString()"><code>getQueryString()</code></a> on your query builder.</p>
</div>
<div class="paragraph">
<p>The transformation will</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>add a <code>LEFT JOIN</code> for the collection of the <code>SIZE</code> invocation</p>
</li>
<li>
<p>add a <code>GROUP BY</code> for the entity that owns the collection</p>
</li>
<li>
<p>and replace the <code>SIZE</code> invocation with a <code>COUNT</code> or <code>COUNT_TUPLE</code> expression</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This transformation also works when having multiple <code>SIZE</code> invocations. If an invocation can&#8217;t be transformed that way, a simple correlated subquery is generated.
There are different reasons why a transformation could fail, but the most common are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The collection is a bag</p>
</li>
<li>
<p>The query has multiple query roots</p>
</li>
<li>
<p>Multiple <code>SIZE</code> invocations with different collection owners</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you prefer subqueries or have problems with the transformation, you can turn the transformation off via a <a href="#size_to_count_transformation">configuration property</a>.</p>
</div>
<div class="paragraph">
<p>Since the transformation introduces aggregate expressions into the query, it is necessary to have <a href="#implicit-group-by-generation">implicit group by generation</a> enabled
if other expressions appear in the <code>SELECT</code>, <code>ORDER BY</code> or <code>HAVING</code> clause. By default <a href="#implicit-group-by-generation">implicit group by generation</a> is enabled
and we recommend you don&#8217;t turn it off.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .select("cat.name")
    .select("SIZE(kittens)")
    .orderByDesc("id");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.name, FUNCTION('COUNT_TUPLE', kittens_1.id)
FROM Cat cat
LEFT JOIN cat.kittens kittens_1
GROUP BY cat.id, cat.name
ORDER BY cat.id DESC NULLS LAST</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the expressions <code>cat.name</code> and <code>id</code> of the <code>SELECT</code> and <code>ORDER BY</code> clause are implicitly added to the <code>GROUP BY</code> because of the aggregate function <code>COUNT_TUPLE</code> being used.</p>
</div>
</div>
<div class="sect3">
<h4 id="outer-function"><a class="anchor" href="#outer-function"></a>17.1.2. OUTER function</h4>
<div class="paragraph">
<p>The <code>OUTER</code> function is an extension provided by Blaze Persistence that can be used to refer to attributes of the parent query&#8217;s root.
By using <code>OUTER</code> you can avoid introducing the query root alias of the outer query into the subquery directly.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("subCat.name").notEqExpression("OUTER(name)")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE EXISTS (
    SELECT 1
    FROM Cat subCat
    WHERE subCat.name &lt;&gt; cat.name
)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>OUTER</code> invocation is replaced by the absolute path expression.</p>
</div>
<div class="paragraph">
<p>Currently it is not allowed to have nested <code>OUTER</code> invocations, but this is already planned. For more information see <a href="https://github.com/Blazebit/blaze-persistence/issues/317">#317</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="built-in-functions"><a class="anchor" href="#built-in-functions"></a>17.2. Built-in functions</h3>
<div class="paragraph">
<p>These functions are provided by Blaze Persistence and are registered by default in every <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html"><code>CriteriaBuilderConfiguration</code></a>.
They can be <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#getFunction(java.lang.String)">overridden</a> at configuration time if desired.</p>
</div>
<div class="paragraph">
<p>Every of the following functions has to be invoked with the JPA 2.1 function syntax.</p>
</div>
<div class="sect3">
<h4 id="count_tuple-function"><a class="anchor" href="#count_tuple-function"></a>17.2.1. COUNT_TUPLE function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'COUNT_TUPLE' (, 'DISTINCT' )?, args+ )</code></p>
</div>
<div class="paragraph">
<p>The <code>COUNT_TUPLE</code> function is like the regular <code>COUNT</code> function, but in addition allows to do distinct counting on multiple and embeddable attributes.
Some JPA providers ignore that some DBMS don&#8217;t support distinct counts on multiple columns and generate broken SQL.
This function will transform the distinct count for DBMS that don&#8217;t have native support to something equivalent.</p>
</div>
<div class="paragraph">
<p>The emulation is based on the idea, that the <strong>NUL</strong> character <code>\0</code> is a valid character in any text type on the DBMS but won&#8217;t ever appear in real data.
A distinct count for two columns can be emulated by doing the following expression instead</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">COUNT(DISTINCT
    COALESCE(
        NULLIF(
            COALESCE(
                COL1 || '', <i class="conum" data-value="1"></i><b>(1)</b>
                '\0'        <i class="conum" data-value="2"></i><b>(2)</b>
            ),
            ''              <i class="conum" data-value="3"></i><b>(3)</b>
        ),
        '\01'               <i class="conum" data-value="4"></i><b>(4)</b>
    ) ||
    '\0' ||                 <i class="conum" data-value="5"></i><b>(5)</b>
    COALESCE(
        NULLIF(
            COALESCE(
                COL2 || '',
                '\0'
            ),
            ''
        ),
        '\02'
    )
)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Concat with empty string to get implicit conversion to text type</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>NULL</code> values are replaced by the <strong>NUL</strong> character</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Produce <code>NULL</code> if the value is an empty string for the next step</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>NULL</code> is required so we can transform empty strings to the text <strong>NUL</strong> character concatenated with the column number i.e. <code>'\0' || '1'</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Separate the column values with a <strong>NUL</strong> character</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By doing a distinct count on the resulting string, the ANSI SQL distinct counting can be fully emulated.</p>
</div>
</div>
<div class="sect3">
<h4 id="cast-functions"><a class="anchor" href="#cast-functions"></a>17.2.2. CAST functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'CAST_XXX', argument )</code></p>
</div>
<div class="paragraph">
<p>There are multiple different cast functions for different data types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code> - <code>CAST_BOOLEAN</code></p>
</li>
<li>
<p><code>Byte</code> - <code>CAST_BYTE</code></p>
</li>
<li>
<p><code>Short</code> - <code>CAST_SHORT</code></p>
</li>
<li>
<p><code>Integer</code> - <code>CAST_INTEGER</code></p>
</li>
<li>
<p><code>Long</code> - <code>CAST_LONG</code></p>
</li>
<li>
<p><code>Float</code> - <code>CAST_FLOAT</code></p>
</li>
<li>
<p><code>Double</code> - <code>CAST_DOUBLE</code></p>
</li>
<li>
<p><code>Character</code> - <code>CAST_CHARACTER</code></p>
</li>
<li>
<p><code>String</code> - <code>CAST_STRING</code></p>
</li>
<li>
<p><code>BigInteger</code> - <code>CAST_BIGINTEGER</code></p>
</li>
<li>
<p><code>BigDecimal</code> - <code>CAST_BIGDECIMAL</code></p>
</li>
<li>
<p><code>java.sql.Time</code> - <code>CAST_TIME</code></p>
</li>
<li>
<p><code>java.sql.Date</code> - <code>CAST_DATE</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code> - <code>CAST_TIMESTAMP</code></p>
</li>
<li>
<p><code>java.util.Calendar</code> - <code>CAST_CALENDAR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A cast invocation will always generate a ANSI SQL cast. The SQL data type for a Java type is determined by <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/DbmsDialect.html#getSqlType(java.lang.Class)"><code>DbmsDialect.getSqlType()</code></a>.
By providing a <a href="#customize-dbms-dialect">custom DBMS dialect</a> you can override these types.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("FUNCTION('CAST_STRING', cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT FUNCTION('CAST_STRING', cat.age)
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="treat-functions"><a class="anchor" href="#treat-functions"></a>17.2.3. TREAT functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'TREAT_XXX', argument )</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This function is used internally and no user should ever have the need for this!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are multiple different treat functions for different data types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code> - <code>TREAT_BOOLEAN</code></p>
</li>
<li>
<p><code>Byte</code> - <code>TREAT_BYTE</code></p>
</li>
<li>
<p><code>Short</code> - <code>TREAT_SHORT</code></p>
</li>
<li>
<p><code>Integer</code> - <code>TREAT_INTEGER</code></p>
</li>
<li>
<p><code>Long</code> - <code>TREAT_LONG</code></p>
</li>
<li>
<p><code>Float</code> - <code>TREAT_FLOAT</code></p>
</li>
<li>
<p><code>Double</code> - <code>TREAT_DOUBLE</code></p>
</li>
<li>
<p><code>Character</code> - <code>TREAT_CHARACTER</code></p>
</li>
<li>
<p><code>String</code> - <code>TREAT_STRING</code></p>
</li>
<li>
<p><code>BigInteger</code> - <code>TREAT_BIGINTEGER</code></p>
</li>
<li>
<p><code>BigDecimal</code> - <code>TREAT_BIGDECIMAL</code></p>
</li>
<li>
<p><code>java.sql.Time</code> - <code>TREAT_TIME</code></p>
</li>
<li>
<p><code>java.sql.Date</code> - <code>TREAT_DATE</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code> - <code>TREAT_TIMESTAMP</code></p>
</li>
<li>
<p><code>java.util.Calendar</code> - <code>TREAT_CALENDAR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A treat invocation will <strong>only</strong> adjust the type of the expression in the JPQL expression and not cause an explicit cast on the DBMS side.
This can be used for cases when the type of an expression is actually known but can&#8217;t be inferred.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement the <a href="#values-clause"><code>VALUES</code> clause</a> for <em>basic</em> types. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="temporal-diff-functions"><a class="anchor" href="#temporal-diff-functions"></a>17.2.4. Temporal DIFF functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'XXX_DIFF', start, end )</code></p>
</div>
<div class="paragraph">
<p>Calculates the difference between the two given temporals like <code>end - start</code> and returning the difference in the requested unit as truncated integer.</p>
</div>
<div class="paragraph">
<p>The possible units and the respective function names are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Millisecond</strong> - <code>MILLISECOND_DIFF</code></p>
</li>
<li>
<p><strong>Second</strong> - <code>SECOND_DIFF</code></p>
</li>
<li>
<p><strong>Minute</strong> - <code>MINUTE_DIFF</code></p>
</li>
<li>
<p><strong>Hour</strong> - <code>HOUR_DIFF</code></p>
</li>
<li>
<p><strong>Day</strong> - <code>DAY_DIFF</code></p>
</li>
<li>
<p><strong>Month</strong> - <code>MONTH_DIFF</code></p>
</li>
<li>
<p><strong>Year</strong> - <code>YEAR_DIFF</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>end &lt; start</code> i.e. the value of <code>end</code> is before <code>start</code>, the result is negative. You are advised to explicitly handle this case or use the <code>ABS</code> function.</p>
</div>
</div>
<div class="sect3">
<h4 id="temporal-extract-functions"><a class="anchor" href="#temporal-extract-functions"></a>17.2.5. Temporal extract functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'XXX', argument )</code></p>
</div>
<div class="paragraph">
<p>Extracts the requested field of temporal argument like specified by the ANSI SQL <code>EXTRACT</code> expression.</p>
</div>
<div class="paragraph">
<p>The possible fields and the respective function names are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Second</strong> - <code>SECOND</code></p>
</li>
<li>
<p><strong>Minute</strong> - <code>MINUTE</code></p>
</li>
<li>
<p><strong>Hour</strong> - <code>HOUR</code></p>
</li>
<li>
<p><strong>Day</strong> - <code>DAY</code></p>
</li>
<li>
<p><strong>Month</strong> - <code>MONTH</code></p>
</li>
<li>
<p><strong>Year</strong> - <code>YEAR</code></p>
</li>
<li>
<p><strong>Epoch</strong> - <code>EPOCH</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="greatest-function"><a class="anchor" href="#greatest-function"></a>17.2.6. GREATEST function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'GREATEST', argument1, argument2 (, ...)? )</code></p>
</div>
<div class="paragraph">
<p>Returns the greatest value of all given arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="least-function"><a class="anchor" href="#least-function"></a>17.2.7. LEAST function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'LEAST', argument1, argument2 (, ...)? )</code></p>
</div>
<div class="paragraph">
<p>Returns the smallest value of all given arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="repeat-function"><a class="anchor" href="#repeat-function"></a>17.2.8. REPEAT function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'REPEAT', argument1, argument2 )</code></p>
</div>
<div class="paragraph">
<p>Returns a string with the <em>argument1</em> repeated for <em>argument2</em> times.</p>
</div>
</div>
<div class="sect3">
<h4 id="limit-function"><a class="anchor" href="#limit-function"></a>17.2.9. LIMIT function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'LIMIT', subquery, limit (, offset )? )</code></p>
</div>
<div class="paragraph">
<p>Applies the DBMS native way of doing <code>LIMIT</code> and <code>OFFSET</code> with the given values <code>limit</code> and <code>offset</code> on the given subquery.</p>
</div>
<div class="paragraph">
<p>The function makes use of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/DbmsLimitHandler.html"><code>DbmsLimitHandler</code></a> provided by the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/DbmsDialect.html#createLimitHandler()"><code>DbmsDialect</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Normally, you don&#8217;t need to use this function directly as the subquery builder API offers direct support for <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/LimitBuilder.html#setFirstResult(int)"><code>setFirstResult()</code></a> and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/LimitBuilder.html#setMaxResults(int)"><code>setMaxResults()</code></a>. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function which is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you use this function directly, beware that for some DBMS it might not be possible to use parameters in <code>LIMIT</code> and <code>OFFSET</code> so if you really require a parameter, make sure it works for your database.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="page_position-function"><a class="anchor" href="#page_position-function"></a>17.2.10. PAGE_POSITION function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'PAGE_POSITION', id_query, entity_id )</code></p>
</div>
<div class="paragraph">
<p>Returns the absolute 1-based position of the entity with the given id within the result produced by the given id query.
The id query must select only the id of an entity and must be of a basic type. The entity id can be a parameter or plain value.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/FullQueryBuilder.html#page(java.lang.Object,%20int)"><code>page(Object entityId, int maxResults)</code></a>. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="group_concat-function"><a class="anchor" href="#group_concat-function"></a>17.2.11. GROUP_CONCAT function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'GROUP_CONCAT' (, DISTINCT)?, expression (, 'SEPARATOR', separator_expression)? (, 'ORDER BY' (, order_by_expression (, order_specification ) )+ )? )</code></p>
</div>
<div class="paragraph">
<p>Where <code>order_specification</code> is one of <code>'ASC'</code>, <code>'DESC'</code>, <code>'ASC NULLS FIRST'</code>, <code>'ASC NULLS LAST'</code>, <code>'DESC NULLS FIRST'</code>, <code>'DESC NULLS LAST'</code> and <code>separator_expression</code> by is <code>','</code> by default.</p>
</div>
<div class="paragraph">
<p>Aggregates/concatenates the values produced by <code>expression</code> to a single string separated by <code>separator_expression</code> in the order defined by the <code>ORDER BY</code> clause.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This function might not be supported by all DBMS, so make sure your target database does before using it
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="set-functions"><a class="anchor" href="#set-functions"></a>17.2.12. SET functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'SET_XXX', subqueries+ (, 'ORDER BY' (, order_by_expression (, order_specification ) )+ )? (, 'LIMIT', limit_expression (, 'OFFSET', offset_expression )? )? )</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This function is used internally and no user should ever have the need for this!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For every type of set operation, there is a function.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UNION</code> - <code>SET_UNION</code></p>
</li>
<li>
<p><code>UNION_ALL</code> - <code>SET_UNION_ALL</code></p>
</li>
<li>
<p><code>INTERSECT</code> - <code>SET_INTERSECT</code></p>
</li>
<li>
<p><code>INTERSECT_ALL</code> - <code>SET_INTERSECT_ALL</code></p>
</li>
<li>
<p><code>EXCEPT</code> - <code>SET_EXCEPT</code></p>
</li>
<li>
<p><code>EXCEPT_ALL</code> - <code>SET_EXCEPT_ALL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Applies the DBMS native way of connecting the given subqueries with the requested set operation, ordering and limiting/skipping.
The function makes use of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/DbmsDialect.html#appendSet()"><code>DbmsDialect.appendSet()</code></a> for rendering.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement set operations for subqueries. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For further information on DBMS support take a look at the <a href="#anchor-set-dbms-compatibility">set operations</a> chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="compare_row_value-function"><a class="anchor" href="#compare_row_value-function"></a>17.2.13. COMPARE_ROW_VALUE function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'COMPARE_ROW_VALUE', comparison_operator, row_value_1_1, row_value_1_2, ..., row_value_1_n, row_value_2_1, row_value_2_2, ..., row_value_2_n)</code></p>
</div>
<div class="paragraph">
<p>Produces a DBMS native row value comparison expression such as <code>(row_value_1_1, row_value_1_2, ..., row_value_1_n) &lt; (row_value_2_1, row_value_2_2, ..., row_value_2_n)</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement optimized keyset pagination. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-jpql-functions"><a class="anchor" href="#custom-jpql-functions"></a>17.3. Custom JPQL functions</h3>
<div class="paragraph">
<p>Apart from providing many useful functions out of the box, Blaze Persistence also allows to implement custom JPQL functions that can be called just like any other non-standard function,
via the JPA 2.1 function syntax. In addition to that, you can even override existing implementations. So if you need to workaround bugs or want to improve something, you don&#8217;t have to wait for a release.</p>
</div>
<div class="paragraph">
<p>Custom functions are registered via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#registerFunction(com.blazebit.persistence.spi.JpqlFunctionGroup)"><code>CriteriaBuilderConfiguration.registerFunction()</code></a>
and expect an instance of a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/JpqlFunctionGroup.html"><code>JpqlFunctionGroup</code></a>. A <code>JpqlFunctionGroup</code> is a container for a custom function that defines the function name,
whether it is an aggregate function and the DBMS specific implementations of it as instances of <code>JpqlFunction</code>.</p>
</div>
<div class="paragraph">
<p>When a function is marked as being an aggregate function, it is treated like any other aggregate function regarding <a href="#implicit-group-by-generation">implicit group by generation</a>.
This means that the occurrence of the function invocation in a query builder, will trigger implicit group by generation.</p>
</div>
<div class="paragraph">
<p>During the building of a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#createCriteriaBuilderFactory(javax.persistence.EntityManagerFactory)"><code>CriteriaBuilderFactory</code></a>
the DBMS specific implementations of the registered <code>JpqlFunctionGroup</code> instances are selected. If there is no DBMS specific one available, it will fallback to the <em>default</em>.
If there is no default implementation available, a warning message is emitted, saying that no applicable function was found.</p>
</div>
<div class="sect3">
<h4 id="anchor-implementing-custom-jpql-function"><a class="anchor" href="#anchor-implementing-custom-jpql-function"></a>17.3.1. Implementing and registering a custom JPQL function</h4>
<div class="paragraph">
<p>Let&#8217;s implement a simple function for illustration purposes. The function should calculate the sum of two arguments and be called <code>CALCULATE_SUM</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class SumFunction implements JpqlFunction {

    @Override
    public boolean hasArguments() {
        return true;                            <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    public boolean hasParenthesesIfNoArguments() {
        return true;                            <i class="conum" data-value="2"></i><b>(2)</b>
    }

    @Override
    public Class&lt;?&gt; getReturnType(Class&lt;?&gt; firstArgumentType) {
        return firstArgumentType;               <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Override
    public void render(FunctionRenderContext context) {
        context.addArgument(0);                 <i class="conum" data-value="4"></i><b>(4)</b>
        context.addChunk("+");
        context.addArgument(1);
    }

}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Denotes if the function has arguments</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Denotes whether the function will have parenthesis when no arguments are passed</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The return type of the function, in our case, it&#8217;s going to be the same as the firstArgumentType</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Adds the first argument to the resulting sql, then the plus operator and finally the second argument</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>getReturnType()</code> method can only make use of the first argument type because Hibernate does not expose other argument types,
but that should be enough most of the time. In case you would need other argument types, you should create separately named functions to handle the return types.</p>
</div>
<div class="paragraph">
<p>The actual rendering of SQL is done with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html#addArgument(int)"><code>addArgument()</code></a>
and <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html#addChunk(java.lang.String)"><code>addChunk</code></a> of the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html"><code>FunctionRenderContext</code></a>.</p>
</div>
<div class="paragraph">
<p>With <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html#addArgument(int)"><code>addArgument(int index)</code></a> you add the argument at the given index to the SQL output.
You can also get access to the SQL string of the argument by using <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html#getArgument(int)"><code>getArgument()</code></a>.
To get the number of actual arguments, you can use <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html#getArgumentsSize()"><code>getArgumentsSize()</code></a>.
Finally, it is also possible to add an arbitrary string to the SQL output with <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/FunctionRenderContext.html#addChunk(java.lang.String)"><code>addChunk(String)</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The API is admittedly bad and will be reworked in the next major version.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Using the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/TemplateRenderer.html"><code>TemplateRenderer</code></a> will hopefully help mitigate the pain a bit.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to register the function, you only have to create a <code>JpqlFunctionGroup</code> with that <code>JpqlFunction</code> and register that on the configuration.
See the <a href="#anchor-environment">environment</a> section for how to get access to the <code>CriteriaBuilderConfiguration</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
JpqlFunctionGroup calculateSumFunction = new JpqlFunctionGroup("CALCULATE_SUM", new SumFunction());
config.registerFunction(calculateSumFunction);</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to register a <code>JpqlFunction</code> for a specific DBMS then use <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/JpqlFunctionGroup.html#add(java.lang.String,%20com.blazebit.persistence.spi.JpqlFunction)"><code>JpqlFunctionGroup.add()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
JpqlFunctionGroup calculateSumFunction = new JpqlFunctionGroup("CALCULATE_SUM", new SumFunction());
calculateSumFunction.add("h2", null);
config.registerFunction(calculateSumFunction);</pre>
</div>
</div>
<div class="paragraph">
<p>Passing <code>null</code> like in the example above, will disable the function for the specified DBMS.</p>
</div>
<div class="paragraph">
<p>Currently you can register functions for the following DBMS</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mysql</p>
</li>
<li>
<p>db2</p>
</li>
<li>
<p>postgresql</p>
</li>
<li>
<p>oracle</p>
</li>
<li>
<p>microsoft</p>
</li>
<li>
<p>sybase</p>
</li>
<li>
<p>h2</p>
</li>
<li>
<p>cubrid</p>
</li>
<li>
<p>hsql</p>
</li>
<li>
<p>informix</p>
</li>
<li>
<p>ingres</p>
</li>
<li>
<p>interbase</p>
</li>
<li>
<p>sqlite</p>
</li>
<li>
<p>firebird</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The determination of the DBMS happens in implementations of <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/EntityManagerFactoryIntegrator.html#getDbms(javax.persistence.EntityManagerFactory)"><code>EntityManagerFactoryIntegrator</code></a>
that reside in the JPA provider integrations. The determination is provider specific and there is currently no way of overriding this behavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="parameters-in-jpql-functions"><a class="anchor" href="#parameters-in-jpql-functions"></a>17.3.2. Parameters in JPQL functions</h4>
<div class="paragraph">
<p>If one of the arguments of a JPQL function contains a parameter, you must render the arguments in the same order to the SQL.
At the time of SQL rendering, there are only positional parameters, so rendering arguments in a different order might lead to wrong parameter bindings.
Another possible problem might arise when you want to make use of an argument multiple times in the resulting SQL. Since the ORM doesn&#8217;t know of the new parameter,
the value won&#8217;t be bound or worse, will be bound to a wrong value.</p>
</div>
<div class="paragraph">
<p>Here are some solutions to handling the problems with parameters</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Disallow parameters by throwing a runtime exception</p>
</li>
<li>
<p>Change the function specification so that the argument order doesn&#8217;t have to be changed (doesn&#8217;t work when only few DBMS require a different order)</p>
</li>
<li>
<p>Render the arguments in the correct order into a SQL <code>VALUES</code> clause or simple <code>SELECT</code> statement and use the aliases instead of the arguments directly</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For an example on using the <code>VALUES</code> clause take a look at the implementation of e.g. <code>PostgreSQLDayDiffFunction</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-jpql-macros"><a class="anchor" href="#custom-jpql-macros"></a>17.4. Custom JPQL macros</h3>
<div class="paragraph">
<p>A <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/JpqlMacro.html"><code>JpqlMacro</code></a> is a special kind of function that is evaluated at expression parse time and produces a JPQL expression.
Contrary to a <code>JpqlFunction</code>, a macro only needs to provide a <code>render()</code> method and does not suffer of the problems regarding parameters since it produces a JPQL expression rather than SQL.</p>
</div>
<div class="paragraph">
<p>One of the possible use cases for macros is to have user defined expression expansions to avoid boilerplate. Let&#8217;s implement a macro called <code>ITEM_TOTAL</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class ItemTotalMacro implements JpqlMacro {

    @Override
    public void render(FunctionRenderContext context) {
        context.addChunk("(1 + ");
        context.addArgument(0);
        context.addChunk(".taxClass.taxValue / 100) * ");

        context.addArgument(0);
        context.addChunk(".quantity * ");
        context.addArgument(0);
        context.addChunk(".price");
    }

}</pre>
</div>
</div>
<div class="paragraph">
<p>When passing in an expression like <code>alias</code>, the macro will produce the expression <code>(1 + alias.taxClass.taxValue / 100) * alias.quantity * alias.price</code>.
The macro can be either globally registered in the configuration or on a case by case basis directly on the <code>CriteriaBuilder</code>.
See the <a href="#anchor-environment">environment</a> section for how to get access to the <code>CriteriaBuilderConfiguration</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
config.registerMacro("ITEM_TOTAL", new ItemTotalMacro());</pre>
</div>
</div>
<div class="paragraph">
<p>Since macros aren&#8217;t actually functions and are pretty unique to Blaze Persistence, we decided to allow invoking them directly instead of having to use the JPA 2.1 function syntax.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how the macro can be used to easily calculate the total amount of an order.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Order.class, "o")
    .select("SUM(ITEM_TOTAL(o.items))");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT SUM((1 + taxClass_1.taxValue / 100) * items_1.quantity * items_1.price)
FROM Order o
LEFT JOIN o.items items_1
LEFT JOIN items_1.taxClass taxClass_1</pre>
</div>
</div>
<div class="paragraph">
<p>To wrap it up, macros help to reuse expressions and avoid boilerplate!</p>
</div>
<div class="paragraph">
<p>Currently there are no built-in JPQL macros available in the core part of Blaze Persistence but only in the entity view module.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One of the use cases for JPQL macros is the <code>VIEW_ROOT</code> function of the Entity Views module.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="customize-dbms-dialect"><a class="anchor" href="#customize-dbms-dialect"></a>18. Customize DBMS dialect</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A DBMS dialect abstracts away some of the specifics of a DBMS like e.g. whether set operations are supported.
Although Blaze Persistence tries very hard to make the DBMS dialects work on the most recent DBMS versions, it might sometimes be necessary to adapt the dialect to specific needs.</p>
</div>
<div class="paragraph">
<p>In general, you are well advised to extend the DBMS dialect that matches your DBMS best and override the methods you want in order to get the desired behavior.</p>
</div>
<div class="paragraph">
<p>A custom DBMS dialect must be registered on the configuration at boot time via <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#registerDialect(java.lang.String,%20com.blazebit.persistence.spi.DbmsDialect)"><code>registerDialect()</code></a>.
See the <a href="#anchor-environment">environment</a> section for how to get access to the <code>CriteriaBuilderConfiguration</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
config.registerDialect("h2", new MyH2DbmsDialect());</pre>
</div>
</div>
<div class="sect2">
<h3 id="custom-sql-type-mappings"><a class="anchor" href="#custom-sql-type-mappings"></a>18.1. Custom SQL type mappings</h3>
<div class="paragraph">
<p>Sometimes it might be necessary to adapt the Java type to SQL type mappings for your DBMS. In order to do so, introduce a new method <code>getSqlTypes</code> and extend the dialect like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class MyH2DbmsDialect extends H2DbmsDialect {

    public MyH2DbmsDialect() {
        super(getSqlTypes());
    }

    private static Map&lt;Class&lt;?&gt;, String&gt; getSqlTypes() {
        Map&lt;Class&lt;?&gt;, String&gt; types = new HashMap&lt;Class&lt;?&gt;, String&gt;();

        types.put(String.class, "nvarchar");

        return types;
    }
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-dbms-dialect-other-customizations"><a class="anchor" href="#custom-dbms-dialect-other-customizations"></a>18.2. Other customizations</h3>
<div class="paragraph">
<p>There are many other customizations possible. Take a look at the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/DbmsDialect.html"><code>DbmsDialect</code></a> API for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>19. Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Blaze Persistence can be configured by setting properties on a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#setProperty(java.lang.String,%20java.lang.String)"><code>CriteriaBuilderConfiguration</code></a>
object and creating a <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/spi/CriteriaBuilderConfiguration.html#createCriteriaBuilderFactory(javax.persistence.EntityManagerFactory)"><code>CriteriaBuilderFactory</code></a> from it.</p>
</div>
<div class="paragraph">
<p>You can also set configuration properties on a per builder basis via the <a href="http://static.javadoc.io/com.blazebit/blaze-persistence-core-api/1.2.0-Alpha4/index.html?com/blazebit/persistence/CommonQueryBuilder.html#setProperty(java.lang.String,%20java.lang.String)"><code>setProperty(String, String)</code></a> method.</p>
</div>
<div class="sect2">
<h3 id="configuration-properties"><a class="anchor" href="#configuration-properties"></a>19.1. Configuration properties</h3>
<div class="sect3">
<h4 id="compatible_mode"><a class="anchor" href="#compatible_mode"></a>19.1.1. COMPATIBLE_MODE</h4>
<div class="paragraph">
<p>Enables JPA compatibility mode to disallow the usage of vendor specific extensions. This will result in higher portability.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.compatible_mode</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="returning_clause_case_sensitive"><a class="anchor" href="#returning_clause_case_sensitive"></a>19.1.2. RETURNING_CLAUSE_CASE_SENSITIVE</h4>
<div class="paragraph">
<p>Defines whether column names should be used with the case in which they are given or as lower case when returning column values from a DML query.
This is mostly relevant for PostgreSQL which requires <code>false</code> to work properly.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.returning_clause_case_sensitive</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="size_to_count_transformation"><a class="anchor" href="#size_to_count_transformation"></a>19.1.3. SIZE_TO_COUNT_TRANSFORMATION</h4>
<div class="paragraph">
<p>Defines whether the SIZE to COUNT tranformation should be applied to queries or not.
The transformation can be very beneficial especially for databases that can&#8217;t optimize subqueries properly within the context of a parent query.
This property exists just so you can turn the transformation off if you encounter problems.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.size_to_count_transformation</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="implicit_group_by_from_select"><a class="anchor" href="#implicit_group_by_from_select"></a>19.1.4. IMPLICIT_GROUP_BY_FROM_SELECT</h4>
<div class="paragraph">
<p>Defines whether non-aggregate expressions from the SELECT clause should be automatically added to the GROUP BY.
Some databases require that all non-aggregate expressions must be included in the GROUP BY clause which is pretty annoying.
This feature can make writing queries a lot easier since it will implicitly copy expressions over to the GROUP BY clause.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.implicit_group_by_from_select</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="implicit_group_by_from_having"><a class="anchor" href="#implicit_group_by_from_having"></a>19.1.5. IMPLICIT_GROUP_BY_FROM_HAVING</h4>
<div class="paragraph">
<p>Defines whether non-aggregate expressions from the HAVING clause should be automatically added to the GROUP BY.
Some databases require that all non-aggregate expressions must be included in the GROUP BY clause which is pretty annoying.
This feature can make writing queries a lot easier since it will implicitly copy expressions over to the GROUP BY clause.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.implicit_group_by_from_having</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="implicit_group_by_from_order_by"><a class="anchor" href="#implicit_group_by_from_order_by"></a>19.1.6. IMPLICIT_GROUP_BY_FROM_ORDER_BY</h4>
<div class="paragraph">
<p>Defines whether non-aggregate expressions from the ORDER BY clause should be automatically added to the GROUP BY.
Some databases require that all non-aggregate expressions must be included in the GROUP BY clause which is pretty annoying.
This feature can make writing queries a lot easier since it will implicitly copy expressions over to the GROUP BY clause.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.implicit_group_by_from_order_by</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="expression_optimization"><a class="anchor" href="#expression_optimization"></a>19.1.7. EXPRESSION_OPTIMIZATION</h4>
<div class="paragraph">
<p>Defines whether expressions should be optimized.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.expression_optimization</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="expression_cache_class"><a class="anchor" href="#expression_cache_class"></a>19.1.8. EXPRESSION_CACHE_CLASS</h4>
<div class="paragraph">
<p>The full qualified expression cache implementation class name.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.expression.cache_class</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration only</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.blazebit.persistence.parser.expression.ConcurrentHashMapExpressionCache</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="values_clause_filter_nulls"><a class="anchor" href="#values_clause_filter_nulls"></a>19.1.9. VALUES_CLAUSE_FILTER_NULLS</h4>
<div class="paragraph">
<p>Defines whether tuples of a VALUES clause with all NULL values should be filtered out.
The property can be changed for a criteria builder before using the VALUES clause.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.values.filter_nulls</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="parameter_as_literal_rendering"><a class="anchor" href="#parameter_as_literal_rendering"></a>19.1.10. PARAMETER_AS_LITERAL_RENDERING</h4>
<div class="paragraph">
<p>Defines whether parameters should be rendered as literals when the type can not be inferred, or always as parameter.
The property can be changed for a criteria builder before constructing a query.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.parameter_literal_rendering</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="optimized_keyset_predicate_rendering"><a class="anchor" href="#optimized_keyset_predicate_rendering"></a>19.1.11. OPTIMIZED_KEYSET_PREDICATE_RENDERING</h4>
<div class="paragraph">
<p>Defines whether the keyset predicate should be rendered in an optimized form so that database optimizers are more likely
to use indices.
The property can be changed for a criteria builder before constructing a query.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">com.blazebit.persistence.optimized_keyset_predicate_rendering</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="configuration-jpql-functions"><a class="anchor" href="#configuration-jpql-functions"></a>19.2. Jpql functions</h3>
<div class="paragraph">
<p>Custom functions that can be invoked via the JPA 2.1 function syntax <code>FUNCTION('function_name', args...)</code> can be registered with <code>registerFunction(JpqlFunctionGroup)</code>.
A <code>JpqlFunctionGroup</code> represents a logical function that can contain multiple implementations for various dbms and can be defined as being an aggregate function.</p>
</div>
<div class="paragraph">
<p>These functions are registered as native persistence provider functions and can therefore also be used with plain JPA APIs or the native persistence provider APIs.
For more information refer to the <a href="#jpql-functions">JPQL functions</a> section.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-dbms-dialects"><a class="anchor" href="#configuration-dbms-dialects"></a>19.3. Dbms dialects</h3>
<div class="paragraph">
<p>Dbms dialect implementations provide SQL-level abstractions for a specific dbms. Blaze Persistence comes with support for the following dbms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>h2</p>
</li>
<li>
<p>mysql</p>
</li>
<li>
<p>postgresql</p>
</li>
<li>
<p>db2</p>
</li>
<li>
<p>oracle</p>
</li>
<li>
<p>microsoft</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By registering a custom implementation for a specific dbms via <code>registerDialect(String, DbmsDialect)</code> the default implementation will be overridden.
For more information refer to the <a href="#customize-dbms-dialect">Customize DBMS dialect</a> section.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-entity-manager-factory-integrators"><a class="anchor" href="#configuration-entity-manager-factory-integrators"></a>19.4. Entity manager factory integrators</h3>
<div class="paragraph">
<p>A little integration layer to extract the dbms of an entity manager and register <code>JpqlFunctionGroup</code> instances with the entity manager. This is normally provided by an integration module for persistence providers.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.2.0-SNAPSHOT<br>
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>