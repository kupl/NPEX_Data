<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Group by and having clause</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#group-by-and-having-clause">Group by and having clause</a>
<ul class="sectlevel2">
<li><a href="#group-by">Group by</a></li>
<li><a href="#having-clause">Having clause</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="group-by-and-having-clause"><a class="anchor" href="#group-by-and-having-clause"></a>Group by and having clause</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>GROUP BY</code> and <code>HAVING</code> clause are closely. Logically the <code>HAVING</code> clause is evaluated after the <code>GROUP BY</code> clause.
A <code>HAVING</code> clause does not make sense without a <code>GROUP BY</code> clause.</p>
</div>
<div class="sect2">
<h3 id="group-by"><a class="anchor" href="#group-by"></a>Group by</h3>
<div class="paragraph">
<p>When a <code>GROUP BY</code> clause is used, most DBMS require that every non-aggregate expression that appears in the following clauses must also appear in the <code>GROUP BY</code> clause</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SELECT</code></p>
</li>
<li>
<p><code>ORDER BY</code></p>
</li>
<li>
<p><code>HAVING</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is due to the fact that these clauses are logically executed after the <code>GROUP BY</code> clause.
Some DBMS even go as far as not allowing expressions of a certain complexity in the <code>GROUP BY</code> clause. For such expressions,
the property/column references have to be extracted and put into the <code>GROUP BY</code> clause instead, so that the composite expressions can be built after grouping.</p>
</div>
<div class="paragraph">
<p>By default, the use of complex expressions is allowed in <a href="{core_jdoc}/persistence/GroupByBuilder.html#groupBy(java.lang.String)"><code>groupBy()</code></a>,
but can be disabled by turning on the <a href="#compatible_mode">compatible mode</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OpenJPA only supports path expressions and simple function expression in the <code>GROUP BY</code> clause
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently it is not possible to have a custom <code>GROUP BY</code> and thus also <code>HAVING</code> clause when using the <code>PaginatedCriteriaBuilder</code> API. Also see <a href="https://github.com/Blazebit/blaze-persistence/issues/194">#194</a>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="implicit-group-by-generation"><a class="anchor" href="#implicit-group-by-generation"></a>Implicit group by generation</h4>
<div class="paragraph">
<p>Fortunately all these issues with different DBMS and the <code>GROUP BY</code> clause is handled by {projectname} through implicit group by generation.
Implicit group by generation adds just the expressions that are necessary for a query to work on a DBMS without changing it&#8217;s semantics.
The generation will kick in as soon as</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>GROUP BY</code> clause is used</p>
</li>
<li>
<p>An aggregate function is used</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you don&#8217;t like the group by generation or you run into a bug, you can always disable it on a per-query and per-clause basis if you like.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#implicit_group_by_from_select">Property for <code>SELECT</code> clause</a></p>
</li>
<li>
<p><a href="#implicit_group_by_from_having">Property for <code>HAVING</code> clause</a></p>
</li>
<li>
<p><a href="#implicit_group_by_from_order_by">Property for <code>ORDER BY</code> clause</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("COUNT(*)");</pre>
</div>
</div>
<div class="paragraph">
<p>This will result in the following JPQL query</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.age, COUNT(*)
FROM Cat cat
GROUP BY cat.age</pre>
</div>
</div>
<div class="paragraph">
<p>The grouping is done based on the non-aggregate expressions, in this case, it is just the <code>age</code> of the cat.
If you disabled the implicit group by generation for the <code>SELECT</code> clause, the <code>GROUP BY</code> clause would be missing and you&#8217;d have to add it manually like</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("COUNT(*)")
    .groupBy("age");</pre>
</div>
</div>
<div class="paragraph">
<p>which isn&#8217;t too painful at first, but can get quite cumbersome when having many expressions.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Not using implicit group by generation for the <code>HAVING</code> clause when using non-trivial expression like e.g. <code>age + 1</code> might lead to problems on some DBMS. MySQL for example can only handle column references in the <code>GROUP BY</code> and doesn&#8217;t match complex expressions for the <code>HAVING</code> clause.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Subqueries are generally not allowed in the <code>GROUP BY</code> clause, thus correlated properties/columns have to be extracted. Implicit group by generation also takes care of that.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Due to the fact that subqueries are not allowed, the <code>SIZE()</code> function can&#8217;t be used in this clause.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="group-by-entity"><a class="anchor" href="#group-by-entity"></a>Group by Entity</h4>
<div class="paragraph">
<p>Although the JPA spec mandates that a JPA provider must support grouping by an entity, it is apparently not asserted by the JPA TCK.
Some implementations don&#8217;t support this feature which is why {projectname} expands an entity in the <code>GROUP BY</code> clause automatically for you.</p>
</div>
<div class="paragraph">
<p>This also works when relying on implicit group by generation i.e.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "c")
    .leftJoin("c.kittens", "kitty")
    .select("c")
    .select("COUNT(*)");</pre>
</div>
</div>
<div class="paragraph">
<p>will result in the following <em>logical</em> JPQL query</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT c, COUNT(*)
FROM Cat c
LEFT JOIN c.kittens kitty
GROUP BY c</pre>
</div>
</div>
<div class="paragraph">
<p>but will expand <code>c</code> to all singular attributes of it&#8217;s type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate still lacks support for this <a href="https://hibernate.atlassian.net/browse/HHH-1615">feature</a> which is one of the reasons for doing the expansion within {projectname}
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="having-clause"><a class="anchor" href="#having-clause"></a>Having clause</h3>
<div class="paragraph">
<p>The <code>HAVING</code> clause is similar to the <a href="#where_clause"><code>WHERE</code> clause</a> and most of the inner workings are described in the <a href="#Predicate Builder">[Predicate Builder]</a> chapter.
The only difference is that the <code>HAVING</code> clause in contrast to the <code>WHERE</code> clause can contain aggregate functions and is logically executed after the <code>GROUP BY</code> clause.</p>
</div>
<div class="paragraph">
<p>The API for using the <code>HAVING</code> clause is the same as for the <code>WHERE</code> clause, except that it uses <code>having</code> instead of the <code>where</code> prefix.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class)
    .select("age")
    .select("COUNT(*)")
    .groupBy("age")
    .having("COUNT(*)").gt(2);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.age, COUNT(*)
FROM Cat cat
GROUP BY cat.age
HAVING COUNT(*) &gt; :param_1</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-04 13:32:35 KST
</div>
</div>
</body>
</html>