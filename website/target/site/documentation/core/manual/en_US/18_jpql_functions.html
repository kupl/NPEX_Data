<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JPQL functions</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#jpql-functions">JPQL functions</a>
<ul class="sectlevel2">
<li><a href="#special-built-in-functions">Special built-in functions</a></li>
<li><a href="#built-in-functions">Built-in functions</a></li>
<li><a href="#custom-jpql-functions">Custom JPQL functions</a></li>
<li><a href="#custom-jpql-macros">Custom JPQL macros</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="jpql-functions"><a class="anchor" href="#jpql-functions"></a>JPQL functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JPQL offers many built-in functions as you can see in the <a href="#string-functions">expressions</a> chapter and as of JPA 2.1 has a syntax for calling database specific functions.
Normally when using the function syntax <code>FUNCTION ( function_name (, args)* )</code>, the JPA provider puts a function call into the SQL like <code>function_name ( args* )</code>.
Instead of simply passing through the function invocation to the SQL, {projectname} decided to reuse the function syntax to allow calling so called JPQL functions.</p>
</div>
<div class="paragraph">
<p>JPQL functions are registered at configuration time and are integrated into a persistence unit, so you could even use the functions by using the JPA provider specific invocation syntax directly.
Except for a few special built-in functions, every function has DBMS specific implementations of the <a href="{core_jdoc}/persistence/spi/JpqlFunction.html"><code>JpqlFunction</code></a> interface
that are registered through a <a href="{core_jdoc}/persistence/spi/JpqlFunctionGroup.html#add(java.lang.String,%20com.blazebit.persistence.spi.JpqlFunction)"><code>JpqlFunctionGroup</code></a> on the
<a href="{core_jdoc}/persistence/spi/CriteriaBuilderConfiguration.html#registerFunction(com.blazebit.persistence.spi.JpqlFunctionGroup)"><code>CriteriaBuilderConfiguration</code></a>.</p>
</div>
<div class="paragraph">
<p>Depending on the DBMS that is encountered at runtime, {projectname} selects the appropriate functions during configuration and registers them in the persistence unit.</p>
</div>
<div class="sect2">
<h3 id="special-built-in-functions"><a class="anchor" href="#special-built-in-functions"></a>Special built-in functions</h3>
<div class="paragraph">
<p>These functions have a deeper integration with the query building process and do not directly generate SQL.</p>
</div>
<div class="sect3">
<h4 id="size-function"><a class="anchor" href="#size-function"></a>SIZE function</h4>
<div class="paragraph">
<p>The <code>SIZE</code> function, which was already briefly explained in the <a href="#Collection functions">[Collection functions]</a> section, returns the number of elements of a mapped collection.
This function is defined by JPQL and {projectname} chose to improve the performance by applying custom query transformations when encountering it.
Normally, a JPA provider will not care to optimize the <code>SIZE</code> function for you and will simply generate a correlated subquery for any uses.</p>
</div>
<div class="paragraph">
<p>{projectname} currently has transformations for <code>SIZE</code> invocations in the <code>SELECT</code> and <code>ORDER BY</code> clauses.
These transformations happen during query generation, so you can see the result by calling <a href="{core_jdoc}/persistence/Queryable.html#getQueryString()"><code>getQueryString()</code></a> on your query builder.</p>
</div>
<div class="paragraph">
<p>The transformation will</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>add a <code>LEFT JOIN</code> for the collection of the <code>SIZE</code> invocation</p>
</li>
<li>
<p>add a <code>GROUP BY</code> for the entity that owns the collection</p>
</li>
<li>
<p>and replace the <code>SIZE</code> invocation with a <code>COUNT</code> or <code>COUNT_TUPLE</code> expression</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This transformation also works when having multiple <code>SIZE</code> invocations. If an invocation can&#8217;t be transformed that way, a simple correlated subquery is generated.
There are different reasons why a transformation could fail, but the most common are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The collection is a bag</p>
</li>
<li>
<p>The query has multiple query roots</p>
</li>
<li>
<p>Multiple <code>SIZE</code> invocations with different collection owners</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you prefer subqueries or have problems with the transformation, you can turn the transformation off via a <a href="#SIZE_TO_COUNT_TRANSFORMATION">configuration property</a>.</p>
</div>
<div class="paragraph">
<p>Since the transformation introduces aggregate expressions into the query, it is necessary to have <a href="#implicit-group-by-generation">implicit group by generation</a> enabled
if other expressions appear in the <code>SELECT</code>, <code>ORDER BY</code> or <code>HAVING</code> clause. By default <a href="#implicit-group-by-generation">implicit group by generation</a> is enabled
and we recommend you don&#8217;t turn it off.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .select("cat.name")
    .select("SIZE(kittens)")
    .orderByDesc("id");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat.name, FUNCTION('COUNT_TUPLE', kittens_1.id)
FROM Cat cat
LEFT JOIN cat.kittens kittens_1
GROUP BY cat.id, cat.name
ORDER BY cat.id DESC NULLS LAST</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the expressions <code>cat.name</code> and <code>id</code> of the <code>SELECT</code> and <code>ORDER BY</code> clause are implicitly added to the <code>GROUP BY</code> because of the aggregate function <code>COUNT_TUPLE</code> being used.</p>
</div>
</div>
<div class="sect3">
<h4 id="outer-function"><a class="anchor" href="#outer-function"></a>OUTER function</h4>
<div class="paragraph">
<p>The <code>OUTER</code> function is an extension provided by {projectname} that can be used to refer to attributes of the parent query&#8217;s root.
By using <code>OUTER</code> you can avoid introducing the query root alias of the outer query into the subquery directly.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Tuple&gt; cb = cbf.create(em, Tuple.class)
    .from(Cat.class, "cat")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("subCat.name").notEqExpression("OUTER(name)")
    .end();</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT cat
FROM Cat cat
WHERE EXISTS (
    SELECT 1
    FROM Cat subCat
    WHERE subCat.name &lt;&gt; cat.name
)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>OUTER</code> invocation is replaced by the absolute path expression.</p>
</div>
<div class="paragraph">
<p>Currently it is not allowed to have nested <code>OUTER</code> invocations, but this is already planned. For more information see <a href="https://github.com/Blazebit/blaze-persistence/issues/317">#317</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="built-in-functions"><a class="anchor" href="#built-in-functions"></a>Built-in functions</h3>
<div class="paragraph">
<p>These functions are provided by {projectname} and are registered by default in every <a href="{core_jdoc}/persistence/spi/CriteriaBuilderConfiguration.html"><code>CriteriaBuilderConfiguration</code></a>.
They can be <a href="{core_jdoc}/persistence/spi/CriteriaBuilderConfiguration.html#getFunction(java.lang.String)">overridden</a> at configuration time if desired.</p>
</div>
<div class="paragraph">
<p>Every of the following functions has to be invoked with the JPA 2.1 function syntax.</p>
</div>
<div class="sect3">
<h4 id="count_tuple-function"><a class="anchor" href="#count_tuple-function"></a>COUNT_TUPLE function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'COUNT_TUPLE' (, 'DISTINCT' )?, args+ )</code></p>
</div>
<div class="paragraph">
<p>The <code>COUNT_TUPLE</code> function is like the regular <code>COUNT</code> function, but in addition allows to do distinct counting on multiple and embeddable attributes.
Some JPA providers ignore that some DBMS don&#8217;t support distinct counts on multiple columns and generate broken SQL.
This function will transform the distinct count for DBMS that don&#8217;t have native support to something equivalent.</p>
</div>
<div class="paragraph">
<p>The emulation is based on the idea, that the <strong>NUL</strong> character <code>\0</code> is a valid character in any text type on the DBMS but won&#8217;t ever appear in real data.
A distinct count for two columns can be emulated by doing the following expression instead</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">COUNT(DISTINCT
    COALESCE(
        NULLIF(
            COALESCE(
                COL1 || '', <i class="conum" data-value="1"></i><b>(1)</b>
                '\0'        <i class="conum" data-value="2"></i><b>(2)</b>
            ),
            ''              <i class="conum" data-value="3"></i><b>(3)</b>
        ),
        '\01'               <i class="conum" data-value="4"></i><b>(4)</b>
    ) ||
    '\0' ||                 <i class="conum" data-value="5"></i><b>(5)</b>
    COALESCE(
        NULLIF(
            COALESCE(
                COL2 || '',
                '\0'
            ),
            ''
        ),
        '\02'
    )
)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Concat with empty string to get implicit conversion to text type</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>NULL</code> values are replaced by the <strong>NUL</strong> character</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Produce <code>NULL</code> if the value is an empty string for the next step</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>NULL</code> is required so we can transform empty strings to the text <strong>NUL</strong> character concatenated with the column number i.e. <code>'\0' || '1'</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Separate the column values with a <strong>NUL</strong> character</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By doing a distinct count on the resulting string, the ANSI SQL distinct counting can be fully emulated.</p>
</div>
</div>
<div class="sect3">
<h4 id="cast-functions"><a class="anchor" href="#cast-functions"></a>CAST functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'CAST_XXX', argument )</code></p>
</div>
<div class="paragraph">
<p>There are multiple different cast functions for different data types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code> - <code>CAST_BOOLEAN</code></p>
</li>
<li>
<p><code>Byte</code> - <code>CAST_BYTE</code></p>
</li>
<li>
<p><code>Short</code> - <code>CAST_SHORT</code></p>
</li>
<li>
<p><code>Integer</code> - <code>CAST_INTEGER</code></p>
</li>
<li>
<p><code>Long</code> - <code>CAST_LONG</code></p>
</li>
<li>
<p><code>Float</code> - <code>CAST_FLOAT</code></p>
</li>
<li>
<p><code>Double</code> - <code>CAST_DOUBLE</code></p>
</li>
<li>
<p><code>Character</code> - <code>CAST_CHARACTER</code></p>
</li>
<li>
<p><code>String</code> - <code>CAST_STRING</code></p>
</li>
<li>
<p><code>BigInteger</code> - <code>CAST_BIGINTEGER</code></p>
</li>
<li>
<p><code>BigDecimal</code> - <code>CAST_BIGDECIMAL</code></p>
</li>
<li>
<p><code>java.sql.Time</code> - <code>CAST_TIME</code></p>
</li>
<li>
<p><code>java.sql.Date</code> - <code>CAST_DATE</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code> - <code>CAST_TIMESTAMP</code></p>
</li>
<li>
<p><code>java.util.Calendar</code> - <code>CAST_CALENDAR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A cast invocation will always generate a ANSI SQL cast. The SQL data type for a Java type is determined by <a href="{core_jdoc}/persistence/spi/DbmsDialect.html#getSqlType(java.lang.Class)"><code>DbmsDialect.getSqlType()</code></a>.
By providing a <a href="#customize-dbms-dialect">custom DBMS dialect</a> you can override these types.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;String&gt; cb = cbf.create(em, String.class)
    .from(Cat.class, "cat")
    .select("FUNCTION('CAST_STRING', cat.age)");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT FUNCTION('CAST_STRING', cat.age)
FROM Cat cat</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="treat-functions"><a class="anchor" href="#treat-functions"></a>TREAT functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'TREAT_XXX', argument )</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This function is used internally and no user should ever have the need for this!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are multiple different treat functions for different data types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code> - <code>TREAT_BOOLEAN</code></p>
</li>
<li>
<p><code>Byte</code> - <code>TREAT_BYTE</code></p>
</li>
<li>
<p><code>Short</code> - <code>TREAT_SHORT</code></p>
</li>
<li>
<p><code>Integer</code> - <code>TREAT_INTEGER</code></p>
</li>
<li>
<p><code>Long</code> - <code>TREAT_LONG</code></p>
</li>
<li>
<p><code>Float</code> - <code>TREAT_FLOAT</code></p>
</li>
<li>
<p><code>Double</code> - <code>TREAT_DOUBLE</code></p>
</li>
<li>
<p><code>Character</code> - <code>TREAT_CHARACTER</code></p>
</li>
<li>
<p><code>String</code> - <code>TREAT_STRING</code></p>
</li>
<li>
<p><code>BigInteger</code> - <code>TREAT_BIGINTEGER</code></p>
</li>
<li>
<p><code>BigDecimal</code> - <code>TREAT_BIGDECIMAL</code></p>
</li>
<li>
<p><code>java.sql.Time</code> - <code>TREAT_TIME</code></p>
</li>
<li>
<p><code>java.sql.Date</code> - <code>TREAT_DATE</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code> - <code>TREAT_TIMESTAMP</code></p>
</li>
<li>
<p><code>java.util.Calendar</code> - <code>TREAT_CALENDAR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A treat invocation will <strong>only</strong> adjust the type of the expression in the JPQL expression and not cause an explicit cast on the DBMS side.
This can be used for cases when the type of an expression is actually known but can&#8217;t be inferred.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement the <a href="#values-clause"><code>VALUES</code> clause</a> for <em>basic</em> types. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="temporal-diff-functions"><a class="anchor" href="#temporal-diff-functions"></a>Temporal DIFF functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'XXX_DIFF', start, end )</code></p>
</div>
<div class="paragraph">
<p>Calculates the difference between the two given temporals like <code>end - start</code> and returning the difference in the requested unit as truncated integer.</p>
</div>
<div class="paragraph">
<p>The possible units and the respective function names are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Millisecond</strong> - <code>MILLISECOND_DIFF</code></p>
</li>
<li>
<p><strong>Second</strong> - <code>SECOND_DIFF</code></p>
</li>
<li>
<p><strong>Minute</strong> - <code>MINUTE_DIFF</code></p>
</li>
<li>
<p><strong>Hour</strong> - <code>HOUR_DIFF</code></p>
</li>
<li>
<p><strong>Day</strong> - <code>DAY_DIFF</code></p>
</li>
<li>
<p><strong>Month</strong> - <code>MONTH_DIFF</code></p>
</li>
<li>
<p><strong>Year</strong> - <code>YEAR_DIFF</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>end &lt; start</code> i.e. the value of <code>end</code> is before <code>start</code>, the result is negative. You are advised to explicitly handle this case or use the <code>ABS</code> function.</p>
</div>
</div>
<div class="sect3">
<h4 id="temporal-extract-functions"><a class="anchor" href="#temporal-extract-functions"></a>Temporal extract functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'XXX', argument )</code></p>
</div>
<div class="paragraph">
<p>Extracts the requested field of temporal argument like specified by the ANSI SQL <code>EXTRACT</code> expression.</p>
</div>
<div class="paragraph">
<p>The possible fields and the respective function names are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Second</strong> - <code>SECOND</code></p>
</li>
<li>
<p><strong>Minute</strong> - <code>MINUTE</code></p>
</li>
<li>
<p><strong>Hour</strong> - <code>HOUR</code></p>
</li>
<li>
<p><strong>Day</strong> - <code>DAY</code></p>
</li>
<li>
<p><strong>Month</strong> - <code>MONTH</code></p>
</li>
<li>
<p><strong>Year</strong> - <code>YEAR</code></p>
</li>
<li>
<p><strong>Epoch</strong> - <code>EPOCH</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="greatest-function"><a class="anchor" href="#greatest-function"></a>GREATEST function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'GREATEST', argument1, argument2 (, &#8230;&#8203;)? )</code></p>
</div>
<div class="paragraph">
<p>Returns the greatest value of all given arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="least-function"><a class="anchor" href="#least-function"></a>LEAST function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'LEAST', argument1, argument2 (, &#8230;&#8203;)? )</code></p>
</div>
<div class="paragraph">
<p>Returns the smallest value of all given arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="repeat-function"><a class="anchor" href="#repeat-function"></a>REPEAT function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'REPEAT', argument1, argument2 )</code></p>
</div>
<div class="paragraph">
<p>Returns a string with the <em>argument1</em> repeated for <em>argument2</em> times.</p>
</div>
</div>
<div class="sect3">
<h4 id="limit-function"><a class="anchor" href="#limit-function"></a>LIMIT function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'LIMIT', subquery, limit (, offset )? )</code></p>
</div>
<div class="paragraph">
<p>Applies the DBMS native way of doing <code>LIMIT</code> and <code>OFFSET</code> with the given values <code>limit</code> and <code>offset</code> on the given subquery.</p>
</div>
<div class="paragraph">
<p>The function makes use of the <a href="{core_jdoc}/persistence/spi/DbmsLimitHandler.html"><code>DbmsLimitHandler</code></a> provided by the <a href="{core_jdoc}/persistence/spi/DbmsDialect.html#createLimitHandler()"><code>DbmsDialect</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Normally, you don&#8217;t need to use this function directly as the subquery builder API offers direct support for <a href="{core_jdoc}/persistence/LimitBuilder.html#setFirstResult(int)"><code>setFirstResult()</code></a> and <a href="{core_jdoc}/persistence/LimitBuilder.html#setMaxResults(int)"><code>setMaxResults()</code></a>. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function which is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you use this function directly, beware that for some DBMS it might not be possible to use parameters in <code>LIMIT</code> and <code>OFFSET</code> so if you really require a parameter, make sure it works for your database.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="page_position-function"><a class="anchor" href="#page_position-function"></a>PAGE_POSITION function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'PAGE_POSITION', id_query, entity_id )</code></p>
</div>
<div class="paragraph">
<p>Returns the absolute 1-based position of the entity with the given id within the result produced by the given id query.
The id query must select only the id of an entity and must be of a basic type. The entity id can be a parameter or plain value.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement <a href="{core_jdoc}/persistence/FullQueryBuilder.html#page(java.lang.Object,%20int)"><code>page(Object entityId, int maxResults)</code></a>. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="group_concat-function"><a class="anchor" href="#group_concat-function"></a>GROUP_CONCAT function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'GROUP_CONCAT' (, DISTINCT)?, expression (, 'SEPARATOR', separator_expression)? (, 'ORDER BY' (, order_by_expression (, order_specification ) )+ )? )</code></p>
</div>
<div class="paragraph">
<p>Where <code>order_specification</code> is one of <code>'ASC'</code>, <code>'DESC'</code>, <code>'ASC NULLS FIRST'</code>, <code>'ASC NULLS LAST'</code>, <code>'DESC NULLS FIRST'</code>, <code>'DESC NULLS LAST'</code> and <code>separator_expression</code> by is <code>','</code> by default.</p>
</div>
<div class="paragraph">
<p>Aggregates/concatenates the values produced by <code>expression</code> to a single string separated by <code>separator_expression</code> in the order defined by the <code>ORDER BY</code> clause.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This function might not be supported by all DBMS, so make sure your target database does before using it
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="set-functions"><a class="anchor" href="#set-functions"></a>SET functions</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'SET_XXX', subqueries+ (, 'ORDER BY' (, order_by_expression (, order_specification ) )+ )? (, 'LIMIT', limit_expression (, 'OFFSET', offset_expression )? )? )</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This function is used internally and no user should ever have the need for this!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For every type of set operation, there is a function.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UNION</code> - <code>SET_UNION</code></p>
</li>
<li>
<p><code>UNION_ALL</code> - <code>SET_UNION_ALL</code></p>
</li>
<li>
<p><code>INTERSECT</code> - <code>SET_INTERSECT</code></p>
</li>
<li>
<p><code>INTERSECT_ALL</code> - <code>SET_INTERSECT_ALL</code></p>
</li>
<li>
<p><code>EXCEPT</code> - <code>SET_EXCEPT</code></p>
</li>
<li>
<p><code>EXCEPT_ALL</code> - <code>SET_EXCEPT_ALL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Applies the DBMS native way of connecting the given subqueries with the requested set operation, ordering and limiting/skipping.
The function makes use of <a href="{core_jdoc}/persistence/spi/DbmsDialect.html#appendSet()"><code>DbmsDialect.appendSet()</code></a> for rendering.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement set operations for subqueries. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For further information on DBMS support take a look at the <a href="#anchor-set-dbms-compatibility">set operations</a> chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="compare_row_value-function"><a class="anchor" href="#compare_row_value-function"></a>COMPARE_ROW_VALUE function</h4>
<div class="paragraph">
<p>Syntax: <code>FUNCTION ( 'COMPARE_ROW_VALUE', comparison_operator, row_value_1_1, row_value_1_2, &#8230;&#8203;, row_value_1_n, row_value_2_1, row_value_2_2, &#8230;&#8203;, row_value_2_n)</code></p>
</div>
<div class="paragraph">
<p>Produces a DBMS native row value comparison expression such as <code>(row_value_1_1, row_value_1_2, &#8230;&#8203;, row_value_1_n) &lt; (row_value_2_1, row_value_2_2, &#8230;&#8203;, row_value_2_n)</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This is an internal function that is used to implement optimized keyset pagination. It is not intended for direct use and might change without notice.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-jpql-functions"><a class="anchor" href="#custom-jpql-functions"></a>Custom JPQL functions</h3>
<div class="paragraph">
<p>Apart from providing many useful functions out of the box, {projectname} also allows to implement custom JPQL functions that can be called just like any other non-standard function,
via the JPA 2.1 function syntax. In addition to that, you can even override existing implementations. So if you need to workaround bugs or want to improve something, you don&#8217;t have to wait for a release.</p>
</div>
<div class="paragraph">
<p>Custom functions are registered via <a href="{core_jdoc}/persistence/spi/CriteriaBuilderConfiguration.html#registerFunction(com.blazebit.persistence.spi.JpqlFunctionGroup)"><code>CriteriaBuilderConfiguration.registerFunction()</code></a>
and expect an instance of a <a href="{core_jdoc}/persistence/spi/JpqlFunctionGroup.html"><code>JpqlFunctionGroup</code></a>. A <code>JpqlFunctionGroup</code> is a container for a custom function that defines the function name,
whether it is an aggregate function and the DBMS specific implementations of it as instances of <code>JpqlFunction</code>.</p>
</div>
<div class="paragraph">
<p>When a function is marked as being an aggregate function, it is treated like any other aggregate function regarding <a href="#implicit-group-by-generation">implicit group by generation</a>.
This means that the occurrence of the function invocation in a query builder, will trigger implicit group by generation.</p>
</div>
<div class="paragraph">
<p>During the building of a <a href="{core_jdoc}/persistence/spi/CriteriaBuilderConfiguration.html#createCriteriaBuilderFactory(javax.persistence.EntityManagerFactory)"><code>CriteriaBuilderFactory</code></a>
the DBMS specific implementations of the registered <code>JpqlFunctionGroup</code> instances are selected. If there is no DBMS specific one available, it will fallback to the <em>default</em>.
If there is no default implementation available, a warning message is emitted, saying that no applicable function was found.</p>
</div>
<div class="sect3">
<h4 id="anchor-implementing-custom-jpql-function"><a class="anchor" href="#anchor-implementing-custom-jpql-function"></a>Implementing and registering a custom JPQL function</h4>
<div class="paragraph">
<p>Let&#8217;s implement a simple function for illustration purposes. The function should calculate the sum of two arguments and be called <code>CALCULATE_SUM</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class SumFunction implements JpqlFunction {

    @Override
    public boolean hasArguments() {
        return true;                            <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    public boolean hasParenthesesIfNoArguments() {
        return true;                            <i class="conum" data-value="2"></i><b>(2)</b>
    }

    @Override
    public Class&lt;?&gt; getReturnType(Class&lt;?&gt; firstArgumentType) {
        return firstArgumentType;               <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Override
    public void render(FunctionRenderContext context) {
        context.addArgument(0);                 <i class="conum" data-value="4"></i><b>(4)</b>
        context.addChunk("+");
        context.addArgument(1);
    }

}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Denotes if the function has arguments</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Denotes whether the function will have parenthesis when no arguments are passed</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The return type of the function, in our case, it&#8217;s going to be the same as the firstArgumentType</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Adds the first argument to the resulting sql, then the plus operator and finally the second argument</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>getReturnType()</code> method can only make use of the first argument type because Hibernate does not expose other argument types,
but that should be enough most of the time. In case you would need other argument types, you should create separately named functions to handle the return types.</p>
</div>
<div class="paragraph">
<p>The actual rendering of SQL is done with <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html#addArgument(int)"><code>addArgument()</code></a>
and <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html#addChunk(java.lang.String)"><code>addChunk</code></a> of the <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html"><code>FunctionRenderContext</code></a>.</p>
</div>
<div class="paragraph">
<p>With <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html#addArgument(int)"><code>addArgument(int index)</code></a> you add the argument at the given index to the SQL output.
You can also get access to the SQL string of the argument by using <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html#getArgument(int)"><code>getArgument()</code></a>.
To get the number of actual arguments, you can use <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html#getArgumentsSize()"><code>getArgumentsSize()</code></a>.
Finally, it is also possible to add an arbitrary string to the SQL output with <a href="{core_jdoc}/persistence/spi/FunctionRenderContext.html#addChunk(java.lang.String)"><code>addChunk(String)</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The API is admittedly bad and will be reworked in the next major version.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Using the <a href="{core_jdoc}/persistence/spi/TemplateRenderer.html"><code>TemplateRenderer</code></a> will hopefully help mitigate the pain a bit.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to register the function, you only have to create a <code>JpqlFunctionGroup</code> with that <code>JpqlFunction</code> and register that on the configuration.
See the <a href="#anchor-environment">environment</a> section for how to get access to the <code>CriteriaBuilderConfiguration</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
JpqlFunctionGroup calculateSumFunction = new JpqlFunctionGroup("CALCULATE_SUM", new SumFunction());
config.registerFunction(calculateSumFunction);</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to register a <code>JpqlFunction</code> for a specific DBMS then use <a href="{core_jdoc}/persistence/spi/JpqlFunctionGroup.html#add(java.lang.String,%20com.blazebit.persistence.spi.JpqlFunction)"><code>JpqlFunctionGroup.add()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
JpqlFunctionGroup calculateSumFunction = new JpqlFunctionGroup("CALCULATE_SUM", new SumFunction());
calculateSumFunction.add("h2", null);
config.registerFunction(calculateSumFunction);</pre>
</div>
</div>
<div class="paragraph">
<p>Passing <code>null</code> like in the example above, will disable the function for the specified DBMS.</p>
</div>
<div class="paragraph">
<p>Currently you can register functions for the following DBMS</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mysql</p>
</li>
<li>
<p>db2</p>
</li>
<li>
<p>postgresql</p>
</li>
<li>
<p>oracle</p>
</li>
<li>
<p>microsoft</p>
</li>
<li>
<p>sybase</p>
</li>
<li>
<p>h2</p>
</li>
<li>
<p>cubrid</p>
</li>
<li>
<p>hsql</p>
</li>
<li>
<p>informix</p>
</li>
<li>
<p>ingres</p>
</li>
<li>
<p>interbase</p>
</li>
<li>
<p>sqlite</p>
</li>
<li>
<p>firebird</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The determination of the DBMS happens in implementations of <a href="{core_jdoc}/persistence/spi/EntityManagerFactoryIntegrator.html#getDbms(javax.persistence.EntityManagerFactory)"><code>EntityManagerFactoryIntegrator</code></a>
that reside in the JPA provider integrations. The determination is provider specific and there is currently no way of overriding this behavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="parameters-in-jpql-functions"><a class="anchor" href="#parameters-in-jpql-functions"></a>Parameters in JPQL functions</h4>
<div class="paragraph">
<p>If one of the arguments of a JPQL function contains a parameter, you must render the arguments in the same order to the SQL.
At the time of SQL rendering, there are only positional parameters, so rendering arguments in a different order might lead to wrong parameter bindings.
Another possible problem might arise when you want to make use of an argument multiple times in the resulting SQL. Since the ORM doesn&#8217;t know of the new parameter,
the value won&#8217;t be bound or worse, will be bound to a wrong value.</p>
</div>
<div class="paragraph">
<p>Here are some solutions to handling the problems with parameters</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Disallow parameters by throwing a runtime exception</p>
</li>
<li>
<p>Change the function specification so that the argument order doesn&#8217;t have to be changed (doesn&#8217;t work when only few DBMS require a different order)</p>
</li>
<li>
<p>Render the arguments in the correct order into a SQL <code>VALUES</code> clause or simple <code>SELECT</code> statement and use the aliases instead of the arguments directly</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For an example on using the <code>VALUES</code> clause take a look at the implementation of e.g. <code>PostgreSQLDayDiffFunction</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-jpql-macros"><a class="anchor" href="#custom-jpql-macros"></a>Custom JPQL macros</h3>
<div class="paragraph">
<p>A <a href="{core_jdoc}/persistence/spi/JpqlMacro.html"><code>JpqlMacro</code></a> is a special kind of function that is evaluated at expression parse time and produces a JPQL expression.
Contrary to a <code>JpqlFunction</code>, a macro only needs to provide a <code>render()</code> method and does not suffer of the problems regarding parameters since it produces a JPQL expression rather than SQL.</p>
</div>
<div class="paragraph">
<p>One of the possible use cases for macros is to have user defined expression expansions to avoid boilerplate. Let&#8217;s implement a macro called <code>ITEM_TOTAL</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">public class ItemTotalMacro implements JpqlMacro {

    @Override
    public void render(FunctionRenderContext context) {
        context.addChunk("(1 + ");
        context.addArgument(0);
        context.addChunk(".taxClass.taxValue / 100) * ");

        context.addArgument(0);
        context.addChunk(".quantity * ");
        context.addArgument(0);
        context.addChunk(".price");
    }

}</pre>
</div>
</div>
<div class="paragraph">
<p>When passing in an expression like <code>alias</code>, the macro will produce the expression <code>(1 + alias.taxClass.taxValue / 100) * alias.quantity * alias.price</code>.
The macro can be either globally registered in the configuration or on a case by case basis directly on the <code>CriteriaBuilder</code>.
See the <a href="#anchor-environment">environment</a> section for how to get access to the <code>CriteriaBuilderConfiguration</code>.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilderConfiguration config = //...
config.registerMacro("ITEM_TOTAL", new ItemTotalMacro());</pre>
</div>
</div>
<div class="paragraph">
<p>Since macros aren&#8217;t actually functions and are pretty unique to {projectname}, we decided to allow invoking them directly instead of having to use the JPA 2.1 function syntax.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how the macro can be used to easily calculate the total amount of an order.</p>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint javaext lang-javaext">CriteriaBuilder&lt;Long&gt; cb = cbf.create(em, Long.class)
    .from(Order.class, "o")
    .select("SUM(ITEM_TOTAL(o.items))");</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
    <pre class="prettyprint sqlext lang-sqlext">SELECT SUM((1 + taxClass_1.taxValue / 100) * items_1.quantity * items_1.price)
FROM Order o
LEFT JOIN o.items items_1
LEFT JOIN items_1.taxClass taxClass_1</pre>
</div>
</div>
<div class="paragraph">
<p>To wrap it up, macros help to reuse expressions and avoid boilerplate!</p>
</div>
<div class="paragraph">
<p>Currently there are no built-in JPQL macros available in the core part of {projectname} but only in the entity view module.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One of the use cases for JPQL macros is the <code>VIEW_ROOT</code> function of the Entity Views module.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>