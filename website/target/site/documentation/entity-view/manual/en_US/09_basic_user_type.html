<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BasicUserType SPI</title>
<link rel="stylesheet" href="css/blazebit.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="prettify/prettify.min.css">
<script src="prettify/prettify.min.js"></script>
<script src="prettify/lang-ext.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body class="book toc2 toc-left">

<div class="brand">
    <a class="vendor" href="https://blazebit.com">
        <strong>Blazebit.com</strong>
    </a>
    <a class="logo" href="https://persistence.blazebit.com">
        <strong>blaze-persistence</strong>
    </a>
</div>
<br/>

<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#entity-view-basic-user-type-spi">BasicUserType SPI</a>
<ul class="sectlevel2">
<li><a href="#supported-types">Supported types</a></li>
<li><a href="#type-support-for-write-models">Type support for write models</a></li>
<li><a href="#type-support-for-jpa-managed-types">Type support for JPA managed types</a></li>
<li><a href="#optimistic-locking-version-type-support">Optimistic locking version type support</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="entity-view-basic-user-type-spi"><a class="anchor" href="#entity-view-basic-user-type-spi"></a>BasicUserType SPI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just like JPA providers offer an SPI to make use of custom types for basic values, {projectname} also does.
For read models, the type isn&#8217;t very important as the JPA provider handles the construction of the values and only provides entity views with object instance.
Since write models need to handle change detection and mutability aspects of basic types i.e. non-subview type, the <code>BasicUserType</code> interface SPI is needed.</p>
</div>
<div class="sect2">
<h3 id="supported-types"><a class="anchor" href="#supported-types"></a>Supported types</h3>
<div class="paragraph">
<p>There are several well known types registered out of the box.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean</code>, <code>java.lang.Boolean</code></p>
</li>
<li>
<p><code>char</code>, <code>java.lang.Character</code></p>
</li>
<li>
<p><code>byte</code>, <code>java.lang.Byte</code></p>
</li>
<li>
<p><code>short</code>, <code>java.lang.Short</code></p>
</li>
<li>
<p><code>int</code>, <code>java.lang.Integer</code></p>
</li>
<li>
<p><code>long</code>, <code>java.lang.Long</code></p>
</li>
<li>
<p><code>float</code>, <code>java.lang.Float</code></p>
</li>
<li>
<p><code>double</code>, <code>java.lang.Double</code></p>
</li>
<li>
<p><code>java.lang.String</code></p>
</li>
<li>
<p><code>java.math.BigInteger</code>, <code>java.math.BigDecimal</code></p>
</li>
<li>
<p><code>java.util.Date</code>, <code>java.sql.Time</code>, <code>java.sql.Date</code>, <code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>java.util.Calendar</code>, <code>java.util.GregorianCalendar</code></p>
</li>
<li>
<p><code>java.util.TimeZone</code>, <code>java.lang.Class</code></p>
</li>
<li>
<p><code>java.util.UUID</code>, <code>java.net.URL</code></p>
</li>
<li>
<p><code>java.util.Locale</code>,  <code>java.util.Currency</code></p>
</li>
<li>
<p><code>byte[]</code>, <code>java.lang.Byte[]</code></p>
</li>
<li>
<p><code>char[]</code>, <code>java.lang.Character[]</code></p>
</li>
<li>
<p><code>java.io.InputStream</code>, <code>java.sql.Blob</code></p>
</li>
<li>
<p><code>java.sql.Clob</code>, <code>java.sql.NClob</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If found on the classpath, types for the following classes are registered</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.time.LocalDate</code>, <code>java.time.LocalDateTime</code>, <code>java.time.LocalTime</code></p>
</li>
<li>
<p><code>java.time.OffsetTime</code>, <code>java.time.OffsetDateTime</code>, <code>java.time.ZonedDateTime</code></p>
</li>
<li>
<p><code>java.time.Duration</code>, <code>java.time.Instant</code></p>
</li>
<li>
<p><code>java.time.MonthDay</code>, <code>java.time.Year</code>, <code>java.time.YearMonth</code>, <code>java.time.Period</code></p>
</li>
<li>
<p><code>java.time.ZoneId</code>, <code>java.time.ZoneOffset</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you miss a type you can register it via <a href="{entity_view_jdoc}/persistence/view/spi/EntityViewConfiguration.html#registerBasicUserType(java.lang.Class,com.blazebit.persistence.view.spi.type.BasicUserType)"><code>EntityViewConfiguration.registerBasicUserType(Class type, BasicUserType userType)</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="type-support-for-write-models"><a class="anchor" href="#type-support-for-write-models"></a>Type support for write models</h3>
<div class="paragraph">
<p>When a basic type is used in a write model, it is very important that an appropriate <code>BasicUserType</code> is registered.
If no basic user type is registered for a type, by default the <code>com.blazebit.persistence.view.spi.type.MutableBasicUserType</code> is used.
This basic user type assume the type is mutable which will cause values of that type to always be assumed being dirty.
Updatable entity views containing values of such a type are thus always considered being dirty which has the effect, that every call to
<a href="{entity_view_jdoc}/persistence/view/EntityViewManager.html#update(java.lang.Object)"><code>EntityViewManager.update(Object view)</code></a>
will cause a flush of attributes containing that value.
The <a href="#Change Model API">updatable-entity-view-change-model-api</a> is also affected of this by always reporting such attributes as being dirty.</p>
</div>
<div class="paragraph">
<p>Immutable types, like e.g. <code>java.lang.String</code> already does, can use the basic user type implementation <code>com.blazebit.persistence.view.spi.type.ImmutableBasicUserType</code>
which assumes objects of the type are immutable.</p>
</div>
<div class="paragraph">
<p>A proper basic user type implementation for mutable types, when based on the provided type <code>com.blazebit.persistence.view.spi.type.AbstractMutableBasicUserType</code>
only needs an implementation for cloning a value. The cloned value is used to e.g. keep the initial state so that later changes can be detected by checking equality.</p>
</div>
</div>
<div class="sect2">
<h3 id="type-support-for-jpa-managed-types"><a class="anchor" href="#type-support-for-jpa-managed-types"></a>Type support for JPA managed types</h3>
<div class="paragraph">
<p>JPA managed types are also considered mutable by default, and since no dirty tracking information is available by default, objects of that such types are always considered dirty thus also always flushed.
An integration with the native dirty tracking mechanism of the JPA provider might improve performance and will be considered in future versions.
Entity types that handle change tracking manually, can implement a custom basic user type to improve the performance for usages of that entity type within updatable entity views,
but are generally recommended to switch to subviews instead.</p>
</div>
<div class="paragraph">
<p>For further information on the possible SPI methods consult the JavaDoc of the <a href="{entity_view_jdoc}/persistence/view/spi/type/BasicUserType.html"><code>BasicUserType</code> interface</a></p>
</div>
</div>
<div class="sect2">
<h3 id="optimistic-locking-version-type-support"><a class="anchor" href="#optimistic-locking-version-type-support"></a>Optimistic locking version type support</h3>
<div class="paragraph">
<p>To allow an attribute to be used as version for optimistic locking, the registered basic type also needs to implement the <code>com.blazebit.persistence.view.spi.type.VersionBasicUserType</code> interface.
This type additionally requires to provide an implementation for returning the <em>next version</em> based on a given current version.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-08-05 16:46:14 KST
</div>
</div>
</body>
</html>