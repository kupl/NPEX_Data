<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SelectingFuture.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.common</a> &gt; <span class="el_source">SelectingFuture.java</span></div><h1>SelectingFuture.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.common;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.linkedin.pinot.common.response.ServerInstance;


/**
 * A selecting future which completes when
 *  (a) Any underlying future completes successfully with a response or
 *  (b) all underlying futures fail.
 *
 * This construct can be used in case where you want to run speculative execution. When
 * one of those completes successfully, we dont have to wait for other options.
 *
 * This future holds the first successfully completed future that notified (if any present) or
 * the last error (if all underlying futures failed)
 * @param &lt;T&gt; Response object.
 */
public class SelectingFuture&lt;T&gt; extends AbstractCompositeListenableFuture&lt;T&gt; {
<span class="fc" id="L45">  protected static Logger LOGGER = LoggerFactory.getLogger(SelectingFuture.class);</span>

  private final List&lt;ServerResponseFuture&lt;T&gt;&gt; _futuresList;

  // First successful Response
  private volatile Map&lt;ServerInstance, T&gt; _delayedResponse;

  // Last Exception in case of error
  private volatile Map&lt;ServerInstance, Throwable&gt; _error;

  private final String _name;

<span class="fc" id="L57">  private long _durationMillis = -1;</span>

<span class="fc" id="L59">  public SelectingFuture(String name) {</span>
<span class="fc" id="L60">    _name = name;</span>
<span class="fc" id="L61">    _futuresList = new ArrayList&lt;ServerResponseFuture&lt;T&gt;&gt;();</span>
<span class="fc" id="L62">    _delayedResponse = null;</span>
<span class="fc" id="L63">    _error = null;</span>
<span class="fc" id="L64">  }</span>

  /**
   * Start the future. This will add listener to the underlying futures. This method needs to be called
   * as soon the composite future is constructed and before any other method is invoked.
   */
  public void start(Collection&lt;ServerResponseFuture&lt;T&gt;&gt; futuresList) {
<span class="fc" id="L71">    boolean started = super.start();</span>

<span class="pc bpc" id="L73" title="1 of 2 branches missed.">    if (!started) {</span>
<span class="nc" id="L74">      String msg = &quot;Unable to start the future. State is already : &quot; + _state;</span>
<span class="nc" id="L75">      LOGGER.error(msg);</span>
<span class="nc" id="L76">      throw new IllegalStateException(msg);</span>
    }

<span class="fc" id="L79">    _futuresList.addAll(futuresList);</span>
<span class="fc" id="L80">    _latch = new CountDownLatch(futuresList.size());</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">    for (ServerResponseFuture&lt;T&gt; entry : _futuresList) {</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">      if (null != entry) {</span>
<span class="fc" id="L83">        addResponseFutureListener(entry);</span>
      }
<span class="fc" id="L85">    }</span>
<span class="fc" id="L86">  }</span>

  /**
   * Call cancel on underlying futures. Dont worry if they are completed.
   * If they are already completed, cancel will be discarded. THis is best-effort only !!.
   */
  @Override
  protected void cancelUnderlyingFutures() {
<span class="fc bfc" id="L94" title="All 2 branches covered.">    for (ServerResponseFuture&lt;T&gt; entry : _futuresList) {</span>
<span class="fc" id="L95">      entry.cancel(true);</span>
<span class="fc" id="L96">    }</span>
<span class="fc" id="L97">  }</span>

  @Override
  public Map&lt;ServerInstance, T&gt; get() throws InterruptedException, ExecutionException {
<span class="nc" id="L101">    _latch.await();</span>
<span class="nc" id="L102">    return _delayedResponse;</span>
  }

  @Override
  public Map&lt;ServerInstance, Throwable&gt; getError() {
<span class="fc" id="L107">    return _error;</span>
  }

  @Override
  public Map&lt;ServerInstance, T&gt; get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L112">    _latch.await(timeout, unit);</span>
<span class="nc" id="L113">    return _delayedResponse;</span>
  }

  @Override
  public T getOne() throws InterruptedException, ExecutionException {
<span class="fc" id="L118">    _latch.await();</span>
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">    if ((null == _delayedResponse) || (_delayedResponse.isEmpty())) {</span>
<span class="fc" id="L120">      return null;</span>
    }
<span class="fc" id="L122">    return _delayedResponse.values().iterator().next();</span>
  }

  @Override
  public T getOne(long timeout, TimeUnit unit)
      throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L128">    boolean notElapsed = _latch.await(timeout,unit);</span>

<span class="nc bnc" id="L130" title="All 2 branches missed.">    if (!notElapsed)</span>
<span class="nc" id="L131">      throw new TimeoutException(&quot;Timedout waiting for async result for selecting future &quot; + _name);</span>

<span class="nc bnc" id="L133" title="All 4 branches missed.">    if ((null == _delayedResponse) || (_delayedResponse.isEmpty())) {</span>
<span class="nc" id="L134">      return null;</span>
    }
<span class="nc" id="L136">    return _delayedResponse.values().iterator().next();</span>
  }

  @Override
  public long getDurationMillis() {
<span class="nc" id="L141">    return _durationMillis;</span>
  }

  @Override
  protected boolean processFutureResult(ServerInstance server, Map&lt;ServerInstance, T&gt; response, Map&lt;ServerInstance, Throwable&gt; error, long durationMillis) {
    // Add an argument here to get the time of completion of the future.
<span class="fc" id="L147">    boolean done = false;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">    if ((null != response)) {</span>
<span class="fc" id="L149">      LOGGER.debug(&quot;Error got from {} is : {}&quot;, server, response);</span>

<span class="fc" id="L151">      _delayedResponse = response;</span>
<span class="fc" id="L152">      _error = null;</span>
<span class="fc" id="L153">      done = true;</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">    } else if (null != error) {</span>
<span class="fc" id="L155">      LOGGER.debug(&quot;Error got from {} is : {}&quot;, server, error);</span>
<span class="fc" id="L156">      _error = error;</span>
    }
<span class="fc" id="L158">    _durationMillis = durationMillis;</span>
<span class="fc" id="L159">    return done;</span>
  }

  @Override
  public ServerInstance getServerInstance() {
<span class="nc" id="L164">    throw new RuntimeException(&quot;Invalid API call on selecting future&quot;);</span>
  }

  @Override
  public String getName() {
<span class="nc" id="L169">    return _name;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>