<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NettyTCPClientConnection.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.netty</a> &gt; <span class="el_source">NettyTCPClientConnection.java</span></div><h1>NettyTCPClientConnection.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.netty;

import com.linkedin.pinot.common.metrics.MetricsHelper;
import com.linkedin.pinot.common.metrics.MetricsHelper.TimerContext;
import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.transport.metrics.NettyClientMetrics;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.util.Timeout;
import io.netty.util.Timer;
import io.netty.util.TimerTask;
import java.net.ConnectException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;


/**
 * TCP based Netty Client Connection.
 *
 * Request and Response have the following format
 *
 * 0                                                         31
 * ------------------------------------------------------------
 * |                  Length ( 32 bits)                       |
 * |                 Payload (Request/Response)               |
 * |                    ...............                       |
 * |                    ...............                       |
 * |                    ...............                       |
 * |                    ...............                       |
 * ------------------------------------------------------------
 */
public class NettyTCPClientConnection extends NettyClientConnection  {
  /**
   * Channel Inbound Handler for receiving response asynchronously
   */
<span class="fc" id="L65">  private NettyClientConnectionHandler _handler = null;</span>

<span class="fc" id="L67">  private NettyClientMetrics _clientMetric = null;</span>

  /**
   * Handle to the future corresponding to the pending request
   */
  private final AtomicReference&lt;ResponseFuture&gt; _outstandingFuture;

  private long _lastRequsetSizeInBytes;
  private long _lastResponseSizeInBytes;
  private TimerContext _lastSendRequestLatency;
  private TimerContext _lastResponseLatency;

  // Timeout object corresponding to the outstanding request
  private volatile Timeout _lastRequestTimeout;
  private volatile long _lastRequestTimeoutMS;
  private volatile long _lastRequestId;
  private volatile Throwable _lastError;
<span class="fc" id="L84">  private volatile boolean _selfClose = false;</span>

  // COnnection Id generator
<span class="fc" id="L87">  private static final AtomicLong _connIdGen = new AtomicLong(0);</span>

  // Channel Setting notification
<span class="fc" id="L90">  private final CountDownLatch _channelSet = new CountDownLatch(1);</span>

  public NettyTCPClientConnection(ServerInstance server, EventLoopGroup eventGroup, Timer timer,
      NettyClientMetrics metric) {
<span class="fc" id="L94">    super(server, eventGroup, timer,_connIdGen.incrementAndGet() );</span>
<span class="fc" id="L95">    _handler = new NettyClientConnectionHandler();</span>
<span class="fc" id="L96">    _outstandingFuture = new AtomicReference&lt;ResponseFuture&gt;();</span>
<span class="fc" id="L97">    _clientMetric = metric;</span>
<span class="fc" id="L98">    init();</span>
<span class="fc" id="L99">  }</span>

  private void init() {
<span class="fc" id="L102">    _bootstrap = new Bootstrap();</span>
<span class="fc" id="L103">    _bootstrap.group(_eventGroup).channel(NioSocketChannel.class).handler(new ChannelHandlerInitializer(_handler));</span>
<span class="fc" id="L104">  }</span>

  protected void setSelfClose(boolean selfClose) {
<span class="fc" id="L107">    _selfClose = selfClose;</span>
<span class="fc" id="L108">  }</span>

  protected boolean isSelfClose() {
<span class="fc" id="L111">    return _selfClose;</span>
  }

  /**
   * Used to validate if the connection state transition is valid.
   * @param nextState
   */
  private void checkTransition(State nextState) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (!_connState.isValidTransition(nextState)) {</span>
<span class="fc" id="L120">      throw new IllegalStateException(&quot;Wrong transition :&quot; + _connState + &quot; -&gt; &quot; + nextState + &quot;, connId:&quot; + getConnId());</span>
    }
<span class="fc" id="L122">  }</span>

  /**
   * Open a connection
   */
  @Override
  public boolean connect() {
    try {
<span class="fc" id="L130">      checkTransition(State.CONNECTED);</span>
      //Connect synchronously. At the end of this line, _channel should have been set
<span class="fc" id="L132">      TimerContext t = MetricsHelper.startTimer();</span>
<span class="fc" id="L133">      ChannelFuture f =  _bootstrap.connect(_server.getHostname(), _server.getPort()).sync();</span>
      /**
       * Waiting for future alone does not guarantee that _channel is set. _channel is set
       * only when the channelActive() async callback runs. So we should also wait for it.
       */
<span class="fc" id="L138">      f.get();</span>
<span class="fc" id="L139">      _channelSet.await();</span>
<span class="fc" id="L140">      t.stop();</span>

<span class="fc" id="L142">      _connState = State.CONNECTED;</span>
<span class="fc" id="L143">      _clientMetric.addConnectStats(t.getLatencyMs());</span>
<span class="fc" id="L144">      return true;</span>
<span class="fc" id="L145">    } catch (Exception ie) {</span>
<span class="pc bpc" id="L146" title="2 of 6 branches missed.">      if (ie instanceof ConnectException &amp;&amp; ie.getMessage() != null &amp;&amp; ie.getMessage().startsWith(&quot;Connection refused&quot;)) {</span>
        // Most common case when a server is down. Don't print the entire stack and fill the logs.
<span class="fc" id="L148">        LOGGER.info(&quot;Could not connect to server {}:{} connId:{}&quot;, _server, ie.getMessage(), getConnId());</span>
      } else {
<span class="fc" id="L150">        LOGGER.error(&quot;Got exception when connecting to server {} connId {}&quot;, _server, ie, getConnId());</span>
      }
    }
<span class="fc" id="L153">    return false;</span>
  }

  /**
   * Called by the channel initializer to set the underlying channel reference.
   * @param channel
   */
  private void setChannel(Channel channel) {
<span class="fc" id="L161">    _channel = channel;</span>
<span class="fc" id="L162">    _channelSet.countDown();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    LOGGER.info(&quot;Setting channel for connection id ({}) to server {}. Is channel null? {}&quot;,_connId, _server, (null == _channel));</span>
<span class="fc" id="L164">  }</span>

  @Override
  public ResponseFuture sendRequest(ByteBuf serializedRequest, long requestId, long timeoutMS) {
<span class="fc" id="L168">    checkTransition(State.REQUEST_WRITTEN);</span>

    //Metrics update
<span class="fc" id="L171">    _lastRequsetSizeInBytes = serializedRequest.readableBytes();</span>
<span class="fc" id="L172">    _lastSendRequestLatency = MetricsHelper.startTimer();</span>
<span class="fc" id="L173">    _lastResponseLatency = MetricsHelper.startTimer();</span>

<span class="fc" id="L175">    _outstandingFuture.set(new ResponseFuture(_server, &quot;Server response future for reqId &quot; + requestId + &quot; to server &quot; + _server + &quot; connId &quot; + getConnId()));</span>
<span class="fc" id="L176">    _lastRequestTimeoutMS = timeoutMS;</span>
<span class="fc" id="L177">    _lastRequestId = requestId;</span>
<span class="fc" id="L178">    _lastError = null;</span>

    /**
     * Start the timer before sending the request.
     * That way, both cases of timeout (request writing to send-buffer and response timeout)
     * can be treated as single timeout condition and handled in the same way
     */
<span class="fc" id="L185">    _lastRequestTimeout = _timer.newTimeout(new ReadTimeoutHandler(), _lastRequestTimeoutMS, TimeUnit.MILLISECONDS);</span>
    try {

<span class="fc" id="L188">      _connState = State.REQUEST_WRITTEN;</span>
<span class="fc" id="L189">      _channel.writeAndFlush(serializedRequest);</span>
      /**
       * IMPORTANT:
       * There could be 2 netty threads one running the below code and another for response/error handling.
       * simultaneously. Netty does not provide guarantees around this. So in worst case, the thread that
       * is flushing request could block for sometime and gets executed after the response is obtained.
       * We should checkin the connection to the pool only after all outstanding callbacks are complete.
       * We do this by trancking the connection state. If we detect that response/error is already obtained,
       * we then do the process of checking back the connection to the pool or destroying (if error)
       */
<span class="fc" id="L199">      synchronized(_handler)</span>
      {
<span class="fc" id="L201">        _lastSendRequestLatency.stop();</span>

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if ( _connState == State.REQUEST_WRITTEN)</span>
        {
<span class="fc" id="L205">          _connState = State.REQUEST_SENT;</span>
        } else {
<span class="nc" id="L207">          LOGGER.info(&quot;Response/Error already arrived !! Checking-in/destroying the connection to server {}, connId {}&quot;, _server, getConnId());</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">          if ( _connState == State.GOT_RESPONSE)</span>
          {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (null != _requestCallback) {</span>
<span class="nc" id="L211">              _requestCallback.onSuccess(null);</span>
            }
<span class="nc bnc" id="L213" title="All 2 branches missed.">          } else if ( _connState == State.ERROR){</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (null != _requestCallback) {</span>
<span class="nc" id="L215">              _requestCallback.onError(_lastError);</span>
            }
          } else {
<span class="nc" id="L218">            throw new IllegalStateException(&quot;Invalid connection State (&quot; + _connState</span>
                                             + &quot;) when sending request to  server &quot; + _server + &quot;, connId &quot; + getConnId());
          }
        }
<span class="pc" id="L222">      }</span>
<span class="nc" id="L223">    } catch (Exception e) {</span>
<span class="nc" id="L224">      LOGGER.error(&quot;Got exception sending the request to server ({}) id {}&quot;, _server, getConnId(), e);</span>

      /**
       * This might not be needed as if we get an exception, channelException() or channelClosed() would
       * have been called which would have set error response but defensively setting. Need to check if
       * this is needed
       */
<span class="nc" id="L231">      _outstandingFuture.get().onError(e);</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">      if (null != _requestCallback) {</span>
<span class="nc" id="L234">        _requestCallback.onError(e);</span>
      }
<span class="nc" id="L236">      _lastSendRequestLatency.stop();</span>
<span class="fc" id="L237">    }</span>
<span class="fc" id="L238">    return _outstandingFuture.get();</span>
  }

  protected void cancelLastRequestTimeout() {
<span class="fc bfc" id="L242" title="All 2 branches covered.">    if (null != _lastRequestTimeout) {</span>
<span class="fc" id="L243">      _lastRequestTimeout.cancel(); //If task is already executed, no side-effect</span>
<span class="fc" id="L244">      _lastRequestTimeout = null;</span>
    }
<span class="fc" id="L246">  }</span>

  // Having a toString method here is useful when logging stuff from AsyncPoolImpl
  @Override
  public String toString() {
<span class="fc" id="L251">    return &quot;Server:&quot; + _server + &quot;,State:&quot; + _connState + &quot;,connId:&quot; + getConnId();</span>
  }

  /**
   * Channel Handler for incoming response.
   *
   */
<span class="fc" id="L258">  public class NettyClientConnectionHandler extends ChannelInboundHandlerAdapter {</span>
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
      // called when:
      // 1. idle server restart
      // 2. Also when an idle connection is closed by broker. In that case, self-close is set to true.
<span class="fc" id="L264">      LOGGER.info(&quot;Client Channel to server ({}) (id = {}) in inactive state (closed).  !!&quot;, _server, _connId);</span>
<span class="fc" id="L265">      Exception ex = new Exception(&quot;Client Channel to server (&quot; + _server + &quot;) is in inactive state (closed) !!&quot;);</span>
<span class="fc" id="L266">      closeOnError(ctx, ex);</span>
<span class="fc" id="L267">      releaseResources();</span>
<span class="fc" id="L268">    }</span>

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
<span class="fc" id="L272">      LOGGER.info(&quot;Client Channel to server ({}) (id = {}) is active.&quot;, _server, _connId);</span>
<span class="fc" id="L273">      setChannel(ctx.channel());</span>
<span class="fc" id="L274">      super.channelActive(ctx);</span>
<span class="fc" id="L275">    }</span>

    @Override
    public synchronized void channelRead(ChannelHandlerContext ctx, Object msg) {
<span class="fc" id="L279">      ByteBuf responseByteBuf = (ByteBuf) msg;</span>
      try {
        // Cancel outstanding timer
<span class="fc" id="L282">        cancelLastRequestTimeout();</span>

        //checkTransition(State.GOT_RESPONSE);
<span class="fc" id="L285">        _lastResponseLatency.stop();</span>

<span class="fc" id="L287">        int numReadableBytes = responseByteBuf.readableBytes();</span>
<span class="fc" id="L288">        byte[] responseBytes = new byte[numReadableBytes];</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (numReadableBytes &gt; 0) {</span>
<span class="fc" id="L290">          responseByteBuf.readBytes(responseBytes);</span>
        }
<span class="fc" id="L292">        _lastResponseSizeInBytes = numReadableBytes;</span>

<span class="fc" id="L294">        State prevState = _connState;</span>
<span class="fc" id="L295">        _connState = State.GOT_RESPONSE;</span>

<span class="fc" id="L297">        _outstandingFuture.get().onSuccess(responseBytes);</span>
<span class="fc" id="L298">        _clientMetric.addRequestResponseStats(_lastRequsetSizeInBytes, 1, _lastResponseSizeInBytes, false,</span>
            _lastSendRequestLatency.getLatencyMs(), _lastResponseLatency.getLatencyMs());

        /**
         * IMPORTANT:
         * There could be 2 netty threads one running the sendRequest() code (the ones after flush()
         * and another for response/error handling (this one)
         * simultaneously. Netty does not provide guarantees around this. So in worst case, the thread that
         * is flushing request could block for sometime and gets executed after the response is obtained.
         * We should checkin the connection to the pool only after all outstanding callbacks are complete.
         * We do this by trancking the connection state. If we detect that response/error arrives before sendRequest
         * completes, we will let the sendRequest to checkin/destroy the connection.
         */
<span class="pc bpc" id="L311" title="1 of 4 branches missed.">        if ((null != _requestCallback) &amp;&amp; (prevState == State.REQUEST_SENT)) {</span>
<span class="fc" id="L312">          _requestCallback.onSuccess(null);</span>
        }
      } finally {
<span class="pc" id="L315">        responseByteBuf.release();</span>
<span class="fc" id="L316">      }</span>
<span class="fc" id="L317">    }</span>

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
      // Called from netty when we get an exception in the channel. Typically this is when the server restarts
      // and we have connections that may or may not have outstanding requests. Connections could also be in the
      // process of being set up when we get this exception.
<span class="fc" id="L324">      LOGGER.info(&quot;Got exception in the channel to {}, connId {}, cause:{}&quot;, _server, getConnId(), cause.getMessage());</span>
<span class="fc" id="L325">      closeOnError(ctx, cause);</span>
<span class="fc" id="L326">      releaseResources();</span>
<span class="fc" id="L327">    }</span>

    private synchronized void closeOnError(ChannelHandlerContext ctx, Throwable cause)
    {
<span class="fc bfc" id="L331" title="All 2 branches covered.">      if ( _connState != State.ERROR)</span>
      {
        //Cancel outstanding timer
<span class="fc" id="L334">        cancelLastRequestTimeout();</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if ( null != _lastResponseLatency)</span>
<span class="fc" id="L337">          _lastResponseLatency.stop();</span>

        //LOG.error(&quot;Got exception when processing the channel. Closing the channel&quot;, cause);
<span class="fc" id="L340">        checkTransition(State.ERROR);</span>

<span class="fc bfc" id="L342" title="All 2 branches covered.">        if ( null != _outstandingFuture.get())</span>
        {
<span class="fc" id="L344">          _outstandingFuture.get().onError(cause);</span>
        }
<span class="fc bfc" id="L346" title="All 4 branches covered.">        _clientMetric.addRequestResponseStats(_lastRequsetSizeInBytes, 1, _lastResponseSizeInBytes, true,</span>
                (null == _lastSendRequestLatency) ? 0 : _lastSendRequestLatency.getLatencyMs(),
                (null == _lastSendRequestLatency ) ? 0 :_lastResponseLatency.getLatencyMs());


        /**
         * IMPORTANT:
         * There could be 2 netty threads one running the sendRequest() code (the ones after flush()
         * and another for response/error handling (this one)
         * simultaneously. Netty does not provide guarantees around this. So in worst case, the thread that
         * is flushing request could block for sometime and gets executed after the response is obtained.
         * We should checkin the connection to the pool only after all outstanding callbacks are complete.
         * We do this by trancking the connection state. If we detect that response/error arrives before sendRequest
         * completes, we will let the sendRequest to checkin/destroy the connection.
         */
<span class="fc bfc" id="L361" title="All 4 branches covered.">        if ((null != _requestCallback) &amp;&amp; (_connState == State.REQUEST_SENT)) {</span>
<span class="fc" id="L362">          LOGGER.info(&quot;Discarding the connection to {} connId {}&quot;, _server, getConnId());</span>
<span class="fc" id="L363">          _requestCallback.onError(cause);</span>
        }

<span class="fc" id="L366">        _connState = State.ERROR;</span>

<span class="fc" id="L368">        ctx.close();</span>

      }
<span class="fc" id="L371">    }</span>
  }

  protected void releaseResources() {

<span class="fc" id="L376">  }</span>

  /**
   * Netty Client Channel Initializer responsible for setting the pipeline
   */
  public class ChannelHandlerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {

    private final ChannelHandler _handler;

<span class="fc" id="L385">    public ChannelHandlerInitializer(ChannelHandler handler) {</span>
<span class="fc" id="L386">      _handler = handler;</span>
<span class="fc" id="L387">    }</span>

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
<span class="fc" id="L391">      ChannelPipeline pipeline = ch.pipeline();</span>
      /**
       * We will use a length prepended payload to defragment TCP fragments.
       */
<span class="fc" id="L395">      pipeline.addLast(&quot;decoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</span>
<span class="fc" id="L396">      pipeline.addLast(&quot;encoder&quot;, new LengthFieldPrepender(4));</span>
      //pipeline.addLast(&quot;logger&quot;, new LoggingHandler());
<span class="fc" id="L398">      pipeline.addLast(&quot;handler&quot;, _handler);</span>
<span class="fc" id="L399">      LOGGER.info(&quot;Server Channel pipeline setup. Pipeline:&quot; + ch.pipeline().names());</span>
<span class="fc" id="L400">    }</span>
  }

  @Override
  public void close() throws InterruptedException {
<span class="fc" id="L405">    LOGGER.info(&quot;Closing client channel to {} connId {}&quot;, _server, getConnId());</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">    if (null != _channel) {</span>
<span class="fc" id="L407">      _channel.close().sync();</span>
<span class="fc" id="L408">      setSelfClose(true);</span>
    }
<span class="fc" id="L410">  }</span>
  /**
   * Timer task responsible for closing the connection on timeout
   *
   */
<span class="fc" id="L415">  public class ReadTimeoutHandler implements TimerTask {</span>

    @Override
    public void run(Timeout timeout) throws Exception {
<span class="fc" id="L419">      String message =</span>
          &quot;Request (&quot; + _lastRequestId + &quot;) to server &quot; + _server + &quot; connId &quot; + getConnId()
              + &quot; timed-out waiting for response. Closing the channel !!&quot;;
<span class="fc" id="L422">      LOGGER.warn(message);</span>
<span class="fc" id="L423">      Exception e = new Exception(message);</span>
<span class="fc" id="L424">      _outstandingFuture.get().onError(e);</span>
<span class="fc" id="L425">      close();</span>
<span class="fc" id="L426">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>