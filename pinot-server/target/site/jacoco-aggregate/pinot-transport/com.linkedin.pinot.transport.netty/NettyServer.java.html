<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NettyServer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.netty</a> &gt; <span class="el_source">NettyServer.java</span></div><h1>NettyServer.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.netty;

import com.google.common.base.Preconditions;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.linkedin.pinot.common.metrics.AggregatedMetricsRegistry;
import com.linkedin.pinot.common.metrics.MetricsHelper;
import com.linkedin.pinot.common.metrics.MetricsHelper.TimerContext;
import com.linkedin.pinot.transport.metrics.AggregatedTransportServerMetrics;
import com.linkedin.pinot.transport.metrics.NettyServerMetrics;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * A Netty Server abstraction. Server implementations are expected to implement the getServerBootstrap() abstract
 * method to configure the server protocol and setup handlers. The Netty server will then bind to the port and
 * listens to incoming connections on the port.
 *
 */
public abstract class NettyServer implements Runnable {

<span class="fc" id="L54">  protected static Logger LOGGER = LoggerFactory.getLogger(NettyServer.class);</span>

  // Server Metrics Group Name Prefix in Metrics Registry
  public static final String AGGREGATED_SERVER_METRICS_NAME = &quot;Server_Global_Metric_&quot;;

  /**
   * The request handler callback which processes the incoming request.
   * This method is executed by the Netty worker thread.
   */
  public interface RequestHandler {
    /**
     * Callback for Servers to process the request and return the response.
     * The ownership of the request bytebuf resides with the caler (NettyServer).
     * This callback is not expected to call {@link ByteBuf#release()} on request
     * The ownership of the request byteBuf lies with the caller.
     *
     * The implementation MUST not throw any runtime exceptions. In case of errors,
     * the implementation is expected to construct and return an error response.
     * If the implementation throws runtime exceptions, then the underlying connection
     * will be terminated.
     *
     *
     * @param channelHandlerContext
     * @param request Serialized request
     * @return Serialized response
     */
    ListenableFuture&lt;byte[]&gt; processRequest(ChannelHandlerContext channelHandlerContext, ByteBuf request);
  }

  public interface RequestHandlerFactory {

    /**
     * Request Handler Factory. The RequestHandler objects are not expected to be
     * thread-safe. Hence, we need a factory for the Channel Initializer to use for each incoming channel.
     * @return
     */
    /*
     * TODO/atumbde: Our exisiting request handlers are thread-safe. So, we can replace factory
     * with request handler object
     */
    RequestHandler createNewRequestHandler();
  }

  /**
   * Server port
   */
  protected int _port;

  // Flag to indicate if shutdown has been completed
<span class="fc" id="L103">  protected AtomicBoolean _shutdownComplete = new AtomicBoolean(false);</span>

  //TODO: Need configs to control number of threads
  // NOTE/atumbde: With ScheduledRequestHandler, queries are executed asynchronously.
  // So, these netty threads are not blocked. Config is still important
<span class="fc" id="L108">  protected final EventLoopGroup _bossGroup = new NioEventLoopGroup(1);</span>
<span class="fc" id="L109">  protected final EventLoopGroup _workerGroup = new NioEventLoopGroup(20);</span>

  // Netty Channel
<span class="fc" id="L112">  protected volatile Channel _channel = null;</span>

  // Factory for generating request Handlers
  protected RequestHandlerFactory _handlerFactory;

  // Aggregated Metrics Registry
  protected final AggregatedMetricsRegistry _metricsRegistry;

  //Aggregated Server Metrics
  protected final AggregatedTransportServerMetrics _metrics;

  protected final long _defaultLargeQueryLatencyMs;

<span class="fc" id="L125">  public NettyServer(int port, RequestHandlerFactory handlerFactory, AggregatedMetricsRegistry registry, long defaultLargeQueryLatencyMs) {</span>
<span class="fc" id="L126">    _port = port;</span>
<span class="fc" id="L127">    _handlerFactory = handlerFactory;</span>
<span class="fc" id="L128">    _metricsRegistry = registry;</span>
<span class="fc" id="L129">    _metrics = new AggregatedTransportServerMetrics(_metricsRegistry, AGGREGATED_SERVER_METRICS_NAME + port + &quot;_&quot;);</span>
<span class="fc" id="L130">    _defaultLargeQueryLatencyMs = defaultLargeQueryLatencyMs;</span>
<span class="fc" id="L131">  }</span>

  @Override
  public void run() {
    try {
<span class="fc" id="L136">      ServerBootstrap bootstrap = getServerBootstrap();</span>

<span class="fc" id="L138">      LOGGER.info(&quot;Binding to the server port !!&quot;);</span>

      // Bind and start to accept incoming connections.
<span class="fc" id="L141">      ChannelFuture f = bootstrap.bind(_port).sync();</span>
<span class="fc" id="L142">      _channel = f.channel();</span>
<span class="fc" id="L143">      LOGGER.info(&quot;Server bounded to port :&quot; + _port + &quot;, Waiting for closing&quot;);</span>
<span class="fc" id="L144">      f.channel().closeFuture().sync();</span>
<span class="fc" id="L145">      LOGGER.info(&quot;Server boss channel is closed. Gracefully shutting down the server netty threads and pipelines&quot;);</span>
<span class="nc" id="L146">    } catch (Exception e) {</span>
<span class="nc" id="L147">      LOGGER.error(&quot;Got exception in the main server thread. Stopping !!&quot;, e);</span>
    } finally {
<span class="pc" id="L149">      _shutdownComplete.set(true);</span>
<span class="pc" id="L150">    }</span>
<span class="fc" id="L151">  }</span>

  /**
   * Generate Protocol specific server bootstrap and return
   *
   */
  protected abstract ServerBootstrap getServerBootstrap();

  public boolean isStarted() {
<span class="fc bfc" id="L160" title="All 2 branches covered.">    return _channel != null;</span>
  }

  /**
   *  Shutdown gracefully
   */
  public void shutdownGracefully() {
<span class="fc" id="L167">    LOGGER.info(&quot;Shutdown requested in the server !!&quot;);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">    if (null != _channel) {</span>
<span class="fc" id="L169">      LOGGER.info(&quot;Closing the server channel&quot;);</span>
<span class="fc" id="L170">      _channel.close();</span>
<span class="fc" id="L171">      _bossGroup.shutdownGracefully();</span>
<span class="fc" id="L172">      _workerGroup.shutdownGracefully();</span>
    }
<span class="fc" id="L174">  }</span>

  /**
   * Blocking call to wait for shutdown completely.
   */
  public void waitForShutdown(long millis) {
<span class="fc" id="L180">    LOGGER.info(&quot;Waiting for Shutdown&quot;);</span>

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (_channel != null) {</span>
<span class="fc" id="L183">      LOGGER.info(&quot;Closing the server channel&quot;);</span>
<span class="fc" id="L184">      long endTime = System.currentTimeMillis() + millis;</span>

<span class="fc" id="L186">      ChannelFuture channelFuture = _channel.close();</span>
<span class="fc" id="L187">      Future&lt;?&gt; bossGroupFuture = _bossGroup.shutdownGracefully();</span>
<span class="fc" id="L188">      Future&lt;?&gt; workerGroupFuture = _workerGroup.shutdownGracefully();</span>

<span class="fc" id="L190">      long currentTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">      if (endTime &gt; currentTime) {</span>
<span class="fc" id="L192">        channelFuture.awaitUninterruptibly(endTime - currentTime, TimeUnit.MILLISECONDS);</span>
      }

<span class="fc" id="L195">      currentTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      if (endTime &gt; currentTime) {</span>
<span class="fc" id="L197">        bossGroupFuture.awaitUninterruptibly(endTime - currentTime, TimeUnit.MINUTES);</span>
      }

<span class="fc" id="L200">      currentTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">      if (endTime &gt; currentTime) {</span>
<span class="fc" id="L202">        workerGroupFuture.awaitUninterruptibly(endTime - currentTime, TimeUnit.MINUTES);</span>
      }

<span class="fc" id="L205">      Preconditions.checkState(channelFuture.isDone(), &quot;Unable to close the channel in %s ms&quot;, millis);</span>
<span class="fc" id="L206">      Preconditions.checkState(bossGroupFuture.isDone(), &quot;Unable to shutdown the boss group in %s ms&quot;, millis);</span>
<span class="fc" id="L207">      Preconditions.checkState(workerGroupFuture.isDone(), &quot;Unable to shutdown the worker group in %s ms&quot;, millis);</span>
    }
<span class="fc" id="L209">  }</span>

  /**
   * Request and Response have the following format
   *
   * 0                                                         31
   * ------------------------------------------------------------
   * |                  Length ( 32 bits)                       |
   * |                 Payload (Request/Response)               |
   * |                    ...............                       |
   * |                    ...............                       |
   * |                    ...............                       |
   * |                    ...............                       |
   * ------------------------------------------------------------
   */
  public static class NettyChannelInboundHandler extends ChannelInboundHandlerAdapter {
    private final long _defaultLargeQueryLatencyMs;
    private final RequestHandler _handler;
    private final NettyServerMetrics _metric;

<span class="fc" id="L229">    public NettyChannelInboundHandler(RequestHandler handler, NettyServerMetrics metric, long defaultLargeQueryLatencyMs) {</span>
<span class="fc" id="L230">      _handler = handler;</span>
<span class="fc" id="L231">      _metric = metric;</span>
<span class="fc" id="L232">      _defaultLargeQueryLatencyMs = defaultLargeQueryLatencyMs;</span>
<span class="fc" id="L233">    }</span>

    public NettyChannelInboundHandler(RequestHandler handler, NettyServerMetrics metric) {
<span class="nc" id="L236">      this(handler, metric, 100);</span>
<span class="nc" id="L237">    }</span>

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
<span class="fc" id="L241">      final long requestStartTime = System.currentTimeMillis();</span>
<span class="fc" id="L242">      LOGGER.debug(&quot;Request received by server !!&quot;);</span>

<span class="fc" id="L244">      final ByteBuf request = (ByteBuf) msg;</span>
<span class="fc" id="L245">      final long requestSizeInBytes = request.readableBytes();</span>

      //Call processing handler
<span class="fc" id="L248">      final TimerContext requestProcessingLatency = MetricsHelper.startTimer();</span>
<span class="fc" id="L249">      final ChannelHandlerContext requestChannelHandlerContext = ctx;</span>
<span class="fc" id="L250">      ListenableFuture&lt;byte[]&gt; serializedQueryResponse = _handler.processRequest(ctx, request);</span>
<span class="fc" id="L251">      Futures.addCallback(serializedQueryResponse, new FutureCallback&lt;byte[]&gt;() {</span>
        void sendResponse(@Nonnull final byte[] result) {
<span class="fc" id="L253">          requestProcessingLatency.stop();</span>

          // Send Response
<span class="fc" id="L256">          final ByteBuf responseBuf = Unpooled.wrappedBuffer(result);</span>
<span class="fc" id="L257">          final TimerContext responseSendLatency = MetricsHelper.startTimer();</span>
<span class="fc" id="L258">          ChannelFuture f = requestChannelHandlerContext.writeAndFlush(responseBuf);</span>
<span class="fc" id="L259">          f.addListener(new ChannelFutureListener() {</span>
            @Override
            public void operationComplete(ChannelFuture future)
                throws Exception {
<span class="fc" id="L263">              LOGGER.debug(&quot;Response has been sent !!&quot;);</span>
<span class="fc" id="L264">              responseSendLatency.stop();</span>
<span class="fc" id="L265">              _metric.addServingStats(requestSizeInBytes, result.length, 1L, false,</span>
                  requestProcessingLatency.getLatencyMs(), responseSendLatency.getLatencyMs());
<span class="fc" id="L267">              long totalQueryTime = System.currentTimeMillis() - requestStartTime;</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">              if (totalQueryTime &gt; _defaultLargeQueryLatencyMs) {</span>
<span class="nc" id="L269">                LOGGER.info(&quot;Slow query: request handler processing time: {}, send response latency: {}, total time to handle request: {}&quot;,</span>
                    requestProcessingLatency.getLatencyMs(),
                    responseSendLatency.getLatencyMs(), totalQueryTime);
              }
<span class="fc" id="L273">            }</span>
          });

          // TODO: check if we can release this right after _handler.processRequest returns
<span class="fc" id="L277">          request.release();</span>
<span class="fc" id="L278">        }</span>
        @Override
        public void onSuccess(@Nullable byte[] result) {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">          if (result == null) {</span>
<span class="nc" id="L282">            result = new byte[0];</span>
          }
<span class="fc" id="L284">          sendResponse(result);</span>
<span class="fc" id="L285">        }</span>

        @Override
        public void onFailure(Throwable t) {
<span class="nc" id="L289">          LOGGER.error(&quot;Request processing returned unhandled exception, error: &quot;, t);</span>
<span class="nc" id="L290">          sendResponse(new byte[0]);</span>
<span class="nc" id="L291">        }</span>
      });

<span class="fc" id="L294">    }</span>

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
<span class="fc" id="L298">      LOGGER.error(&quot;Got exception in the channel handler&quot;, cause);</span>
<span class="fc" id="L299">      _metric.addServingStats(0, 0, 0L, true, 0, 0);</span>
<span class="fc" id="L300">      ctx.close();</span>
<span class="fc" id="L301">    }</span>


    @Override
    public String toString() {
<span class="nc" id="L306">      return &quot;NettyChannelInboundHandler [_handler=&quot; + _handler + &quot;, _metric=&quot; + _metric + &quot;]&quot;;</span>
    }
  }

  public boolean isShutdownComplete() {
<span class="nc" id="L311">    return _shutdownComplete.get();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>