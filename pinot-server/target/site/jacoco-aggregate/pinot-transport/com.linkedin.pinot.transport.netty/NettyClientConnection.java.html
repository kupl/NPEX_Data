<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NettyClientConnection.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-transport</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.transport.netty</a> &gt; <span class="el_source">NettyClientConnection.java</span></div><h1>NettyClientConnection.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.transport.netty;

import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.transport.common.AsyncResponseFuture;
import com.linkedin.pinot.transport.common.Callback;
import com.linkedin.pinot.transport.common.NoneType;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.EventLoopGroup;
import io.netty.util.Timer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * A Netty standalone connection. This will be managed as a resource in a pool to reuse
 * connection. This is not thread-safe so multiple requests cannot be sent simultaneously.
 * This class provides an async API to send requests and wait for response.
 */
public abstract class NettyClientConnection {
<span class="fc" id="L37">  protected static Logger LOGGER = LoggerFactory.getLogger(NettyTCPClientConnection.class);</span>

  /**
   * Client Connection State
   */
<span class="pc" id="L42">  public enum State {</span>
<span class="fc" id="L43">    INIT,</span>
<span class="fc" id="L44">    CONNECTED,</span>
<span class="fc" id="L45">    REQUEST_WRITTEN,</span>
<span class="fc" id="L46">    REQUEST_SENT,</span>
<span class="fc" id="L47">    ERROR,</span>
<span class="fc" id="L48">    GOT_RESPONSE;</span>

    public boolean isValidTransition(State nextState) {
<span class="pc bpc" id="L51" title="4 of 7 branches missed.">      switch (nextState) {</span>
        case INIT:
<span class="nc" id="L53">          return false; // Init state happens only as the first transition</span>
        case CONNECTED:
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">          return this == State.INIT; // We do not reconnect with same NettyClientConnection object. We create new one</span>
        case REQUEST_WRITTEN:
<span class="fc bfc" id="L57" title="All 4 branches covered.">          return (this == State.CONNECTED) || (this == State.GOT_RESPONSE);</span>
        case REQUEST_SENT:
<span class="nc bnc" id="L59" title="All 2 branches missed.">          return this == State.REQUEST_WRITTEN;</span>
        case ERROR:
<span class="fc" id="L61">          return true;</span>
        case GOT_RESPONSE:
<span class="nc bnc" id="L63" title="All 2 branches missed.">          return this == State.REQUEST_SENT;</span>
      }
<span class="nc" id="L65">      return false;</span>
    }
  };

  protected final ServerInstance _server;

  protected final EventLoopGroup _eventGroup;
  protected Bootstrap _bootstrap;
  protected volatile Channel _channel;
  // State of the request/connection
  protected volatile State _connState;
  protected final long _connId;

  // Timer for tracking read-timeouts
  protected final Timer _timer;

  // Callback to notify if a response has been successfully received or error
  protected volatile Callback&lt;NoneType&gt; _requestCallback;

<span class="fc" id="L84">  public NettyClientConnection(ServerInstance server, EventLoopGroup eventGroup, Timer timer, long connId) {</span>
<span class="fc" id="L85">    _connState = State.INIT;</span>
<span class="fc" id="L86">    _server = server;</span>
<span class="fc" id="L87">    _connId = connId;</span>
<span class="fc" id="L88">    _timer = timer;</span>
<span class="fc" id="L89">    _eventGroup = eventGroup;</span>
<span class="fc" id="L90">  }</span>

  public long getConnId() {
<span class="fc" id="L93">    return _connId;</span>
  }


  /**
   * Connect to the server. Returns false if unable to connect to the server.
   */
  public abstract boolean connect();

  /**
   * Close the client connection
   */
  public abstract void close() throws InterruptedException;

  /**
   * API to send a request asynchronously.
   * @param serializedRequest serialized payload to send the request
   * @param requestId Request Id
   * @param timeoutMs Timeout in milli-seconds. If timeout &amp;lt; 0, then no timeout
   * @return Future to return the response returned from the server.
   */
  public abstract ResponseFuture sendRequest(ByteBuf serializedRequest, long requestId, long timeoutMs);

  public void setRequestCallback(Callback&lt;NoneType&gt; callback) {
<span class="fc" id="L117">    _requestCallback = callback;</span>
<span class="fc" id="L118">  }</span>

  /**
   * Future Handle provided to the request sender to asynchronously wait for response.
   * We use guava API for implementing Futures.
   */
  public static class ResponseFuture extends AsyncResponseFuture&lt;byte[]&gt; {

    public ResponseFuture(ServerInstance key, String ctxt) {
<span class="fc" id="L127">      super(key, ctxt);</span>
<span class="fc" id="L128">    }</span>

    /**
     * Error Future which is used to represent a future which failed with error.
     * @param key Key for the future
     * @param error Throwable for the response
     */
    public ResponseFuture(ServerInstance key, Throwable error, String ctxt) {
<span class="nc" id="L136">      super(key, error, ctxt);</span>
<span class="nc" id="L137">    }</span>
  }

  /**
   * Validates if the underlying channel is active
   * @return
   */
  public boolean validate() {
<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (null == _channel) {</span>
<span class="fc" id="L146">      return false;</span>
    }
<span class="fc" id="L148">    return _channel.isActive();</span>
  }

  public ServerInstance getServer() {
<span class="fc" id="L152">    return _server;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>