<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SegmentIndexCreationDriverImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.segment.creator.impl</a> &gt; <span class="el_source">SegmentIndexCreationDriverImpl.java</span></div><h1>SegmentIndexCreationDriverImpl.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.segment.creator.impl;

import com.linkedin.pinot.common.data.FieldSpec;
import com.linkedin.pinot.common.data.MetricFieldSpec;
import com.linkedin.pinot.common.data.Schema;
import com.linkedin.pinot.common.data.StarTreeIndexSpec;
import com.linkedin.pinot.core.data.GenericRow;
import com.linkedin.pinot.core.data.extractors.FieldExtractorFactory;
import com.linkedin.pinot.core.data.extractors.PlainFieldExtractor;
import com.linkedin.pinot.core.data.readers.RecordReader;
import com.linkedin.pinot.core.data.readers.RecordReaderFactory;
import com.linkedin.pinot.core.indexsegment.generator.SegmentGeneratorConfig;
import com.linkedin.pinot.core.indexsegment.generator.SegmentVersion;
import com.linkedin.pinot.core.segment.creator.ColumnIndexCreationInfo;
import com.linkedin.pinot.core.segment.creator.ColumnStatistics;
import com.linkedin.pinot.core.segment.creator.ForwardIndexType;
import com.linkedin.pinot.core.segment.creator.InvertedIndexType;
import com.linkedin.pinot.core.segment.creator.RecordReaderSegmentCreationDataSource;
import com.linkedin.pinot.core.segment.creator.SegmentCreationDataSource;
import com.linkedin.pinot.core.segment.creator.SegmentCreator;
import com.linkedin.pinot.core.segment.creator.SegmentIndexCreationDriver;
import com.linkedin.pinot.core.segment.creator.SegmentIndexCreationInfo;
import com.linkedin.pinot.core.segment.creator.SegmentPreIndexStatsContainer;
import com.linkedin.pinot.core.segment.creator.StatsCollectorConfig;
import com.linkedin.pinot.core.segment.creator.impl.stats.SegmentPreIndexStatsCollectorImpl;
import com.linkedin.pinot.core.segment.index.converter.SegmentFormatConverter;
import com.linkedin.pinot.core.segment.index.converter.SegmentFormatConverterFactory;
import com.linkedin.pinot.core.segment.store.SegmentDirectoryPaths;
import com.linkedin.pinot.core.startree.OffHeapStarTreeBuilder;
import com.linkedin.pinot.core.startree.StarTreeBuilder;
import com.linkedin.pinot.core.startree.StarTreeBuilderConfig;
import com.linkedin.pinot.core.startree.hll.HllUtil;
import com.linkedin.pinot.core.util.CrcUtils;
import com.linkedin.pinot.startree.hll.HllConfig;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Implementation of an index segment creator.
 */
// TODO: Check resource leaks
<span class="fc" id="L71">public class SegmentIndexCreationDriverImpl implements SegmentIndexCreationDriver {</span>

<span class="fc" id="L73">  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentIndexCreationDriverImpl.class);</span>

  private SegmentGeneratorConfig config;
  private RecordReader recordReader;
  private SegmentPreIndexStatsContainer segmentStats;
  private Map&lt;String, ColumnIndexCreationInfo&gt; indexCreationInfoMap;
  private SegmentCreator indexCreator;
  private SegmentIndexCreationInfo segmentIndexCreationInfo;
  private Schema dataSchema;
  private PlainFieldExtractor extractor;
<span class="fc" id="L83">  private int totalDocs = 0;</span>
<span class="fc" id="L84">  private int totalRawDocs = 0;</span>
<span class="fc" id="L85">  private int totalAggDocs = 0;</span>
  private File tempIndexDir;
  private String segmentName;
<span class="fc" id="L88">  private long totalRecordReadTime = 0;</span>
<span class="fc" id="L89">  private long totalIndexTime = 0;</span>
<span class="fc" id="L90">  private long totalStatsCollectorTime = 0;</span>
<span class="fc" id="L91">  private boolean createStarTree = false;</span>
  // flag indicates if the this segment generator code
  // will create the HLL index for the given columns.
  // This will be false if HLL column is provided to us
<span class="fc" id="L95">  private boolean createHllIndex = false;</span>

  private File starTreeTempDir;

  @Override
  public void init(SegmentGeneratorConfig config) throws Exception {
<span class="fc" id="L101">    init(config, new RecordReaderSegmentCreationDataSource(RecordReaderFactory.getRecordReader(config)));</span>
<span class="fc" id="L102">  }</span>

  public void init(SegmentGeneratorConfig config, SegmentCreationDataSource dataSource) throws Exception {
<span class="fc" id="L105">    this.config = config;</span>
<span class="fc" id="L106">    this.createStarTree = config.isEnableStarTreeIndex();</span>
<span class="fc" id="L107">    recordReader = dataSource.getRecordReader();</span>
<span class="fc" id="L108">    dataSchema = recordReader.getSchema();</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (config.getHllConfig() != null) {</span>
<span class="fc" id="L111">      HllConfig hllConfig = config.getHllConfig();</span>
      // create hll index is true only if we're provided with columns to
      // generate HLL fields
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">      if (hllConfig.getColumnsToDeriveHllFields() != null &amp;&amp; !hllConfig.getColumnsToDeriveHllFields().isEmpty()) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (!createStarTree) {</span>
<span class="nc" id="L116">          throw new IllegalArgumentException(&quot;Derived HLL fields generation will not work if StarTree is not enabled.&quot;);</span>
        } else {
<span class="fc" id="L118">          createHllIndex = true;</span>
        }
      } // else columnsToDeriveHllFields is null...don't do anything in this case
      // segment seal() will write the log2m value to the metadata
    }

<span class="fc" id="L124">    addDerivedFieldsInSchema();</span>

<span class="fc" id="L126">    extractor = FieldExtractorFactory.getPlainFieldExtractor(dataSchema);</span>

    // Initialize stats collection
<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (!createStarTree) { // For star tree, the stats are gathered in buildStarTree()</span>
<span class="fc" id="L130">      segmentStats = dataSource.gatherStats(new StatsCollectorConfig(dataSchema, config.getSegmentPartitionConfig()));</span>
<span class="fc" id="L131">      totalDocs = segmentStats.getTotalDocCount();</span>
<span class="fc" id="L132">      totalRawDocs = segmentStats.getRawDocCount();</span>
<span class="fc" id="L133">      totalAggDocs = segmentStats.getAggregatedDocCount();</span>
    }

    // Initialize index creation
<span class="fc" id="L137">    segmentIndexCreationInfo = new SegmentIndexCreationInfo();</span>
<span class="fc" id="L138">    indexCreationInfoMap = new HashMap&lt;&gt;();</span>

    // Check if has star tree
<span class="fc" id="L141">    indexCreator = new SegmentColumnarIndexCreator();</span>

    // Ensure that the output directory exists
<span class="fc" id="L144">    final File indexDir = new File(config.getOutDir());</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    if (!indexDir.exists()) {</span>
<span class="nc" id="L146">      indexDir.mkdirs();</span>
    }

    // Create a temporary directory used in segment creation
<span class="fc" id="L150">    tempIndexDir = new File(indexDir, com.linkedin.pinot.common.utils.FileUtils.getRandomFileName());</span>
<span class="fc" id="L151">    starTreeTempDir = new File(indexDir, com.linkedin.pinot.common.utils.FileUtils.getRandomFileName());</span>
<span class="fc" id="L152">    LOGGER.debug(&quot;tempIndexDir:{}&quot;, tempIndexDir);</span>
<span class="fc" id="L153">    LOGGER.debug(&quot;starTreeTempDir:{}&quot;, starTreeTempDir);</span>
<span class="fc" id="L154">  }</span>

  public void init(SegmentGeneratorConfig config, RecordReader reader) throws Exception {
<span class="fc" id="L157">    init(config, new RecordReaderSegmentCreationDataSource(reader));</span>
<span class="fc" id="L158">  }</span>

  private void addDerivedFieldsInSchema() {
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (createHllIndex) {</span>
<span class="fc" id="L162">      Collection&lt;String&gt; columnNames = dataSchema.getColumnNames();</span>
<span class="fc" id="L163">      HllConfig hllConfig = config.getHllConfig();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">      for (String derivedFieldName : hllConfig.getDerivedHllFieldToOriginMap().keySet()) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (columnNames.contains(derivedFieldName)) {</span>
<span class="nc" id="L166">          throw new IllegalArgumentException(</span>
              &quot;Cannot add derived field: &quot; + derivedFieldName + &quot; since it already exists in schema.&quot;);
        } else {
<span class="fc" id="L169">          dataSchema.addField(</span>
              new MetricFieldSpec(derivedFieldName, FieldSpec.DataType.STRING, hllConfig.getHllFieldSize(),
                  MetricFieldSpec.DerivedMetricType.HLL));
        }
<span class="fc" id="L173">      }</span>
    }
<span class="fc" id="L175">  }</span>

  private void populateDefaultDerivedColumnValues(GenericRow row) throws IOException {
    //add default hll value in each row
<span class="fc bfc" id="L179" title="All 2 branches covered.">    if (createHllIndex) {</span>
<span class="fc" id="L180">      HllConfig hllConfig = config.getHllConfig();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">      for (Entry&lt;String, String&gt; entry : hllConfig.getDerivedHllFieldToOriginMap().entrySet()) {</span>
<span class="fc" id="L182">        String derivedFieldName = entry.getKey();</span>
<span class="fc" id="L183">        String originFieldName = entry.getValue();</span>
<span class="fc" id="L184">        row.putField(derivedFieldName,</span>
            HllUtil.singleValueHllAsString(hllConfig.getHllLog2m(), row.getValue(originFieldName)));
<span class="fc" id="L186">      }</span>
    }
<span class="fc" id="L188">  }</span>

  @Override
  public void build() throws Exception {
<span class="fc bfc" id="L192" title="All 2 branches covered.">    if (createStarTree) {</span>
      // TODO: add on-heap star-tree builder
<span class="fc" id="L194">      buildStarTree();</span>
    } else {
<span class="fc" id="L196">      buildRaw();</span>
    }
<span class="fc" id="L198">  }</span>

  private void buildStarTree() throws Exception {
    // Create stats collector
<span class="fc" id="L202">    StatsCollectorConfig statsCollectorConfig = new StatsCollectorConfig(dataSchema, config.getSegmentPartitionConfig());</span>
<span class="fc" id="L203">    SegmentPreIndexStatsCollectorImpl statsCollector = new SegmentPreIndexStatsCollectorImpl(statsCollectorConfig);</span>
<span class="fc" id="L204">    statsCollector.init();</span>
<span class="fc" id="L205">    segmentStats = statsCollector;</span>

<span class="fc" id="L207">    long start = System.currentTimeMillis();</span>
    //construct star tree builder config
<span class="fc" id="L209">    StarTreeIndexSpec starTreeIndexSpec = config.getStarTreeIndexSpec();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">    if (starTreeIndexSpec == null) {</span>
<span class="fc" id="L211">      starTreeIndexSpec = new StarTreeIndexSpec();</span>
<span class="fc" id="L212">      starTreeIndexSpec.setMaxLeafRecords(StarTreeIndexSpec.DEFAULT_MAX_LEAF_RECORDS);</span>

      // Overwrite the null index spec with default one.
<span class="fc" id="L215">      config.enableStarTreeIndex(starTreeIndexSpec);</span>
    }
    //create star builder config from startreeindexspec. Merge these two in one later.
<span class="fc" id="L218">    StarTreeBuilderConfig starTreeBuilderConfig = new StarTreeBuilderConfig();</span>
<span class="fc" id="L219">    starTreeBuilderConfig.setOutDir(starTreeTempDir);</span>
<span class="fc" id="L220">    starTreeBuilderConfig.setSchema(dataSchema);</span>
<span class="fc" id="L221">    starTreeBuilderConfig.setDimensionsSplitOrder(starTreeIndexSpec.getDimensionsSplitOrder());</span>
<span class="fc" id="L222">    starTreeBuilderConfig.setSkipStarNodeCreationDimensions(</span>
        starTreeIndexSpec.getSkipStarNodeCreationForDimensions());
<span class="fc" id="L224">    starTreeBuilderConfig.setSkipMaterializationDimensions(starTreeIndexSpec.getSkipMaterializationForDimensions());</span>
<span class="fc" id="L225">    starTreeBuilderConfig.setSkipMaterializationCardinalityThreshold(</span>
        starTreeIndexSpec.getSkipMaterializationCardinalityThreshold());
<span class="fc" id="L227">    starTreeBuilderConfig.setMaxNumLeafRecords(starTreeIndexSpec.getMaxLeafRecords());</span>
<span class="fc" id="L228">    starTreeBuilderConfig.setExcludeSkipMaterializationDimensionsForStarTreeIndex(</span>
        starTreeIndexSpec.isExcludeSkipMaterializationDimensionsForStarTreeIndex());

    //initialize star tree builder
<span class="pc" id="L232">    try (StarTreeBuilder starTreeBuilder = new OffHeapStarTreeBuilder()) {</span>
<span class="fc" id="L233">      starTreeBuilder.init(starTreeBuilderConfig);</span>
      //build star tree along with collecting stats
<span class="fc" id="L235">      recordReader.rewind();</span>
<span class="fc" id="L236">      LOGGER.info(&quot;Start append raw data to star tree builder!&quot;);</span>
<span class="fc" id="L237">      totalDocs = 0;</span>
<span class="fc" id="L238">      GenericRow readRow = new GenericRow();</span>
<span class="fc" id="L239">      GenericRow transformedRow = new GenericRow();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">      while (recordReader.hasNext()) {</span>
        //PlainFieldExtractor conducts necessary type conversions
<span class="fc" id="L242">        transformedRow = readNextRowSanitized(readRow, transformedRow);</span>
        //must be called after previous step since type conversion for derived values is unnecessary
<span class="fc" id="L244">        populateDefaultDerivedColumnValues(transformedRow);</span>
<span class="fc" id="L245">        starTreeBuilder.append(transformedRow);</span>
<span class="fc" id="L246">        statsCollector.collectRow(transformedRow);</span>
<span class="fc" id="L247">        totalRawDocs++;</span>
<span class="fc" id="L248">        totalDocs++;</span>
      }
<span class="fc" id="L250">      recordReader.close();</span>
<span class="fc" id="L251">      LOGGER.info(&quot;Start building star tree!&quot;);</span>
<span class="fc" id="L252">      starTreeBuilder.build();</span>
<span class="fc" id="L253">      LOGGER.info(&quot;Finished building star tree!&quot;);</span>
<span class="fc" id="L254">      long starTreeBuildFinishTime = System.currentTimeMillis();</span>
      //build stats
      // Count the number of documents and gather per-column statistics
<span class="fc" id="L257">      LOGGER.info(&quot;Start building StatsCollector!&quot;);</span>
<span class="fc" id="L258">      Iterator&lt;GenericRow&gt; aggregatedRowsIterator = starTreeBuilder.iterator(starTreeBuilder.getTotalRawDocumentCount(),</span>
          starTreeBuilder.getTotalRawDocumentCount() + starTreeBuilder.getTotalAggregateDocumentCount());
<span class="fc bfc" id="L260" title="All 2 branches covered.">      while (aggregatedRowsIterator.hasNext()) {</span>
<span class="fc" id="L261">        GenericRow genericRow = aggregatedRowsIterator.next();</span>
<span class="fc" id="L262">        statsCollector.collectRow(genericRow, true /* isAggregated */);</span>
<span class="fc" id="L263">        totalAggDocs++;</span>
<span class="fc" id="L264">        totalDocs++;</span>
<span class="fc" id="L265">      }</span>
<span class="fc" id="L266">      statsCollector.build();</span>
<span class="fc" id="L267">      buildIndexCreationInfo();</span>
<span class="fc" id="L268">      LOGGER.info(&quot;Collected stats for {} raw documents, {} aggregated documents&quot;, totalRawDocs, totalAggDocs);</span>
<span class="fc" id="L269">      long statCollectionFinishTime = System.currentTimeMillis();</span>

      try {
        // Initialize the index creation using the per-column statistics information
<span class="fc" id="L273">        indexCreator.init(config, segmentIndexCreationInfo, indexCreationInfoMap, dataSchema, tempIndexDir);</span>

        //iterate over the data again,
<span class="fc" id="L276">        Iterator&lt;GenericRow&gt; allRowsIterator = starTreeBuilder.iterator(0,</span>
            starTreeBuilder.getTotalRawDocumentCount() + starTreeBuilder.getTotalAggregateDocumentCount());

<span class="fc bfc" id="L279" title="All 2 branches covered.">        while (allRowsIterator.hasNext()) {</span>
<span class="fc" id="L280">          GenericRow genericRow = allRowsIterator.next();</span>
<span class="fc" id="L281">          indexCreator.indexRow(genericRow);</span>
<span class="fc" id="L282">        }</span>
<span class="nc" id="L283">      } catch (Exception e) {</span>
<span class="nc" id="L284">        indexCreator.close();</span>
<span class="nc" id="L285">        throw e;</span>
<span class="fc" id="L286">      }</span>

      // Serialize the star tree into a file
<span class="fc" id="L289">      starTreeBuilder.serializeTree(new File(tempIndexDir, V1Constants.STAR_TREE_INDEX_FILE), indexCreationInfoMap);</span>

      // Update the dimensions split order and skip materialization dimensions spec so that then can be written into
      // the segment metadata
<span class="fc" id="L293">      starTreeIndexSpec.setDimensionsSplitOrder(starTreeBuilder.getDimensionsSplitOrder());</span>
<span class="fc" id="L294">      starTreeIndexSpec.setSkipMaterializationForDimensions(starTreeBuilder.getSkipMaterializationDimensions());</span>

      //post creation
<span class="fc" id="L297">      handlePostCreation();</span>
<span class="fc" id="L298">      long end = System.currentTimeMillis();</span>
<span class="fc" id="L299">      LOGGER.info(&quot;Total time:{} \n star tree build time:{} \n stat collection time:{} \n column index build time:{}&quot;,</span>
          (end - start), (starTreeBuildFinishTime - start), statCollectionFinishTime - starTreeBuildFinishTime,
          end - statCollectionFinishTime);
<span class="pc bpc" id="L302" title="6 of 8 branches missed.">    }</span>
<span class="fc" id="L303">  }</span>

  private void buildRaw()
      throws Exception {
    // Count the number of documents and gather per-column statistics
<span class="fc" id="L308">    LOGGER.debug(&quot;Start building StatsCollector!&quot;);</span>
<span class="fc" id="L309">    buildIndexCreationInfo();</span>
<span class="fc" id="L310">    LOGGER.info(&quot;Finished building StatsCollector!&quot;);</span>
<span class="fc" id="L311">    LOGGER.info(&quot;Collected stats for {} documents&quot;, totalDocs);</span>

    try {
      // Initialize the index creation using the per-column statistics information
<span class="fc" id="L315">      indexCreator.init(config, segmentIndexCreationInfo, indexCreationInfoMap, dataSchema, tempIndexDir);</span>

      // Build the index
<span class="fc" id="L318">      recordReader.rewind();</span>
<span class="fc" id="L319">      LOGGER.info(&quot;Start building IndexCreator!&quot;);</span>
<span class="fc" id="L320">      GenericRow readRow = new GenericRow();</span>
<span class="fc" id="L321">      GenericRow transformedRow = new GenericRow();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">      while (recordReader.hasNext()) {</span>
<span class="fc" id="L323">        long start = System.currentTimeMillis();</span>
<span class="fc" id="L324">        transformedRow = readNextRowSanitized(readRow, transformedRow);</span>
<span class="fc" id="L325">        long stop = System.currentTimeMillis();</span>
<span class="fc" id="L326">        indexCreator.indexRow(transformedRow);</span>
<span class="fc" id="L327">        long stop1 = System.currentTimeMillis();</span>
<span class="fc" id="L328">        totalRecordReadTime += (stop - start);</span>
<span class="fc" id="L329">        totalIndexTime += (stop1 - stop);</span>
<span class="fc" id="L330">      }</span>
<span class="nc" id="L331">    } catch (Exception e) {</span>
<span class="nc" id="L332">      indexCreator.close();</span>
<span class="nc" id="L333">      throw e;</span>
    } finally {
<span class="pc" id="L335">      recordReader.close();</span>
<span class="fc" id="L336">    }</span>
<span class="fc" id="L337">    LOGGER.info(&quot;Finished records indexing in IndexCreator!&quot;);</span>
    int numErrors, numConversions, numNulls, numNullCols;
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">    if ((numErrors = extractor.getTotalErrors()) &gt; 0) {</span>
<span class="nc" id="L340">      LOGGER.warn(&quot;Index creator for schema {} had {} rows with errors&quot;, dataSchema.getSchemaName(), numErrors);</span>
    }
<span class="fc" id="L342">    Map&lt;String, Integer&gt; errorCount = extractor.getErrorCount();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">    for (String column : errorCount.keySet()) {</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">      if ((numErrors = errorCount.get(column)) &gt; 0) {</span>
<span class="nc" id="L345">        LOGGER.info(&quot;Column {} had {} rows with errors&quot;, column, numErrors);</span>
      }
<span class="fc" id="L347">    }</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">    if ((numConversions = extractor.getTotalConversions()) &gt; 0) {</span>
<span class="nc" id="L349">      LOGGER.info(&quot;Index creator for schema {} had {} rows with type conversions&quot;, dataSchema.getSchemaName(),</span>
          numConversions);
    }
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">    if ((numNulls = extractor.getTotalNulls()) &gt; 0) {</span>
<span class="nc" id="L353">      LOGGER.info(&quot;Index creator for schema {} had {} rows with null columns&quot;, dataSchema.getSchemaName(), numNulls);</span>
    }
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">    if ((numNullCols = extractor.getTotalNullCols()) &gt; 0) {</span>
<span class="nc" id="L356">      LOGGER.info(&quot;Index creator for schema {} had {}  null columns&quot;, dataSchema.getSchemaName(), numNullCols);</span>
    }

<span class="fc" id="L359">    handlePostCreation();</span>
<span class="fc" id="L360">  }</span>

  private void handlePostCreation()
      throws Exception {
<span class="fc" id="L364">    final String timeColumn = config.getTimeColumnName();</span>
<span class="fc" id="L365">    segmentName = config.getSegmentNameGenerator().generateSegmentName(segmentStats.getColumnProfileFor(timeColumn));</span>
<span class="fc" id="L366">    updateSegmentStartEndTimeIfNecessary(segmentStats.getColumnProfileFor(timeColumn));</span>

    try {
      // Write the index files to disk
<span class="fc" id="L370">      indexCreator.setSegmentName(segmentName);</span>
<span class="fc" id="L371">      indexCreator.seal();</span>
    } finally {
<span class="pc" id="L373">      indexCreator.close();</span>
<span class="fc" id="L374">    }</span>
<span class="fc" id="L375">    LOGGER.info(&quot;Finished segment seal!&quot;);</span>

    // Delete the directory named after the segment name, if it exists
<span class="fc" id="L378">    final File outputDir = new File(config.getOutDir());</span>
<span class="fc" id="L379">    final File segmentOutputDir = new File(outputDir, segmentName);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">    if (segmentOutputDir.exists()) {</span>
<span class="fc" id="L381">      FileUtils.deleteDirectory(segmentOutputDir);</span>
    }

    // Move the temporary directory into its final location
<span class="fc" id="L385">    FileUtils.moveDirectory(tempIndexDir, segmentOutputDir);</span>

    // Delete the temporary directory
<span class="fc" id="L388">    FileUtils.deleteQuietly(tempIndexDir);</span>

    // Convert segment format if necessary
<span class="fc" id="L391">    convertFormatIfNeeded(segmentOutputDir);</span>

    // Compute CRC and creation time
<span class="fc" id="L394">    long crc = CrcUtils.forAllFilesInFolder(segmentOutputDir).computeCrc();</span>
    long creationTime;
<span class="fc" id="L396">    String creationTimeInConfig = config.getCreationTime();</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">    if (creationTimeInConfig != null) {</span>
      try {
<span class="fc" id="L399">        creationTime = Long.parseLong(creationTimeInConfig);</span>
<span class="nc" id="L400">      } catch (Exception e) {</span>
<span class="nc" id="L401">        LOGGER.error(&quot;Caught exception while parsing creation time in config, use current time as creation time&quot;);</span>
<span class="nc" id="L402">        creationTime = System.currentTimeMillis();</span>
<span class="pc" id="L403">      }</span>
    } else {
<span class="fc" id="L405">      creationTime = System.currentTimeMillis();</span>
    }

    // Persist creation metadata to disk
<span class="fc" id="L409">    persistCreationMeta(segmentOutputDir, crc, creationTime);</span>

<span class="fc" id="L411">    LOGGER.info(&quot;Driver, record read time : {}&quot;, totalRecordReadTime);</span>
<span class="fc" id="L412">    LOGGER.info(&quot;Driver, stats collector time : {}&quot;, totalStatsCollectorTime);</span>
<span class="fc" id="L413">    LOGGER.info(&quot;Driver, indexing time : {}&quot;, totalIndexTime);</span>
<span class="fc" id="L414">  }</span>

  private void updateSegmentStartEndTimeIfNecessary(ColumnStatistics timeColumnStats) {
<span class="pc bpc" id="L417" title="1 of 3 branches missed.">    switch (config.getTimeColumnType()) {</span>
      case EPOCH:
<span class="fc" id="L419">        break;</span>
      case SIMPLE_DATE:
<span class="fc" id="L421">        long startTime = convertStartTimeSDFToMillis(timeColumnStats);</span>
<span class="fc" id="L422">        config.getCustomProperties().put(V1Constants.MetadataKeys.Segment.SEGMENT_START_TIME, String.valueOf(startTime));</span>
<span class="fc" id="L423">        long endTime = convertEndTimeSDFToMillis(timeColumnStats);</span>
<span class="fc" id="L424">        config.getCustomProperties().put(V1Constants.MetadataKeys.Segment.SEGMENT_END_TIME, String.valueOf(endTime));</span>
        break;
    }
<span class="fc" id="L427">  }</span>

  public long convertStartTimeSDFToMillis(ColumnStatistics timeColumnStats) {
<span class="fc" id="L430">    final String minTimeStr = timeColumnStats.getMinValue().toString();</span>
<span class="fc" id="L431">    return convertSDFToMillis(minTimeStr);</span>
  }

  public long convertEndTimeSDFToMillis(ColumnStatistics timeColumnStats) {
<span class="fc" id="L435">    final String maxTimeStr = timeColumnStats.getMaxValue().toString();</span>
<span class="fc" id="L436">    return convertSDFToMillis(maxTimeStr);</span>
  }

  private long convertSDFToMillis(final String colValue) {
<span class="fc" id="L440">    final String sdfFormatStr = config.getSimpleDateFormat();</span>
<span class="fc" id="L441">    DateTimeFormatter sdfFormatter = DateTimeFormat.forPattern(sdfFormatStr);</span>
<span class="fc" id="L442">    DateTime dateTime = DateTime.parse(colValue, sdfFormatter);</span>
<span class="fc" id="L443">    return dateTime.getMillis();</span>
  }

  // Explanation of why we are using format converter:
  // There are 3 options to correctly generate segments to v3 format
  // 1. Generate v3 directly: This is efficient but v3 index writer needs to know buffer size upfront.
  // Inverted, star and raw indexes don't have the index size upfront. This is also least flexible approach
  // if we add more indexes in future.
  // 2. Hold data in-memory: One way to work around predeclaring sizes in (1) is to allocate &quot;large&quot; buffer (2GB?)
  // and hold the data in memory and write the buffer at the end. The memory requirement in this case increases linearly
  // with the number of columns. Variation of that is to mmap data to separate files...which is what we are doing here
  // 3. Another option is to generate dictionary and fwd indexes in v3 and generate inverted, star and raw indexes in
  // separate files. Then add those files to v3 index file. This leads to lot of hodgepodge code to
  // handle multiple segment formats.
  // Using converter is similar to option (2), plus it's battle-tested code. We will roll out with
  // this change to keep changes limited. Once we've migrated we can implement approach (1) with option to
  // copy for indexes for which we don't know sizes upfront.
  private void convertFormatIfNeeded(File segmentDirectory)
      throws Exception {
<span class="fc" id="L462">    SegmentVersion versionToGenerate = config.getSegmentVersion();</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">    if (versionToGenerate.equals(SegmentVersion.v1)) {</span>
      // v1 by default
<span class="fc" id="L465">      return;</span>
    }
<span class="fc" id="L467">    SegmentFormatConverter converter = SegmentFormatConverterFactory.getConverter(SegmentVersion.v1, SegmentVersion.v3);</span>
<span class="fc" id="L468">    converter.convert(segmentDirectory);</span>
<span class="fc" id="L469">  }</span>

  public ColumnStatistics getColumnStatisticsCollector(final String columnName)
      throws Exception {
<span class="fc" id="L473">    return segmentStats.getColumnProfileFor(columnName);</span>
  }

  public static void persistCreationMeta(File indexDir, long crc, long creationTime) throws IOException {
<span class="fc" id="L477">    File segmentDir = SegmentDirectoryPaths.findSegmentDirectory(indexDir);</span>
<span class="fc" id="L478">    File creationMetaFile = new File(segmentDir, V1Constants.SEGMENT_CREATION_META);</span>
<span class="pc" id="L479">    try (DataOutputStream output = new DataOutputStream(new FileOutputStream(creationMetaFile))) {</span>
<span class="fc" id="L480">      output.writeLong(crc);</span>
<span class="fc" id="L481">      output.writeLong(creationTime);</span>
<span class="pc bpc" id="L482" title="6 of 8 branches missed.">    }</span>
<span class="fc" id="L483">  }</span>

  /**
   * Complete the stats gathering process and store the stats information in indexCreationInfoMap.
   */
  void buildIndexCreationInfo()
      throws Exception {
<span class="fc bfc" id="L490" title="All 2 branches covered.">    for (FieldSpec spec : dataSchema.getAllFieldSpecs()) {</span>
<span class="fc" id="L491">      String column = spec.getName();</span>
<span class="fc" id="L492">      indexCreationInfoMap.put(column,</span>
          new ColumnIndexCreationInfo(true/*createDictionary*/, segmentStats.getColumnProfileFor(column).getMinValue(),
              segmentStats.getColumnProfileFor(column).getMaxValue(),
              segmentStats.getColumnProfileFor(column).getUniqueValuesSet(), ForwardIndexType.FIXED_BIT_COMPRESSED,
              InvertedIndexType.ROARING_BITMAPS, segmentStats.getColumnProfileFor(column).isSorted(),
              segmentStats.getColumnProfileFor(column).hasNull(),
              segmentStats.getColumnProfileFor(column).getTotalNumberOfEntries(),
              segmentStats.getColumnProfileFor(column).getMaxNumberOfMultiValues(),
              segmentStats.getColumnProfileFor(column).getLengthOfLargestElement(), false/*isAutoGenerated*/,
              segmentStats.getColumnProfileFor(column).getPartitionFunction(),
              segmentStats.getColumnProfileFor(column).getNumPartitions(),
              segmentStats.getColumnProfileFor(column).getPartitionRanges(),
              dataSchema.getFieldSpecFor(column).getDefaultNullValue()));
<span class="fc" id="L505">    }</span>
<span class="fc" id="L506">    segmentIndexCreationInfo.setTotalDocs(totalDocs);</span>
<span class="fc" id="L507">    segmentIndexCreationInfo.setTotalRawDocs(totalRawDocs);</span>
<span class="fc" id="L508">    segmentIndexCreationInfo.setTotalAggDocs(totalAggDocs);</span>
<span class="fc" id="L509">    segmentIndexCreationInfo.setStarTreeEnabled(createStarTree);</span>
<span class="fc" id="L510">    segmentIndexCreationInfo.setTotalConversions(extractor.getTotalConversions());</span>
<span class="fc" id="L511">    segmentIndexCreationInfo.setTotalErrors(extractor.getTotalErrors());</span>
<span class="fc" id="L512">    segmentIndexCreationInfo.setTotalNullCols(extractor.getTotalNullCols());</span>
<span class="fc" id="L513">    segmentIndexCreationInfo.setTotalNulls(extractor.getTotalNulls());</span>
<span class="fc" id="L514">  }</span>

  /**
   * Returns the name of the segment associated with this index creation driver.
   */
  @Override
  public String getSegmentName() {
<span class="fc" id="L521">    return segmentName;</span>
  }

  /**
   * Returns the path of the output directory
   */
  @Override
  public File getOutputDirectory() {
<span class="fc" id="L529">    return new File(new File(config.getOutDir()), segmentName);</span>
  }

  private GenericRow readNextRowSanitized(GenericRow readRow, GenericRow transformedRow) throws IOException {
<span class="fc" id="L533">    return extractor.transform(recordReader.next(readRow), transformedRow);</span>
  }

  public SegmentPreIndexStatsContainer getSegmentStats() {
<span class="nc" id="L537">    return segmentStats;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>