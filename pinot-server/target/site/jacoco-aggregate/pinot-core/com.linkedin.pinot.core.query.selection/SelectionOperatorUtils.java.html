<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SelectionOperatorUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-core</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.core.query.selection</a> &gt; <span class="el_source">SelectionOperatorUtils.java</span></div><h1>SelectionOperatorUtils.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.core.query.selection;

import com.linkedin.pinot.common.data.FieldSpec.DataType;
import com.linkedin.pinot.common.request.Selection;
import com.linkedin.pinot.common.request.SelectionSort;
import com.linkedin.pinot.common.response.ServerInstance;
import com.linkedin.pinot.common.response.broker.SelectionResults;
import com.linkedin.pinot.common.utils.DataSchema;
import com.linkedin.pinot.common.utils.DataTable;
import com.linkedin.pinot.core.common.DataSourceMetadata;
import com.linkedin.pinot.core.common.datatable.DataTableBuilder;
import com.linkedin.pinot.core.indexsegment.IndexSegment;
import java.io.Serializable;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;


/**
 * The &lt;code&gt;SelectionOperatorUtils&lt;/code&gt; class provides the utility methods for selection queries without
 * &lt;code&gt;ORDER BY&lt;/code&gt; and {@link SelectionOperatorService}.
 * &lt;p&gt;Expected behavior:
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     Return selection results with the same order of columns as user passed in.
 *     &lt;ul&gt;
 *       &lt;li&gt;Eg. SELECT colB, colA, colC FROM table -&gt; [valB, valA, valC]&lt;/li&gt;
 *     &lt;/ul&gt;
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     For 'SELECT *', return columns with alphabetically order.
 *     &lt;ul&gt;
 *       &lt;li&gt;Eg. SELECT * FROM table -&gt; [valA, valB, valC]&lt;/li&gt;
 *     &lt;/ul&gt;
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 */
public class SelectionOperatorUtils {
<span class="nc" id="L66">  private SelectionOperatorUtils() {</span>
<span class="nc" id="L67">  }</span>

<span class="fc" id="L69">  private static final DecimalFormat INT_FORMAT =</span>
      new DecimalFormat(&quot;##########&quot;, DecimalFormatSymbols.getInstance(Locale.US));
<span class="fc" id="L71">  private static final DecimalFormat LONG_FORMAT =</span>
      new DecimalFormat(&quot;####################&quot;, DecimalFormatSymbols.getInstance(Locale.US));
<span class="fc" id="L73">  private static final DecimalFormat FLOAT_FORMAT =</span>
      new DecimalFormat(&quot;#########0.0####&quot;, DecimalFormatSymbols.getInstance(Locale.US));
<span class="fc" id="L75">  private static final DecimalFormat DOUBLE_FORMAT =</span>
      new DecimalFormat(&quot;###################0.0#########&quot;, DecimalFormatSymbols.getInstance(Locale.US));

  /**
   * Expand &lt;code&gt;'SELECT *'&lt;/code&gt; to select all columns with {@link IndexSegment}, order all columns alphabatically.
   * (Inner segment)
   *
   * @param selectionColumns unexpanded selection columns (may contain '*').
   * @param indexSegment index segment.
   * @return expanded selection columns.
   */
  @Nonnull
  public static List&lt;String&gt; getSelectionColumns(@Nonnull List&lt;String&gt; selectionColumns,
      @Nonnull IndexSegment indexSegment) {
<span class="pc bpc" id="L89" title="1 of 4 branches missed.">    if (selectionColumns.size() == 1 &amp;&amp; selectionColumns.get(0).equals(&quot;*&quot;)) {</span>
<span class="fc" id="L90">      List&lt;String&gt; allColumns = new ArrayList&lt;&gt;(indexSegment.getColumnNames());</span>
<span class="fc" id="L91">      Collections.sort(allColumns);</span>
<span class="fc" id="L92">      return allColumns;</span>
    } else {
<span class="fc" id="L94">      return selectionColumns;</span>
    }
  }

  /**
   * Extract all related columns for a selection query with {@link IndexSegment}. (Inner segment)
   *
   * @param selection selection query.
   * @param indexSegment index segment.
   * @return all related columns.
   */
  @Nonnull
  public static String[] extractSelectionRelatedColumns(@Nonnull Selection selection,
      @Nonnull IndexSegment indexSegment) {
<span class="fc" id="L108">    Set&lt;String&gt; selectionColumns = new HashSet&lt;&gt;(getSelectionColumns(selection.getSelectionColumns(), indexSegment));</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    if (selection.getSelectionSortSequence() != null) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">      for (SelectionSort selectionSort : selection.getSelectionSortSequence()) {</span>
<span class="fc" id="L111">        selectionColumns.add(selectionSort.getColumn());</span>
<span class="fc" id="L112">      }</span>
    }
<span class="fc" id="L114">    return selectionColumns.toArray(new String[selectionColumns.size()]);</span>
  }

  /**
   * Extract the {@link DataSchema} from sort sequence, selection columns and {@link IndexSegment}. (Inner segment)
   * &lt;p&gt;Inside data schema, we just store each column once (de-duplicated).
   *
   * @param sortSequence sort sequence.
   * @param selectionColumns selection columns.
   * @param indexSegment index segment.
   * @return data schema.
   */
  @Nonnull
  public static DataSchema extractDataSchema(@Nullable List&lt;SelectionSort&gt; sortSequence,
      @Nonnull List&lt;String&gt; selectionColumns, @Nonnull IndexSegment indexSegment) {
<span class="fc" id="L129">    List&lt;String&gt; columnList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L130">    Set&lt;String&gt; columnSet = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">    if (sortSequence != null) {</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">      for (SelectionSort selectionSort : sortSequence) {</span>
<span class="fc" id="L134">        String column = selectionSort.getColumn();</span>
<span class="fc" id="L135">        columnList.add(column);</span>
<span class="fc" id="L136">        columnSet.add(column);</span>
<span class="fc" id="L137">      }</span>
    }

<span class="fc bfc" id="L140" title="All 2 branches covered.">    for (String column : selectionColumns) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">      if (!columnSet.contains(column)) {</span>
<span class="fc" id="L142">        columnList.add(column);</span>
<span class="fc" id="L143">        columnSet.add(column);</span>
      }
<span class="fc" id="L145">    }</span>

<span class="fc" id="L147">    int numColumns = columnList.size();</span>
<span class="fc" id="L148">    String[] columns = new String[numColumns];</span>
<span class="fc" id="L149">    DataType[] dataTypes = new DataType[numColumns];</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    for (int i = 0; i &lt; numColumns; i++) {</span>
<span class="fc" id="L151">      String column = columnList.get(i);</span>
<span class="fc" id="L152">      columns[i] = column;</span>
<span class="fc" id="L153">      DataSourceMetadata columnMetadata = indexSegment.getDataSource(column).getDataSourceMetadata();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">      if (columnMetadata.isSingleValue()) {</span>
<span class="fc" id="L155">        dataTypes[i] = columnMetadata.getDataType();</span>
      } else {
<span class="fc" id="L157">        dataTypes[i] = columnMetadata.getDataType().toMultiValue();</span>
      }
    }

<span class="fc" id="L161">    return new DataSchema(columns, dataTypes);</span>
  }

  /**
   * Expand &lt;code&gt;'SELECT *'&lt;/code&gt; to select all columns with {@link DataSchema}, order all columns alphabatically.
   * (Inter segment)
   *
   * @param selectionColumns unexpanded selection columns (may contain '*').
   * @param dataSchema data schema.
   * @return expanded selection columns.
   */
  @Nonnull
  public static List&lt;String&gt; getSelectionColumns(@Nonnull List&lt;String&gt; selectionColumns,
      @Nonnull DataSchema dataSchema) {
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">    if ((selectionColumns.size() == 1) &amp;&amp; selectionColumns.get(0).equals(&quot;*&quot;)) {</span>
<span class="fc" id="L176">      int numColumns = dataSchema.size();</span>
<span class="fc" id="L177">      List&lt;String&gt; allColumns = new ArrayList&lt;&gt;(numColumns);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">      for (int i = 0; i &lt; numColumns; i++) {</span>
<span class="fc" id="L179">        allColumns.add(dataSchema.getColumnName(i));</span>
      }
<span class="fc" id="L181">      Collections.sort(allColumns);</span>
<span class="fc" id="L182">      return allColumns;</span>
    } else {
<span class="fc" id="L184">      return selectionColumns;</span>
    }
  }

  /**
   * Merge two partial results for selection queries without &lt;code&gt;ORDER BY&lt;/code&gt;. (Server side)
   *
   * @param mergedRows partial results 1.
   * @param rowsToMerge partial results 2.
   * @param selectionSize size of the selection.
   */
  public static void mergeWithoutOrdering(@Nonnull Collection&lt;Serializable[]&gt; mergedRows,
      @Nonnull Collection&lt;Serializable[]&gt; rowsToMerge, int selectionSize) {
<span class="fc" id="L197">    Iterator&lt;Serializable[]&gt; iterator = rowsToMerge.iterator();</span>
<span class="pc bpc" id="L198" title="1 of 4 branches missed.">    while (mergedRows.size() &lt; selectionSize &amp;&amp; iterator.hasNext()) {</span>
<span class="fc" id="L199">      mergedRows.add(iterator.next());</span>
    }
<span class="fc" id="L201">  }</span>

  /**
   * Merge two partial results for selection queries with &lt;code&gt;ORDER BY&lt;/code&gt;. (Server side)
   *
   * @param mergedRows partial results 1.
   * @param rowsToMerge partial results 2.
   * @param maxNumRows maximum number of rows need to be stored.
   */
  public static void mergeWithOrdering(@Nonnull PriorityQueue&lt;Serializable[]&gt; mergedRows,
      @Nonnull Collection&lt;Serializable[]&gt; rowsToMerge, int maxNumRows) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">    for (Serializable[] row : rowsToMerge) {</span>
<span class="fc" id="L213">      addToPriorityQueue(row, mergedRows, maxNumRows);</span>
<span class="fc" id="L214">    }</span>
<span class="fc" id="L215">  }</span>

  /**
   * Build a {@link DataTable} from a {@link Collection} of selection rows with {@link DataSchema}. (Server side)
   * &lt;p&gt;The passed in data schema stored the column data type that can cover all actual data types for that column.
   * &lt;p&gt;The actual data types for each column in rows can be different but must be compatible with each other.
   * &lt;p&gt;Before write each row into the data table, first convert it to match the data types in data schema.
   *
   * @param rows {@link Collection} of selection rows.
   * @param dataSchema data schema.
   * @return data table.
   * @throws Exception
   */
  @Nonnull
  public static DataTable getDataTableFromRows(@Nonnull Collection&lt;Serializable[]&gt; rows, @Nonnull DataSchema dataSchema)
      throws Exception {
<span class="fc" id="L231">    int numColumns = dataSchema.size();</span>

<span class="fc" id="L233">    DataTableBuilder dataTableBuilder = new DataTableBuilder(dataSchema);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">    for (Serializable[] row : rows) {</span>
<span class="fc" id="L235">      dataTableBuilder.startRow();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      for (int i = 0; i &lt; numColumns; i++) {</span>
<span class="fc" id="L237">        Serializable columnValue = row[i];</span>
<span class="fc" id="L238">        DataType columnType = dataSchema.getColumnType(i);</span>
<span class="pc bpc" id="L239" title="5 of 11 branches missed.">        switch (columnType) {</span>
          // Single-value column.
          case INT:
<span class="nc" id="L242">            dataTableBuilder.setColumn(i, ((Number) columnValue).intValue());</span>
<span class="nc" id="L243">            break;</span>
          case LONG:
<span class="fc" id="L245">            dataTableBuilder.setColumn(i, ((Number) columnValue).longValue());</span>
<span class="fc" id="L246">            break;</span>
          case FLOAT:
<span class="nc" id="L248">            dataTableBuilder.setColumn(i, ((Number) columnValue).floatValue());</span>
<span class="nc" id="L249">            break;</span>
          case DOUBLE:
<span class="fc" id="L251">            dataTableBuilder.setColumn(i, ((Number) columnValue).doubleValue());</span>
<span class="fc" id="L252">            break;</span>
          case STRING:
<span class="fc" id="L254">            dataTableBuilder.setColumn(i, ((String) columnValue));</span>
<span class="fc" id="L255">            break;</span>

          // Multi-value column.
          case INT_ARRAY:
<span class="nc" id="L259">            dataTableBuilder.setColumn(i, (int[]) columnValue);</span>
<span class="nc" id="L260">            break;</span>
          case LONG_ARRAY:
            // LONG_ARRAY type covers INT_ARRAY and LONG_ARRAY.
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (columnValue instanceof int[]) {</span>
<span class="fc" id="L264">              int[] ints = (int[]) columnValue;</span>
<span class="fc" id="L265">              int length = ints.length;</span>
<span class="fc" id="L266">              long[] longs = new long[length];</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">              for (int j = 0; j &lt; length; j++) {</span>
<span class="fc" id="L268">                longs[j] = ints[j];</span>
              }
<span class="fc" id="L270">              dataTableBuilder.setColumn(i, longs);</span>
<span class="fc" id="L271">            } else {</span>
<span class="fc" id="L272">              dataTableBuilder.setColumn(i, (long[]) columnValue);</span>
            }
<span class="fc" id="L274">            break;</span>
          case FLOAT_ARRAY:
<span class="nc" id="L276">            dataTableBuilder.setColumn(i, (float[]) columnValue);</span>
<span class="nc" id="L277">            break;</span>
          case DOUBLE_ARRAY:
            // DOUBLE_ARRAY type covers INT_ARRAY, LONG_ARRAY, FLOAT_ARRAY and DOUBLE_ARRAY.
<span class="fc bfc" id="L280" title="All 2 branches covered.">            if (columnValue instanceof int[]) {</span>
<span class="fc" id="L281">              int[] ints = (int[]) columnValue;</span>
<span class="fc" id="L282">              int length = ints.length;</span>
<span class="fc" id="L283">              double[] doubles = new double[length];</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">              for (int j = 0; j &lt; length; j++) {</span>
<span class="fc" id="L285">                doubles[j] = ints[j];</span>
              }
<span class="fc" id="L287">              dataTableBuilder.setColumn(i, doubles);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            } else if (columnValue instanceof long[]) {</span>
<span class="fc" id="L289">              long[] longs = (long[]) columnValue;</span>
<span class="fc" id="L290">              int length = longs.length;</span>
<span class="fc" id="L291">              double[] doubles = new double[length];</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">              for (int j = 0; j &lt; length; j++) {</span>
<span class="fc" id="L293">                doubles[j] = longs[j];</span>
              }
<span class="fc" id="L295">              dataTableBuilder.setColumn(i, doubles);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            } else if (columnValue instanceof float[]) {</span>
<span class="fc" id="L297">              float[] floats = (float[]) columnValue;</span>
<span class="fc" id="L298">              int length = floats.length;</span>
<span class="fc" id="L299">              double[] doubles = new double[length];</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">              for (int j = 0; j &lt; length; j++) {</span>
<span class="fc" id="L301">                doubles[j] = floats[j];</span>
              }
<span class="fc" id="L303">              dataTableBuilder.setColumn(i, doubles);</span>
<span class="fc" id="L304">            } else {</span>
<span class="fc" id="L305">              dataTableBuilder.setColumn(i, (double[]) columnValue);</span>
            }
<span class="fc" id="L307">            break;</span>
          case STRING_ARRAY:
<span class="fc" id="L309">            dataTableBuilder.setColumn(i, (String[]) columnValue);</span>
<span class="fc" id="L310">            break;</span>

          default:
<span class="nc" id="L313">            throw new UnsupportedOperationException(</span>
                &quot;Unsupported data type: &quot; + columnType + &quot; for column: &quot; + dataSchema.getColumnName(i));
        }
      }
<span class="fc" id="L317">      dataTableBuilder.finishRow();</span>
<span class="fc" id="L318">    }</span>

<span class="fc" id="L320">    return dataTableBuilder.build();</span>
  }

  /**
   * Extract a selection row from {@link DataTable}. (Broker side)
   *
   * @param dataTable data table.
   * @param rowId row id.
   * @return selection row.
   */
  @Nonnull
  public static Serializable[] extractRowFromDataTable(@Nonnull DataTable dataTable, int rowId) {
<span class="fc" id="L332">    DataSchema dataSchema = dataTable.getDataSchema();</span>
<span class="fc" id="L333">    int numColumns = dataSchema.size();</span>

<span class="fc" id="L335">    Serializable[] row = new Serializable[numColumns];</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">    for (int i = 0; i &lt; numColumns; i++) {</span>
<span class="fc" id="L337">      DataType columnType = dataSchema.getColumnType(i);</span>
<span class="pc bpc" id="L338" title="5 of 11 branches missed.">      switch (columnType) {</span>
        // Single-value column.
        case INT:
<span class="nc" id="L341">          row[i] = dataTable.getInt(rowId, i);</span>
<span class="nc" id="L342">          break;</span>
        case LONG:
<span class="fc" id="L344">          row[i] = dataTable.getLong(rowId, i);</span>
<span class="fc" id="L345">          break;</span>
        case FLOAT:
<span class="nc" id="L347">          row[i] = dataTable.getFloat(rowId, i);</span>
<span class="nc" id="L348">          break;</span>
        case DOUBLE:
<span class="fc" id="L350">          row[i] = dataTable.getDouble(rowId, i);</span>
<span class="fc" id="L351">          break;</span>
        case STRING:
<span class="fc" id="L353">          row[i] = dataTable.getString(rowId, i);</span>
<span class="fc" id="L354">          break;</span>

        // Multi-value column.
        case INT_ARRAY:
<span class="nc" id="L358">          row[i] = dataTable.getIntArray(rowId, i);</span>
<span class="nc" id="L359">          break;</span>
        case LONG_ARRAY:
<span class="fc" id="L361">          row[i] = dataTable.getLongArray(rowId, i);</span>
<span class="fc" id="L362">          break;</span>
        case FLOAT_ARRAY:
<span class="nc" id="L364">          row[i] = dataTable.getFloatArray(rowId, i);</span>
<span class="nc" id="L365">          break;</span>
        case DOUBLE_ARRAY:
<span class="fc" id="L367">          row[i] = dataTable.getDoubleArray(rowId, i);</span>
<span class="fc" id="L368">          break;</span>
        case STRING_ARRAY:
<span class="fc" id="L370">          row[i] = dataTable.getStringArray(rowId, i);</span>
<span class="fc" id="L371">          break;</span>

        default:
<span class="nc" id="L374">          throw new UnsupportedOperationException(</span>
              &quot;Unsupported data type: &quot; + columnType + &quot; for column: &quot; + dataSchema.getColumnName(i));
      }
    }

<span class="fc" id="L379">    return row;</span>
  }

  /**
   * Reduce a collection of {@link DataTable}s to selection rows for selection queries without &lt;code&gt;ORDER BY&lt;/code&gt;.
   * (Broker side)
   *
   * @param selectionResults {@link Map} from {@link ServerInstance} to {@link DataTable}.
   * @param selectionSize size of the selection.
   * @return reduced results.
   */
  @Nonnull
  public static List&lt;Serializable[]&gt; reduceWithoutOrdering(@Nonnull Map&lt;ServerInstance, DataTable&gt; selectionResults,
      int selectionSize) {
<span class="nc" id="L393">    List&lt;Serializable[]&gt; rows = new ArrayList&lt;&gt;(selectionSize);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">    for (DataTable dataTable : selectionResults.values()) {</span>
<span class="nc" id="L395">      int numRows = dataTable.getNumberOfRows();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">      for (int rowId = 0; rowId &lt; numRows; rowId++) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (rows.size() &lt; selectionSize) {</span>
<span class="nc" id="L398">          rows.add(extractRowFromDataTable(dataTable, rowId));</span>
        } else {
<span class="nc" id="L400">          return rows;</span>
        }
      }
<span class="nc" id="L403">    }</span>
<span class="nc" id="L404">    return rows;</span>
  }

  /**
   * Render the unformatted selection rows to a formatted {@link SelectionResults} object for selection queries without
   * &lt;code&gt;ORDER BY&lt;/code&gt;. (Broker side)
   * &lt;p&gt;{@link SelectionResults} object will be used to build the broker response.
   * &lt;p&gt;Should be called after method &quot;reduceWithoutOrdering()&quot;.
   *
   * @param rows unformatted selection rows.
   * @param dataSchema data schema.
   * @param selectionColumns selection columns.
   * @return {@link SelectionResults} object results.
   */
  @Nonnull
  public static SelectionResults renderSelectionResultsWithoutOrdering(@Nonnull List&lt;Serializable[]&gt; rows,
      @Nonnull DataSchema dataSchema, @Nonnull List&lt;String&gt; selectionColumns) {
    // TODO: remove the code for backward compatible after server updated to the latest code.
<span class="fc" id="L422">    int numSelectionColumns = selectionColumns.size();</span>
<span class="fc" id="L423">    int[] columnIndices = new int[numSelectionColumns];</span>
<span class="fc" id="L424">    Map&lt;String, Integer&gt; dataSchemaIndices = new HashMap&lt;&gt;(numSelectionColumns);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">    for (int i = 0; i &lt; numSelectionColumns; i++) {</span>
<span class="fc" id="L426">      dataSchemaIndices.put(dataSchema.getColumnName(i), i);</span>
    }
<span class="fc bfc" id="L428" title="All 2 branches covered.">    for (int i = 0; i &lt; numSelectionColumns; i++) {</span>
<span class="fc" id="L429">      columnIndices[i] = dataSchemaIndices.get(selectionColumns.get(i));</span>
    }
<span class="fc" id="L431">    int numRows = rows.size();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">    for (int i = 0; i &lt; numRows; i++) {</span>
<span class="fc" id="L433">      rows.set(i, getFormattedRowWithoutOrdering(rows.get(i), dataSchema, columnIndices));</span>
    }

    /* TODO: uncomment after server updated to the latest code.
    for (Serializable[] row : rows) {
      formatRowWithoutOrdering(row, dataSchema);
    }*/
<span class="fc" id="L440">    return new SelectionResults(selectionColumns, rows);</span>
  }

  /**
   * Helper method to format a selection row, make all values string or string array type based on data schema passed in
   * for selection queries without &lt;code&gt;ORDER BY&lt;/code&gt;. (Broker side)
   * &lt;p&gt;Formatted row is used to build the {@link SelectionResults}.
   *
   * @param row selection row to be formatted.
   * @param dataSchema data schema.
   */
  private static void formatRowWithoutOrdering(@Nonnull Serializable[] row, @Nonnull DataSchema dataSchema) {
<span class="nc" id="L452">    int numColumns = row.length;</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">    for (int i = 0; i &lt; numColumns; i++) {</span>
<span class="nc" id="L454">      row[i] = getFormattedValue(row[i], dataSchema.getColumnType(i));</span>
    }
<span class="nc" id="L456">  }</span>

  // TODO: remove this method after server updated to the latest code.
  private static Serializable[] getFormattedRowWithoutOrdering(@Nonnull Serializable[] row,
      @Nonnull DataSchema dataSchema, @Nonnull int[] columnIndices) {
<span class="fc" id="L461">    int numColumns = columnIndices.length;</span>
<span class="fc" id="L462">    Serializable[] formattedRow = new Serializable[numColumns];</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">    for (int i = 0; i &lt; numColumns; i++) {</span>
<span class="fc" id="L464">      int columnIndex = columnIndices[i];</span>
<span class="fc" id="L465">      formattedRow[i] =</span>
          SelectionOperatorUtils.getFormattedValue(row[columnIndex], dataSchema.getColumnType(columnIndex));
    }
<span class="fc" id="L468">    return formattedRow;</span>
  }

  /**
   * Format a {@link Serializable} value into a {@link String} or {@link String} array based on the data type.
   * (Broker side)
   * &lt;p&gt;Actual value type can be different with data type passed in, but they must be type compatible.
   *
   * @param value value to be formatted.
   * @param dataType data type.
   * @return formatted value.
   */
  @Nonnull
  public static Serializable getFormattedValue(@Nonnull Serializable value, @Nonnull DataType dataType) {
<span class="pc bpc" id="L482" title="4 of 9 branches missed.">    switch (dataType) {</span>
      // Single-value column.
      case INT:
<span class="nc" id="L485">        return INT_FORMAT.format(((Number) value).intValue());</span>
      case LONG:
<span class="fc" id="L487">        return LONG_FORMAT.format(((Number) value).longValue());</span>
      case FLOAT:
<span class="nc" id="L489">        return FLOAT_FORMAT.format(((Number) value).floatValue());</span>
      case DOUBLE:
<span class="fc" id="L491">        return DOUBLE_FORMAT.format(((Number) value).doubleValue());</span>

      // Multi-value column.
      case INT_ARRAY:
<span class="nc" id="L495">        int[] ints = (int[]) value;</span>
<span class="nc" id="L496">        int length = ints.length;</span>
<span class="nc" id="L497">        String[] formattedValue = new String[length];</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L499">          formattedValue[i] = INT_FORMAT.format(ints[i]);</span>
        }
<span class="nc" id="L501">        return formattedValue;</span>
      case LONG_ARRAY:
        // LONG_ARRAY type covers INT_ARRAY and LONG_ARRAY.
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (value instanceof int[]) {</span>
<span class="fc" id="L505">          ints = (int[]) value;</span>
<span class="fc" id="L506">          length = ints.length;</span>
<span class="fc" id="L507">          formattedValue = new String[length];</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">          for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L509">            formattedValue[i] = LONG_FORMAT.format(ints[i]);</span>
          }
        } else {
<span class="fc" id="L512">          long[] longs = (long[]) value;</span>
<span class="fc" id="L513">          length = longs.length;</span>
<span class="fc" id="L514">          formattedValue = new String[length];</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">          for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L516">            formattedValue[i] = LONG_FORMAT.format(longs[i]);</span>
          }
        }
<span class="fc" id="L519">        return formattedValue;</span>
      case FLOAT_ARRAY:
<span class="nc" id="L521">        float[] floats = (float[]) value;</span>
<span class="nc" id="L522">        length = floats.length;</span>
<span class="nc" id="L523">        formattedValue = new String[length];</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L525">          formattedValue[i] = FLOAT_FORMAT.format(floats[i]);</span>
        }
<span class="nc" id="L527">        return formattedValue;</span>
      case DOUBLE_ARRAY:
        // DOUBLE_ARRAY type covers INT_ARRAY, LONG_ARRAY, FLOAT_ARRAY and DOUBLE_ARRAY.
<span class="fc bfc" id="L530" title="All 2 branches covered.">        if (value instanceof int[]) {</span>
<span class="fc" id="L531">          ints = (int[]) value;</span>
<span class="fc" id="L532">          length = ints.length;</span>
<span class="fc" id="L533">          formattedValue = new String[length];</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">          for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L535">            formattedValue[i] = DOUBLE_FORMAT.format((double) ints[i]);</span>
          }
<span class="fc" id="L537">          return formattedValue;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        } else if (value instanceof long[]) {</span>
<span class="fc" id="L539">          long[] longs = (long[]) value;</span>
<span class="fc" id="L540">          length = longs.length;</span>
<span class="fc" id="L541">          formattedValue = new String[length];</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">          for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L543">            formattedValue[i] = DOUBLE_FORMAT.format((double) longs[i]);</span>
          }
<span class="fc" id="L545">          return formattedValue;</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">        } else if (value instanceof float[]) {</span>
<span class="fc" id="L547">          floats = (float[]) value;</span>
<span class="fc" id="L548">          length = floats.length;</span>
<span class="fc" id="L549">          formattedValue = new String[length];</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">          for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L551">            formattedValue[i] = DOUBLE_FORMAT.format(floats[i]);</span>
          }
<span class="fc" id="L553">          return formattedValue;</span>
        } else {
<span class="fc" id="L555">          double[] doubles = (double[]) value;</span>
<span class="fc" id="L556">          length = doubles.length;</span>
<span class="fc" id="L557">          formattedValue = new String[length];</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">          for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L559">            formattedValue[i] = DOUBLE_FORMAT.format(doubles[i]);</span>
          }
<span class="fc" id="L561">          return formattedValue;</span>
        }
      default:
        // For STRING and STRING_ARRAY, no need to format.
<span class="fc" id="L565">        return value;</span>
    }
  }

  /**
   * Helper method to add a value to a {@link PriorityQueue}.
   *
   * @param value value to be added.
   * @param queue priority queue.
   * @param maxNumValues maximum number of values in the priority queue.
   * @param &lt;T&gt; type for the value.
   */
  public static &lt;T&gt; void addToPriorityQueue(@Nonnull T value, @Nonnull PriorityQueue&lt;T&gt; queue, int maxNumValues) {
<span class="fc bfc" id="L578" title="All 2 branches covered.">    if (queue.size() &lt; maxNumValues) {</span>
<span class="fc" id="L579">      queue.add(value);</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">    } else if (queue.comparator().compare(queue.peek(), value) &lt; 0) {</span>
<span class="fc" id="L581">      queue.poll();</span>
<span class="fc" id="L582">      queue.offer(value);</span>
    }
<span class="fc" id="L584">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>