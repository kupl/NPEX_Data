<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TarGzCompressionUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-common</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.common.utils</a> &gt; <span class="el_source">TarGzCompressionUtils.java</span></div><h1>TarGzCompressionUtils.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.common.utils;

import com.linkedin.pinot.common.Utils;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.LinkedList;
import java.util.List;

import org.apache.commons.compress.archivers.ArchiveException;
import org.apache.commons.compress.archivers.ArchiveStreamFactory;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Taken from http://www.thoughtspark.org/node/53
 *
 */
<span class="nc" id="L50">public class TarGzCompressionUtils {</span>
<span class="fc" id="L51">  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);</span>
  public static final String TAR_GZ_FILE_EXTENTION = &quot;.tar.gz&quot;;

  /**
   * Creates a tar.gz file at the specified path with the contents of the
   * specified directory.
   *
   * @param directoryPath
   *          The path to the directory to create an archive of
   * @param tarGzPath
   *          The path to the archive to create. The file may not exist but
   *          it's parent must exist and the parent must be a directory
   * @return tarGzPath
   * @throws IOException
   *           If anything goes wrong
   */
  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)
      throws IOException {
<span class="fc" id="L69">    return createTarGzOfDirectory(directoryPath, tarGzPath, &quot;&quot;);</span>
  }

  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix) throws IOException {
<span class="fc" id="L73">    FileOutputStream fOut = null;</span>
<span class="fc" id="L74">    BufferedOutputStream bOut = null;</span>
<span class="fc" id="L75">    GzipCompressorOutputStream gzOut = null;</span>
<span class="fc" id="L76">    TarArchiveOutputStream tOut = null;</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENTION)) {</span>
<span class="nc" id="L78">      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENTION;</span>
    }

    try {
<span class="fc" id="L82">      fOut = new FileOutputStream(new File(tarGzPath));</span>
<span class="fc" id="L83">      bOut = new BufferedOutputStream(fOut);</span>
<span class="fc" id="L84">      gzOut = new GzipCompressorOutputStream(bOut);</span>
<span class="fc" id="L85">      tOut = new TarArchiveOutputStream(gzOut);</span>
<span class="fc" id="L86">      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);</span>
<span class="fc" id="L87">      addFileToTarGz(tOut, directoryPath, entryPrefix);</span>
<span class="nc" id="L88">    } catch (IOException e) {</span>
<span class="nc" id="L89">      LOGGER.error(&quot;Failed to create tar.gz file for {} at path: {}&quot;, directoryPath, tarGzPath, e);</span>
<span class="nc" id="L90">      Utils.rethrowException(e);</span>
    } finally {
<span class="pc bpc" id="L92" title="5 of 6 branches missed.">      if (tOut != null) {</span>
<span class="pc" id="L93">        tOut.finish();</span>
<span class="pc" id="L94">        tOut.close();</span>
      }
<span class="pc bpc" id="L96" title="5 of 6 branches missed.">      if (gzOut != null) {</span>
<span class="pc" id="L97">        gzOut.close();</span>
      }
<span class="pc bpc" id="L99" title="5 of 6 branches missed.">      if (bOut != null) {</span>
<span class="pc" id="L100">        bOut.close();</span>
      }
<span class="pc bpc" id="L102" title="5 of 6 branches missed.">      if (fOut != null) {</span>
<span class="pc" id="L103">        fOut.close();</span>
      }
    }
<span class="fc" id="L106">    return tarGzPath;</span>
  }

  public static String createTarGzOfDirectory(String directoryPath) throws IOException {
<span class="nc" id="L110">    String tarGzPath = directoryPath.substring(0);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    while (tarGzPath.endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L112">      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);</span>
    }
<span class="nc" id="L114">    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENTION;</span>
<span class="nc" id="L115">    return createTarGzOfDirectory(directoryPath, tarGzPath);</span>
  }

  /**
   * Creates a tar entry for the path specified with a name built from the base
   * passed in and the file/directory name. If the path is a directory, a
   * recursive call is made such that the full directory is added to the tar.
   *
   * @param tOut
   *          The tar file's output stream
   * @param path
   *          The filesystem path of the file/directory being added
   * @param base
   *          The base prefix to for the name of the tar file entry
   *
   * @throws IOException
   *           If anything goes wrong
   */
  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base) throws IOException {
<span class="fc" id="L134">    File f = new File(path);</span>
<span class="fc" id="L135">    String entryName = base + f.getName();</span>
<span class="fc" id="L136">    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);</span>

<span class="fc" id="L138">    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);</span>
<span class="fc" id="L139">    tOut.putArchiveEntry(tarEntry);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (f.isFile()) {</span>
<span class="fc" id="L142">      IOUtils.copy(new FileInputStream(f), tOut);</span>

<span class="fc" id="L144">      tOut.closeArchiveEntry();</span>
    } else {
<span class="fc" id="L146">      tOut.closeArchiveEntry();</span>

<span class="fc" id="L148">      File[] children = f.listFiles();</span>

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">      if (children != null) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (File child : children) {</span>
<span class="fc" id="L152">          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + &quot;/&quot;);</span>
        }
      }
    }
<span class="fc" id="L156">  }</span>

  /** Untar an input file into an output file.

   * The output file is created in the output folder, having the same name
   * as the input file, minus the '.tar' extension.
   *
   * @param inputFile     the input .tar file
   * @param outputDir     the output directory file.
   * @throws IOException
   * @throws FileNotFoundException
   *
   * @return  The {@link List} of {@link File}s with the untared content.
   * @throws ArchiveException
   */
  public static List&lt;File&gt; unTar(final File inputFile, final File outputDir) throws FileNotFoundException, IOException,
      ArchiveException {

<span class="fc" id="L174">    LOGGER.debug(String.format(&quot;Untaring %s to dir %s.&quot;, inputFile.getAbsolutePath(), outputDir.getAbsolutePath()));</span>
<span class="fc" id="L175">    TarArchiveInputStream debInputStream = null;</span>
<span class="fc" id="L176">    InputStream is = null;</span>
<span class="fc" id="L177">    final List&lt;File&gt; untaredFiles = new LinkedList&lt;File&gt;();</span>
    try {
<span class="fc" id="L179">      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));</span>
<span class="fc" id="L180">      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(&quot;tar&quot;, is);</span>
<span class="fc" id="L181">      TarArchiveEntry entry = null;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {</span>
<span class="fc" id="L183">        final File outputFile = new File(outputDir, entry.getName());</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (entry.isDirectory()) {</span>
<span class="fc" id="L185">          LOGGER.debug(String.format(&quot;Attempting to write output directory %s.&quot;, outputFile.getAbsolutePath()));</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">          if (!outputFile.exists()) {</span>
<span class="fc" id="L187">            LOGGER.debug(String.format(&quot;Attempting to create output directory %s.&quot;, outputFile.getAbsolutePath()));</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if (!outputFile.mkdirs()) {</span>
<span class="nc" id="L189">              throw new IllegalStateException(String.format(&quot;Couldn't create directory %s.&quot;,</span>
                  outputFile.getAbsolutePath()));
            }
          } else {
<span class="nc" id="L193">            LOGGER.error(&quot;The directory already there. Deleting - &quot; + outputFile.getAbsolutePath());</span>
<span class="nc" id="L194">            FileUtils.deleteDirectory(outputFile);</span>
          }
        } else {
<span class="fc" id="L197">          LOGGER.debug(String.format(&quot;Creating output file %s.&quot;, outputFile.getAbsolutePath()));</span>
<span class="fc" id="L198">          File directory = outputFile.getParentFile();</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">          if (!directory.exists()) {</span>
<span class="nc" id="L200">            directory.mkdirs();</span>
          }
<span class="fc" id="L202">          OutputStream outputFileStream = null;</span>
          try {
<span class="fc" id="L204">            outputFileStream = new FileOutputStream(outputFile);</span>
<span class="fc" id="L205">            IOUtils.copy(debInputStream, outputFileStream);</span>
          } finally {
<span class="pc" id="L207">            IOUtils.closeQuietly(outputFileStream);</span>
<span class="fc" id="L208">          }</span>
        }
<span class="fc" id="L210">        untaredFiles.add(outputFile);</span>
<span class="fc" id="L211">      }</span>
    } finally {
<span class="pc" id="L213">      IOUtils.closeQuietly(debInputStream);</span>
<span class="pc" id="L214">      IOUtils.closeQuietly(is);</span>
<span class="fc" id="L215">    }</span>
<span class="fc" id="L216">    return untaredFiles;</span>
  }

  public static InputStream unTarOneFile(InputStream tarGzInputStream, final String filename)
      throws FileNotFoundException, IOException, ArchiveException {
<span class="nc" id="L221">    TarArchiveInputStream debInputStream = null;</span>
<span class="nc" id="L222">    InputStream is = null;</span>
    try {
<span class="nc" id="L224">      is = new GzipCompressorInputStream(tarGzInputStream);</span>
<span class="nc" id="L225">      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(&quot;tar&quot;, is);</span>
<span class="nc" id="L226">      TarArchiveEntry entry = null;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (entry.getName().contains(filename)) {</span>
<span class="nc" id="L229">          ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span>
<span class="nc" id="L230">          IOUtils.copy(debInputStream, byteArrayOutputStream);</span>
<span class="nc" id="L231">          return new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span>
        }
      }
    } finally {
<span class="nc" id="L235">      IOUtils.closeQuietly(debInputStream);</span>
<span class="nc" id="L236">      IOUtils.closeQuietly(is);</span>
<span class="nc" id="L237">    }</span>
<span class="nc" id="L238">    return null;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>