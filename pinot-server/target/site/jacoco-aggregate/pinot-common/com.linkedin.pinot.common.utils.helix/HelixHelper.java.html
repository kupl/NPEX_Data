<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HelixHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">pinot-server</a> &gt; <a href="../index.html" class="el_bundle">pinot-common</a> &gt; <a href="index.source.html" class="el_package">com.linkedin.pinot.common.utils.helix</a> &gt; <span class="el_source">HelixHelper.java</span></div><h1>HelixHelper.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2014-2016 LinkedIn Corp. (pinot-core@linkedin.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.linkedin.pinot.common.utils.helix;

import com.google.common.base.Function;
import com.linkedin.pinot.common.utils.CommonConstants;
import com.linkedin.pinot.common.utils.EqualityUtils;
import com.linkedin.pinot.common.utils.retry.RetryPolicies;
import com.linkedin.pinot.common.utils.retry.RetryPolicy;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import javax.annotation.Nullable;
import org.I0Itec.zkclient.exception.ZkBadVersionException;
import org.apache.helix.AccessOption;
import org.apache.helix.HelixAdmin;
import org.apache.helix.HelixDataAccessor;
import org.apache.helix.HelixManager;
import org.apache.helix.PropertyKey;
import org.apache.helix.PropertyKey.Builder;
import org.apache.helix.ZNRecord;
import org.apache.helix.manager.zk.ZNRecordSerializer;
import org.apache.helix.model.ExternalView;
import org.apache.helix.model.HelixConfigScope;
import org.apache.helix.model.HelixConfigScope.ConfigScopeProperty;
import org.apache.helix.model.IdealState;
import org.apache.helix.model.InstanceConfig;
import org.apache.helix.model.builder.HelixConfigScopeBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


<span class="nc" id="L49">public class HelixHelper {</span>
<span class="nc" id="L50">  private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);</span>
<span class="nc" id="L51">  private static final Logger LOGGER = LoggerFactory.getLogger(HelixHelper.class);</span>
  private static final int MAX_PARTITION_COUNT_IN_UNCOMPRESSED_IDEAL_STATE = 1000;

  private static final String ONLINE = &quot;ONLINE&quot;;
  private static final String OFFLINE = &quot;OFFLINE&quot;;

  public static final String BROKER_RESOURCE = CommonConstants.Helix.BROKER_RESOURCE_INSTANCE;

  /**
   * Updates the ideal state, retrying if necessary in case of concurrent updates to the ideal state.
   *
   * @param helixManager The HelixManager used to interact with the Helix cluster
   * @param resourceName The resource for which to update the ideal state
   * @param updater A function that returns an updated ideal state given an input ideal state
   */
  // TODO: since updater always update ideal state in place, it should return boolean indicating whether the ideal state get changed.
  public static void updateIdealState(final HelixManager helixManager, final String resourceName,
      final Function&lt;IdealState, IdealState&gt; updater, RetryPolicy policy) {
    try {
<span class="nc" id="L70">      policy.attempt(new Callable&lt;Boolean&gt;() {</span>
        @Override
        public Boolean call() {
<span class="nc" id="L73">          HelixDataAccessor dataAccessor = helixManager.getHelixDataAccessor();</span>
<span class="nc" id="L74">          PropertyKey idealStateKey = dataAccessor.keyBuilder().idealStates(resourceName);</span>
<span class="nc" id="L75">          IdealState idealState = dataAccessor.getProperty(idealStateKey);</span>

          // Make a copy of the the idealState above to pass it to the updater
          // NOTE: new IdealState(idealState.getRecord()) does not work because it's shallow copy for map fields and
          // list fields
<span class="nc" id="L80">          ZNRecordSerializer znRecordSerializer = new ZNRecordSerializer();</span>
<span class="nc" id="L81">          IdealState idealStateCopy = new IdealState(</span>
              (ZNRecord) znRecordSerializer.deserialize(znRecordSerializer.serialize(idealState.getRecord())));

          IdealState updatedIdealState;
          try {
<span class="nc" id="L86">            updatedIdealState = updater.apply(idealStateCopy);</span>
<span class="nc" id="L87">          } catch (Exception e) {</span>
<span class="nc" id="L88">            LOGGER.error(&quot;Caught exception while updating ideal state for resource: {}&quot;, resourceName, e);</span>
<span class="nc" id="L89">            return false;</span>
<span class="nc" id="L90">          }</span>

          // If there are changes to apply, apply them
<span class="nc bnc" id="L93" title="All 4 branches missed.">          if (!EqualityUtils.isEqual(idealState, updatedIdealState) &amp;&amp; updatedIdealState != null) {</span>

            // If the ideal state is large enough, enable compression
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (MAX_PARTITION_COUNT_IN_UNCOMPRESSED_IDEAL_STATE &lt; updatedIdealState.getPartitionSet().size()) {</span>
<span class="nc" id="L97">              updatedIdealState.getRecord().setBooleanField(&quot;enableCompression&quot;, true);</span>
            }

            // Check version and set ideal state
            try {
<span class="nc bnc" id="L102" title="All 2 branches missed.">              if (dataAccessor.getBaseDataAccessor()</span>
                  .set(idealStateKey.getPath(), updatedIdealState.getRecord(), idealState.getRecord().getVersion(),
                      AccessOption.PERSISTENT)) {
<span class="nc" id="L105">                return true;</span>
              } else {
<span class="nc" id="L107">                LOGGER.warn(&quot;Failed to update ideal state for resource: {}&quot;, resourceName);</span>
<span class="nc" id="L108">                return false;</span>
              }
<span class="nc" id="L110">            } catch (ZkBadVersionException e) {</span>
<span class="nc" id="L111">              LOGGER.warn(&quot;Version changed while updating ideal state for resource: {}&quot;, resourceName);</span>
<span class="nc" id="L112">              return false;</span>
<span class="nc" id="L113">            } catch (Exception e) {</span>
<span class="nc" id="L114">              boolean idealStateIsCompressed =</span>
                  updatedIdealState.getRecord().getBooleanField(&quot;enableCompression&quot;, false);
<span class="nc" id="L116">              LOGGER.warn(&quot;Caught exception while updating ideal state for resource: {} (compressed={})&quot;, resourceName,</span>
                  idealStateIsCompressed, e);
<span class="nc" id="L118">              return false;</span>
            }
          } else {
<span class="nc" id="L121">            LOGGER.warn(&quot;Idempotent or null ideal state update for resource {}, skipping update.&quot;, resourceName);</span>
<span class="nc" id="L122">            return true;</span>
          }
        }
      });
<span class="nc" id="L126">    } catch (Exception e) {</span>
<span class="nc" id="L127">      throw new RuntimeException(&quot;Caught exception while updating ideal state for resource: &quot; + resourceName, e);</span>
<span class="nc" id="L128">    }</span>
<span class="nc" id="L129">  }</span>

  /**
   * Returns all instances for the given cluster.
   *
   * @param helixAdmin The HelixAdmin object used to interact with the Helix cluster
   * @param clusterName Name of the cluster for which to get all the instances for.
   * @return Returns a List of strings containing the instance names for the given cluster.
   */
  public static List&lt;String&gt; getAllInstances(HelixAdmin helixAdmin, String clusterName) {
<span class="nc" id="L139">    return helixAdmin.getInstancesInCluster(clusterName);</span>
  }

  /**
   * Returns all instances for the given resource.
   *
   * @param idealState IdealState of the resource for which to return the instances of.
   * @return Returns a Set of strings containing the instance names for the given cluster.
   */
  public static Set&lt;String&gt; getAllInstancesForResource(IdealState idealState) {
<span class="nc" id="L149">    final Set&lt;String&gt; instances = new HashSet&lt;String&gt;();</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">    for (final String partition : idealState.getPartitionSet()) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">      for (final String instance : idealState.getInstanceSet(partition)) {</span>
<span class="nc" id="L153">        instances.add(instance);</span>
<span class="nc" id="L154">      }</span>
<span class="nc" id="L155">    }</span>
<span class="nc" id="L156">    return instances;</span>
  }

  /**
   * Toggle the state of the instance between OFFLINE and ONLINE.
   *
   * @param instanceName Name of the instance for which to toggle the state.
   * @param clusterName Name of the cluster to which the instance belongs.
   * @param admin HelixAdmin to access the cluster.
   * @param enable Set enable to true for ONLINE and FALSE for OFFLINE.
   */
  public static void setInstanceState(String instanceName, String clusterName, HelixAdmin admin, boolean enable) {
<span class="nc" id="L168">    admin.enableInstance(clusterName, instanceName, enable);</span>
<span class="nc" id="L169">  }</span>

  public static void setStateForInstanceList(List&lt;String&gt; instances, String clusterName, HelixAdmin admin,
      boolean enable) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">    for (final String instance : instances) {</span>
<span class="nc" id="L174">      setInstanceState(instance, clusterName, admin, enable);</span>
<span class="nc" id="L175">    }</span>
<span class="nc" id="L176">  }</span>

  public static void setStateForInstanceSet(Set&lt;String&gt; instances, String clusterName, HelixAdmin admin, boolean enable) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">    for (final String instanceName : instances) {</span>
<span class="nc" id="L180">      setInstanceState(instanceName, clusterName, admin, enable);</span>
<span class="nc" id="L181">    }</span>
<span class="nc" id="L182">  }</span>

  public static Map&lt;String, String&gt; getInstanceConfigsMapFor(String instanceName, String clusterName, HelixAdmin admin) {
<span class="nc" id="L185">    final HelixConfigScope scope = getInstanceScopefor(clusterName, instanceName);</span>
<span class="nc" id="L186">    final List&lt;String&gt; keys = admin.getConfigKeys(scope);</span>
<span class="nc" id="L187">    return admin.getConfig(scope, keys);</span>
  }

  public static HelixConfigScope getInstanceScopefor(String clusterName, String instanceName) {
<span class="nc" id="L191">    return new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT, clusterName).forParticipant(instanceName)</span>
        .build();
  }

  public static HelixConfigScope getResourceScopeFor(String clusterName, String resourceName) {
<span class="nc" id="L196">    return new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE, clusterName).forResource(resourceName).build();</span>
  }

  public static Map&lt;String, String&gt; getResourceConfigsFor(String clusterName, String resourceName, HelixAdmin admin) {
<span class="nc" id="L200">    final HelixConfigScope scope = getResourceScopeFor(clusterName, resourceName);</span>
<span class="nc" id="L201">    final List&lt;String&gt; keys = admin.getConfigKeys(scope);</span>
<span class="nc" id="L202">    return admin.getConfig(scope, keys);</span>
  }

  public static void updateResourceConfigsFor(Map&lt;String, String&gt; newConfigs, String resourceName, String clusterName,
      HelixAdmin admin) {
<span class="nc" id="L207">    final HelixConfigScope scope = getResourceScopeFor(clusterName, resourceName);</span>
<span class="nc" id="L208">    admin.setConfig(scope, newConfigs);</span>
<span class="nc" id="L209">  }</span>

  public static void deleteResourcePropertyFromHelix(HelixAdmin admin, String clusterName, String resourceName,
      String configKey) {
<span class="nc" id="L213">    final List&lt;String&gt; keys = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L214">    keys.add(configKey);</span>

<span class="nc" id="L216">    final HelixConfigScope scope = getResourceScopeFor(clusterName, resourceName);</span>
<span class="nc" id="L217">    admin.removeConfig(scope, keys);</span>
<span class="nc" id="L218">  }</span>

  public static IdealState getTableIdealState(HelixManager manager, String resourceName) {
<span class="nc" id="L221">    final HelixDataAccessor accessor = manager.getHelixDataAccessor();</span>
<span class="nc" id="L222">    final Builder builder = accessor.keyBuilder();</span>
<span class="nc" id="L223">    return accessor.getProperty(builder.idealStates(resourceName));</span>
  }

  public static ExternalView getExternalViewForResource(HelixAdmin admin, String clusterName, String resourceName) {
<span class="nc" id="L227">    return admin.getResourceExternalView(clusterName, resourceName);</span>
  }

  public static Map&lt;String, String&gt; getBrokerResourceConfig(HelixAdmin admin, String clusterName) {
<span class="nc" id="L231">    return HelixHelper.getResourceConfigsFor(clusterName, BROKER_RESOURCE, admin);</span>
  }

  public static void updateBrokerConfig(Map&lt;String, String&gt; brokerResourceConfig, HelixAdmin admin, String clusterName) {
<span class="nc" id="L235">    HelixHelper.updateResourceConfigsFor(brokerResourceConfig, BROKER_RESOURCE, clusterName, admin);</span>
<span class="nc" id="L236">  }</span>

  public static IdealState getBrokerIdealStates(HelixAdmin admin, String clusterName) {
<span class="nc" id="L239">    return admin.getResourceIdealState(clusterName, BROKER_RESOURCE);</span>
  }

  /**
   * Remove a resource (offline/realtime table) from the Broker's ideal state.
   *
   * @param helixManager The HelixManager object for accessing helix cluster.
   * @param resourceTag Name of the resource that needs to be removed from Broker ideal state.
   */
  public static void removeResourceFromBrokerIdealState(HelixManager helixManager, final String resourceTag) {
<span class="nc" id="L249">    Function&lt;IdealState, IdealState&gt; updater = new Function&lt;IdealState, IdealState&gt;() {</span>
      @Override
      public IdealState apply(IdealState idealState) {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (idealState.getPartitionSet().contains(resourceTag)) {</span>
<span class="nc" id="L253">          idealState.getPartitionSet().remove(resourceTag);</span>
<span class="nc" id="L254">          return idealState;</span>
        } else {
<span class="nc" id="L256">          return null;</span>
        }
      }
    };

    // Removing partitions from ideal state
<span class="nc" id="L262">    LOGGER.info(&quot;Trying to remove resource {} from idealstate&quot;, resourceTag);</span>
<span class="nc" id="L263">    HelixHelper.updateIdealState(helixManager, CommonConstants.Helix.BROKER_RESOURCE_INSTANCE, updater,</span>
        DEFAULT_RETRY_POLICY);
<span class="nc" id="L265">  }</span>

  /**
   * Returns the set of online instances from external view.
   *
   * @param resourceExternalView External view for the resource.
   * @return Set&amp;lt;String&amp;gt; of online instances in the external view for the resource.
   */
  public static Set&lt;String&gt; getOnlineInstanceFromExternalView(ExternalView resourceExternalView) {
<span class="nc" id="L274">    Set&lt;String&gt; instanceSet = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">    if (resourceExternalView != null) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">      for (String partition : resourceExternalView.getPartitionSet()) {</span>
<span class="nc" id="L277">        Map&lt;String, String&gt; stateMap = resourceExternalView.getStateMap(partition);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (String instance : stateMap.keySet()) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">          if (stateMap.get(instance).equalsIgnoreCase(ONLINE)) {</span>
<span class="nc" id="L280">            instanceSet.add(instance);</span>
          }
<span class="nc" id="L282">        }</span>
<span class="nc" id="L283">      }</span>
    }
<span class="nc" id="L285">    return instanceSet;</span>
  }

  /**
   * Get a set of offline instance from the external view of the resource.
   *
   * @param resourceExternalView External view of the resource
   * @return Set of string instance names of the offline instances in the external view.
   */
  public static Set&lt;String&gt; getOfflineInstanceFromExternalView(ExternalView resourceExternalView) {
<span class="nc" id="L295">    Set&lt;String&gt; instanceSet = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">    for (String partition : resourceExternalView.getPartitionSet()) {</span>
<span class="nc" id="L297">      Map&lt;String, String&gt; stateMap = resourceExternalView.getStateMap(partition);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">      for (String instance : stateMap.keySet()) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (stateMap.get(instance).equalsIgnoreCase(OFFLINE)) {</span>
<span class="nc" id="L300">          instanceSet.add(instance);</span>
        }
<span class="nc" id="L302">      }</span>
<span class="nc" id="L303">    }</span>
<span class="nc" id="L304">    return instanceSet;</span>
  }

  /**
   * Remove the segment from the cluster.
   *
   * @param helixManager The HelixManager object to access the helix cluster.
   * @param tableName Name of the table to which the new segment is to be added.
   * @param segmentName Name of the new segment to be added
   */
  public static void removeSegmentFromIdealState(HelixManager helixManager, String tableName, final String segmentName) {
<span class="nc" id="L315">    Function&lt;IdealState, IdealState&gt; updater = new Function&lt;IdealState, IdealState&gt;() {</span>
      @Override
      public IdealState apply(IdealState idealState) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (idealState == null) {</span>
<span class="nc" id="L319">          return idealState;</span>
        }
        // partitionSet is never null but let's be defensive anyway
<span class="nc" id="L322">        Set&lt;String&gt; partitionSet = idealState.getPartitionSet();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (partitionSet != null) {</span>
<span class="nc" id="L324">          partitionSet.remove(segmentName);</span>
        }
<span class="nc" id="L326">        return idealState;</span>
      }
    };

<span class="nc" id="L330">    updateIdealState(helixManager, tableName, updater, DEFAULT_RETRY_POLICY);</span>
<span class="nc" id="L331">  }</span>

  public static void removeSegmentsFromIdealState(HelixManager helixManager, String tableName, final List&lt;String&gt; segments) {
<span class="nc" id="L334">    Function&lt;IdealState, IdealState&gt; updater = new Function&lt;IdealState, IdealState&gt;() {</span>
      @Nullable
      @Override
      public IdealState apply(@Nullable IdealState idealState) {
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (idealState == null) {</span>
<span class="nc" id="L339">          return idealState;</span>
        }
        // partitionSet is never null but let's be defensive anyway
<span class="nc" id="L342">        Set&lt;String&gt; partitionSet = idealState.getPartitionSet();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (partitionSet != null) {</span>
<span class="nc" id="L344">          partitionSet.removeAll(segments);</span>
        }
<span class="nc" id="L346">        return idealState;</span>
      }
    };
<span class="nc" id="L349">    updateIdealState(helixManager, tableName, updater, DEFAULT_RETRY_POLICY);</span>
<span class="nc" id="L350">  }</span>

  /**
   * Add the new specified segment to the idealState of the specified table in the specified cluster.
   *
   * @param helixManager The HelixManager object to access the helix cluster.
   * @param tableNameWithType Name of the table to which the new segment is to be added.
   * @param segmentName Name of the new segment to be added
   * @param assignedInstances List of assigned instances
   */
  public static void addSegmentToIdealState(HelixManager helixManager, final String tableNameWithType,
      final String segmentName, final List&lt;String&gt; assignedInstances) {

<span class="nc" id="L363">    Function&lt;IdealState, IdealState&gt; updater = new Function&lt;IdealState, IdealState&gt;() {</span>
      @Override
      public IdealState apply(IdealState idealState) {
<span class="nc" id="L366">        Set&lt;String&gt; partitions = idealState.getPartitionSet();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (partitions.contains(segmentName)) {</span>
<span class="nc" id="L368">          LOGGER.warn(&quot;Segment already exists in the ideal state for segment: {} of table: {}, do not update&quot;,</span>
              segmentName, tableNameWithType);
        } else {
<span class="nc bnc" id="L371" title="All 2 branches missed.">          if (assignedInstances.isEmpty()) {</span>
<span class="nc" id="L372">            LOGGER.warn(&quot;No instance assigned for segment: {} of table: {}&quot;, segmentName, tableNameWithType);</span>
          } else {
<span class="nc" id="L374">            int numPartitions = partitions.size() + 1;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            for (String instance : assignedInstances) {</span>
<span class="nc" id="L376">              idealState.setPartitionState(segmentName, instance, ONLINE);</span>
<span class="nc" id="L377">            }</span>
<span class="nc" id="L378">            idealState.setNumPartitions(numPartitions);</span>
          }
        }
<span class="nc" id="L381">        return idealState;</span>
      }
    };

<span class="nc" id="L385">    updateIdealState(helixManager, tableNameWithType, updater, DEFAULT_RETRY_POLICY);</span>
<span class="nc" id="L386">  }</span>

  public static List&lt;String&gt; getEnabledInstancesWithTag(HelixAdmin helixAdmin, String helixClusterName,
      String instanceTag) {
<span class="nc" id="L390">    List&lt;String&gt; instances = helixAdmin.getInstancesInCluster(helixClusterName);</span>
<span class="nc" id="L391">    List&lt;String&gt; enabledInstances = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">    for (String instance : instances) {</span>
      try {
<span class="nc" id="L394">        InstanceConfig instanceConfig = helixAdmin.getInstanceConfig(helixClusterName, instance);</span>
<span class="nc bnc" id="L395" title="All 4 branches missed.">        if (instanceConfig.containsTag(instanceTag) &amp;&amp; instanceConfig.getInstanceEnabled()) {</span>
<span class="nc" id="L396">          enabledInstances.add(instance);</span>
        }
<span class="nc" id="L398">      } catch (Exception e) {</span>
<span class="nc" id="L399">        LOGGER.error(&quot;Caught exception while fetching instance config for instance: {}&quot;, instance, e);</span>
<span class="nc" id="L400">      }</span>
<span class="nc" id="L401">    }</span>
<span class="nc" id="L402">    return enabledInstances;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>