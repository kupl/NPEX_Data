{
    "cxf-dosgi_3e12204": {
        "bug_id": "cxf-dosgi_3e12204",
        "commit": "https://github.com/apache/cxf-dosgi/commit/3e12204f80e667c85bb56837232a1559345db1a3",
        "file": [
            {
                "additions": 101,
                "blob_url": "https://github.com/apache/cxf-dosgi/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java",
                "changes": 188,
                "contents_url": "https://api.github.com/repos/apache/cxf-dosgi/contents/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java?ref=3e12204f80e667c85bb56837232a1559345db1a3",
                "deletions": 87,
                "filename": "dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java",
                "patch": "@@ -18,6 +18,7 @@\n  */\n package org.apache.cxf.dosgi.topologymanager;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Dictionary;\n@@ -131,15 +132,9 @@ protected void removeRemoteServiceAdmin(RemoteServiceAdmin rsa) {\n                     Collection<ExportRegistration> endpoints = exports.getValue().get(rsa);\n                     // TODO for each notify discovery......\n \n-                    try {\n-                        ServiceReference[] refs = Utils.getEndpointListeners(bctx);\n-                        if (refs != null) {\n-                            for (ServiceReference sref : refs) {\n-                                notifyListenersOfRemovalIfAppropriate(sref, endpoints);\n-                            }\n-                        }\n-                    } catch (InvalidSyntaxException e) {\n-                        LOG.log(Level.SEVERE, e.getMessage(), e);\n+                    ServiceReference[] refs = getEndpointListeners(bctx);\n+                    for (ServiceReference sref : refs) {\n+                        notifyListenersOfRemovalIfAppropriate(sref, endpoints);\n                     }\n \n                     // remove all management information for the RemoteServiceAdmin\n@@ -227,14 +222,12 @@ protected void exportService(ServiceReference sref) {\n                                  new LinkedHashMap<RemoteServiceAdmin, Collection<ExportRegistration>>());\n         }\n \n-        // trigger the export\n         triggerExport(sref);\n \n     }\n \n     private void triggerExport(final ServiceReference sref) {\n         execService.execute(new Runnable() {\n-            @SuppressWarnings(\"unchecked\")\n             public void run() {\n                 LOG.finer(\"TopologyManager: exporting service ...\");\n \n@@ -273,8 +266,7 @@ public void run() {\n                                     // enqueue in local list of endpoints\n                                     exports.put(remoteServiceAdmin, endpoints);\n \n-                                    // publish to endpoint listeners\n-                                    nofifyListeners(endpoints);\n+                                    nofifyEndpointListenersOfAdding(endpoints);\n                                 }\n                             }\n                         }\n@@ -285,21 +277,28 @@ public void run() {\n         });\n     }\n \n-    protected void nofifyListeners(Collection<ExportRegistration> exportRegistrations) {\n-        try {\n-            // Find all EndpointListeners; They must have the Scope property otherwise they have to be ignored\n-            ServiceReference[] refs = Utils.getEndpointListeners(bctx);\n-\n-            if (refs != null) {\n-                for (ServiceReference sref : refs) {\n-                    notifyListenerOfAddingIfAppropriate(sref, exportRegistrations);\n-                }\n-            }\n+    protected void nofifyEndpointListenersOfAdding(Collection<ExportRegistration> exportRegistrations) {\n+        ServiceReference[] epListeners = getEndpointListeners(bctx);\n+        for (ServiceReference sref : epListeners) {\n+            notifyListenerOfAddingIfAppropriate(sref, exportRegistrations);\n+        }\n+    }\n \n+     /** \n+      * Find all EndpointListeners; They must have the Scope property otherwise they have to be ignored\n+      * @param bctx\n+      * @return\n+      * @throws InvalidSyntaxException\n+      */\n+    protected static ServiceReference[] getEndpointListeners(BundleContext bctx) {\n+        ServiceReference[] result = null;\n+        try {\n+            String filter = \"(\" + EndpointListener.ENDPOINT_LISTENER_SCOPE + \"=*)\";\n+            result = bctx.getServiceReferences(EndpointListener.class.getName(), filter);\n         } catch (InvalidSyntaxException e) {\n             LOG.log(Level.SEVERE, e.getMessage(), e);\n         }\n-\n+        return (result == null) ? new ServiceReference[]{} : result;\n     }\n \n     /**\n@@ -311,91 +310,84 @@ protected void nofifyListeners(Collection<ExportRegistration> exportRegistration\n     protected void notifyListenerOfAddingIfAppropriate(ServiceReference sref,\n                                                        Collection<ExportRegistration> exportRegistrations) {\n \n-        // if (sref.getBundle().equals(bctx.getBundle())) {\n-        // LOG\n-        // .info(\"TopologyManager: notifyListenerOfAddingIfAppropriate() called for own listener -> skipping \");\n-        // return;\n-        // }\n-\n         EndpointListener epl = (EndpointListener)bctx.getService(sref);\n-\n         LOG.finer(\"TopologyManager: notifyListenerOfAddingIfAppropriate() \");\n+        List<Filter> filters = getFiltersFromEndpointListenerScope(sref, bctx);\n \n-        try {\n-\n-            List<Filter> filters = Utils.normalizeScope(sref, bctx);\n-\n-            for (ExportRegistration exReg : exportRegistrations) {\n-\n-                // FIXME!!!!!!!!!!!!! There needs to be a better way ?!?!?!\n-                Map props = exReg.getExportReference().getExportedEndpoint().getProperties();\n-                Dictionary d = new Hashtable(props);\n-\n-                if (LOG.isLoggable(Level.FINE)) {\n-                    for (Filter filter : filters) {\n-                        LOG.fine(\"Matching: \" + filter + \"  against \" + d);\n-                    }\n-                }\n-\n-                for (Filter filter : filters) {\n-                    if (filter.match(d)) {\n-                        LOG.fine(\"Listener mached one of the Endpoints !!!!: \" + epl);\n-\n-                        epl.endpointAdded(exReg.getExportReference().getExportedEndpoint(), filter\n-                                .toString());\n-                    }\n-                }\n+        for (ExportRegistration exReg : exportRegistrations) {\n+            EndpointDescription endpoint = getExportedEndpoint(exReg);\n+            List<Filter> matchingFilters = getMatchingFilters(filters, endpoint);\n+            for (Filter filter : matchingFilters) {\n+                epl.endpointAdded(endpoint, filter.toString());\n             }\n-\n-        } catch (InvalidSyntaxException e) {\n-            LOG.log(Level.SEVERE, e.getMessage(), e);\n         }\n+\n     }\n \n     protected void notifyListenersOfRemovalIfAppropriate(ServiceReference sref,\n-                                                         Collection<ExportRegistration> exportRegistrations) {\n-\n-        EndpointListener epl = (EndpointListener)bctx.getService(sref);\n+            Collection<ExportRegistration> exportRegistrations) {\n \n+        EndpointListener epl = (EndpointListener) bctx.getService(sref);\n         LOG.finer(\"TopologyManager: notifyListenerOfREMOVALIfAppropriate() \");\n+        List<Filter> filters = getFiltersFromEndpointListenerScope(sref, bctx);\n \n-        List<Filter> filters;\n+        for (ExportRegistration exReg : exportRegistrations) {\n+            EndpointDescription endpoint = getExportedEndpoint(exReg);\n+            List<Filter> matchingFilters = getMatchingFilters(filters, endpoint);\n+            for (Filter filter : matchingFilters) {\n+                epl.endpointRemoved(endpoint, filter.toString());\n+            }\n+        }\n+    }\n+    \n+    static List<Filter> getFiltersFromEndpointListenerScope(ServiceReference sref,BundleContext bctx) {\n+        List<Filter> filters = new ArrayList<Filter>();\n         try {\n-            filters = Utils.normalizeScope(sref, bctx);\n-\n-            for (ExportRegistration exReg : exportRegistrations) {\n-\n-                // FIXME!!!!!!!!!!!!! There needs to be a better way ?!?!?!\n-            \tExportReference ref = exReg.getExportReference(); \n-            \tEndpointDescription endpoint = ref.getExportedEndpoint(); \n-                Map props = endpoint.getProperties();\n-                Dictionary d = new Hashtable(props);\n-\n-                if (LOG.isLoggable(Level.FINE)) {\n-                    for (Filter filter : filters) {\n-                        LOG.fine(\"Matching: \" + filter + \"  against \" + d);\n-                    }\n+            Object fo = sref.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE);\n+            if (fo instanceof String) {\n+                filters.add(bctx.createFilter((String) fo));\n+            } else if (fo instanceof String[]) {\n+                String[] foArray = (String[]) fo;\n+                for (String f : foArray) {\n+                    filters.add(bctx.createFilter(f));\n                 }\n-\n-                for (Filter filter : filters) {\n-                    if (filter.match(d)) {\n-                        LOG.fine(\"Listener matched one of the Endpoints !!!! --> calling removed() ...\");\n-\n-                        epl.endpointRemoved(exReg.getExportReference().getExportedEndpoint(), filter\n-                            .toString());\n+            } else if (fo instanceof Collection) {\n+                @SuppressWarnings(\"rawtypes\")\n+                Collection c = (Collection) fo;\n+                for (Object o : c) {\n+                    if (o instanceof String) {\n+                        filters.add(bctx.createFilter((String) o));\n+                    } else {\n+                        LOG.warning(\"Component of a filter is not a string -> skipped !\");\n                     }\n                 }\n             }\n         } catch (InvalidSyntaxException e) {\n             LOG.log(Level.SEVERE, e.getMessage(), e);\n         }\n+        return filters;\n+    }\n+\n+    private List<Filter> getMatchingFilters(List<Filter> filters,\n+            EndpointDescription endpoint) {\n+        List<Filter> matchingFilters = new ArrayList<Filter>();\n+        Dictionary<String, Object> d = getEndpointProperties(endpoint);\n \n+        for (Filter filter : filters) {\n+            if (LOG.isLoggable(Level.FINE)) {\n+                LOG.fine(\"Matching: \" + filter + \"  against \" + d);\n+            }\n+            if (filter.match(d)) {\n+                LOG.fine(\"Listener matched one of the Endpoints !!!! --> calling removed() ...\");\n+                matchingFilters.add(filter);\n+            }\n+        }\n+        return matchingFilters;\n     }\n \n     private void checkExistingServices() throws InvalidSyntaxException {\n-        ServiceReference[] references = bctx\n-            .getServiceReferences(null, \"(\" + RemoteConstants.SERVICE_EXPORTED_INTERFACES + \"=*)\");\n-        // + \"(\"+org.apache.cxf.dosgi.dsw.Constants.EXPORTED_INTERFACES_OLD + \"=*))\");\n+        String filter = \"(\" + RemoteConstants.SERVICE_EXPORTED_INTERFACES + \"=*)\";\n+        ServiceReference[] references = bctx.getServiceReferences(null, filter);\n \n         if (references != null) {\n             for (ServiceReference sref : references) {\n@@ -411,7 +403,6 @@ public void removeExportRegistration(ExportRegistration exportRegistration) {\n \n                 Map<RemoteServiceAdmin, Collection<ExportRegistration>> ex = exportedServices.get(sref);\n                 if (ex != null) {\n-                    EndpointDescription ep = exportRegistration.getExportReference().getExportedEndpoint();\n                     for (Map.Entry<RemoteServiceAdmin, Collection<ExportRegistration>> export : ex.entrySet()) {\n                         export.getValue().contains(exportRegistration);\n                     }\n@@ -432,4 +423,27 @@ public void removeExportReference(ExportReference anyObject) {\n         // LOG.severe(\"NOT implemented !!!\");\n     }\n \n+    /**\n+     * Retrieve exported Endpoint while handling null\n+     * @param exReg\n+     * @return exported Endpoint or null if not present\n+     */\n+    private EndpointDescription getExportedEndpoint(ExportRegistration exReg) {\n+        ExportReference ref = (exReg == null) ? null : exReg.getExportReference();\n+        return (ref == null) ? null : ref.getExportedEndpoint(); \n+    }\n+    \n+    /**\n+     * Retrieve endpoint properties as Dictionary\n+     * \n+     * @param ep\n+     * @return endpoint properties (will never return null) \n+     */\n+    private Dictionary<String, Object> getEndpointProperties(EndpointDescription ep) {\n+        if (ep == null || ep.getProperties() == null) {\n+            return new Hashtable<String, Object>();\n+        } else {\n+            return new Hashtable<String, Object>(ep.getProperties());\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/cxf-dosgi/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/TopologyManager.java",
                "sha": "1b3f7e683b892e36c6fe43ecfac1e9be19cc575b",
                "status": "modified"
            },
            {
                "additions": 0,
                "blob_url": "https://github.com/apache/cxf-dosgi/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java",
                "changes": 43,
                "contents_url": "https://api.github.com/repos/apache/cxf-dosgi/contents/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java?ref=3e12204f80e667c85bb56837232a1559345db1a3",
                "deletions": 43,
                "filename": "dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java",
                "patch": "@@ -18,57 +18,14 @@\n   */\n package org.apache.cxf.dosgi.topologymanager;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n import java.util.UUID;\n-import java.util.logging.Logger;\n \n import org.osgi.framework.BundleContext;\n-import org.osgi.framework.Filter;\n-import org.osgi.framework.InvalidSyntaxException;\n-import org.osgi.framework.ServiceReference;\n-import org.osgi.service.remoteserviceadmin.EndpointListener;\n import org.osgi.service.remoteserviceadmin.RemoteConstants;\n \n \n public class Utils {\n \n-    private static final Logger LOG = Logger.getLogger(Utils.class.getName());\n-    \n-    protected static ServiceReference[] getEndpointListeners(BundleContext bctx) throws InvalidSyntaxException {\n-        ServiceReference[] refs = bctx\n-            .getServiceReferences(EndpointListener.class.getName(),\n-                                  \"(\" + EndpointListener.ENDPOINT_LISTENER_SCOPE + \"=*)\");\n-        return refs;\n-    }\n-\n-    public static List<Filter> normalizeScope(ServiceReference sref,BundleContext bctx) throws InvalidSyntaxException {\n-        List<Filter> filters = new ArrayList<Filter>();\n-    \n-        Object fo = sref.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE);\n-        if (fo instanceof String) {\n-            filters.add(bctx.createFilter((String)fo));\n-        } else if (fo instanceof String[]) {\n-            String[] foArray = (String[])fo;\n-            for (String f : foArray) {\n-                filters.add(bctx.createFilter(f));\n-            }\n-        } else if (fo instanceof Collection) {\n-            Collection c = (Collection)fo;\n-            for (Object o : c) {\n-                if (o instanceof String) {\n-                    filters.add(bctx.createFilter((String)o));\n-                } else {\n-                    LOG.info(\"Component of a filter is not a string -> skipped !\");\n-                }\n-            }\n-        }\n-    \n-        return filters;\n-    }\n-\n-    \n     public static String getUUID(BundleContext bctx) {\n         synchronized (\"org.osgi.framework.uuid\") {\n             String uuid = bctx.getProperty(\"org.osgi.framework.uuid\");",
                "raw_url": "https://github.com/apache/cxf-dosgi/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/main/java/org/apache/cxf/dosgi/topologymanager/Utils.java",
                "sha": "a198580d8d404b3a4013b052a939d6d93bf5f8ee",
                "status": "modified"
            },
            {
                "additions": 101,
                "blob_url": "https://github.com/apache/cxf-dosgi/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java",
                "changes": 103,
                "contents_url": "https://api.github.com/repos/apache/cxf-dosgi/contents/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java?ref=3e12204f80e667c85bb56837232a1559345db1a3",
                "deletions": 2,
                "filename": "dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java",
                "patch": "@@ -18,7 +18,10 @@\n   */\n package org.apache.cxf.dosgi.topologymanager;\n \n+import static org.junit.Assert.assertEquals;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -56,12 +59,12 @@ public void testNotifyListenersOfRemovalIfAppropriate() throws InvalidSyntaxExce\n         ExportReference exRef2 = c.createMock(ExportReference.class);\n         \n         \n-        Map props = new HashMap();\n+        Map<String, Object> props = new HashMap<String, Object>();\n         String[] oc = new String[1];\n         oc[0] = \"myClass\";\n         props.put(\"objectClass\", oc);\n         \n-        Map props2 = new HashMap();\n+        Map<String, Object> props2 = new HashMap<String, Object>();\n         oc = new String[1];\n         oc[0] = \"notMyClass\";\n         props2.put(\"objectClass\", oc);\n@@ -106,4 +109,100 @@ public Filter answer() throws Throwable {\n \n     }\n \n+    @Test\n+    public void testNomalizeScopeForSingleString() {\n+\n+        try {\n+            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n+            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n+                .andReturn(\"Filterstring\");\n+\n+            Filter f = EasyMock.createNiceMock(Filter.class);\n+            \n+            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n+            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f);\n+\n+            EasyMock.replay(sr);\n+            EasyMock.replay(bc);\n+\n+            List<Filter> res = TopologyManager.getFiltersFromEndpointListenerScope(sr, bc);\n+\n+            assertEquals(1, res.size());\n+            assertEquals(f, res.get(0));\n+\n+            EasyMock.verify(sr);\n+            EasyMock.verify(bc);\n+        } catch (InvalidSyntaxException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    \n+    @Test\n+    public void testNomalizeScopeForStringArray() {\n+\n+        try {\n+            \n+            String[] filterStrings = {\"f1\",\"f2\",\"f3\"};\n+            \n+            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n+            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n+                .andReturn(filterStrings);\n+\n+            Filter f = EasyMock.createNiceMock(Filter.class);\n+            \n+            \n+            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n+            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(filterStrings.length);\n+\n+            EasyMock.replay(sr);\n+            EasyMock.replay(bc);\n+\n+            List<Filter> res = TopologyManager.getFiltersFromEndpointListenerScope(sr, bc);\n+\n+            assertEquals(filterStrings.length, res.size());\n+            assertEquals(f, res.get(0));\n+\n+            EasyMock.verify(sr);\n+            EasyMock.verify(bc);\n+        } catch (InvalidSyntaxException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    @Test\n+    public void testNomalizeScopeForCollection() {\n+\n+        try {\n+            \n+            \n+            Collection<String> collection = new ArrayList<String>();\n+            collection.add(\"f1\");\n+            collection.add(\"f2\");\n+            collection.add(\"f3\");\n+            \n+            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n+            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n+                .andReturn(collection);\n+\n+            Filter f = EasyMock.createNiceMock(Filter.class);\n+            \n+            \n+            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n+            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(collection.size());\n+\n+            EasyMock.replay(sr);\n+            EasyMock.replay(bc);\n+\n+            List<Filter> res = TopologyManager.getFiltersFromEndpointListenerScope(sr, bc);\n+\n+            assertEquals(collection.size(), res.size());\n+            assertEquals(f, res.get(0));\n+\n+            EasyMock.verify(sr);\n+            EasyMock.verify(bc);\n+        } catch (InvalidSyntaxException e) {\n+            e.printStackTrace();\n+        }\n+    }\n }",
                "raw_url": "https://github.com/apache/cxf-dosgi/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/TopologyManagerTest.java",
                "sha": "b232a52f2b61ddc695644786f73f5f8a8b339795",
                "status": "modified"
            },
            {
                "additions": 7,
                "blob_url": "https://github.com/apache/cxf-dosgi/blob/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java",
                "changes": 124,
                "contents_url": "https://api.github.com/repos/apache/cxf-dosgi/contents/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java?ref=3e12204f80e667c85bb56837232a1559345db1a3",
                "deletions": 117,
                "filename": "dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java",
                "patch": "@@ -18,130 +18,23 @@\n   */\n package org.apache.cxf.dosgi.topologymanager;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n import java.util.Dictionary;\n-import java.util.HashMap;\n import java.util.Hashtable;\n-import java.util.List;\n-import java.util.Map;\n-\n \n import org.easymock.classextension.EasyMock;\n+import org.junit.Test;\n import org.osgi.framework.BundleContext;\n import org.osgi.framework.Filter;\n import org.osgi.framework.FrameworkUtil;\n import org.osgi.framework.InvalidSyntaxException;\n-import org.osgi.framework.ServiceReference;\n-import org.osgi.service.remoteserviceadmin.EndpointListener;\n import org.osgi.service.remoteserviceadmin.RemoteConstants;\n \n-import org.junit.Test;\n-\n public class UtilsTest {\n-\n-    @Test\n-    public void testNomalizeScopeForSingleString() {\n-\n-        try {\n-            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n-            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n-                .andReturn(\"Filterstring\");\n-\n-            Filter f = EasyMock.createNiceMock(Filter.class);\n-            \n-            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n-            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f);\n-\n-            EasyMock.replay(sr);\n-            EasyMock.replay(bc);\n-\n-            List<Filter> res = Utils.normalizeScope(sr, bc);\n-\n-            assertEquals(1, res.size());\n-            assertEquals(f, res.get(0));\n-\n-            EasyMock.verify(sr);\n-            EasyMock.verify(bc);\n-        } catch (InvalidSyntaxException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n-    \n-    @Test\n-    public void testNomalizeScopeForStringArray() {\n-\n-        try {\n-            \n-            String[] filterStrings = {\"f1\",\"f2\",\"f3\"};\n-            \n-            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n-            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n-                .andReturn(filterStrings);\n-\n-            Filter f = EasyMock.createNiceMock(Filter.class);\n-            \n-            \n-            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n-            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(filterStrings.length);\n-\n-            EasyMock.replay(sr);\n-            EasyMock.replay(bc);\n-\n-            List<Filter> res = Utils.normalizeScope(sr, bc);\n-\n-            assertEquals(filterStrings.length, res.size());\n-            assertEquals(f, res.get(0));\n-\n-            EasyMock.verify(sr);\n-            EasyMock.verify(bc);\n-        } catch (InvalidSyntaxException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n-    \n-    \n-    @Test\n-    public void testNomalizeScopeForCollection() {\n-\n-        try {\n-            \n-            \n-            Collection<String> collection = new ArrayList<String>();\n-            collection.add(\"f1\");\n-            collection.add(\"f2\");\n-            collection.add(\"f3\");\n-            \n-            ServiceReference sr = EasyMock.createMock(ServiceReference.class);\n-            EasyMock.expect(sr.getProperty(EndpointListener.ENDPOINT_LISTENER_SCOPE))\n-                .andReturn(collection);\n-\n-            Filter f = EasyMock.createNiceMock(Filter.class);\n-            \n-            \n-            BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n-            EasyMock.expect(bc.createFilter((String)EasyMock.anyObject())).andReturn(f).times(collection.size());\n-\n-            EasyMock.replay(sr);\n-            EasyMock.replay(bc);\n-\n-            List<Filter> res = Utils.normalizeScope(sr, bc);\n-\n-            assertEquals(collection.size(), res.size());\n-            assertEquals(f, res.get(0));\n-\n-            EasyMock.verify(sr);\n-            EasyMock.verify(bc);\n-        } catch (InvalidSyntaxException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n     \n     @Test\n     public void testGetNewUUID(){\n@@ -155,9 +48,7 @@ public void testGetNewUUID(){\n         \n         EasyMock.verify(bc);\n     }\n-     \n-    \n-    \n+\n     @Test\n     public void testGetExistingUUID(){\n         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n@@ -170,7 +61,6 @@ public void testGetExistingUUID(){\n         EasyMock.verify(bc);\n     }\n \n-    \n     @Test\n     public void testUUIDFilterExtension() throws InvalidSyntaxException{\n         String filter = \"(a=b)\";\n@@ -184,7 +74,7 @@ public void testUUIDFilterExtension() throws InvalidSyntaxException{\n         \n         Filter f = FrameworkUtil.createFilter(filter);\n         \n-        Dictionary m = new Hashtable();\n+        Dictionary<String, String> m = new Hashtable<String, String>();\n         m.put(\"a\", \"b\");\n         \n         assertTrue(filter+\" filter must match as uuid is missing\",f.match(m));      ",
                "raw_url": "https://github.com/apache/cxf-dosgi/raw/3e12204f80e667c85bb56837232a1559345db1a3/dsw/cxf-topology-manager/src/test/java/org/apache/cxf/dosgi/topologymanager/UtilsTest.java",
                "sha": "c6baa8a1e764e5a9068bc92d176b6ab00327ece9",
                "status": "modified"
            }
        ],
        "message": "DOSGI-129 Fixing NPE, better handling of exceptions\n\ngit-svn-id: https://svn.apache.org/repos/asf/cxf/dosgi/trunk@1401715 13f79535-47bb-0310-9956-ffa450edef68",
        "parent": "https://github.com/apache/cxf-dosgi/commit/dd2409513c541273200b7f7814d9a1a71eda5846",
        "patched_files": [
            "Utils.java",
            "TopologyManager.java"
        ],
        "repo": "cxf-dosgi",
        "unit_tests": [
            "TopologyManagerTest.java",
            "UtilsTest.java"
        ]
    }
}